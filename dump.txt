Dump created: 2025-08-22 12:29:42
Repository tree:
Scalp/
    CHANGELOG.md
    Makefile
    PROMPT.md
    README.md
    STRATEGY.md
    bitget_futures_pairs.py
    bot.py
    cli.py
    dump_repo.py
    init.py
    pytest.ini
    quick_order.py
    requirements-dev.txt
    requirements.txt
    short_one_way.py
    tests/
        conftest.py
        test_analyse_risque.py
        test_backtest.py
        test_backtest_multi.py
        test_backtest_position.py
        test_bitget_futures_pairs.py
        test_bot_place_order_caps.py
        test_bot_update.py
        test_break_even_stop.py
        test_calc_pnl_pct.py
        test_check_config.py
        test_cli.py
        test_client.py
        test_compute_position_size.py
        test_compute_position_size_cap.py
        test_dynamic_allocation.py
        test_effective_leverage.py
        test_env_loading.py
        test_grid_search.py
        test_heat_score.py
        test_indicators.py
        test_min_qty_rules.py
        test_notifier.py
        test_notional_and_pnl_units.py
        test_pair_selection.py
        test_pairs.py
        test_risk_manager.py
        test_risk_utils.py
        test_signal_risk.py
        test_slippage.py
        test_strategy_v2.py
        test_telegram_bot.py
        test_utils.py
        test_version.py
        test_walk_forward.py
        test_ws.py
    scalp/
        VERSION
        __init__.py
        bitget_client.py
        bot_config.py
        client.py
        config.py
        logging_utils.py
        metrics.py
        notifier.py
        pairs.py
        strategy.py
        telegram_bot.py
        trade_utils.py
        version.py
        ws.py
        services/
            __init__.py
            order_service.py
        adapters/
            __init__.py
            bitget.py
        selection/
            __init__.py
            momentum.py
            scanner.py
        risk/
            __init__.py
            manager.py
        backtest/
            __init__.py
            walkforward.py
    data/
        __init__.py
        indicators.py
    live/
        __init__.py
        orchestrator.py
    result/
    signals/
        __init__.py
        generator.py
    backtest/
        __init__.py
        engine.py
        grid_search.py
        optimize.py
        run_multi.py
    notebooks/
        spot/
            bitget_bot.py

## CHANGELOG.md (last modified: 2025-08-22 07:05:27)
# Changelog

## Unreleased

- Trigger trade entries via `strategy.generate_signal` with weighted scoring and
  signal levels.
- Dynamic risk management adapting `risk_pct` and leverage based on signal and
  user risk level.
- Notional and margin caps with available balance check to avoid Bitget error
  `40762`.
- Risk notifications with green/yellow/red indicators for terminal and
  Telegram.


## Makefile (last modified: 2025-08-22 07:05:27)
.PHONY: test

test:
	pytest


## PROMPT.md (last modified: 2025-08-22 07:05:27)
# Prompt de re-création du bot Scalp (version spot)

Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.

## Structure principale

### bot.py
- `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
- `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
- `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
- `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
- `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
- `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
- `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.

### cli.py
- `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
- `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
- `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
- `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
- `main(argv=None)` : point d'entrée qui déclenche la commande choisie.

### init.py
- `install_packages(*args)` : installe des paquets via `pip`.
- `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.

## Modules `scalp`

### bot_config.py
- `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).

### metrics.py
- `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
- `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
- `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
- `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
- `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.

### strategy.py
- `ema(series, window)` : moyenne mobile exponentielle.
- `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
- `obv(closes, volumes)` : série On Balance Volume.
- `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
- `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
- `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
- `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
- `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
- `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.

### trade_utils.py
- `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
- `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
- `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
- `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
- `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
- `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
- `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.

### risk
- `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
- `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
- `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
- `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
  - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.

### notifier.py
- `_pair_name(symbol)` : formatte le nom d’une paire.
- `_format_text(event, payload=None)` : construit un message lisible.
- `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.

### logging_utils.py
- `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
- `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).

### bitget_client.py
- `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
  - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
  - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
  - `get_account()`, `get_open_orders(symbol=None)`.
  - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
  - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.

### pairs.py
- `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
- `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
- `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
- `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
- `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
- `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
- `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
- `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.

### telegram_bot.py
- `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
  - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
  - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
  - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
- `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.

## Utilisation
1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
2. Exécuter `init.py` pour installer les dépendances.
3. Lancer `bot.py` pour démarrer le trading.
4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.

Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.



## README.md (last modified: 2025-08-22 07:05:27)
# Scalp

Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.

## Installation

Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :

```bash
pip install -r requirements.txt
```

Pour développer ou exécuter les tests :

```bash
pip install -r requirements-dev.txt
pytest  # ou make test
```

## Configuration

Le bot lit sa configuration via des variables d'environnement :

- `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
- `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
- `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
- `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
- `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
- `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
- `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
- `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
- `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
- `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
- `LOG_DIR` : dossier où seront écrits les fichiers de log.
- `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.

- `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
- `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).

Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
`.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
au démarrage et toutes les variables qu'il contient seront disponibles pour le
bot.


Exemple :

```bash
export BITGET_ACCESS_KEY="votre_cle"
export BITGET_SECRET_KEY="votre_secret"
export PAPER_TRADE=true
python bot.py
```

## Lancement

Après configuration, lancez simplement :

```bash
python bot.py
```

Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.

Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.

Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.


## Stratégie

Scalp cherche à capter de courts mouvements de tendance tout en coupant
rapidement les pertes.

Principes généraux :

- sélection de paires liquides au fort momentum ;
- trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
- confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
- stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
  calculée selon le risque ;
- limites quotidiennes pour protéger le capital.

Les règles détaillées et l’algorithme complet sont décrits dans
`STRATEGY.md`.

## Version

La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
le code via la variable `scalp.__version__` :

```python
from scalp import __version__
print(__version__)
```

Pour incrémenter la version, utilisez `scalp.version.bump_version` avec

`"major"`, `"minor"` ou `"patch"` comme argument. La fonction
`scalp.version.bump_version_from_message` permet également de déterminer
automatiquement l'incrément à appliquer à partir d'un message de commit
suivant la convention [Conventional Commits](https://www.conventionalcommits.org).

Exemple d'incrément basé sur un message :

```python
from scalp.version import bump_version_from_message
bump_version_from_message("feat: add new strategy")
```

Exécuté en tant que script, `python -m scalp.version` lit le dernier
message de commit `git` et met à jour le fichier `VERSION` en
conséquence.

La même opération peut être déclenchée depuis la ligne de commande via
`cli.py` :

```bash
python cli.py bump-version
```


## Changelog

- Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).

## Avertissement

© 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.


## STRATEGY.md (last modified: 2025-08-22 07:05:27)
# Stratégie de trading

Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.

## Principes généraux

- ne traiter que des actifs liquides à fort momentum ;
- suivre la tendance dominante et éviter les marchés plats ;
- utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
- dimensionner chaque position selon un pourcentage fixe du capital ;
- couper rapidement les pertes et laisser courir les gains via un suivi dynamique.

## Sélection des paires

1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
   - croisement entre EMA20 et EMA50 ;
   - ATR élevé pour privilégier les actifs volatils.

## Génération du signal

`generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :

- prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
- **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
- **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
- hausse d’**OBV** ou volume supérieur à la moyenne ;
- cassure du dernier **swing high/low** ;
- éventuel filtre d’**order book imbalance** et de ratio de ticks.

Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.

## Gestion du risque

La classe `RiskManager` applique plusieurs garde‑fous :

- limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
- suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
- pause forcée en cas de pertes consécutives prolongées ;
- contrôle du nombre maximal de positions ouvertes.

Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.


## backtest/__init__.py (last modified: 2025-08-22 07:05:27)
"""Backtesting helpers and optimisation utilities."""

from .optimize import (
    param_space_default,
    eval_params_one,
    run_param_sweep,
    optimize,
)

__all__ = [
    "param_space_default",
    "eval_params_one",
    "run_param_sweep",
    "optimize",
]


## backtest/engine.py (last modified: 2025-08-22 12:29:12)
"""Simple backtest engine with dynamic risk and trailing stops.

This module provides two helpers:
- the original :class:`BacktestEngine` for individual trades,
- :func:`backtest_symbol` used by the multi pair backtester.  The latter
  intentionally relies only on the Python standard library so it can run in
  restricted environments.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Sequence, Tuple
import math
import random

from scalp.metrics import calc_pnl_pct
from scalp.risk import adjust_risk_pct
from scalp.strategy import generate_signal

__all__ = [
    "dynamic_risk_pct",
    "apply_trailing",
    "BacktestEngine",
    "run_backtest",
    "backtest_symbol",
]


# ---------------------------------------------------------------------------
# Simple trade engine used by existing tests
# ---------------------------------------------------------------------------


def dynamic_risk_pct(risk_pct: float, win_streak: int, loss_streak: int) -> float:
    """Return a risk percentage adjusted by recent performance."""

    return adjust_risk_pct(risk_pct, win_streak, loss_streak)


def apply_trailing(
    side: str,
    high: float,
    low: float,
    exit_price: float,
    trail_pct: float,
) -> float:
    """Apply a trailing stop to an exit price."""

    if trail_pct <= 0:
        return exit_price

    side = side.lower()
    if side == "long":
        trail_stop = high * (1 - trail_pct)
        return trail_stop if exit_price > trail_stop else exit_price
    if side == "short":
        trail_stop = low * (1 + trail_pct)
        return trail_stop if exit_price < trail_stop else exit_price
    raise ValueError("side must be 'long' or 'short'")


@dataclass
class BacktestEngine:
    """Iterate over trades applying dynamic risk and trailing stops."""

    risk_pct: float = 0.01
    log: List[Dict[str, Any]] = field(default_factory=list, init=False)
    _win_streak: int = field(default=0, init=False)
    _loss_streak: int = field(default=0, init=False)

    def _process_trade(self, trade: Dict[str, Any]) -> Dict[str, Any]:
        self.risk_pct = dynamic_risk_pct(self.risk_pct, self._win_streak, self._loss_streak)

        entry = float(trade["entry"])
        exit_price = float(trade["exit"])
        side = int(trade.get("side", 1))

        exit_price = apply_trailing(
            "long" if side == 1 else "short",
            float(trade.get("high", exit_price)),
            float(trade.get("low", exit_price)),
            exit_price,
            float(trade.get("trail_pct", 0.0)),
        )

        pnl_pct = calc_pnl_pct(entry, exit_price, side, trade.get("fee_rate", 0.0))
        if pnl_pct >= 0:
            self._win_streak += 1
            self._loss_streak = 0
        else:
            self._loss_streak += 1
            self._win_streak = 0

        record = {
            "entry": entry,
            "exit": exit_price,
            "side": side,
            "pnl_pct": pnl_pct,
            "risk_pct": self.risk_pct,
            "score": trade.get("score"),
            "reasons": trade.get("reasons"),
            "quality": trade.get("quality"),
        }
        self.log.append(record)
        return record

    def run(self, trades: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
        self.log.clear()
        self._win_streak = 0
        self._loss_streak = 0
        for tr in trades:
            self._process_trade(tr)
        return self.log


def run_backtest(
    trades: Sequence[Dict[str, Any]], *, risk_pct: float = 0.01
) -> List[Dict[str, Any]]:
    engine = BacktestEngine(risk_pct=risk_pct)
    return engine.run(trades)


# ---------------------------------------------------------------------------
# Backtest helper for the multi pair runner
# ---------------------------------------------------------------------------


def _apply_slippage(price: float, side: int, bps: float, *, is_entry: bool) -> float:
    slip = bps / 10000.0
    if side == 1:
        return price * (1 + slip) if is_entry else price * (1 - slip)
    return price * (1 - slip) if is_entry else price * (1 + slip)


def backtest_symbol(
    data: List[Dict[str, Any]],
    symbol: str,
    *,
    fee_rate: float = 0.0,
    slippage_bps: float = 0.0,
    risk_pct: float = 0.01,
    initial_equity: float = 1000.0,
    leverage: float = 1.0,
    paper_constraints: bool = True,
    seed: int | None = None,
) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    """Replay a strategy on ``data`` for a single symbol.

    ``data`` is a list of dictionaries containing ``timestamp`` (as a
    ``datetime``), ``open``, ``high``, ``low``, ``close`` and ``volume``.
    The function returns a list of trades and the resulting equity curve.
    """

    if seed is not None:
        random.seed(seed)

    MIN_VOL = 0.001
    VOL_UNIT = 0.0001
    MIN_TRADE_USDT = 5.0

    equity = float(initial_equity)
    trades: List[Dict[str, Any]] = []
    equity_curve: List[Dict[str, Any]] = []
    position: Dict[str, Any] | None = None

    for i, row in enumerate(data):
        price = float(row["close"])
        ts: datetime = row["timestamp"]

        if position is not None:
            side = position["side"]
            exit_price = None
            reason = ""
            if side == 1:
                if row["low"] <= position["sl"]:
                    exit_price = position["sl"]
                    reason = "sl"
                elif row["high"] >= position["tp"]:
                    exit_price = position["tp"]
                    reason = "tp"
            else:
                if row["high"] >= position["sl"]:
                    exit_price = position["sl"]
                    reason = "sl"
                elif row["low"] <= position["tp"]:
                    exit_price = position["tp"]
                    reason = "tp"
            if exit_price is not None:
                exit_price = _apply_slippage(exit_price, -side, slippage_bps, is_entry=False)
                pnl_pct = calc_pnl_pct(position["entry"], exit_price, side, fee_rate)
                pnl_usdt = position["notional"] * (pnl_pct / 100.0)
                equity += pnl_usdt
                trades.append(
                    {
                        "entry_time": position["entry_time"],
                        "exit_time": ts,
                        "symbol": symbol,
                        "side": "long" if side == 1 else "short",
                        "entry": position["entry"],
                        "exit": exit_price,
                        "qty": position["qty"],
                        "pnl_pct": pnl_pct,
                        "pnl_usdt": pnl_usdt,
                        "fee_pct": fee_rate * 2 * 100.0,
                        "slippage_bps": slippage_bps,
                        "reason": reason,
                        "score": position.get("score"),
                        "notional": position["notional"],
                        "holding_s": (ts - position["entry_time"]).total_seconds(),
                    }
                )
                equity_curve.append({"timestamp": ts, "equity": equity})
                position = None
                continue

        ohlcv = {
            "open": [r["open"] for r in data[: i + 1]],
            "high": [r["high"] for r in data[: i + 1]],
            "low": [r["low"] for r in data[: i + 1]],
            "close": [r["close"] for r in data[: i + 1]],
            "volume": [r["volume"] for r in data[: i + 1]],
        }
        sig = generate_signal(symbol, ohlcv, equity=equity, risk_pct=risk_pct)
        if sig is None or position is not None:
            continue
        side = 1 if sig.side == "long" else -1
        entry = _apply_slippage(price, side, slippage_bps, is_entry=True)
        sl = float(sig.sl)
        tp = float(sig.tp1 or sig.tp2 or price)
        qty = float(getattr(sig, "qty", 0) or 0)
        if qty <= 0:
            dist = abs(entry - sl)
            qty = (equity * risk_pct) / dist if dist else 0.0
        if paper_constraints:
            if qty < MIN_VOL:
                qty = MIN_VOL
            qty = math.floor(qty / VOL_UNIT) * VOL_UNIT
            if qty * entry < MIN_TRADE_USDT:
                continue
        notional = qty * entry * leverage
        position = {
            "side": side,
            "entry": entry,
            "sl": sl,
            "tp": tp,
            "qty": qty,
            "entry_time": ts,
            "notional": notional,
            "score": getattr(sig, "score", None),
        }

    if position is not None:
        final_price = float(data[-1]["close"])
        ts = data[-1]["timestamp"]
        exit_price = _apply_slippage(final_price, -position["side"], slippage_bps, is_entry=False)
        pnl_pct = calc_pnl_pct(position["entry"], exit_price, position["side"], fee_rate)
        pnl_usdt = position["notional"] * (pnl_pct / 100.0)
        equity += pnl_usdt
        trades.append(
            {
                "entry_time": position["entry_time"],
                "exit_time": ts,
                "symbol": symbol,
                "side": "long" if position["side"] == 1 else "short",
                "entry": position["entry"],
                "exit": exit_price,
                "qty": position["qty"],
                "pnl_pct": pnl_pct,
                "pnl_usdt": pnl_usdt,
                "fee_pct": fee_rate * 2 * 100.0,
                "slippage_bps": slippage_bps,
                "reason": "close",
                "score": position.get("score"),
                "notional": position["notional"],
                "holding_s": (ts - position["entry_time"]).total_seconds(),
            }
        )
        equity_curve.append({"timestamp": ts, "equity": equity})

    return trades, equity_curve


## backtest/grid_search.py (last modified: 2025-08-22 12:29:12)
"""Grid-search express module to evaluate hyperparameter combinations.

This module builds combinations of strategy and engine parameters, runs the
existing multi symbol backtester for each combination, collects key metrics and
selects the best configuration according to:

1. Profit factor (descending)
2. Maximum drawdown percentage (ascending)
3. Net PnL in USDT (descending)
4. Number of trades (ascending)

Results are written under ``result/grid`` by default and a short summary is
printed to the console.
"""
from __future__ import annotations

from dataclasses import dataclass
import csv
import json
import os
import random
from itertools import product
from typing import Any, Callable, Dict, Iterable, List, Sequence

# ---------------------------------------------------------------------------
# Utilities
# ---------------------------------------------------------------------------


def parse_hours(hours: str) -> List[int]:
    """Parse hours specification like ``"7-11,13-17"`` into a list of ints.

    Each comma separated element can either be a single hour (``"8"``) or a
    range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
    """

    if not hours:
        return []
    result: List[int] = []
    for part in hours.split(","):
        part = part.strip()
        if not part:
            continue
        if "-" in part:
            start_s, end_s = part.split("-", 1)
            start, end = int(start_s), int(end_s)
            result.extend(range(start, end + 1))
        else:
            result.append(int(part))
    return sorted(set(result))


# Order of parameters used throughout the module and in CSV output
PARAM_KEYS = [
    "timeframe",
    "score_min",
    "atr_min_ratio",
    "rr_min",
    "risk_pct",
    "slippage_bps",
    "fee_rate",
    "cooldown_secs",
    "hours",
]

# Default values used if a parameter is not provided in the grid
DEFAULTS = {
    "score_min": 55,
    "atr_min_ratio": 0.002,
    "rr_min": 1.2,
    "risk_pct": 0.01,
    "slippage_bps": 2,
    "fee_rate": 0.001,
    "cooldown_secs": 300,
    "hours": "7-11,13-17",
}


@dataclass
class GridResult:
    params: Dict[str, Any]
    metrics: Dict[str, float]


def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
    if isinstance(val, (list, tuple, set)):
        return list(val)
    return [val]


def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
    """Return a list of parameter combinations.

    ``param_lists`` maps parameter names to a sequence of values.  Missing keys
    fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
    sampled to ``grid_max`` elements when necessary while trying to maintain a
    variety of timeframes and ``atr_min_ratio`` values.
    """

    lists: Dict[str, List[Any]] = {}
    for key in PARAM_KEYS:
        if key == "timeframe":
            # timeframe must be explicitly provided; default empty -> "1m"
            vals = param_lists.get(key) or ["1m"]
        else:
            vals = param_lists.get(key)
            if not vals:
                default = DEFAULTS[key]
                vals = [default]
        lists[key] = _ensure_list(vals)

    combos: List[Dict[str, Any]] = [
        dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
    ]

    # Uniform sampling if exceeding grid_max
    if len(combos) > grid_max:
        step = len(combos) / float(grid_max)
        sampled = []
        for i in range(grid_max):
            idx = int(round(i * step))
            if idx >= len(combos):
                idx = len(combos) - 1
            sampled.append(combos[idx])
        # ensure each timeframe appears at least once
        wanted_tfs = set(lists["timeframe"])
        present_tfs = {c["timeframe"] for c in sampled}
        missing = list(wanted_tfs - present_tfs)
        if missing:
            for tf in missing:
                for c in combos:
                    if c["timeframe"] == tf and c not in sampled:
                        sampled.append(c)
                        break
            sampled = sampled[:grid_max]
        combos = sampled
    return combos


# ---------------------------------------------------------------------------
# Core runner
# ---------------------------------------------------------------------------


def run_grid_search(
    *,
    symbols: Sequence[str],
    exchange: str,
    base_params: Dict[str, Any],
    param_lists: Dict[str, Sequence[Any]],
    grid_max: int = 12,
    csv_dir: str | None = None,
    initial_equity: float = 1000.0,
    leverage: float = 1.0,
    paper_constraints: bool = True,
    seed: int | None = None,
    out_dir: str = "./result/grid",
    match_exchange_semantics: bool = False,  # placeholder for compatibility
    run_func: Callable[..., Any] | None = None,
) -> List[GridResult]:
    """Execute grid search across parameter combinations.

    ``base_params`` provides default single values for parameters. ``param_lists``
    contains the grid specifications from CLI (already parsed into sequences).
    ``run_func`` should have the same signature as :func:`run_backtest_multi`.
    """

    if seed is not None:
        random.seed(seed)

    if run_func is None:  # avoid circular import at module load
        from .run_multi import run_backtest_multi  # late import

        run_func = run_backtest_multi

    # merge lists with defaults
    full_lists: Dict[str, Sequence[Any]] = {}
    for k in PARAM_KEYS:
        if k == "timeframe":
            full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
        else:
            if param_lists.get(k) is not None:
                full_lists[k] = param_lists[k]
            else:
                full_lists[k] = [base_params.get(k, DEFAULTS[k])]

    combos = build_param_grid(full_lists, grid_max)

    results: List[GridResult] = []
    os.makedirs(out_dir, exist_ok=True)

    for combo in combos:
        # Build parameters for backtester
        tf = combo["timeframe"]
        fee = float(combo["fee_rate"])
        slip = float(combo["slippage_bps"])
        risk = float(combo["risk_pct"])

        summary, _trades = run_func(
            symbols=list(symbols),
            exchange=exchange,
            timeframe=tf,
            csv_dir=csv_dir,
            fee_rate=fee,
            slippage_bps=slip,
            risk_pct=risk,
            initial_equity=initial_equity,
            leverage=leverage,
            paper_constraints=paper_constraints,
            seed=seed,
            out_dir=os.path.join(out_dir, "tmp"),
            plot=False,
            dry_run=True,
        )
        total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
        metrics = {
            "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
            "profit_factor": float(total.get("profit_factor", 0.0)),
            "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
            "winrate_pct": float(total.get("winrate_pct", 0.0)),
            "trades": float(total.get("trades", 0.0)),
            "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
        }
        results.append(GridResult(params=combo, metrics=metrics))

    # sort results
    results.sort(
        key=lambda r: (
            -r.metrics["profit_factor"],
            r.metrics["max_dd_pct"],
            -r.metrics["pnl_usdt"],
            r.metrics["trades"],
        )
    )

    # console output -------------------------------------------------------
    print(
        f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
    )
    header = (
        f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
    )
    print(header)
    for r in results[:10]:
        m = r.metrics
        print(
            f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
        )

    # write csv ------------------------------------------------------------
    csv_cols = PARAM_KEYS + [
        "pnl_usdt",
        "profit_factor",
        "max_dd_pct",
        "winrate_pct",
        "trades",
        "final_equity",
    ]
    with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
        writer = csv.DictWriter(fh, fieldnames=csv_cols)
        writer.writeheader()
        for r in results:
            row = {**r.params, **r.metrics}
            writer.writerow(row)

    best = results[0]
    with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
        json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)

    # markdown summary -----------------------------------------------------
    md_path = os.path.join(out_dir, "grid_summary.md")
    with open(md_path, "w", encoding="utf8") as fh:
        fh.write(
            "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
        )
        for r in results[:10]:
            m = r.metrics
            fh.write(
                f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
            )

    # optional scatter plot ------------------------------------------------
    try:  # pragma: no cover - optional dependency
        import matplotlib.pyplot as plt

        pf = [r.metrics["profit_factor"] for r in results]
        dd = [r.metrics["max_dd_pct"] for r in results]
        trades = [r.metrics["trades"] for r in results]
        tfs = [r.params["timeframe"] for r in results]
        colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
        c = [colors[tf] for tf in tfs]
        plt.figure(figsize=(6, 4))
        plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
        plt.xlabel("MaxDD%")
        plt.ylabel("Profit Factor")
        plt.title("PF vs MaxDD")
        plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
        plt.close()
    except Exception:  # pragma: no cover
        pass

    return results


__all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]


## backtest/optimize.py (last modified: 2025-08-22 07:05:27)
from __future__ import annotations

"""Parameter sweep utilities for strategy optimisation.

This module performs a grid search over a parameter space in parallel.  It
tries to use :mod:`ray` for distributed execution when available and falls
back to :mod:`multiprocessing` otherwise.
"""

import itertools
import json
import multiprocessing as mp
import os
from typing import Any, Dict, Iterable, List, Sequence

try:  # Optional dependency
    import ray  # type: ignore
except Exception:  # pragma: no cover - ray is optional
    ray = None

from scalp.backtest import backtest_trades


# ---------------------------------------------------------------------------
# Parameter space
# ---------------------------------------------------------------------------

def param_space_default() -> Dict[str, Sequence[Any]]:
    """Return the default parameter search space.

    The keys correspond to strategy parameters while the values are iterables
    of possible settings.  The defaults represent a small but representative
    grid and can be overridden by callers.
    """

    return {
        "ema_fast": [10, 20, 30],
        "ema_slow": [50, 100, 200],
        "rsi_period": [14, 21],
        "atr_period": [14, 21],
    }


def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    """Expand *space* into a list of parameter combinations."""

    keys = list(space)
    values = [space[k] for k in keys]
    return [dict(zip(keys, combo)) for combo in itertools.product(*values)]


# ---------------------------------------------------------------------------
# Evaluation
# ---------------------------------------------------------------------------

def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    """Run a backtest for a single parameter combination.

    ``grid_item`` contains the parameter values along with optional ``trades``
    to evaluate.  The function returns a copy of the parameters augmented with
    the computed PnL under the key ``pnl``.
    """

    params = dict(grid_item)
    trades = params.pop("trades", [])
    fee_rate = params.pop("fee_rate", None)
    pnl = backtest_trades(trades, fee_rate=fee_rate)
    params["pnl"] = pnl
    return params


# ---------------------------------------------------------------------------
# Orchestration
# ---------------------------------------------------------------------------

def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    """Evaluate the full parameter grid in parallel and return results."""

    space = space or param_space_default()
    grid = _param_grid(space)

    # Determine execution backend
    use_ray = False
    if ray is not None:
        try:  # pragma: no cover - depends on ray
            ray.init(ignore_reinit_error=True)
            use_ray = True
        except Exception:
            use_ray = False

    if use_ray:
        remote_eval = ray.remote(eval_params_one)  # type: ignore
        futures = [remote_eval.remote(g) for g in grid]
        results = ray.get(futures)
    else:
        jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
        with mp.Pool(processes=jobs) as pool:
            results = pool.map(eval_params_one, grid)

    return results


def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
    """High level helper executing the sweep and saving aggregated results."""

    results = run_param_sweep(space, jobs=jobs)
    with open(outfile, "w", encoding="utf8") as fh:
        json.dump(results, fh, indent=2, sort_keys=True)
    return results


def main() -> None:  # pragma: no cover - convenience CLI
    optimize()


if __name__ == "__main__":  # pragma: no cover
    main()


## backtest/run_multi.py (last modified: 2025-08-22 12:29:12)
"""Run multi-symbol backtests from the command line.

Example:
    python backtest/run_multi.py --symbols "BTC/USDT,ETH/USDT" --exchange csv --csv-dir ./data
"""
import argparse
import csv
import json
import os
import random
import statistics
from datetime import datetime, timezone
from typing import Dict, List, Tuple

from .engine import backtest_symbol
from .grid_search import run_grid_search


def _load_csv(symbol: str, timeframe: str, csv_dir: str) -> List[Dict[str, object]]:
    sym = symbol.replace("/", "")
    patterns = [
        f"{sym}-{timeframe}.csv",
        f"{sym}_{timeframe}.csv",
        f"{symbol.replace('/', '_')}-{timeframe}.csv",
        f"{symbol.replace('/', '_')}_{timeframe}.csv",
    ]
    for pat in patterns:
        path = os.path.join(csv_dir, pat)
        if os.path.exists(path):
            rows: List[Dict[str, object]] = []
            with open(path, newline="", encoding="utf8") as fh:
                reader = csv.DictReader(fh)
                for r in reader:
                    ts = datetime.fromtimestamp(float(r["timestamp"]) / 1000.0, tz=timezone.utc)
                    rows.append(
                        {
                            "timestamp": ts,
                            "open": float(r["open"]),
                            "high": float(r["high"]),
                            "low": float(r["low"]),
                            "close": float(r["close"]),
                            "volume": float(r["volume"]),
                        }
                    )
            return rows
    raise FileNotFoundError(f"CSV for {symbol} not found in {csv_dir}")


def load_data(symbols: List[str], exchange: str, timeframe: str, csv_dir: str | None) -> Dict[str, List[Dict[str, object]]]:
    data: Dict[str, List[Dict[str, object]]] = {}
    for sym in symbols:
        if exchange != "csv":
            raise ValueError("Only csv exchange supported in test environment")
        if not csv_dir:
            raise ValueError("csv_dir required")
        data[sym] = _load_csv(sym, timeframe, csv_dir)
    return data


def compute_metrics(trades: List[Dict[str, float]], equity_curve: List[Dict[str, float]], initial_equity: float) -> Dict[str, float]:
    trades_count = len(trades)
    pnl_usdt = sum(t["pnl_usdt"] for t in trades)
    pnl_pct = pnl_usdt / initial_equity * 100.0 if initial_equity else 0.0
    wins = [t for t in trades if t["pnl_usdt"] > 0]
    losses = [t for t in trades if t["pnl_usdt"] < 0]
    winrate = len(wins) / trades_count * 100.0 if trades_count else 0.0
    expectancy = statistics.mean([t["pnl_pct"] for t in trades]) if trades else 0.0
    profit_factor = sum(t["pnl_usdt"] for t in wins) / abs(sum(t["pnl_usdt"] for t in losses)) if losses else float("inf")
    peak = equity_curve[0]["equity"] if equity_curve else initial_equity
    max_dd = 0.0
    for p in equity_curve:
        if p["equity"] > peak:
            peak = p["equity"]
        dd = (peak - p["equity"]) / peak if peak else 0.0
        if dd > max_dd:
            max_dd = dd
    returns: List[float] = []
    prev = None
    for p in equity_curve:
        if prev is not None and prev > 0:
            returns.append((p["equity"] - prev) / prev)
        prev = p["equity"]
    sharpe = 0.0
    if returns:
        mean = statistics.mean(returns)
        std = statistics.pstdev(returns)
        if std:
            sharpe = mean / std * (len(returns) ** 0.5)
    avg_hold = statistics.mean([t["holding_s"] for t in trades]) if trades else 0.0
    turnover = sum(abs(t["notional"]) for t in trades) / initial_equity if trades else 0.0
    return {
        "trades": trades_count,
        "winrate_pct": winrate,
        "pnl_pct": pnl_pct,
        "pnl_usdt": pnl_usdt,
        "expectancy_pct": expectancy,
        "profit_factor": profit_factor,
        "max_drawdown_pct": max_dd * 100.0,
        "sharpe": sharpe,
        "avg_hold_s": avg_hold,
        "turnover": turnover,
    }


def run_backtest_multi(
    *,
    symbols: List[str],
    exchange: str,
    timeframe: str,
    csv_dir: str | None = None,
    fee_rate: float = 0.0,
    slippage_bps: float = 0.0,
    risk_pct: float = 0.01,
    initial_equity: float = 1000.0,
    leverage: float = 1.0,
    paper_constraints: bool = True,
    seed: int | None = None,
    out_dir: str = "./result",
    plot: bool = False,
    dry_run: bool = False,
) -> Tuple[List[Dict[str, float]], List[Dict[str, float]]]:
    if seed is not None:
        random.seed(seed)
    data = load_data(symbols, exchange, timeframe, csv_dir)
    os.makedirs(out_dir, exist_ok=True)

    per_symbol_summary: List[Dict[str, float]] = []
    all_trades: List[Dict[str, float]] = []
    equity_maps: Dict[str, List[Dict[str, float]]] = {}
    init_per_symbol = initial_equity / len(symbols)

    for sym in symbols:
        trades, eq = backtest_symbol(
            data[sym],
            sym,
            fee_rate=fee_rate,
            slippage_bps=slippage_bps,
            risk_pct=risk_pct,
            initial_equity=init_per_symbol,
            leverage=leverage,
            paper_constraints=paper_constraints,
            seed=seed,
        )
        all_trades.extend(trades)
        equity_maps[sym] = eq
        met = compute_metrics(trades, eq, init_per_symbol)
        row = {"symbol": sym}
        row.update(met)
        per_symbol_summary.append(row)
        if not dry_run:
            with open(os.path.join(out_dir, f"equity_curve_{sym.replace('/', '_')}.csv"), "w", newline="") as fh:
                w = csv.writer(fh)
                w.writerow(["timestamp", "equity"])
                for e in eq:
                    w.writerow([e["timestamp"].isoformat(), f"{e['equity']:.6f}"])

    # total equity curve based on trade order
    eq_total: List[Dict[str, float]] = []
    eq = initial_equity
    for tr in sorted(all_trades, key=lambda x: x["exit_time"]):
        eq += tr["pnl_usdt"]
        eq_total.append({"timestamp": tr["exit_time"], "equity": eq})
    total_metrics = compute_metrics(all_trades, eq_total, initial_equity)
    total_row = {"symbol": "TOTAL", **total_metrics, "avg_corr": 0.0}
    summary = per_symbol_summary + [total_row]

    if not dry_run:
        # summary csv
        cols = [
            "symbol",
            "trades",
            "winrate_pct",
            "pnl_pct",
            "pnl_usdt",
            "expectancy_pct",
            "profit_factor",
            "max_drawdown_pct",
            "sharpe",
            "avg_hold_s",
            "turnover",
            "avg_corr",
        ]
        with open(os.path.join(out_dir, "report_summary.csv"), "w", newline="") as fh:
            w = csv.writer(fh)
            w.writerow(cols)
            for row in summary:
                w.writerow([row.get(c, "") for c in cols])
        # trades csv
        trade_cols = [
            "entry_time",
            "exit_time",
            "symbol",
            "side",
            "entry",
            "exit",
            "qty",
            "pnl_pct",
            "pnl_usdt",
            "fee_pct",
            "slippage_bps",
            "reason",
            "score",
            "notional",
            "holding_s",
        ]
        with open(os.path.join(out_dir, "report_trades.csv"), "w", newline="") as fh:
            w = csv.writer(fh)
            w.writerow(trade_cols)
            for tr in all_trades:
                w.writerow([tr.get(c, "") if not isinstance(tr.get(c, ""), datetime) else tr.get(c).isoformat() for c in trade_cols])
        with open(os.path.join(out_dir, "equity_curve_total.csv"), "w", newline="") as fh:
            w = csv.writer(fh)
            w.writerow(["timestamp", "equity"])
            for e in eq_total:
                w.writerow([e["timestamp"].isoformat(), f"{e['equity']:.6f}"])
        with open(os.path.join(out_dir, "metrics.json"), "w", encoding="utf8") as fh:
            json.dump({
                "parameters": {
                    "symbols": symbols,
                    "exchange": exchange,
                    "timeframe": timeframe,
                    "fee_rate": fee_rate,
                    "slippage_bps": slippage_bps,
                    "risk_pct": risk_pct,
                    "initial_equity": initial_equity,
                    "leverage": leverage,
                    "paper_constraints": paper_constraints,
                    "seed": seed,
                },
                "summary": summary,
            }, fh, indent=2, default=str)
    # console output
    header = f"{'symbol':<10} {'trades':>6} {'win%':>6} {'pnl%':>8} {'pnl_usdt':>10}"
    print(header)
    for row in summary:
        print(
            f"{row['symbol']:<10} {int(row['trades']):>6} {row['winrate_pct']:>6.2f} {row['pnl_pct']:>8.2f} {row['pnl_usdt']:>10.2f}"
        )
    return summary, all_trades


def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Run multi-pair backtest")
    p.add_argument("--symbols", required=True)
    p.add_argument("--exchange", default="csv")
    p.add_argument("--timeframe", default="1m")
    p.add_argument("--csv-dir")
    p.add_argument("--fee-rate", type=float, default=0.0)
    p.add_argument("--slippage-bps", type=float, default=0.0)
    p.add_argument("--risk-pct", type=float, default=0.01)
    p.add_argument("--initial-equity", type=float, default=1000.0)
    p.add_argument("--leverage", type=float, default=1.0)
    p.add_argument("--paper-constraints", action="store_true")
    p.add_argument("--seed", type=int)
    p.add_argument("--out-dir", default="./result")
    p.add_argument("--plot", action="store_true")
    p.add_argument("--dry-run", action="store_true")
    # grid search options
    p.add_argument("--grid", action="store_true", help="activate grid search")
    p.add_argument("--grid-max", type=int, default=12)
    p.add_argument("--grid-tf")
    p.add_argument("--grid-score-min")
    p.add_argument("--grid-atr-min")
    p.add_argument("--grid-rr-min")
    p.add_argument("--grid-risk-pct")
    p.add_argument("--grid-slippage-bps")
    p.add_argument("--grid-fee")
    p.add_argument("--grid-cooldown")
    p.add_argument("--grid-hours")
    p.add_argument("--match-exchange-semantics", action="store_true")
    return p


def main(args: List[str] | None = None):
    parser = build_arg_parser()
    ns = parser.parse_args(args=args)
    symbols = [s.strip() for s in ns.symbols.split(",") if s.strip()]
    if ns.grid:
        # helper to parse comma separated values
        def _parse(val: str | None, cast):
            if not val:
                return None
            return [cast(v) for v in val.split(",") if v.strip()]

        param_lists: Dict[str, List] = {}
        if ns.grid_tf:
            param_lists["timeframe"] = _parse(ns.grid_tf, str)
        if ns.grid_score_min:
            param_lists["score_min"] = _parse(ns.grid_score_min, float)
        if ns.grid_atr_min:
            param_lists["atr_min_ratio"] = _parse(ns.grid_atr_min, float)
        if ns.grid_rr_min:
            param_lists["rr_min"] = _parse(ns.grid_rr_min, float)
        if ns.grid_risk_pct:
            param_lists["risk_pct"] = _parse(ns.grid_risk_pct, float)
        if ns.grid_slippage_bps:
            param_lists["slippage_bps"] = _parse(ns.grid_slippage_bps, float)
        if ns.grid_fee:
            param_lists["fee_rate"] = _parse(ns.grid_fee, float)
        if ns.grid_cooldown:
            param_lists["cooldown_secs"] = _parse(ns.grid_cooldown, int)
        if ns.grid_hours:
            param_lists["hours"] = _parse(ns.grid_hours, str)

        base_params = {
            "timeframe": ns.timeframe,
            "score_min": 55,
            "atr_min_ratio": 0.002,
            "rr_min": 1.2,
            "risk_pct": ns.risk_pct,
            "slippage_bps": ns.slippage_bps,
            "fee_rate": ns.fee_rate,
            "cooldown_secs": 300,
            "hours": "7-11,13-17",
        }

        return run_grid_search(
            symbols=symbols,
            exchange=ns.exchange,
            base_params=base_params,
            param_lists=param_lists,
            grid_max=ns.grid_max,
            csv_dir=ns.csv_dir,
            initial_equity=ns.initial_equity,
            leverage=ns.leverage,
            paper_constraints=ns.paper_constraints,
            seed=ns.seed,
            out_dir=os.path.join(ns.out_dir, "grid"),
            match_exchange_semantics=ns.match_exchange_semantics,
        )

    return run_backtest_multi(
        symbols=symbols,
        exchange=ns.exchange,
        timeframe=ns.timeframe,
        csv_dir=ns.csv_dir,
        fee_rate=ns.fee_rate,
        slippage_bps=ns.slippage_bps,
        risk_pct=ns.risk_pct,
        initial_equity=ns.initial_equity,
        leverage=ns.leverage,
        paper_constraints=ns.paper_constraints,
        seed=ns.seed,
        out_dir=ns.out_dir,
        plot=ns.plot,
        dry_run=ns.dry_run,
    )


if __name__ == "__main__":  # pragma: no cover
    main()


## bitget_futures_pairs.py (last modified: 2025-08-22 07:05:27)
#!/usr/bin/env python3
"""Fetch the list of Bitget futures contracts.

This helper script queries the public Bitget REST API to retrieve futures
trading pairs for the specified product types and saves them to CSV and JSON
files. It mirrors the standalone example provided by the user but integrates
with the repository's configuration system.

Usage examples::

    python bitget_futures_pairs.py
    python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
    python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
"""
from __future__ import annotations

import argparse
import csv
import json
import sys
import time
from typing import Any, Dict, List

from scalp.bot_config import CONFIG

try:  # pragma: no cover - import guard
    import requests
except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
    sys.stderr.write(
        "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
    )
    raise

BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]


def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
    """Return contract metadata for ``product_type``."""
    url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
    params = {"productType": product_type}
    resp = requests.get(url, params=params, timeout=timeout)
    try:
        data = resp.json()
    except json.JSONDecodeError as exc:  # pragma: no cover - network failure
        raise RuntimeError(
            f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
        ) from exc
    if resp.status_code != 200 or data.get("code") != "00000":
        raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
    return data.get("data", [])


def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Select and rename key fields for CSV/JSON output."""
    rows: List[Dict[str, Any]] = []
    for c in contracts:
        row = {
            "productType": product_type,
            "symbol": c.get("symbol"),
            "baseCoin": c.get("baseCoin"),
            "quoteCoin": c.get("quoteCoin"),
            "symbolType": c.get("symbolType"),
            "symbolStatus": c.get("symbolStatus"),
            "maxLever": c.get("maxLever"),
            "minLever": c.get("minLever"),
            "minTradeNum": c.get("minTradeNum"),
            "sizeMultiplier": c.get("sizeMultiplier"),
            "pricePlace": c.get("pricePlace"),
            "volumePlace": c.get("volumePlace"),
            "launchTime": c.get("launchTime"),
            "deliveryTime": c.get("deliveryTime"),
        }
        rows.append(row)
    return rows


def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
    """Write ``rows`` to ``path`` in CSV format."""
    headers = [
        "productType",
        "symbol",
        "baseCoin",
        "quoteCoin",
        "symbolType",
        "symbolStatus",
        "maxLever",
        "minLever",
        "minTradeNum",
        "sizeMultiplier",
        "pricePlace",
        "volumePlace",
        "launchTime",
        "deliveryTime",
    ]
    with open(path, "w", newline="", encoding="utf-8") as fh:
        writer = csv.DictWriter(fh, fieldnames=headers)
        writer.writeheader()
        if rows:
            writer.writerows(rows)


def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
    )
    parser.add_argument(
        "--types",
        nargs="+",
        default=DEFAULT_PRODUCT_TYPES,
        help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
    )
    parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
    parser.add_argument(
        "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
    )
    parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
    args = parser.parse_args(argv)

    all_rows: List[Dict[str, Any]] = []
    merged_json: Dict[str, List[Dict[str, Any]]] = {}

    for i, pt in enumerate(args.types):
        try:
            contracts = fetch_contracts(pt)
        except Exception as exc:  # pragma: no cover - network/runtime error
            sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
            continue
        rows = normalize_rows(pt, contracts)
        all_rows.extend(rows)
        merged_json[pt] = contracts
        if i < len(args.types) - 1 and args.sleep > 0:
            time.sleep(args.sleep)

    all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))

    write_csv(all_rows, args.out)
    with open(args.json_out, "w", encoding="utf-8") as fh:
        json.dump(merged_json, fh, ensure_ascii=False, indent=2)

    counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
    total = sum(counts.values())
    print(
        f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
    )
    for pt, n in counts.items():
        print(f"  - {pt}: {n} pairs")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI execution
    raise SystemExit(main())


## bot.py (last modified: 2025-08-22 12:29:12)
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import asyncio
from scalp.adapters.bitget import BitgetFuturesClient
from scalp.services.order_service import OrderService, OrderCaps
from scalp.config import load_or_exit
from live.orchestrator import run_orchestrator


def main():
    CONFIG = load_or_exit()
    parser = argparse.ArgumentParser()
    parser.add_argument("--async", dest="use_async", action="store_true", default=True, help="run with asyncio orchestrator (default)")
    parser.add_argument("--sync", dest="use_async", action="store_false", help="force legacy sync loop")
    parser.add_argument("--symbols", type=str, default="BTCUSDT,ETHUSDT", help="liste de symboles séparés par des virgules")
    args = parser.parse_args()

    exchange = BitgetFuturesClient(
        api_key=CONFIG.BITGET_API_KEY,
        secret=CONFIG.BITGET_API_SECRET,
        passphrase=CONFIG.BITGET_PASSPHRASE,
        paper_trade=CONFIG.PAPER_TRADE,
    )
    order_service = OrderService(exchange, OrderCaps(
        min_trade_usdt=getattr(CONFIG, "MIN_TRADE_USDT", 5.0),
        leverage=getattr(CONFIG, "LEVERAGE", 1.0),
    ))

    symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]

    if args.use_async:
        asyncio.run(run_orchestrator(exchange, order_service, CONFIG, symbols))
        return

    # --------- CHEMIN LEGACY SYNC (EXISTANT) ---------
    # Conserver/laisser ton ancienne boucle ici pour compatibilité si besoin.
    # Sinon, on peut lever une exception claire:
    raise SystemExit("Legacy sync loop disabled; run without --sync or implement legacy path.")


if __name__ == "__main__":
    main()


## cli.py (last modified: 2025-08-22 07:05:27)
"""Command line utilities for the Scalp project.

This module exposes a small command line interface used throughout the
project.  The actual trading logic lives in other modules, however the CLI is
responsible for parsing parameters and dispatching the appropriate routines.

The implementation intentionally keeps the invoked functions minimal so that
tests can patch them easily.  In a real deployment these functions would
perform optimisation, walk‑forward analysis or run the live pipeline.
"""

from __future__ import annotations

import argparse
import asyncio
from typing import Iterable, List

from scalp.version import bump_version_from_git


# ---------------------------------------------------------------------------
# Placeholder implementations
# ---------------------------------------------------------------------------


def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    """Run a parallel parameter optimisation.

    The real project dispatches a potentially heavy optimisation routine.  The
    function is kept trivial so unit tests can verify that the CLI wiring works
    without actually performing the optimisation.
    """

    print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")


def run_walkforward_analysis(
    pair: str, timeframe: str, splits: int, train_ratio: float
) -> None:
    """Execute a walk-forward analysis."""

    print(
        f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    )


async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    """Run the live trading pipeline."""

    print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")


# ---------------------------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------------------------


def create_parser() -> argparse.ArgumentParser:
    """Create the top-level argument parser."""

    parser = argparse.ArgumentParser(description="Scalp command line tools")
    sub = parser.add_subparsers(dest="command")

    # --- ``opt`` command -------------------------------------------------
    opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    opt_p.add_argument("--tf", required=True, help="timeframe")
    opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    opt_p.set_defaults(
        func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    )

    # --- ``walkforward`` command ----------------------------------------
    wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    wf_p.add_argument("--pair", required=True, help="trading pair")
    wf_p.add_argument("--tf", required=True, help="timeframe")
    wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    wf_p.add_argument(
        "--train-ratio",
        type=float,
        default=0.7,
        help="portion of data used for training",
    )
    wf_p.set_defaults(
        func=lambda a: run_walkforward_analysis(
            a.pair, a.tf, a.splits, a.train_ratio
        )
    )

    # --- ``live`` command -----------------------------------------------
    live_p = sub.add_parser("live", help="run the live async pipeline")
    live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))

    # --- ``bump-version`` command -------------------------------------
    bv_p = sub.add_parser(
        "bump-version",
        help="update the VERSION file based on the latest git commit",
    )
    bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))

    return parser


def main(argv: Iterable[str] | None = None) -> int:
    """Entry point used by tests and ``if __name__ == '__main__'`` block."""

    parser = create_parser()
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return 0
    result = args.func(args)
    return 0 if result is None else int(result)


if __name__ == "__main__":  # pragma: no cover - manual invocation
    raise SystemExit(main())



## data/__init__.py (last modified: 2025-08-22 07:05:27)
"""Indicator computation helpers."""

from .indicators import compute_all

__all__ = ["compute_all"]


## data/indicators.py (last modified: 2025-08-22 07:05:27)
import pandas as pd

__all__ = ["compute_all"]

def compute_all(
    df: pd.DataFrame,
    *,
    ema_fast: int = 20,
    ema_slow: int = 50,
    rsi_period: int = 14,
    macd_fast: int = 12,
    macd_slow: int = 26,
    macd_signal: int = 9,
    atr_period: int = 14,
    swing_lookback: int = 5,
) -> pd.DataFrame:
    """Compute common indicators and return enriched DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
        ``volume`` columns ordered chronologically.

    Returns
    -------
    pd.DataFrame
        New DataFrame with additional indicator columns.
    """

    if df.empty:
        return df.copy()

    df = df.copy()

    # --- VWAP ---------------------------------------------------------------
    typical = (df["high"] + df["low"] + df["close"]) / 3.0
    vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
    df["vwap"] = vwap

    # --- EMAs ---------------------------------------------------------------
    df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
    df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()

    # --- RSI ----------------------------------------------------------------
    delta = df["close"].diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(rsi_period).mean()
    avg_loss = loss.rolling(rsi_period).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    df["rsi"] = rsi.fillna(50.0)

    # --- MACD ---------------------------------------------------------------
    ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
    ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
    macd = ema_fast_series - ema_slow_series
    signal = macd.ewm(span=macd_signal, adjust=False).mean()
    df["macd"] = macd
    df["macd_signal"] = signal
    df["macd_hist"] = macd - signal

    # --- OBV ----------------------------------------------------------------
    obv = [0.0]
    closes = df["close"].tolist()
    vols = df["volume"].tolist()
    for i in range(1, len(df)):
        if closes[i] > closes[i - 1]:
            obv.append(obv[-1] + vols[i])
        elif closes[i] < closes[i - 1]:
            obv.append(obv[-1] - vols[i])
        else:
            obv.append(obv[-1])
    df["obv"] = obv

    # --- ATR ----------------------------------------------------------------
    high_low = df["high"] - df["low"]
    high_close = (df["high"] - df["close"].shift()).abs()
    low_close = (df["low"] - df["close"].shift()).abs()
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = tr.rolling(atr_period).mean()

    # --- Swing highs/lows ---------------------------------------------------
    df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
    df["swing_low"] = df["low"].rolling(window=swing_lookback).min()

    return df


## dump_repo.py (last modified: 2025-08-22 07:05:27)
import os
from datetime import datetime
from pathlib import Path

IGNORE_EXTENSIONS = {'.log', '.pyc'}
IGNORE_DIRS = {'__pycache__'}


def _is_ignored(path: Path) -> bool:
    """Return True if the path should be ignored."""
    if any(part.startswith('.') for part in path.parts):
        return True
    if path.suffix in IGNORE_EXTENSIONS:
        return True
    if any(part in IGNORE_DIRS for part in path.parts):
        return True
    return False


def _build_tree(root: Path, ignore_path: Path) -> str:
    lines = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirpath = Path(dirpath)
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
        depth = len(dirpath.relative_to(root).parts)
        indent = '    ' * depth
        lines.append(f"{indent}{dirpath.name}/")
        for fname in sorted(filenames):
            fpath = dirpath / fname
            if fpath == ignore_path or _is_ignored(fpath):
                continue
            lines.append(f"{indent}    {fname}")
    return '\n'.join(lines)


def _iter_files(root: Path):
    for path in sorted(root.rglob('*')):
        if path.is_file() and not _is_ignored(path):
            yield path


def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
    """Create a text dump of the repository tree and file contents."""
    root_path = Path(root).resolve()
    output_path = root_path / output_path
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with output_path.open('w', encoding='utf-8') as dump:
        dump.write(f"Dump created: {now}\n")
        dump.write('Repository tree:\n')
        dump.write(_build_tree(root_path, output_path))
        dump.write('\n\n')
        for file_path in _iter_files(root_path):
            rel_path = file_path.relative_to(root_path)
            if file_path == output_path:
                continue
            mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            dump.write(f"## {rel_path} (last modified: {mod_time})\n")
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    dump.write(f.read())
            except Exception:
                dump.write('[unreadable file]\n')
            dump.write('\n\n')


if __name__ == '__main__':
    create_dump_file()


## init.py (last modified: 2025-08-22 07:05:27)
#!/usr/bin/env python3
"""Install all project dependencies.

Run this script once to install every ``requirements*.txt`` file found in the
repository as well as the packages needed for the test suite.  All subsequent
invocations of the bot or its submodules will then share the same Python
environment with the required dependencies available.
"""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path


def install_packages(*args: str) -> None:
    """Install packages using pip for the current Python interpreter."""
    cmd = [sys.executable, "-m", "pip", "install", *args]
    subprocess.check_call(cmd)


def main() -> None:
    repo_root = Path(__file__).resolve().parent

    # Install from any requirements*.txt file across the repository so that
    # sub-packages with their own dependency lists are also covered.
    for req in sorted(repo_root.rglob("requirements*.txt")):
        install_packages("-r", str(req))

    # Ensure test dependencies are available
    install_packages("pytest")


if __name__ == "__main__":
    main()


## live/__init__.py (last modified: 2025-08-22 12:29:12)
"""Live trading helpers."""

from .orchestrator import Orchestrator, run_orchestrator

__all__ = ["Orchestrator", "run_orchestrator"]


## live/orchestrator.py (last modified: 2025-08-22 12:29:12)
from __future__ import annotations
import asyncio
import signal
import time
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

from scalp.adapters.bitget import BitgetFuturesClient
from scalp.services.order_service import OrderService, OrderRequest
from scalp.strategy import generate_signal, Signal


@dataclass
class SymbolContext:
    symbol: str
    ohlcv: List[Dict]
    position_open: bool = False
    last_signal_ts: float = 0.0


class Orchestrator:
    """
    Orchestrateur asyncio: gère plusieurs tâches concurrentes.
    """

    def __init__(self, exchange: BitgetFuturesClient, order_service: OrderService, config, symbols: Sequence[str]):
        self.exchange = exchange
        self.order_service = order_service
        self.config = config
        self.symbols = list(symbols)
        self.ctx: Dict[str, SymbolContext] = {s: SymbolContext(s, []) for s in self.symbols}
        self._running = False
        self._tasks: List[asyncio.Task] = []
        self._heartbeat_ts = 0.0

    # ---------- UTILITAIRES ----------
    async def _sleep(self, secs: float) -> None:
        try:
            await asyncio.sleep(secs)
        except asyncio.CancelledError:
            pass

    async def _safe(self, coro, *, label: str, backoff: float = 1.0, backoff_max: float = 30.0):
        delay = backoff
        while self._running:
            try:
                return await coro
            except asyncio.CancelledError:
                raise
            except Exception as e:
                print(f"[orchestrator] {label} failed: {e!r}, retry in {delay:.1f}s")
                await self._sleep(delay)
                delay = min(backoff_max, delay * 1.7)

    # ---------- TACHES ----------
    async def _task_heartbeat(self):
        while self._running:
            self._heartbeat_ts = time.time()
            print("[heartbeat] alive")
            await self._sleep(15)

    async def _task_refresh_watchlist(self):
        # Placeholder: à relier à ta logique de sélection dynamique de paires
        while self._running:
            # Ici on pourrait filtrer par volume via exchange.get_ticker()
            await self._sleep(60)

    async def _fetch_ohlcv_once(self, symbol: str, limit: int = 100) -> List[Dict]:
        """
        Récupère une petite fenêtre OHLCV via l'endpoint kline REST existant du client de base.
        On suppose que le client de base expose get_kline(symbol, granularity) -> dict avec "data".
        Adapte si nécessaire à ton client.
        """
        # Fallback générique: on reconstitue une bougie synthétique à partir du ticker si pas d'API kline.
        try:
            data = self.exchange.get_kline(symbol, interval="1m")  # adapter si signature différente
            rows = data.get("data") or data.get("result") or []
            out = []
            for r in rows[-limit:]:
                # Adapter les clés selon Bitget (ts, open, high, low, close, volume)
                o = float(r.get("open", r[1] if isinstance(r, (list, tuple)) else 0))
                h = float(r.get("high", r[2] if isinstance(r, (list, tuple)) else 0))
                l = float(r.get("low",  r[3] if isinstance(r, (list, tuple)) else 0))
                c = float(r.get("close",r[4] if isinstance(r, (list, tuple)) else 0))
                v = float(r.get("volume", r[5] if isinstance(r, (list, tuple)) else 0))
                t = int(r.get("ts", r[0] if isinstance(r, (list, tuple)) else 0))
                out.append({"ts": t, "open": o, "high": h, "low": l, "close": c, "volume": v})
            if out:
                return out
        except Exception:
            pass
        # Fallback synthétique
        tkr = self.exchange.get_ticker(symbol)
        items = tkr.get("data") or []
        if not items:
            return []
        last = items[0]
        p = float(last.get("lastPrice", last.get("close", 0)))
        ts = int(time.time() * 1000)
        return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": float(last.get("volume", 0))}]

    async def _task_trade_loop(self, symbol: str):
        ctx = self.ctx[symbol]
        print(f"[trade-loop] start {symbol}")
        # Pré-chargement fenêtre
        ctx.ohlcv = await self._safe(self._fetch_ohlcv_once(symbol, limit=200), label=f"fetch_ohlcv_boot:{symbol}")
        while self._running:
            # 1) rafraîchir dernière bougie
            new_rows = await self._safe(self._fetch_ohlcv_once(symbol, limit=2), label=f"fetch_ohlcv_tail:{symbol}")
            if new_rows:
                # maintenir une fenêtre glissante
                ctx.ohlcv = (ctx.ohlcv + new_rows)[-400:]
            # 2) générer signal
            try:
                sig: Optional[Signal] = generate_signal(ohlcv=ctx.ohlcv, config=self.config)
            except Exception as e:
                print(f"[trade-loop:{symbol}] generate_signal error: {e!r}")
                sig = None
            # 3) exécuter
            if sig and not ctx.position_open:
                try:
                    assets = self.exchange.get_assets()
                    equity_usdt = 0.0
                    for a in (assets.get("data") or []):
                        if a.get("currency") == "USDT":
                            equity_usdt = float(a.get("equity", 0))
                            break
                    req = OrderRequest(
                        symbol=sig.symbol or symbol,
                        side="long" if sig.side > 0 else "short",
                        price=float(sig.entry),
                        sl=float(sig.sl),
                        tp=float(sig.tp1) if getattr(sig, "tp1", None) else (float(sig.tp2) if getattr(sig, "tp2", None) else None),
                        risk_pct=float(getattr(self.config, "RISK_PCT", 0.01)),
                    )
                    res = self.order_service.prepare_and_place(equity_usdt, req)
                    if res.accepted:
                        ctx.position_open = True
                        ctx.last_signal_ts = time.time()
                        print(f"[order] {symbol} accepted")
                    else:
                        print(f"[order] {symbol} rejected: {res.reason}")
                except Exception as e:
                    print(f"[trade-loop:{symbol}] order error: {e!r}")
            # 4) tempo
            await self._sleep(1.0)

    async def _task_telegram(self):
        # Placeholder: déplacer ici la logique Telegram existante si nécessaire
        while self._running:
            await self._sleep(1.0)

    # ---------- BOOT/RUN ----------
    async def run(self):
        if self._running:
            return
        self._running = True
        loop = asyncio.get_running_loop()
        for sig in (signal.SIGINT, signal.SIGTERM):
            try:
                loop.add_signal_handler(sig, lambda s=sig: asyncio.create_task(self.stop(reason=f"signal:{s.name}")))
            except NotImplementedError:
                pass  # Windows
        self._tasks = [
            asyncio.create_task(self._task_heartbeat(), name="heartbeat"),
            asyncio.create_task(self._task_refresh_watchlist(), name="watchlist"),
            asyncio.create_task(self._task_telegram(), name="telegram"),
        ] + [asyncio.create_task(self._task_trade_loop(s), name=f"trade:{s}") for s in self.symbols]
        print("[orchestrator] running")
        try:
            await asyncio.gather(*self._tasks)
        except asyncio.CancelledError:
            pass
        finally:
            print("[orchestrator] stopped")

    async def stop(self, reason: str = "unknown"):
        if not self._running:
            return
        print(f"[orchestrator] stopping: {reason}")
        self._running = False
        for t in self._tasks:
            t.cancel()
        await asyncio.sleep(0)  # yield to cancellations


# Helper de lancement depuis bot.py
async def run_orchestrator(exchange: BitgetFuturesClient, order_service: OrderService, config, symbols: Sequence[str]):
    orch = Orchestrator(exchange, order_service, config, symbols)
    await orch.run()


## notebooks/spot/bitget_bot.py (last modified: 2025-08-22 07:05:27)
import os
import time
import hmac
import hashlib
import base64
import logging
from argparse import ArgumentParser
from pathlib import Path
from typing import Any, Dict, List
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv

BASE_URL = "https://api.bitget.com"
RECV_WINDOW = 5000


def load_keys() -> Dict[str, str]:
    parent = Path(__file__).resolve().parent.parent
    load_dotenv(parent / ".env")
    api_key = os.getenv("BITGET_API_KEY")
    api_secret = os.getenv("BITGET_API_SECRET")
    if not api_key or not api_secret:
        raise RuntimeError("API keys not found in environment")
    return {"key": api_key, "secret": api_secret}


class BitgetClient:
    def __init__(self) -> None:
        creds = load_keys()
        self.api_key = creds["key"]
        self.api_secret = creds["secret"]
        self.session = requests.Session()
        self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
        self.time_offset = self._compute_time_offset()

    def _compute_time_offset(self) -> int:
        server = self.server_time()
        return int(server["serverTime"]) - int(time.time() * 1000)

    def _timestamp(self) -> int:
        return int(time.time() * 1000) + self.time_offset

    def _request(
        self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
    ) -> Any:
        params = params or {}
        if signed:
            params["timestamp"] = self._timestamp()
            params["recvWindow"] = RECV_WINDOW
            query = urlencode(params)
            signature = base64.b64encode(
                hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
            ).decode()
            query += f"&signature={signature}"
            headers = {"X-BITGET-APIKEY": self.api_key}
            if method.upper() == "GET":
                url = f"{BASE_URL}{path}?{query}"
                resp = self.session.get(url, headers=headers)
            else:
                url = f"{BASE_URL}{path}"
                headers["Content-Type"] = "application/x-www-form-urlencoded"
                resp = self.session.post(url, data=query, headers=headers)
        else:
            url = f"{BASE_URL}{path}"
            resp = self.session.request(method, url, params=params)

        resp.raise_for_status()
        if resp.text:
            return resp.json()
        return {}

    # Helpers
    def server_time(self) -> Any:
        return self._request("GET", "/api/v3/time")

    def ticker_price(self, symbol: str) -> Any:
        return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})

    def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
        return self._request(
            "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
        )

    def test_order(self, **params: Any) -> Any:
        return self._request("POST", "/api/v3/order/test", params, signed=True)

    def place_order(self, **params: Any) -> Any:
        return self._request("POST", "/api/v3/order", params, signed=True)

    def account_info(self) -> Any:
        return self._request("GET", "/api/v3/account", signed=True)

    def book_ticker(self, symbol: str) -> Any:
        return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})


def sma(values: List[float], period: int) -> float:
    if len(values) < period:
        raise ValueError("Not enough data for SMA")
    return sum(values[-period:]) / period


def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
    kl = client.klines(symbol, limit=50)
    closes = [float(k[4]) for k in kl]
    sma9_prev = sma(closes[:-1], 9)
    sma21_prev = sma(closes[:-1], 21)
    sma9_curr = sma(closes, 9)
    sma21_curr = sma(closes, 21)

    cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
    cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr

    log = logging.getLogger("bitget_bot")

    if cross_up:
        book = client.book_ticker(symbol)
        ask = float(book["askPrice"])
        qty = quote_usdt / ask
        params = {
            "symbol": symbol,
            "side": "BUY",
            "type": "LIMIT",
            "timeInForce": "IOC",
            "quantity": f"{qty:.6f}",
            "price": book["askPrice"],
        }
        log.info("BUY signal %s", params)
        resp = client.test_order(**params) if dry_run else client.place_order(**params)
        log.info("response %s", resp)
    elif cross_down:
        account = client.account_info()
        base = symbol.rstrip("USDT")
        bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
        qty = float(bal["free"])
        if qty > 0:
            book = client.book_ticker(symbol)
            params = {
                "symbol": symbol,
                "side": "SELL",
                "type": "LIMIT",
                "timeInForce": "IOC",
                "quantity": f"{qty:.6f}",
                "price": book["bidPrice"],
            }
            log.info("SELL signal %s", params)
            resp = client.test_order(**params) if dry_run else client.place_order(**params)
            log.info("response %s", resp)
        else:
            log.info("No balance to sell")


def interval_seconds(interval: str) -> int:
    unit = interval[-1]
    qty = int(interval[:-1])
    if unit == "m":
        return qty * 60
    if unit == "h":
        return qty * 3600
    if unit == "d":
        return qty * 86400
    return 60


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    parser = ArgumentParser(description="Bitget SMA crossover bot")
    parser.add_argument("--symbol", default="BTCUSDT")
    parser.add_argument("--quote-usdt", type=float, default=10.0)
    parser.add_argument("--interval", default="1m")
    parser.add_argument("--loop", action="store_true")
    parser.add_argument("--dry-run", dest="dry_run", action="store_true")
    parser.add_argument("--live", dest="dry_run", action="store_false")
    parser.set_defaults(dry_run=True)
    args = parser.parse_args()

    client = BitgetClient()
    delay = interval_seconds(args.interval)

    while True:
        try:
            analyze(client, args.symbol, args.quote_usdt, args.dry_run)
        except Exception as exc:
            logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
        if not args.loop:
            break
        time.sleep(delay)


if __name__ == "__main__":
    main()


## pytest.ini (last modified: 2025-08-22 07:05:27)
[pytest]
addopts = -q


## quick_order.py (last modified: 2025-08-22 07:05:27)
#!/usr/bin/env python3
"""Submit a simple market order on Bitget futures.

This helper reads API credentials and trade parameters from environment
variables (optionally loaded from a `.env` file) and places a one-way
market order.  Only the essential steps from the user's reference script
are kept to minimise latency and redundant code.

Environment variables:
    BITGET_API_KEY / BITGET_ACCESS_KEY
    BITGET_API_SECRET / BITGET_SECRET_KEY
    BITGET_API_PASSPHRASE
    BITGET_BASE_URL (default https://api.bitget.com)
    BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
    BITGET_MARGIN_COIN (default ``USDT``)
    BITGET_SYMBOL (e.g. ``BTCUSDT``)
    BITGET_TEST_NOTIONAL_USDT (default ``5``)

Usage:
    python quick_order.py buy
    python quick_order.py sell
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

from dotenv import load_dotenv

from scalp.bitget_client import BitgetFuturesClient

# Load variables from `.env` if present
load_dotenv(Path(__file__).resolve().parent / ".env")

side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
if side not in {"buy", "sell"}:
    raise SystemExit("Usage: quick_order.py [buy|sell]")

base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))

if not (ak and sk and ph):
    raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")

client = BitgetFuturesClient(
    access_key=ak,
    secret_key=sk,
    base_url=base,
    passphrase=ph,
    paper_trade=False,
)

tick = client.get_ticker(symbol)
price = None
try:
    data = tick.get("data")
    if isinstance(data, list) and data:
        price_str = data[0].get("lastPr") or data[0].get("lastPrice")
        if price_str is not None:
            price = float(price_str)
    elif isinstance(data, dict):
        price_str = data.get("lastPr") or data.get("lastPrice")
        if price_str is not None:
            price = float(price_str)
except Exception:
    pass
if price is None or price <= 0:
    raise SystemExit("Prix introuvable pour le ticker")

size = round(notional / price, 6)
client.set_position_mode_one_way(symbol, product_type)
client.set_leverage(symbol, product_type, margin_coin, leverage=2)
resp = client.place_market_order_one_way(
    symbol, side, size, product_type, margin_coin
)
print(resp)


## requirements-dev.txt (last modified: 2025-08-22 07:05:27)
pytest


## requirements.txt (last modified: 2025-08-22 12:29:12)
requests
python-dotenv
pydantic>=2


## scalp/VERSION (last modified: 2025-08-22 07:05:27)
0.3.0



## scalp/__init__.py (last modified: 2025-08-22 07:05:27)
"""Utilities and helpers for Scalp bot.

When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
keys to live in ``notebook/.env``.  On import this module attempts to load the
variables from that file so that API keys can remain outside of the repository
yet still be available at runtime.
"""

from __future__ import annotations

import os
from pathlib import Path
import sys


def _load_parent_env() -> None:
    """Load environment variables from ``../.env`` relative to the entry script.

    The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
    are expected to be stored one directory above (``notebook/.env``).  If that
    file is not found the function falls back to the historical behaviour of
    checking ``../.env`` relative to the package itself.
    """

    script_path = Path(sys.argv[0]).resolve()
    env_file = script_path.parent.parent / ".env"
    if not env_file.exists():
        env_file = Path(__file__).resolve().parents[2] / ".env"
        if not env_file.exists():
            return

    try:
        from dotenv import load_dotenv

        load_dotenv(env_file)
    except Exception:  # pragma: no cover - optional dependency
        for line in env_file.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            os.environ.setdefault(key.strip(), value.strip().strip("'\""))


_load_parent_env()

from .version import get_version, bump_version_from_message  # noqa: E402
from .strategy import (  # noqa: E402
    Signal,
    scan_pairs,
    select_active_pairs,
    generate_signal,
    backtest,
)
from .risk.manager import RiskManager  # noqa: E402

__all__ = [
    "get_version",
    "bump_version_from_message",
    "__version__",
    "Signal",
    "scan_pairs",
    "select_active_pairs",
    "generate_signal",
    "RiskManager",
    "backtest",
]

__version__ = get_version()


## scalp/adapters/__init__.py (last modified: 2025-08-22 12:29:12)


## scalp/adapters/bitget.py (last modified: 2025-08-22 12:29:12)
from __future__ import annotations
from typing import Any, Dict, List, Optional
import requests
from scalp.bitget_client import BitgetFuturesClient as _Base


def _to_float(x, default=0.0) -> float:
    try:
        return float(x)
    except Exception:
        return default


class BitgetFuturesClient(_Base):
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        kwargs.setdefault("requests_module", requests)
        # Map friendly aliases to the base client's parameter names
        if "api_key" in kwargs and "access_key" not in kwargs:
            kwargs["access_key"] = kwargs.pop("api_key")
        if "secret" in kwargs and "secret_key" not in kwargs:
            kwargs["secret_key"] = kwargs.pop("secret")
        kwargs.setdefault("base_url", "https://api.bitget.com")
        super().__init__(*args, **kwargs)

    def get_assets(self) -> Dict[str, Any]:
        raw = super().get_assets()
        data = raw.get("data") or raw.get("result") or raw.get("assets") or []
        norm: List[Dict[str, Any]] = []
        for a in data:
            currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
            equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
            available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
            norm.append({"currency": currency, "equity": equity, "available": available, **a})
        return {"success": True, "data": norm}

    def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        if symbol:
            raw = super().get_ticker(symbol)
            items = [raw.get("data") or raw]
        else:
            raw = super().get_tickers()
            items = raw.get("data") or raw.get("result") or raw.get("tickers") or []
        norm: List[Dict[str, Any]] = []
        for t in items:
            s = t.get("symbol") or t.get("instId") or t.get("instrumentId") or ""
            s = s.replace("_", "")
            last_ = t.get("lastPrice") or t.get("last", t.get("close", t.get("markPrice", 0)))
            bid_ = t.get("bidPrice") or t.get("bestBidPrice") or t.get("bestBid", t.get("buyOne", 0))
            ask_ = t.get("askPrice") or t.get("bestAskPrice") or t.get("bestAsk", t.get("sellOne", 0))
            vol_usdt = t.get("usdtVolume") or t.get("quoteVolume") or t.get("turnover24h")
            vol_base = t.get("baseVolume") or t.get("volume") or t.get("size24h")
            volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
            norm.append({
                "symbol": s,
                "lastPrice": _to_float(last_),
                "bidPrice": _to_float(bid_),
                "askPrice": _to_float(ask_),
                "volume": volume,
                **t,
            })
        return {"success": True, "data": norm}


## scalp/backtest/__init__.py (last modified: 2025-08-22 12:29:12)
"""Simple backtesting helpers."""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from scalp.bot_config import CONFIG
from scalp.metrics import calc_pnl_pct
from .walkforward import walk_forward

__all__ = ["backtest_trades", "walk_forward_windows", "walk_forward"]


def _apply_slippage(price: float, side: int, bps: float, *, is_entry: bool) -> float:
    """Return price adjusted for slippage in basis points.

    ``side`` is ``1`` for long entries and ``-1`` for shorts.  ``is_entry``
    indicates whether the adjustment is for the entry or the exit leg.
    """

    slip = bps / 10000.0
    if side == 1:
        return price * (1 + slip) if is_entry else price * (1 - slip)
    return price * (1 - slip) if is_entry else price * (1 + slip)


def backtest_trades(
    trades: List[Dict[str, Any]],
    *,
    fee_rate: Optional[float] = None,
    slippage_bps: float = 0.0,
    logger: Any | None = None,
) -> float:
    """Compute cumulative PnL for a series of trades.

    ``slippage_bps`` simulates execution slippage for both entry and exit.
    If ``logger`` is provided it must expose a ``log(dict)`` method and each
    trade will be recorded with the computed PnL using the executed prices.
    """
    fee_rate = fee_rate if fee_rate is not None else CONFIG.get("FEE_RATE", 0.0)

    pnl = 0.0
    for tr in trades:
        symbol = tr.get("symbol")
        entry = tr.get("entry")
        exit_ = tr.get("exit")
        side = tr.get("side", 1)
        if None in (symbol, entry, exit_):
            continue
        entry_exec = _apply_slippage(float(entry), side, slippage_bps, is_entry=True)
        exit_exec = _apply_slippage(float(exit_), -side, slippage_bps, is_entry=False)
        pnl_trade = calc_pnl_pct(entry_exec, exit_exec, side, fee_rate)
        if logger is not None:
            logger.log(
                {
                    "pair": symbol,
                    "tf": tr.get("tf"),
                    "dir": "long" if side > 0 else "short",
                    "entry": entry_exec,
                    "sl": tr.get("sl"),
                    "tp": tr.get("tp"),
                    "score": tr.get("score"),
                    "reasons": tr.get("reasons"),
                    "pnl": pnl_trade,
                }
            )
        pnl += pnl_trade
    return pnl


def walk_forward_windows(series: List[Any], train: int, test: int):
    """Yield sequential ``(train, test)`` windows for walk-forward analysis.

    Parameters
    ----------
    series:
        Ordered data sequence.  The function simply slices the input and does
        not inspect the values.
    train, test:
        Number of elements for the training and testing windows respectively.
    """

    end = len(series) - train - test + 1
    step = test if test > 0 else 1
    for start in range(0, max(0, end), step):
        train_slice = series[start : start + train]
        test_slice = series[start + train : start + train + test]
        if len(test_slice) < test or len(train_slice) < train:
            break
        yield train_slice, test_slice


## scalp/backtest/walkforward.py (last modified: 2025-08-22 07:05:27)
from __future__ import annotations

from itertools import product
from statistics import mean, stdev
from typing import Dict, Iterable, Optional

from ..strategy import max_drawdown


def _sharpe(returns: Iterable[float]) -> float:
    vals = list(returns)
    if not vals:
        return 0.0
    mu = mean(vals)
    if len(vals) > 1:
        sd = stdev(vals)
    else:
        sd = 0.0
    return mu / sd if sd > 0 else 0.0


def _stability(equity: Iterable[float]) -> float:
    curve = list(equity)
    n = len(curve)
    if n < 2:
        return 0.0
    x = list(range(n))
    x_mean = sum(x) / n
    y_mean = sum(curve) / n
    ss_tot = sum((y - y_mean) ** 2 for y in curve)
    denom = sum((xi - x_mean) ** 2 for xi in x)
    if denom == 0 or ss_tot == 0:
        return 0.0
    b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    a = y_mean - b * x_mean
    ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    return 1 - ss_res / ss_tot


def walk_forward(
    df,
    splits: int = 5,
    train_ratio: float = 0.7,
    params: Optional[Dict[str, Iterable]] = None,
) -> Dict[str, float]:
    """Perform walk-forward optimisation and evaluation.

    Parameters
    ----------
    df:
        DataFrame containing per-period percentage returns. The first column is
        used when a dedicated ``"returns"`` column is not found.
    splits:
        Number of walk-forward test windows.
    train_ratio:
        Proportion of the data used for training in the initial window.
    params:
        Optional parameter grid. If provided, columns in ``df`` matching each
        parameter combination are evaluated and the best Sharpe ratio on the
        training window is selected. When ``None``, the first column is used.
    """

    if df.empty:
        return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}

    returns_col = "returns" if "returns" in df.columns else df.columns[0]
    data = df.copy()

    n = len(data)
    train_len = max(1, int(n * train_ratio))
    test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)

    sharpe_list = []
    mdd_list = []
    pnl_list = []
    stability_list = []

    from . import walk_forward_windows

    indices = list(range(n))

    for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
        train_df = data.iloc[tr_idx]
        test_df = data.iloc[te_idx]

        # Parameter optimisation based on Sharpe ratio
        if params:
            best_col = None
            best_score = float("-inf")
            keys, values = zip(*params.items()) if params else ([], [])
            for combo in product(*values):
                col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
                if col_name not in data.columns:
                    continue
                score = _sharpe(train_df[col_name])
                if score > best_score:
                    best_score = score
                    best_col = col_name
            series = test_df[best_col] if best_col else test_df[returns_col]
        else:
            series = test_df[returns_col]

        sharpe_list.append(_sharpe(series))
        equity = (1 + series / 100.0).cumprod()
        mdd_list.append(max_drawdown(equity))
        pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
        stability_list.append(_stability(equity))

    count = len(sharpe_list) or 1
    mean_sharpe = sum(sharpe_list) / count
    mean_mdd = sum(mdd_list) / count
    mean_pnl = sum(pnl_list) / count
    mean_stability = sum(stability_list) / count

    return {
        "sharpe": mean_sharpe,
        "mdd": mean_mdd,
        "pnl": mean_pnl,
        "stability": mean_stability,
    }


## scalp/bitget_client.py (last modified: 2025-08-22 07:05:27)
import json
import logging
import time
import hmac
import hashlib
import base64
import uuid
from typing import Any, Dict, List, Optional

import requests


# Mapping of deprecated v1 product type identifiers to the new v2 names
_PRODUCT_TYPE_ALIASES = {
    "UMCBL": "USDT-FUTURES",
    "DMCBL": "USDC-FUTURES",
    "CMCBL": "COIN-FUTURES",
}

# Granularity aliases from v1 to v2 nomenclature
_GRANULARITY_ALIASES = {
    "MIN1": "1m",
    "MIN3": "3m",
    "MIN5": "5m",
    "MIN15": "15m",
    "MIN30": "30m",
    "HOUR1": "1H",
    "HOUR4": "4H",
    "HOUR12": "12H",
    "DAY1": "1D",
    "WEEK1": "1W",
}


# Default margin coin for each product type. Some authenticated endpoints
# require ``marginCoin`` in addition to ``productType``; supplying a sensible
# default avoids ``400 Bad Request`` responses when the caller does not provide
# it explicitly.
_DEFAULT_MARGIN_COIN = {
    "USDT-FUTURES": "USDT",
    "USDC-FUTURES": "USDC",
}


class BitgetFuturesClient:
    """Lightweight REST client for Bitget LAPI v2 futures endpoints."""

    def __init__(
        self,
        access_key: str,
        secret_key: str,
        base_url: str,
        *,
        product_type: str = "USDT-FUTURES",
        recv_window: int = 30,
        paper_trade: bool = True,
        requests_module: Any = requests,
        log_event: Optional[Any] = None,
        passphrase: Optional[str] = None,
    ) -> None:
        self.ak = access_key
        self.sk = secret_key
        self.base = base_url.rstrip("/")
        pt = product_type.upper()
        self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
        self.recv_window = recv_window
        self.paper_trade = paper_trade
        self.requests = requests_module
        self.log_event = log_event or (lambda *a, **k: None)
        self.passphrase = passphrase
        if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
            logging.warning(
                "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
            )
        # Cache for contract precision details to avoid repeated network calls
        self._contract_cache: Dict[str, Dict[str, Any]] = {}

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    @staticmethod
    def _ms() -> int:
        return int(time.time() * 1000)

    @staticmethod
    def _urlencode_sorted(params: Dict[str, Any]) -> str:
        if not params:
            return ""
        items = []
        for k in sorted(params.keys()):
            v = "" if params[k] is None else str(params[k])
            items.append(f"{k}={v}")
        return "&".join(items)

    def _sign(self, prehash: str) -> str:
        """Return a base64-encoded HMAC SHA256 signature."""
        digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
        return base64.b64encode(digest).decode()

    def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
        headers = {
            "ACCESS-KEY": self.ak,
            "ACCESS-SIGN": signature,
            "ACCESS-TIMESTAMP": str(timestamp),
            "ACCESS-RECV-WINDOW": str(self.recv_window),
            "Content-Type": "application/json",
        }
        if self.passphrase:
            headers["ACCESS-PASSPHRASE"] = self.passphrase
        return headers

    def _format_symbol(self, symbol: str) -> str:
        """Return ``symbol`` formatted for Bitget API.

        The v2 endpoints expect the trading pair without any product type
        suffix (``BTCUSDT``). Older configurations may provide symbols like
        ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
        separators and any trailing product type string (legacy or v2).
        """

        if not symbol:
            return symbol

        sym = symbol.replace("_", "").upper()
        # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
        if sym.endswith(self.product_type):
            sym = sym[: -len(self.product_type)]
        else:
            for old in _PRODUCT_TYPE_ALIASES.keys():
                if sym.endswith(old):
                    sym = sym[: -len(old)]
                    break
        return sym

    def _product_type(self, pt: Optional[str] = None) -> str:
        """Normalise ``pt`` to a valid v2 product type identifier."""
        key = (pt or self.product_type or "").upper()
        return _PRODUCT_TYPE_ALIASES.get(key, key)

    # ------------------------------------------------------------------
    # Public endpoints
    # ------------------------------------------------------------------
    def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        """Return futures contract information.

        The previous implementation queried ``/contract-detail`` which does not
        exist on Bitget's v2 API and resulted in a 404 error.  The correct
        endpoint is ``/contracts`` with the symbol supplied as a query
        parameter."""

        url = f"{self.base}/api/v2/mix/market/contracts"
        params: Dict[str, Any] = {"productType": self.product_type}
        if symbol:
            params["symbol"] = self._format_symbol(symbol)
        r = self.requests.get(url, params=params, timeout=15)
        if r.status_code == 404:  # pragma: no cover - depends on network
            logging.error("Contract detail introuvable pour %s", symbol)
            return {"success": False, "code": 404, "data": None}
        r.raise_for_status()
        return r.json()

    # ------------------------------------------------------------------
    def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
        """Return price and volume precision for ``symbol``.

        Results are cached to minimise HTTP requests. If the contract
        information cannot be retrieved, ``(0, 0)`` is returned.
        """
        sym = self._format_symbol(symbol)
        info = self._contract_cache.get(sym)
        if info is None:
            detail = self.get_contract_detail(sym)
            try:
                data = detail.get("data", [])
                if isinstance(data, list) and data:
                    info = data[0]
                else:
                    info = {}
            except Exception:
                info = {}
            self._contract_cache[sym] = info
        price_place = int(info.get("pricePlace") or 0)
        volume_place = int(info.get("volumePlace") or 0)
        return price_place, volume_place

    def get_kline(
        self,
        symbol: str,
        interval: str = "1m",
        start: Optional[int] = None,
        end: Optional[int] = None,
    ) -> Dict[str, Any]:
        # Endpoint expects the trading pair in query parameters rather than
        # encoded in the path. Using ``/candles/{symbol}`` results in a 404
        # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
        url = f"{self.base}/api/v2/mix/market/candles"
        interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
        params: Dict[str, Any] = {
            "symbol": self._format_symbol(symbol),
            "productType": self.product_type,
            "granularity": interval_norm,
        }
        if start is not None:
            params["startTime"] = int(start)
        if end is not None:
            params["endTime"] = int(end)
        r = self.requests.get(url, params=params, timeout=15)
        r.raise_for_status()
        data = r.json()

        rows = data.get("data") if isinstance(data, dict) else None
        if isinstance(rows, list) and rows and isinstance(rows[0], list):
            cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
            for row in rows:
                if len(row) < 7:
                    continue
                try:
                    ts, op, hi, lo, cl, vol, qv = row[:7]
                    cols["ts"].append(int(ts))
                    cols["open"].append(float(op))
                    cols["high"].append(float(hi))
                    cols["low"].append(float(lo))
                    cols["close"].append(float(cl))
                    cols["volume"].append(float(vol))
                    cols["quoteVolume"].append(float(qv))
                except (TypeError, ValueError):
                    continue
            data["data"] = cols
        elif isinstance(rows, list):
            data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
        return data

    def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        if symbol:
            url = f"{self.base}/api/v2/mix/market/ticker"
            params = {
                "symbol": self._format_symbol(symbol),
                "productType": self.product_type,
            }
        else:
            url = f"{self.base}/api/v2/mix/market/tickers"
            params = {"productType": self.product_type}
        r = self.requests.get(url, params=params, timeout=15)
        r.raise_for_status()
        return r.json()

    # ------------------------------------------------------------------
    # Private endpoints
    # ------------------------------------------------------------------
    def _private_request(
        self,
        method: str,
        path: str,
        *,
        params: Optional[Dict[str, Any]] = None,
        body: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        method = method.upper()
        ts = self._ms()

        if method in ("GET", "DELETE"):
            qs = self._urlencode_sorted(params or {})
            req_path = path + (f"?{qs}" if qs else "")
            sig = self._sign(f"{ts}{method}{req_path}")
            headers = self._headers(sig, ts)
            url = f"{self.base}{req_path}"
            r = self.requests.request(method, url, headers=headers, timeout=20)
        elif method == "POST":
            qs = self._urlencode_sorted(params or {})
            req_path = path + (f"?{qs}" if qs else "")
            body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
            sig = self._sign(f"{ts}{method}{req_path}{body_str}")
            headers = self._headers(sig, ts)
            url = f"{self.base}{req_path}"
            r = self.requests.post(
                url,
                data=body_str.encode("utf-8"),
                headers=headers,
                timeout=20,
            )
        else:
            raise ValueError("M\u00e9thode non support\u00e9e")

        resp_text = getattr(r, "text", "")
        try:
            data = r.json()
        except Exception:
            data = {
                "success": False,
                "error": resp_text,
                "status_code": getattr(r, "status_code", None),
            }

        status = getattr(r, "status_code", 0)
        if status >= 400:
            code = str(data.get("code")) if isinstance(data, dict) else ""
            if code == "22001":
                logging.info("Aucun ordre à annuler (%s %s)", method, path)
            else:
                try:
                    r.raise_for_status()
                except Exception as e:
                    if not resp_text:
                        resp_text = getattr(r, "text", "") or str(e)
                logging.error(
                    "Erreur HTTP/JSON %s %s -> %s %s",
                    method,
                    path,
                    status,
                    resp_text,
                )
                if isinstance(data, dict):
                    data.setdefault("success", False)
                    data.setdefault("status_code", status)
                    data.setdefault("error", resp_text)

        self.log_event(
            "http_private",
            {"method": method, "path": path, "params": params, "body": body, "response": data},
        )
        return data

    # Accounts & positions -------------------------------------------------
    def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {
                "success": True,
                "code": 0,
                "data": [
                    {
                        "currency": "USDT",
                        "equity": 100.0,
                    }
                ],
            }

        params = {"productType": self.product_type}
        if margin_coin is None:
            margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
        if margin_coin:
            params["marginCoin"] = margin_coin
        data = self._private_request(
            "GET", "/api/v2/mix/account/accounts", params=params
        )
        if isinstance(data, dict):
            data.setdefault("success", str(data.get("code")) == "00000")
        try:
            for row in data.get("data", []):
                if "currency" not in row and row.get("marginCoin"):
                    row["currency"] = str(row["marginCoin"]).upper()
                chosen = None
                for key in ("available", "cashBalance", "equity", "usdtEquity"):
                    val = row.get(key)
                    if val is not None:
                        chosen = val
                        break
                if chosen is not None:
                    row["equity"] = chosen
                try:
                    row["equity"] = float(row["equity"])
                except Exception:
                    pass
        except Exception:  # pragma: no cover - best effort
            pass
        return data

    def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {"success": True, "code": 0, "data": []}
        data = self._private_request(
            "GET",
            "/api/v2/mix/position/all-position",
            params={"productType": self._product_type(product_type)},
        )
        try:
            positions = data.get("data", [])
            filtered = []
            for pos in positions:
                vol = pos.get("vol")
                try:
                    if vol is not None and float(vol) > 0:
                        filtered.append(pos)
                except (TypeError, ValueError):
                    continue
            data["data"] = filtered
        except Exception:  # pragma: no cover - best effort
            pass
        return data

    def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {"success": True, "code": 0, "data": []}
        params: Dict[str, Any] = {"productType": self.product_type}
        if symbol:
            params["symbol"] = self._format_symbol(symbol)
        return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)

    # Account configuration -------------------------------------------------
    def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
        body = {
            "productType": self._product_type(product_type),
            "symbol": self._format_symbol(symbol),
            "posMode": "one_way_mode",
        }
        return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)

    def set_leverage(
        self,
        symbol: str,
        product_type: Optional[str] = None,
        margin_coin: str = "USDT",
        leverage: int = 1,
    ) -> Dict[str, Any]:
        body = {
            "symbol": self._format_symbol(symbol),
            "productType": self._product_type(product_type),
            "marginCoin": margin_coin,
            "leverage": int(leverage),
        }
        return self._private_request(
            "POST", "/api/v2/mix/account/set-leverage", body=body
        )

    def place_market_order_one_way(
        self,
        symbol: str,
        side: str,
        size: float,
        product_type: Optional[str] = None,
        margin_coin: str = "USDT",
        *,
        time_in_force: str = "normal",
    ) -> Dict[str, Any]:
        side = side.lower()
        if side not in {"buy", "sell"}:
            raise ValueError("side must be 'buy' or 'sell'")
        body = {
            "symbol": self._format_symbol(symbol),
            "productType": self._product_type(product_type),
            "marginCoin": margin_coin,
            "marginMode": "crossed",
            "posMode": "one_way_mode",
            "orderType": "market",
            "side": side,
            "size": str(size),
            "timeInForceValue": time_in_force,
            "clientOid": str(uuid.uuid4())[:32],
        }
        return self._private_request(
            "POST", "/api/v2/mix/order/place-order", body=body
        )

    # Orders ---------------------------------------------------------------
    def place_order(
        self,
        symbol: str,
        side: int,
        vol: int,
        order_type: int,
        *,
        price: Optional[float] = None,
        open_type: int = 1,
        leverage: Optional[int] = None,
        position_id: Optional[int] = None,
        external_oid: Optional[str] = None,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
        position_mode: Optional[int] = None,
        margin_coin: Optional[str] = None,
        time_in_force: str = "normal",
    ) -> Dict[str, Any]:
        """Submit an order.

        This helper keeps backward compatibility with the older numeric
        parameters used by the bot while translating them to the string based
        fields required by Bitget's v2 API.
        """
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
                side,
                vol,
                order_type,
                price,
            )
            return {
                "success": True,
                "paperTrade": True,
                "simulated": {
                    "symbol": symbol,
                    "side": side,
                    "vol": vol,
                    "type": order_type,
                    "price": price,
                    "openType": open_type,
                    "leverage": leverage,
                    "stopLossPrice": stop_loss,
                    "takeProfitPrice": take_profit,
                },
            }

        # ------------------------------------------------------------------
        # Parameter mapping
        # ------------------------------------------------------------------
        side_map = {
            1: ("buy", "long"),
            2: ("buy", "short"),
            3: ("sell", "short"),
            4: ("sell", "long"),
        }
        if isinstance(side, int):
            mapped = side_map.get(side)
            if not mapped:
                raise ValueError(f"Invalid side value: {side}")
            side_str, pos_side = mapped
        else:
            side_str = str(side)
            pos_side = None

        order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
        if isinstance(order_type, int):
            order_str = order_map.get(order_type)
            if order_str is None:
                order_str = "limit" if price is not None else "market"
        else:
            order_str = str(order_type)

        margin_mode = "crossed" if int(open_type) == 1 else "isolated"

        if margin_coin is None:
            margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)

        # ------------------------------------------------------------------
        # Precision handling
        # ------------------------------------------------------------------
        try:
            price_place, volume_place = self._get_contract_precision(symbol)
        except Exception:  # pragma: no cover - best effort
            price_place = volume_place = 0
        if price is not None:
            price = round(float(price), price_place)
        if vol is not None:
            vol = round(float(vol), volume_place)

        body = {
            "symbol": self._format_symbol(symbol),
            "productType": self.product_type,
            "marginMode": margin_mode,
            "orderType": order_str,
            "side": side_str,
            "size": vol,
            "timeInForceValue": time_in_force,
        }
        if pos_side is not None:
            body["posSide"] = pos_side
        if margin_coin:
            body["marginCoin"] = margin_coin
        if price is not None:
            body["price"] = float(price)
        if leverage is not None:
            body["leverage"] = int(leverage)
        if position_id is not None:
            body["positionId"] = int(position_id)
        if external_oid:
            body["clientOid"] = str(external_oid)[:32]
        else:
            body["clientOid"] = str(uuid.uuid4())[:32]
        if stop_loss is not None:
            body["stopLossPrice"] = float(stop_loss)
        if take_profit is not None:
            body["takeProfitPrice"] = float(take_profit)
        if position_mode is not None:
            body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
        elif pos_side is not None:
            body["posMode"] = "hedge_mode"

        return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)

    def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
            )
            return {"success": True, "code": 0}
        return self._private_request(
            "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
        )

    def cancel_all(
        self,
        symbol: Optional[str] = None,
        margin_coin: Optional[str] = None,
    ) -> Dict[str, Any]:
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> annulation simulée de tous les ordres"
            )
            return {"success": True, "code": 0}
        body = {"productType": self.product_type}
        if symbol:
            body["symbol"] = self._format_symbol(symbol)
        if margin_coin is None:
            margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
        if margin_coin:
            body["marginCoin"] = margin_coin
        return self._private_request(
            "POST", "/api/v2/mix/order/cancel-all-orders", body=body
        )

    def close_position(
        self,
        symbol: str,
        size: Optional[int] = None,
        hold_side: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Close an open position for ``symbol``.

        Parameters
        ----------
        symbol:
            Trading symbol to close.
        size:
            Optional number of contracts to close. If omitted the entire
            position is closed.
        hold_side:
            Optional side (``"long"``/``"short"``) to close when ``size`` is
            specified. If not provided the exchange will infer it.
        """

        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
            )
            return {"success": True, "code": 0}

        body = {"symbol": self._format_symbol(symbol)}
        if size is not None:
            body["size"] = int(size)
        if hold_side:
            body["holdSide"] = hold_side

        body["productType"] = self.product_type
        return self._private_request(
            "POST", "/api/v2/mix/position/close-position", body=body
        )

    def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
        """Close all open positions."""
        results = []
        try:
            for pos in self.get_positions(product_type).get("data", []):
                sym = pos.get("symbol")
                if sym:
                    results.append(self.close_position(sym))
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Erreur fermeture de toutes les positions: %s", exc)
        return {"success": True, "data": results}


## scalp/bot_config.py (last modified: 2025-08-22 07:05:27)
import os


DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"

CONFIG = {
    "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
    or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
    "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
    or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
    "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
    "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
    "SYMBOL": DEFAULT_SYMBOL,
    "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
    "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
    "INTERVAL": os.getenv("INTERVAL", "1m"),
    "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
    "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
    "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
    "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
    "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
    "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
    "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
    "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
    "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
    "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
    "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
    "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
    "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
    "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
    "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
    "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
    "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
    "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
    "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
    "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
    "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
    # --- Sécurité / Sizing -------------------------------------------------
    "ALLOWED_SYMBOLS": [
        s.strip().upper()
        for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
        if s.strip()
    ],
    "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
    "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
    "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
    "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
    "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
    "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
    "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
    "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
    "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
}



## scalp/client.py (last modified: 2025-08-22 07:05:27)
import logging
from typing import Any, Dict, Optional

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class HTTPError(RuntimeError):
    """Raised when an HTTP request fails"""


class HttpClient:
    """Simple HTTP client with persistent session and retry logic.

    The client exposes a :py:meth:`close` method and implements the context
    manager protocol so it can be used with ``with`` statements to ensure
    that the underlying :class:`requests.Session` is properly closed.
    """

    def __init__(
        self,
        base_url: str,
        *,
        timeout: float = 10.0,
        max_retries: int = 3,
        backoff_factor: float = 0.3,
        status_forcelist: Optional[list[int]] = None,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.session = requests.Session()
        retry = Retry(
            total=max_retries,
            backoff_factor=backoff_factor,
            status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
            allowed_methods=[
                "HEAD",
                "GET",
                "OPTIONS",
                "POST",
                "PUT",
                "DELETE",
                "PATCH",
            ],
        )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

    def close(self) -> None:
        """Close the underlying :class:`requests.Session`."""
        self.session.close()

    # ------------------------------------------------------------------
    # Context manager support
    # ------------------------------------------------------------------
    def __enter__(self) -> "HttpClient":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
        self.close()

    def request(
        self,
        method: str,
        path: str,
        *,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """Perform an HTTP request and return JSON data.

        Errors during the request raise ``HTTPError``. If the response cannot
        be decoded as JSON, a dictionary describing the issue is returned.
        """
        url = f"{self.base_url}{path}"
        try:
            resp = self.session.request(
                method,
                url,
                params=params,
                json=json,
                headers=headers,
                timeout=self.timeout,
            )
            resp.raise_for_status()
        except requests.RequestException as exc:  # network or HTTP errors
            msg = f"HTTP error calling {url}: {exc}"
            logging.error(msg)
            raise HTTPError(msg) from exc

        try:
            return resp.json()
        except ValueError:  # invalid JSON
            msg = "Invalid JSON in response"
            logging.error("%s for %s: %s", msg, url, resp.text)
            return {"success": False, "error": msg, "text": resp.text}


## scalp/config.py (last modified: 2025-08-22 12:29:12)
from __future__ import annotations
from pydantic import BaseModel, Field, ValidationError
import os, sys


class AppConfig(BaseModel):
    BITGET_API_KEY: str = Field(..., min_length=10)
    BITGET_API_SECRET: str = Field(..., min_length=10)
    BITGET_PASSPHRASE: str = Field(..., min_length=3)
    RISK_PCT: float = Field(0.01, ge=0.0, le=0.05)
    MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
    LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
    PAPER_TRADE: bool = Field(True)


def load_or_exit() -> AppConfig:
    try:
        return AppConfig(
            BITGET_API_KEY=os.environ.get("BITGET_API_KEY"),
            BITGET_API_SECRET=os.environ.get("BITGET_API_SECRET"),
            BITGET_PASSPHRASE=os.environ.get("BITGET_PASSPHRASE"),
            RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
            MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
            LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
            PAPER_TRADE=os.environ.get("PAPER_TRADE", "true").lower() in ("1","true","yes"),
        )
    except ValidationError as e:
        print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
        sys.exit(2)


## scalp/logging_utils.py (last modified: 2025-08-22 07:05:27)
"""Logging helpers for the Scalp bot."""

from __future__ import annotations

import atexit
import csv
import json
import os
import sqlite3
import time
from pathlib import Path
from typing import Any, Dict, List


def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    """Return a callable that logs events as JSON lines.

    Parameters
    ----------
    path: str
        Target file path for JSON lines.
    max_bytes: int, optional
        If >0, rotate the file when its size exceeds this value.
    backup_count: int, optional
        Number of rotated files to keep when ``max_bytes`` is set.
    """
    os.makedirs(os.path.dirname(path), exist_ok=True)
    log_file = open(path, "a", encoding="utf-8")

    def _close_file() -> None:
        try:
            log_file.close()
        except Exception:
            pass

    atexit.register(_close_file)

    def _rotate() -> None:
        nonlocal log_file
        log_file.close()
        for i in range(backup_count - 1, 0, -1):
            src = f"{path}.{i}"
            dst = f"{path}.{i + 1}"
            if os.path.exists(src):
                os.replace(src, dst)
        os.replace(path, f"{path}.1")
        log_file = open(path, "a", encoding="utf-8")

    def _log(event: str, payload: Dict[str, Any]) -> None:
        nonlocal log_file
        payload = dict(payload or {})
        payload["event"] = event
        payload["ts"] = int(time.time() * 1000)
        line = json.dumps(payload, ensure_ascii=False)
        if max_bytes and backup_count > 0:
            if log_file.tell() + len(line) + 1 > max_bytes:
                _rotate()
        log_file.write(line + "\n")
        log_file.flush()

    return _log


class TradeLogger:
    """Helper writing trade information to CSV and SQLite files."""

    fields = [
        "pair",
        "tf",
        "dir",
        "entry",
        "sl",
        "tp",
        "score",
        "reasons",
        "pnl",
    ]

    def __init__(self, csv_path: str, sqlite_path: str) -> None:
        os.makedirs(os.path.dirname(csv_path), exist_ok=True)
        self.csv_path = csv_path
        self.sqlite_path = sqlite_path

        # Ensure CSV has header
        if not os.path.exists(csv_path):
            with open(csv_path, "w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=self.fields)
                writer.writeheader()

        # Setup SQLite store
        self.conn = sqlite3.connect(sqlite_path)
        cur = self.conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS trades (
                pair TEXT,
                tf TEXT,
                dir TEXT,
                entry REAL,
                sl REAL,
                tp REAL,
                score REAL,
                reasons TEXT,
                pnl REAL
            )
            """
        )
        self.conn.commit()
        atexit.register(self.conn.close)

    def log(self, data: Dict[str, Any]) -> None:
        row = {k: data.get(k) for k in self.fields}
        with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=self.fields)
            writer.writerow(row)
        cur = self.conn.cursor()
        cur.execute(
            "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                row["pair"],
                row["tf"],
                row["dir"],
                row["entry"],
                row["sl"],
                row["tp"],
                row["score"],
                row["reasons"],
                row["pnl"],
            ),
        )
        self.conn.commit()


BASE_DIR = Path(__file__).resolve().parents[2]


def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
    """Append a row to ``path`` creating the file with ``fields`` if needed."""
    path.parent.mkdir(parents=True, exist_ok=True)
    file_exists = path.exists()
    with path.open("a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fields)
        if not file_exists:
            writer.writeheader()
        writer.writerow({k: row.get(k) for k in fields})


def log_position(data: Dict[str, Any]) -> None:
    """Log a closed position to ``../positions.csv``."""
    fields = [
        "timestamp",
        "pair",
        "direction",
        "entry",
        "exit",
        "pnl_pct",
        "fee_rate",
        "notes",
    ]
    _append_csv(BASE_DIR / "positions.csv", fields, data)


def log_operation_memo(data: Dict[str, Any]) -> None:
    """Log operation details to ``../operations_memo.csv``."""
    fields = ["timestamp", "pair", "details"]
    _append_csv(BASE_DIR / "operations_memo.csv", fields, data)


## scalp/metrics.py (last modified: 2025-08-22 07:05:27)
"""Utility metrics for trading calculations."""

from __future__ import annotations


from typing import Iterable

__all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]


def calc_pnl_pct(
    entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
) -> float:
    """Return percentage PnL between entry and exit prices minus fees.


    Parameters
    ----------
    entry_price: float
        Trade entry price (>0).
    exit_price: float
        Trade exit price (>0).
    side: int
        +1 for long, -1 for short.
    fee_rate: float, optional
        Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
        applied twice (entry + exit).
    """
    if entry_price <= 0 or exit_price <= 0:
        raise ValueError("Prices must be positive")
    if side not in (1, -1):
        raise ValueError("side must be +1 (long) or -1 (short)")

    pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
    return pnl - fee_pct


def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    """Compute the Relative Strength Index (RSI) using Wilder's smoothing.


    Parameters
    ----------
    prices:
        Ordered sequence of closing prices.
    period:
        Number of periods to use for the calculation. Must be positive and the
        length of ``prices`` must be at least ``period + 1``.
    """

    prices_list = [float(p) for p in prices]

    if period <= 0:
        raise ValueError("period must be positive")
    if len(prices_list) < period + 1:

        raise ValueError("len(prices) must be >= period + 1")

    gains: list[float] = []
    losses: list[float] = []
    for i in range(1, period + 1):

        diff = prices_list[i] - prices_list[i - 1]

        if diff >= 0:
            gains.append(diff)
            losses.append(0.0)
        else:
            gains.append(0.0)
            losses.append(-diff)

    avg_gain = sum(gains) / period
    avg_loss = sum(losses) / period

    for i in range(period + 1, len(prices_list)):
        diff = prices_list[i] - prices_list[i - 1]

        gain = max(diff, 0.0)
        loss = max(-diff, 0.0)
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period

    if avg_gain == 0 and avg_loss == 0:
        return 50.0
    if avg_loss == 0:
        return 100.0
    if avg_gain == 0:
        return 0.0
    rs = avg_gain / avg_loss
    return 100.0 - (100.0 / (1.0 + rs))


def calc_atr(
    highs: Iterable[float],
    lows: Iterable[float],
    closes: Iterable[float],
    period: int = 14,
) -> float:
    """Compute the Average True Range (ATR) using Wilder's smoothing.


    Parameters
    ----------
    highs, lows, closes:
        Ordered sequences of high, low and close prices. All sequences must
        have the same length and contain at least ``period + 1`` elements.
    period:
        Number of periods to use for the calculation. Must be positive.
    """

    highs_list = [float(h) for h in highs]
    lows_list = [float(low) for low in lows]
    closes_list = [float(c) for c in closes]

    length = len(highs_list)
    if length != len(lows_list) or length != len(closes_list):

        raise ValueError("Input sequences must have the same length")
    if period <= 0:
        raise ValueError("period must be positive")
    if length < period + 1:
        raise ValueError("Input sequences must have at least period + 1 elements")

    trs: list[float] = []
    for i in range(1, len(highs_list)):
        tr = max(
            highs_list[i] - lows_list[i],
            abs(highs_list[i] - closes_list[i - 1]),
            abs(lows_list[i] - closes_list[i - 1]),
        )
        trs.append(tr)

    atr = sum(trs[:period]) / period
    for tr in trs[period:]:
        atr = (atr * (period - 1) + tr) / period
    return atr


def calc_macd(
    prices: Sequence[float],
    fast: int = 12,
    slow: int = 26,
    signal: int = 9,
) -> tuple[float, float, float]:
    """Return MACD, signal line and histogram values.

    The implementation computes exponential moving averages using Wilder's
    smoothing. ``prices`` must contain at least ``slow + signal`` elements.
    """

    prices_list = [float(p) for p in prices]
    if fast <= 0 or slow <= 0 or signal <= 0:
        raise ValueError("periods must be positive")
    min_len = max(fast, slow) + signal
    if len(prices_list) < min_len:
        raise ValueError("len(prices) must be >= slow + signal")

    def _ema_series(series: Sequence[float], window: int) -> list[float]:
        k = 2.0 / (window + 1.0)
        out = [float(series[0])]
        for x in series[1:]:
            out.append(float(x) * k + out[-1] * (1.0 - k))
        return out

    fast_ema = _ema_series(prices_list, fast)
    slow_ema = _ema_series(prices_list, slow)
    macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
    signal_series = _ema_series(macd_series, signal)
    macd_val = macd_series[-1]
    signal_val = signal_series[-1]
    hist = macd_val - signal_val
    return macd_val, signal_val, hist


def backtest_position(
    prices: list[float], entry_idx: int, exit_idx: int, side: int
) -> bool:
    """Run a basic backtest to verify a position's coherence.

    Parameters
    ----------
    prices: list[float]
        Sequential list of prices to evaluate.
    entry_idx: int
        Index in ``prices`` where the position is opened.
    exit_idx: int
        Index in ``prices`` where the position is closed (must be > ``entry_idx``).
    side: int
        +1 for long, -1 for short.

    Returns
    -------
    bool
        ``True`` if the resulting PnL is non-negative, meaning the position is
        coherent with the direction of price movement. ``False`` otherwise.
    """
    if side not in (1, -1):
        raise ValueError("side must be +1 (long) or -1 (short)")
    if not (0 <= entry_idx < exit_idx < len(prices)):
        raise ValueError(
            "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
        )

    entry_price = float(prices[entry_idx])
    exit_price = float(prices[exit_idx])
    pnl = calc_pnl_pct(entry_price, exit_price, side)
    return pnl >= 0.0


## scalp/notifier.py (last modified: 2025-08-22 12:29:12)
"""Simple notifier for bot events."""

from __future__ import annotations

import logging
import os
from typing import Any, Dict

try:  # pragma: no cover - guarded import for optional dependency
    import requests as _requests

    # ``requests`` may be provided as a stub during tests. Ensure it exposes a
    # ``post`` attribute so callers can monkeypatch it reliably.
    if not hasattr(_requests, "post"):
        raise ImportError
    requests = _requests
except Exception:  # pragma: no cover - fallback when ``requests`` is missing

    class _Requests:
        """Minimal stand‑in for :mod:`requests` when the real library is absent."""

        def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
            raise RuntimeError("requests.post unavailable")

    requests = _Requests()  # type: ignore[assignment]


def _pair_name(symbol: str) -> str:
    """Return a human friendly pair name without the base ``USDT``."""
    if "_" in symbol:
        base, quote = symbol.split("_", 1)
    elif symbol.endswith("USDT"):
        base, quote = symbol[:-4], "USDT"
    else:
        base, quote = symbol, ""
    if not quote or quote == "USDT":
        return base
    return f"{base}/{quote}"


def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
    """Format a position open/close payload."""

    side = payload.get("side")
    symbol = payload.get("symbol")
    if symbol:
        symbol = _pair_name(symbol)

    if event == "position_opened":
        rc = payload.get("risk_color", "")
        head = f"{rc} Ouvre {side} {symbol}".strip()
        lines = [head]
        lines.append(
            f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
        )
        lines.append(
            "Marge estimée: {} USDT (dispo: {} USDT)".format(
                payload.get("required_margin_usdt"), payload.get("available_usdt")
            )
        )
        lines.append(
            "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
                payload.get("signal_level"),
                payload.get("risk_level_user"),
                float(payload.get("risk_pct_eff", 0.0)) * 100,
            )
        )
        lines.append(
            "Prix: {}   Vol: {} (cs={})".format(
                payload.get("price"),
                payload.get("vol"),
                payload.get("contract_size"),
            )
        )
        return "\n".join(lines)

    # position_closed
    rc = payload.get("risk_color", "")
    head = f"Ferme {side} {symbol} {rc}".strip()
    lines = [head]
    pnl_usdt = payload.get("pnl_usdt")
    fees = payload.get("fees_usdt")
    if pnl_usdt is not None and fees is not None:
        lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
    pct = payload.get("pnl_pct_on_margin")
    if pct is not None:
        lines.append(f"% sur marge: {pct:.2f}%")
    lines.append(
        "Entrée: {}  Sortie: {}".format(
            payload.get("entry_price"), payload.get("exit_price")
        )
    )
    lines.append(
        "Vol: {}  Notional: in {} → out {} USDT".format(
            payload.get("vol"),
            payload.get("notional_entry_usdt"),
            payload.get("notional_exit_usdt"),
        )
    )
    return "\n".join(lines)


def _format_pair_list(payload: Dict[str, Any]) -> str:
    """Format the pair list payload.

    The detailed pair listing is intentionally hidden from terminal output to
    reduce noise. Only an acknowledgement message is returned.
    """

    return "Listing ok"


def _format_generic(event: str, payload: Dict[str, Any]) -> str:
    text = event
    if payload:
        items = "\n".join(f"{k}={v}" for k, v in payload.items())
        text = f"{text}\n{items}"
    return text


def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
    """Return a human readable text describing the event payload."""
    payload = payload or {}
    if event in {"position_opened", "position_closed"}:
        return _format_position_event(event, payload)
    if event == "pair_list":
        return _format_pair_list(payload)
    if event == "bot_started":
        return "🤖 Bot démarré"
    return _format_generic(event, payload)


def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
    """Send an event payload to configured endpoints.

    Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
    and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
    ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
    ignored so they do not interrupt the bot's execution.
    """

    data = {"event": event}
    if payload:
        data.update(payload)

    # Generic HTTP webhook
    url = os.getenv("NOTIFY_URL")
    if url:
        try:
            requests.post(url, json=data, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort only
            logging.error("Notification error for %s: %s", event, exc)

    # Telegram notification
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    # ``pair_list`` notifications are intentionally not forwarded to Telegram
    if token and chat_id and event != "pair_list":
        text = _format_text(event, payload or {})
        t_url = f"https://api.telegram.org/bot{token}/sendMessage"
        t_payload = {"chat_id": chat_id, "text": text}
        try:  # pragma: no cover - network
            requests.post(t_url, json=t_payload, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort only
            logging.error("Telegram notification error for %s: %s", event, exc)


## scalp/pairs.py (last modified: 2025-08-22 12:29:12)
"""Utilities to select trading pairs and detect signals."""
from __future__ import annotations
from typing import Any, Dict, List, Optional, Callable
from scalp.strategy import Signal

from scalp.bot_config import CONFIG
from scalp.strategy import ema as default_ema, cross as default_cross
from scalp.notifier import notify


def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    """Return all trading pairs using the client's ``get_ticker`` method."""
    tick = client.get_ticker()
    data = tick.get("data") if isinstance(tick, dict) else []
    if not data:
        return []
    return data if isinstance(data, list) else [data]


def filter_trade_pairs(
    client: Any,
    *,
    volume_min: float = 5_000_000,
    max_spread_bps: float = 5.0,
    top_n: int = 40,
) -> List[Dict[str, Any]]:
    """Filter pairs by volume and spread."""
    pairs = get_trade_pairs(client)
    eligible: List[Dict[str, Any]] = []

    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        try:
            vol = float(info.get("volume", 0))
        except (TypeError, ValueError):
            continue
        if vol < volume_min:
            continue
        try:
            bid = float(info.get("bidPrice", 0))
            ask = float(info.get("askPrice", 0))
        except (TypeError, ValueError):
            continue
        if bid <= 0 or ask <= 0:
            continue
        spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
        if spread_bps >= max_spread_bps:
            continue
        eligible.append(info)

    eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    return eligible[:top_n]


def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
    """Return ``top_n`` pairs sorted by ``key``."""
    pairs = get_trade_pairs(client)

    def volume(row: Dict[str, Any]) -> float:
        try:
            return float(row.get(key, 0))
        except (TypeError, ValueError):
            return 0.0

    pairs.sort(key=volume, reverse=True)
    return pairs[:top_n]


def _ancienne_impl(
    client: Any,
    pairs: List[Dict[str, Any]],
    *,
    interval: str = "1m",
    ema_fast_n: Optional[int] = None,
    ema_slow_n: Optional[int] = None,
    ema_func=default_ema,
    cross_func=default_cross,
) -> List[Dict[str, Any]]:
    """Original implementation returning dicts."""
    ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    results: List[Dict[str, Any]] = []

    for info in pairs:
        symbol = info.get("symbol")
        if not symbol:
            continue
        k = client.get_kline(symbol, interval=interval)
        closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
        if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
            continue
        efull = ema_func(closes, ema_fast_n)
        eslow = ema_func(closes, ema_slow_n)
        signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
        if signal == 1:
            price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
            results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
        elif signal == -1:
            price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
            results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
    return results


def _to_signal(d: dict) -> Signal:
    side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
    return Signal(
        symbol=d.get("symbol"),
        side=side,
        entry=float(d.get("price", d.get("entry", 0))),
        sl=float(d.get("sl", 0)),
        tp1=float(d.get("tp1", 0)) or None,
        tp2=float(d.get("tp2", 0)) or None,
        score=d.get("score"),
        quality=d.get("quality"),
        reasons=d.get("reasons", []),
    )


def find_trade_positions(
    client: Any,
    pairs: List[Dict[str, Any]],
    *,
    interval: str = "1m",
    ema_fast_n: Optional[int] = None,
    ema_slow_n: Optional[int] = None,
    ema_func=default_ema,
    cross_func=default_cross,
) -> List[Signal]:
    raw = _ancienne_impl(
        client,
        pairs,
        interval=interval,
        ema_fast_n=ema_fast_n,
        ema_slow_n=ema_slow_n,
        ema_func=ema_func,
        cross_func=cross_func,
    )
    return [_to_signal(x) for x in raw]


def send_selected_pairs(
    client: Any,
    top_n: int = 40,
    *,
    select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
    notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
) -> Dict[str, str]:
    """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.

    Returns the payload sent to ``notify_fn``. The mapping contains the
    comma-separated symbols for each color group (``green``, ``orange`` and
    ``red``) or an empty dictionary when no pairs are available.
    """

    def split_symbol(sym: str) -> tuple[str, str]:
        if "_" in sym:
            left, right = sym.split("_", 1)
            # Legacy style: BTC_USDT
            if len(right) <= 4:
                return left, right
            # Bitget futures style: BTCUSDT_UMCBL
            main = left
            if main.endswith("USDT"):
                return main[:-4], "USDT"
            if main.endswith("USDC"):
                return main[:-4], "USDC"
            if main.endswith("USD"):
                return main[:-3], "USD"
            return main, ""
        if sym.endswith("USDT"):
            return sym[:-4], "USDT"
        if sym.endswith("USDC"):
            return sym[:-4], "USDC"
        if sym.endswith("USD"):
            return sym[:-3], "USD"
        return sym, ""

    pairs = select_fn(client, top_n=top_n * 3)
    allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
    by_base: Dict[str, Dict[str, Any]] = {}
    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        norm_sym = sym.split("_")[0].upper()
        if allowed and norm_sym not in allowed:
            continue
        base, quote = split_symbol(sym)
        existing = by_base.get(base)
        priority = {"USDT": 3, "USDC": 2, "USD": 1}
        if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
            by_base[base] = {"data": info, "quote": quote}

    unique = sorted(
        (v["data"] for v in by_base.values()),
        key=lambda row: float(row.get("volume", 0)),
        reverse=True,
    )
    symbols: list[str] = []
    for row in unique[:top_n]:
        sym = row.get("symbol")
        if not sym:
            continue
        base, _ = split_symbol(sym)
        symbols.append(base)
    if symbols:
        n = len(symbols)
        third = max(n // 3, 1)
        green = symbols[:third]
        orange = symbols[third : 2 * third]
        red = symbols[2 * third :]
        payload: Dict[str, str] = {}
        if green:
            payload["green"] = ", ".join(green)
        if orange:
            payload["orange"] = ", ".join(orange)
        if red:
            payload["red"] = ", ".join(red)
        notify_fn("pair_list", payload)
        return payload
    return {}


def heat_score(volatility: float, volume: float, news: bool = False) -> float:
    """Return a heat score combining volatility, volume and a news flag."""
    mult = 2.0 if news else 1.0
    return volatility * volume * mult


def select_top_heat_pairs(
    pairs: List[Dict[str, Any]], *, top_n: int = 3
) -> List[Dict[str, Any]]:
    """Return ``top_n`` pairs ranked by ``heat_score``."""

    scored: List[Dict[str, Any]] = []
    for info in pairs:
        try:
            vol = float(info.get("volatility", 0))
            volume = float(info.get("volume", 0))
        except (TypeError, ValueError):
            continue
        score = heat_score(vol, volume, bool(info.get("news")))
        row = dict(info)
        row["heat_score"] = score
        scored.append(row)

    scored.sort(key=lambda r: r["heat_score"], reverse=True)
    return scored[:top_n]


def decorrelate_pairs(
    pairs: List[Dict[str, Any]],
    corr: Dict[str, Dict[str, float]],
    *,
    threshold: float = 0.8,
    top_n: int = 3,
) -> List[Dict[str, Any]]:
    """Return top pairs while avoiding highly correlated symbols.

    ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
    pairs are considered too correlated when the absolute value of the
    correlation exceeds ``threshold``.
    """

    selected: List[Dict[str, Any]] = []
    for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
        sym = info.get("symbol")
        if not sym:
            continue
        if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
            selected.append(info)
        if len(selected) >= top_n:
            break
    return selected


## scalp/risk/__init__.py (last modified: 2025-08-22 07:05:27)
"""Risk management utilities for position sizing."""

from __future__ import annotations

__all__ = ["calc_risk_amount", "calc_position_size", "adjust_risk_pct", "RiskManager"]


def calc_risk_amount(equity: float, risk_pct: float) -> float:
    """Return the monetary amount to risk on a trade.

    Parameters
    ----------
    equity: float
        Total account equity in quote currency.
    risk_pct: float
        Fraction of equity to risk (e.g. ``0.01`` for 1%). Must be in ``(0, 1]``.
    """
    if equity <= 0:
        raise ValueError("equity must be positive")
    if risk_pct <= 0 or risk_pct > 1:
        raise ValueError("risk_pct must be between 0 and 1")
    return equity * risk_pct


def calc_position_size(equity: float, risk_pct: float, stop_distance: float) -> float:
    """Compute position size given risk and stop distance.

    The size is ``risk_amount / stop_distance`` where ``risk_amount`` equals
    ``equity * risk_pct``.

    Parameters
    ----------
    equity: float
        Total account equity in quote currency.
    risk_pct: float
        Fraction of equity to risk (e.g. ``0.01`` for 1%).
    stop_distance: float
        Distance between entry price and stop-loss in quote currency.
        Must be positive.
    """
    if stop_distance <= 0:
        raise ValueError("stop_distance must be positive")
    risk_amount = calc_risk_amount(equity, risk_pct)
    return risk_amount / stop_distance


def adjust_risk_pct(
    risk_pct: float,
    win_streak: int,
    loss_streak: int,
    *,
    increase: float = 0.12,
    decrease: float = 0.25,
    min_pct: float = 0.001,
    max_pct: float = 0.05,
) -> float:
    """Return ``risk_pct`` adjusted by recent performance.

    After two consecutive winning trades the risk percentage is increased by
    ``increase`` (default 12%).  After two consecutive losses it is reduced by
    ``decrease`` (default 25%).  The result is bounded by ``min_pct`` and
    ``max_pct``.

    Parameters
    ----------
    risk_pct:
        Current risk fraction (e.g. ``0.01`` for 1%).  Must be positive.
    win_streak / loss_streak:
        Number of consecutive wins or losses.
    increase / decrease:
        Fractional adjustments applied when the respective streak is reached.
    min_pct / max_pct:
        Hard limits for the adjusted risk.
    """

    if risk_pct <= 0:
        raise ValueError("risk_pct must be positive")

    if win_streak >= 2:
        risk_pct *= 1.0 + increase
    if loss_streak >= 2:
        risk_pct *= 1.0 - decrease

    if risk_pct < min_pct:
        return min_pct
    if risk_pct > max_pct:
        return max_pct
    return risk_pct


# RiskManager lives in a separate module but is exported here for convenience.
from .manager import RiskManager  # noqa: E402  (import at end to avoid cycle)


## scalp/risk/manager.py (last modified: 2025-08-22 07:05:27)
"""Advanced risk management utilities.

This module provides the :class:`RiskManager` class which tracks trading
performance and adjusts risk exposure accordingly.  It also implements helper
methods for dynamic risk calculation and trailing stops.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional

from . import adjust_risk_pct


@dataclass
class RiskManager:
    """Utility class implementing kill switch, loss limits and risk scaling."""

    max_daily_loss_pct: float
    max_positions: int
    risk_pct: float
    aggressive: bool = False
    max_daily_profit_pct: Optional[float] = None
    min_risk_pct: float = 0.001
    max_risk_pct: float = 0.05

    def __post_init__(self) -> None:
        self.base_risk_pct = self.risk_pct
        self.reset_day()

    # ------------------------------------------------------------------
    # State management
    # ------------------------------------------------------------------
    def reset_day(self) -> None:
        """Reset daily counters at the start of a new session."""
        self.daily_pnl_pct = 0.0
        self.consecutive_losses = 0
        self.win_streak = 0
        self.loss_streak = 0
        self.kill_switch = False
        self.risk_pct = self.base_risk_pct

    # ------------------------------------------------------------------
    # Trade handling
    # ------------------------------------------------------------------
    def register_trade(self, pnl_pct: float) -> None:
        """Register the outcome of a closed trade.

        The method updates win/loss streaks, daily profit and loss counters and
        adjusts the internal risk percentage.  When the daily loss or profit
        thresholds are breached the ``kill_switch`` flag is activated.
        """
        if pnl_pct < 0:
            self.consecutive_losses += 1
            self.loss_streak += 1
            self.win_streak = 0
        else:
            self.consecutive_losses = 0
            self.win_streak += 1
            self.loss_streak = 0

        self.daily_pnl_pct += pnl_pct

        if self.daily_pnl_pct <= -self.max_daily_loss_pct:
            self.kill_switch = True
        if (
            self.max_daily_profit_pct is not None
            and self.daily_pnl_pct >= self.max_daily_profit_pct
        ):
            self.kill_switch = True

        # Update risk percentage based purely on streaks for the next trade
        self.risk_pct = adjust_risk_pct(
            self.risk_pct, self.win_streak, self.loss_streak
        )

    # Backwards compatibility with older API
    record_trade = register_trade

    # ------------------------------------------------------------------
    # Dynamic risk and trailing stop utilities
    # ------------------------------------------------------------------
    def dynamic_risk_pct(self, signal_quality: float, score: float) -> float:
        """Return a risk percentage adjusted for streaks and signal quality.

        ``signal_quality`` is expected to be in the ``[0, 1]`` range where higher
        values indicate better confidence.  ``score`` acts as a modifier in the
        ``[-1, 1]`` range and allows callers to further tweak the risk based on
        arbitrary logic.  The result is clamped between ``min_risk_pct`` and
        ``max_risk_pct`` and stored in :attr:`risk_pct` for convenience.
        """
        base = adjust_risk_pct(self.base_risk_pct, self.win_streak, self.loss_streak)
        quality = max(0.0, min(1.0, signal_quality))
        score = max(-1.0, min(1.0, score))
        pct = base * (1.0 + quality * score)
        pct = max(self.min_risk_pct, min(self.max_risk_pct, pct))
        self.risk_pct = pct
        return pct

    def apply_trailing(
        self,
        direction: int,
        price: float,
        sl: float,
        atr: float,
        params: Dict[str, float],
    ) -> float:
        """Return a new stop-loss based on trailing stop parameters.

        Parameters
        ----------
        direction:
            ``1`` for long positions and ``-1`` for short positions.
        price:
            Current market price.
        sl:
            Existing stop-loss level.
        atr:
            Current Average True Range value.
        params:
            Dictionary controlling the behaviour.  Supported keys are:
            ``type`` (``"atr"`` or ``"vwap"``).  For ``atr`` trailing the key
            ``atr_mult`` (or ``mult``) specifies the ATR multiplier.  For VWAP
            trailing provide ``vwap`` and optional ``buffer``.
        """
        method = params.get("type", "atr")
        new_sl = sl
        if method == "atr":
            mult = float(params.get("atr_mult", params.get("mult", 1.0)))
            if atr > 0 and mult > 0:
                distance = atr * mult
                if direction > 0:
                    candidate = price - distance
                    if candidate > sl:
                        new_sl = candidate
                else:
                    candidate = price + distance
                    if candidate < sl:
                        new_sl = candidate
        elif method == "vwap":
            vwap_val = params.get("vwap")
            if vwap_val is not None:
                buffer = float(params.get("buffer", 0.0))
                if direction > 0:
                    candidate = vwap_val - buffer
                    if candidate > sl:
                        new_sl = candidate
                else:
                    candidate = vwap_val + buffer
                    if candidate < sl:
                        new_sl = candidate
        return new_sl

    # ------------------------------------------------------------------
    # Misc helpers
    # ------------------------------------------------------------------
    def pause_duration(self) -> int:
        """Return seconds to pause after consecutive losses."""
        if self.consecutive_losses >= 5:
            return 60 * 60
        if self.consecutive_losses >= 3:
            return 15 * 60
        return 0

    def can_open(self, current_positions: int) -> bool:
        """Return whether a new position can be opened."""
        return (not self.kill_switch) and current_positions < self.max_positions


## scalp/selection/__init__.py (last modified: 2025-08-22 07:05:27)
"""Pair selection helpers for the Scalp bot.

This package exposes two utilities used during the preparation phase of the
trading strategy:

``scan_pairs``
    Performs the first level market scan by filtering pairs based on volume,
    spread and hourly volatility.

``select_active_pairs``
    Refines a list of pairs by keeping only those showing an EMA20/EMA50
    crossover and a sufficiently high ATR.
"""

from .scanner import scan_pairs
from .momentum import select_active_pairs

__all__ = ["scan_pairs", "select_active_pairs"]



## scalp/selection/momentum.py (last modified: 2025-08-22 07:05:27)
"""Utilities to select pairs exhibiting strong momentum."""

from __future__ import annotations

from typing import Any, Dict, List, Sequence

from ..metrics import calc_atr


def ema(series: Sequence[float], window: int) -> List[float]:
    """Simple exponential moving average implementation."""

    if window <= 1 or not series:
        return list(series)
    k = 2.0 / (window + 1.0)
    out: List[float] = [float(series[0])]
    prev = out[0]
    for x in series[1:]:
        prev = float(x) * k + prev * (1.0 - k)
        out.append(prev)
    return out


def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""

    if prev_fast <= prev_slow and last_fast > last_slow:
        return 1
    if prev_fast >= prev_slow and last_fast < last_slow:
        return -1
    return 0


def _quantile(values: Sequence[float], q: float) -> float:
    """Return the *q* quantile of *values* (0 <= q <= 1)."""

    if not values:
        return 0.0
    q = min(max(q, 0.0), 1.0)
    vals = sorted(values)
    idx = int((len(vals) - 1) * q)
    return vals[idx]


def select_active_pairs(
    client: Any,
    pairs: Sequence[Dict[str, Any]],
    *,
    interval: str = "Min5",
    ema_fast: int = 20,
    ema_slow: int = 50,
    atr_period: int = 14,
    atr_quantile: float = 0.5,
    top_n: int = 5,
) -> List[Dict[str, Any]]:
    """Return pairs with an EMA crossover and high ATR.

    Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    Among those candidates, the Average True Range is computed and only pairs
    whose ATR is above the provided quantile are returned.  The resulting
    dictionaries include an ``atr`` key for convenience.
    """

    candidates: List[Dict[str, Any]] = []
    atrs: List[float] = []

    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        k = client.get_kline(sym, interval=interval)
        kdata = k.get("data") if isinstance(k, dict) else {}
        closes = kdata.get("close", [])
        highs = kdata.get("high", [])
        lows = kdata.get("low", [])
        if len(closes) < max(ema_slow, atr_period) + 2:
            continue
        efast = ema(closes, ema_fast)
        eslow = ema(closes, ema_slow)
        if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
            continue
        atr_val = calc_atr(highs, lows, closes, atr_period)
        row = dict(info)
        row["atr"] = atr_val
        candidates.append(row)
        atrs.append(atr_val)

    if not candidates:
        return []

    threshold = _quantile(atrs, atr_quantile)
    selected = [row for row in candidates if row["atr"] >= threshold]
    selected.sort(key=lambda r: r["atr"], reverse=True)
    return selected[:top_n]


__all__ = ["select_active_pairs"]



## scalp/selection/scanner.py (last modified: 2025-08-22 07:05:27)
"""Utilities for scanning tradable pairs on the exchange."""

from __future__ import annotations

from typing import Any, Dict, List


def scan_pairs(
    client: Any,
    *,
    volume_min: float = 5_000_000,
    max_spread_bps: float = 5.0,
    min_hourly_vol: float = 0.0,
    top_n: int = 40,
) -> List[Dict[str, Any]]:
    """Return pairs satisfying basic liquidity and volatility filters.

    Parameters
    ----------
    client: Any
        Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    volume_min: float, optional
        Minimum 24h volume required to keep a pair.
    max_spread_bps: float, optional
        Maximum allowed bid/ask spread expressed in basis points.
    min_hourly_vol: float, optional
        Minimum volatility over the last hour expressed as ``(high - low) /
        close``.  When set to ``0`` the filter is disabled.
    top_n: int, optional
        Limit the number of returned pairs.
    """

    tick = client.get_ticker()
    data = tick.get("data") if isinstance(tick, dict) else []
    if not isinstance(data, list):
        data = [data]

    eligible: List[Dict[str, Any]] = []

    for row in data:
        sym = row.get("symbol")
        if not sym:
            continue
        try:
            vol = float(row.get("volume", 0))
            bid = float(row.get("bidPrice", 0))
            ask = float(row.get("askPrice", 0))
        except (TypeError, ValueError):
            continue
        if vol < volume_min or bid <= 0 or ask <= 0:
            continue
        spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
        if spread_bps >= max_spread_bps:
            continue

        if min_hourly_vol > 0:
            k = client.get_kline(sym, interval="Min60")
            kdata = k.get("data") if isinstance(k, dict) else {}
            highs = kdata.get("high", [])
            lows = kdata.get("low", [])
            closes = kdata.get("close", [])
            if not highs or not lows or not closes:
                continue
            try:
                h = float(highs[-1])
                l = float(lows[-1])
                c = float(closes[-1])
            except (TypeError, ValueError):
                continue
            hourly_vol = (h - l) / c if c else 0.0
            if hourly_vol < min_hourly_vol:
                continue

        eligible.append(row)

    eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    return eligible[:top_n]


__all__ = ["scan_pairs"]



## scalp/services/__init__.py (last modified: 2025-08-22 12:29:12)


## scalp/services/order_service.py (last modified: 2025-08-22 12:29:12)
from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, Optional, Protocol
from scalp.trade_utils import extract_available_balance


@dataclass
class OrderCaps:
    min_trade_usdt: float = 5.0
    leverage: float = 1.0


@dataclass
class OrderRequest:
    symbol: str
    side: str
    price: float
    sl: float
    tp: Optional[float]
    risk_pct: float


@dataclass
class OrderResult:
    accepted: bool
    reason: str = ""
    payload: Dict[str, Any] = None


class Exchange(Protocol):
    def get_assets(self) -> Dict[str, Any]: ...
    def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
    def place_order(
        self,
        symbol: str,
        side: str,
        quantity: float,
        order_type: str,
        price: Optional[float] = None,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
    ) -> Dict[str, Any]: ...


class OrderService:
    def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
        self.exchange = exchange
        self.caps = caps

    @staticmethod
    def _abs(x: float) -> float:
        return -x if x < 0 else x

    def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
        dist = self._abs(price - sl)
        if dist <= 0:
            return 0.0
        risk_usdt = max(0.0, equity_usdt * risk_pct)
        return 0.0 if price <= 0 else (risk_usdt / dist)

    def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
        qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
        if qty <= 0:
            return OrderResult(False, "invalid_size")
        notional = qty * req.price
        if notional < self.caps.min_trade_usdt:
            return OrderResult(False, "under_min_notional")
        assets = self.exchange.get_assets()
        available = extract_available_balance(assets)
        required_margin = notional / max(1.0, self.caps.leverage)
        if available < required_margin:
            return OrderResult(False, "insufficient_margin")
        side = "BUY" if req.side == "long" else "SELL"
        out = self.exchange.place_order(
            symbol=req.symbol,
            side=side,
            quantity=qty,
            order_type="limit",
            price=req.price,
            stop_loss=req.sl,
            take_profit=req.tp,
        )
        return OrderResult(True, "", out)


## scalp/strategy.py (last modified: 2025-08-22 12:29:12)
"""Core trading strategy components for scalping EMA/VWAP/RSI/ATR.

This module implements a minimal but functional version of the strategy
outlined in the project specification.  The focus is on pure Python
implementations so the logic can easily be unit tested without requiring
external services or heavy third‑party dependencies.

The strategy is deliberately stateless; functions operate on passed data and
return simple data structures.  This makes it easy to plug the logic into
real‑time trading loops or backtest engines.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Sequence, List, Dict, Optional, Tuple, Any

from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
from .risk import calc_position_size

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def ema(series: Sequence[float], window: int) -> List[float]:
    """Return the exponential moving average of *series*.

    The first value is the raw input to remain consistent with most trading
    platforms.  ``window`` must be positive; when it equals ``1`` the input is
    returned unchanged.
    """

    if window <= 1 or not series:
        return list(series)
    k = 2.0 / (window + 1.0)
    out: List[float] = [float(series[0])]
    prev = out[0]
    for x in series[1:]:
        prev = float(x) * k + prev * (1.0 - k)
        out.append(prev)
    return out

def vwap(highs: Sequence[float], lows: Sequence[float],
         closes: Sequence[float], volumes: Sequence[float]) -> float:
    """Compute the volume weighted average price (VWAP).

    Parameters
    ----------
    highs, lows, closes, volumes: Sequence[float]
        Matching sequences for the period considered.
    """

    tp_vol = 0.0
    vol_sum = 0.0
    for h, low, c, v in zip(highs, lows, closes, volumes):
        tp = (h + low + c) / 3.0
        tp_vol += tp * v
        vol_sum += v
    return tp_vol / vol_sum if vol_sum else 0.0

def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    """Return the On Balance Volume (OBV) series."""

    if not closes:
        return []
    out: List[float] = [0.0]
    for i in range(1, len(closes)):
        if closes[i] > closes[i - 1]:
            out.append(out[-1] + volumes[i])
        elif closes[i] < closes[i - 1]:
            out.append(out[-1] - volumes[i])
        else:
            out.append(out[-1])
    return out


def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    """Detect a crossing between two series.

    Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    ``0`` otherwise.
    """

    if prev_fast <= prev_slow and last_fast > last_slow:
        return 1
    if prev_fast >= prev_slow and last_fast < last_slow:
        return -1
    return 0


def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    """Compute order book imbalance.

    The value is normalised between ``-1`` and ``1`` where positive numbers
    indicate bid dominance.  ``0`` is returned when both volumes are zero.
    """

    total = bid_vol + ask_vol
    return (bid_vol - ask_vol) / total if total else 0.0


def swing_levels(
    highs: Sequence[float], lows: Sequence[float], lookback: int
) -> Tuple[float, float]:
    """Return the most recent swing high and swing low.

    ``lookback`` defines how many completed candles are inspected.  The current
    candle is excluded to avoid look‑ahead bias.
    """

    if len(highs) < lookback + 1 or len(lows) < lookback + 1:
        return highs[-1], lows[-1]
    high = max(highs[-lookback - 1 : -1])
    low = min(lows[-lookback - 1 : -1])
    return high, low

# ---------------------------------------------------------------------------
# Pair selection
# ---------------------------------------------------------------------------

# The first and second level pair selection helpers now live in
# :mod:`scalp.selection`.  They are re-exported here for backward compatibility
# and to keep the public API unchanged.
from .selection.scanner import scan_pairs  # noqa: E402
from .selection.momentum import select_active_pairs  # noqa: E402

# ---------------------------------------------------------------------------
# Signal generation
# ---------------------------------------------------------------------------

@dataclass
class Signal:
    """Trading signal with risk parameters."""

    symbol: str
    side: int  # 1 for long, -1 for short
    entry: float
    sl: float
    tp1: float
    tp2: float
    qty: float = 0.0
    score: Optional[float] = None
    quality: Optional[float] = None
    reasons: Optional[List[str]] = None

    def __post_init__(self) -> None:  # pragma: no cover - simple coercion
        if isinstance(self.side, str):
            self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1

    @property
    def price(self) -> float:
        return self.entry


def _generate_signal(
    symbol: str,
    ohlcv: Dict[str, Sequence[float]],
    *,
    equity: float,
    risk_pct: float,
    ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
    ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
    order_book: Optional[Dict[str, float]] = None,
    tick_ratio_buy: Optional[float] = None,
    atr_disable_pct: float = 0.2,
    atr_reduce_pct: float = 2.0,
    swing_lookback: int = 5,
    macd_fast: int = 12,
    macd_slow: int = 26,
    macd_signal: int = 9,
    trend_ema_period: int = 200,
) -> Optional[Signal]:
    """Return a trading :class:`Signal` if conditions are met.

    ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
    sequences ordered from oldest to newest.  The function checks the following
    rules:

    * price positioned relative to VWAP and EMA20/EMA50 trend
    * RSI(14) crossing key levels (40/60)
    * OBV rising or high short‑term volume
    * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
    * Micro‑structure breakout of last swing high/low
    * MACD trend filter
    * Long‑term trend via configurable EMA filter
    * Order book imbalance and tape filters
    * Dynamic ATR‑based stop‑loss and take‑profit
    * Position sizing via ``calc_position_size``
    """

    closes = [float(x) for x in ohlcv.get("close", [])]
    highs = [float(x) for x in ohlcv.get("high", [])]
    lows = [float(x) for x in ohlcv.get("low", [])]
    vols = [float(x) for x in ohlcv.get("volume", [])]
    if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
        return None

    price = closes[-1]
    ema20 = ema(closes, 20)
    ema50 = ema(closes, 50)
    ema_trend = ema(closes, trend_ema_period)
    v = vwap(highs, lows, closes, vols)
    obv_series = obv(closes, vols)
    obv_rising = obv_series[-1] > obv_series[-2]
    vol_last3 = sum(vols[-3:])
    vol_ma20 = sum(vols[-20:]) / 20.0
    vol_rising = vol_last3 > vol_ma20

    macd_val, macd_sig, _ = calc_macd(
        closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
    )

    # Multi timeframe filters -------------------------------------------------
    trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
    if ohlcv_1h:
        h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
        if len(h_closes) >= 52:
            h_ema50 = ema(h_closes, 50)
            if len(h_ema50) >= 2:
                slope = h_ema50[-1] - h_ema50[-2]
                if slope > 0:
                    trend_dir = 1
                elif slope < 0:
                    trend_dir = -1

    rsi_15 = None
    if ohlcv_15m:
        m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
        if len(m_closes) >= 15:
            rsi_15 = calc_rsi(m_closes, 14)

    # RSI crossing logic (5m)
    rsi_curr = calc_rsi(closes[-15:], 14)
    rsi_prev = calc_rsi(closes[-16:-1], 14)

    atr = calc_atr(highs, lows, closes, 14)
    atr_pct = atr / price * 100.0 if price else 0.0
    if atr_pct < atr_disable_pct:
        return None
    size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0

    sl_dist = 0.5 * atr
    tp1_dist = 1.0 * atr
    tp2_dist = 1.5 * atr

    swing_high, swing_low = swing_levels(highs, lows, swing_lookback)

    obi_ok_long = obi_ok_short = True
    if order_book is not None:
        bid = float(order_book.get("bid_vol_aggreg", 0))
        ask = float(order_book.get("ask_vol_aggreg", 0))
        obi = order_book_imbalance(bid, ask)
        obi_ok_long = obi > 0.1
        obi_ok_short = obi < -0.1

    tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
    tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45

    def _size(dist: float) -> float:
        return calc_position_size(equity, risk_pct, dist) * size_mult
    weights = {
        "ema": 15.0,
        "macd": 15.0,
        "vwap": 15.0,
        "rsi": 15.0,
        "obv": 10.0,
        "swing": 10.0,
        "atr": 20.0,
    }

    atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]

    long_score = atr_score
    long_reasons: List[str] = []
    if price > v:
        long_score += weights["vwap"]
        long_reasons.append("vwap")
    if ema20[-1] > ema50[-1]:
        long_score += weights["ema"]
        long_reasons.append("ema")
    if rsi_prev <= 40 < rsi_curr:
        long_score += weights["rsi"]
        long_reasons.append("rsi")
    if macd_val > macd_sig:
        long_score += weights["macd"]
        long_reasons.append("macd")
    if obv_rising or vol_rising:
        long_score += weights["obv"]
        long_reasons.append("obv")
    if price > swing_high:
        long_score += weights["swing"]
        long_reasons.append("swing")

    short_score = atr_score
    short_reasons: List[str] = []
    if price < v:
        short_score += weights["vwap"]
        short_reasons.append("vwap")
    if ema20[-1] < ema50[-1]:
        short_score += weights["ema"]
        short_reasons.append("ema")
    if rsi_prev >= 60 > rsi_curr:
        short_score += weights["rsi"]
        short_reasons.append("rsi")
    if macd_val < macd_sig:
        short_score += weights["macd"]
        short_reasons.append("macd")
    if obv_series[-1] < obv_series[-2] or vol_rising:
        short_score += weights["obv"]
        short_reasons.append("obv")
    if price < swing_low:
        short_score += weights["swing"]
        short_reasons.append("swing")

    side: Optional[str] = None
    score: float = 0.0
    reasons: List[str] = []
    if (
        long_score >= short_score
        and long_score > 0
        and macd_val > macd_sig
        and obi_ok_long
        and tick_ok_long
        and trend_dir >= 0
        and price > ema_trend[-1]
    ):
        side = "long"
        score = long_score
        reasons = long_reasons
        sl = price - sl_dist
        tp1 = price + tp1_dist
        tp2 = price + tp2_dist
    elif (
        short_score > long_score
        and short_score > 0
        and macd_val < macd_sig
        and obi_ok_short
        and tick_ok_short
        and trend_dir <= 0
        and price < ema_trend[-1]
    ):
        side = "short"
        score = short_score
        reasons = short_reasons
        sl = price + sl_dist
        tp1 = price - tp1_dist
        tp2 = price - tp2_dist
    else:
        return None

    qty = _size(sl_dist)
    return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)


def generate_signal(*args, **kwargs) -> Optional[Signal]:
    if "config" in kwargs:
        config = kwargs.pop("config")
        symbol = kwargs.pop("symbol", None)
        ohlcv = kwargs.pop("ohlcv", None)
        if ohlcv is None:
            raise TypeError("ohlcv argument required")
        return _generate_signal(
            symbol or ohlcv.get("symbol", ""),
            ohlcv,
            equity=kwargs.pop("equity", 0.0),
            risk_pct=getattr(config, "RISK_PCT", 0.0),
            **kwargs,
        )
    return _generate_signal(*args, **kwargs)

# ---------------------------------------------------------------------------
# Backtesting utilities
# ---------------------------------------------------------------------------

def max_drawdown(equity_curve: Sequence[float]) -> float:
    peak = equity_curve[0]
    mdd = 0.0
    for x in equity_curve:
        if x > peak:
            peak = x
        dd = (peak - x) / peak * 100.0
        if dd > mdd:
            mdd = dd
    return mdd

def backtest(
    trades: Sequence[Dict[str, Any]],
    *,
    equity_start: float = 1_000.0,
    fee_rate: float = 0.0,
) -> Dict[str, float]:
    """Evaluate a list of trade dictionaries.

    Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
    optionally include ``duration`` in minutes.  Results are aggregated into
    common performance metrics to quickly evaluate the strategy.
    """

    equity = equity_start
    equity_curve = [equity]
    pnl_pct_list: List[float] = []
    wins = losses = 0
    win_sum = loss_sum = 0.0
    total_duration = 0.0

    for t in trades:
        pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
        pnl_pct_list.append(pnl_pct)
        if pnl_pct >= 0:
            wins += 1
            win_sum += pnl_pct
        else:
            losses += 1
            loss_sum += pnl_pct
        equity *= 1 + pnl_pct / 100.0
        equity_curve.append(equity)
        total_duration += float(t.get("duration", 0.0))

    pnl_pct_total = sum(pnl_pct_list)
    pnl_usdt = equity - equity_start
    profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
    winrate = wins / len(trades) * 100.0 if trades else 0.0
    mdd = max_drawdown(equity_curve)
    avg_trade_time = total_duration / len(trades) if trades else 0.0
    exposure = total_duration  # in minutes, callers can normalise if desired
    # Sharpe ratio based on per-trade returns
    if len(pnl_pct_list) > 1:
        mean = sum(pnl_pct_list) / len(pnl_pct_list)
        var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
        sharpe = mean / (var ** 0.5) if var > 0 else 0.0
    else:
        sharpe = 0.0

    return {
        "pnl_usdt": pnl_usdt,
        "pnl_pct": pnl_pct_total,
        "profit_factor": profit_factor,
        "winrate": winrate,
        "max_drawdown": mdd,
        "avg_trade_time": avg_trade_time,
        "exposure": exposure,
        "sharpe": sharpe,
    }


## scalp/telegram_bot.py (last modified: 2025-08-22 12:29:12)
from __future__ import annotations

import logging
import os
from typing import Any, Dict, Optional

try:  # pragma: no cover - optional dependency
    import requests as _requests
    requests = _requests
except Exception:  # pragma: no cover
    class _Requests:
        def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
            raise RuntimeError("requests.get unavailable")

        def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
            raise RuntimeError("requests.post unavailable")

    requests = _Requests()  # type: ignore[assignment]


class TelegramBot:
    """Minimal Telegram bot using the HTTP API.


    The bot exposes a simple *menu* based interface with clickable buttons so
    users do not have to remember text commands.  A sub-menu lets the user set
    the risk level.

    """

    def __init__(
        self,
        token: str,
        chat_id: str,
        client: Any,
        config: Dict[str, Any],
        risk_mgr: Any,
        *,
        requests_module: Any = requests,
    ) -> None:
        self.token = token
        self.chat_id = str(chat_id)
        self.client = client
        self.config = config
        self.risk_mgr = risk_mgr
        self.requests = requests_module
        self.last_update_id: Optional[int] = None
        self.stop_requested = False


        self.main_keyboard = [
            [{"text": "Positions ouvertes", "callback_data": "positions"}],
            [{"text": "Update Cryptos", "callback_data": "update"}],
            [{"text": "Réglages", "callback_data": "settings"}],
            [{"text": "Arrêt bot", "callback_data": "shutdown"}],
        ]
        self.settings_keyboard = [
            [{"text": "Stop trade", "callback_data": "stop"}],
            [{"text": "Réglage risk", "callback_data": "risk"}],
            [{"text": "Nb positions", "callback_data": "maxpos"}],
            [{"text": "Reset risk", "callback_data": "reset_risk"}],
            [{"text": "Reset total", "callback_data": "reset_all"}],
            [{"text": "Retour", "callback_data": "back"}],
        ]
        self.risk_keyboard = [
            [
                {"text": "🟢", "callback_data": "risk_green"},
                {"text": "🟠", "callback_data": "risk_orange"},
                {"text": "🔴", "callback_data": "risk_red"},
            ],
            [{"text": "Retour", "callback_data": "back"}],
        ]
        self.maxpos_keyboard = [
            [
                {"text": "1", "callback_data": "maxpos_1"},
                {"text": "2", "callback_data": "maxpos_2"},
                {"text": "3", "callback_data": "maxpos_3"},
            ],
            [
                {"text": "4", "callback_data": "maxpos_4"},
                {"text": "5", "callback_data": "maxpos_5"},
            ],
            [{"text": "Retour", "callback_data": "back"}],
        ]

        # Show menu on startup with zero PnL session
        self.send_main_menu(0.0)


    def _base_symbol(self, symbol: str) -> str:
        sym = symbol.replace("_", "")
        return sym[:-4] if sym.endswith("USDT") else sym

    def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
        pos = self.client.get_positions() or {}
        buttons: list[list[Dict[str, str]]] = []
        for p in pos.get("data") or []:
            sym = p.get("symbol")
            if not sym:
                continue
            base = self._base_symbol(sym)
            # Use the full symbol in the callback so we can properly
            # identify the position to close.  Only the label shows the
            # base asset to keep the interface concise.
            buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
        buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
        buttons.append([{"text": "Retour", "callback_data": "back"}])
        return buttons


    def _menu_text(self, session_pnl: float) -> str:
        assets = self.client.get_assets() or {}
        equity = 0.0
        for row in assets.get("data") or []:
            if row.get("currency") == "USDT":
                try:
                    equity = float(row.get("equity", 0.0))
                except Exception:
                    equity = 0.0
                break
        return (
            f"Solde: {equity:.2f} USDT\n"
            f"PnL session: {session_pnl:.2f} USDT\n"
            f"Positions max: {self.risk_mgr.max_positions}\n"
            f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
            "Choisissez une option:"
        )

    def send_main_menu(self, session_pnl: float) -> None:
        self.send(self._menu_text(session_pnl), self.main_keyboard)

    def update_pairs(self) -> None:
        from bot import update as _update  # lazy import to avoid cycle
        _update(self.client, top_n=40)

    # ------------------------------------------------------------------
    def _api_url(self, method: str) -> str:
        return f"https://api.telegram.org/bot{self.token}/{method}"


    def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
        payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
        if keyboard:
            payload["reply_markup"] = {"inline_keyboard": keyboard}

        try:  # pragma: no cover - network
            self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram send error: %s", exc)

    def answer_callback(self, cb_id: str) -> None:
        payload = {"callback_query_id": cb_id}
        try:  # pragma: no cover - network
            self.requests.post(
                self._api_url("answerCallbackQuery"), json=payload, timeout=5
            )
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram answerCallback error: %s", exc)


    # ------------------------------------------------------------------
    def fetch_updates(self) -> list[Dict[str, Any]]:
        params: Dict[str, Any] = {}
        if self.last_update_id is not None:
            params["offset"] = self.last_update_id + 1
        try:  # pragma: no cover - network
            r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
            r.raise_for_status()
            data = r.json()
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram getUpdates error: %s", exc)
            return []
        updates = data.get("result", [])
        if updates:
            self.last_update_id = updates[-1].get("update_id")
        return updates

    # ------------------------------------------------------------------
    def handle_updates(self, session_pnl: float) -> None:
        for update in self.fetch_updates():

            callback = update.get("callback_query")
            if callback:
                if str(callback.get("from", {}).get("id")) != self.chat_id:
                    continue
                data = callback.get("data", "")
                reply, kb = self.handle_callback(data, session_pnl)
                if reply:
                    self.send(reply, kb)
                cb_id = callback.get("id")
                if cb_id:
                    self.answer_callback(cb_id)
                continue


            msg = update.get("message") or {}
            chat = msg.get("chat") or {}
            if str(chat.get("id")) != self.chat_id:
                continue

            # Any text message triggers the main menu with balance and PnL
            self.send_main_menu(session_pnl)

    # ------------------------------------------------------------------
    def handle_callback(
        self, data: str, session_pnl: float
    ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
        if not data:
            return None, None
        if data == "balance":
            assets = self.client.get_assets() or {}
            equity = 0.0
            for row in assets.get("data") or []:
                if row.get("currency") == "USDT":
                    try:
                        equity = float(row.get("equity", 0.0))
                    except Exception:
                        equity = 0.0
                    break

            return f"Solde: {equity:.2f} USDT", self.main_keyboard
        if data == "positions":
            pos = self.client.get_positions() or {}
            lines = []
            for p in pos.get("data") or []:
                symbol = p.get("symbol", "")
                base = self._base_symbol(symbol)
                side = p.get("side")
                vol = p.get("vol")
                pnl = p.get("pnl_usdt")
                if pnl is None:
                    pnl = p.get("pnl_usd")
                if pnl is None:
                    pnl = p.get("pnl")
                pnl_pct = p.get("pnl_pct_on_margin")
                if pnl_pct is None:
                    pnl_pct = p.get("pnl_pct")
                line = f"{base} {side} {vol}"
                if pnl is not None and pnl_pct is not None:
                    line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
                lines.append(line)
            if not lines:

                return "Aucune position ouverte", self.main_keyboard
            return "Positions:\n" + "\n".join(lines), self.main_keyboard
        if data == "pnl":
            return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
        if data == "risk":
            return "Choisissez le niveau de risque:", self.risk_keyboard
        if data == "settings":
            return "Réglages:", self.settings_keyboard
        if data == "maxpos":
            return "Choisissez le nombre de positions:", self.maxpos_keyboard
        if data == "reset_risk":
            try:
                self.risk_mgr.reset_day()
                return "Risque réinitialisé", self.settings_keyboard
            except Exception:
                return "Erreur reset risque", self.settings_keyboard
        if data == "update":
            try:
                self.update_pairs()
                return "Liste cryptos mise à jour", self.main_keyboard
            except Exception:
                return "Erreur mise à jour", self.main_keyboard
        if data.startswith("risk"):
            mapping = {
                "risk_green": 1,
                "risk_orange": 2,
                "risk_red": 3,
            }
            lvl = mapping.get(data)
            if lvl:
                self.config["RISK_LEVEL"] = lvl
                return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
            return "Niveau de risque inchangé", self.main_keyboard

        if data.startswith("maxpos_"):
            try:
                lvl = int(data.split("_", 1)[1])
            except Exception:
                lvl = None
            if lvl:
                self.config["MAX_POSITIONS"] = lvl
                self.risk_mgr.max_positions = lvl
                return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
            return "Nombre de positions inchangé", self.main_keyboard

        if data == "reset_all":
            try:
                self.client.close_all_positions()
                self.risk_mgr.reset_day()
                return "Positions et risque réinitialisés", self.settings_keyboard
            except Exception:
                return "Erreur lors du reset total", self.settings_keyboard

        if data == "stop":
            pos = self.client.get_positions() or {}
            if not (pos.get("data") or []):
                return "Aucune crypto sélectionnée", self.settings_keyboard
            return "Choisissez la position à fermer:", self._build_stop_keyboard()
        if data == "stop_all":
            try:
                self.client.close_all_positions()
                return "Toutes les positions fermées", self.settings_keyboard
            except Exception:
                return "Erreur arrêt trade", self.settings_keyboard
        if data.startswith("stop_"):
            sym = data[5:]
            try:
                self.client.close_position(sym)
                return f"Position {sym} fermée", self.settings_keyboard
            except Exception:
                return f"Erreur arrêt trade {sym}", self.settings_keyboard

        if data == "shutdown":
            self.stop_requested = True
            return "Arrêt du bot demandé", self.main_keyboard

        if data == "back":
            return self._menu_text(session_pnl), self.main_keyboard
        return None, None


def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    if token and chat_id:
        return TelegramBot(token, chat_id, client, config, risk_mgr)
    return None


## scalp/trade_utils.py (last modified: 2025-08-22 12:29:12)
"""Utilities for risk analysis and position sizing."""
from __future__ import annotations

import logging
import math
from typing import Any, Dict, List, Optional, Tuple

from scalp.bot_config import CONFIG


def get_contract_size(contract_detail: Dict[str, Any], symbol: Optional[str] = None) -> float:
    """Return the contract size for ``symbol``.

    Bitget may expose the contract unit as ``contractSize`` or
    ``sizeMultiplier`` depending on the endpoint.  This helper normalises the
    two so the rest of the code base has a single source of truth for
    conversions between contract volume and notional value.
    """

    symbol = symbol or CONFIG.get("SYMBOL")
    data = contract_detail.get("data") if isinstance(contract_detail, dict) else None
    if isinstance(data, list):
        contract = next((c for c in data if c and c.get("symbol") == symbol), data[0] if data else {})
    else:
        contract = data or {}
    size = contract.get("contractSize") or contract.get("sizeMultiplier") or 1.0
    try:
        return float(size)
    except (TypeError, ValueError):
        return 1.0


# Backwards compatibility: old name used internally/tests
extract_contract_size = get_contract_size


def notional(price: float, vol: float, contract_size: float) -> float:
    """Return the notional value in USDT for ``vol`` contracts."""

    return float(price) * float(vol) * float(contract_size)


def required_margin(
    notion: float,
    lev: float,
    fee_rate: float,
    buffer: float = 0.03,
) -> float:
    """Return estimated required margin including fees and buffer.

    The margin is the sum of the collateral required by the leverage and the
    estimated taker fees for both sides of the trade.  ``buffer`` adds an extra
    safety margin to account for slight price movements between order placement
    and execution.
    """

    lev = max(float(lev), 1.0)
    fee = float(fee_rate)
    return (notion / lev + fee * notion) * (1.0 + buffer)


def extract_available_balance(assets: Dict[str, Any], currency: str = "USDT") -> float:
    """Return available balance for ``currency`` from Bitget assets payload.

    The exchange may expose multiple fields depending on account mode and API
    version.  We iterate through the known keys, returning the first positive
    value encountered.  ``0.0`` is returned when no usable balance can be
    determined.  The helper only falls back to the more generic ``equity``
    fields when the granular balance keys are absent; if the exchange reports
    them with a ``0`` value we honour that and return ``0.0`` to avoid sizing
    orders against unavailable funds.
    """

    for row in assets.get("data", []):
        if row.get("currency") != currency:
            continue

        has_balance_field = False
        for key in (
            "available",
            "availableBalance",
            "availableMargin",
            "cashBalance",
        ):
            if key in row:
                has_balance_field = True
            val = row.get(key)
            if val is None:
                continue
            try:
                eq = float(val)
            except (TypeError, ValueError):
                continue
            if eq > 0:
                return eq

        if has_balance_field:
            return 0.0

        for key in ("equity", "usdtEquity"):
            val = row.get(key)
            if val is None:
                continue
            try:
                eq = float(val)
            except (TypeError, ValueError):
                continue
            if eq > 0:
                return eq
        break
    return 0.0


def compute_execution_metrics(
    fills: List[Dict[str, Any]], *, contract_size: float = 1.0
) -> Tuple[float, float, float]:
    """Aggregate Bitget fills into execution metrics.

    Parameters
    ----------
    fills:
        Sequence of fill dictionaries containing price and quantity.  The
        helper accepts the common Bitget keys ``fillPrice``/``price`` and
        ``fillQty``/``size``/``vol`` for the executed quantity.  Unknown or
        malformed entries are ignored.
    contract_size:
        Multiplier to convert contract volume into notional value.

    Returns
    -------
    tuple
        ``(exec_qty, exec_notional, avg_exec_price)`` where quantities are in
        contract units and notional is expressed in quote currency.
    """

    exec_qty = 0.0
    exec_notional = 0.0
    for f in fills:
        price = f.get("fillPrice") or f.get("price")
        qty = f.get("fillQty") or f.get("size") or f.get("vol") or f.get("qty")
        try:
            price_f = float(price)
            qty_f = float(qty)
        except (TypeError, ValueError):
            continue
        exec_qty += qty_f
        exec_notional += price_f * qty_f * contract_size

    avg_price = exec_notional / (exec_qty * contract_size) if exec_qty else 0.0
    return exec_qty, exec_notional, avg_price


def compute_position_size(
    contract_detail: Dict[str, Any],
    equity_usdt: float,
    price: float,
    risk_pct: float,
    leverage: int,
    symbol: Optional[str] = None,
    available_usdt: Optional[float] = None,
) -> int:
    """Return contract volume to trade for the given risk parameters.

    The original implementation assumed ``price`` and contract metadata were
    always valid which could lead to divide-by-zero errors or negative volumes
    when the upstream API returned incomplete data.  To harden the sizing logic
    we now validate these inputs and simply return ``0`` whenever they are
    non‑positive.  The caller interprets a zero volume as a cue to skip the
    trade, keeping the bot running without raising exceptions.
    """

    symbol = symbol or CONFIG.get("SYMBOL")
    contracts = contract_detail.get("data") or []
    if not isinstance(contracts, list):
        contracts = [contracts]
    contract = next((c for c in contracts if c and c.get("symbol") == symbol), None)
    if contract is None:
        raise ValueError("Contract detail introuvable pour le symbole")

    contract_size = get_contract_size(contract_detail, symbol)
    vol_unit = int(contract.get("volUnit", 1))
    min_vol = int(contract.get("minVol", 1))
    min_usdt = float(contract.get("minTradeUSDT", 5))

    if price <= 0 or contract_size <= 0 or vol_unit <= 0 or min_vol <= 0:
        return 0

    notional_target = equity_usdt * float(risk_pct) * float(leverage)
    if notional_target <= 0.0:
        return 0

    denom = price * contract_size
    if denom <= 0:
        return 0

    vol = notional_target / denom
    vol = int(math.floor(vol / vol_unit) * vol_unit)
    vol = max(min_vol, vol)
    notional = vol * denom
    if notional < min_usdt:
        return 0

    fee_rate = max(CONFIG.get("FEE_RATE", 0.0), 0.001)
    max_notional = equity_usdt / (1 / float(leverage) + fee_rate)
    max_vol = int(math.floor(max_notional / denom / vol_unit) * vol_unit)
    if max_vol < min_vol:
        return 0
    if vol > max_vol:
        vol = max_vol
        notional = vol * denom
        if notional < min_usdt:
            return 0

    if available_usdt is not None:
        cap = available_usdt / (1 / float(leverage) + fee_rate)
        cap_vol = int(math.floor(cap / denom / vol_unit) * vol_unit)
        if cap_vol < min_vol:
            return 0
        if vol > cap_vol:
            vol = cap_vol
            notional = vol * denom
            if notional < min_usdt:
                return 0

    return vol


def compute_pnl_usdt(
    contract_detail: Dict[str, Any],
    entry_price: float,
    exit_price: float,
    vol: float,
    side: int,
    symbol: Optional[str] = None,
) -> float:
    """Return PnL in USDT using contract size for ``vol`` contracts."""

    size = get_contract_size(contract_detail, symbol)
    diff = (exit_price - entry_price) * (1 if side > 0 else -1)
    return diff * size * vol


def compute_pnl_with_fees(
    contract_detail: Dict[str, Any],
    entry_price: float,
    exit_price: float,
    vol: float,
    side: int,
    leverage: float,
    fee_rate: float,
    symbol: Optional[str] = None,
) -> Tuple[float, float]:
    """Return net PnL in USDT and percentage on margin.

    ``side`` should be ``1`` for long positions and ``-1`` for shorts.
    """

    cs = get_contract_size(contract_detail, symbol)
    n_entry = notional(entry_price, vol, cs)
    n_exit = notional(exit_price, vol, cs)
    gross = (exit_price - entry_price) * vol * cs * (1 if side > 0 else -1)
    fees = fee_rate * (n_entry + n_exit)
    pnl = gross - fees
    margin = n_entry / max(float(leverage), 1.0)
    pct = 0.0 if margin == 0 else pnl / margin * 100.0
    return pnl, pct

def effective_leverage(
    entry_price: float,
    liquidation_price: float,
    position_margin: float,
    position_size: float,
) -> float:
    """Return the effective leverage of a futures position.

    ``effective_leverage`` is defined as the ratio between the position's
    notional value and the collateral backing it.  The collateral is primarily
    taken from ``position_margin`` but, when unavailable, it can be inferred
    from the distance to the liquidation price.

    The function is resilient to missing or non‑positive inputs and falls back
    to ``0.0`` whenever leverage cannot be determined.
    """

    try:
        entry = float(entry_price)
        liq = float(liquidation_price)
        margin = float(position_margin)
        size = float(position_size)
    except (TypeError, ValueError):
        return 0.0

    if entry <= 0 or size == 0:
        return 0.0

    notional = abs(size) * entry

    if margin <= 0:
        price_diff = abs(entry - liq)
        margin = price_diff * abs(size)

    if margin <= 0:
        return 0.0

    return notional / margin


def analyse_risque(
    contract_detail: Dict[str, Any],
    open_positions: List[Dict[str, Any]],
    equity_usdt: float,
    price: float,
    risk_pct: float,
    base_leverage: int,
    symbol: Optional[str] = None,
    side: str = "long",
    risk_level: int = 2,
) -> Tuple[int, int]:
    """Analyse le risque avant l'ouverture d'une position."""
    symbol = symbol or CONFIG.get("SYMBOL")
    side = side.lower()

    max_positions_map = {1: 1, 2: 3, 3: 5}
    leverage_map = {1: max(1, base_leverage // 2), 2: base_leverage, 3: base_leverage * 2}

    max_pos = max_positions_map.get(risk_level, max_positions_map[2])
    leverage = leverage_map.get(risk_level, base_leverage)

    current = 0
    for pos in open_positions or []:
        if pos and pos.get("symbol") == symbol:
            if str(pos.get("side", "")).lower() == side:
                current += 1

    if current >= max_pos:
        return 0, leverage

    vol = compute_position_size(
        contract_detail,
        equity_usdt=equity_usdt,
        price=price,
        risk_pct=risk_pct,
        leverage=leverage,
        symbol=symbol,
    )
    return vol, leverage


def trailing_stop(side: str, current_price: float, atr: float, sl: float, *, mult: float = 0.75) -> float:
    """Update a stop loss using a trailing ATR multiple."""

    if side.lower() == "long":
        new_sl = current_price - mult * atr
        return max(sl, new_sl)
    new_sl = current_price + mult * atr
    return min(sl, new_sl)


def break_even_stop(
    side: str,
    entry_price: float,
    current_price: float,
    atr: float,
    sl: float,
    *,
    mult: float = 1.0,
) -> float:
    """Move stop loss to break-even after a favourable move.

    Once price advances ``mult`` times the ``atr`` from ``entry_price`` the
    original stop loss ``sl`` is tightened to the entry.  This helps lock in
    profits while still giving the trade room to develop.
    """

    side = side.lower()
    if side == "long":
        if current_price - entry_price >= mult * atr:
            return max(sl, entry_price)
        return sl
    if side == "short":
        if entry_price - current_price >= mult * atr:
            return min(sl, entry_price)
        return sl
    raise ValueError("side must be 'long' or 'short'")


def should_scale_in(
    entry_price: float,
    current_price: float,
    last_entry: float,
    atr: float,
    side: str,
    *,
    distance_mult: float = 0.5,
) -> bool:
    """Return ``True`` when price moved sufficiently to add to the position."""

    if side.lower() == "long":
        target = last_entry + distance_mult * atr
        return current_price >= target
    target = last_entry - distance_mult * atr
    return current_price <= target


def timeout_exit(
    entry_time: float,
    now: float,
    entry_price: float,
    current_price: float,
    side: str,
    *,
    progress_min: float = 15.0,
    timeout_min: float = 30.0,
) -> bool:
    """Return ``True`` when a position should be closed for lack of progress.

    Parameters
    ----------
    entry_time, now:
        Timestamps in **seconds**.  ``progress_min`` and ``timeout_min`` are
        expressed in minutes and converted to seconds inside the function so
        callers can provide human-friendly minute values.
    """

    # Convert the minute based thresholds to seconds for comparison with the
    # epoch based ``entry_time``/``now`` values.
    progress_sec = progress_min * 60.0
    timeout_sec = timeout_min * 60.0

    elapsed = now - entry_time
    if elapsed >= timeout_sec:
        return True
    if elapsed >= progress_sec:
        progress = (
            current_price - entry_price
            if side.lower() == "long"
            else entry_price - current_price
        )
        return progress <= 0
    return False


def marketable_limit_price(
    side: str,
    *,
    best_bid: float,
    best_ask: float,
    slippage: float = 0.001,
) -> float:
    """Return price for a marketable limit order with slippage cap.

    Parameters
    ----------
    side:
        ``"buy"`` or ``"sell"``.
    best_bid, best_ask:
        Current best bid and ask prices.
    slippage:
        Maximum relative slippage allowed (e.g. ``0.001`` = 0.1%).
    """

    if slippage < 0:
        raise ValueError("slippage must be non-negative")
    side = side.lower()
    if side == "buy":
        return best_ask * (1.0 + slippage)
    if side == "sell":
        return best_bid * (1.0 - slippage)
    raise ValueError("side must be 'buy' or 'sell'")


## scalp/version.py (last modified: 2025-08-22 07:05:27)
"""Utilities for managing the Scalp bot version."""

from __future__ import annotations

from pathlib import Path
import re

import subprocess


# Path to the VERSION file within the package
_VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
_VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")


def get_version() -> str:
    """Return the current version of the bot.

    If the VERSION file does not exist the default version ``0.0.0`` is
    returned.
    """
    if not _VERSION_FILE.exists():
        return "0.0.0"
    return _VERSION_FILE.read_text().strip()


def _parse(version: str) -> tuple[int, int, int]:
    match = _VERSION_RE.match(version)
    if not match:
        raise ValueError(f"Invalid version: {version!r}")
    return tuple(int(x) for x in match.groups())


def bump_version(part: str = "patch") -> str:
    """Bump the version stored in the VERSION file.

    Parameters
    ----------
    part:
        Which component to increment. Accepted values are ``"major"``,
        ``"minor"`` and ``"patch"`` (default).
    """
    major, minor, patch = _parse(get_version())
    if part == "major":
        major += 1
        minor = 0
        patch = 0
    elif part == "minor":
        minor += 1
        patch = 0

    elif part == "patch":
        patch += 1
    else:
        raise ValueError(f"Unknown part: {part}")
    new_version = f"{major}.{minor}.{patch}"
    _VERSION_FILE.write_text(f"{new_version}\n")
    return new_version


def bump_version_from_message(message: str) -> str:
    """Bump the version according to a commit message.

    ``message`` is evaluated using a tiny subset of the Conventional
    Commits spec. Messages starting with ``feat`` bump the *minor*
    version, messages whose header ends with ``!`` or contain
    ``BREAKING CHANGE`` bump the *major* version. All other messages
    bump the *patch* component.
    """

    header = message.strip().splitlines()[0].lower()
    lower = message.lower()
    type_part = header.split(":")[0]
    if "!" in type_part or "breaking change" in lower:
        part = "major"
    elif type_part.startswith("feat"):
        part = "minor"
    else:
        part = "patch"
    return bump_version(part)


def bump_version_from_git() -> str:
    """Read the latest git commit message and bump the version accordingly."""
    try:
        message = subprocess.check_output(
            ["git", "log", "-1", "--pretty=%B"], text=True
        ).strip()
    except Exception:
        message = ""
    return bump_version_from_message(message)


if __name__ == "__main__":
    print(bump_version_from_git())


## scalp/ws.py (last modified: 2025-08-22 07:05:27)
"""Minimal websocket manager with heartbeat and auto-resubscribe.

This module provides a light-weight framework to maintain a realtime
connection to an exchange.  The actual network layer is expected to be
supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
manager handles retrying failed connections and periodically invoking the
``subscribe`` callback as a heartbeat.  This keeps the code fully testable
without opening real network sockets.
"""
from __future__ import annotations

import asyncio
import logging
from typing import Awaitable, Callable, Optional


class WebsocketManager:
    """Maintain a websocket connection with heartbeat and retry."""

    def __init__(
        self,
        connect: Callable[[], Awaitable[None]],
        subscribe: Callable[[], Awaitable[None]],
        *,
        heartbeat_interval: float = 30.0,
        max_retries: int = 3,
    ) -> None:
        self._connect = connect
        self._subscribe = subscribe
        self.heartbeat_interval = heartbeat_interval
        self.max_retries = max_retries
        self._heartbeat_task: Optional[asyncio.Task] = None

    async def run(self) -> None:
        """Open the connection retrying on failure."""
        retries = 0
        while True:
            try:
                await self._connect()
                await self._subscribe()
                self._heartbeat_task = asyncio.create_task(self._heartbeat())
                return
            except Exception as exc:  # pragma: no cover - network errors
                logging.error("websocket connect failed: %s", exc)
                retries += 1
                if retries > self.max_retries:
                    raise
                await asyncio.sleep(1)

    async def _heartbeat(self) -> None:
        """Send periodic heartbeats and resubscribe on failure."""
        while True:
            await asyncio.sleep(self.heartbeat_interval)
            try:
                await self._subscribe()
            except Exception as exc:  # pragma: no cover - network errors
                logging.warning("websocket heartbeat failed: %s", exc)
                await self.run()
                break

    async def stop(self) -> None:
        """Cancel the heartbeat task if it is running."""
        task = self._heartbeat_task
        if task and not task.done():
            task.cancel()
            try:
                await task
            except BaseException:  # pragma: no cover - cancellation
                pass
        self._heartbeat_task = None


## short_one_way.py (last modified: 2025-08-22 07:05:27)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Example script to open a one-way short on Bitget futures.

This standalone script signs and sends a market sell order using the
Bitget REST API. Environment variables required (defined in a `.env`
file alongside this script):

- ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
- ``BITGET_API_KEY``
- ``BITGET_API_SECRET``
- ``BITGET_API_PASSPHRASE``
- ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
- ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
- ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
- ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)

The script retrieves the current contract specification and price,
ensures account settings (one-way mode & leverage) and finally places a
market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.

The intent is purely demonstrational; use at your own risk.
"""

import base64
import hashlib
import hmac
import json
import os
import sys
import time
import uuid
from pathlib import Path

import requests

try:  # lazy dependency import for dotenv
    from dotenv import load_dotenv
except ImportError:  # pragma: no cover - installation fallback
    import subprocess

    subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
    from dotenv import load_dotenv

# load environment variables
load_dotenv(Path(__file__).resolve().parent / ".env")


def T(x):  # small helper used throughout configuration
    return x.strip() if isinstance(x, str) else x


BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
AK = T(os.getenv("BITGET_API_KEY"))
SK = T(os.getenv("BITGET_API_SECRET"))
PH = T(os.getenv("BITGET_API_PASSPHRASE"))
PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))

if not (AK and SK and PH):
    sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")

print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")


# ---------- signing helpers ----------
def sign_get(ts, path, params):
    qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
    sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    return sig, qs


def sign_post(ts, path, body, params=None):
    qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
    pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
    sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    return sig, body_str, qs


def headers(sig, ts):
    return {
        "ACCESS-KEY": AK,
        "ACCESS-SIGN": sig,
        "ACCESS-TIMESTAMP": str(ts),
        "ACCESS-PASSPHRASE": PH,
        "ACCESS-RECV-WINDOW": "60000",
        "Content-Type": "application/json",
    }


def pick_price(d: dict):
    for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
        try:
            v = float(d.get(k))
            if v > 0:
                return v
        except Exception:
            pass
    return None


# ---------- public endpoints ----------
def get_contract_spec():
    r = requests.get(
        f"{BASE}/api/v2/mix/market/contracts",
        params={"productType": PT, "symbol": SYMB},
        timeout=12,
    )
    r.raise_for_status()
    arr = r.json().get("data") or []
    if not arr:
        raise RuntimeError("Contrat introuvable")
    return arr[0]


def get_price():
    # 1) ticker (obj/list) avec productType
    try:
        r = requests.get(
            f"{BASE}/api/v2/mix/market/ticker",
            params={"symbol": SYMB, "productType": PT},
            timeout=10,
        )
        r.raise_for_status()
        data = r.json().get("data")
        if isinstance(data, dict):
            p = pick_price(data)
            if p:
                return p
        if isinstance(data, list) and data:
            p = pick_price(data[0])
            if p:
                return p
    except requests.HTTPError as e:
        print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("⚠️ ticker err:", e)

    # 2) tickers (liste entière)
    try:
        r = requests.get(
            f"{BASE}/api/v2/mix/market/tickers",
            params={"productType": PT},
            timeout=10,
        )
        r.raise_for_status()
        arr = r.json().get("data") or []
        row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
        p = pick_price(row or {})
        if p:
            return p
    except requests.HTTPError as e:
        print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("⚠️ tickers err:", e)

    # 3) candles 1m (close)
    try:
        # ``symbol`` must be provided as a query parameter; placing it in the
        # path triggers a 404 response from Bitget.
        r = requests.get(
            f"{BASE}/api/v2/mix/market/candles",
            params={"symbol": SYMB, "granularity": "1m"},
            timeout=10,
        )
        r.raise_for_status()
        arr = r.json().get("data") or []
        if arr:
            return float(arr[0][4])
    except requests.HTTPError as e:
        print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("⚠️ candles err:", e)

    raise RuntimeError("prix indisponible")


# ---------- private endpoints ----------
def check_accounts():
    path = "/api/v2/mix/account/accounts"
    ts = int(time.time() * 1000)
    params = {"productType": PT}
    sig, qs = sign_get(ts, path, params)
    url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
    r = requests.get(url, headers=headers(sig, ts), timeout=12)
    print("accounts", r.status_code, r.text[:160])
    r.raise_for_status()
    j = r.json()
    if str(j.get("code")) not in ("00000", "0"):
        raise RuntimeError(j)


def set_position_mode_one_way():
    path = "/api/v2/mix/account/set-position-mode"
    ts = int(time.time() * 1000)
    body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
    sig, b, qs = sign_post(ts, path, body)
    url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
    r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
    print("set-position-mode(one-way)", r.status_code, r.text[:160])
    r.raise_for_status()


def set_leverage(lv: int = 2):
    path = "/api/v2/mix/account/set-leverage"
    ts = int(time.time() * 1000)
    body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
    sig, b, qs = sign_post(ts, path, body)
    url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
    r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
    print("set-leverage", r.status_code, r.text[:160])
    r.raise_for_status()


def place_one_way_sell(size_coin: float):
    """Ouvre un SHORT en one_way_mode (market SELL)."""
    path = "/api/v2/mix/order/place-order"
    ts = int(time.time() * 1000)
    body = {
        "symbol": SYMB,
        "productType": PT,
        "marginCoin": MC,
        "marginMode": "crossed",
        "posMode": "one_way_mode",
        "orderType": "market",
        "side": "sell",  # <-- SHORT
        "size": str(size_coin),
        "timeInForceValue": "normal",
        "clientOid": str(uuid.uuid4())[:32],
    }
    sig, b, qs = sign_post(ts, path, body)
    url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
    r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
    print("place-order(one-way SELL)", r.status_code, r.text[:220])
    r.raise_for_status()
    j = r.json()
    if str(j.get("code")) not in ("00000", "0"):
        raise RuntimeError(j)
    return j


# ---------- main ----------
def main():
    spec = get_contract_spec()
    min_usdt = float(spec.get("minTradeUSDT") or 5)
    min_num = float(spec.get("minTradeNum") or 0)
    size_place = int(spec.get("sizePlace") or 6)
    print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")

    px = get_price()
    print(f"Prix OK ≈ {px}")

    check_accounts()
    set_position_mode_one_way()
    set_leverage(2)

    target = max(NOTIONAL, min_usdt)
    size = max(target / px, min_num)
    size = float(f"{size:.{size_place}f}")
    print(f"Taille={size} (target≈{target}USDT)")

    j = place_one_way_sell(size)
    print("✅ SHORT OK")
    print(json.dumps(j, indent=2, ensure_ascii=False))


if __name__ == "__main__":  # pragma: no cover - script entrypoint
    main()


## signals/__init__.py (last modified: 2025-08-22 07:05:27)
"""Signal generation utilities."""

from .generator import generate_signal

__all__ = ["generate_signal"]


## signals/generator.py (last modified: 2025-08-22 07:05:27)
from __future__ import annotations

from typing import Any, Dict, List, Optional

import pandas as pd

from data.indicators import compute_all

__all__ = ["generate_signal"]


def _quality_from_score(score: float) -> str:
    if score >= 0.8:
        return "A"
    if score >= 0.5:
        return "B"
    return "C"


def generate_signal(
    df: pd.DataFrame,
    *,
    trend_tf: Optional[pd.DataFrame] = None,
    confirm_tf: Optional[pd.DataFrame] = None,
    atr_mult: float = 1.0,
    trailing: bool = False,
    **_: Any,
) -> Optional[Dict[str, Any]]:
    """Generate a trading signal with confluence scoring.

    Parameters
    ----------
    df: pd.DataFrame
        Primary timeframe OHLCV data.
    trend_tf: pd.DataFrame, optional
        Higher timeframe used for trend filtering.
    confirm_tf: pd.DataFrame, optional
        Lower timeframe used for confirmation.
    atr_mult: float, optional
        Multiplier applied to ATR for stop/target calculation.
    trailing: bool, optional
        When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).

    Returns
    -------
    dict | None
        Dictionary describing the signal or ``None`` if no trade setup exists.
    """

    if df is None or len(df) < 2:
        return None

    df = compute_all(df)
    last = df.iloc[-1]

    conditions: List[bool] = []
    reasons: List[str] = []
    direction: Optional[str] = None

    # --- Basic trend via EMAs ----------------------------------------------
    if last["close"] > last["ema20"] > last["ema50"]:
        direction = "long"
        reasons.append("price_above_ema")
        conditions.append(True)
    elif last["close"] < last["ema20"] < last["ema50"]:
        direction = "short"
        reasons.append("price_below_ema")
        conditions.append(True)
    else:
        conditions.append(False)
        return None

    # --- RSI ---------------------------------------------------------------
    if direction == "long":
        cond = last["rsi"] > 55
        if cond:
            reasons.append("rsi_bullish")
        conditions.append(cond)
    else:
        cond = last["rsi"] < 45
        if cond:
            reasons.append("rsi_bearish")
        conditions.append(cond)

    # --- MACD --------------------------------------------------------------
    if direction == "long":
        cond = last["macd"] > last["macd_signal"]
        if cond:
            reasons.append("macd_bullish")
        conditions.append(cond)
    else:
        cond = last["macd"] < last["macd_signal"]
        if cond:
            reasons.append("macd_bearish")
        conditions.append(cond)

    # --- OBV momentum ------------------------------------------------------
    if len(df) >= 2:
        obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
        if obv_up:
            reasons.append("obv_trending")
        conditions.append(obv_up)

    # --- Trend timeframe filter -------------------------------------------
    if trend_tf is not None and len(trend_tf) >= 2:
        tdf = compute_all(trend_tf)
        ema50 = tdf["ema50"]
        slope = ema50.iloc[-1] - ema50.iloc[-2]
        if direction == "long":
            cond = slope > 0
            if cond:
                reasons.append("trend_up")
            conditions.append(cond)
        else:
            cond = slope < 0
            if cond:
                reasons.append("trend_down")
            conditions.append(cond)

    # --- Confirmation timeframe filter ------------------------------------
    if confirm_tf is not None and len(confirm_tf) > 0:
        cdf = compute_all(confirm_tf)
        rsi = cdf["rsi"].iloc[-1]
        if direction == "long":
            cond = rsi > 50
            if cond:
                reasons.append("confirm_rsi_bullish")
            conditions.append(cond)
        else:
            cond = rsi < 50
            if cond:
                reasons.append("confirm_rsi_bearish")
            conditions.append(cond)

    score = (
        sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
    )
    quality = _quality_from_score(score)

    atr = last.get("atr")
    if pd.isna(atr) or atr == 0:
        return None

    entry = float(last["close"])
    if direction == "long":
        sl = entry - atr * atr_mult
        tp = entry + atr * atr_mult * 2
    else:
        sl = entry + atr * atr_mult
        tp = entry - atr * atr_mult * 2

    result: Dict[str, Any] = {
        "direction": direction,
        "entry": entry,
        "sl": sl,
        "tp": tp,
        "score": round(score, 3),
        "reasons": reasons,
        "quality": quality,
    }

    if trailing:
        result["trail"] = atr * atr_mult

    return result


## tests/conftest.py (last modified: 2025-08-22 07:05:27)
"""Test configuration and shared fixtures."""

import sys
import types
from pathlib import Path


# Ensure the project root is importable so tests can ``import bot``.
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))


# Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
# the real dependency during test collection. Individual tests patch the
# functions they need (``request``/``post``/``get``).
sys.modules.setdefault(
    "requests",
    types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
)



## tests/test_analyse_risque.py (last modified: 2025-08-22 07:05:27)
import os
import sys
import types

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.SimpleNamespace(
    request=lambda *a, **k: None,
    post=lambda *a, **k: None,
    HTTPError=Exception,
)

from bot import analyse_risque  # noqa: E402


def make_contract_detail():
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }


def test_analyse_risque_limits_and_leverage():
    contract_detail = make_contract_detail()
    # Risk level 1: leverage halved, limit 1 position
    open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=1)
    assert lev == 5
    assert vol == 0  # already one long position

    # Risk level 2: base leverage, limit 3 positions
    open_pos = [
        {"symbol": "BTC_USDT", "side": "long"},
        {"symbol": "BTC_USDT", "side": "long"},
        {"symbol": "BTC_USDT", "side": "long"},
    ]
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=2)
    assert lev == 10
    assert vol == 0

    # Risk level 3: leverage doubled, no existing position
    open_pos = []
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=3)
    assert lev == 20
    assert vol == 1


## tests/test_backtest.py (last modified: 2025-08-22 07:05:27)
import pytest

import bot


def test_backtest_trades():
    trades = [
        {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
        {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
    ]
    pnl = bot.backtest_trades(trades, fee_rate=0.001)
    # Both trades: 10% - 0.2% fee = 9.8% each
    assert pnl == pytest.approx(19.6)


## tests/test_backtest_multi.py (last modified: 2025-08-22 12:29:12)
import csv
import random
from datetime import datetime, timedelta, timezone
from pathlib import Path

import pytest

from backtest.run_multi import run_backtest_multi
from scalp.strategy import Signal


def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
    start = datetime(2024, 1, 1, tzinfo=timezone.utc)
    filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
    with open(filename, "w", newline="") as fh:
        writer = csv.writer(fh)
        writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
        for i in range(200):
            ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
            price = 100 + i
            writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])


def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    closes = ohlcv["close"]
    if len(closes) < 10:
        return None
    price = closes[-1]
    sl = price * 0.99
    tp = price * 1.01
    qty = equity * risk_pct / (price - sl)
    return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])


def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    if len(ohlcv["close"]) < 10 or random.random() > 0.3:
        return None
    price = ohlcv["close"][-1]
    sl = price * 0.99
    tp = price * 1.01
    qty = equity * risk_pct / (price - sl)
    return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)


def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    closes = ohlcv["close"]
    if len(closes) < 10:
        return None
    price = closes[-1]
    sl = price * 0.99
    tp = price * 1.01
    return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)


def find_row(summary, symbol):
    for row in summary:
        if row["symbol"] == symbol:
            return row
    raise KeyError(symbol)


def test_csv_multi_pairs(tmp_path, monkeypatch):
    for sym in ["BTC/USDT", "ETH/USDT"]:
        make_csv(tmp_path, sym)
    monkeypatch.setattr("scalp.strategy.generate_signal", simple_signal)
    monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
    out = tmp_path / "out"
    summary, trades = run_backtest_multi(
        symbols=["BTC/USDT", "ETH/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        fee_rate=0.0,
        slippage_bps=0.0,
        risk_pct=0.01,
        initial_equity=1000,
        leverage=1.0,
        paper_constraints=True,
        seed=42,
        out_dir=str(out),
        plot=False,
    )
    btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
    eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
    assert len(btc_trades) > 0 and len(eth_trades) > 0
    assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
    total = find_row(summary, "TOTAL")["pnl_usdt"]
    assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
    # files
    assert (out / "report_summary.csv").exists()
    assert (out / "report_trades.csv").exists()
    assert (out / "equity_curve_total.csv").exists()
    assert (out / "equity_curve_BTC_USDT.csv").exists()
    # columns in trades
    for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
        assert col in trades[0]


def test_fee_slippage(tmp_path, monkeypatch):
    make_csv(tmp_path, "BTC/USDT")
    monkeypatch.setattr("scalp.strategy.generate_signal", simple_signal)
    monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
    summary1, _ = run_backtest_multi(
        symbols=["BTC/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        fee_rate=0.0,
        slippage_bps=0.0,
        out_dir=str(tmp_path / "o1"),
    )
    summary2, _ = run_backtest_multi(
        symbols=["BTC/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        fee_rate=0.01,
        slippage_bps=100,
        out_dir=str(tmp_path / "o2"),
    )
    pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
    pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
    assert pnl2 < pnl1


def test_paper_constraints(tmp_path, monkeypatch):
    make_csv(tmp_path, "BTC/USDT")
    monkeypatch.setattr("scalp.strategy.generate_signal", tiny_qty_signal)
    monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
    summary, trades = run_backtest_multi(
        symbols=["BTC/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        paper_constraints=True,
        out_dir=str(tmp_path / "o"),
    )
    assert all(t["qty"] >= 0.001 for t in trades)
    assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
    assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)


def test_seed_reproducible(tmp_path, monkeypatch):
    make_csv(tmp_path, "BTC/USDT")
    monkeypatch.setattr("scalp.strategy.generate_signal", random_signal)
    monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
    s1, t1 = run_backtest_multi(
        symbols=["BTC/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        seed=7,
        out_dir=str(tmp_path / "o1"),
    )
    s2, t2 = run_backtest_multi(
        symbols=["BTC/USDT"],
        exchange="csv",
        timeframe="1m",
        csv_dir=str(tmp_path),
        seed=7,
        out_dir=str(tmp_path / "o2"),
    )
    assert t1 == t2
    assert s1 == s2


## tests/test_backtest_position.py (last modified: 2025-08-22 07:05:27)
import os
import sys
import pytest

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from scalp.metrics import backtest_position


def test_backtest_position_long():
    prices = [100.0, 110.0, 120.0]
    assert backtest_position(prices, 0, 2, 1) is True


def test_backtest_position_short():
    prices = [100.0, 90.0, 80.0]
    assert backtest_position(prices, 0, 2, -1) is True


def test_backtest_position_incoherent():
    prices = [100.0, 110.0, 120.0]
    assert backtest_position(prices, 0, 2, -1) is False


def test_backtest_position_bad_indices():
    prices = [100.0, 110.0]
    with pytest.raises(ValueError):
        backtest_position(prices, 1, 0, 1)


## tests/test_bitget_futures_pairs.py (last modified: 2025-08-22 07:05:27)
import json
from pathlib import Path
from typing import Any, Dict

import pytest

import bitget_futures_pairs as bfp


class DummyResponse:
    def __init__(self, status: int, payload: Dict[str, Any]):
        self.status_code = status
        self._payload = payload
        self.text = json.dumps(payload)

    def json(self):
        return self._payload


def test_fetch_contracts_success(monkeypatch):
    payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}

    def fake_get(url, params=None, timeout=0):
        return DummyResponse(200, payload)

    monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    contracts = bfp.fetch_contracts("USDT-FUTURES")
    assert contracts == payload["data"]


def test_fetch_contracts_error(monkeypatch):
    payload = {"code": "10001"}

    def fake_get(url, params=None, timeout=0):
        return DummyResponse(200, payload)

    monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    with pytest.raises(RuntimeError):
        bfp.fetch_contracts("USDT-FUTURES")


def test_normalize_rows():
    contracts = [
        {
            "symbol": "BTCUSDT",
            "baseCoin": "BTC",
            "quoteCoin": "USDT",
            "symbolType": "perpetual",
            "symbolStatus": "normal",
            "maxLever": "50",
            "minLever": "1",
            "minTradeNum": "0.001",
            "sizeMultiplier": "1",
            "pricePlace": "2",
            "volumePlace": "3",
            "launchTime": 0,
            "deliveryTime": 0,
        }
    ]
    rows = bfp.normalize_rows("USDT-FUTURES", contracts)
    assert rows[0]["symbol"] == "BTCUSDT"
    assert rows[0]["productType"] == "USDT-FUTURES"


def test_write_csv(tmp_path: Path):
    path = tmp_path / "pairs.csv"
    bfp.write_csv([], str(path))
    assert path.exists()
    content = path.read_text().splitlines()
    assert content[0].startswith("productType,")


## tests/test_bot_place_order_caps.py (last modified: 2025-08-22 12:29:12)
import os
import sys
import types
sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')

from bot import attempt_entry, Signal


class DummyClient:
    def __init__(self):
        self.last_order = None

    def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
        self.last_order = (args, kwargs)
        return {"code": "00000"}


class DummyRisk:
    def __init__(self, pct):
        self.risk_pct = pct


def _detail():
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.001,
                "volUnit": 1,
                "minVol": 1,
                "minTradeUSDT": 5,
            }
        ]
    }


def test_attempt_entry_respects_caps(monkeypatch):
    captured = {}

    def fake_notify(event, payload):
        captured[event] = payload

    monkeypatch.setattr("bot.notify", fake_notify)
    client = DummyClient()
    sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    rm = DummyRisk(0.02)
    equity = 100
    available = 2.2  # just enough for 1 contract with buffer
    params = attempt_entry(
        client,
        _detail(),
        sig,
        equity_usdt=equity,
        available_usdt=available,
        cfg={"LEVERAGE": 10},
        risk_mgr=rm,
        user_risk_level=1,
    )
    assert client.last_order is not None
    assert params["vol"] >= 1
    opened = captured["position_opened"]
    assert opened["notional_usdt"] >= 5
    assert opened["vol"] >= 1


def test_attempt_entry_insufficient_margin(monkeypatch):
    captured = {}

    def fake_notify(event, payload):
        captured[event] = payload

    monkeypatch.setattr("bot.notify", fake_notify)
    client = DummyClient()
    sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    rm = DummyRisk(0.02)
    equity = 100
    available = 1.0  # below required margin
    params = attempt_entry(
        client,
        _detail(),
        sig,
        equity_usdt=equity,
        available_usdt=available,
        cfg={"LEVERAGE": 10},
        risk_mgr=rm,
        user_risk_level=1,
    )
    assert client.last_order is None
    assert params["vol"] == 0
    assert captured["order_blocked"]["reason"].startswith("volume reduced")


def test_attempt_entry_under_min_trade(monkeypatch):
    captured = {}

    def fake_notify(event, payload):
        captured[event] = payload

    monkeypatch.setattr("bot.notify", fake_notify)
    client = DummyClient()
    sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    rm = DummyRisk(0.02)
    detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.001,
                "volUnit": 1,
                "minVol": 1,
                "minTradeUSDT": 50,
            }
        ]
    }
    equity = 100
    available = 100
    params = attempt_entry(
        client,
        detail,
        sig,
        equity_usdt=equity,
        available_usdt=available,
        cfg={"LEVERAGE": 10},
        risk_mgr=rm,
        user_risk_level=1,
    )
    assert client.last_order is None
    assert params["vol"] == 0
    assert captured["order_blocked"]["reason"].startswith("volume reduced")


## tests/test_bot_update.py (last modified: 2025-08-22 07:05:27)
import logging
import bot


def test_update_displays_pairs(monkeypatch, caplog):
    def fake_send(client, top_n=40):
        assert (client, top_n) == ("cli", 5)
        return {"green": "BTC", "orange": "ETH", "red": "XRP"}

    monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
    with caplog.at_level(logging.INFO):
        payload = bot.update("cli", top_n=5)
    assert payload["green"] == "BTC"
    assert "Listing ok" in caplog.text


def test_update_survives_errors(monkeypatch, caplog):
    """``update`` should never raise even if pair selection fails."""

    def boom(client, top_n=40):  # pragma: no cover - simulated failure
        raise RuntimeError("network down")

    monkeypatch.setattr(bot, "send_selected_pairs", boom)
    with caplog.at_level(logging.INFO):
        payload = bot.update("cli", top_n=5)

    # The function returns an empty payload and logs the error, but still logs
    # the "Listing ok" acknowledgement so callers can proceed.
    assert payload == {}
    assert "network down" in caplog.text
    assert "Listing ok" in caplog.text



## tests/test_break_even_stop.py (last modified: 2025-08-22 07:05:27)
from scalp.trade_utils import break_even_stop


def test_break_even_stop_long() -> None:
    sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
    assert sl == 100
    sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
    assert sl == 95


def test_break_even_stop_short() -> None:
    sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
    assert sl == 100
    sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
    assert sl == 105


## tests/test_calc_pnl_pct.py (last modified: 2025-08-22 07:05:27)
import os
import sys
import pytest
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from scalp.metrics import calc_pnl_pct


def test_calc_pnl_pct_long():
    assert calc_pnl_pct(100.0, 110.0, 1) == 10.0

def test_calc_pnl_pct_short():
    assert calc_pnl_pct(100.0, 90.0, -1) == 10.0


def test_calc_pnl_pct_with_fee():
    # 10% move minus 0.1%*2 fees = 9.8%
    assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)


## tests/test_check_config.py (last modified: 2025-08-22 07:05:27)
import logging
from bot import check_config


def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
    monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
    monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
    monkeypatch.delenv("NOTIFY_URL", raising=False)
    with caplog.at_level(logging.INFO):
        check_config()
    messages = [r.getMessage() for r in caplog.records]
    assert any("BITGET_ACCESS_KEY" in m for m in messages)
    assert any("BITGET_SECRET_KEY" in m for m in messages)
    assert all("NOTIFY_URL" not in m for m in messages)


def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
    monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
    monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
    monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
    with caplog.at_level(logging.INFO):
        check_config()
    assert caplog.records == []


## tests/test_cli.py (last modified: 2025-08-22 07:05:27)
"""Tests for the command line interface defined in :mod:`cli`."""

from __future__ import annotations

import cli


def test_opt_invokes_parallel_optimization(monkeypatch):
    """The ``opt`` command should call ``run_parallel_optimization``."""

    called = {}

    def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
        called["args"] = (pairs, tf, jobs)

    monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
    cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
    assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)


def test_walkforward_invokes_analysis(monkeypatch):
    """The ``walkforward`` command calls ``run_walkforward_analysis``."""

    called = {}

    def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
        called["args"] = (pair, tf, splits, train_ratio)

    monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
    cli.main(
        [
            "walkforward",
            "--pair",
            "BTCUSDT",
            "--tf",
            "1m",
            "--splits",
            "3",
            "--train-ratio",
            "0.8",
        ]
    )
    assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)


def test_live_invokes_async_pipeline(monkeypatch):
    """The ``live`` command must execute the async pipeline via ``asyncio.run``."""

    called = {}

    async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
        called["args"] = (pairs, list(tfs))

    monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
    cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
    assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])


def test_bump_version_invokes_helper(monkeypatch):
    """The ``bump-version`` command calls ``bump_version_from_git``."""

    called = {}

    def fake_bump():  # pragma: no cover - executed via CLI
        called["called"] = True
        return "0.1.0"

    monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
    cli.main(["bump-version"])
    assert called["called"] is True



## tests/test_client.py (last modified: 2025-08-22 07:05:27)
import json
import hmac
import hashlib
import base64
import pytest
import bot
from bot import BitgetFuturesClient


@pytest.fixture(autouse=True)
def no_log_event(monkeypatch):
    monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)


def test_private_request_get_signature(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    called = {}

    def fake_request(method, url, headers=None, timeout=None):
        called["method"] = method
        called["url"] = url
        called["headers"] = headers

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"success": True}

        return Resp()

    monkeypatch.setattr(bot.requests, "request", fake_request)

    resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
    assert resp["success"] is True
    qs = "a=1&b=2"
    prehash = f"1000GET/api/test?{qs}"
    expected = base64.b64encode(
        hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    ).decode()
    assert called["headers"]["ACCESS-SIGN"] == expected
    assert called["headers"]["ACCESS-KEY"] == "key"
    assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    assert called["url"] == "https://test/api/test?a=1&b=2"


def test_private_request_post_signature(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    called = {}

    def fake_post(url, data=None, headers=None, timeout=None):
        called["url"] = url
        called["data"] = data
        called["headers"] = headers

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"success": True}

        return Resp()

    monkeypatch.setattr(bot.requests, "post", fake_post)

    resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
    assert resp["success"] is True
    body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
    prehash = f"1000POST/api/test{body}"
    expected = base64.b64encode(
        hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    ).decode()
    assert called["headers"]["ACCESS-SIGN"] == expected
    assert called["headers"]["ACCESS-KEY"] == "key"
    assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    assert called["data"].decode("utf-8") == body
    assert called["url"] == "https://test/api/test"


def test_private_request_http_error(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    class Resp:
        status_code = 418

        def raise_for_status(self):
            raise bot.requests.HTTPError("teapot")

        def json(self):
            return {"unused": True}

    monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())

    resp = client._private_request("GET", "/api/test")
    assert resp["success"] is False
    assert resp["status_code"] == 418
    assert "teapot" in resp["error"]


def test_get_assets_normalization(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["params"] = params
        return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    assets = client.get_assets()

    assert assets["success"] is True
    usdt = assets.get("data", [])[0]
    assert usdt["currency"].upper() == "USDT"
    assert usdt["equity"] == 1.0
    assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}


def test_get_assets_equity_fallback(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_private(self, method, path, params=None, body=None):
        return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    assets = client.get_assets()
    usdt = assets.get("data", [])[0]
    assert usdt["currency"] == "USDT"
    assert usdt["equity"] == 2.0


def test_get_assets_prefers_available(monkeypatch):
    """When both equity and available are returned, available should win."""
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_private(self, method, path, params=None, body=None):
        return {
            "code": "00000",
            "data": [
                {
                    "marginCoin": "USDT",
                    "equity": "5",
                    "available": "1",
                }
            ],
        }

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    assets = client.get_assets()
    usdt = assets.get("data", [])[0]
    assert usdt["equity"] == 1.0



def test_get_assets_zero_available(monkeypatch):
    """Zero available balance should propagate as zero equity."""
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_private(self, method, path, params=None, body=None):
        return {
            "code": "00000",
            "data": [
                {
                    "marginCoin": "USDT",
                    "available": "0",
                    "equity": "5",
                }
            ],
        }

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    assets = client.get_assets()
    usdt = assets.get("data", [])[0]
    assert usdt["equity"] == 0.0


def test_get_assets_available_balance(monkeypatch):
    """Support alternative ``availableBalance`` field name."""
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_private(self, method, path, params=None, body=None):
        return {
            "code": "00000",
            "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
        }

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    assets = client.get_assets()
    usdt = assets.get("data", [])[0]
    assert usdt["equity"] == 3.5


def test_get_ticker_normalization(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_get(url, params=None, timeout=None):
        called["url"] = url
        called["params"] = params

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {
                    "data": {
                        "instId": "BTCUSDT",
                        "lastPr": "1",
                        "bestBidPrice": "0.9",
                        "bestAskPrice": "1.1",
                        "usdtVolume": "100",
                    }
                }

        return Resp()

    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    ticker = client.get_ticker("BTC_USDT")

    assert ticker["success"] is True
    data = ticker["data"][0]
    assert data["symbol"] == "BTCUSDT"
    assert data["lastPrice"] == "1"
    assert data["bidPrice"] == "0.9"
    assert data["askPrice"] == "1.1"
    assert data["volume"] == 100.0
    assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}


def test_http_client_context_manager(monkeypatch):
    import sys
    import importlib
    sys.modules.pop('requests', None)
    real_requests = importlib.import_module('requests')
    sys.modules['requests'] = real_requests
    import scalp.client as http_client
    importlib.reload(http_client)

    closed = {"count": 0}

    class DummySession:
        def mount(self, *a, **k):
            pass

        def request(self, *a, **k):
            class Resp:
                def raise_for_status(self):
                    pass

                def json(self):
                    return {}

                text = "{}"

            return Resp()

        def close(self):
            closed["count"] += 1

    monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())

    http = http_client.HttpClient("http://example.com")
    http.close()
    assert closed["count"] == 1

    closed["count"] = 0
    with http_client.HttpClient("http://example.com") as hc:
        hc.request("GET", "/")
    assert closed["count"] == 1


def test_get_kline_query_params(monkeypatch):
    """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
    query parameter. The previous implementation embedded the symbol in the
    path which resulted in a 404 from Bitget."""

    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_get(url, params=None, timeout=None):
        called["url"] = url
        called["params"] = params

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"data": []}

        return Resp()

    # Some tests replace ``bot.requests`` with a lightweight namespace that
    # doesn't define ``get``. ``raising=False`` ensures the attribute is added
    # even if missing so we can observe the call.
    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    client.get_kline("BTC_USDT", interval="Min1")

    assert called["url"].endswith("/api/v2/mix/market/candles")
    assert called["params"] == {
        "symbol": "BTCUSDT",
        "productType": "USDT-FUTURES",
        "granularity": "1m",
    }


def test_get_open_orders_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["params"] = params
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.get_open_orders("BTCUSDT_UMCBL")

    assert called["path"] == "/api/v2/mix/order/orders-pending"
    assert called["params"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
    }


def test_product_type_alias():
    client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
    assert client.product_type == "USDT-FUTURES"


def test_get_contract_detail_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_get(url, params=None, timeout=None):
        called["url"] = url
        called["params"] = params

        class Resp:
            status_code = 200

            def raise_for_status(self):
                pass

            def json(self):
                return {"data": []}

        return Resp()

    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    client.get_contract_detail("BTCUSDT_UMCBL")

    assert called["url"].endswith("/api/v2/mix/market/contracts")
    assert called["params"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
    }


def test_cancel_all_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["params"] = params
        called["body"] = body
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")

    assert called["method"] == "POST"
    assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
    assert called["params"] is None
    assert called["body"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
        "marginCoin": "USDT",
    }


def test_place_order_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    called = {}

    monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["body"] = body
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)

    assert resp["success"] is True
    assert called["method"] == "POST"
    assert called["path"] == "/api/v2/mix/order/place-order"
    body = called["body"]
    assert body["symbol"] == "BTCUSDT"
    assert body["marginCoin"] == "USDT"
    assert body["marginMode"] == "crossed"
    assert body["side"] == "buy"
    assert body["posSide"] == "long"
    assert "reduceOnly" not in body
    assert body["posMode"] == "hedge_mode"


@pytest.mark.parametrize(
    "code, side_str, pos_side",
    [
        (4, "sell", "long"),
        (2, "buy", "short"),
    ],
)
def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["body"] = body
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)

    body = called["body"]
    assert body["side"] == side_str
    assert body["posSide"] == pos_side
    assert "reduceOnly" not in body


def test_place_order_precision(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["body"] = body
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.place_order(
        "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
    )

    assert called["body"]["price"] == 1234.57
    assert called["body"]["size"] == 1.235


def test_margin_cap_skips_order(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
    called = {}

    def fake_private(method, path, **kwargs):
        called["path"] = path
        return {"code": "00000"}

    monkeypatch.setattr(client, "_private_request", fake_private)
    contract_detail = {
        "data": {
            "symbol": "BTCUSDT_UMCBL",
            "contractSize": 1,
            "volUnit": 1,
            "minVol": 1,
            "minTradeUSDT": 5,
        }
    }
    price = 100.0
    available = 0.5
    vol = bot.compute_position_size(
        contract_detail,
        equity_usdt=available,
        price=price,
        risk_pct=1.0,
        leverage=10,
        symbol="BTCUSDT_UMCBL",
        available_usdt=available,
    )
    if vol > 0:
        client.place_order(
            "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
        )
    assert called == {}


def test_margin_cap_reduces_volume(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
    called = {}

    def fake_private(method, path, **kwargs):
        called["body"] = kwargs.get("body")
        return {"code": "00000"}

    monkeypatch.setattr(client, "_private_request", fake_private)
    contract_detail = {
        "data": {
            "symbol": "BTCUSDT_UMCBL",
            "contractSize": 1,
            "volUnit": 1,
            "minVol": 1,
            "minTradeUSDT": 5,
        }
    }
    price = 10.0
    vol_theoretical = bot.compute_position_size(
        contract_detail,
        equity_usdt=100,
        price=price,
        risk_pct=1.0,
        leverage=10,
        symbol="BTCUSDT_UMCBL",
    )
    available = 20.0
    vol_final = bot.compute_position_size(
        contract_detail,
        equity_usdt=available,
        price=price,
        risk_pct=1.0,
        leverage=10,
        symbol="BTCUSDT_UMCBL",
        available_usdt=available,
    )
    assert vol_final < vol_theoretical
    client.place_order(
        "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
    )
    assert called["body"]["size"] == vol_final

def test_get_open_orders_paper_trade(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)

    called = {"count": 0}

    def fake_private(*a, **k):
        called["count"] += 1
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    resp = client.get_open_orders("BTCUSDT_UMCBL")

    assert resp["success"] is True
    assert resp["data"] == []
    assert called["count"] == 0


def test_cancel_all_paper_trade(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)

    called = {"count": 0}

    def fake_private(*a, **k):
        called["count"] += 1
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")

    assert resp["success"] is True
    assert called["count"] == 0


def test_get_kline_transforms_data(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_get(url, params=None, timeout=None):
        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {
                    "data": [
                        ["1", "2", "3", "1", "2", "10", "20"],
                        ["2", "3", "4", "2", "3", "11", "21"],
                    ]
                }

        return Resp()

    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    data = client.get_kline("BTC_USDT", interval="1m")
    kdata = data["data"]
    assert kdata["open"] == [2.0, 3.0]
    assert kdata["high"] == [3.0, 4.0]
    assert kdata["low"] == [1.0, 2.0]
    assert kdata["close"] == [2.0, 3.0]
    assert kdata["volume"] == [10.0, 11.0]
    assert kdata["quoteVolume"] == [20.0, 21.0]


## tests/test_compute_position_size.py (last modified: 2025-08-22 07:05:27)
import os
import sys
import types
import pytest

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules["requests"] = types.ModuleType("requests")
import bot  # noqa: E402
from bot import compute_position_size  # noqa: E402


def test_compute_position_size_basic():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
                                risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    assert vol == 1


def test_compute_position_size_symbol_not_found():
    contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
    with pytest.raises(ValueError):
        compute_position_size(contract_detail, equity_usdt=1000, price=500,
                                risk_pct=0.01, leverage=10, symbol="BTC_USDT")


def test_compute_position_size_invalid_price():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=1000,
        price=0,
        risk_pct=0.01,
        leverage=10,
        symbol="BTC_USDT",
    )
    assert vol == 0


def test_compute_position_size_respects_equity():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 1,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=5,
        price=100,
        risk_pct=0.01,
        leverage=10,
        symbol="BTC_USDT",
    )
    assert vol == 0


def test_compute_position_size_leaves_fee_buffer():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 1,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=100,
        price=100,
        risk_pct=1.0,
        leverage=1,
        symbol="BTC_USDT",
    )
    assert vol == 0


def test_compute_position_size_under_min_notional_returns_zero():
    contract_detail = {
        "data": [
            {
                "symbol": "PI_USDT",
                "contractSize": 1,
                "volUnit": 1,
                "minVol": 1,
                "minTradeUSDT": 5,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=100,
        price=0.5,
        risk_pct=0.0001,
        leverage=20,
        symbol="PI_USDT",
    )
    assert vol == 0


def test_compute_position_size_cap_by_available():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 1,
                "volUnit": 2,
                "minVol": 2,
                "minTradeUSDT": 5,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=100,
        price=10,
        risk_pct=0.5,
        leverage=10,
        symbol="BTC_USDT",
        available_usdt=0.5,
    )
    assert vol == 0
    vol = compute_position_size(
        contract_detail,
        equity_usdt=100,
        price=10,
        risk_pct=0.5,
        leverage=10,
        symbol="BTC_USDT",
        available_usdt=10,
    )
    assert vol == 8
    fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
    required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
    assert required <= 10


## tests/test_compute_position_size_cap.py (last modified: 2025-08-22 07:05:27)
import os
import sys
import types
import pytest

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')

from bot import compute_position_size, CONFIG


def _detail(vol_unit=1, min_vol=1, min_trade=5):
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.001,
                "volUnit": vol_unit,
                "minVol": min_vol,
                "minTradeUSDT": min_trade,
            }
        ]
    }


def test_volume_zero_when_available_low():
    detail = _detail()
    vol = compute_position_size(
        detail,
        equity_usdt=1000,
        price=10000,
        risk_pct=0.01,
        leverage=10,
        symbol="BTC_USDT",
        available_usdt=0.5,
    )
    assert vol == 0


def test_margin_close_to_available():
    detail = _detail()
    CONFIG["FEE_RATE"] = 0.001
    available = 1.05
    vol = compute_position_size(
        detail,
        equity_usdt=1000,
        price=10000,
        risk_pct=1,
        leverage=10,
        symbol="BTC_USDT",
        available_usdt=available,
    )
    assert vol == 1
    notional = 10000 * 0.001 * vol
    fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
    required = (notional / 10 + fee) * 1.03
    assert required == pytest.approx(available, rel=0.05)


def test_respects_units_and_minimums():
    detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
    vol = compute_position_size(
        detail,
        equity_usdt=1000,
        price=1000,
        risk_pct=1,
        leverage=5,
        symbol="BTC_USDT",
        available_usdt=1000,
    )
    assert vol % 2 == 0 and vol >= 2


## tests/test_dynamic_allocation.py (last modified: 2025-08-22 07:05:27)
import math
from scalp.risk import adjust_risk_pct


def test_adjust_risk_pct_increase_decrease():
    base = 0.01
    assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
    assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base


def test_adjust_risk_pct_bounds():
    assert math.isclose(
        adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
    )
    assert math.isclose(
        adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
    )


## tests/test_effective_leverage.py (last modified: 2025-08-22 07:05:27)
import pytest
from scalp.trade_utils import effective_leverage


def test_effective_leverage_basic():
    lev = effective_leverage(
        entry_price=100.0,
        liquidation_price=90.0,
        position_margin=10.0,
        position_size=1.0,
    )
    assert lev == pytest.approx(10.0)


def test_effective_leverage_estimated_margin():
    lev = effective_leverage(
        entry_price=200.0,
        liquidation_price=180.0,
        position_margin=0.0,
        position_size=2.0,
    )
    # price diff 20 * size 2 -> margin 40; notional 400
    assert lev == pytest.approx(10.0)


def test_effective_leverage_short_position():
    lev = effective_leverage(
        entry_price=100.0,
        liquidation_price=110.0,
        position_margin=10.0,
        position_size=-1.5,
    )
    assert lev == pytest.approx(15.0)


def test_effective_leverage_invalid():
    assert effective_leverage(0, 0, 0, 0) == 0.0


## tests/test_env_loading.py (last modified: 2025-08-22 07:05:27)
"""Tests for loading environment variables from ``notebook/.env``."""

from __future__ import annotations

import importlib
import os
import sys
from pathlib import Path


def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
    """Module should load variables from ``notebook/.env`` if present."""

    notebook = tmp_path / "notebook"
    spot = notebook / "spot"
    spot.mkdir(parents=True)
    bitget_bot = spot / "bitget_bot.py"
    bitget_bot.write_text("")
    env_file = notebook / ".env"
    env_file.write_text("BITGET_ACCESS_KEY=from_env\n")

    old = os.environ.pop("BITGET_ACCESS_KEY", None)
    monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
    import scalp

    importlib.reload(scalp)

    try:
        assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
    finally:
        env_file.unlink(missing_ok=True)
        if old is None:
            os.environ.pop("BITGET_ACCESS_KEY", None)
        else:
            os.environ["BITGET_ACCESS_KEY"] = old


## tests/test_grid_search.py (last modified: 2025-08-22 12:29:12)
import json
import random

import pytest

from backtest import grid_search


def test_build_grid_sampling():
    param_lists = {
        "timeframe": ["1m", "5m", "15m"],
        "score_min": [50, 55, 60],
        "atr_min_ratio": [0.0015, 0.002, 0.003],
    }
    combos = grid_search.build_param_grid(param_lists, grid_max=6)
    assert len(combos) == 6
    tfs = {c["timeframe"] for c in combos}
    assert {"1m", "5m", "15m"}.issubset(tfs)


def test_run_grid_search_with_mock(tmp_path):
    calls = []

    def fake_run_backtest_multi(**kwargs):
        tf = kwargs.get("timeframe")
        risk = kwargs.get("risk_pct")
        # fabricate metrics based on params
        pf = {"1m": 1.5, "5m": 3.0}[tf]
        pf += risk  # tiny variation
        metrics = {
            "symbol": "TOTAL",
            "pnl_usdt": 100 * risk,
            "profit_factor": pf,
            "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
            "winrate_pct": 50.0,
            "trades": 40 if tf == "1m" else 30,
        }
        calls.append((tf, risk))
        return [metrics], []

    param_lists = {
        "timeframe": ["1m", "5m"],
        "risk_pct": [0.005, 0.01],
    }
    base_params = {
        "timeframe": "1m",
        "risk_pct": 0.005,
    }
    out_dir = tmp_path / "grid"
    grid_search.run_grid_search(
        symbols=["BTC/USDT"],
        exchange="csv",
        base_params=base_params,
        param_lists=param_lists,
        grid_max=4,
        csv_dir="/dev/null",
        out_dir=str(out_dir),
        run_func=fake_run_backtest_multi,
    )
    best = json.loads((out_dir / "best_config.json").read_text())
    # best PF should be timeframe 5m risk 0.01
    assert best["params"]["timeframe"] == "5m"
    assert best["params"]["risk_pct"] == 0.01
    assert len(calls) == 4


def test_parse_hours():
    assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]


def test_deterministic_results(tmp_path):
    def fake_run_backtest_multi(**kwargs):
        # metrics vary with global random state
        pf = random.uniform(1.0, 3.0)
        metrics = {
            "symbol": "TOTAL",
            "pnl_usdt": random.uniform(-10, 10),
            "profit_factor": pf,
            "max_drawdown_pct": random.uniform(1, 5),
            "winrate_pct": 50.0,
            "trades": random.randint(10, 50),
        }
        return [metrics], []

    param_lists = {"timeframe": ["1m", "5m"]}
    base_params = {"timeframe": "1m"}
    out_dir = tmp_path / "grid"
    res1 = grid_search.run_grid_search(
        symbols=["BTC/USDT"],
        exchange="csv",
        base_params=base_params,
        param_lists=param_lists,
        grid_max=2,
        csv_dir="/dev/null",
        out_dir=str(out_dir),
        seed=42,
        run_func=fake_run_backtest_multi,
    )
    best1 = json.loads((out_dir / "best_config.json").read_text())
    # run again
    out_dir2 = tmp_path / "grid2"
    res2 = grid_search.run_grid_search(
        symbols=["BTC/USDT"],
        exchange="csv",
        base_params=base_params,
        param_lists=param_lists,
        grid_max=2,
        csv_dir="/dev/null",
        out_dir=str(out_dir2),
        seed=42,
        run_func=fake_run_backtest_multi,
    )
    best2 = json.loads((out_dir2 / "best_config.json").read_text())
    assert best1 == best2
    # also ensure results object same best params
    assert res1[0].params == res2[0].params


## tests/test_heat_score.py (last modified: 2025-08-22 07:05:27)
from scalp.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs


def test_heat_score_value():
    assert heat_score(2.0, 100.0) == 200.0
    assert heat_score(2.0, 100.0, news=True) == 400.0


def test_select_and_decorrelate_pairs():
    pairs = [
        {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
        {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
        {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
        {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
    ]
    top = select_top_heat_pairs(pairs, top_n=3)
    assert len(top) == 3
    corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
    selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
    syms = {p["symbol"] for p in selected}
    assert not ("A" in syms and "B" in syms)


## tests/test_indicators.py (last modified: 2025-08-22 07:05:27)


import os
import sys
import pytest
sys.path.append(os.path.dirname(os.path.dirname(__file__)))




from scalp.metrics import calc_rsi, calc_atr, calc_macd


def test_calc_rsi_uptrend():
    prices = list(range(1, 16))  # strictly increasing
    assert calc_rsi(prices, period=14) == pytest.approx(100.0)


def test_calc_rsi_downtrend():
    prices = list(range(15, 0, -1))  # strictly decreasing
    assert calc_rsi(prices, period=14) == pytest.approx(0.0)



def test_calc_rsi_flat():
    prices = [1.0] * 15  # no movement
    assert calc_rsi(prices, period=14) == pytest.approx(50.0)



    highs = [10, 11, 12, 13, 14]
    lows = [9, 10, 11, 12, 13]
    closes = [9.5, 10.5, 11.5, 12.5, 13.5]
    assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)


def test_calc_macd_trend():
    prices = list(range(1, 60))
    macd, signal, hist = calc_macd(prices)
    assert macd > signal
    assert hist > 0


def test_calc_macd_flat():
    prices = [100.0] * 60
    macd, signal, hist = calc_macd(prices)
    assert macd == pytest.approx(0.0)
    assert signal == pytest.approx(0.0)
    assert hist == pytest.approx(0.0)



@pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
def test_calc_rsi_invalid_inputs(prices, period):
    with pytest.raises(ValueError):
        calc_rsi(prices, period=period)


@pytest.mark.parametrize(
    "highs, lows, closes, period",
    [
        ([1, 2, 3], [1, 2], [1, 2, 3], 2),
        ([1, 2], [1, 1], [1, 1], 3),
    ],
)
def test_calc_atr_invalid_inputs(highs, lows, closes, period):
    with pytest.raises(ValueError):
        calc_atr(highs, lows, closes, period=period)



## tests/test_min_qty_rules.py (last modified: 2025-08-22 12:29:12)
import os
import sys
import types

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')

from bot import _apply_contract_checks


def _detail():
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 1,
                "volUnit": 5,
                "minVol": 10,
                "minTradeUSDT": 5,
            }
        ]
    }


def test_min_qty_floor_and_validation():
    detail = _detail()
    vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
    assert vol == 10
    vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
    assert vol2 == 0


## tests/test_notifier.py (last modified: 2025-08-22 12:29:12)
import scalp.notifier as notifier


def test_notify_skips_without_targets(monkeypatch):
    called = False

    def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
        nonlocal called
        called = True

    monkeypatch.delenv("NOTIFY_URL", raising=False)
    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    monkeypatch.setattr(notifier.requests, "post", fake_post)
    notifier.notify("test", {"foo": 1})
    assert called is False


def test_notify_posts_http(monkeypatch):
    payload = {}

    def fake_post(url, json=None, timeout=5):
        payload["url"] = url
        payload["json"] = json
        payload["timeout"] = timeout

    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    monkeypatch.setattr(notifier.requests, "post", fake_post)
    notifier.notify("evt", {"bar": 2})
    assert payload["url"] == "http://example.com"
    assert payload["json"]["event"] == "evt"
    assert payload["json"]["bar"] == 2


def test_notify_posts_telegram(monkeypatch):
    payload = {}

    def fake_post(url, json=None, timeout=5):
        payload["url"] = url
        payload["json"] = json
        payload["timeout"] = timeout

    monkeypatch.delenv("NOTIFY_URL", raising=False)
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    monkeypatch.setattr(notifier.requests, "post", fake_post)

    notifier.notify("evt", {"bar": 2})

    assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
    assert payload["json"]["chat_id"] == "123"
    assert "evt" in payload["json"]["text"]


def test_notify_posts_both(monkeypatch):
    calls = []

    def fake_post(url, json=None, timeout=5):
        calls.append({"url": url, "json": json, "timeout": timeout})

    monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    monkeypatch.setattr(notifier.requests, "post", fake_post)

    notifier.notify("evt", {"bar": 2})

    assert len(calls) == 2
    urls = {c["url"] for c in calls}
    assert "http://example.com" in urls
    assert "https://api.telegram.org/botabc/sendMessage" in urls


def test_notify_skips_telegram_for_pair_list(monkeypatch):
    calls = []

    def fake_post(url, json=None, timeout=5):
        calls.append(url)

    monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    monkeypatch.setattr(notifier.requests, "post", fake_post)

    notifier.notify("pair_list", {"pairs": "BTC"})

    # Only the generic webhook should be called, not Telegram
    assert calls == ["http://example.com"]


def test_format_text_open_position():
    payload = {
        "symbol": "BTCUSDT",
        "side": "short",
        "price": 18350,
        "vol": 37,
        "contract_size": 1,
        "notional_usdt": 120.5,
        "leverage": 5,
        "required_margin_usdt": 25.3,
        "available_usdt": 134,
        "risk_level_user": 3,
        "signal_level": 2,
        "risk_color": "🟡",
        "risk_pct_eff": 0.01,
        "fee_rate": 0.001,
    }
    text = notifier._format_text("position_opened", payload)
    lines = text.splitlines()

    assert lines[0] == "🟡 Ouvre short BTC"
    assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
    assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
    assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
    assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"


def test_format_text_closed_position():
    payload = {
        "symbol": "BTCUSDT",
        "side": "short",
        "entry_price": 18350,
        "exit_price": 18328,
        "vol": 37,
        "contract_size": 1,
        "notional_entry_usdt": 120.5,
        "notional_exit_usdt": 120.3,
        "fees_usdt": 0.03,
        "pnl_usdt": 0.84,
        "pnl_pct_on_margin": 3.25,
        "leverage": 5,
        "risk_color": "🟡",
        "fee_rate": 0.001,
    }
    text = notifier._format_text("position_closed", payload)
    lines = text.splitlines()
    assert lines[0] == "Ferme short BTC 🟡"
    assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
    assert lines[2] == "% sur marge: 3.25%"
    assert lines[3] == "Entrée: 18350  Sortie: 18328"
    assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"


def test_format_text_pair_list_and_start():
    assert notifier._format_text("bot_started") == "🤖 Bot démarré"
    text = notifier._format_text(
        "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
    )
    assert text == "Listing ok"


def test_format_pair_list_helper():
    payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
    text = notifier._format_pair_list(payload)
    assert text == "Listing ok"


def test_format_position_event_helper():
    payload = {
        "symbol": "BTCUSDT",
        "side": "short",
        "price": 18350,
        "vol": 37,
        "contract_size": 1,
        "notional_usdt": 120.5,
        "leverage": 5,
        "required_margin_usdt": 25.3,
        "available_usdt": 134,
        "risk_level_user": 3,
        "signal_level": 2,
        "risk_color": "🟡",
        "risk_pct_eff": 0.01,
        "fee_rate": 0.001,
    }
    text = notifier._format_position_event("position_opened", payload)
    assert text.splitlines()[0] == "🟡 Ouvre short BTC"




## tests/test_notional_and_pnl_units.py (last modified: 2025-08-22 12:29:12)
import os, sys, types, pytest
sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')

from scalp.trade_utils import (
    get_contract_size,
    notional as calc_notional,
    required_margin as calc_required_margin,
    compute_pnl_usdt,
    compute_pnl_with_fees,
)


def _detail():
    return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}


def test_notional_and_pnl_units():
    detail = _detail()
    cs = get_contract_size(detail, "BTC_USDT")
    N = calc_notional(10000, 2, cs)
    assert N == pytest.approx(10000 * 0.001 * 2)
    margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
    assert margin == pytest.approx(N / 10 + 0.001 * N)
    pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
    assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
    pnl_net, pct = compute_pnl_with_fees(
        detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
    )
    gross = (10100 - 10000) * cs * 2
    fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
    expected = gross - fees
    expected_pct = expected / (N / 10) * 100
    assert pnl_net == pytest.approx(expected)
    assert pct == pytest.approx(expected_pct)


## tests/test_pair_selection.py (last modified: 2025-08-22 07:05:27)
import bot


def test_get_trade_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {"symbol": "BTC_USDT"},
                    {"symbol": "ETH_USDT"},
                ],
            }

    pairs = bot.get_trade_pairs(Client())
    assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]


def test_select_top_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {"symbol": "A", "volume": "1"},
                    {"symbol": "B", "volume": "3"},
                    {"symbol": "C", "volume": "2"},
                ],
            }

    top = bot.select_top_pairs(Client(), top_n=2)
    assert [p["symbol"] for p in top] == ["B", "C"]


def test_select_top_pairs_default_count():
    class Client:
        def get_ticker(self, symbol=None):
            data = []
            for i in range(100):
                data.append({"symbol": str(i), "volume": str(i)})
            return {"success": True, "data": data}

    top = bot.select_top_pairs(Client())
    assert len(top) == 40


def test_filter_trade_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {
                        "symbol": "AAA",
                        "volume": "6000000",
                        "bidPrice": "100",
                        "askPrice": "100.03",
                    },  # spread ~3 bps
                    {
                        "symbol": "BBB",
                        "volume": "10000000",
                        "bidPrice": "50",
                        "askPrice": "50.1",
                    },  # spread ~200 bps
                    {
                        "symbol": "CCC",
                        "volume": "7000000",
                        "bidPrice": "10",
                        "askPrice": "10.01",
                    },  # spread ~100 bps
                    {
                        "symbol": "DDD",
                        "volume": "4000000",
                        "bidPrice": "20",
                        "askPrice": "20.01",
                    },  # volume trop faible
                ],
            }

    pairs = bot.filter_trade_pairs(
        Client(),
        volume_min=5_000_000,
        max_spread_bps=5,
    )
    assert [p["symbol"] for p in pairs] == ["AAA"]


def test_find_trade_positions(monkeypatch):
    class Client:
        def __init__(self):
            self.data = {
                "AAA": {"data": {"close": [1, 2, 3]}},
                "BBB": {"data": {"close": [3, 2, 1]}},
            }

        def get_kline(self, symbol, interval="1m"):
            return self.data[symbol]

    pairs = [
        {"symbol": "AAA", "lastPrice": "1"},
        {"symbol": "BBB", "lastPrice": "1"},
    ]

    monkeypatch.setattr(bot, "ema", lambda series, window: series)

    def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
        if last_fast > prev_fast:
            return 1
        if last_fast < prev_fast:
            return -1
        return 0

    monkeypatch.setattr(bot, "cross", fake_cross)

    signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
    assert signals == [
        {"symbol": "AAA", "signal": "long", "price": 1.0},
        {"symbol": "BBB", "signal": "short", "price": 1.0},
    ]


## tests/test_pairs.py (last modified: 2025-08-22 07:05:27)
import bot


def test_send_selected_pairs(monkeypatch):
    sent = {}

    def fake_notify(event, payload=None):
        sent["event"] = event
        sent["payload"] = payload

    monkeypatch.setattr(bot, "notify", fake_notify)
    monkeypatch.setattr(
        bot,
        "filter_trade_pairs",
        lambda client, top_n=120: [
            {"symbol": "WIFUSDT", "volume": 10},
            {"symbol": "WIFUSDT", "volume": 9},
            {"symbol": "BTCUSD", "volume": 8},
            {"symbol": "BTCUSDT", "volume": 7},
            {"symbol": "DOGEUSDT", "volume": 6},
            {"symbol": "ETHUSDC", "volume": 5},
            {"symbol": "ETHUSDT", "volume": 4},
        ],
    )

    monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])

    payload = bot.send_selected_pairs(object(), top_n=4)

    assert sent["event"] == "pair_list"
    assert sent["payload"]["green"] == "BTC"
    assert sent["payload"]["orange"] == "ETH"
    assert "red" not in sent["payload"]
    assert payload == sent["payload"]


def test_send_selected_pairs_no_whitelist(monkeypatch):
    sent = {}

    def fake_notify(event, payload=None):
        sent["payload"] = payload

    monkeypatch.setattr(bot, "notify", fake_notify)
    monkeypatch.setattr(
        bot,
        "filter_trade_pairs",
        lambda client, top_n=120: [
            {"symbol": "AAAUSDT", "volume": 10},
            {"symbol": "BBBUSD", "volume": 9},
            {"symbol": "CCCUSDC", "volume": 8},
            {"symbol": "DDDUSDT", "volume": 7},
        ],
    )
    monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])

    payload = bot.send_selected_pairs(object(), top_n=4)

    assert payload == sent["payload"]
    assert payload["green"] == "AAA"
    assert payload["orange"] == "BBB"
    assert payload["red"] == "CCC, DDD"


def test_filter_trade_pairs_all_pairs(monkeypatch):
    class DummyClient:
        def get_ticker(self):
            return {
                "data": [
                    {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
                    {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
                ]
            }

    client = DummyClient()
    res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
    assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]



## tests/test_risk_manager.py (last modified: 2025-08-22 07:05:27)
from scalp import RiskManager


def test_kill_switch_triggered() -> None:
    rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(-1.0)
    rm.record_trade(-1.5)
    assert rm.kill_switch is True


def test_profit_kill_switch_triggered() -> None:
    rm = RiskManager(
        max_daily_loss_pct=10.0,
        max_daily_profit_pct=3.0,
        max_positions=1,
        risk_pct=0.01,
    )
    rm.record_trade(1.5)
    rm.record_trade(1.6)
    assert rm.kill_switch is True


def test_pause_and_can_open() -> None:
    rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(-0.5)
    rm.record_trade(-0.6)
    rm.record_trade(-0.7)
    assert rm.pause_duration() == 15 * 60
    rm.record_trade(-0.8)
    rm.record_trade(-0.9)
    assert rm.pause_duration() == 60 * 60
    assert rm.can_open(0) is True
    assert rm.can_open(1) is False


def test_risk_pct_scaling() -> None:
    rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(1.0)
    rm.record_trade(1.0)
    assert rm.risk_pct > 0.01
    rm.record_trade(-1.0)
    rm.record_trade(-1.0)
    assert rm.risk_pct < 0.01


## tests/test_risk_utils.py (last modified: 2025-08-22 07:05:27)
import pytest

from scalp.risk import calc_risk_amount, calc_position_size


def test_calc_risk_amount_basic():
    assert calc_risk_amount(1000, 0.01) == 10.0


def test_calc_position_size_basic():
    # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
    assert calc_position_size(1000, 0.01, 50) == 0.2


@pytest.mark.parametrize("equity,risk_pct", [
    (0, 0.01),
    (-100, 0.01),
    (1000, 0),
    (1000, -0.1),
    (1000, 1.5),
])
def test_calc_risk_amount_invalid(equity, risk_pct):
    with pytest.raises(ValueError):
        calc_risk_amount(equity, risk_pct)


@pytest.mark.parametrize("stop_distance", [0, -1])
def test_calc_position_size_invalid_stop(stop_distance):
    with pytest.raises(ValueError):
        calc_position_size(1000, 0.01, stop_distance)


## tests/test_signal_risk.py (last modified: 2025-08-22 12:29:12)
import types
import os
import sys

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')

from bot import (
    map_score_to_sig_level,
    compute_risk_params,
    prepare_order,
    Signal,
    CONFIG,
)


class DummyRisk:
    def __init__(self, pct: float) -> None:
        self.risk_pct = pct


def _contract_detail():
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.001,
                "volUnit": 1,
                "minVol": 1,
                "minTradeUSDT": 5,
            }
        ]
    }


def test_score_to_level_mapping():
    assert map_score_to_sig_level(10) == 1
    assert map_score_to_sig_level(35) == 2
    assert map_score_to_sig_level(69.9) == 2
    assert map_score_to_sig_level(70) == 3


def test_risk_tables():
    rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
    assert rp == 0.01 * 1.25
    assert lev == int(20 * 0.75)
    assert cap == 0.55
    rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
    assert rp2 == 0.01 * 1.0
    assert lev2 == int(20 * 0.5)
    assert cap2 == 0.35


def test_notional_cap():
    rm = DummyRisk(0.05)
    sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    available = 1000
    params = prepare_order(
        sig,
        _contract_detail(),
        equity_usdt=available,
        available_usdt=available,
        base_leverage=10,
        risk_mgr=rm,
        user_risk_level=2,
    )
    assert params["notional"] <= params["cap_ratio"] * available + 1e-6


## tests/test_slippage.py (last modified: 2025-08-22 07:05:27)
from scalp.trade_utils import marketable_limit_price


def test_marketable_limit_price_buy_sell():
    price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
    assert price_buy == 10.0 * 1.001
    price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
    assert price_sell == 9.9 * (1 - 0.001)


## tests/test_strategy_v2.py (last modified: 2025-08-22 07:05:27)
import pytest

from scalp import strategy
from scalp.trade_utils import trailing_stop, should_scale_in, timeout_exit


def make_ohlcv(n=60, start=100, step=1):
    closes = [start + i * step for i in range(n)]
    highs = [c + 1 for c in closes]
    lows = [c - 1 for c in closes]
    vols = [1 for _ in closes]
    return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}


def test_generate_signal_atr_adaptation(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    # patches for deterministic RSI values
    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    # low ATR -> signal disabled
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig is None

    # high ATR -> size reduced
    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig and sig.side == "long"
    assert sig.qty == 50


def test_generate_signal_short_with_filters(monkeypatch):
    base = make_ohlcv(start=200, step=-2)
    ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
    ohlcv_1h = make_ohlcv(start=200, step=-2)

    rsi_vals = iter([40, 59, 61])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
        tick_ratio_buy=0.4,
    )
    assert sig and sig.side == "short"
    assert sig.qty == 100


def test_trailing_and_timeout():
    # trailing stop
    sl = trailing_stop("long", current_price=110, atr=10, sl=90)
    assert sl == pytest.approx(102.5)
    # scaling
    assert should_scale_in(100, 105, 100, 10, "long") is True
    assert should_scale_in(100, 95, 100, 10, "short") is True
    # timeout
    # before the progress window no exit should be triggered
    assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    # after ``progress_min`` minutes without favourable movement we close
    assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)


def test_generate_signal_macd_filter(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
    monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig is None



def test_generate_signal_trend_ema_filter(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)

    orig_ema = strategy.ema

    def fake_ema(series, window):
        if window == 200:
            return [x + 1000 for x in orig_ema(series, window)]
        return orig_ema(series, window)

    monkeypatch.setattr(strategy, "ema", fake_ema)

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
        trend_ema_period=200,
    )
    assert sig is None
    

## tests/test_telegram_bot.py (last modified: 2025-08-22 07:05:27)
from scalp.telegram_bot import TelegramBot


class DummyClient:

    def __init__(self):
        self.closed = []
        self.closed_all = False


    def get_assets(self):
        return {"data": [{"currency": "USDT", "equity": 123.45}]}

    def get_positions(self):
        return {
            "data": [
                {
                    "symbol": "BTC_USDT",
                    "side": "long",
                    "vol": 2,
                    "pnl_usd": 1.0,
                    "pnl_pct": 5.0,
                }
            ]
        }

    def close_position(self, sym):
        self.closed.append(sym)

    def close_all_positions(self):
        self.closed_all = True



class DummyRiskMgr:

    def __init__(self):
        self.reset_called = False
        self.max_positions = 1
        self.risk_pct = 0.01

    def reset_day(self):
        self.reset_called = True


class DummyRequests:
    def __init__(self):
        self.posts = []

    def post(self, url, json=None, timeout=5):
        self.posts.append((url, json))

    def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
        return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()


def make_bot(config=None, requests_module=None):
    cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
    if config:
        cfg.update(config)
    if requests_module is None:
        requests_module = DummyRequests()
    return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)


def test_handle_balance():
    bot = make_bot()

    resp, kb = bot.handle_callback("balance", 0.0)
    assert "123.45" in resp
    assert kb == bot.main_keyboard



def test_handle_positions():
    bot = make_bot()
    resp, _ = bot.handle_callback("positions", 0.0)
    assert "BTC" in resp
    assert "PnL" in resp


def test_handle_positions_zero_pnl():
    bot = make_bot()

    def zero_positions():
        return {
            "data": [
                {
                    "symbol": "BTC_USDT",
                    "side": "long",
                    "vol": 1,
                    "pnl_usd": 0.0,
                    "pnl_pct": 0.0,
                }
            ]
        }

    bot.client.get_positions = zero_positions
    resp, _ = bot.handle_callback("positions", 0.0)
    assert "PnL: 0.00 USDT" in resp



def test_handle_pnl():
    bot = make_bot()
    resp, _ = bot.handle_callback("pnl", 5.0)

    assert "5.00" in resp


def test_handle_risk_change():
    bot = make_bot()

    resp, kb = bot.handle_callback("risk_red", 0.0)
    assert "3" in resp
    assert bot.config["RISK_LEVEL"] == 3
    assert kb == bot.main_keyboard


def test_risk_menu():
    bot = make_bot()
    resp, kb = bot.handle_callback("risk", 0.0)
    assert "risque" in resp.lower()
    assert kb == bot.risk_keyboard



def test_stop_menu_and_actions():
    bot = make_bot()
    resp, kb = bot.handle_callback("stop", 0.0)
    assert any(
        btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
    )
    assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
    resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
    assert "fermée" in resp.lower()
    assert bot.client.closed == ["BTC_USDT"]
    resp, _ = bot.handle_callback("stop_all", 0.0)
    assert bot.client.closed_all is True


def test_handle_unknown():
    bot = make_bot()
    resp, kb = bot.handle_callback("foobar", 0.0)
    assert resp is None
    assert kb is None


def test_reset_all():
    bot = make_bot()
    resp, kb = bot.handle_callback("reset_all", 0.0)
    assert "réinitialisés" in resp.lower()
    assert bot.risk_mgr.reset_called is True
    assert bot.client.closed_all is True
    assert kb == bot.settings_keyboard


def test_shutdown_bot():
    bot = make_bot()
    resp, kb = bot.handle_callback("shutdown", 0.0)
    assert "arrêt" in resp.lower()
    assert bot.stop_requested is True
    assert kb == bot.main_keyboard


def test_start_sends_menu():
    req = DummyRequests()
    make_bot(requests_module=req)
    assert req.posts
    text = req.posts[0][1]["text"]
    assert "Solde" in text and "PnL session" in text
    assert "Positions max" in text
    assert "Risque actuel" in text


def test_settings_menu_and_reset_risk():
    bot = make_bot()
    resp, kb = bot.handle_callback("settings", 0.0)
    assert "réglages" in resp.lower()
    assert kb == bot.settings_keyboard
    resp, kb = bot.handle_callback("reset_risk", 0.0)
    assert "risque" in resp.lower()
    assert bot.risk_mgr.reset_called is True
    assert kb == bot.settings_keyboard


def test_update_button(monkeypatch):
    bot = make_bot()
    called = {}

    def fake_update():
        called["called"] = True

    bot.update_pairs = fake_update
    resp, kb = bot.handle_callback("update", 0.0)
    assert called["called"] is True
    assert "mise à jour" in resp.lower()
    assert kb == bot.main_keyboard


def test_maxpos_menu_and_change():
    bot = make_bot()
    resp, kb = bot.handle_callback("maxpos", 0.0)
    assert "nombre" in resp.lower()
    assert kb == bot.maxpos_keyboard
    resp, kb = bot.handle_callback("maxpos_3", 0.0)
    assert "3" in resp
    assert bot.config["MAX_POSITIONS"] == 3
    assert bot.risk_mgr.max_positions == 3
    assert kb == bot.main_keyboard


def test_stop_no_positions():
    bot = make_bot()
    bot.client.get_positions = lambda: {"data": []}
    resp, kb = bot.handle_callback("stop", 0.0)
    assert "aucune crypto" in resp.lower()
    assert kb == bot.settings_keyboard



## tests/test_utils.py (last modified: 2025-08-22 07:05:27)
import pytest
from bot import ema, cross, compute_position_size, CONFIG
from scalp.trade_utils import extract_available_balance


def test_ema_basic():
    data = [1, 2, 3, 4, 5]
    result = ema(data, 3)
    assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])


def test_cross_up_down_none():
    assert cross(3, 2, 1, 2) == 1  # up cross
    assert cross(0.5, 1, 2, 1) == -1  # down cross
    assert cross(2, 2, 2, 2) == 0  # no cross


def test_compute_position_size():
    detail = {
        "data": [
            {
                "symbol": CONFIG["SYMBOL"],
                "contractSize": 0.001,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
                                risk_pct=0.01, leverage=5)
    assert vol == 1


def test_compute_position_size_missing_symbol():
    with pytest.raises(ValueError):
        compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)


def test_extract_available_balance_fallback():
    assets = {
        "data": [
            {
                "currency": "USDT",
                "available": 0,
                "cashBalance": "150.5",
                "equity": "200",
            }
        ]
    }
    assert extract_available_balance(assets) == 150.5


def test_extract_available_balance_equity_only():
    assets = {
        "data": [
            {
                "currency": "USDT",
                "equity": "42",
            }
        ]
    }
    assert extract_available_balance(assets) == 42.0


def test_extract_available_balance_zero_available_returns_zero():
    assets = {
        "data": [
            {
                "currency": "USDT",
                "available": 0,
                "availableBalance": 0,
                "equity": "42",
            }
        ]
    }
    assert extract_available_balance(assets) == 0.0


## tests/test_version.py (last modified: 2025-08-22 07:05:27)
import pytest
from scalp import version


def test_get_version(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("1.2.3")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.get_version() == "1.2.3"


def test_bump_version(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"

    vfile.write_text("0.1.2\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.bump_version("minor") == "0.2.0"
    assert vfile.read_text().strip() == "0.2.0"


def test_bump_version_invalid_part(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("0.1.0\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    with pytest.raises(ValueError):
        version.bump_version("foo")


def test_bump_from_message(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("1.0.0\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.bump_version_from_message("feat: add x") == "1.1.0"
    assert version.bump_version_from_message("fix: bug") == "1.1.1"
    assert version.bump_version_from_message("feat!: major change") == "2.0.0"



## tests/test_walk_forward.py (last modified: 2025-08-22 07:05:27)
from scalp.backtest import walk_forward_windows


def test_walk_forward_windows():
    data = list(range(10))
    windows = list(walk_forward_windows(data, train=4, test=2))
    assert windows == [
        ([0, 1, 2, 3], [4, 5]),
        ([2, 3, 4, 5], [6, 7]),
        ([4, 5, 6, 7], [8, 9]),
    ]


## tests/test_ws.py (last modified: 2025-08-22 07:05:27)
import asyncio

from scalp.ws import WebsocketManager


def test_websocket_manager_stop():
    async def connect():
        return None

    async def subscribe():
        return None

    ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)

    async def run_and_stop():
        await ws.run()
        assert ws._heartbeat_task is not None
        await ws.stop()
        assert ws._heartbeat_task is None

    asyncio.run(run_and_stop())


