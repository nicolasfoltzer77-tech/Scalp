Dump updated: 2025-08-24 10:34:49
Résumé: instantané exhaustif du dépôt, reflétant l'arborescence et le contenu des fichiers actuels.
Repository tree:
Scalp/
    CHANGELOG.md
    Makefile
    PROMPT.md
    README.md
    STRATEGY.md
    bot.py
    cli.py
    init.py
    pytest.ini
    requirements-dev.txt
    requirements.txt
    sitecustomize.py
    tg_diag.py
    data/
        BTCUSDT-1m.csv
        __init__.py
        indicators.py
    docs/
        CLEANUP_TODO.txt
        CONFIG.txt
    tests/
        conftest.py
        test_analyse_risque.py
        test_backtest.py
        test_backtest_multi.py
        test_backtest_position.py
        test_bitget_futures_pairs.py
        test_bot_place_order_caps.py
        test_bot_update.py
        test_break_even_stop.py
        test_calc_pnl_pct.py
        test_check_config.py
        test_cli.py
        test_client.py
        test_compute_position_size.py
        test_compute_position_size_cap.py
        test_dynamic_allocation.py
        test_effective_leverage.py
        test_env_loading.py
        test_grid_search.py
        test_heat_score.py
        test_indicators.py
        test_min_qty_rules.py
        test_notifier.py
        test_notional_and_pnl_units.py
        test_pair_selection.py
        test_pairs.py
        test_risk_manager.py
        test_risk_utils.py
        test_signal_risk.py
        test_slippage.py
        test_strategy_v2.py
        test_telegram_bot.py
        test_utils.py
        test_version.py
        test_walk_forward.py
        test_ws.py
    TRASH_20250823-124533/
        bitget_futures_pairs.py
        dashboard.py
        dump_repo.py
        quick_order.py
        rr.py
        run_backtest.py
        short_one_way.py
        notebooks/
            spot/
                bitget_bot.py
        result/
        scalper/
            bot_config.py
            legacy_config.py
            notifier.py
            telegram_bot.py
    scalper/
        VERSION
        __init__.py
        bitget_client.py
        client.py
        logging_utils.py
        metrics.py
        pairs.py
        selfcheck.py
        strategy.py
        trade_utils.py
        version.py
        ws.py
        risk/
            __init__.py
            manager.py
        services/
            __init__.py
            data_cache.py
            order_service.py
            utils.py
        strategy/
            factory.py
            startegies/
                current.py
        positions/
            __init__.py
            state.py
        config/
            __init__.py
            config.yaml
            loader.py
            strategies.yml
        live/
            __init__.py
            backtest_telegram.py
            commands.py
            data_utils.py
            fetcher.py
            journal.py
            logs.py
            notify.py
            ohlcv_service.py
            orchestrator.py
            orders.py
            position_fsm.py
            runner.py
            setup_wizard.py
            state_store.py
            telegram_async.py
            watchlist.py
            loops/
                trade.py
        adapters/
            __init__.py
            bitget.py
            bitget_fetch.py
            market_data.py
        signals/
            __init__.py
            current.py
            factory.py
            generator.py
        exchange/
            __init__.py
            bitget.py
            bitget_ccxt.py
            fees.py
        backtest/
            __init__.py
            cache.py
            cli.py
            engine.py
            grid_search.py
            loader_csv.py
            market_data.py
            metrics.py
            optimize.py
            position_sizing.py
            run_multi.py
            runner.py
            walkforward.py
        hooks/
            prewarm_cache.py
        core/
            indicators.py
            signal.py
        selection/
            __init__.py
            momentum.py
            scanner.py

## CHANGELOG.md (last modified: 2025-08-24 10:15:51)
     1: # Changelog
     2: 
     3: ## Unreleased
     4: 
     5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
     6:   signal levels.
     7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
     8:   user risk level.
     9: - Notional and margin caps with available balance check to avoid Bitget error
    10:   `40762`.
    11: - Risk notifications with green/yellow/red indicators for terminal and
    12:   Telegram.


## Makefile (last modified: 2025-08-24 10:15:51)
     1: .PHONY: test
     2: 
     3: test:
     4: 	pytest


## PROMPT.md (last modified: 2025-08-24 10:15:51)
     1: # Prompt de re-création du bot Scalp (version spot)
     2: 
     3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
     4: 
     5: ## Structure principale
     6: 
     7: ### bot.py
     8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
     9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
    10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
    11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
    12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
    13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
    14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
    15: 
    16: ### cli.py
    17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
    18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
    19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
    20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
    21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
    22: 
    23: ### init.py
    24: - `install_packages(*args)` : installe des paquets via `pip`.
    25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
    26: 
    27: ## Modules `scalp`
    28: 
    29: ### bot_config.py
    30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
    31: 
    32: ### metrics.py
    33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
    34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
    35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
    36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
    37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
    38: 
    39: ### strategy.py
    40: - `ema(series, window)` : moyenne mobile exponentielle.
    41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
    42: - `obv(closes, volumes)` : série On Balance Volume.
    43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
    44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
    45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
    46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
    47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
    48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
    49: 
    50: ### trade_utils.py
    51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
    52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
    53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
    54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
    55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
    56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
    57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
    58: 
    59: ### risk
    60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
    61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
    62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
    63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
    64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
    65: 
    66: ### notifier.py
    67: - `_pair_name(symbol)` : formatte le nom d’une paire.
    68: - `_format_text(event, payload=None)` : construit un message lisible.
    69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
    70: 
    71: ### logging_utils.py
    72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
    73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
    74: 
    75: ### bitget_client.py
    76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
    77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
    78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
    79:   - `get_account()`, `get_open_orders(symbol=None)`.
    80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
    81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
    82: 
    83: ### pairs.py
    84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
    85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
    86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
    87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
    88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
    89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
    90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
    91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
    92: 
    93: ### telegram_bot.py
    94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
    95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
    96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
    97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
    98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
    99: 
   100: ## Utilisation
   101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   102: 2. Exécuter `init.py` pour installer les dépendances.
   103: 3. Lancer `bot.py` pour démarrer le trading.
   104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   105: 
   106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   107: 


## README.md (last modified: 2025-08-24 10:15:51)
     1: # Scalp
     2: 
     3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
     4: 
     5: ## Installation
     6: 
     7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
     8: 
     9: ```bash
    10: pip install -r requirements.txt
    11: ```
    12: 
    13: Pour développer ou exécuter les tests :
    14: 
    15: ```bash
    16: pip install -r requirements-dev.txt
    17: pytest  # ou make test
    18: ```
    19: 
    20: ## Configuration
    21: 
    22: Le bot lit sa configuration via des variables d'environnement :
    23: 
    24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
    25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
    26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
    27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
    28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
    29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
    30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
    31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
    32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
    33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
    34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
    35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
    36: 
    37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
    38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
    39: 
    40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
    41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
    42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
    43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
    44: bot.
    45: 
    46: 
    47: Exemple :
    48: 
    49: ```bash
    50: export BITGET_ACCESS_KEY="votre_cle"
    51: export BITGET_SECRET_KEY="votre_secret"
    52: export PAPER_TRADE=true
    53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
    54: export TELEGRAM_CHAT_ID="123456789"
    55: python bot.py
    56: ```
    57: 
    58: ## Lancement
    59: 
    60: Après configuration, lancez simplement :
    61: 
    62: ```bash
    63: python bot.py
    64: ```
    65: 
    66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
    67: 
    68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
    69: 
    70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
    71: 
    72: 
    73: ## Stratégie
    74: 
    75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
    76: rapidement les pertes.
    77: 
    78: Principes généraux :
    79: 
    80: - sélection de paires liquides au fort momentum ;
    81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
    82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
    83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
    84:   calculée selon le risque ;
    85: - limites quotidiennes pour protéger le capital.
    86: 
    87: Les règles détaillées et l’algorithme complet sont décrits dans
    88: `STRATEGY.md`.
    89: 
    90: ## Version
    91: 
    92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
    93: le code via la variable `scalp.__version__` :
    94: 
    95: ```python
    96: from scalp import __version__
    97: print(__version__)
    98: ```
    99: 
   100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   101: 
   102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   103: `scalp.version.bump_version_from_message` permet également de déterminer
   104: automatiquement l'incrément à appliquer à partir d'un message de commit
   105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   106: 
   107: Exemple d'incrément basé sur un message :
   108: 
   109: ```python
   110: from scalp.version import bump_version_from_message
   111: bump_version_from_message("feat: add new strategy")
   112: ```
   113: 
   114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   115: message de commit `git` et met à jour le fichier `VERSION` en
   116: conséquence.
   117: 
   118: La même opération peut être déclenchée depuis la ligne de commande via
   119: `cli.py` :
   120: 
   121: ```bash
   122: python cli.py bump-version
   123: ```
   124: 
   125: 
   126: ## Changelog
   127: 
   128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   129: 
   130: ## Avertissement
   131: 
   132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.


## STRATEGY.md (last modified: 2025-08-24 10:15:51)
     1: # Stratégie de trading
     2: 
     3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
     4: 
     5: ## Principes généraux
     6: 
     7: - ne traiter que des actifs liquides à fort momentum ;
     8: - suivre la tendance dominante et éviter les marchés plats ;
     9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
    10: - dimensionner chaque position selon un pourcentage fixe du capital ;
    11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
    12: 
    13: ## Sélection des paires
    14: 
    15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
    16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
    17:    - croisement entre EMA20 et EMA50 ;
    18:    - ATR élevé pour privilégier les actifs volatils.
    19: 
    20: ## Génération du signal
    21: 
    22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
    23: 
    24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
    25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
    26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
    27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
    28: - cassure du dernier **swing high/low** ;
    29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
    30: 
    31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
    32: 
    33: ## Gestion du risque
    34: 
    35: La classe `RiskManager` applique plusieurs garde‑fous :
    36: 
    37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
    38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
    39: - pause forcée en cas de pertes consécutives prolongées ;
    40: - contrôle du nombre maximal de positions ouvertes.
    41: 
    42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.


## TRASH_20250823-124533/bitget_futures_pairs.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: """Fetch the list of Bitget futures contracts.
     3: 
     4: This helper script queries the public Bitget REST API to retrieve futures
     5: trading pairs for the specified product types and saves them to CSV and JSON
     6: files. It mirrors the standalone example provided by the user but integrates
     7: with the repository's configuration system.
     8: 
     9: Usage examples::
    10: 
    11:     python bitget_futures_pairs.py
    12:     python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
    13:     python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
    14: """
    15: from __future__ import annotations
    16: 
    17: import argparse
    18: import csv
    19: import json
    20: import sys
    21: import time
    22: from typing import Any, Dict, List
    23: 
    24: from scalper.bot_config import CONFIG
    25: 
    26: try:  # pragma: no cover - import guard
    27:     import requests
    28: except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
    29:     sys.stderr.write(
    30:         "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
    31:     )
    32:     raise
    33: 
    34: BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
    35: CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
    36: DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]
    37: 
    38: 
    39: def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
    40:     """Return contract metadata for ``product_type``."""
    41:     url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
    42:     params = {"productType": product_type}
    43:     resp = requests.get(url, params=params, timeout=timeout)
    44:     try:
    45:         data = resp.json()
    46:     except json.JSONDecodeError as exc:  # pragma: no cover - network failure
    47:         raise RuntimeError(
    48:             f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
    49:         ) from exc
    50:     if resp.status_code != 200 or data.get("code") != "00000":
    51:         raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
    52:     return data.get("data", [])
    53: 
    54: 
    55: def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    56:     """Select and rename key fields for CSV/JSON output."""
    57:     rows: List[Dict[str, Any]] = []
    58:     for c in contracts:
    59:         row = {
    60:             "productType": product_type,
    61:             "symbol": c.get("symbol"),
    62:             "baseCoin": c.get("baseCoin"),
    63:             "quoteCoin": c.get("quoteCoin"),
    64:             "symbolType": c.get("symbolType"),
    65:             "symbolStatus": c.get("symbolStatus"),
    66:             "maxLever": c.get("maxLever"),
    67:             "minLever": c.get("minLever"),
    68:             "minTradeNum": c.get("minTradeNum"),
    69:             "sizeMultiplier": c.get("sizeMultiplier"),
    70:             "pricePlace": c.get("pricePlace"),
    71:             "volumePlace": c.get("volumePlace"),
    72:             "launchTime": c.get("launchTime"),
    73:             "deliveryTime": c.get("deliveryTime"),
    74:         }
    75:         rows.append(row)
    76:     return rows
    77: 
    78: 
    79: def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
    80:     """Write ``rows`` to ``path`` in CSV format."""
    81:     headers = [
    82:         "productType",
    83:         "symbol",
    84:         "baseCoin",
    85:         "quoteCoin",
    86:         "symbolType",
    87:         "symbolStatus",
    88:         "maxLever",
    89:         "minLever",
    90:         "minTradeNum",
    91:         "sizeMultiplier",
    92:         "pricePlace",
    93:         "volumePlace",
    94:         "launchTime",
    95:         "deliveryTime",
    96:     ]
    97:     with open(path, "w", newline="", encoding="utf-8") as fh:
    98:         writer = csv.DictWriter(fh, fieldnames=headers)
    99:         writer.writeheader()
   100:         if rows:
   101:             writer.writerows(rows)
   102: 
   103: 
   104: def main(argv: List[str] | None = None) -> int:
   105:     parser = argparse.ArgumentParser(
   106:         description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
   107:     )
   108:     parser.add_argument(
   109:         "--types",
   110:         nargs="+",
   111:         default=DEFAULT_PRODUCT_TYPES,
   112:         help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
   113:     )
   114:     parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
   115:     parser.add_argument(
   116:         "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
   117:     )
   118:     parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
   119:     args = parser.parse_args(argv)
   120: 
   121:     all_rows: List[Dict[str, Any]] = []
   122:     merged_json: Dict[str, List[Dict[str, Any]]] = {}
   123: 
   124:     for i, pt in enumerate(args.types):
   125:         try:
   126:             contracts = fetch_contracts(pt)
   127:         except Exception as exc:  # pragma: no cover - network/runtime error
   128:             sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
   129:             continue
   130:         rows = normalize_rows(pt, contracts)
   131:         all_rows.extend(rows)
   132:         merged_json[pt] = contracts
   133:         if i < len(args.types) - 1 and args.sleep > 0:
   134:             time.sleep(args.sleep)
   135: 
   136:     all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))
   137: 
   138:     write_csv(all_rows, args.out)
   139:     with open(args.json_out, "w", encoding="utf-8") as fh:
   140:         json.dump(merged_json, fh, ensure_ascii=False, indent=2)
   141: 
   142:     counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
   143:     total = sum(counts.values())
   144:     print(
   145:         f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
   146:     )
   147:     for pt, n in counts.items():
   148:         print(f"  - {pt}: {n} pairs")
   149:     return 0
   150: 
   151: 
   152: if __name__ == "__main__":  # pragma: no cover - CLI execution
   153:     raise SystemExit(main())


## TRASH_20250823-124533/dashboard.py (last modified: 2025-08-24 10:15:51)
     1: # dashboard.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: import time
     6: from pathlib import Path
     7: from typing import Dict, Tuple
     8: 
     9: import pandas as pd
    10: import streamlit as st
    11: 
    12: # ------------------------------------------------------------
    13: # Réglages
    14: # ------------------------------------------------------------
    15: LOG_DIR = Path("scalp/live/logs")  # emplacement des CSV créés par l'orchestrateur
    16: REFRESH_SECS = 5                   # auto-refresh UI
    17: MAX_ROWS_SHOW = 2000               # clamp mémoire
    18: 
    19: 
    20: # ------------------------------------------------------------
    21: # Utilitaires lecture robuste CSV
    22: # ------------------------------------------------------------
    23: def _safe_read_csv(path: Path) -> pd.DataFrame:
    24:     if not path.exists():
    25:         return pd.DataFrame()
    26:     try:
    27:         df = pd.read_csv(path)
    28:         # clamp pour éviter d’exploser en RAM si les logs deviennent énormes
    29:         if len(df) > MAX_ROWS_SHOW:
    30:             df = df.tail(MAX_ROWS_SHOW).reset_index(drop=True)
    31:         return df
    32:     except Exception:
    33:         # fichier en cours d’écriture → on réessaiera au prochain tick
    34:         return pd.DataFrame()
    35: 
    36: 
    37: def load_logs() -> Dict[str, pd.DataFrame]:
    38:     return {
    39:         "signals": _safe_read_csv(LOG_DIR / "signals.csv"),
    40:         "orders": _safe_read_csv(LOG_DIR / "orders.csv"),
    41:         "fills": _safe_read_csv(LOG_DIR / "fills.csv"),
    42:         "positions": _safe_read_csv(LOG_DIR / "positions.csv"),
    43:     }
    44: 
    45: 
    46: def _format_ts_ms_to_str(df: pd.DataFrame, col: str = "ts") -> pd.DataFrame:
    47:     if col in df.columns:
    48:         try:
    49:             df[col] = pd.to_datetime(df[col], unit="ms")
    50:         except Exception:
    51:             try:
    52:                 df[col] = pd.to_datetime(df[col])
    53:             except Exception:
    54:                 pass
    55:     return df
    56: 
    57: 
    58: # ------------------------------------------------------------
    59: # Métriques & agrégats simples
    60: # ------------------------------------------------------------
    61: def compute_activity_metrics(df_orders: pd.DataFrame, df_fills: pd.DataFrame) -> Tuple[float, float, int]:
    62:     """
    63:     Retourne: (volume notionnel approx, fees cumulés, nb fills)
    64:     - notionnel approx = somme(|price * qty|) sur les fills (indépendant du sens)
    65:     - fees = somme(fee) si dispo
    66:     """
    67:     notional = 0.0
    68:     fees = 0.0
    69:     n_fills = 0
    70: 
    71:     if not df_fills.empty:
    72:         # normalisation colonnes
    73:         price_col = next((c for c in ["price", "fillPrice", "fill_px"] if c in df_fills.columns), None)
    74:         qty_col = next((c for c in ["qty", "size", "fillQty", "fill_sz"] if c in df_fills.columns), None)
    75:         fee_col = next((c for c in ["fee", "fillFee"] if c in df_fills.columns), None)
    76: 
    77:         if price_col and qty_col:
    78:             notional = float((df_fills[price_col].abs() * df_fills[qty_col].abs()).sum())
    79:             n_fills = int(len(df_fills))
    80:         if fee_col:
    81:             fees = float(df_fills[fee_col].fillna(0).sum())
    82: 
    83:     return notional, fees, n_fills
    84: 
    85: 
    86: def last_positions_snapshot(df_positions: pd.DataFrame) -> pd.DataFrame:
    87:     """Dernier état par symbole (state/qty/entry)."""
    88:     if df_positions.empty:
    89:         return df_positions
    90:     df = df_positions.copy()
    91:     df = _format_ts_ms_to_str(df, "ts")
    92:     # on prend le dernier enregistrement par symbol
    93:     last = df.sort_values("ts").groupby("symbol", as_index=False).tail(1)
    94:     return last.sort_values("symbol").reset_index(drop=True)
    95: 
    96: 
    97: def recent_signals(df_signals: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
    98:     if df_signals.empty:
    99:         return df_signals
   100:     df = df_signals.copy()
   101:     df = _format_ts_ms_to_str(df, "ts")
   102:     df = df.sort_values("ts", ascending=False).head(limit)
   103:     return df.reset_index(drop=True)
   104: 
   105: 
   106: def recent_orders(df_orders: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   107:     if df_orders.empty:
   108:         return df_orders
   109:     df = df_orders.copy()
   110:     df = _format_ts_ms_to_str(df, "ts")
   111:     df = df.sort_values("ts", ascending=False).head(limit)
   112:     # petites colonnes utiles en premier
   113:     cols = [c for c in ["ts", "symbol", "side", "status", "price", "sl", "tp", "risk_pct", "order_id"] if c in df.columns]
   114:     other = [c for c in df.columns if c not in cols]
   115:     return df[cols + other]
   116: 
   117: 
   118: def recent_fills(df_fills: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
   119:     if df_fills.empty:
   120:         return df_fills
   121:     df = df_fills.copy()
   122:     df = _format_ts_ms_to_str(df, "ts")
   123:     df = df.sort_values("ts", ascending=False).head(limit)
   124:     cols = [c for c in ["ts", "symbol", "order_id", "trade_id", "price", "qty", "fee"] if c in df.columns]
   125:     other = [c for c in df.columns if c not in cols]
   126:     return df[cols + other]
   127: 
   128: 
   129: # ------------------------------------------------------------
   130: # UI
   131: # ------------------------------------------------------------
   132: st.set_page_config(page_title="ScalpBot Dashboard", layout="wide")
   133: st.title("📊 ScalpBot — Dashboard Live")
   134: 
   135: # auto-refresh
   136: st.caption("Auto-refresh toutes les {}s".format(REFRESH_SECS))
   137: st_autorefresh = st.experimental_rerun if False else None  # placeholder to keep code readable
   138: # Streamlit v1.32+ propose st.autorefresh :
   139: try:
   140:     st_autorefresh = st.experimental_rerun  # fallback compat
   141:     from streamlit.runtime.scriptrunner import add_script_run_ctx  # noqa: F401
   142:     st_autorefresh = None
   143: except Exception:
   144:     pass
   145: 
   146: try:
   147:     st_autorefresh = st.autorefresh(interval=REFRESH_SECS * 1000, key="autorf")
   148: except Exception:
   149:     pass
   150: 
   151: # Choix du dossier de logs (utile si on lance le dashboard depuis un autre cwd)
   152: default_dir = str(LOG_DIR.resolve())
   153: custom_dir = st.sidebar.text_input("Dossier de logs", value=default_dir)
   154: LOG_DIR = Path(custom_dir) if custom_dir else LOG_DIR
   155: 
   156: if not LOG_DIR.exists():
   157:     st.error(f"Dossier introuvable : {LOG_DIR}")
   158:     st.stop()
   159: 
   160: data = load_logs()
   161: df_sig, df_ord, df_fill, df_pos = data["signals"], data["orders"], data["fills"], data["positions"]
   162: 
   163: # KPIs rapides
   164: notional, fees, n_fills = compute_activity_metrics(df_ord, df_fill)
   165: col_a, col_b, col_c, col_d = st.columns(4)
   166: col_a.metric("Paires actives (Top 10)", "10")
   167: col_b.metric("Fills (total)", f"{n_fills}")
   168: col_c.metric("Notionnel cumulé (approx)", f"{notional:,.0f} USDT")
   169: col_d.metric("Frais cumulés", f"{fees:,.2f} USDT")
   170: 
   171: st.divider()
   172: 
   173: # 1) Positions snapshot
   174: st.subheader("📌 Positions (snapshot courant par symbole)")
   175: pos_snapshot = last_positions_snapshot(df_pos)
   176: if pos_snapshot.empty:
   177:     st.info("Aucune position pour l’instant.")
   178: else:
   179:     # Met un peu d'ordre dans les colonnes
   180:     order_cols = [c for c in ["symbol", "state", "qty", "entry", "ts"] if c in pos_snapshot.columns]
   181:     pos_snapshot = pos_snapshot[order_cols + [c for c in pos_snapshot.columns if c not in order_cols]]
   182:     st.dataframe(pos_snapshot, use_container_width=True, height=260)
   183: 
   184: # 2) Derniers signaux
   185: st.subheader("📣 Derniers signaux")
   186: sig_tbl = recent_signals(df_sig, limit=40)
   187: if sig_tbl.empty:
   188:     st.info("Pas encore de signaux.")
   189: else:
   190:     # comptage LONG/SHORT
   191:     try:
   192:         by_side = sig_tbl.assign(side_norm=sig_tbl["side"].astype(str).str.upper()).groupby("side_norm").size()
   193:         st.bar_chart(by_side)
   194:     except Exception:
   195:         pass
   196:     st.dataframe(sig_tbl, use_container_width=True, height=300)
   197: 
   198: # 3) Ordres récents
   199: st.subheader("🧾 Ordres récents")
   200: ord_tbl = recent_orders(df_ord, limit=40)
   201: if ord_tbl.empty:
   202:     st.info("Pas encore d’ordres.")
   203: else:
   204:     st.dataframe(ord_tbl, use_container_width=True, height=280)
   205: 
   206: # 4) Fills récents
   207: st.subheader("✅ Fills récents")
   208: fills_tbl = recent_fills(df_fill, limit=80)
   209: if fills_tbl.empty:
   210:     st.info("Pas encore d’exécutions (fills).")
   211: else:
   212:     st.dataframe(fills_tbl, use_container_width=True, height=320)
   213: 
   214: st.caption(f"Logs: {LOG_DIR}")

## TRASH_20250823-124533/dump_repo.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: from datetime import datetime
     3: from pathlib import Path
     4: 
     5: IGNORE_EXTENSIONS = {'.log', '.pyc'}
     6: IGNORE_DIRS = {'__pycache__'}
     7: 
     8: 
     9: def _is_ignored(path: Path) -> bool:
    10:     """Return True if the path should be ignored."""
    11:     if any(part.startswith('.') for part in path.parts):
    12:         return True
    13:     if path.suffix in IGNORE_EXTENSIONS:
    14:         return True
    15:     if any(part in IGNORE_DIRS for part in path.parts):
    16:         return True
    17:     return False
    18: 
    19: 
    20: def _build_tree(root: Path, ignore_path: Path) -> str:
    21:     lines = []
    22:     for dirpath, dirnames, filenames in os.walk(root):
    23:         dirpath = Path(dirpath)
    24:         dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
    25:         depth = len(dirpath.relative_to(root).parts)
    26:         indent = '    ' * depth
    27:         lines.append(f"{indent}{dirpath.name}/")
    28:         for fname in sorted(filenames):
    29:             fpath = dirpath / fname
    30:             if fpath == ignore_path or _is_ignored(fpath):
    31:                 continue
    32:             lines.append(f"{indent}    {fname}")
    33:     return '\n'.join(lines)
    34: 
    35: 
    36: def _iter_files(root: Path):
    37:     for path in sorted(root.rglob('*')):
    38:         if path.is_file() and not _is_ignored(path):
    39:             yield path
    40: 
    41: 
    42: def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
    43:     """Create a text dump of the repository tree and file contents."""
    44:     root_path = Path(root).resolve()
    45:     output_path = root_path / output_path
    46:     now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    47:     with output_path.open('w', encoding='utf-8') as dump:
    48:         dump.write(f"Dump created: {now}\n")
    49:         dump.write('Repository tree:\n')
    50:         dump.write(_build_tree(root_path, output_path))
    51:         dump.write('\n\n')
    52:         for file_path in _iter_files(root_path):
    53:             rel_path = file_path.relative_to(root_path)
    54:             if file_path == output_path:
    55:                 continue
    56:             mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
    57:             dump.write(f"## {rel_path} (last modified: {mod_time})\n")
    58:             try:
    59:                 with file_path.open('r', encoding='utf-8') as f:
    60:                     for i, line in enumerate(f, 1):
    61:                         dump.write(f"{i:6}: {line}")
    62:             except Exception:
    63:                 dump.write('[unreadable file]\n')
    64:             dump.write('\n\n')
    65: 
    66: 
    67: if __name__ == '__main__':
    68:     create_dump_file()


## TRASH_20250823-124533/notebooks/spot/bitget_bot.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import time
     3: import hmac
     4: import hashlib
     5: import base64
     6: import logging
     7: from argparse import ArgumentParser
     8: from pathlib import Path
     9: from typing import Any, Dict, List
    10: from urllib.parse import urlencode
    11: 
    12: import requests
    13: from dotenv import load_dotenv
    14: 
    15: BASE_URL = "https://api.bitget.com"
    16: RECV_WINDOW = 5000
    17: 
    18: 
    19: def load_keys() -> Dict[str, str]:
    20:     parent = Path(__file__).resolve().parent.parent
    21:     load_dotenv(parent / ".env")
    22:     api_key = os.getenv("BITGET_API_KEY")
    23:     api_secret = os.getenv("BITGET_API_SECRET")
    24:     if not api_key or not api_secret:
    25:         raise RuntimeError("API keys not found in environment")
    26:     return {"key": api_key, "secret": api_secret}
    27: 
    28: 
    29: class BitgetClient:
    30:     def __init__(self) -> None:
    31:         creds = load_keys()
    32:         self.api_key = creds["key"]
    33:         self.api_secret = creds["secret"]
    34:         self.session = requests.Session()
    35:         self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
    36:         self.time_offset = self._compute_time_offset()
    37: 
    38:     def _compute_time_offset(self) -> int:
    39:         server = self.server_time()
    40:         return int(server["serverTime"]) - int(time.time() * 1000)
    41: 
    42:     def _timestamp(self) -> int:
    43:         return int(time.time() * 1000) + self.time_offset
    44: 
    45:     def _request(
    46:         self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
    47:     ) -> Any:
    48:         params = params or {}
    49:         if signed:
    50:             params["timestamp"] = self._timestamp()
    51:             params["recvWindow"] = RECV_WINDOW
    52:             query = urlencode(params)
    53:             signature = base64.b64encode(
    54:                 hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
    55:             ).decode()
    56:             query += f"&signature={signature}"
    57:             headers = {"X-BITGET-APIKEY": self.api_key}
    58:             if method.upper() == "GET":
    59:                 url = f"{BASE_URL}{path}?{query}"
    60:                 resp = self.session.get(url, headers=headers)
    61:             else:
    62:                 url = f"{BASE_URL}{path}"
    63:                 headers["Content-Type"] = "application/x-www-form-urlencoded"
    64:                 resp = self.session.post(url, data=query, headers=headers)
    65:         else:
    66:             url = f"{BASE_URL}{path}"
    67:             resp = self.session.request(method, url, params=params)
    68: 
    69:         resp.raise_for_status()
    70:         if resp.text:
    71:             return resp.json()
    72:         return {}
    73: 
    74:     # Helpers
    75:     def server_time(self) -> Any:
    76:         return self._request("GET", "/api/v3/time")
    77: 
    78:     def ticker_price(self, symbol: str) -> Any:
    79:         return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})
    80: 
    81:     def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
    82:         return self._request(
    83:             "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
    84:         )
    85: 
    86:     def test_order(self, **params: Any) -> Any:
    87:         return self._request("POST", "/api/v3/order/test", params, signed=True)
    88: 
    89:     def place_order(self, **params: Any) -> Any:
    90:         return self._request("POST", "/api/v3/order", params, signed=True)
    91: 
    92:     def account_info(self) -> Any:
    93:         return self._request("GET", "/api/v3/account", signed=True)
    94: 
    95:     def book_ticker(self, symbol: str) -> Any:
    96:         return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})
    97: 
    98: 
    99: def sma(values: List[float], period: int) -> float:
   100:     if len(values) < period:
   101:         raise ValueError("Not enough data for SMA")
   102:     return sum(values[-period:]) / period
   103: 
   104: 
   105: def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
   106:     kl = client.klines(symbol, limit=50)
   107:     closes = [float(k[4]) for k in kl]
   108:     sma9_prev = sma(closes[:-1], 9)
   109:     sma21_prev = sma(closes[:-1], 21)
   110:     sma9_curr = sma(closes, 9)
   111:     sma21_curr = sma(closes, 21)
   112: 
   113:     cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
   114:     cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr
   115: 
   116:     log = logging.getLogger("bitget_bot")
   117: 
   118:     if cross_up:
   119:         book = client.book_ticker(symbol)
   120:         ask = float(book["askPrice"])
   121:         qty = quote_usdt / ask
   122:         params = {
   123:             "symbol": symbol,
   124:             "side": "BUY",
   125:             "type": "LIMIT",
   126:             "timeInForce": "IOC",
   127:             "quantity": f"{qty:.6f}",
   128:             "price": book["askPrice"],
   129:         }
   130:         log.info("BUY signal %s", params)
   131:         resp = client.test_order(**params) if dry_run else client.place_order(**params)
   132:         log.info("response %s", resp)
   133:     elif cross_down:
   134:         account = client.account_info()
   135:         base = symbol.rstrip("USDT")
   136:         bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
   137:         qty = float(bal["free"])
   138:         if qty > 0:
   139:             book = client.book_ticker(symbol)
   140:             params = {
   141:                 "symbol": symbol,
   142:                 "side": "SELL",
   143:                 "type": "LIMIT",
   144:                 "timeInForce": "IOC",
   145:                 "quantity": f"{qty:.6f}",
   146:                 "price": book["bidPrice"],
   147:             }
   148:             log.info("SELL signal %s", params)
   149:             resp = client.test_order(**params) if dry_run else client.place_order(**params)
   150:             log.info("response %s", resp)
   151:         else:
   152:             log.info("No balance to sell")
   153: 
   154: 
   155: def interval_seconds(interval: str) -> int:
   156:     unit = interval[-1]
   157:     qty = int(interval[:-1])
   158:     if unit == "m":
   159:         return qty * 60
   160:     if unit == "h":
   161:         return qty * 3600
   162:     if unit == "d":
   163:         return qty * 86400
   164:     return 60
   165: 
   166: 
   167: def main() -> None:
   168:     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
   169:     parser = ArgumentParser(description="Bitget SMA crossover bot")
   170:     parser.add_argument("--symbol", default="BTCUSDT")
   171:     parser.add_argument("--quote-usdt", type=float, default=10.0)
   172:     parser.add_argument("--interval", default="1m")
   173:     parser.add_argument("--loop", action="store_true")
   174:     parser.add_argument("--dry-run", dest="dry_run", action="store_true")
   175:     parser.add_argument("--live", dest="dry_run", action="store_false")
   176:     parser.set_defaults(dry_run=True)
   177:     args = parser.parse_args()
   178: 
   179:     client = BitgetClient()
   180:     delay = interval_seconds(args.interval)
   181: 
   182:     while True:
   183:         try:
   184:             analyze(client, args.symbol, args.quote_usdt, args.dry_run)
   185:         except Exception as exc:
   186:             logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
   187:         if not args.loop:
   188:             break
   189:         time.sleep(delay)
   190: 
   191: 
   192: if __name__ == "__main__":
   193:     main()


## TRASH_20250823-124533/quick_order.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: """Submit a simple market order on Bitget futures.
     3: 
     4: This helper reads API credentials and trade parameters from environment
     5: variables (optionally loaded from a `.env` file) and places a one-way
     6: market order.  Only the essential steps from the user's reference script
     7: are kept to minimise latency and redundant code.
     8: 
     9: Environment variables:
    10:     BITGET_API_KEY / BITGET_ACCESS_KEY
    11:     BITGET_API_SECRET / BITGET_SECRET_KEY
    12:     BITGET_API_PASSPHRASE
    13:     BITGET_BASE_URL (default https://api.bitget.com)
    14:     BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
    15:     BITGET_MARGIN_COIN (default ``USDT``)
    16:     BITGET_SYMBOL (e.g. ``BTCUSDT``)
    17:     BITGET_TEST_NOTIONAL_USDT (default ``5``)
    18: 
    19: Usage:
    20:     python quick_order.py buy
    21:     python quick_order.py sell
    22: """
    23: 
    24: from __future__ import annotations
    25: 
    26: import os
    27: import sys
    28: from pathlib import Path
    29: 
    30: from dotenv import load_dotenv
    31: 
    32: from scalper.bitget_client import BitgetFuturesClient
    33: 
    34: # Load variables from `.env` if present
    35: load_dotenv(Path(__file__).resolve().parent / ".env")
    36: 
    37: side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
    38: if side not in {"buy", "sell"}:
    39:     raise SystemExit("Usage: quick_order.py [buy|sell]")
    40: 
    41: base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
    42: ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
    43: sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
    44: ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
    45: product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
    46: margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
    47: symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
    48: notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))
    49: 
    50: if not (ak and sk and ph):
    51:     raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")
    52: 
    53: client = BitgetFuturesClient(
    54:     access_key=ak,
    55:     secret_key=sk,
    56:     base_url=base,
    57:     passphrase=ph,
    58:     paper_trade=False,
    59: )
    60: 
    61: tick = client.get_ticker(symbol)
    62: price = None
    63: try:
    64:     data = tick.get("data")
    65:     if isinstance(data, list) and data:
    66:         price_str = data[0].get("lastPr") or data[0].get("lastPrice")
    67:         if price_str is not None:
    68:             price = float(price_str)
    69:     elif isinstance(data, dict):
    70:         price_str = data.get("lastPr") or data.get("lastPrice")
    71:         if price_str is not None:
    72:             price = float(price_str)
    73: except Exception:
    74:     pass
    75: if price is None or price <= 0:
    76:     raise SystemExit("Prix introuvable pour le ticker")
    77: 
    78: size = round(notional / price, 6)
    79: client.set_position_mode_one_way(symbol, product_type)
    80: client.set_leverage(symbol, product_type, margin_coin, leverage=2)
    81: resp = client.place_market_order_one_way(
    82:     symbol, side, size, product_type, margin_coin
    83: )
    84: print(resp)


## TRASH_20250823-124533/rr.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: import argparse, shutil, re, os, datetime as dt
     4: from pathlib import Path
     5: 
     6: # ---------- helpers ----------
     7: def info(msg): print(f"[i] {msg}")
     8: def ok(msg):   print(f"[✓] {msg}")
     9: def warn(msg): print(f"[!] {msg}")
    10: 
    11: def backup_repo(repo: Path) -> Path:
    12:     ts = dt.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    13:     dst = repo.parent / f".backup-refactor-{ts}"
    14:     shutil.copytree(repo, dst)
    15:     ok(f"Sauvegarde créée: {dst}")
    16:     return dst
    17: 
    18: def ensure_pkg_init(path: Path):
    19:     initp = path / "__init__.py"
    20:     if not initp.exists():
    21:         initp.write_text("# package\n", encoding="utf-8")
    22: 
    23: def move_dir(src: Path, dst: Path):
    24:     if not src.exists(): return
    25:     dst.mkdir(parents=True, exist_ok=True)
    26:     for child in src.iterdir():
    27:         shutil.move(str(child), str(dst / child.name))
    28:     # supprime le répertoire source s'il est vide
    29:     try: src.rmdir()
    30:     except Exception: pass
    31: 
    32: # règles initiales (rangement)
    33: IMPORT_RULES_STAGE1 = [
    34:     (re.compile(r"from\s+scalp\.config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
    35:     (re.compile(r"from\s+config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
    36:     (re.compile(r"from\s+scalp\.config\s+import\s+load_settings"), "from scalper.config import load_settings"),
    37:     (re.compile(r"from\s+live(\.| import)"), r"from scalper.live\1"),
    38:     (re.compile(r"import\s+live(\s|$)"), r"import scalper.live\1"),
    39:     (re.compile(r"from\s+backtest(\.| import)"), r"from scalper.backtest\1"),
    40:     (re.compile(r"import\s+backtest(\s|$)"), r"import scalper.backtest\1"),
    41:     (re.compile(r"from\s+signals(\.| import)"), r"from scalper.signals\1"),
    42:     (re.compile(r"import\s+signals(\s|$)"), r"import scalper.signals\1"),
    43:     (re.compile(r"from\s+exchange(\.| import)"), r"from scalper.exchange\1"),
    44:     (re.compile(r"import\s+exchange(\s|$)"), r"import scalper.exchange\1"),
    45: ]
    46: 
    47: def rewrite_imports(root: Path, rules):
    48:     changed = 0
    49:     for py in root.rglob("*.py"):
    50:         if ".backup-" in str(py) or ".backup" in str(py):  # safety
    51:             continue
    52:         txt = py.read_text(encoding="utf-8")
    53:         new = txt
    54:         for pat, rep in rules:
    55:             new = pat.sub(rep, new)
    56:         if new != txt:
    57:             py.write_text(new, encoding="utf-8")
    58:             changed += 1
    59:     return changed
    60: 
    61: def ensure_config_package(scalp_pkg: Path):
    62:     """Transforme scalp/config.py en package scalp/config/loader.py et ajoute __init__.py exportant load_settings."""
    63:     flat = scalp_pkg / "config.py"
    64:     pkg = scalp_pkg / "config"
    65:     loader = pkg / "loader.py"
    66:     initp = pkg / "__init__.py"
    67: 
    68:     # si un config.py existe, le renommer pour archivage
    69:     if flat.exists():
    70:         legacy = scalp_pkg / "legacy_config.py"
    71:         if legacy.exists(): legacy.unlink()
    72:         shutil.move(str(flat), str(legacy))
    73:         info(f"renommé {flat} -> {legacy}")
    74: 
    75:     pkg.mkdir(parents=True, exist_ok=True)
    76:     ensure_pkg_init(pkg)
    77: 
    78:     # si pas de loader.py, créer un loader minimal (tu pourras le remplacer par ta version complète)
    79:     if not loader.exists():
    80:         loader.write_text(
    81:             'from __future__ import annotations\n'
    82:             'import os, json\n'
    83:             'from typing import Any, Dict, Tuple\n'
    84:             'try:\n'
    85:             '    import yaml\n'
    86:             'except Exception:\n'
    87:             '    yaml = None\n'
    88:             'try:\n'
    89:             '    from dotenv import load_dotenv\n'
    90:             'except Exception:\n'
    91:             '    load_dotenv = None\n'
    92:             '\n'
    93:             'def _read_yaml(path: str):\n'
    94:             '    if not os.path.exists(path): return {}\n'
    95:             '    with open(path, "r", encoding="utf-8") as f:\n'
    96:             '        if yaml: return yaml.safe_load(f) or {}\n'
    97:             '        return json.load(f)\n'
    98:             '\n'
    99:             'def load_settings(config_path: str="config.yml", config_local_path: str="config.local.yml"):\n'
   100:             '    if load_dotenv: load_dotenv(override=False)\n'
   101:             '    base = _read_yaml(config_path)\n'
   102:             '    local = _read_yaml(config_local_path)\n'
   103:             '    cfg = {**base, **local}\n'
   104:             '    runtime = {\n'
   105:             '        "quiet": bool(cfg.get("QUIET", 1)),\n'
   106:             '        "print_sample": bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)),\n'
   107:             '        "timeframe": str(cfg.get("TIMEFRAME", "5m")),\n'
   108:             '        "cash": float(cfg.get("CASH", 10000)),\n'
   109:             '        "risk_pct": float(cfg.get("RISK_PCT", 0.5)),\n'
   110:             '        "slippage_bps": float(cfg.get("SLIPPAGE_BPS", 2)),\n'
   111:             '        "watchlist_mode": str(cfg.get("WATCHLIST_MODE", "local")),\n'
   112:             '        "watchlist_local_conc": int(cfg.get("WATCHLIST_LOCAL_CONC", 5)),\n'
   113:             '        "top_symbols": cfg.get("TOP_SYMBOLS", []),\n'
   114:             '        "top_candidates": cfg.get("TOP_CANDIDATES", []),\n'
   115:             '        "caps": cfg.get("CAPS", {}),\n'
   116:             '        "fees_by_symbol": {},\n'
   117:             '    }\n'
   118:             '    secrets = {\n'
   119:             '        "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),\n'
   120:             '        "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),\n'
   121:             '        "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),\n'
   122:             '        "BITGET_USE_TESTNET": os.getenv("BITGET_USE_TESTNET", "1") in ("1","true","True"),\n'
   123:             '        "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),\n'
   124:             '        "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),\n'
   125:             '        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),\n'
   126:             '    }\n'
   127:             '    return runtime, secrets\n',
   128:             encoding="utf-8"
   129:         )
   130:     # __init__.py exporte load_settings
   131:     initp.write_text("from .loader import load_settings\n__all__ = ['load_settings']\n", encoding="utf-8")
   132: 
   133: def stage1_restructure(repo: Path):
   134:     """Range les modules à l’intérieur du package 'scalp/' + fix imports."""
   135:     scalp_pkg = repo / "scalp"
   136:     scalp_pkg.mkdir(exist_ok=True)
   137:     ensure_pkg_init(scalp_pkg)
   138: 
   139:     for mod in ("live", "backtest", "signals", "config", "exchange"):
   140:         src = repo / mod
   141:         if src.exists() and src.is_dir():
   142:             dst = scalp_pkg / mod
   143:             info(f"déplacement {src} -> {dst}")
   144:             move_dir(src, dst)
   145:             ensure_pkg_init(dst)
   146: 
   147:     # gérer config.py -> package config/loader.py
   148:     ensure_config_package(scalp_pkg)
   149: 
   150:     # réécriture imports vers scalper.*
   151:     changed = rewrite_imports(repo, IMPORT_RULES_STAGE1)
   152:     ok(f"imports stage1 réécrits dans {changed} fichier(s)")
   153: 
   154: def stage2_rename_package(repo: Path, old="scalp", new="scalper"):
   155:     """Renomme le package interne old -> new et réécrit tous les imports."""
   156:     pkg_old = repo / old
   157:     pkg_new = repo / new
   158:     if not pkg_old.exists():
   159:         warn(f"package {pkg_old} introuvable (déjà renommé ?)")
   160:     else:
   161:         shutil.move(str(pkg_old), str(pkg_new))
   162:         ok(f"package renommé {pkg_old.name} -> {pkg_new.name}")
   163: 
   164:     # réécriture imports 'old.' -> 'new.'
   165:     pat = re.compile(rf"\b{old}\.")
   166:     changed = 0
   167:     for py in repo.rglob("*.py"):
   168:         if ".backup" in str(py): continue
   169:         txt = py.read_text(encoding="utf-8")
   170:         new_txt = pat.sub(f"{new}.", txt)
   171:         if new_txt != txt:
   172:             py.write_text(new_txt, encoding="utf-8")
   173:             changed += 1
   174:     ok(f"imports stage2 réécrits dans {changed} fichier(s)")
   175: 
   176: def main():
   177:     ap = argparse.ArgumentParser(description="Restructure + rename Python package (scalp -> scalper).")
   178:     ap.add_argument("--repo", default="./", help="Chemin du repo (racine qui contient bot.py).")
   179:     args = ap.parse_args()
   180:     repo = Path(args.repo).resolve()
   181:     if not repo.exists(): raise SystemExit(f"Repo introuvable: {repo}")
   182: 
   183:     # 1) sauvegarde
   184:     backup_repo(repo)
   185: 
   186:     # 2) ranger les modules sous scalp/ (package) + fixer imports
   187:     stage1_restructure(repo)
   188: 
   189:     # 3) renommer le package interne scalp/ -> scalper/ + fixer imports
   190:     stage2_rename_package(repo, old="scalp", new="scalper")
   191: 
   192:     ok("Refactor complet terminé.")
   193:     print("\n➡️ Vérifie maintenant:\n"
   194:           "   python - <<'PY'\n"
   195:           "import importlib; m = importlib.import_module('scalper.config'); print('OK:', hasattr(m, 'load_settings'))\n"
   196:           "PY\n"
   197:           "\nPuis lance:\n"
   198:           "   python bot.py\n")
   199: 
   200: if __name__ == "__main__":
   201:     main()

## TRASH_20250823-124533/run_backtest.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: import os
     3: from scalper.backtest.engine import BacktestEngine
     4: 
     5: def main():
     6:     print("[*] Lancement du backtest...")
     7:     
     8:     # ⚡ Tu pourras changer ces paramètres
     9:     pairs = ["BTCUSDT", "ETHUSDT"]  # pour commencer simple
    10:     start_date = "2024-01-01"
    11:     end_date = "2024-02-01"
    12: 
    13:     # Dossier résultat
    14:     result_dir = os.path.join(os.path.dirname(__file__), "result")
    15:     os.makedirs(result_dir, exist_ok=True)
    16: 
    17:     # Création du moteur
    18:     engine = BacktestEngine(
    19:         pairs=pairs,
    20:         start_date=start_date,
    21:         end_date=end_date,
    22:         result_dir=result_dir
    23:     )
    24: 
    25:     # Lancer le backtest
    26:     engine.run()
    27: 
    28:     print("[✅] Backtest terminé ! Résultats disponibles dans /result/")
    29: 
    30: if __name__ == "__main__":
    31:     main()

## TRASH_20250823-124533/scalper/bot_config.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: 
     3: 
     4: DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"
     5: 
     6: CONFIG = {
     7:     "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
     8:     or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
     9:     "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
    10:     or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
    11:     "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
    12:     "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
    13:     "SYMBOL": DEFAULT_SYMBOL,
    14:     "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
    15:     "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
    16:     "INTERVAL": os.getenv("INTERVAL", "1m"),
    17:     "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
    18:     "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
    19:     "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
    20:     "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
    21:     "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
    22:     "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
    23:     "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
    24:     "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
    25:     "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
    26:     "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
    27:     "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
    28:     "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
    29:     "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
    30:     "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
    31:     "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
    32:     "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
    33:     "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
    34:     "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
    35:     "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
    36:     "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
    37:     "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
    38:     # --- Sécurité / Sizing -------------------------------------------------
    39:     "ALLOWED_SYMBOLS": [
    40:         s.strip().upper()
    41:         for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
    42:         if s.strip()
    43:     ],
    44:     "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
    45:     "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
    46:     "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
    47:     "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
    48:     "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
    49:     "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
    50:     "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
    51:     "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
    52:     "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
    53: }
    54: 


## TRASH_20250823-124533/scalper/legacy_config.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/config.py
     2: from __future__ import annotations
     3: import os, sys
     4: from typing import Optional
     5: 
     6: # ---------------------------
     7: #  Chargement .env (sans dep)
     8: # ---------------------------
     9: def _load_dotenv_if_present(path: str = ".env") -> None:
    10:     try:
    11:         if not os.path.isfile(path):
    12:             return
    13:         with open(path, "r", encoding="utf-8") as f:
    14:             for line in f:
    15:                 s = line.strip()
    16:                 if not s or s.startswith("#") or "=" not in s:
    17:                     continue
    18:                 k, v = s.split("=", 1)
    19:                 k = k.strip()
    20:                 v = v.strip().strip('"').strip("'")
    21:                 # ne pas écraser une var déjà définie par l'env
    22:                 os.environ.setdefault(k, v)
    23:     except Exception:
    24:         pass
    25: 
    26: _load_dotenv_if_present()
    27: 
    28: # ---------------------------
    29: #  Aliases variables d'env
    30: # ---------------------------
    31: def _env_alias(name: str, *aliases: str) -> Optional[str]:
    32:     """Retourne la première valeur non nulle parmi name et ses alias."""
    33:     if name in os.environ and os.environ[name]:
    34:         return os.environ[name]
    35:     for a in aliases:
    36:         v = os.environ.get(a)
    37:         if v:
    38:             return v
    39:     return None
    40: 
    41: def _env_bool(name: str, default: bool) -> bool:
    42:     raw = os.environ.get(name)
    43:     if raw is None:
    44:         return default
    45:     return raw.lower() in ("1", "true", "yes", "on")
    46: 
    47: # ---------------------------
    48: #  Pydantic v1 si dispo
    49: # ---------------------------
    50: try:
    51:     from pydantic import BaseModel, Field, ValidationError  # type: ignore
    52:     _HAVE_PYDANTIC = True
    53: except Exception:
    54:     _HAVE_PYDANTIC = False
    55: 
    56: if _HAVE_PYDANTIC:
    57: 
    58:     class AppConfig(BaseModel):
    59:         # Clés Bitget
    60:         BITGET_API_KEY: str = Field(..., min_length=3)
    61:         BITGET_API_SECRET: str = Field(..., min_length=3)
    62:         BITGET_PASSPHRASE: str = Field(..., min_length=1)
    63: 
    64:         # Trading
    65:         RISK_PCT: float = Field(0.01, ge=0.0, le=0.2)
    66:         MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
    67:         LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
    68:         PAPER_TRADE: bool = Field(True)
    69: 
    70:         # Telegram (facultatif)
    71:         TELEGRAM_BOT_TOKEN: Optional[str] = None
    72:         TELEGRAM_CHAT_ID: Optional[str] = None
    73: 
    74:     def load_or_exit() -> "AppConfig":
    75:         try:
    76:             # supporte aussi ACCESS_KEY/SECRET_KEY (alias)
    77:             api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
    78:             api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
    79:             api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
    80: 
    81:             return AppConfig(
    82:                 BITGET_API_KEY=api_key,
    83:                 BITGET_API_SECRET=api_sec,
    84:                 BITGET_PASSPHRASE=api_pass,
    85:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
    86:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
    87:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
    88:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
    89:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
    90:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
    91:             )
    92:         except ValidationError as e:
    93:             print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
    94:             sys.exit(2)
    95: 
    96: else:
    97:     # ---------------------------
    98:     #  Fallback dataclass simple
    99:     # ---------------------------
   100:     from dataclasses import dataclass
   101: 
   102:     @dataclass
   103:     class AppConfig:
   104:         BITGET_API_KEY: str
   105:         BITGET_API_SECRET: str
   106:         BITGET_PASSPHRASE: str
   107: 
   108:         RISK_PCT: float = 0.01
   109:         MIN_TRADE_USDT: float = 5.0
   110:         LEVERAGE: float = 1.0
   111:         PAPER_TRADE: bool = True
   112: 
   113:         TELEGRAM_BOT_TOKEN: Optional[str] = None
   114:         TELEGRAM_CHAT_ID: Optional[str] = None
   115: 
   116:     def load_or_exit() -> "AppConfig":
   117:         api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
   118:         api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
   119:         api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
   120: 
   121:         if not api_key or not api_sec or not api_pass:
   122:             print("[CONFIG] Missing Bitget credentials. Expected either:", file=sys.stderr)
   123:             print("        - BITGET_API_KEY / BITGET_API_SECRET / BITGET_PASSPHRASE", file=sys.stderr)
   124:             print("          or", file=sys.stderr)
   125:             print("        - BITGET_ACCESS_KEY / BITGET_SECRET_KEY / BITGET_PASSPHRASE", file=sys.stderr)
   126:             sys.exit(2)
   127: 
   128:         try:
   129:             return AppConfig(
   130:                 BITGET_API_KEY=api_key,
   131:                 BITGET_API_SECRET=api_sec,
   132:                 BITGET_PASSPHRASE=api_pass,
   133:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
   134:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
   135:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
   136:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
   137:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
   138:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
   139:             )
   140:         except Exception as e:
   141:             print(f"[CONFIG] Invalid configuration values: {e!r}", file=sys.stderr)
   142:             sys.exit(2)

## TRASH_20250823-124533/scalper/notifier.py (last modified: 2025-08-24 10:15:51)
     1: """Simple notifier for bot events."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import logging
     6: import os
     7: from typing import Any, Dict
     8: 
     9: try:  # pragma: no cover - guarded import for optional dependency
    10:     import requests as _requests
    11: 
    12:     # ``requests`` may be provided as a stub during tests. Ensure it exposes a
    13:     # ``post`` attribute so callers can monkeypatch it reliably.
    14:     if not hasattr(_requests, "post"):
    15:         raise ImportError
    16:     requests = _requests
    17: except Exception:  # pragma: no cover - fallback when ``requests`` is missing
    18: 
    19:     class _Requests:
    20:         """Minimal stand‑in for :mod:`requests` when the real library is absent."""
    21: 
    22:         def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
    23:             raise RuntimeError("requests.post unavailable")
    24: 
    25:     requests = _Requests()  # type: ignore[assignment]
    26: 
    27: 
    28: def _pair_name(symbol: str) -> str:
    29:     """Return a human friendly pair name without the base ``USDT``."""
    30:     if "_" in symbol:
    31:         base, quote = symbol.split("_", 1)
    32:     elif symbol.endswith("USDT"):
    33:         base, quote = symbol[:-4], "USDT"
    34:     else:
    35:         base, quote = symbol, ""
    36:     if not quote or quote == "USDT":
    37:         return base
    38:     return f"{base}/{quote}"
    39: 
    40: 
    41: def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
    42:     """Format a position open/close payload."""
    43: 
    44:     side = payload.get("side")
    45:     symbol = payload.get("symbol")
    46:     if symbol:
    47:         symbol = _pair_name(symbol)
    48: 
    49:     if event == "position_opened":
    50:         rc = payload.get("risk_color", "")
    51:         head = f"{rc} Ouvre {side} {symbol}".strip()
    52:         lines = [head]
    53:         lines.append(
    54:             f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
    55:         )
    56:         lines.append(
    57:             "Marge estimée: {} USDT (dispo: {} USDT)".format(
    58:                 payload.get("required_margin_usdt"), payload.get("available_usdt")
    59:             )
    60:         )
    61:         lines.append(
    62:             "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
    63:                 payload.get("signal_level"),
    64:                 payload.get("risk_level_user"),
    65:                 float(payload.get("risk_pct_eff", 0.0)) * 100,
    66:             )
    67:         )
    68:         lines.append(
    69:             "Prix: {}   Vol: {} (cs={})".format(
    70:                 payload.get("price"),
    71:                 payload.get("vol"),
    72:                 payload.get("contract_size"),
    73:             )
    74:         )
    75:         return "\n".join(lines)
    76: 
    77:     # position_closed
    78:     rc = payload.get("risk_color", "")
    79:     head = f"Ferme {side} {symbol} {rc}".strip()
    80:     lines = [head]
    81:     pnl_usdt = payload.get("pnl_usdt")
    82:     fees = payload.get("fees_usdt")
    83:     if pnl_usdt is not None and fees is not None:
    84:         lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
    85:     pct = payload.get("pnl_pct_on_margin")
    86:     if pct is not None:
    87:         lines.append(f"% sur marge: {pct:.2f}%")
    88:     lines.append(
    89:         "Entrée: {}  Sortie: {}".format(
    90:             payload.get("entry_price"), payload.get("exit_price")
    91:         )
    92:     )
    93:     lines.append(
    94:         "Vol: {}  Notional: in {} → out {} USDT".format(
    95:             payload.get("vol"),
    96:             payload.get("notional_entry_usdt"),
    97:             payload.get("notional_exit_usdt"),
    98:         )
    99:     )
   100:     return "\n".join(lines)
   101: 
   102: 
   103: def _format_pair_list(payload: Dict[str, Any]) -> str:
   104:     """Format the pair list payload.
   105: 
   106:     The detailed pair listing is intentionally hidden from terminal output to
   107:     reduce noise. Only an acknowledgement message is returned.
   108:     """
   109: 
   110:     return "Listing ok"
   111: 
   112: 
   113: def _format_generic(event: str, payload: Dict[str, Any]) -> str:
   114:     text = event
   115:     if payload:
   116:         items = "\n".join(f"{k}={v}" for k, v in payload.items())
   117:         text = f"{text}\n{items}"
   118:     return text
   119: 
   120: 
   121: def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
   122:     """Return a human readable text describing the event payload."""
   123:     payload = payload or {}
   124:     if event in {"position_opened", "position_closed"}:
   125:         return _format_position_event(event, payload)
   126:     if event == "pair_list":
   127:         return _format_pair_list(payload)
   128:     if event == "bot_started":
   129:         return "🤖 Bot démarré"
   130:     return _format_generic(event, payload)
   131: 
   132: 
   133: def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
   134:     """Send an event payload to configured endpoints.
   135: 
   136:     Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
   137:     and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
   138:     ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
   139:     ignored so they do not interrupt the bot's execution.
   140:     """
   141: 
   142:     data = {"event": event}
   143:     if payload:
   144:         data.update(payload)
   145: 
   146:     # Generic HTTP webhook
   147:     url = os.getenv("NOTIFY_URL")
   148:     if url:
   149:         try:
   150:             requests.post(url, json=data, timeout=5)
   151:         except Exception as exc:  # pragma: no cover - best effort only
   152:             logging.error("Notification error for %s: %s", event, exc)
   153: 
   154:     # Telegram notification
   155:     token = os.getenv("TELEGRAM_BOT_TOKEN")
   156:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
   157:     # ``pair_list`` notifications are intentionally not forwarded to Telegram
   158:     if token and chat_id and event != "pair_list":
   159:         text = _format_text(event, payload or {})
   160:         t_url = f"https://api.telegram.org/bot{token}/sendMessage"
   161:         t_payload = {"chat_id": chat_id, "text": text}
   162:         try:  # pragma: no cover - network
   163:             requests.post(t_url, json=t_payload, timeout=5)
   164:         except Exception as exc:  # pragma: no cover - best effort only
   165:             logging.error("Telegram notification error for %s: %s", event, exc)


## TRASH_20250823-124533/scalper/telegram_bot.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: import logging
     4: import os
     5: from typing import Any, Dict, Optional
     6: 
     7: try:  # pragma: no cover - optional dependency
     8:     import requests as _requests
     9:     requests = _requests
    10: except Exception:  # pragma: no cover
    11:     class _Requests:
    12:         def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
    13:             raise RuntimeError("requests.get unavailable")
    14: 
    15:         def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
    16:             raise RuntimeError("requests.post unavailable")
    17: 
    18:     requests = _Requests()  # type: ignore[assignment]
    19: 
    20: 
    21: class TelegramBot:
    22:     """Minimal Telegram bot using the HTTP API.
    23: 
    24: 
    25:     The bot exposes a simple *menu* based interface with clickable buttons so
    26:     users do not have to remember text commands.  A sub-menu lets the user set
    27:     the risk level.
    28: 
    29:     """
    30: 
    31:     def __init__(
    32:         self,
    33:         token: str,
    34:         chat_id: str,
    35:         client: Any,
    36:         config: Dict[str, Any],
    37:         risk_mgr: Any,
    38:         *,
    39:         requests_module: Any = requests,
    40:     ) -> None:
    41:         self.token = token
    42:         self.chat_id = str(chat_id)
    43:         self.client = client
    44:         self.config = config
    45:         self.risk_mgr = risk_mgr
    46:         self.requests = requests_module
    47:         self.last_update_id: Optional[int] = None
    48:         self.stop_requested = False
    49: 
    50: 
    51:         self.main_keyboard = [
    52:             [{"text": "Positions ouvertes", "callback_data": "positions"}],
    53:             [{"text": "Update Cryptos", "callback_data": "update"}],
    54:             [{"text": "Réglages", "callback_data": "settings"}],
    55:             [{"text": "Arrêt bot", "callback_data": "shutdown"}],
    56:         ]
    57:         self.settings_keyboard = [
    58:             [{"text": "Stop trade", "callback_data": "stop"}],
    59:             [{"text": "Réglage risk", "callback_data": "risk"}],
    60:             [{"text": "Nb positions", "callback_data": "maxpos"}],
    61:             [{"text": "Reset risk", "callback_data": "reset_risk"}],
    62:             [{"text": "Reset total", "callback_data": "reset_all"}],
    63:             [{"text": "Retour", "callback_data": "back"}],
    64:         ]
    65:         self.risk_keyboard = [
    66:             [
    67:                 {"text": "🟢", "callback_data": "risk_green"},
    68:                 {"text": "🟠", "callback_data": "risk_orange"},
    69:                 {"text": "🔴", "callback_data": "risk_red"},
    70:             ],
    71:             [{"text": "Retour", "callback_data": "back"}],
    72:         ]
    73:         self.maxpos_keyboard = [
    74:             [
    75:                 {"text": "1", "callback_data": "maxpos_1"},
    76:                 {"text": "2", "callback_data": "maxpos_2"},
    77:                 {"text": "3", "callback_data": "maxpos_3"},
    78:             ],
    79:             [
    80:                 {"text": "4", "callback_data": "maxpos_4"},
    81:                 {"text": "5", "callback_data": "maxpos_5"},
    82:             ],
    83:             [{"text": "Retour", "callback_data": "back"}],
    84:         ]
    85: 
    86:         # Show menu on startup with zero PnL session
    87:         self.send_main_menu(0.0)
    88: 
    89: 
    90:     def _base_symbol(self, symbol: str) -> str:
    91:         sym = symbol.replace("_", "")
    92:         return sym[:-4] if sym.endswith("USDT") else sym
    93: 
    94:     def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
    95:         pos = self.client.get_positions() or {}
    96:         buttons: list[list[Dict[str, str]]] = []
    97:         for p in pos.get("data") or []:
    98:             sym = p.get("symbol")
    99:             if not sym:
   100:                 continue
   101:             base = self._base_symbol(sym)
   102:             # Use the full symbol in the callback so we can properly
   103:             # identify the position to close.  Only the label shows the
   104:             # base asset to keep the interface concise.
   105:             buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
   106:         buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
   107:         buttons.append([{"text": "Retour", "callback_data": "back"}])
   108:         return buttons
   109: 
   110: 
   111:     def _menu_text(self, session_pnl: float) -> str:
   112:         assets = self.client.get_assets() or {}
   113:         equity = 0.0
   114:         for row in assets.get("data") or []:
   115:             if row.get("currency") == "USDT":
   116:                 try:
   117:                     equity = float(row.get("equity", 0.0))
   118:                 except Exception:
   119:                     equity = 0.0
   120:                 break
   121:         return (
   122:             f"Solde: {equity:.2f} USDT\n"
   123:             f"PnL session: {session_pnl:.2f} USDT\n"
   124:             f"Positions max: {self.risk_mgr.max_positions}\n"
   125:             f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
   126:             "Choisissez une option:"
   127:         )
   128: 
   129:     def send_main_menu(self, session_pnl: float) -> None:
   130:         self.send(self._menu_text(session_pnl), self.main_keyboard)
   131: 
   132:     def update_pairs(self) -> None:
   133:         from bot import update as _update  # lazy import to avoid cycle
   134:         _update(self.client, top_n=40)
   135: 
   136:     # ------------------------------------------------------------------
   137:     def _api_url(self, method: str) -> str:
   138:         return f"https://api.telegram.org/bot{self.token}/{method}"
   139: 
   140: 
   141:     def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
   142:         payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
   143:         if keyboard:
   144:             payload["reply_markup"] = {"inline_keyboard": keyboard}
   145: 
   146:         try:  # pragma: no cover - network
   147:             self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
   148:         except Exception as exc:  # pragma: no cover - best effort
   149:             logging.error("Telegram send error: %s", exc)
   150: 
   151:     def answer_callback(self, cb_id: str) -> None:
   152:         payload = {"callback_query_id": cb_id}
   153:         try:  # pragma: no cover - network
   154:             self.requests.post(
   155:                 self._api_url("answerCallbackQuery"), json=payload, timeout=5
   156:             )
   157:         except Exception as exc:  # pragma: no cover - best effort
   158:             logging.error("Telegram answerCallback error: %s", exc)
   159: 
   160: 
   161:     # ------------------------------------------------------------------
   162:     def fetch_updates(self) -> list[Dict[str, Any]]:
   163:         params: Dict[str, Any] = {}
   164:         if self.last_update_id is not None:
   165:             params["offset"] = self.last_update_id + 1
   166:         try:  # pragma: no cover - network
   167:             r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
   168:             r.raise_for_status()
   169:             data = r.json()
   170:         except Exception as exc:  # pragma: no cover - best effort
   171:             logging.error("Telegram getUpdates error: %s", exc)
   172:             return []
   173:         updates = data.get("result", [])
   174:         if updates:
   175:             self.last_update_id = updates[-1].get("update_id")
   176:         return updates
   177: 
   178:     # ------------------------------------------------------------------
   179:     def handle_updates(self, session_pnl: float) -> None:
   180:         for update in self.fetch_updates():
   181: 
   182:             callback = update.get("callback_query")
   183:             if callback:
   184:                 if str(callback.get("from", {}).get("id")) != self.chat_id:
   185:                     continue
   186:                 data = callback.get("data", "")
   187:                 reply, kb = self.handle_callback(data, session_pnl)
   188:                 if reply:
   189:                     self.send(reply, kb)
   190:                 cb_id = callback.get("id")
   191:                 if cb_id:
   192:                     self.answer_callback(cb_id)
   193:                 continue
   194: 
   195: 
   196:             msg = update.get("message") or {}
   197:             chat = msg.get("chat") or {}
   198:             if str(chat.get("id")) != self.chat_id:
   199:                 continue
   200: 
   201:             # Any text message triggers the main menu with balance and PnL
   202:             self.send_main_menu(session_pnl)
   203: 
   204:     # ------------------------------------------------------------------
   205:     def handle_callback(
   206:         self, data: str, session_pnl: float
   207:     ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
   208:         if not data:
   209:             return None, None
   210:         if data == "balance":
   211:             assets = self.client.get_assets() or {}
   212:             equity = 0.0
   213:             for row in assets.get("data") or []:
   214:                 if row.get("currency") == "USDT":
   215:                     try:
   216:                         equity = float(row.get("equity", 0.0))
   217:                     except Exception:
   218:                         equity = 0.0
   219:                     break
   220: 
   221:             return f"Solde: {equity:.2f} USDT", self.main_keyboard
   222:         if data == "positions":
   223:             pos = self.client.get_positions() or {}
   224:             lines = []
   225:             for p in pos.get("data") or []:
   226:                 symbol = p.get("symbol", "")
   227:                 base = self._base_symbol(symbol)
   228:                 side = p.get("side")
   229:                 vol = p.get("vol")
   230:                 pnl = p.get("pnl_usdt")
   231:                 if pnl is None:
   232:                     pnl = p.get("pnl_usd")
   233:                 if pnl is None:
   234:                     pnl = p.get("pnl")
   235:                 pnl_pct = p.get("pnl_pct_on_margin")
   236:                 if pnl_pct is None:
   237:                     pnl_pct = p.get("pnl_pct")
   238:                 line = f"{base} {side} {vol}"
   239:                 if pnl is not None and pnl_pct is not None:
   240:                     line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
   241:                 lines.append(line)
   242:             if not lines:
   243: 
   244:                 return "Aucune position ouverte", self.main_keyboard
   245:             return "Positions:\n" + "\n".join(lines), self.main_keyboard
   246:         if data == "pnl":
   247:             return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
   248:         if data == "risk":
   249:             return "Choisissez le niveau de risque:", self.risk_keyboard
   250:         if data == "settings":
   251:             return "Réglages:", self.settings_keyboard
   252:         if data == "maxpos":
   253:             return "Choisissez le nombre de positions:", self.maxpos_keyboard
   254:         if data == "reset_risk":
   255:             try:
   256:                 self.risk_mgr.reset_day()
   257:                 return "Risque réinitialisé", self.settings_keyboard
   258:             except Exception:
   259:                 return "Erreur reset risque", self.settings_keyboard
   260:         if data == "update":
   261:             try:
   262:                 self.update_pairs()
   263:                 return "Liste cryptos mise à jour", self.main_keyboard
   264:             except Exception:
   265:                 return "Erreur mise à jour", self.main_keyboard
   266:         if data.startswith("risk"):
   267:             mapping = {
   268:                 "risk_green": 1,
   269:                 "risk_orange": 2,
   270:                 "risk_red": 3,
   271:             }
   272:             lvl = mapping.get(data)
   273:             if lvl:
   274:                 self.config["RISK_LEVEL"] = lvl
   275:                 return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
   276:             return "Niveau de risque inchangé", self.main_keyboard
   277: 
   278:         if data.startswith("maxpos_"):
   279:             try:
   280:                 lvl = int(data.split("_", 1)[1])
   281:             except Exception:
   282:                 lvl = None
   283:             if lvl:
   284:                 self.config["MAX_POSITIONS"] = lvl
   285:                 self.risk_mgr.max_positions = lvl
   286:                 return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
   287:             return "Nombre de positions inchangé", self.main_keyboard
   288: 
   289:         if data == "reset_all":
   290:             try:
   291:                 self.client.close_all_positions()
   292:                 self.risk_mgr.reset_day()
   293:                 return "Positions et risque réinitialisés", self.settings_keyboard
   294:             except Exception:
   295:                 return "Erreur lors du reset total", self.settings_keyboard
   296: 
   297:         if data == "stop":
   298:             pos = self.client.get_positions() or {}
   299:             if not (pos.get("data") or []):
   300:                 return "Aucune crypto sélectionnée", self.settings_keyboard
   301:             return "Choisissez la position à fermer:", self._build_stop_keyboard()
   302:         if data == "stop_all":
   303:             try:
   304:                 self.client.close_all_positions()
   305:                 return "Toutes les positions fermées", self.settings_keyboard
   306:             except Exception:
   307:                 return "Erreur arrêt trade", self.settings_keyboard
   308:         if data.startswith("stop_"):
   309:             sym = data[5:]
   310:             try:
   311:                 self.client.close_position(sym)
   312:                 return f"Position {sym} fermée", self.settings_keyboard
   313:             except Exception:
   314:                 return f"Erreur arrêt trade {sym}", self.settings_keyboard
   315: 
   316:         if data == "shutdown":
   317:             self.stop_requested = True
   318:             return "Arrêt du bot demandé", self.main_keyboard
   319: 
   320:         if data == "back":
   321:             return self._menu_text(session_pnl), self.main_keyboard
   322:         return None, None
   323: 
   324: 
   325: def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
   326:     token = os.getenv("TELEGRAM_BOT_TOKEN")
   327:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
   328:     if token and chat_id:
   329:         return TelegramBot(token, chat_id, client, config, risk_mgr)
   330:     return None


## TRASH_20250823-124533/short_one_way.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: # -*- coding: utf-8 -*-
     3: """Example script to open a one-way short on Bitget futures.
     4: 
     5: This standalone script signs and sends a market sell order using the
     6: Bitget REST API. Environment variables required (defined in a `.env`
     7: file alongside this script):
     8: 
     9: - ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
    10: - ``BITGET_API_KEY``
    11: - ``BITGET_API_SECRET``
    12: - ``BITGET_API_PASSPHRASE``
    13: - ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
    14: - ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
    15: - ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
    16: - ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)
    17: 
    18: The script retrieves the current contract specification and price,
    19: ensures account settings (one-way mode & leverage) and finally places a
    20: market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.
    21: 
    22: The intent is purely demonstrational; use at your own risk.
    23: """
    24: 
    25: import base64
    26: import hashlib
    27: import hmac
    28: import json
    29: import os
    30: import sys
    31: import time
    32: import uuid
    33: from pathlib import Path
    34: 
    35: import requests
    36: 
    37: try:  # lazy dependency import for dotenv
    38:     from dotenv import load_dotenv
    39: except ImportError:  # pragma: no cover - installation fallback
    40:     import subprocess
    41: 
    42:     subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
    43:     from dotenv import load_dotenv
    44: 
    45: # load environment variables
    46: load_dotenv(Path(__file__).resolve().parent / ".env")
    47: 
    48: 
    49: def T(x):  # small helper used throughout configuration
    50:     return x.strip() if isinstance(x, str) else x
    51: 
    52: 
    53: BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
    54: AK = T(os.getenv("BITGET_API_KEY"))
    55: SK = T(os.getenv("BITGET_API_SECRET"))
    56: PH = T(os.getenv("BITGET_API_PASSPHRASE"))
    57: PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
    58: MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
    59: SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
    60: NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))
    61: 
    62: if not (AK and SK and PH):
    63:     sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")
    64: 
    65: print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")
    66: 
    67: 
    68: # ---------- signing helpers ----------
    69: def sign_get(ts, path, params):
    70:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    71:     pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
    72:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    73:     return sig, qs
    74: 
    75: 
    76: def sign_post(ts, path, body, params=None):
    77:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    78:     body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
    79:     pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
    80:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    81:     return sig, body_str, qs
    82: 
    83: 
    84: def headers(sig, ts):
    85:     return {
    86:         "ACCESS-KEY": AK,
    87:         "ACCESS-SIGN": sig,
    88:         "ACCESS-TIMESTAMP": str(ts),
    89:         "ACCESS-PASSPHRASE": PH,
    90:         "ACCESS-RECV-WINDOW": "60000",
    91:         "Content-Type": "application/json",
    92:     }
    93: 
    94: 
    95: def pick_price(d: dict):
    96:     for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
    97:         try:
    98:             v = float(d.get(k))
    99:             if v > 0:
   100:                 return v
   101:         except Exception:
   102:             pass
   103:     return None
   104: 
   105: 
   106: # ---------- public endpoints ----------
   107: def get_contract_spec():
   108:     r = requests.get(
   109:         f"{BASE}/api/v2/mix/market/contracts",
   110:         params={"productType": PT, "symbol": SYMB},
   111:         timeout=12,
   112:     )
   113:     r.raise_for_status()
   114:     arr = r.json().get("data") or []
   115:     if not arr:
   116:         raise RuntimeError("Contrat introuvable")
   117:     return arr[0]
   118: 
   119: 
   120: def get_price():
   121:     # 1) ticker (obj/list) avec productType
   122:     try:
   123:         r = requests.get(
   124:             f"{BASE}/api/v2/mix/market/ticker",
   125:             params={"symbol": SYMB, "productType": PT},
   126:             timeout=10,
   127:         )
   128:         r.raise_for_status()
   129:         data = r.json().get("data")
   130:         if isinstance(data, dict):
   131:             p = pick_price(data)
   132:             if p:
   133:                 return p
   134:         if isinstance(data, list) and data:
   135:             p = pick_price(data[0])
   136:             if p:
   137:                 return p
   138:     except requests.HTTPError as e:
   139:         print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
   140:     except Exception as e:
   141:         print("⚠️ ticker err:", e)
   142: 
   143:     # 2) tickers (liste entière)
   144:     try:
   145:         r = requests.get(
   146:             f"{BASE}/api/v2/mix/market/tickers",
   147:             params={"productType": PT},
   148:             timeout=10,
   149:         )
   150:         r.raise_for_status()
   151:         arr = r.json().get("data") or []
   152:         row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
   153:         p = pick_price(row or {})
   154:         if p:
   155:             return p
   156:     except requests.HTTPError as e:
   157:         print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
   158:     except Exception as e:
   159:         print("⚠️ tickers err:", e)
   160: 
   161:     # 3) candles 1m (close)
   162:     try:
   163:         # ``symbol`` must be provided as a query parameter; placing it in the
   164:         # path triggers a 404 response from Bitget.
   165:         r = requests.get(
   166:             f"{BASE}/api/v2/mix/market/candles",
   167:             params={"symbol": SYMB, "granularity": "1m"},
   168:             timeout=10,
   169:         )
   170:         r.raise_for_status()
   171:         arr = r.json().get("data") or []
   172:         if arr:
   173:             return float(arr[0][4])
   174:     except requests.HTTPError as e:
   175:         print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
   176:     except Exception as e:
   177:         print("⚠️ candles err:", e)
   178: 
   179:     raise RuntimeError("prix indisponible")
   180: 
   181: 
   182: # ---------- private endpoints ----------
   183: def check_accounts():
   184:     path = "/api/v2/mix/account/accounts"
   185:     ts = int(time.time() * 1000)
   186:     params = {"productType": PT}
   187:     sig, qs = sign_get(ts, path, params)
   188:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   189:     r = requests.get(url, headers=headers(sig, ts), timeout=12)
   190:     print("accounts", r.status_code, r.text[:160])
   191:     r.raise_for_status()
   192:     j = r.json()
   193:     if str(j.get("code")) not in ("00000", "0"):
   194:         raise RuntimeError(j)
   195: 
   196: 
   197: def set_position_mode_one_way():
   198:     path = "/api/v2/mix/account/set-position-mode"
   199:     ts = int(time.time() * 1000)
   200:     body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
   201:     sig, b, qs = sign_post(ts, path, body)
   202:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   203:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
   204:     print("set-position-mode(one-way)", r.status_code, r.text[:160])
   205:     r.raise_for_status()
   206: 
   207: 
   208: def set_leverage(lv: int = 2):
   209:     path = "/api/v2/mix/account/set-leverage"
   210:     ts = int(time.time() * 1000)
   211:     body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
   212:     sig, b, qs = sign_post(ts, path, body)
   213:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   214:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
   215:     print("set-leverage", r.status_code, r.text[:160])
   216:     r.raise_for_status()
   217: 
   218: 
   219: def place_one_way_sell(size_coin: float):
   220:     """Ouvre un SHORT en one_way_mode (market SELL)."""
   221:     path = "/api/v2/mix/order/place-order"
   222:     ts = int(time.time() * 1000)
   223:     body = {
   224:         "symbol": SYMB,
   225:         "productType": PT,
   226:         "marginCoin": MC,
   227:         "marginMode": "crossed",
   228:         "posMode": "one_way_mode",
   229:         "orderType": "market",
   230:         "side": "sell",  # <-- SHORT
   231:         "size": str(size_coin),
   232:         "timeInForceValue": "normal",
   233:         "clientOid": str(uuid.uuid4())[:32],
   234:     }
   235:     sig, b, qs = sign_post(ts, path, body)
   236:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   237:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
   238:     print("place-order(one-way SELL)", r.status_code, r.text[:220])
   239:     r.raise_for_status()
   240:     j = r.json()
   241:     if str(j.get("code")) not in ("00000", "0"):
   242:         raise RuntimeError(j)
   243:     return j
   244: 
   245: 
   246: # ---------- main ----------
   247: def main():
   248:     spec = get_contract_spec()
   249:     min_usdt = float(spec.get("minTradeUSDT") or 5)
   250:     min_num = float(spec.get("minTradeNum") or 0)
   251:     size_place = int(spec.get("sizePlace") or 6)
   252:     print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")
   253: 
   254:     px = get_price()
   255:     print(f"Prix OK ≈ {px}")
   256: 
   257:     check_accounts()
   258:     set_position_mode_one_way()
   259:     set_leverage(2)
   260: 
   261:     target = max(NOTIONAL, min_usdt)
   262:     size = max(target / px, min_num)
   263:     size = float(f"{size:.{size_place}f}")
   264:     print(f"Taille={size} (target≈{target}USDT)")
   265: 
   266:     j = place_one_way_sell(size)
   267:     print("✅ SHORT OK")
   268:     print(json.dumps(j, indent=2, ensure_ascii=False))
   269: 
   270: 
   271: if __name__ == "__main__":  # pragma: no cover - script entrypoint
   272:     main()


## bot.py (last modified: 2025-08-24 10:15:51)
     1: # bot.py
     2: #!/usr/bin/env python3
     3: from __future__ import annotations
     4: 
     5: import asyncio
     6: import logging
     7: import os
     8: import sys
     9: from typing import Any, Dict, Iterable, Optional, Sequence
    10: 
    11: # -----------------------------------------------------------------------------
    12: # Logging de base
    13: # -----------------------------------------------------------------------------
    14: LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
    15: logging.basicConfig(
    16:     level=getattr(logging, LOG_LEVEL, logging.INFO),
    17:     format="%(asctime)s %(levelname)s %(name)s: %(message)s",
    18: )
    19: log = logging.getLogger("bot")
    20: 
    21: # -----------------------------------------------------------------------------
    22: # Chargement config (paramètres généraux YAML + secrets .env)
    23: # sitecustomize.py est importé automatiquement par Python si présent sur le
    24: # PYTHONPATH et, dans ce repo, il charge /notebooks/.env, normalise les aliases
    25: # et déclenche un pré‑flight qui écrit un READY.json si tout va bien.
    26: # -----------------------------------------------------------------------------
    27: try:
    28:     from scalper.config.loader import load_config  # type: ignore
    29: except Exception as exc:  # pragma: no cover
    30:     log.error("Impossible d'importer scalper.config.loader.load_config: %s", exc)
    31:     raise
    32: 
    33: 
    34: # -----------------------------------------------------------------------------
    35: # Petits utilitaires
    36: # -----------------------------------------------------------------------------
    37: def _comma_split(val: Optional[str]) -> list[str]:
    38:     if not val:
    39:         return []
    40:     return [s.strip() for s in val.split(",") if s.strip()]
    41: 
    42: 
    43: def check_config() -> None:
    44:     """
    45:     Vérif locale non bloquante des secrets critiques.
    46:     Le pré‑flight global (sitecustomize.py) s'occupe déjà de stopper si manquant.
    47:     """
    48:     for key in ("BITGET_ACCESS_KEY", "BITGET_SECRET_KEY"):
    49:         if not os.getenv(key):
    50:             logging.getLogger("bot.config").info("Missing %s", key)
    51: 
    52: 
    53: def _has_orchestrator() -> bool:
    54:     try:
    55:         import scalper.live.orchestrator  # noqa: F401
    56:         return True
    57:     except Exception:
    58:         return False
    59: 
    60: 
    61: # -----------------------------------------------------------------------------
    62: # Construction de l’exchange (CCXT si possible -> fallback REST)
    63: # -----------------------------------------------------------------------------
    64: def _build_exchange(cfg: Dict[str, Any]):
    65:     """
    66:     Retourne (exchange, backend_name)
    67:     - backend 'ccxt' si scalper.exchange.bitget_ccxt est dispo
    68:     - backend 'rest' sinon (scalper.bitget_client.BitgetFuturesClient)
    69:     """
    70:     access = cfg.get("secrets", {}).get("bitget", {}).get("access") or ""
    71:     secret = cfg.get("secrets", {}).get("bitget", {}).get("secret") or ""
    72:     passphrase = cfg.get("secrets", {}).get("bitget", {}).get("passphrase") or ""
    73:     runtime = cfg.get("runtime") or {}
    74:     data_dir = str(runtime.get("data_dir", "/notebooks/data"))
    75: 
    76:     # CCXT async
    77:     try:
    78:         from scalper.exchange.bitget_ccxt import BitgetExchange  # type: ignore
    79:         ex = BitgetExchange(
    80:             api_key=access,
    81:             secret=secret,
    82:             password=passphrase,
    83:             data_dir=data_dir,
    84:         )
    85:         log.info("Exchange initialisé: CCXT")
    86:         return ex, "ccxt"
    87:     except Exception as exc:
    88:         log.warning("CCXT indisponible (%s) — on bascule REST", exc)
    89: 
    90:     # REST interne
    91:     from scalper.bitget_client import BitgetFuturesClient  # type: ignore
    92:     base_url = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
    93:     ex = BitgetFuturesClient(
    94:         access_key=access,
    95:         secret_key=secret,
    96:         passphrase=passphrase,
    97:         base_url=base_url,
    98:         paper_trade=bool(runtime.get("paper_trade", True)),
    99:     )
   100:     log.info("Exchange initialisé: REST")
   101:     return ex, "rest"
   102: 
   103: 
   104: # -----------------------------------------------------------------------------
   105: # Chemin principal: orchestrateur live
   106: # -----------------------------------------------------------------------------
   107: async def _run_with_orchestrator(cfg: Dict[str, Any]) -> None:
   108:     """
   109:     Démarre l’orchestrateur live si disponible.
   110:     Modules attendus (présents dans le repo) :
   111:       - scalper/live/orchestrator.py : RunConfig, run_orchestrator
   112:       - scalper/live/notify.py      : build_notifier_and_commands
   113:     """
   114:     from scalper.live.orchestrator import RunConfig, run_orchestrator  # type: ignore
   115:     from scalper.live.notify import build_notifier_and_commands        # type: ignore
   116: 
   117:     runtime = cfg.get("runtime") or {}
   118:     strategy = cfg.get("strategy") or {}
   119: 
   120:     # Watchlist : si allowed_symbols vide -> fallback par défaut
   121:     allowed: Sequence[str] = runtime.get("allowed_symbols") or []
   122:     symbols = list(allowed) if allowed else ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
   123: 
   124:     run_cfg = RunConfig(
   125:         symbols=symbols,
   126:         timeframe=strategy.get("live_timeframe", "1m"),
   127:         refresh_secs=int(runtime.get("refresh_secs", 5)),
   128:         cache_dir=str(runtime.get("data_dir", "/notebooks/data")),
   129:     )
   130: 
   131:     exchange, backend = _build_exchange(cfg)
   132:     notifier, cmd_stream = await build_notifier_and_commands(cfg)
   133: 
   134:     log.info(
   135:         "Orchestrateur: backend=%s timeframe=%s symbols=%s",
   136:         backend, run_cfg.timeframe, ",".join(run_cfg.symbols),
   137:     )
   138:     await run_orchestrator(exchange, run_cfg, notifier, cmd_stream)
   139: 
   140: 
   141: # -----------------------------------------------------------------------------
   142: # Fallback minimal: scan pairs + log (si orchestrateur indisponible)
   143: # -----------------------------------------------------------------------------
   144: def _fallback_scan_once(cfg: Dict[str, Any]) -> None:
   145:     """
   146:     Mode secouru (pour ne pas planter si l’orchestrateur n’est pas importable).
   147:     Utilise le client REST + pairs.py pour un scan et log d’activité.
   148:     """
   149:     from scalper.bitget_client import BitgetFuturesClient  # type: ignore
   150:     from scalper.pairs import get_trade_pairs, select_top_pairs  # type: ignore
   151: 
   152:     access = cfg.get("secrets", {}).get("bitget", {}).get("access") or ""
   153:     secret = cfg.get("secrets", {}).get("bitget", {}).get("secret") or ""
   154:     passphrase = cfg.get("secrets", {}).get("bitget", {}).get("passphrase") or ""
   155:     runtime = cfg.get("runtime") or {}
   156: 
   157:     client = BitgetFuturesClient(
   158:         access_key=access,
   159:         secret_key=secret,
   160:         passphrase=passphrase,
   161:         base_url=os.getenv("BITGET_BASE_URL", "https://api.bitget.com"),
   162:         paper_trade=bool(runtime.get("paper_trade", True)),
   163:     )
   164:     pairs = get_trade_pairs(client) or []
   165:     top = select_top_pairs(client, top_n=10) or []
   166:     top_symbols = [p.get("symbol", "?") for p in top]
   167:     log.info("Scanner: total_pairs=%d top10=%s", len(pairs), ",".join(top_symbols))
   168: 
   169: 
   170: # -----------------------------------------------------------------------------
   171: # Entrée CLI
   172: # -----------------------------------------------------------------------------
   173: def main(argv: Optional[Iterable[str]] = None) -> int:
   174:     # Vérif locale (info) des secrets critiques
   175:     check_config()
   176: 
   177:     # Charge la config fusionnée (config.yaml + .env)
   178:     cfg = load_config()
   179: 
   180:     if _has_orchestrator():
   181:         try:
   182:             asyncio.run(_run_with_orchestrator(cfg))
   183:             return 0
   184:         except KeyboardInterrupt:
   185:             log.info("Arrêt demandé (Ctrl+C)")
   186:             return 0
   187:         except SystemExit as exc:
   188:             return int(getattr(exc, "code", 1) or 1)
   189:         except Exception as exc:
   190:             log.exception("Erreur orchestrateur: %s", exc)
   191:             return 1
   192:     else:
   193:         log.warning("Orchestrateur indisponible — mode scanner minimal.")
   194:         try:
   195:             _fallback_scan_once(cfg)
   196:             return 0
   197:         except Exception as exc:
   198:             log.exception("Erreur scanner: %s", exc)
   199:             return 1
   200: 
   201: 
   202: if __name__ == "__main__":
   203:     raise SystemExit(main(sys.argv[1:]))

## cli.py (last modified: 2025-08-24 10:15:51)
     1: """Command line utilities for the Scalp project.
     2: 
     3: This module exposes a small command line interface used throughout the
     4: project.  The actual trading logic lives in other modules, however the CLI is
     5: responsible for parsing parameters and dispatching the appropriate routines.
     6: 
     7: The implementation intentionally keeps the invoked functions minimal so that
     8: tests can patch them easily.  In a real deployment these functions would
     9: perform optimisation, walk‑forward analysis or run the live pipeline.
    10: """
    11: 
    12: from __future__ import annotations
    13: 
    14: import argparse
    15: import asyncio
    16: from typing import Iterable, List
    17: 
    18: from scalper.version import bump_version_from_git
    19: 
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Placeholder implementations
    23: # ---------------------------------------------------------------------------
    24: 
    25: 
    26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    27:     """Run a parallel parameter optimisation.
    28: 
    29:     The real project dispatches a potentially heavy optimisation routine.  The
    30:     function is kept trivial so unit tests can verify that the CLI wiring works
    31:     without actually performing the optimisation.
    32:     """
    33: 
    34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
    35: 
    36: 
    37: def run_walkforward_analysis(
    38:     pair: str, timeframe: str, splits: int, train_ratio: float
    39: ) -> None:
    40:     """Execute a walk-forward analysis."""
    41: 
    42:     print(
    43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    44:     )
    45: 
    46: 
    47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    48:     """Run the live trading pipeline."""
    49: 
    50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
    51: 
    52: 
    53: # ---------------------------------------------------------------------------
    54: # Argument parsing
    55: # ---------------------------------------------------------------------------
    56: 
    57: 
    58: def create_parser() -> argparse.ArgumentParser:
    59:     """Create the top-level argument parser."""
    60: 
    61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
    62:     sub = parser.add_subparsers(dest="command")
    63: 
    64:     # --- ``opt`` command -------------------------------------------------
    65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    67:     opt_p.add_argument("--tf", required=True, help="timeframe")
    68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    69:     opt_p.set_defaults(
    70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    71:     )
    72: 
    73:     # --- ``walkforward`` command ----------------------------------------
    74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    75:     wf_p.add_argument("--pair", required=True, help="trading pair")
    76:     wf_p.add_argument("--tf", required=True, help="timeframe")
    77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    78:     wf_p.add_argument(
    79:         "--train-ratio",
    80:         type=float,
    81:         default=0.7,
    82:         help="portion of data used for training",
    83:     )
    84:     wf_p.set_defaults(
    85:         func=lambda a: run_walkforward_analysis(
    86:             a.pair, a.tf, a.splits, a.train_ratio
    87:         )
    88:     )
    89: 
    90:     # --- ``live`` command -----------------------------------------------
    91:     live_p = sub.add_parser("live", help="run the live async pipeline")
    92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
    95: 
    96:     # --- ``bump-version`` command -------------------------------------
    97:     bv_p = sub.add_parser(
    98:         "bump-version",
    99:         help="update the VERSION file based on the latest git commit",
   100:     )
   101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
   102: 
   103:     return parser
   104: 
   105: 
   106: def main(argv: Iterable[str] | None = None) -> int:
   107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
   108: 
   109:     parser = create_parser()
   110:     args = parser.parse_args(argv)
   111:     if not hasattr(args, "func"):
   112:         parser.print_help()
   113:         return 0
   114:     result = args.func(args)
   115:     return 0 if result is None else int(result)
   116: 
   117: 
   118: if __name__ == "__main__":  # pragma: no cover - manual invocation
   119:     raise SystemExit(main())
   120: 


## data/BTCUSDT-1m.csv (last modified: 2025-08-24 10:15:51)
     1: ts,open,high,low,close,volume
     2: 1625097600000,34000,34100,33950,34050,123.4
     3: 1625097660000,34050,34200,34000,34150,150.7
     4: 1625097720000,34150,34300,34100,34250,180.3
     5: 1625097780000,34250,34400,34200,34350,200.1
     6: 1625097840000,34350,34500,34300,34450,220.8

## data/__init__.py (last modified: 2025-08-24 10:15:51)
     1: """Indicator computation helpers."""
     2: 
     3: from .indicators import compute_all
     4: 
     5: __all__ = ["compute_all"]


## data/indicators.py (last modified: 2025-08-24 10:15:51)
     1: import pandas as pd
     2: 
     3: __all__ = ["compute_all"]
     4: 
     5: def compute_all(
     6:     df: pd.DataFrame,
     7:     *,
     8:     ema_fast: int = 20,
     9:     ema_slow: int = 50,
    10:     rsi_period: int = 14,
    11:     macd_fast: int = 12,
    12:     macd_slow: int = 26,
    13:     macd_signal: int = 9,
    14:     atr_period: int = 14,
    15:     swing_lookback: int = 5,
    16: ) -> pd.DataFrame:
    17:     """Compute common indicators and return enriched DataFrame.
    18: 
    19:     Parameters
    20:     ----------
    21:     df : pd.DataFrame
    22:         DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
    23:         ``volume`` columns ordered chronologically.
    24: 
    25:     Returns
    26:     -------
    27:     pd.DataFrame
    28:         New DataFrame with additional indicator columns.
    29:     """
    30: 
    31:     if df.empty:
    32:         return df.copy()
    33: 
    34:     df = df.copy()
    35: 
    36:     # --- VWAP ---------------------------------------------------------------
    37:     typical = (df["high"] + df["low"] + df["close"]) / 3.0
    38:     vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
    39:     df["vwap"] = vwap
    40: 
    41:     # --- EMAs ---------------------------------------------------------------
    42:     df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
    43:     df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()
    44: 
    45:     # --- RSI ----------------------------------------------------------------
    46:     delta = df["close"].diff()
    47:     gain = delta.where(delta > 0, 0.0)
    48:     loss = -delta.where(delta < 0, 0.0)
    49:     avg_gain = gain.rolling(rsi_period).mean()
    50:     avg_loss = loss.rolling(rsi_period).mean()
    51:     rs = avg_gain / avg_loss
    52:     rsi = 100 - (100 / (1 + rs))
    53:     df["rsi"] = rsi.fillna(50.0)
    54: 
    55:     # --- MACD ---------------------------------------------------------------
    56:     ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
    57:     ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
    58:     macd = ema_fast_series - ema_slow_series
    59:     signal = macd.ewm(span=macd_signal, adjust=False).mean()
    60:     df["macd"] = macd
    61:     df["macd_signal"] = signal
    62:     df["macd_hist"] = macd - signal
    63: 
    64:     # --- OBV ----------------------------------------------------------------
    65:     obv = [0.0]
    66:     closes = df["close"].tolist()
    67:     vols = df["volume"].tolist()
    68:     for i in range(1, len(df)):
    69:         if closes[i] > closes[i - 1]:
    70:             obv.append(obv[-1] + vols[i])
    71:         elif closes[i] < closes[i - 1]:
    72:             obv.append(obv[-1] - vols[i])
    73:         else:
    74:             obv.append(obv[-1])
    75:     df["obv"] = obv
    76: 
    77:     # --- ATR ----------------------------------------------------------------
    78:     high_low = df["high"] - df["low"]
    79:     high_close = (df["high"] - df["close"].shift()).abs()
    80:     low_close = (df["low"] - df["close"].shift()).abs()
    81:     tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    82:     df["atr"] = tr.rolling(atr_period).mean()
    83: 
    84:     # --- Swing highs/lows ---------------------------------------------------
    85:     df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
    86:     df["swing_low"] = df["low"].rolling(window=swing_lookback).min()
    87: 
    88:     return df


## docs/CLEANUP_TODO.txt (last modified: 2025-08-24 10:15:51)
     1: docs/CLEANUP_TODO.txt
     2: [INUTILE/À SUPPRIMER LATER] Dossier d’archives non utilisé par l’exécution :
     3: - TRASH_20250823-124533/
     4: 
     5: [INUTILE/À SUPPRIMER LATER] Scripts et modules obsolètes à l’intérieur de TRASH_20250823-124533/ (doublons ou anciens essais) :
     6: - quick_order.py
     7: - dashboard.py
     8: - rr.py
     9: - notebooks/spot/bitget_bot.py
    10: - scalper/telegram_bot.py
    11: - scalper/notifier.py
    12: - scalper/legacy_config.py
    13: 
    14: [NOTE]
    15: Ces éléments ne sont pas importés par l’entrée bot.py, ni requis par scalper/live/* actuel.
    16: On les garde pour l’instant comme référence, mais cible de suppression lors de la phase “ménage” (<400 lignes et code mort).
    17: FIN DE FICHIER

## docs/CONFIG.txt (last modified: 2025-08-24 10:15:51)
     1: Nom du fichier : scalper/config/config.yaml
     2: Rôle : contient TOUS les paramètres généraux versionnés. AUCUN secret ici.
     3: Le fichier .env (au parent de notebooks/scalp, ex: /notebooks/.env) ne doit contenir QUE les secrets (clés API, tokens). Ce .env est chargé automatiquement au boot par sitecustomize.py.
     4: 
     5: 1) Secrets (dans /notebooks/.env)
     6: - BITGET_ACCESS_KEY        (aliases: BITGET_API_KEY, BITGET_KEY)
     7: - BITGET_SECRET_KEY        (aliases: BITGET_API_SECRET, BITGET_SECRET)
     8: - BITGET_PASSPHRASE        (aliases: BITGET_API_PASSPHRASE, BITGET_PASSWORD, BITGET_API_PASSWORD)
     9: - TELEGRAM_BOT_TOKEN       (aliases: TELEGRAM_TOKEN, TG_TOKEN)
    10: - TELEGRAM_CHAT_ID         (aliases: TG_CHAT_ID, TELEGRAM_TO, CHAT_ID)
    11: 
    12: Exemple minimal .env :
    13: BITGET_ACCESS_KEY=__A_REMPLIR__
    14: BITGET_SECRET_KEY=__A_REMPLIR__
    15: BITGET_PASSPHRASE=__A_REMPLIR__
    16: TELEGRAM_BOT_TOKEN=
    17: TELEGRAM_CHAT_ID=
    18: 
    19: 2) Paramètres généraux (dans scalper/config/config.yaml)
    20: Bloc runtime:
    21: - data_dir         (chemin, défaut: /notebooks/data)
    22: - log_dir          (chemin, défaut: /notebooks/scalp/logs)
    23: - paper_trade      (bool, défaut: true)
    24: - allowed_symbols  (liste, défaut: [])
    25: - refresh_secs     (int, défaut: 5)
    26: 
    27: Bloc strategy:
    28: - live_timeframe   (str, ex: 1m)
    29: - ema_fast         (int, défaut: 20)
    30: - ema_slow         (int, défaut: 50)
    31: - macd_fast        (int, défaut: 12)
    32: - macd_slow        (int, défaut: 26)
    33: - macd_signal      (int, défaut: 9)
    34: - ema_trend_period (int, défaut: 100)
    35: 
    36: Bloc risk:
    37: - risk_pct_equity     (float, défaut: 0.02)
    38: - leverage            (int, défaut: 5)
    39: - stop_loss_pct       (float, défaut: 0.01)
    40: - take_profit_pct     (float, défaut: 0.02)
    41: - atr_period          (int, défaut: 14)
    42: - trail_atr_mult      (float, défaut: 2.0)
    43: - scale_in_atr_mult   (float, défaut: 0.5)
    44: - progress_min        (int, défaut: 15)
    45: - timeout_min         (int, défaut: 30)
    46: - max_daily_loss_pct  (float, défaut: 0.05)
    47: - max_daily_profit_pct(float, défaut: 0.10)
    48: - max_positions       (int, défaut: 3)
    49: 
    50: Exemple complet config.yaml :
    51: runtime:
    52:   data_dir: /notebooks/data
    53:   log_dir: /notebooks/scalp/logs
    54:   paper_trade: true
    55:   allowed_symbols: []
    56:   refresh_secs: 5
    57: strategy:
    58:   live_timeframe: 1m
    59:   ema_fast: 20
    60:   ema_slow: 50
    61:   macd_fast: 12
    62:   macd_slow: 26
    63:   macd_signal: 9
    64:   ema_trend_period: 100
    65: risk:
    66:   risk_pct_equity: 0.02
    67:   leverage: 5
    68:   stop_loss_pct: 0.01
    69:   take_profit_pct: 0.02
    70:   atr_period: 14
    71:   trail_atr_mult: 2.0
    72:   scale_in_atr_mult: 0.5
    73:   progress_min: 15
    74:   timeout_min: 30
    75:   max_daily_loss_pct: 0.05
    76:   max_daily_profit_pct: 0.10
    77:   max_positions: 3
    78: 
    79: 3) Ordre de priorité et validation
    80: - .env : secrets uniquement, alias normalisés au boot.
    81: - config.yaml : tous les paramètres généraux.
    82: - Au démarrage (bot.py -> import automatique sitecustomize.py), pré-flight vérifie:
    83:   * secrets requis : BITGET_ACCESS_KEY, BITGET_SECRET_KEY
    84:   * paramètres minimaux : strategy.live_timeframe, runtime.data_dir
    85:   Si OK, écrit /notebooks/.scalper/READY.json (green-flag) et le bot démarre. Sinon, il affiche ce qui manque et s’arrête.
    86: 
    87: 4) Où ça vit dans le repo
    88: - .env : parent de notebooks/scalp (déjà géré par le code).
    89: - config.yaml : scalper/config/config.yaml (versionné).
    90: - READY.json : /notebooks/.scalper/READY.json
    91: 
    92: 5) Bonnes pratiques
    93: - Ne jamais versionner .env.
    94: - Toujours versionner config.yaml.
    95: - Modifier config.yaml pour faire évoluer les réglages.
    96: - Les listes de paires peuvent être mises dans allowed_symbols.
    97: FIN DE FICHIER

## init.py (last modified: 2025-08-24 10:15:51)
     1: #!/usr/bin/env python3
     2: """Install all project dependencies.
     3: 
     4: Run this script once to install every ``requirements*.txt`` file found in the
     5: repository as well as the packages needed for the test suite.  All subsequent
     6: invocations of the bot or its submodules will then share the same Python
     7: environment with the required dependencies available.
     8: """
     9: 
    10: from __future__ import annotations
    11: 
    12: import subprocess
    13: import sys
    14: from pathlib import Path
    15: 
    16: 
    17: def install_packages(*args: str) -> None:
    18:     """Install packages using pip for the current Python interpreter."""
    19:     cmd = [sys.executable, "-m", "pip", "install", *args]
    20:     subprocess.check_call(cmd)
    21: 
    22: 
    23: def main() -> None:
    24:     repo_root = Path(__file__).resolve().parent
    25: 
    26:     # Install from any requirements*.txt file across the repository so that
    27:     # sub-packages with their own dependency lists are also covered.
    28:     for req in sorted(repo_root.rglob("requirements*.txt")):
    29:         install_packages("-r", str(req))
    30: 
    31:     # Ensure test dependencies are available
    32:     install_packages("pytest")
    33: 
    34: 
    35: if __name__ == "__main__":
    36:     main()


## pytest.ini (last modified: 2025-08-24 10:15:51)
     1: [pytest]
     2: addopts = -q


## requirements-dev.txt (last modified: 2025-08-24 10:15:51)
     1: pytest


## requirements.txt (last modified: 2025-08-24 10:15:51)
     1: requests
     2: python-dotenv
     3: pydantic==1.10.15 ; python_version < "3.11"
     4: 
     5: # pydantic v1 déjà pin si environnement ancien
     6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)


## scalper/VERSION (last modified: 2025-08-24 10:15:51)
     1: 0.3.0
     2: 


## scalper/__init__.py (last modified: 2025-08-24 10:15:51)
     1: # Rend le dossier 'scalper' importable comme package.
     2: __all__ = ["live", "signals", "core"]

## scalper/adapters/__init__.py (last modified: 2025-08-24 10:15:51)


## scalper/adapters/bitget.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/adapters/bitget.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional
     4: import inspect, os
     5: import requests
     6: 
     7: # Client bas-niveau fourni par le repo
     8: from scalper.bitget_client import BitgetFuturesClient as _Base
     9: 
    10: 
    11: def _to_float(x, default: float = 0.0) -> float:
    12:     try:
    13:         return float(x)
    14:     except Exception:
    15:         return default
    16: 
    17: 
    18: def _select_base_url() -> str:
    19:     env = os.environ.get("BITGET_BASE_URL")
    20:     if env:
    21:         return env
    22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
    23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
    24: 
    25: 
    26: class BitgetFuturesClient(_Base):
    27:     """
    28:     Adaptateur Bitget:
    29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
    30:       - Normalisations robustes: assets, ticker(s), positions, fills
    31:     """
    32: 
    33:     # --------------------- INIT dynamique ---------------------
    34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
    35:         """
    36:         Accepte indifféremment:
    37:           api_key/apiKey/access_key/accessKey/key
    38:           api_secret/apiSecret/secret/secret_key/secretKey
    39:           passphrase/password/api_passphrase/apiPassphrase
    40:           base_url/baseUrl/host/endpoint (ou auto)
    41:         On n'envoie au client de base que les noms présents dans sa signature.
    42:         """
    43:         user_kwargs = dict(kwargs)
    44: 
    45:         # Collecte des valeurs possibles (tous alias)
    46:         incoming_key = (
    47:             user_kwargs.pop("api_key", None)
    48:             or user_kwargs.pop("apiKey", None)
    49:             or user_kwargs.pop("access_key", None)
    50:             or user_kwargs.pop("accessKey", None)
    51:             or user_kwargs.pop("key", None)
    52:             or user_kwargs.pop("API_KEY", None)
    53:         )
    54:         incoming_secret = (
    55:             user_kwargs.pop("api_secret", None)
    56:             or user_kwargs.pop("apiSecret", None)
    57:             or user_kwargs.pop("secret_key", None)
    58:             or user_kwargs.pop("secretKey", None)
    59:             or user_kwargs.pop("secret", None)
    60:             or user_kwargs.pop("API_SECRET", None)
    61:         )
    62:         incoming_pass = (
    63:             user_kwargs.pop("passphrase", None)
    64:             or user_kwargs.pop("password", None)
    65:             or user_kwargs.pop("api_passphrase", None)
    66:             or user_kwargs.pop("apiPassphrase", None)
    67:         )
    68:         incoming_base = (
    69:             user_kwargs.pop("base_url", None)
    70:             or user_kwargs.pop("baseUrl", None)
    71:             or user_kwargs.pop("host", None)
    72:             or user_kwargs.pop("endpoint", None)
    73:             or _select_base_url()
    74:         )
    75: 
    76:         # Signature réelle du client bas-niveau
    77:         sig = inspect.signature(_Base.__init__)
    78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
    79: 
    80:         def pick_name(cands: List[str]) -> Optional[str]:
    81:             for c in cands:
    82:                 if c in param_names:
    83:                     return c
    84:             return None
    85: 
    86:         # Noms réellement supportés
    87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
    88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
    89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
    90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
    91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
    92: 
    93:         # Construire kwargs à transmettre (une seule fois par nom)
    94:         base_kwargs: Dict[str, Any] = {}
    95:         if key_name and incoming_key is not None:
    96:             base_kwargs[key_name] = incoming_key
    97:         if sec_name and incoming_secret is not None:
    98:             base_kwargs[sec_name] = incoming_secret
    99:         if pas_name and incoming_pass is not None:
   100:             base_kwargs[pas_name] = incoming_pass
   101:         if base_name:
   102:             base_kwargs[base_name] = incoming_base
   103:         if req_mod_name:
   104:             base_kwargs[req_mod_name] = requests
   105: 
   106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
   107:         # qui n'a pas été défini ci-dessus, on le relaie.
   108:         for k, v in list(user_kwargs.items()):
   109:             if k in param_names and k not in base_kwargs:
   110:                 base_kwargs[k] = v
   111: 
   112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
   113:         super().__init__(**base_kwargs)
   114: 
   115:     # --------------------- COMPTES / ASSETS ---------------------
   116:     def get_assets(self) -> Dict[str, Any]:
   117:         raw = super().get_assets()
   118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
   119:         norm: List[Dict[str, Any]] = []
   120:         for a in data:
   121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
   122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
   123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
   124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
   125:         return {"success": True, "data": norm}
   126: 
   127:     # ------------------------ TICKER(S) -------------------------
   128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   129:         """
   130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
   131:         Tolère top-level dict/list et items dict/list.
   132:         """
   133:         try:
   134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
   135:         except Exception as e:
   136:             return {"success": False, "error": repr(e), "data": []}
   137: 
   138:         items: List[Any] = []
   139:         if isinstance(raw, dict):
   140:             d = raw.get("data")
   141:             if symbol and isinstance(d, dict):
   142:                 items = [d]
   143:             else:
   144:                 items = d or raw.get("result") or raw.get("tickers") or []
   145:         elif isinstance(raw, (list, tuple)):
   146:             items = list(raw)
   147: 
   148:         norm: List[Dict[str, Any]] = []
   149:         for t in items:
   150:             if isinstance(t, dict):
   151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
   152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
   153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
   154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
   155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
   156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
   157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
   158:                 norm.append({
   159:                     "symbol": s,
   160:                     "lastPrice": _to_float(last_),
   161:                     "bidPrice": _to_float(bid_),
   162:                     "askPrice": _to_float(ask_),
   163:                     "volume": volume
   164:                 })
   165:             else:
   166:                 seq = list(t)
   167:                 if len(seq) >= 5:
   168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
   169:                     if first_ts:
   170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
   171:                     else:
   172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
   173:                 else:
   174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
   175:                 s = (symbol or "").replace("_", "")
   176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
   177: 
   178:         return {"success": True, "data": norm}
   179: 
   180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
   181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
   183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
   184:         out: List[Dict[str, Any]] = []
   185:         for p in items:
   186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
   187:             if symbol and s != symbol:
   188:                 continue
   189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
   190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
   191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
   192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
   193:         return {"success": True, "data": out}
   194: 
   195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
   196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
   197:         items = raw.get("data") or raw.get("result") or []
   198:         out: List[Dict[str, Any]] = []
   199:         for f in items[:limit]:
   200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
   201:             if s != symbol:
   202:                 continue
   203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
   204:                 continue
   205:             out.append({
   206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
   207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
   208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
   209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
   210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
   211:                 "ts": int(f.get("ts", f.get("time", 0))),
   212:             })
   213:         return {"success": True, "data": out}
   214: 
   215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
   217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
   218:         return {"success": ok, "data": {"orderId": order_id}}

## scalper/adapters/bitget_fetch.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/adapters/bitget_fetch.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import inspect
     6: import os
     7: from typing import Any, Optional
     8: 
     9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    10: 
    11: def _log(msg: str) -> None:
    12:     if BT_DEBUG:
    13:         print(f"[bt.debug] {msg}", flush=True)
    14: 
    15: _TF_TO_SECS = {
    16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    17:     "1h": 3600, "4h": 14400, "1d": 86400,
    18: }
    19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
    20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
    22: }
    23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
    24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
    26: }
    27: 
    28: def _await_if_needed(val: Any) -> Any:
    29:     if inspect.isawaitable(val):
    30:         try:
    31:             asyncio.get_running_loop()
    32:         except RuntimeError:
    33:             return asyncio.run(val)
    34:         else:
    35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
    36:             return fut.result()
    37:     return val
    38: 
    39: class BitgetFetchAdapter:
    40:     """
    41:     Adaptateur qui fournit une méthode CCXT-like:
    42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
    43:     au-dessus d'un client Bitget existant (sync ou async).
    44:     """
    45:     def __init__(self, client: Any, *, market_hint: str | None = None):
    46:         self.client = client
    47:         self.market_hint = (market_hint or "").lower() or None
    48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
    49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
    50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
    51: 
    52:     @staticmethod
    53:     def _possible_methods(client: Any) -> list[str]:
    54:         names = dir(client)
    55:         base = [
    56:             "fetch_ohlcv",
    57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
    58:             "klines", "get_klines", "kline",
    59:             "mix_get_candles", "mix_candles",
    60:             "spot_get_candles", "spot_candles",
    61:             "market_candles", "public_candles",
    62:         ]
    63:         # + heuristique: tout ce qui contient candle/kline
    64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
    65:         out = []
    66:         for n in base + extra:
    67:             if n in names and callable(getattr(client, n)) and n not in out:
    68:                 out.append(n)
    69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
    70:         return out
    71: 
    72:     @staticmethod
    73:     def _sym_variants(sym: str) -> list[str]:
    74:         s = sym.upper()
    75:         out = [s]
    76:         if not s.endswith("_UMCBL"):
    77:             out.append(f"{s}_UMCBL")
    78:         if not s.endswith("_SPBL"):
    79:             out.append(f"{s}_SPBL")
    80:         _log(f"Variantes symbole testées: {out}")
    81:         return out
    82: 
    83:     @staticmethod
    84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
    85:         secs = _TF_TO_SECS.get(timeframe, 300)
    86:         mix = _TF_TO_MIX.get(timeframe, "5min")
    87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
    88:         variants = []
    89:         if market_hint == "mix":
    90:             variants.append({"granularity": mix})
    91:         if market_hint == "spot":
    92:             variants.append({"period": spot})
    93:         variants += [
    94:             {"timeframe": timeframe},
    95:             {"interval": timeframe},
    96:             {"k": secs},
    97:             {"granularity": mix},
    98:             {"period": spot},
    99:         ]
   100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
   101:         return variants
   102: 
   103:     @staticmethod
   104:     def _normalize_rows(raw: Any) -> list[list[float]]:
   105:         import pandas as pd  # local import
   106:         if raw is None:
   107:             raise ValueError("OHLCV vide")
   108:         if isinstance(raw, dict) and "data" in raw:
   109:             raw = raw["data"]
   110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
   111:             out = []
   112:             for r in raw:
   113:                 ts = int(str(r[0]))
   114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
   115:                 out.append([ts, o, h, l, c, v])
   116:             return out
   117:         if "pandas" in str(type(raw)):
   118:             df = raw
   119:             if "timestamp" in df.columns:
   120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:                 df = df.set_index("timestamp").sort_index()
   122:             df = df[["open", "high", "low", "close", "volume"]]
   123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
   124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
   125: 
   126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
   127:         methods = self._possible_methods(self.client)
   128:         if not methods:
   129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
   130: 
   131:         last_err: Exception | None = None
   132:         for mname in methods:
   133:             fn = getattr(self.client, mname)
   134:             for sym in self._sym_variants(symbol):
   135:                 for par in self._param_variants(timeframe, self.market_hint):
   136:                     kwargs = dict(par)
   137:                     kwargs.setdefault("symbol", sym)
   138:                     kwargs.setdefault("limit", limit)
   139:                     if since is not None:
   140:                         kwargs.setdefault("since", since)
   141:                     try:
   142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
   143:                         res = _await_if_needed(fn(**kwargs))
   144:                         rows = self._normalize_rows(res)
   145:                         if rows:
   146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
   147:                             first = rows[0][0]; last = rows[-1][0]
   148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
   149:                                  f"t0={first} {unit}, t1={last} {unit}")
   150:                             return rows
   151:                     except TypeError as e:
   152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
   153:                         last_err = e
   154:                     except Exception as e:
   155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
   156:                         last_err = e
   157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
   158: 
   159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
   160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
   161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
   162:         _log("exchange.fetch_ohlcv() déjà présent.")
   163:         return exchange
   164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
   165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)

## scalper/adapters/market_data.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/market_data.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: from pathlib import Path
     6: from typing import Any
     7: 
     8: import pandas as pd
     9: 
    10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    11: 
    12: def _log(msg: str) -> None:
    13:     if BT_DEBUG:
    14:         print(f"[bt.debug] {msg}", flush=True)
    15: 
    16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
    17:     root = Path(data_dir)
    18:     root.mkdir(parents=True, exist_ok=True)
    19:     tf = timeframe.replace(":", "")
    20:     return root / f"{symbol}-{tf}.csv"
    21: 
    22: def _read_csv(path: Path) -> pd.DataFrame:
    23:     _log(f"lecture CSV: {path}")
    24:     df = pd.read_csv(path)
    25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
    26:     if ts_col is None:
    27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
    28:     df = df.rename(columns={ts_col: "timestamp"})
    29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
    30:     df = df.set_index("timestamp").sort_index()
    31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    32:     return df
    33: 
    34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
    35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
    36:     if "timestamp" not in tmp.columns:
    37:         tmp = tmp.rename(columns={"index": "timestamp"})
    38:     tmp.to_csv(path, index=False)
    39:     _log(f"écrit CSV: {path} (n={len(df)})")
    40: 
    41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
    42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
    43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
    44:     # Normalisation minimaliste (liste de listes)
    45:     rows = []
    46:     for r in raw:
    47:         ts = int(r[0])
    48:         unit = "ms" if ts > 10_000_000_000 else "s"
    49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
    50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
    51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
    52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    53:     return df
    54: 
    55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
    56:     """
    57:     Loader hybride:
    58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
    59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
    60:     """
    61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
    62:         path = _csv_path(data_dir, symbol, timeframe)
    63:         if path.exists():
    64:             df = _read_csv(path)
    65:             src = "csv"
    66:         else:
    67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
    68:             _write_csv(path, df)
    69:             src = "exchange"
    70:         if start:
    71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
    72:         if end:
    73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
    74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
    75:              f"range=[{df.index.min()} .. {df.index.max()}]")
    76:         return df
    77:     return load

## scalper/backtest/__init__.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/__init__.py
     2: from .runner import (
     3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
     4:     run_multi, run_single,  # mêmes signatures async
     5:     save_results,           # no-op compat
     6: )
     7: from .cache import (
     8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
     9:     tf_to_seconds,
    10: )

## scalper/backtest/cache.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/cache.py
     2: from __future__ import annotations
     3: 
     4: import csv
     5: import json
     6: import os
     7: import time
     8: from dataclasses import dataclass
     9: from pathlib import Path
    10: from typing import Dict, List, Tuple, Iterable, Optional
    11: 
    12: # ---------------- Timeframe utils ----------------
    13: 
    14: _TF_SECONDS = {
    15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
    17:     "1d": 86400, "3d": 259200, "1w": 604800,
    18: }
    19: 
    20: def tf_to_seconds(tf: str) -> int:
    21:     tf = tf.strip().lower()
    22:     if tf not in _TF_SECONDS:
    23:         raise ValueError(f"Timeframe inconnu: {tf}")
    24:     return _TF_SECONDS[tf]
    25: 
    26: # ---------------- Fraîcheur cible par TF ----------------
    27: 
    28: _DEFAULT_MAX_AGE = {
    29:     # règle empirique (peut être surchargée par ENV)
    30:     "1m": 2 * 3600,        # 2h
    31:     "3m": 4 * 3600,        # 4h
    32:     "5m": 12 * 3600,       # 12h
    33:     "15m": 24 * 3600,      # 24h
    34:     "30m": 36 * 3600,      # 36h
    35:     "1h": 3 * 86400,       # 3 jours
    36:     "2h": 5 * 86400,       # 5 jours
    37:     "4h": 10 * 86400,      # 10 jours
    38:     "6h": 15 * 86400,      # 15 jours
    39:     "12h": 20 * 86400,     # 20 jours
    40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
    41:     "3d": 10 * 86400,
    42:     "1w": 30 * 86400,
    43: }
    44: 
    45: def max_age_for_tf(tf: str) -> int:
    46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
    47:     tf = tf.lower()
    48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
    49:     if env_key in os.environ:
    50:         try:
    51:             return int(os.environ[env_key])
    52:         except Exception:
    53:             pass
    54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
    55: 
    56: # ---------------- CSV I/O ----------------
    57: 
    58: def data_dir() -> Path:
    59:     d = Path(os.getenv("DATA_DIR", "data"))
    60:     d.mkdir(parents=True, exist_ok=True)
    61:     return d
    62: 
    63: def csv_path(symbol: str, tf: str) -> Path:
    64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
    65: 
    66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
    67:     out: List[List[float]] = []
    68:     if not path.exists():
    69:         return out
    70:     with path.open("r", newline="") as f:
    71:         r = csv.reader(f)
    72:         header = next(r, None)
    73:         for row in r:
    74:             # columns: timestamp,open,high,low,close,volume
    75:             try:
    76:                 ts, o, h, l, c, v = row[:6]
    77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
    78:             except Exception:
    79:                 continue
    80:     return out
    81: 
    82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
    83:     new_file = not path.exists()
    84:     with path.open("w", newline="") as f:
    85:         w = csv.writer(f)
    86:         w.writerow(["timestamp","open","high","low","close","volume"])
    87:         for r in rows:
    88:             w.writerow(r)
    89: 
    90: # ---------------- Validation / Chargement / Fetch ----------------
    91: 
    92: @dataclass
    93: class CacheInfo:
    94:     symbol: str
    95:     tf: str
    96:     path: Path
    97:     exists: bool
    98:     fresh: bool
    99:     last_ts: Optional[int] = None
   100:     rows: int = 0
   101: 
   102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
   103:     if not last_ts:
   104:         return False
   105:     age = int(time.time()) - int(last_ts / 1000)
   106:     return age <= max_age_for_tf(tf)
   107: 
   108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
   109:     p = csv_path(symbol, tf)
   110:     if not p.exists():
   111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
   112:     rows = read_csv_ohlcv(p)
   113:     last_ts = rows[-1][0] if rows else None
   114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
   115: 
   116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
   117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
   118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
   119: 
   120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
   121:     info = inspect_csv(symbol, tf)
   122:     if info.exists and info.fresh:
   123:         data = read_csv_ohlcv(info.path)
   124:         return info, data
   125: 
   126:     # fetch & persist
   127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
   128:     if data:
   129:         write_csv_ohlcv(info.path, data)
   130:         info = inspect_csv(symbol, tf)  # refresh stats
   131:     return info, data
   132: 
   133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
   134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
   135:     out: Dict[str, List[List[float]]] = {}
   136:     for s in symbols:
   137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
   138:         out[s] = rows
   139:     return out
   140: 
   141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
   142:     report = []
   143:     for s in symbols:
   144:         info = inspect_csv(s, tf)
   145:         report.append({
   146:             "symbol": s,
   147:             "tf": tf,
   148:             "path": str(info.path),
   149:             "exists": info.exists,
   150:             "fresh": info.fresh,
   151:             "last_ts": info.last_ts,
   152:             "rows": info.rows,
   153:             "max_age": max_age_for_tf(tf),
   154:         })
   155:     out_path.parent.mkdir(parents=True, exist_ok=True)
   156:     out_path.write_text(json.dumps(report, indent=2))

## scalper/backtest/cli.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: import argparse
     4: from scalper.backtest.runner import run_multi, csv_loader_factory
     5: 
     6: def create_parser() -> argparse.ArgumentParser:
     7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
     8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
     9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
    10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
    11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
    12:     p.add_argument("--cash", type=float, default=10_000.0)
    13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
    14:     p.add_argument("--slippage-bps", type=float, default=1.5)
    15:     return p
    16: 
    17: def main(argv: list[str] | None = None) -> int:
    18:     p = create_parser()
    19:     a = p.parse_args(argv)
    20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
    21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
    22:     loader = csv_loader_factory(a.data_dir)
    23:     run_multi(
    24:         symbols=symbols,
    25:         timeframes=tfs,
    26:         loader=loader,
    27:         out_dir=a.out_dir,
    28:         initial_cash=a.cash,
    29:         risk_pct=a.risk,
    30:         slippage_bps=a.slippage_bps,
    31:     )
    32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
    33:     return 0
    34: 
    35: if __name__ == "__main__":
    36:     raise SystemExit(main())

## scalper/backtest/engine.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/engine.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Tuple
     4: import csv
     5: import os
     6: from dataclasses import dataclass
     7: from scalper.strategy.factory import resolve_signal_fn
     8: from scalper.core.signal import Signal
     9: from scalper.backtest.position_sizing import position_size_from_signal, fees_cost
    10: 
    11: @dataclass
    12: class Trade:
    13:     symbol: str
    14:     timeframe: str
    15:     side: str
    16:     entry_ts: int
    17:     exit_ts: int
    18:     entry: float
    19:     exit: float
    20:     qty: float
    21:     pnl: float
    22:     pnl_after_fees: float
    23:     reasons: str
    24: 
    25: def _read_csv(path: str) -> Dict[str, List[float]]:
    26:     cols = ("timestamp","open","high","low","close","volume")
    27:     out = {k: [] for k in cols}
    28:     with open(path, "r", newline="", encoding="utf-8") as f:
    29:         r = csv.DictReader(f)
    30:         for row in r:
    31:             for k in cols:
    32:                 out[k].append(float(row[k]))
    33:     return out
    34: 
    35: def _slice(d: Dict[str, List[float]], end_idx: int) -> Dict[str, List[float]]:
    36:     return {k: v[: end_idx + 1] for k, v in d.items()}
    37: 
    38: class BacktestEngine:
    39:     def __init__(
    40:         self,
    41:         *,
    42:         symbol: str,
    43:         timeframe: str,
    44:         data: Dict[str, List[float]],
    45:         equity_start: float = 1_000.0,
    46:         risk_pct: float = 0.01,
    47:         fees_bps: float = 6.0,
    48:         warmup: int = 230,
    49:         strategies_cfg: Dict[str, Any],
    50:         data_1h: Optional[Dict[str, List[float]]] = None,
    51:     ):
    52:         self.symbol = symbol.upper()
    53:         self.tf = timeframe
    54:         self.data = data
    55:         self.data_1h = data_1h
    56:         self.equity = float(equity_start)
    57:         self.start_equity = float(equity_start)
    58:         self.risk_pct = float(risk_pct)
    59:         self.fees_bps = float(fees_bps)
    60:         self.warmup = int(warmup)
    61:         self.cfg = strategies_cfg
    62:         self.trades: List[Trade] = []
    63:         self.signals_rows: List[Dict[str, Any]] = []
    64:         self.signal_fn = resolve_signal_fn(self.symbol, self.tf, self.cfg)
    65: 
    66:     def run(self) -> Tuple[float, List[Trade]]:
    67:         n = len(self.data["close"])
    68:         pos_open: Optional[Signal] = None
    69:         pos_qty: float = 0.0
    70:         entry_idx: int = -1
    71: 
    72:         for i in range(self.warmup, n):
    73:             window = _slice(self.data, i)
    74:             window_1h = _slice(self.data_1h, self._map_1h_index(i)) if self.data_1h else None
    75: 
    76:             sig = self.signal_fn(
    77:                 symbol=self.symbol, timeframe=self.tf, ohlcv=window,
    78:                 equity=self.equity, risk_pct=self.risk_pct, ohlcv_1h=window_1h,
    79:             )
    80:             if sig:
    81:                 self.signals_rows.append(sig.as_dict())
    82: 
    83:             if pos_open is None and sig is not None:
    84:                 qty = position_size_from_signal(self.equity, sig, self.risk_pct * max(0.25, sig.quality))
    85:                 if qty <= 0:
    86:                     continue
    87:                 pos_open, pos_qty, entry_idx = sig, qty, i
    88:                 continue
    89: 
    90:             if pos_open is not None:
    91:                 hi = self.data["high"][i]
    92:                 lo = self.data["low"][i]
    93:                 exit_price: Optional[float] = None
    94:                 tp1 = pos_open.tp1 or pos_open.entry
    95:                 tp2 = pos_open.tp2 or pos_open.entry
    96:                 half_closed = False
    97:                 be = pos_open.entry
    98: 
    99:                 if pos_open.side == "long":
   100:                     if lo <= pos_open.sl:
   101:                         exit_price = pos_open.sl
   102:                     elif hi >= tp1:
   103:                         pnl_half = (tp1 - pos_open.entry) * (pos_qty * 0.5)
   104:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
   105:                         self.equity += pnl_half - fees
   106:                         pos_qty *= 0.5
   107:                         half_closed = True
   108:                         pos_open.sl = be
   109:                     if hi >= tp2:
   110:                         exit_price = tp2
   111:                 else:
   112:                     if hi >= pos_open.sl:
   113:                         exit_price = pos_open.sl
   114:                     elif lo <= tp1:
   115:                         pnl_half = (pos_open.entry - tp1) * (pos_qty * 0.5)
   116:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
   117:                         self.equity += pnl_half - fees
   118:                         pos_qty *= 0.5
   119:                         half_closed = True
   120:                         pos_open.sl = be
   121:                     if lo <= tp2:
   122:                         exit_price = tp2
   123: 
   124:                 if exit_price is None and half_closed:
   125:                     continue
   126: 
   127:                 if exit_price is not None:
   128:                     pnl = (exit_price - pos_open.entry) * pos_qty if pos_open.side == "long" else (pos_open.entry - exit_price) * pos_qty
   129:                     fees = fees_cost(exit_price * pos_qty, self.fees_bps)
   130:                     pnl_after = pnl - fees
   131:                     self.equity += pnl_after
   132: 
   133:                     tr = Trade(
   134:                         symbol=self.symbol, timeframe=self.tf, side=pos_open.side,
   135:                         entry_ts=int(self.data["timestamp"][entry_idx]), exit_ts=int(self.data["timestamp"][i]),
   136:                         entry=pos_open.entry, exit=exit_price, qty=pos_qty,
   137:                         pnl=pnl, pnl_after_fees=pnl_after, reasons="|".join(pos_open.reasons),
   138:                     )
   139:                     self.trades.append(tr)
   140:                     pos_open, pos_qty, entry_idx = None, 0.0, -1
   141: 
   142:         return self.equity, self.trades
   143: 
   144:     def _map_1h_index(self, i_main: int) -> int:
   145:         if not self.data_1h:
   146:             return 0
   147:         ts = self.data["timestamp"][i_main]
   148:         arr = self.data_1h["timestamp"]
   149:         j = 0
   150:         while j + 1 < len(arr) and arr[j + 1] <= ts:
   151:             j += 1
   152:         return j
   153: 
   154:     # --- E/S helpers ---
   155:     @staticmethod
   156:     def load_csv(path: str) -> Dict[str, List[float]]:
   157:         if not os.path.isfile(path):
   158:             raise FileNotFoundError(f"CSV OHLCV introuvable: {path}")
   159:         return _read_csv(path)
   160: 
   161:     def save_results(self, out_dir: str = "backtest_out") -> None:
   162:         os.makedirs(out_dir, exist_ok=True)
   163:         if self.signals_rows:
   164:             sig_path = os.path.join(out_dir, f"signals_{self.symbol}_{self.tf}.csv")
   165:             keys = sorted(self.signals_rows[0].keys())
   166:             with open(sig_path, "w", newline="", encoding="utf-8") as f:
   167:                 import csv
   168:                 w = csv.DictWriter(f, fieldnames=keys)
   169:                 w.writeheader()
   170:                 for row in self.signals_rows:
   171:                     w.writerow(row)
   172:         if self.trades:
   173:             tr_path = os.path.join(out_dir, f"trades_{self.symbol}_{self.tf}.csv")
   174:             with open(tr_path, "w", newline="", encoding="utf-8") as f:
   175:                 import csv
   176:                 w = csv.writer(f)
   177:                 w.writerow(["symbol","timeframe","side","entry_ts","exit_ts","entry","exit","qty","pnl","pnl_after_fees","reasons"])
   178:                 for t in self.trades:
   179:                     w.writerow([t.symbol,t.timeframe,t.side,t.entry_ts,t.exit_ts,t.entry,t.exit,t.qty,t.pnl,t.pnl_after_fees,t.reasons])
   180: 
   181:     def summary(self) -> Dict[str, float]:
   182:         eq = self.equity
   183:         ret = (eq / self.start_equity - 1.0) * 100.0
   184:         n = len(self.trades)
   185:         wins = sum(1 for t in self.trades if t.pnl_after_fees > 0)
   186:         winrate = (wins / n * 100.0) if n else 0.0
   187:         return {"equity_end": eq, "return_pct": ret, "trades": float(n), "winrate_pct": winrate}

## scalper/backtest/grid_search.py (last modified: 2025-08-24 10:15:51)
     1: """Grid-search express module to evaluate hyperparameter combinations.
     2: 
     3: This module builds combinations of strategy and engine parameters, runs the
     4: existing multi symbol backtester for each combination, collects key metrics and
     5: selects the best configuration according to:
     6: 
     7: 1. Profit factor (descending)
     8: 2. Maximum drawdown percentage (ascending)
     9: 3. Net PnL in USDT (descending)
    10: 4. Number of trades (ascending)
    11: 
    12: Results are written under ``result/grid`` by default and a short summary is
    13: printed to the console.
    14: """
    15: from __future__ import annotations
    16: 
    17: from dataclasses import dataclass
    18: import csv
    19: import json
    20: import os
    21: import random
    22: from itertools import product
    23: from typing import Any, Callable, Dict, Iterable, List, Sequence
    24: 
    25: # ---------------------------------------------------------------------------
    26: # Utilities
    27: # ---------------------------------------------------------------------------
    28: 
    29: 
    30: def parse_hours(hours: str) -> List[int]:
    31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
    32: 
    33:     Each comma separated element can either be a single hour (``"8"``) or a
    34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
    35:     """
    36: 
    37:     if not hours:
    38:         return []
    39:     result: List[int] = []
    40:     for part in hours.split(","):
    41:         part = part.strip()
    42:         if not part:
    43:             continue
    44:         if "-" in part:
    45:             start_s, end_s = part.split("-", 1)
    46:             start, end = int(start_s), int(end_s)
    47:             result.extend(range(start, end + 1))
    48:         else:
    49:             result.append(int(part))
    50:     return sorted(set(result))
    51: 
    52: 
    53: # Order of parameters used throughout the module and in CSV output
    54: PARAM_KEYS = [
    55:     "timeframe",
    56:     "score_min",
    57:     "atr_min_ratio",
    58:     "rr_min",
    59:     "risk_pct",
    60:     "slippage_bps",
    61:     "fee_rate",
    62:     "cooldown_secs",
    63:     "hours",
    64: ]
    65: 
    66: # Default values used if a parameter is not provided in the grid
    67: DEFAULTS = {
    68:     "score_min": 55,
    69:     "atr_min_ratio": 0.002,
    70:     "rr_min": 1.2,
    71:     "risk_pct": 0.01,
    72:     "slippage_bps": 2,
    73:     "fee_rate": 0.001,
    74:     "cooldown_secs": 300,
    75:     "hours": "7-11,13-17",
    76: }
    77: 
    78: 
    79: @dataclass
    80: class GridResult:
    81:     params: Dict[str, Any]
    82:     metrics: Dict[str, float]
    83: 
    84: 
    85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
    86:     if isinstance(val, (list, tuple, set)):
    87:         return list(val)
    88:     return [val]
    89: 
    90: 
    91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
    92:     """Return a list of parameter combinations.
    93: 
    94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
    95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
    96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
    97:     variety of timeframes and ``atr_min_ratio`` values.
    98:     """
    99: 
   100:     lists: Dict[str, List[Any]] = {}
   101:     for key in PARAM_KEYS:
   102:         if key == "timeframe":
   103:             # timeframe must be explicitly provided; default empty -> "1m"
   104:             vals = param_lists.get(key) or ["1m"]
   105:         else:
   106:             vals = param_lists.get(key)
   107:             if not vals:
   108:                 default = DEFAULTS[key]
   109:                 vals = [default]
   110:         lists[key] = _ensure_list(vals)
   111: 
   112:     combos: List[Dict[str, Any]] = [
   113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
   114:     ]
   115: 
   116:     # Uniform sampling if exceeding grid_max
   117:     if len(combos) > grid_max:
   118:         step = len(combos) / float(grid_max)
   119:         sampled = []
   120:         for i in range(grid_max):
   121:             idx = int(round(i * step))
   122:             if idx >= len(combos):
   123:                 idx = len(combos) - 1
   124:             sampled.append(combos[idx])
   125:         # ensure each timeframe appears at least once
   126:         wanted_tfs = set(lists["timeframe"])
   127:         present_tfs = {c["timeframe"] for c in sampled}
   128:         missing = list(wanted_tfs - present_tfs)
   129:         if missing:
   130:             for tf in missing:
   131:                 for c in combos:
   132:                     if c["timeframe"] == tf and c not in sampled:
   133:                         sampled.append(c)
   134:                         break
   135:             sampled = sampled[:grid_max]
   136:         combos = sampled
   137:     return combos
   138: 
   139: 
   140: # ---------------------------------------------------------------------------
   141: # Core runner
   142: # ---------------------------------------------------------------------------
   143: 
   144: 
   145: def run_grid_search(
   146:     *,
   147:     symbols: Sequence[str],
   148:     exchange: str,
   149:     base_params: Dict[str, Any],
   150:     param_lists: Dict[str, Sequence[Any]],
   151:     grid_max: int = 12,
   152:     csv_dir: str | None = None,
   153:     initial_equity: float = 1000.0,
   154:     leverage: float = 1.0,
   155:     paper_constraints: bool = True,
   156:     seed: int | None = None,
   157:     out_dir: str = "./result/grid",
   158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
   159:     run_func: Callable[..., Any] | None = None,
   160: ) -> List[GridResult]:
   161:     """Execute grid search across parameter combinations.
   162: 
   163:     ``base_params`` provides default single values for parameters. ``param_lists``
   164:     contains the grid specifications from CLI (already parsed into sequences).
   165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
   166:     """
   167: 
   168:     if seed is not None:
   169:         random.seed(seed)
   170: 
   171:     if run_func is None:  # avoid circular import at module load
   172:         from .run_multi import run_backtest_multi  # late import
   173: 
   174:         run_func = run_backtest_multi
   175: 
   176:     # merge lists with defaults
   177:     full_lists: Dict[str, Sequence[Any]] = {}
   178:     for k in PARAM_KEYS:
   179:         if k == "timeframe":
   180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
   181:         else:
   182:             if param_lists.get(k) is not None:
   183:                 full_lists[k] = param_lists[k]
   184:             else:
   185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
   186: 
   187:     combos = build_param_grid(full_lists, grid_max)
   188: 
   189:     results: List[GridResult] = []
   190:     os.makedirs(out_dir, exist_ok=True)
   191: 
   192:     for combo in combos:
   193:         # Build parameters for backtester
   194:         tf = combo["timeframe"]
   195:         fee = float(combo["fee_rate"])
   196:         slip = float(combo["slippage_bps"])
   197:         risk = float(combo["risk_pct"])
   198: 
   199:         summary, _trades = run_func(
   200:             symbols=list(symbols),
   201:             exchange=exchange,
   202:             timeframe=tf,
   203:             csv_dir=csv_dir,
   204:             fee_rate=fee,
   205:             slippage_bps=slip,
   206:             risk_pct=risk,
   207:             initial_equity=initial_equity,
   208:             leverage=leverage,
   209:             paper_constraints=paper_constraints,
   210:             seed=seed,
   211:             out_dir=os.path.join(out_dir, "tmp"),
   212:             plot=False,
   213:             dry_run=True,
   214:         )
   215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
   216:         metrics = {
   217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
   218:             "profit_factor": float(total.get("profit_factor", 0.0)),
   219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
   220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
   221:             "trades": float(total.get("trades", 0.0)),
   222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
   223:         }
   224:         results.append(GridResult(params=combo, metrics=metrics))
   225: 
   226:     # sort results
   227:     results.sort(
   228:         key=lambda r: (
   229:             -r.metrics["profit_factor"],
   230:             r.metrics["max_dd_pct"],
   231:             -r.metrics["pnl_usdt"],
   232:             r.metrics["trades"],
   233:         )
   234:     )
   235: 
   236:     # console output -------------------------------------------------------
   237:     print(
   238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
   239:     )
   240:     header = (
   241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
   242:     )
   243:     print(header)
   244:     for r in results[:10]:
   245:         m = r.metrics
   246:         print(
   247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
   248:         )
   249: 
   250:     # write csv ------------------------------------------------------------
   251:     csv_cols = PARAM_KEYS + [
   252:         "pnl_usdt",
   253:         "profit_factor",
   254:         "max_dd_pct",
   255:         "winrate_pct",
   256:         "trades",
   257:         "final_equity",
   258:     ]
   259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
   260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
   261:         writer.writeheader()
   262:         for r in results:
   263:             row = {**r.params, **r.metrics}
   264:             writer.writerow(row)
   265: 
   266:     best = results[0]
   267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
   268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
   269: 
   270:     # markdown summary -----------------------------------------------------
   271:     md_path = os.path.join(out_dir, "grid_summary.md")
   272:     with open(md_path, "w", encoding="utf8") as fh:
   273:         fh.write(
   274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
   275:         )
   276:         for r in results[:10]:
   277:             m = r.metrics
   278:             fh.write(
   279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
   280:             )
   281: 
   282:     # optional scatter plot ------------------------------------------------
   283:     try:  # pragma: no cover - optional dependency
   284:         import matplotlib.pyplot as plt
   285: 
   286:         pf = [r.metrics["profit_factor"] for r in results]
   287:         dd = [r.metrics["max_dd_pct"] for r in results]
   288:         trades = [r.metrics["trades"] for r in results]
   289:         tfs = [r.params["timeframe"] for r in results]
   290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
   291:         c = [colors[tf] for tf in tfs]
   292:         plt.figure(figsize=(6, 4))
   293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
   294:         plt.xlabel("MaxDD%")
   295:         plt.ylabel("Profit Factor")
   296:         plt.title("PF vs MaxDD")
   297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
   298:         plt.close()
   299:     except Exception:  # pragma: no cover
   300:         pass
   301: 
   302:     return results
   303: 
   304: 
   305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]


## scalper/backtest/loader_csv.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/loader_csv.py
     2: from __future__ import annotations
     3: 
     4: import csv
     5: from typing import Dict, List
     6: 
     7: from scalper.services.data_cache import csv_path
     8: 
     9: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
    10: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
    11:     path = csv_path(symbol, timeframe)
    12:     rows: List[List[float]] = []
    13:     with open(path, "r") as f:
    14:         r = csv.DictReader(f)
    15:         for row in r:
    16:             rows.append([
    17:                 int(row["timestamp"]),
    18:                 float(row["open"]),
    19:                 float(row["high"]),
    20:                 float(row["low"]),
    21:                 float(row["close"]),
    22:                 float(row["volume"]),
    23:             ])
    24:     rows.sort(key=lambda x: x[0])
    25:     return rows
    26: 
    27: 
    28: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
    29:     out: Dict[str, List[List[float]]] = {}
    30:     for s in symbols:
    31:         out[s] = load_ohlcv_csv(s, timeframe)
    32:     return out

## scalper/backtest/market_data.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import time
     6: from pathlib import Path
     7: from typing import Any, Iterable, Optional, Sequence, Tuple
     8: from urllib.request import Request, urlopen
     9: from urllib.error import URLError, HTTPError
    10: 
    11: import pandas as pd
    12: 
    13: # ============================================================================
    14: # Logs & utilitaires
    15: # ============================================================================
    16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    17: def _log(msg: str) -> None:
    18:     if BT_DEBUG:
    19:         print(f"[bt.debug] {msg}", flush=True)
    20: 
    21: def _now_ms() -> int:
    22:     return int(time.time() * 1000)
    23: 
    24: def _tf_to_seconds(tf: str) -> int:
    25:     tf = tf.lower().strip()
    26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
    27:     if tf not in table:
    28:         raise ValueError(f"Timeframe non supporté: {tf}")
    29:     return table[tf]
    30: 
    31: def _parse_duration(s: str) -> int:
    32:     """
    33:     '90s','15m','2h','3d' -> secondes
    34:     """
    35:     s = s.strip().lower()
    36:     if s.endswith("s"): return int(float(s[:-1]))
    37:     if s.endswith("m"): return int(float(s[:-1])*60)
    38:     if s.endswith("h"): return int(float(s[:-1])*3600)
    39:     if s.endswith("d"): return int(float(s[:-1])*86400)
    40:     return int(float(s))  # secondes
    41: 
    42: # ============================================================================
    43: # Politique de fraîcheur (par défaut + overrides via ENV)
    44: # ============================================================================
    45: def _default_max_age_seconds(tf: str) -> int:
    46:     """
    47:     Règles par défaut (conservatrices) :
    48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
    49:       - 30m     : 1h
    50:       - 1h      : 6h
    51:       - 4h      : 24h
    52:       - 1d      : 3d
    53:     """
    54:     tf = tf.lower()
    55:     if tf in ("1m","3m","5m","15m"):
    56:         return 2 * _tf_to_seconds(tf)
    57:     if tf == "30m":
    58:         return 3600
    59:     if tf == "1h":
    60:         return 6*3600
    61:     if tf == "4h":
    62:         return 24*3600
    63:     if tf == "1d":
    64:         return 3*86400
    65:     raise ValueError(tf)
    66: 
    67: def _max_age_seconds(tf: str) -> int:
    68:     """
    69:     Overrides possibles (au choix) :
    70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
    71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
    72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
    73:     """
    74:     tfk = tf.lower().replace(":", "")
    75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
    76:     if env_spec:
    77:         return _parse_duration(env_spec)
    78:     mult = os.getenv("CSV_MAX_AGE_MULT")
    79:     if mult:
    80:         return int(float(mult) * _tf_to_seconds(tf))
    81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
    82:     if g:
    83:         return _parse_duration(g)
    84:     return _default_max_age_seconds(tf)
    85: 
    86: # ============================================================================
    87: # CSV helpers + validation
    88: # ============================================================================
    89: def _data_dir(default: str = "data") -> Path:
    90:     root = Path(os.getenv("DATA_DIR", default))
    91:     root.mkdir(parents=True, exist_ok=True)
    92:     return root
    93: 
    94: def _csv_path(symbol: str, timeframe: str) -> Path:
    95:     tf = timeframe.replace(":", "")
    96:     return _data_dir() / f"{symbol}-{tf}.csv"
    97: 
    98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
    99:     rows = list(rows)
   100:     if not rows:
   101:         raise ValueError("OHLCV vide")
   102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
   103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
   104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
   105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
   106: 
   107: def _read_csv(path: Path) -> pd.DataFrame:
   108:     df = pd.read_csv(path)
   109:     # tolère quelques variations de colonnes
   110:     cols = {c.lower(): c for c in df.columns}
   111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
   112:     if not ts_col:
   113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
   114:     rename = {ts_col: "timestamp"}
   115:     for c in ("open","high","low","close","volume"):
   116:         if c not in cols:
   117:             raise ValueError(f"Colonne manquante: {c}")
   118:         rename[cols[c]] = c
   119:     df = df.rename(columns=rename)
   120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
   122:     df = df.drop_duplicates("timestamp")
   123:     df = df.set_index("timestamp")
   124:     return df
   125: 
   126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
   127:     out = df.reset_index().rename(columns={"index": "timestamp"})
   128:     out.to_csv(path, index=False)
   129: 
   130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
   131:     """
   132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
   133:       - schéma valide
   134:       - assez de lignes
   135:       - fraîcheur < seuil selon TF
   136:     """
   137:     if not path.exists():
   138:         return False, "absent"
   139:     try:
   140:         df = _read_csv(path)
   141:     except Exception as e:
   142:         return False, f"invalid({e})"
   143:     if len(df) < min_rows:
   144:         return False, f"too_few_rows({len(df)}<{min_rows})"
   145:     # Fraîcheur
   146:     last_ts = int(df.index.max().timestamp())
   147:     age_s = int(time.time()) - last_ts
   148:     max_age = _max_age_seconds(timeframe)
   149:     if age_s > max_age:
   150:         return False, f"stale({age_s}s>{max_age}s)"
   151:     # Monotonicité (échantillon)
   152:     if not df.index.is_monotonic_increasing:
   153:         return False, "not_monotonic"
   154:     return True, "ok"
   155: 
   156: # ============================================================================
   157: # Fallback réseau (CCXT d'abord, HTTP sinon)
   158: # ============================================================================
   159: def _ensure_ccxt() -> Any | None:
   160:     try:
   161:         import ccxt  # type: ignore
   162:         return ccxt
   163:     except Exception:
   164:         return None
   165: 
   166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   167:     ccxt = _ensure_ccxt()
   168:     if not ccxt:
   169:         _log("ccxt indisponible")
   170:         return None
   171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
   172:     ex.load_markets()
   173:     base = symbol.upper()
   174:     if not base.endswith("USDT"):
   175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
   176:     coin = base[:-4]
   177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
   178:     for ccxt_sym in candidates:
   179:         try:
   180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
   181:             if rows:
   182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
   183:         except Exception as e:
   184:             _log(f"ccxt fail {ccxt_sym}: {e}")
   185:             continue
   186:     return None
   187: 
   188: # === (facultatif) HTTP Bitget v1 minimal ===
   189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
   190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
   191: 
   192: def _http_get(url: str, timeout: int = 20) -> dict | list:
   193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
   194:     with urlopen(req, timeout=timeout) as resp:
   195:         return json.loads(resp.read().decode("utf-8"))
   196: 
   197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
   198:     rows = payload.get("data") if isinstance(payload, dict) else payload
   199:     if not isinstance(rows, list):
   200:         raise ValueError(f"Réponse inattendue: {payload}")
   201:     out = []
   202:     for r in rows:
   203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
   204:         out.append([ts,o,h,l,c,v])
   205:     out.sort(key=lambda x:x[0])
   206:     return out
   207: 
   208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   209:     tf = timeframe.lower()
   210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
   211:     if not (g and p):
   212:         return None
   213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
   214:     trials = [
   215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
   216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
   217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
   218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
   219:     ]
   220:     for url in trials:
   221:         try:
   222:             payload = _http_get(url)
   223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
   224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
   225:             rows = _normalize_http_rows(payload)
   226:             if rows:
   227:                 return _rows_to_df(rows)
   228:         except Exception as e:
   229:             _log(f"HTTP fail: {url} -> {e}")
   230:             continue
   231:     return None
   232: 
   233: # ============================================================================
   234: # API publique utilisée par l’orchestrateur/backtest
   235: # ============================================================================
   236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
   237:     """
   238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
   239:     """
   240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
   241:     if df is not None:
   242:         _log(f"source=ccxt  n={len(df)}")
   243:         return df
   244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
   245:     if df is not None:
   246:         _log(f"source=http  n={len(df)}")
   247:         return df
   248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
   249: 
   250: def hybrid_loader(
   251:     data_dir: str = "data",
   252:     *,
   253:     use_cache_first: bool = True,
   254:     min_rows: int = 100,
   255:     refill_if_stale: bool = True,
   256:     network_limit: int = 1000,
   257: ):
   258:     """
   259:     Loader smart :
   260:       1) si CSV présent ET frais/valide → le renvoie
   261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
   262:       3) sinon → lève
   263:     """
   264:     os.environ.setdefault("DATA_DIR", data_dir)
   265: 
   266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
   267:         path = _csv_path(symbol, timeframe)
   268: 
   269:         if use_cache_first:
   270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
   271:             if ok:
   272:                 _log(f"CSV OK: {path}")
   273:                 df = _read_csv(path)
   274:             else:
   275:                 _log(f"CSV non utilisable ({why}): {path}")
   276:                 if not refill_if_stale:
   277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
   278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   279:                 _write_csv(path, df)
   280:         else:
   281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   282:             _write_csv(path, df)
   283: 
   284:         # Fenêtrage temporel si demandé (timestamps UTC)
   285:         if start:
   286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
   287:         if end:
   288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
   289:         return df
   290: 
   291:     return load

## scalper/backtest/metrics.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: import math
     3: from dataclasses import dataclass
     4: from typing import List, Dict
     5: 
     6: @dataclass
     7: class Trade:
     8:     ts: int
     9:     side: str
    10:     entry: float
    11:     exit: float
    12:     pnl_abs: float
    13:     pnl_pct: float
    14:     dur_min: float
    15: 
    16: def equity_to_drawdown(equity: List[float]) -> float:
    17:     peak = -1e18; maxdd = 0.0
    18:     for v in equity:
    19:         if v > peak: peak = v
    20:         dd = 0.0 if peak == 0 else (peak - v) / peak
    21:         if dd > maxdd: maxdd = dd
    22:     return maxdd
    23: 
    24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
    25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
    26:     if not returns: return 0.0
    27:     mean = sum(returns)/len(returns)
    28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
    29:     std = math.sqrt(var) if var>0 else 0.0
    30:     if std == 0: return 0.0
    31:     return (mean - rf) / std * math.sqrt(period_per_year)
    32: 
    33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
    34:     wins = [t for t in trades if t.pnl_abs > 0]
    35:     losses = [t for t in trades if t.pnl_abs < 0]
    36:     wr = len(wins)/len(trades) if trades else 0.0
    37:     gross_win = sum(t.pnl_abs for t in wins)
    38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
    39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
    40:     mdd = equity_to_drawdown(equity)
    41:     shp = sharpe(bar_returns)
    42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
    43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
    44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
    45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
    46:     return {
    47:         "trades": len(trades),
    48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
    49:         "expectancy": expectancy, "cagr": cagr, "score": score,
    50:         "equity_start": equity[0] if equity else None,
    51:         "equity_end": equity[-1] if equity else None,
    52:     }

## scalper/backtest/optimize.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: """Parameter sweep utilities for strategy optimisation.
     4: 
     5: This module performs a grid search over a parameter space in parallel.  It
     6: tries to use :mod:`ray` for distributed execution when available and falls
     7: back to :mod:`multiprocessing` otherwise.
     8: """
     9: 
    10: import itertools
    11: import json
    12: import multiprocessing as mp
    13: import os
    14: from typing import Any, Dict, Iterable, List, Sequence
    15: 
    16: try:  # Optional dependency
    17:     import ray  # type: ignore
    18: except Exception:  # pragma: no cover - ray is optional
    19:     ray = None
    20: 
    21: from scalper.backtest import backtest_trades
    22: 
    23: 
    24: # ---------------------------------------------------------------------------
    25: # Parameter space
    26: # ---------------------------------------------------------------------------
    27: 
    28: def param_space_default() -> Dict[str, Sequence[Any]]:
    29:     """Return the default parameter search space.
    30: 
    31:     The keys correspond to strategy parameters while the values are iterables
    32:     of possible settings.  The defaults represent a small but representative
    33:     grid and can be overridden by callers.
    34:     """
    35: 
    36:     return {
    37:         "ema_fast": [10, 20, 30],
    38:         "ema_slow": [50, 100, 200],
    39:         "rsi_period": [14, 21],
    40:         "atr_period": [14, 21],
    41:     }
    42: 
    43: 
    44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    45:     """Expand *space* into a list of parameter combinations."""
    46: 
    47:     keys = list(space)
    48:     values = [space[k] for k in keys]
    49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
    50: 
    51: 
    52: # ---------------------------------------------------------------------------
    53: # Evaluation
    54: # ---------------------------------------------------------------------------
    55: 
    56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    57:     """Run a backtest for a single parameter combination.
    58: 
    59:     ``grid_item`` contains the parameter values along with optional ``trades``
    60:     to evaluate.  The function returns a copy of the parameters augmented with
    61:     the computed PnL under the key ``pnl``.
    62:     """
    63: 
    64:     params = dict(grid_item)
    65:     trades = params.pop("trades", [])
    66:     fee_rate = params.pop("fee_rate", None)
    67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
    68:     params["pnl"] = pnl
    69:     return params
    70: 
    71: 
    72: # ---------------------------------------------------------------------------
    73: # Orchestration
    74: # ---------------------------------------------------------------------------
    75: 
    76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    77:     """Evaluate the full parameter grid in parallel and return results."""
    78: 
    79:     space = space or param_space_default()
    80:     grid = _param_grid(space)
    81: 
    82:     # Determine execution backend
    83:     use_ray = False
    84:     if ray is not None:
    85:         try:  # pragma: no cover - depends on ray
    86:             ray.init(ignore_reinit_error=True)
    87:             use_ray = True
    88:         except Exception:
    89:             use_ray = False
    90: 
    91:     if use_ray:
    92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
    93:         futures = [remote_eval.remote(g) for g in grid]
    94:         results = ray.get(futures)
    95:     else:
    96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
    97:         with mp.Pool(processes=jobs) as pool:
    98:             results = pool.map(eval_params_one, grid)
    99: 
   100:     return results
   101: 
   102: 
   103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
   104:     """High level helper executing the sweep and saving aggregated results."""
   105: 
   106:     results = run_param_sweep(space, jobs=jobs)
   107:     with open(outfile, "w", encoding="utf8") as fh:
   108:         json.dump(results, fh, indent=2, sort_keys=True)
   109:     return results
   110: 
   111: 
   112: def main() -> None:  # pragma: no cover - convenience CLI
   113:     optimize()
   114: 
   115: 
   116: if __name__ == "__main__":  # pragma: no cover
   117:     main()


## scalper/backtest/position_sizing.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/position_sizing.py
     2: from __future__ import annotations
     3: from scalper.core.signal import Signal
     4: 
     5: def position_size_from_signal(equity: float, sig: Signal, risk_pct: float) -> float:
     6:     """
     7:     Taille = (equity * risk_pct) / |entry - sl|
     8:     Retourne la QUANTITÉ (unités de la crypto).
     9:     """
    10:     risk = max(1e-12, abs(sig.entry - sig.sl))
    11:     cash_at_risk = max(0.0, equity) * max(0.0, risk_pct)
    12:     return max(0.0, cash_at_risk / risk)
    13: 
    14: def fees_cost(notional: float, bps: float) -> float:
    15:     return abs(notional) * (bps / 10000.0)

## scalper/backtest/run_multi.py (last modified: 2025-08-24 10:15:51)
     1: # annulé

## scalper/backtest/runner.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/backtest/runner.py
     2: from __future__ import annotations
     3: import argparse
     4: import os
     5: from typing import Dict, List
     6: from scalper.strategy.factory import load_strategies_cfg
     7: from scalper.backtest.engine import BacktestEngine
     8: 
     9: def run_once(
    10:     symbol: str,
    11:     timeframe: str,
    12:     csv_path: str,
    13:     strategies_cfg_path: str = "scalper/config/strategies.yml",
    14:     csv_1h_path: str = "",
    15:     equity: float = 1000.0,
    16:     risk: float = 0.01,
    17:     fees_bps: float = 6.0,
    18: ) -> Dict[str, float]:
    19:     cfg = load_strategies_cfg(strategies_cfg_path)
    20:     data = BacktestEngine.load_csv(csv_path)
    21:     data_1h = BacktestEngine.load_csv(csv_1h_path) if csv_1h_path and os.path.isfile(csv_1h_path) else None
    22: 
    23:     eng = BacktestEngine(
    24:         symbol=symbol, timeframe=timeframe, data=data, data_1h=data_1h,
    25:         equity_start=equity, risk_pct=risk, fees_bps=fees_bps, strategies_cfg=cfg,
    26:     )
    27:     eng.run()
    28:     eng.save_results()
    29:     return eng.summary()
    30: 
    31: def main():
    32:     ap = argparse.ArgumentParser(description="Runner Backtest (point d'entrée unique)")
    33:     ap.add_argument("--symbol", required=True, help="ex: BTCUSDT")
    34:     ap.add_argument("--tf", required=True, help="ex: 5m, 1h")
    35:     ap.add_argument("--csv", required=True, help="CSV OHLCV principal (timestamp,open,high,low,close,volume)")
    36:     ap.add_argument("--csv_1h", default="", help="CSV 1h (optionnel) pour filtre MTF")
    37:     ap.add_argument("--cfg", default="scalper/config/strategies.yml", help="config stratégies (YAML/JSON)")
    38:     ap.add_argument("--equity", type=float, default=1000.0)
    39:     ap.add_argument("--risk", type=float, default=0.01)
    40:     ap.add_argument("--fees_bps", type=float, default=6.0)
    41:     args = ap.parse_args()
    42: 
    43:     summary = run_once(
    44:         symbol=args.symbol, timeframe=args.tf, csv_path=args.csv,
    45:         strategies_cfg_path=args.cfg, csv_1h_path=args.csv_1h,
    46:         equity=args.equity, risk=args.risk, fees_bps=args.fees_bps,
    47:     )
    48:     print("== Résumé ==")
    49:     print(summary)
    50: 
    51: if __name__ == "__main__":
    52:     main()

## scalper/backtest/walkforward.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: from itertools import product
     4: from statistics import mean, stdev
     5: from typing import Dict, Iterable, Optional
     6: 
     7: from ..strategy import max_drawdown
     8: 
     9: 
    10: def _sharpe(returns: Iterable[float]) -> float:
    11:     vals = list(returns)
    12:     if not vals:
    13:         return 0.0
    14:     mu = mean(vals)
    15:     if len(vals) > 1:
    16:         sd = stdev(vals)
    17:     else:
    18:         sd = 0.0
    19:     return mu / sd if sd > 0 else 0.0
    20: 
    21: 
    22: def _stability(equity: Iterable[float]) -> float:
    23:     curve = list(equity)
    24:     n = len(curve)
    25:     if n < 2:
    26:         return 0.0
    27:     x = list(range(n))
    28:     x_mean = sum(x) / n
    29:     y_mean = sum(curve) / n
    30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
    31:     denom = sum((xi - x_mean) ** 2 for xi in x)
    32:     if denom == 0 or ss_tot == 0:
    33:         return 0.0
    34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    35:     a = y_mean - b * x_mean
    36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    37:     return 1 - ss_res / ss_tot
    38: 
    39: 
    40: def walk_forward(
    41:     df,
    42:     splits: int = 5,
    43:     train_ratio: float = 0.7,
    44:     params: Optional[Dict[str, Iterable]] = None,
    45: ) -> Dict[str, float]:
    46:     """Perform walk-forward optimisation and evaluation.
    47: 
    48:     Parameters
    49:     ----------
    50:     df:
    51:         DataFrame containing per-period percentage returns. The first column is
    52:         used when a dedicated ``"returns"`` column is not found.
    53:     splits:
    54:         Number of walk-forward test windows.
    55:     train_ratio:
    56:         Proportion of the data used for training in the initial window.
    57:     params:
    58:         Optional parameter grid. If provided, columns in ``df`` matching each
    59:         parameter combination are evaluated and the best Sharpe ratio on the
    60:         training window is selected. When ``None``, the first column is used.
    61:     """
    62: 
    63:     if df.empty:
    64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
    65: 
    66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
    67:     data = df.copy()
    68: 
    69:     n = len(data)
    70:     train_len = max(1, int(n * train_ratio))
    71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
    72: 
    73:     sharpe_list = []
    74:     mdd_list = []
    75:     pnl_list = []
    76:     stability_list = []
    77: 
    78:     from . import walk_forward_windows
    79: 
    80:     indices = list(range(n))
    81: 
    82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
    83:         train_df = data.iloc[tr_idx]
    84:         test_df = data.iloc[te_idx]
    85: 
    86:         # Parameter optimisation based on Sharpe ratio
    87:         if params:
    88:             best_col = None
    89:             best_score = float("-inf")
    90:             keys, values = zip(*params.items()) if params else ([], [])
    91:             for combo in product(*values):
    92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
    93:                 if col_name not in data.columns:
    94:                     continue
    95:                 score = _sharpe(train_df[col_name])
    96:                 if score > best_score:
    97:                     best_score = score
    98:                     best_col = col_name
    99:             series = test_df[best_col] if best_col else test_df[returns_col]
   100:         else:
   101:             series = test_df[returns_col]
   102: 
   103:         sharpe_list.append(_sharpe(series))
   104:         equity = (1 + series / 100.0).cumprod()
   105:         mdd_list.append(max_drawdown(equity))
   106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
   107:         stability_list.append(_stability(equity))
   108: 
   109:     count = len(sharpe_list) or 1
   110:     mean_sharpe = sum(sharpe_list) / count
   111:     mean_mdd = sum(mdd_list) / count
   112:     mean_pnl = sum(pnl_list) / count
   113:     mean_stability = sum(stability_list) / count
   114: 
   115:     return {
   116:         "sharpe": mean_sharpe,
   117:         "mdd": mean_mdd,
   118:         "pnl": mean_pnl,
   119:         "stability": mean_stability,
   120:     }


## scalper/bitget_client.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/bitget_client.py
     2: from __future__ import annotations
     3: 
     4: import base64
     5: import hashlib
     6: import hmac
     7: import json
     8: import logging
     9: import time
    10: from dataclasses import dataclass
    11: from typing import Any, Dict, Mapping, Optional
    12: 
    13: import requests
    14: 
    15: __all__ = ["BitgetFuturesClient", "ApiError"]
    16: 
    17: log = logging.getLogger("scalper.bitget_client")
    18: 
    19: 
    20: # =============================================================================
    21: # Exceptions
    22: # =============================================================================
    23: class ApiError(RuntimeError):
    24:     """Erreur API Bitget (HTTP != 200, code != '00000', ou payload invalide)."""
    25: 
    26:     def __init__(self, message: str, *, http_status: int | None = None, body: Any | None = None):
    27:         super().__init__(message)
    28:         self.http_status = http_status
    29:         self.body = body
    30: 
    31: 
    32: # =============================================================================
    33: # Helpers
    34: # =============================================================================
    35: def _now_ms() -> int:
    36:     return int(time.time() * 1000)
    37: 
    38: 
    39: def _canonical_json(obj: Mapping[str, Any] | None) -> str:
    40:     if not obj:
    41:         return ""
    42:     # JSON compact, trié, ascii pour signature stable
    43:     return json.dumps(obj, separators=(",", ":"), sort_keys=True, ensure_ascii=True)
    44: 
    45: 
    46: # =============================================================================
    47: # Client REST Futures (USDT-M)
    48: # =============================================================================
    49: @dataclass
    50: class _Auth:
    51:     access_key: str
    52:     secret_key: str
    53:     passphrase: str
    54:     recv_window: int = 30_000  # ms
    55: 
    56: 
    57: class BitgetFuturesClient:
    58:     """
    59:     Client REST léger pour les Futures USDT-M de Bitget.
    60: 
    61:     Points clés:
    62:     - Public: get_ticker(symbol?), get_klines(symbol, interval, limit, start/end?)
    63:     - Privé : get_account(), get_open_orders(symbol?), cancel_order(), cancel_all()
    64:               place_market_order_one_way(), place_limit_order_one_way()
    65:               set_position_mode_one_way(), set_leverage()
    66:     - Safe: gestion d’erreurs centralisée, retries modestes côté réseau, timeouts.
    67: 
    68:     Notes:
    69:     - Les endpoints et champs renvoyés sont harmonisés pour rester stables
    70:       côté bot/orchestrateur. On tolère plusieurs variantes de clés (lastPr/lastPrice).
    71:     """
    72: 
    73:     def __init__(
    74:         self,
    75:         *,
    76:         access_key: str = "",
    77:         secret_key: str = "",
    78:         passphrase: str = "",
    79:         base_url: str = "https://api.bitget.com",
    80:         paper_trade: bool = True,
    81:         timeout: float = 10.0,
    82:         session: Optional[requests.Session] = None,
    83:     ) -> None:
    84:         self.base_url = base_url.rstrip("/")
    85:         self.auth = _Auth(access_key, secret_key, passphrase)
    86:         self.paper = paper_trade
    87:         self.timeout = float(timeout)
    88:         self.sess = session or requests.Session()
    89:         # En-têtes par défaut (Bitget utilise parfois des headers dédiés)
    90:         self.sess.headers.update({"Accept": "application/json"})
    91:         log.info("BitgetFuturesClient ready (paper=%s base=%s)", self.paper, self.base_url)
    92: 
    93:     # -------------------------------------------------------------------------
    94:     # Core HTTP
    95:     # -------------------------------------------------------------------------
    96:     def _sign(self, ts_ms: int, method: str, path: str, query: str, body: str) -> str:
    97:         """
    98:         Signature (préservée au plus simple) :
    99:           sign = base64( HMAC_SHA256(secret, f"{ts}{method}{path}{query}{body}") )
   100:         - method en MAJUSCULES
   101:         - query inclut '?' si présent, sinon ""
   102:         - body = chaîne JSON canonique (ou vide)
   103:         """
   104:         msg = f"{ts_ms}{method.upper()}{path}{query}{body}"
   105:         return base64.b64encode(hmac.new(self.auth.secret_key.encode(), msg.encode(), hashlib.sha256).digest()).decode()
   106: 
   107:     def _request(
   108:         self,
   109:         method: str,
   110:         path: str,
   111:         *,
   112:         params: Optional[Mapping[str, Any]] = None,
   113:         body: Optional[Mapping[str, Any]] = None,
   114:         signed: bool = False,
   115:     ) -> Dict[str, Any]:
   116:         url = f"{self.base_url}{path}"
   117:         params = dict(params or {})
   118:         body_json = _canonical_json(body)
   119:         query = ""
   120: 
   121:         headers = {"Content-Type": "application/json"}
   122:         if not signed:
   123:             # Public
   124:             resp = self.sess.request(
   125:                 method=method.upper(),
   126:                 url=url,
   127:                 params=params or None,
   128:                 timeout=self.timeout,
   129:                 headers=headers,
   130:             )
   131:         else:
   132:             # Privé: timestamp + recvWindow
   133:             ts = _now_ms()
   134:             if "recvWindow" not in params:
   135:                 params["recvWindow"] = self.auth.recv_window
   136:             # Construire la query string stable (requests la formate si on passe 'params')
   137:             # Pour la signature, on reconstruit minimalement:
   138:             if params:
   139:                 # Tri simple par clé pour stabilité
   140:                 q_items = "&".join(f"{k}={params[k]}" for k in sorted(params))
   141:                 query = f"?{q_items}"
   142:             signature = self._sign(ts, method, path, query, body_json)
   143: 
   144:             headers.update(
   145:                 {
   146:                     "ACCESS-KEY": self.auth.access_key,
   147:                     "ACCESS-SIGN": signature,
   148:                     "ACCESS-TIMESTAMP": str(ts),
   149:                     "ACCESS-PASSPHRASE": self.auth.passphrase,
   150:                 }
   151:             )
   152: 
   153:             resp = self.sess.request(
   154:                 method=method.upper(),
   155:                 url=url,
   156:                 params=params or None,
   157:                 data=body_json if body_json else None,
   158:                 timeout=self.timeout,
   159:                 headers=headers,
   160:             )
   161: 
   162:         # Gestion d’erreurs HTTP
   163:         if resp.status_code != 200:
   164:             raise ApiError(f"HTTP {resp.status_code} for {path}", http_status=resp.status_code, body=resp.text)
   165: 
   166:         # Décodage JSON
   167:         try:
   168:             data = resp.json()
   169:         except Exception as exc:
   170:             raise ApiError(f"Non-JSON response for {path}: {resp.text[:200]}") from exc
   171: 
   172:         # Protocole Bitget: code == '00000' attendu
   173:         code = str(data.get("code", ""))
   174:         if code and code != "00000":
   175:             raise ApiError(f"Bitget API error code={code} for {path}", body=data)
   176: 
   177:         return data
   178: 
   179:     # -------------------------------------------------------------------------
   180:     # PUBLIC
   181:     # -------------------------------------------------------------------------
   182:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   183:         """
   184:         Ticker spot/futures. On suit l'API publique 'mix' si symbol précisé.
   185:         Retourne un dict avec 'data' list/dict ; on tolère plusieurs champs prix.
   186:         """
   187:         if symbol:
   188:             # Futures Mix tickers (ex: /api/v2/mix/market/tickers?productType=USDT-FUTURES)
   189:             # Ici on récupère tous les tickers puis on filtre localement pour robustesse.
   190:             data = self._request(
   191:                 "GET",
   192:                 "/api/v2/mix/market/tickers",
   193:                 params={"productType": "USDT-FUTURES"},
   194:                 signed=False,
   195:             )
   196:             # Harmoniser: extraire l’entrée du symbole demandé
   197:             items = data.get("data") or []
   198:             sym = symbol.replace("_", "").upper()
   199:             hit: Dict[str, Any] | None = None
   200:             for it in items:
   201:                 if (it.get("symbol") or "").replace("_", "").upper() == sym:
   202:                     hit = it
   203:                     break
   204:             return {"data": hit or {}}
   205: 
   206:         # Sans symbole: renvoie tout (liste)
   207:         return self._request(
   208:             "GET",
   209:             "/api/v2/mix/market/tickers",
   210:             params={"productType": "USDT-FUTURES"},
   211:             signed=False,
   212:         )
   213: 
   214:     def get_klines(
   215:         self,
   216:         symbol: str,
   217:         interval: str = "1m",
   218:         limit: int = 100,
   219:         start: Optional[int] = None,
   220:         end: Optional[int] = None,
   221:     ) -> Dict[str, Any]:
   222:         """
   223:         OHLCV Futures.
   224:         interval: '1m', '5m', '15m', '1h', ...
   225:         start/end: timestamps ms optionnels selon l’API.
   226:         """
   227:         params: Dict[str, Any] = {
   228:             "symbol": symbol.replace("_", "").upper(),
   229:             "granularity": interval,
   230:             "productType": "USDT-FUTURES",
   231:             "limit": max(1, min(int(limit), 1000)),
   232:         }
   233:         if start is not None:
   234:             params["startTime"] = int(start)
   235:         if end is not None:
   236:             params["endTime"] = int(end)
   237: 
   238:         return self._request("GET", "/api/v2/mix/market/candles", params=params, signed=False)
   239: 
   240:     # -------------------------------------------------------------------------
   241:     # PRIVÉ (Futures One-Way par défaut)
   242:     # -------------------------------------------------------------------------
   243:     def get_account(self) -> Dict[str, Any]:
   244:         """Infos compte futures (marges, balances)."""
   245:         return self._request("GET", "/api/v2/mix/account/accounts", params={"productType": "USDT-FUTURES"}, signed=True)
   246: 
   247:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   248:         params: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   249:         if symbol:
   250:             params["symbol"] = symbol.replace("_", "").upper()
   251:         return self._request("GET", "/api/v2/mix/order/open-orders", params=params, signed=True)
   252: 
   253:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   254:         body = {
   255:             "symbol": symbol.replace("_", "").upper(),
   256:             "productType": "USDT-FUTURES",
   257:             "orderId": order_id,
   258:         }
   259:         return self._request("POST", "/api/v2/mix/order/cancel-order", body=body, signed=True)
   260: 
   261:     def cancel_all(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   262:         body: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   263:         if symbol:
   264:             body["symbol"] = symbol.replace("_", "").upper()
   265:         return self._request("POST", "/api/v2/mix/order/cancel-batch-orders", body=body, signed=True)
   266: 
   267:     # -- Mode de position & levier ------------------------------------------------
   268:     def set_position_mode_one_way(self, symbol: str, product_type: str = "USDT-FUTURES") -> Dict[str, Any]:
   269:         """Passe le mode de position en One-Way (si nécessaire)."""
   270:         body = {
   271:             "productType": product_type,
   272:             "symbol": symbol.replace("_", "").upper(),
   273:             "holdMode": "one_way",  # valeur usuelle côté API mix
   274:         }
   275:         return self._request("POST", "/api/v2/mix/account/set-position-mode", body=body, signed=True)
   276: 
   277:     def set_leverage(
   278:         self,
   279:         symbol: str,
   280:         product_type: str = "USDT-FUTURES",
   281:         margin_coin: str = "USDT",
   282:         leverage: int = 2,
   283:         side: str = "long",
   284:     ) -> Dict[str, Any]:
   285:         """Règle l’effet de levier (par side 'long'/'short' ou global selon l’API)."""
   286:         lev = max(1, int(leverage))
   287:         body = {
   288:             "symbol": symbol.replace("_", "").upper(),
   289:             "productType": product_type,
   290:             "marginCoin": margin_coin,
   291:             "leverage": str(lev),
   292:             "holdSide": side.lower(),  # 'long' ou 'short'
   293:         }
   294:         return self._request("POST", "/api/v2/mix/account/set-leverage", body=body, signed=True)
   295: 
   296:     # -- Placement d’ordres (One-Way) -------------------------------------------
   297:     def place_market_order_one_way(
   298:         self,
   299:         symbol: str,
   300:         side: str,
   301:         size: float,
   302:         product_type: str = "USDT-FUTURES",
   303:         margin_coin: str = "USDT",
   304:         client_oid: Optional[str] = None,
   305:     ) -> Dict[str, Any]:
   306:         """
   307:         Place un ordre MARKET en mode one-way.
   308:         side: 'buy' ou 'sell'
   309:         size: quantité de contrat (arrondie au format serveur côté API)
   310:         """
   311:         body: Dict[str, Any] = {
   312:             "symbol": symbol.replace("_", "").upper(),
   313:             "productType": product_type,
   314:             "marginCoin": margin_coin,
   315:             "size": f"{float(size):.6f}",
   316:             "side": side.lower(),
   317:             "orderType": "market",
   318:         }
   319:         if client_oid:
   320:             body["clientOid"] = client_oid
   321:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   322: 
   323:     def place_limit_order_one_way(
   324:         self,
   325:         symbol: str,
   326:         side: str,
   327:         size: float,
   328:         price: float,
   329:         product_type: str = "USDT-FUTURES",
   330:         margin_coin: str = "USDT",
   331:         tif: str = "GTC",
   332:         client_oid: Optional[str] = None,
   333:     ) -> Dict[str, Any]:
   334:         """
   335:         Place un ordre LIMIT en mode one-way.
   336:         tif: GTC/IOC/FOK suivant l’API.
   337:         """
   338:         body: Dict[str, Any] = {
   339:             "symbol": symbol.replace("_", "").upper(),
   340:             "productType": product_type,
   341:             "marginCoin": margin_coin,
   342:             "size": f"{float(size):.6f}",
   343:             "price": f"{float(price):.8f}",
   344:             "side": side.lower(),
   345:             "orderType": "limit",
   346:             "timeInForceValue": tif.upper(),
   347:         }
   348:         if client_oid:
   349:             body["clientOid"] = client_oid
   350:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   351: 
   352:     # -------------------------------------------------------------------------
   353:     # Helpers d’accès — compat facilité avec du code existant
   354:     # -------------------------------------------------------------------------
   355:     def last_price(self, symbol: str) -> float:
   356:         """
   357:         Renvoie un prix last connu en tolérant plusieurs structures/clefs de la réponse.
   358:         """
   359:         tick = self.get_ticker(symbol)
   360:         data = tick.get("data")
   361:         if isinstance(data, list) and data:
   362:             data = data[0]
   363:         if not isinstance(data, dict):
   364:             return 0.0
   365:         price_str = (
   366:             data.get("lastPr")
   367:             or data.get("lastPrice")
   368:             or data.get("close")
   369:             or data.get("price")
   370:             or data.get("l")
   371:         )
   372:         try:
   373:             return float(price_str)
   374:         except Exception:
   375:             return 0.0

## scalper/client.py (last modified: 2025-08-24 10:15:51)
     1: import logging
     2: from typing import Any, Dict, Optional
     3: 
     4: import requests
     5: from requests.adapters import HTTPAdapter
     6: from urllib3.util.retry import Retry
     7: 
     8: 
     9: class HTTPError(RuntimeError):
    10:     """Raised when an HTTP request fails"""
    11: 
    12: 
    13: class HttpClient:
    14:     """Simple HTTP client with persistent session and retry logic.
    15: 
    16:     The client exposes a :py:meth:`close` method and implements the context
    17:     manager protocol so it can be used with ``with`` statements to ensure
    18:     that the underlying :class:`requests.Session` is properly closed.
    19:     """
    20: 
    21:     def __init__(
    22:         self,
    23:         base_url: str,
    24:         *,
    25:         timeout: float = 10.0,
    26:         max_retries: int = 3,
    27:         backoff_factor: float = 0.3,
    28:         status_forcelist: Optional[list[int]] = None,
    29:     ) -> None:
    30:         self.base_url = base_url.rstrip("/")
    31:         self.timeout = timeout
    32:         self.session = requests.Session()
    33:         retry = Retry(
    34:             total=max_retries,
    35:             backoff_factor=backoff_factor,
    36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
    37:             allowed_methods=[
    38:                 "HEAD",
    39:                 "GET",
    40:                 "OPTIONS",
    41:                 "POST",
    42:                 "PUT",
    43:                 "DELETE",
    44:                 "PATCH",
    45:             ],
    46:         )
    47:         adapter = HTTPAdapter(max_retries=retry)
    48:         self.session.mount("http://", adapter)
    49:         self.session.mount("https://", adapter)
    50: 
    51:     def close(self) -> None:
    52:         """Close the underlying :class:`requests.Session`."""
    53:         self.session.close()
    54: 
    55:     # ------------------------------------------------------------------
    56:     # Context manager support
    57:     # ------------------------------------------------------------------
    58:     def __enter__(self) -> "HttpClient":
    59:         return self
    60: 
    61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
    62:         self.close()
    63: 
    64:     def request(
    65:         self,
    66:         method: str,
    67:         path: str,
    68:         *,
    69:         params: Optional[Dict[str, Any]] = None,
    70:         json: Optional[Dict[str, Any]] = None,
    71:         headers: Optional[Dict[str, str]] = None,
    72:     ) -> Dict[str, Any]:
    73:         """Perform an HTTP request and return JSON data.
    74: 
    75:         Errors during the request raise ``HTTPError``. If the response cannot
    76:         be decoded as JSON, a dictionary describing the issue is returned.
    77:         """
    78:         url = f"{self.base_url}{path}"
    79:         try:
    80:             resp = self.session.request(
    81:                 method,
    82:                 url,
    83:                 params=params,
    84:                 json=json,
    85:                 headers=headers,
    86:                 timeout=self.timeout,
    87:             )
    88:             resp.raise_for_status()
    89:         except requests.RequestException as exc:  # network or HTTP errors
    90:             msg = f"HTTP error calling {url}: {exc}"
    91:             logging.error(msg)
    92:             raise HTTPError(msg) from exc
    93: 
    94:         try:
    95:             return resp.json()
    96:         except ValueError:  # invalid JSON
    97:             msg = "Invalid JSON in response"
    98:             logging.error("%s for %s: %s", msg, url, resp.text)
    99:             return {"success": False, "error": msg, "text": resp.text}


## scalper/config/__init__.py (last modified: 2025-08-24 10:15:51)
     1: from .loader import load_settings
     2: __all__ = ['load_settings']


## scalper/config/config.yaml (last modified: 2025-08-24 10:15:51)
     1: # scalper/config/config.yaml
     2: # Paramètres généraux (versionnés). Aucun secret ici.
     3: 
     4: runtime:
     5:   data_dir: /notebooks/data
     6:   log_dir: /notebooks/scalp/logs
     7:   paper_trade: true
     8:   allowed_symbols: []   # vide = toutes
     9:   refresh_secs: 5
    10: 
    11: strategy:
    12:   live_timeframe: 1m
    13:   ema_fast: 20
    14:   ema_slow: 50
    15:   macd_fast: 12
    16:   macd_slow: 26
    17:   macd_signal: 9
    18:   ema_trend_period: 100
    19: 
    20: risk:
    21:   risk_pct_equity: 0.02
    22:   leverage: 5
    23:   stop_loss_pct: 0.01
    24:   take_profit_pct: 0.02
    25:   atr_period: 14
    26:   trail_atr_mult: 2.0
    27:   scale_in_atr_mult: 0.5
    28:   progress_min: 15
    29:   timeout_min: 30
    30:   max_daily_loss_pct: 0.05
    31:   max_daily_profit_pct: 0.10
    32:   max_positions: 3

## scalper/config/loader.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/config/loader.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: from pathlib import Path
     6: from typing import Dict, Tuple, Any
     7: 
     8: # PyYAML est recommandé ; si absent on fonctionnera avec un dict vide.
     9: try:
    10:     import yaml
    11: except Exception:  # pragma: no cover
    12:     yaml = None
    13: 
    14: # ------------ Aliases ENV -> clés canoniques (SECRETS UNIQUEMENT) ------------
    15: _ALIASES: Dict[str, Tuple[str, ...]] = {
    16:     "BITGET_ACCESS_KEY": ("BITGET_API_KEY", "BITGET_KEY"),
    17:     "BITGET_SECRET_KEY": ("BITGET_API_SECRET", "BITGET_SECRET"),
    18:     "BITGET_PASSPHRASE": ("BITGET_API_PASSPHRASE", "BITGET_PASSWORD", "BITGET_API_PASSWORD"),
    19:     "TELEGRAM_BOT_TOKEN": ("TELEGRAM_TOKEN", "TG_TOKEN"),
    20:     "TELEGRAM_CHAT_ID": ("TG_CHAT_ID", "TELEGRAM_TO", "CHAT_ID"),
    21: }
    22: 
    23: def _adopt_alias(target: str) -> None:
    24:     if os.getenv(target):
    25:         return
    26:     for alt in _ALIASES.get(target, ()):
    27:         v = os.getenv(alt)
    28:         if v:
    29:             os.environ[target] = v
    30:             return
    31: 
    32: def apply_env_aliases() -> None:
    33:     """Projette les aliases vers les clés canoniques (secrets)."""
    34:     for k in _ALIASES:
    35:         _adopt_alias(k)
    36: 
    37: # ------------ Chargement des paramètres généraux (YAML versionné) ------------
    38: def load_yaml_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    39:     """
    40:     Charge le fichier YAML de paramètres généraux (PAS de secrets).
    41:     Chemin par défaut : scalper/config/config.yaml (dans le repo).
    42:     """
    43:     if path is None:
    44:         path = Path(__file__).resolve().parent / "config.yaml"
    45:     path = Path(path)
    46:     if yaml is None or not path.exists():
    47:         return {}
    48:     with path.open("r", encoding="utf-8") as fh:
    49:         data = yaml.safe_load(fh) or {}
    50:     return data
    51: 
    52: def load_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    53:     """
    54:     Fusionne :
    55:       - paramètres généraux depuis YAML (versionné),
    56:       - secrets depuis l'environnement (déjà chargés depuis /notebooks/.env).
    57:     """
    58:     cfg = load_yaml_config(path)
    59:     apply_env_aliases()
    60:     cfg.setdefault("secrets", {})
    61:     cfg["secrets"]["bitget"] = {
    62:         "access": os.getenv("BITGET_ACCESS_KEY") or "",
    63:         "secret": os.getenv("BITGET_SECRET_KEY") or "",
    64:         "passphrase": os.getenv("BITGET_PASSPHRASE") or "",
    65:     }
    66:     cfg["secrets"]["telegram"] = {
    67:         "token": os.getenv("TELEGRAM_BOT_TOKEN") or "",
    68:         "chat_id": os.getenv("TELEGRAM_CHAT_ID") or "",
    69:     }
    70:     return cfg
    71: 
    72: __all__ = ["apply_env_aliases", "load_yaml_config", "load_config"]

## scalper/config/strategies.yml (last modified: 2025-08-24 10:15:51)
     1: # scalper/config/strategies.yml
     2: default: current
     3: by_timeframe:
     4:   "1m": current
     5:   "5m": current
     6:   "15m": current
     7:   "1h": current
     8: by_symbol:
     9:   BTCUSDT:
    10:     "1m": current
    11:     "5m": current
    12:   ETHUSDT:
    13:     "5m": current


## scalper/core/indicators.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/core/indicators.py
     2: from __future__ import annotations
     3: from typing import Sequence, Tuple, List
     4: 
     5: def _to_list(x: Sequence[float]) -> List[float]:
     6:     return list(map(float, x))
     7: 
     8: def ema(series: Sequence[float], period: int) -> List[float]:
     9:     s = _to_list(series)
    10:     if period <= 1 or len(s) == 0:
    11:         return s[:]
    12:     k = 2.0 / (period + 1.0)
    13:     out = [s[0]]
    14:     for i in range(1, len(s)):
    15:         out.append(s[i] * k + out[-1] * (1.0 - k))
    16:     return out
    17: 
    18: def sma(series: Sequence[float], period: int) -> List[float]:
    19:     s = _to_list(series)
    20:     out: List[float] = []
    21:     acc = 0.0
    22:     for i, v in enumerate(s):
    23:         acc += v
    24:         if i >= period:
    25:             acc -= s[i - period]
    26:         out.append(acc / min(i + 1, period))
    27:     return out
    28: 
    29: def rsi(closes: Sequence[float], period: int = 14) -> List[float]:
    30:     c = _to_list(closes)
    31:     if len(c) < 2:
    32:         return [50.0] * len(c)
    33:     gains = [0.0]
    34:     losses = [0.0]
    35:     for i in range(1, len(c)):
    36:         ch = c[i] - c[i - 1]
    37:         gains.append(max(ch, 0.0))
    38:         losses.append(max(-ch, 0.0))
    39:     avg_gain = sma(gains, period)
    40:     avg_loss = sma(losses, period)
    41:     out = []
    42:     for g, l in zip(avg_gain, avg_loss):
    43:         if l == 0:
    44:             out.append(100.0)
    45:         else:
    46:             rs = g / l
    47:             out.append(100.0 - (100.0 / (1.0 + rs)))
    48:     return out
    49: 
    50: def macd(closes: Sequence[float], fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[List[float], List[float], List[float]]:
    51:     c = _to_list(closes)
    52:     ema_fast = ema(c, fast)
    53:     ema_slow = ema(c, slow)
    54:     macd_line = [f - s for f, s in zip(ema_fast, ema_slow)]
    55:     signal_line = ema(macd_line, signal)
    56:     hist = [m - s for m, s in zip(macd_line, signal_line)]
    57:     return macd_line, signal_line, hist
    58: 
    59: def atr(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], period: int = 14) -> List[float]:
    60:     h, l, c = _to_list(highs), _to_list(lows), _to_list(closes)
    61:     if not h:
    62:         return []
    63:     trs = [h[0] - l[0]]
    64:     for i in range(1, len(h)):
    65:         tr = max(h[i] - l[i], abs(h[i] - c[i - 1]), abs(l[i] - c[i - 1]))
    66:         trs.append(tr)
    67:     return ema(trs, period)
    68: 
    69: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    70:     c, v = _to_list(closes), _to_list(volumes)
    71:     out = [0.0]
    72:     for i in range(1, len(c)):
    73:         if c[i] > c[i - 1]:
    74:             out.append(out[-1] + v[i])
    75:         elif c[i] < c[i - 1]:
    76:             out.append(out[-1] - v[i])
    77:         else:
    78:             out.append(out[-1])
    79:     return out
    80: 
    81: def vwap(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    82:     h, l, c, v = _to_list(highs), _to_list(lows), _to_list(closes), _to_list(volumes)
    83:     out: List[float] = []
    84:     cum_tp_vol = 0.0
    85:     cum_vol = 0.0
    86:     for hi, lo, cl, vol in zip(h, l, c, v):
    87:         tp = (hi + lo + cl) / 3.0
    88:         cum_tp_vol += tp * vol
    89:         cum_vol += max(vol, 1e-12)
    90:         out.append(cum_tp_vol / cum_vol)
    91:     return out
    92: 
    93: def slope(series: Sequence[float], lookback: int = 5) -> List[float]:
    94:     s = _to_list(series)
    95:     out: List[float] = []
    96:     for i in range(len(s)):
    97:         if i < lookback:
    98:             out.append(0.0)
    99:         else:
   100:             denom = abs(s[i - lookback]) if abs(s[i - lookback]) > 1e-12 else 1e-12
   101:             out.append((s[i] - s[i - lookback]) / denom)
   102:     return out

## scalper/core/signal.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/core/signal.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass, field
     4: from typing import List, Optional, Literal, Dict, Any
     5: 
     6: Side = Literal["long", "short"]
     7: 
     8: @dataclass
     9: class Signal:
    10:     symbol: str
    11:     timeframe: str
    12:     side: Side
    13:     entry: float
    14:     sl: float
    15:     tp1: Optional[float] = None
    16:     tp2: Optional[float] = None
    17:     qty: Optional[float] = None
    18:     score: float = 0.0          # 0..1 (ou entier, normalisé au besoin)
    19:     quality: float = 0.0        # 0..1
    20:     reasons: List[str] = field(default_factory=list)
    21:     timestamp: Optional[int] = None  # ms epoch de la bougie de déclenchement
    22:     extra: Dict[str, Any] = field(default_factory=dict)
    23: 
    24:     def risk_per_unit(self) -> float:
    25:         return abs(self.entry - self.sl)
    26: 
    27:     def as_dict(self) -> Dict[str, Any]:
    28:         d = {
    29:             "symbol": self.symbol, "timeframe": self.timeframe, "side": self.side,
    30:             "entry": self.entry, "sl": self.sl, "tp1": self.tp1, "tp2": self.tp2,
    31:             "qty": self.qty, "score": self.score, "quality": self.quality,
    32:             "timestamp": self.timestamp, "reasons": "|".join(self.reasons),
    33:         }
    34:         d.update(self.extra or {})
    35:         return d

## scalper/exchange/__init__.py (last modified: 2025-08-24 10:15:51)
     1: # Rend le sous-package exchanges importable
     2: __all__ = ["bitget"]

## scalper/exchange/bitget.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/exchange/bitget.py
     2: from __future__ import annotations
     3: import os
     4: import requests
     5: from typing import List, Dict, Any
     6: 
     7: BASE_URL = "https://api.bitget.com"
     8: 
     9: # Spot: period strings
    10: _SPOT_PERIOD = {
    11:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min", "30m": "30min",
    12:     "1h": "1hour", "4h": "4hour", "6h": "6hour", "12h": "12hour",
    13:     "1d": "1day", "3d": "3day", "1w": "1week",
    14: }
    15: # Mix: granularity seconds
    16: _MIX_GRAN = {
    17:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    18:     "1h": 3600, "4h": 14400, "6h": 21600, "12h": 43200,
    19:     "1d": 86400, "3d": 259200, "1w": 604800,
    20: }
    21: 
    22: def _market_from_symbol(symbol: str) -> str:
    23:     s = symbol.upper()
    24:     if s.endswith("_SPBL"):
    25:         return "spot"
    26:     if s.endswith("_UMCBL"):
    27:         return "umcbl"
    28:     if s.endswith("_DMCBL"):
    29:         return "dmcbl"
    30:     if s.endswith("_CMCBL"):
    31:         return "cmcbl"
    32:     # fallback env / défaut umcbl
    33:     return os.getenv("BITGET_MARKET", "umcbl").lower()
    34: 
    35: def _product_type(market: str) -> str:
    36:     # valeur attendue par les endpoints mix (umcbl/dmcbl/cmcbl)
    37:     if market in ("umcbl", "dmcbl", "cmcbl"):
    38:         return market
    39:     return "umcbl"
    40: 
    41: class BitgetExchange:
    42:     """
    43:     Wrapper simple: get_ohlcv(symbol, timeframe, limit) -> [[ts, o, h, l, c, v], ...]
    44:     symbol spot ex: BTCUSDT_SPBL
    45:     symbol perp ex: BTCUSDT_UMCBL / BTCUSD_DMCBL / BTCUSD_CMCBL
    46:     """
    47:     def __init__(self, api_key: str = "", api_secret: str = "", api_passphrase: str = "", timeout: int = 20) -> None:
    48:         self.session = requests.Session()
    49:         self.session.headers.update({"User-Agent": "scalp-bot/1.0"})
    50:         self.timeout = timeout
    51: 
    52:     def _get(self, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
    53:         url = BASE_URL + path
    54:         r = self.session.get(url, params=params, timeout=self.timeout)
    55:         r.raise_for_status()
    56:         data = r.json()
    57:         # Bitget: {"code":"00000","msg":"success","requestTime":..., "data":[...]}
    58:         if not isinstance(data, dict) or str(data.get("code")) not in ("00000", "0", "200"):
    59:             raise RuntimeError(f"Bitget error payload: {data}")
    60:         return data
    61: 
    62:     def get_ohlcv(self, symbol: str, timeframe: str = "5m", limit: int = 500) -> List[List[float]]:
    63:         timeframe = timeframe.lower()
    64:         mkt = _market_from_symbol(symbol)
    65: 
    66:         if mkt == "spot":
    67:             period = _SPOT_PERIOD.get(timeframe)
    68:             if not period:
    69:                 raise ValueError(f"timeframe spot non supporté: {timeframe}")
    70:             # Bitget spot: limit max souvent 1000
    71:             lim = max(1, min(int(limit), 1000))
    72:             params = {"symbol": symbol, "period": period, "limit": lim}
    73:             data = self._get("/api/spot/v1/market/candles", params=params)
    74:             rows = data.get("data") or []
    75:             out: List[List[float]] = []
    76:             # Bitget renvoie décroissant -> on inverse
    77:             for r in reversed(rows):
    78:                 ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
    79:                 out.append([ts, o, h, l, c, v])
    80:             return out
    81: 
    82:         # MIX (umcbl/dmcbl/cmcbl)
    83:         gran = _MIX_GRAN.get(timeframe)
    84:         if not gran:
    85:             raise ValueError(f"timeframe mix non supporté: {timeframe}")
    86: 
    87:         # Bitget mix: limit max souvent 200, granularity en secondes, productType parfois requis
    88:         lim = max(1, min(int(limit), 200))
    89:         params = {
    90:             "symbol": symbol,
    91:             "granularity": int(gran),
    92:             "limit": lim,
    93:             "productType": _product_type(mkt),
    94:         }
    95: 
    96:         # essais: candles -> history-candles (certaines régions)
    97:         try:
    98:             data = self._get("/api/mix/v1/market/candles", params=params)
    99:         except requests.HTTPError:
   100:             data = self._get("/api/mix/v1/market/history-candles", params=params)
   101: 
   102:         rows = data.get("data") or []
   103:         out: List[List[float]] = []
   104:         for r in reversed(rows):
   105:             ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
   106:             out.append([ts, o, h, l, c, v])
   107:         return out

## scalper/exchange/bitget_ccxt.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/exchange/bitget_ccxt.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Any, List, Optional
     9: 
    10: # CCXT async
    11: try:
    12:     import ccxt.async_support as ccxt
    13: except Exception as e:  # noqa: BLE001
    14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
    15: 
    16: 
    17: def _now_ms() -> int:
    18:     return int(time.time() * 1000)
    19: 
    20: 
    21: class BitgetExchange:
    22:     """
    23:     Échange Bitget via CCXT (async) avec cache CSV local.
    24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
    25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
    26:         [[ts, open, high, low, close, volume], ...]
    27:     """
    28: 
    29:     def __init__(
    30:         self,
    31:         *,
    32:         api_key: Optional[str] = None,
    33:         secret: Optional[str] = None,
    34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
    35:         data_dir: str = "/notebooks/data",
    36:         use_cache: bool = True,
    37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
    38:         spot: bool = True,           # True = SPOT (recommandé ici)
    39:     ) -> None:
    40:         self.data_dir = data_dir
    41:         self.use_cache = use_cache
    42:         self.min_fresh = int(min_fresh_seconds)
    43:         self.spot = spot
    44: 
    45:         os.makedirs(self.data_dir, exist_ok=True)
    46: 
    47:         # Instance CCXT (async)
    48:         self.ex = ccxt.bitget({
    49:             "apiKey": api_key or "",
    50:             "secret": secret or "",
    51:             "password": password or "",
    52:             "enableRateLimit": True,
    53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
    54:         })
    55: 
    56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
    57:         self._markets_task: Optional[asyncio.Task[Any]] = None
    58: 
    59:     async def _ensure_markets(self) -> None:
    60:         if self._markets_task is None:
    61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
    62:         await self._markets_task
    63: 
    64:     # ---------- CSV cache ----------
    65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
    66:         safe = symbol.replace("/", "").replace(":", "")
    67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
    68: 
    69:     def _read_cache(self, path: str) -> List[List[float]]:
    70:         if not os.path.exists(path):
    71:             return []
    72:         rows: List[List[float]] = []
    73:         try:
    74:             with open(path, "r", newline="") as f:
    75:                 rd = csv.reader(f)
    76:                 for r in rd:
    77:                     if not r:
    78:                         continue
    79:                     # ts, o, h, l, c, v
    80:                     try:
    81:                         rows.append([
    82:                             int(r[0]),
    83:                             float(r[1]),
    84:                             float(r[2]),
    85:                             float(r[3]),
    86:                             float(r[4]),
    87:                             float(r[5]),
    88:                         ])
    89:                     except Exception:
    90:                         # on ignore les lignes corrompues
    91:                         continue
    92:         except Exception:
    93:             return []
    94:         return rows
    95: 
    96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
    97:         # On ré‑écrit intégralement (simple et sûr)
    98:         tmp = path + ".tmp"
    99:         with open(tmp, "w", newline="") as f:
   100:             wr = csv.writer(f)
   101:             wr.writerows(data)
   102:         os.replace(tmp, path)
   103: 
   104:     # ---------- API publique pour orchestrateur ----------
   105:     async def fetch_ohlcv(
   106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
   107:     ) -> List[List[float]]:
   108:         """
   109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
   110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
   111:         """
   112:         await self._ensure_markets()
   113: 
   114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
   115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
   116:         cache_path = self._csv_path(symbol, timeframe)
   117: 
   118:         # 1) Cache
   119:         if self.use_cache:
   120:             cached = self._read_cache(cache_path)
   121:             if cached:
   122:                 # fraicheur = diff entre maintenant et ts dernière bougie
   123:                 last_ts = int(cached[-1][0])
   124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
   125:                     # suffisant => on retourne la fin
   126:                     if len(cached) >= limit:
   127:                         return cached[-limit:]
   128:                     # pas assez, on essaiera de compléter via CCXT plus bas
   129:                 # sinon: on tentera de rafraîchir plus loin
   130: 
   131:         # 2) Remote via CCXT
   132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
   133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
   134:         params: dict[str, Any] = {}
   135:         if self.spot is True:
   136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
   137: 
   138:         try:
   139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
   140:         except Exception as e:  # noqa: BLE001
   141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
   142:             cached = self._read_cache(cache_path) if self.use_cache else []
   143:             if cached:
   144:                 return cached[-limit:]
   145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
   146: 
   147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
   148:         if self.use_cache:
   149:             base = self._read_cache(cache_path)
   150:             merged = _merge_ohlcv(base, ohlcv)
   151:             self._write_cache(cache_path, merged)
   152:             # retourne la fin
   153:             return merged[-limit:]
   154: 
   155:         return ohlcv[-limit:]
   156: 
   157:     async def close(self) -> None:
   158:         try:
   159:             await self.ex.close()
   160:         except Exception:
   161:             pass
   162: 
   163: 
   164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
   165:     """
   166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
   167:     """
   168:     if not a:
   169:         return list(b)
   170:     if not b:
   171:         return list(a)
   172: 
   173:     # index rapide par ts
   174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
   175:     for row in b:
   176:         by_ts[int(row[0])] = row
   177:     return [by_ts[k] for k in sorted(by_ts)]

## scalper/exchange/fees.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/exchange/fees.py
     2: from __future__ import annotations
     3: 
     4: from typing import Dict, Iterable
     5: 
     6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
     7: DEFAULT_TAKER_BPS = 6    # 0.06%
     8: DEFAULT_MAKER_BPS = 2    # 0.02%
     9: 
    10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
    11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
    12: 
    13: 
    14: def get_fee(symbol: str, kind: str = "taker") -> float:
    15:     """
    16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
    17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
    18:     """
    19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
    20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
    21:     return float(bps) / 10_000.0
    22: 
    23: 
    24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
    25:     """
    26:     Tente de charger les frais auprès de l'exchange (type ccxt):
    27:       - fetch_trading_fees(symbols) si dispo
    28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
    29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
    30:     """
    31:     symbols = list(symbols)
    32:     fees: Dict[str, Dict[str, float]] = {}
    33: 
    34:     try:
    35:         if hasattr(exchange, "fetch_trading_fees"):
    36:             data = await exchange.fetch_trading_fees(symbols)
    37:             for s in symbols:
    38:                 d = (data or {}).get(s, {}) or {}
    39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    42:         else:
    43:             for s in symbols:
    44:                 try:
    45:                     d = await exchange.fetch_trading_fee(s)
    46:                 except Exception:
    47:                     d = {}
    48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    51:     except Exception:
    52:         # fallback: défauts
    53:         for s in symbols:
    54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
    55: 
    56:     # maj du cache
    57:     _FEES_BY_SYMBOL.update(fees)
    58:     return fees

## scalper/hooks/prewarm_cache.py (last modified: 2025-08-24 10:15:51)
     1: # -*- coding: utf-8 -*-
     2: """
     3: Pré-chauffe léger du cache OHLCV.
     4: 
     5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
     6: pour chaque symbole, et on s'assure que le dossier data existe.
     7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
     8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
     9: signature.
    10: """
    11: from __future__ import annotations
    12: from pathlib import Path
    13: from typing import Iterable
    14: 
    15: 
    16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
    17:     out = Path(out_dir)
    18:     out.mkdir(parents=True, exist_ok=True)
    19:     for sym in symbols:
    20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
    21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
    22:         print(f"[cache] warmup OK for {sym}")

## scalper/live/__init__.py (last modified: 2025-08-24 10:15:51)
     1: __all__ = ["orchestrator", "fetcher", "runner"]

## scalper/live/backtest_telegram.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/backtest_telegram.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import os
     6: from typing import List
     7: 
     8: from scalper.backtest import BTCfg, run_multi
     9: from scalper.services.utils import safe_call
    10: 
    11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
    12: async def _get_exchange():
    13:     try:
    14:         import ccxt.async_support as ccxt  # type: ignore
    15:     except Exception:
    16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
    17:     return ccxt.bitget()
    18: 
    19: def _parse_symbols(defaults: List[str]) -> List[str]:
    20:     env = os.getenv("BACKTEST_SYMBOLS", "")
    21:     if env.strip():
    22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
    23:     return defaults
    24: 
    25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
    26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
    27:     symbols = _parse_symbols(defaults)
    28:     cash = float(os.getenv("BT_CASH", "10000"))
    29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
    30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
    31:     limit = int(os.getenv("BT_LIMIT", "1500"))
    32: 
    33:     await notifier.send(
    34:         "🧪 Backtest en cours...\n"
    35:         f"• Symbols: {', '.join(symbols)}\n"
    36:         f"• TF: {timeframe}\n"
    37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
    38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
    39:     )
    40: 
    41:     async def _run():
    42:         exchange = await _get_exchange()
    43:         try:
    44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
    45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
    46:             res = await run_multi(cfg, exchange)
    47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
    48:         finally:
    49:             try:
    50:                 await exchange.close()
    51:             except Exception:
    52:                 pass
    53: 
    54:     try:
    55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
    56:     except Exception as e:
    57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")

## scalper/live/commands.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/commands.py
     2: from __future__ import annotations
     3: from typing import Any, AsyncIterator, Dict
     4: 
     5: async def command_stream() -> AsyncIterator[Dict[str, Any]]:
     6:     # Exemple: brancher une vraie source d’événements/commandes ici si besoin.
     7:     while False:
     8:         yield {}

## scalper/live/data_utils.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/data_utils.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Sequence
     4: 
     5: Cols = ("timestamp", "open", "high", "low", "close", "volume")
     6: 
     7: def ohlcv_rows_to_dict(rows: Sequence[Sequence[float]]) -> Dict[str, List[float]]:
     8:     """
     9:     Convertit [[ts,o,h,l,c,v], ...] -> dict de listes.
    10:     Tolère float|int|str numériques.
    11:     """
    12:     out: Dict[str, List[float]] = {k: [] for k in Cols}
    13:     for r in rows:
    14:         if len(r) < 6:
    15:             raise ValueError("Ligne OHLCV invalide (6 colonnes attendues).")
    16:         out["timestamp"].append(float(r[0]))
    17:         out["open"].append(float(r[1]))
    18:         out["high"].append(float(r[2]))
    19:         out["low"].append(float(r[3]))
    20:         out["close"].append(float(r[4]))
    21:         out["volume"].append(float(r[5]))
    22:     return out
    23: 
    24: def ohlcv_df_or_dict_to_dict(obj) -> Dict[str, List[float]]:
    25:     """
    26:     Accepte:
    27:       - pandas.DataFrame avec colonnes Cols
    28:       - dict de listes
    29:     """
    30:     if hasattr(obj, "columns"):
    31:         missing = [c for c in Cols if c not in obj.columns]
    32:         if missing:
    33:             raise ValueError(f"Colonnes OHLCV manquantes: {missing}")
    34:         return {k: [float(x) for x in obj[k].tolist()] for k in Cols}
    35:     if isinstance(obj, dict):
    36:         missing = [c for c in Cols if c not in obj]
    37:         if missing:
    38:             raise ValueError(f"Clés OHLCV manquantes: {missing}")
    39:         return {k: [float(x) for x in obj[k]] for k in Cols}
    40:     raise TypeError("Format OHLCV non supporté (DataFrame ou dict attendu).")
    41: 
    42: def map_index_secondary(ts_main: float, ts_arr: List[float]) -> int:
    43:     """
    44:     Retourne l'index i du timestamp secondaire le plus proche
    45:     inférieur/égal à ts_main. Recherche linéaire suffisante en live.
    46:     """
    47:     j = 0
    48:     n = len(ts_arr)
    49:     while j + 1 < n and ts_arr[j + 1] <= ts_main:
    50:         j += 1
    51:     return j

## scalper/live/fetcher.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/fetcher.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional, Any
     4: 
     5: class DataFetcher:
     6:     """
     7:     Récupération OHLCV depuis un client d'exchange.
     8:     Compatible:
     9:       - Wrapper custom: client.get_ohlcv(symbol, timeframe, limit)
    10:       - ccxt direct:    client.fetch_ohlcv(symbol, timeframe=..., limit=...)
    11:     Retour standardisé: dict[str, list[float]] avec clés:
    12:       timestamp, open, high, low, close, volume
    13:     """
    14:     def __init__(self, client: Any) -> None:
    15:         self.client = client
    16:         # Détection des méthodes disponibles
    17:         self._has_get = hasattr(client, "get_ohlcv")
    18:         self._has_fetch = hasattr(client, "fetch_ohlcv")
    19: 
    20:         if not (self._has_get or self._has_fetch):
    21:             raise AttributeError(
    22:                 "Le client exchange doit exposer get_ohlcv(...) ou fetch_ohlcv(...). "
    23:                 "Ex: wrapper custom ou objet ccxt.bitget."
    24:             )
    25: 
    26:     @staticmethod
    27:     def _to_dict(rows: List[List[float]]) -> Dict[str, List[float]]:
    28:         cols = ("timestamp", "open", "high", "low", "close", "volume")
    29:         out = {k: [] for k in cols}
    30:         for r in rows:
    31:             # rows: [ts, open, high, low, close, volume]
    32:             out["timestamp"].append(float(r[0]))
    33:             out["open"].append(float(r[1]))
    34:             out["high"].append(float(r[2]))
    35:             out["low"].append(float(r[3]))
    36:             out["close"].append(float(r[4]))
    37:             out["volume"].append(float(r[5]))
    38:         return out
    39: 
    40:     def fetch(self, symbol: str, timeframe: str, limit: int = 1500) -> Dict[str, List[float]]:
    41:         if self._has_get:
    42:             rows = self.client.get_ohlcv(symbol=symbol, timeframe=timeframe, limit=limit)
    43:         else:
    44:             # ccxt: fetch_ohlcv(symbol, timeframe=..., limit=...)
    45:             rows = self.client.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    46:         return self._to_dict(rows)
    47: 
    48:     def try_fetch_1h(self, symbol: str, limit: int = 1500) -> Optional[Dict[str, List[float]]]:
    49:         try:
    50:             if self._has_get:
    51:                 rows = self.client.get_ohlcv(symbol=symbol, timeframe="1h", limit=limit)
    52:             else:
    53:                 rows = self.client.fetch_ohlcv(symbol, timeframe="1h", limit=limit)
    54:             return self._to_dict(rows)
    55:         except Exception:
    56:             return None

## scalper/live/journal.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: import os, csv
     3: from typing import Any, Dict, List
     4: 
     5: class LogWriter:
     6:     """Gestion simple des CSV (création à la volée + append)."""
     7:     def __init__(self, dirpath: str) -> None:
     8:         self.dir = dirpath
     9:         os.makedirs(self.dir, exist_ok=True)
    10: 
    11:     def init(self, fname: str, headers: List[str]) -> None:
    12:         p = os.path.join(self.dir, fname)
    13:         if not os.path.exists(p):
    14:             with open(p, "w", newline="", encoding="utf-8") as f:
    15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
    16: 
    17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
    18:         p = os.path.join(self.dir, fname)
    19:         with open(p, "a", newline="", encoding="utf-8") as f:
    20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)

## scalper/live/logs.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/live/logs.py
     2: from __future__ import annotations
     3: import os, csv
     4: from typing import Any, List, Dict
     5: 
     6: class CsvLog:
     7:     def __init__(self, path: str, headers: List[str]):
     8:         self.path = path
     9:         self.headers = headers
    10:         self._ensure_header()
    11: 
    12:     def _ensure_header(self):
    13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
    14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
    15:         if must_write:
    16:             with open(self.path, "w", newline="") as f:
    17:                 csv.writer(f).writerow(self.headers)
    18: 
    19:     def write_row(self, row: Dict[str, Any]):
    20:         with open(self.path, "a", newline="") as f:
    21:             w = csv.DictWriter(f, fieldnames=self.headers)
    22:             w.writerow({k: row.get(k, "") for k in self.headers})

## scalper/live/loops/trade.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/live/loops/trade.py
     2: from __future__ import annotations
     3: import asyncio, os
     4: from dataclasses import dataclass, field
     5: from typing import Any, Dict, List, Callable
     6: 
     7: from ...services.utils import safe_call
     8: from ...risk.manager import compute_size
     9: 
    10: QUIET = int(os.getenv("QUIET", "0") or "0")
    11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
    12: 
    13: class PositionFSM:
    14:     def __init__(self):
    15:         self.state = "FLAT"
    16:         self.side = "flat"
    17:         self.entry = 0.0
    18:         self.qty = 0.0
    19:     def can_open(self): return self.state == "FLAT"
    20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
    21:     def can_close(self): return self.state == "OPEN"
    22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
    23: 
    24: @dataclass
    25: class SymbolContext:
    26:     symbol: str
    27:     timeframe: str
    28:     ohlcv: List[List[float]] = field(default_factory=list)
    29:     ticks: int = 0
    30:     fsm: PositionFSM = field(default_factory=PositionFSM)
    31: 
    32: class TradeLoop:
    33:     """
    34:     Boucle par symbole, indépendante de l'orchestrateur.
    35:     """
    36:     def __init__(
    37:         self,
    38:         symbol: str,
    39:         timeframe: str,
    40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
    41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
    42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
    43:         config: Dict[str, Any],
    44:         mode_getter: Callable[[], str],
    45:         log_signals, log_orders, log_fills,
    46:         tick_counter_add: Callable[[int], None],
    47:     ):
    48:         self.symbol = symbol
    49:         self.timeframe = timeframe
    50:         self.fetch = ohlcv_fetch
    51:         self.order_market = order_market
    52:         self.generate_signal = generate_signal
    53:         self.config = config
    54:         self.get_mode = mode_getter
    55:         self.log_signals = log_signals
    56:         self.log_orders = log_orders
    57:         self.log_fills = log_fills
    58:         self.ctx = SymbolContext(symbol, timeframe)
    59:         self._tick_add = tick_counter_add
    60: 
    61:         # Risk/frais
    62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
    63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
    64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
    65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
    66: 
    67:     def _bps_for(self, order_type: str = "market") -> float:
    68:         # market -> taker; limit post-only -> maker
    69:         per = self.fees_map.get(self.symbol, {})
    70:         if order_type == "limit":
    71:             return float(per.get("maker_bps", 0.0))
    72:         return float(per.get("taker_bps", 0.0))
    73: 
    74:     async def run(self, running: Callable[[], bool]):
    75:         lookback = 200
    76:         while running():
    77:             if self.get_mode() != "RUNNING":
    78:                 await asyncio.sleep(0.5); continue
    79: 
    80:             async def _fetch():
    81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
    82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
    83:             if not ohlcv or len(ohlcv) < lookback+1:
    84:                 await asyncio.sleep(1.0); continue
    85: 
    86:             self.ctx.ohlcv = ohlcv
    87:             self.ctx.ticks += 1
    88:             self._tick_add(1)
    89: 
    90:             window = ohlcv[-(lookback+1):]
    91:             ts, _o, _h, _l, c, _v = window[-1]
    92: 
    93:             try:
    94:                 sig = self.generate_signal(window, self.config) or {}
    95:             except Exception as e:
    96:                 if not QUIET:
    97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
    98:                 await asyncio.sleep(0.5); continue
    99: 
   100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
   101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
   102: 
   103:             # --- Entrée (market -> taker)
   104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
   105:                 balance = float(self.config.get("cash", 10_000.0))
   106:                 qty = compute_size(
   107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
   108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
   109:                 )
   110:                 if qty > 0:
   111:                     async def _place():
   112:                         return await self.order_market(self.symbol, side, qty)
   113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
   114:                     self.ctx.fsm.on_open(side, entry or c, qty)
   115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
   116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
   117: 
   118:             # --- Sortie (market -> taker)
   119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
   120:                 qty = self.ctx.fsm.qty
   121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
   122:                 async def _close():
   123:                     return await self.order_market(self.symbol, exit_side, qty)
   124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
   125: 
   126:                 # fill avec slippage + frais (taker)
   127:                 price_fill = float(c)
   128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
   129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
   130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
   131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
   132:                                           "order_id": (order or {}).get("id","")})
   133:                 self.ctx.fsm.on_close()
   134: 
   135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
   136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
   137: 
   138:             await asyncio.sleep(0.1 if QUIET else 0.01)

## scalper/live/notify.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/notify.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import json
     6: import logging
     7: import os
     8: from typing import Any, AsyncIterator, Dict, Optional
     9: 
    10: import requests
    11: 
    12: log = logging.getLogger("scalper.live.notify")
    13: 
    14: 
    15: class _NullNotifier:
    16:     async def send(self, text: str) -> None:
    17:         log.info("[NOTIFY] %s", text)
    18: 
    19: 
    20: class TelegramNotifier:
    21:     def __init__(self, token: str, chat_id: str, timeout: float = 5.0) -> None:
    22:         self.token = token
    23:         self.chat_id = chat_id
    24:         self.timeout = timeout
    25: 
    26:     async def send(self, text: str) -> None:
    27:         url = f"https://api.telegram.org/bot{self.token}/sendMessage"
    28:         payload = {"chat_id": self.chat_id, "text": text}
    29:         try:
    30:             # Appel sync dans thread pour rester simple
    31:             def _post() -> None:
    32:                 requests.post(url, json=payload, timeout=self.timeout)
    33:             loop = asyncio.get_running_loop()
    34:             await loop.run_in_executor(None, _post)
    35:         except Exception:
    36:             log.debug("Envoi Telegram échoué", exc_info=True)
    37: 
    38: 
    39: async def _command_stream_stub() -> AsyncIterator[Dict[str, Any]]:
    40:     """
    41:     Générateur de commandes vide (placeholder).
    42:     Peut être remplacé par une vraie source (websocket, telegram callbacks, etc.).
    43:     """
    44:     while False:
    45:         yield {}
    46: 
    47: 
    48: def build_notifier_and_commands(cfg: Dict[str, Any] | None = None) -> tuple[Any, AsyncIterator[Dict[str, Any]] | None]:
    49:     """
    50:     Retourne (notifier, command_stream)
    51:     - Notifier Telegram si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID présents, sinon Null.
    52:     - Flux de commandes: stub None (l’orchestrateur gère le None).
    53:     """
    54:     token = os.getenv("TELEGRAM_BOT_TOKEN") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("token")
    55:     chat_id = os.getenv("TELEGRAM_CHAT_ID") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("chat_id")
    56: 
    57:     if token and chat_id:
    58:         return TelegramNotifier(token, chat_id), None
    59:     return _NullNotifier(), None

## scalper/live/ohlcv_service.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: import time
     3: from typing import Any, Dict, List, Optional
     4: 
     5: try:
     6:     from scalper.adapters.market_data import MarketData
     7: except Exception:
     8:     MarketData = None  # type: ignore
     9: 
    10: class OhlcvService:
    11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
    12:     def __init__(self, exchange) -> None:
    13:         self.exchange = exchange
    14:         self.md = MarketData(exchange) if MarketData is not None else None
    15: 
    16:     @staticmethod
    17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
    18:         out: List[Dict[str, float]] = []
    19:         if not rows: return out
    20:         for r in rows:
    21:             if isinstance(r, dict):
    22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
    23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
    24:                 v = float(r.get("volume", r.get("vol", 0.0)))
    25:             else:
    26:                 rr = list(r)
    27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
    28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
    29:                 else:
    30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
    31:                     h = float(rr[1]) if len(rr) > 1 else o
    32:                     l = float(rr[2]) if len(rr) > 2 else o
    33:                     c = float(rr[3]) if len(rr) > 3 else o
    34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
    35:                     ts = int(rr[5]) if len(rr) > 5 else 0
    36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
    37:         return out
    38: 
    39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
    40:         # 1) MarketData (si dispo)
    41:         if self.md is not None:
    42:             try:
    43:                 d = self.md.get_ohlcv(symbol, interval, limit)
    44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
    45:                     return self.normalize_rows(d["data"])
    46:             except Exception:
    47:                 pass
    48: 
    49:         # 2) Exchange natif
    50:         rows: List[Any] = []
    51:         try:
    52:             data = self.exchange.get_kline(symbol, interval=interval)
    53:         except Exception:
    54:             data = None
    55: 
    56:         if isinstance(data, dict):
    57:             rows = (
    58:                 data.get("data") or data.get("result") or data.get("records") or
    59:                 data.get("list") or data.get("items") or data.get("candles") or []
    60:             )
    61:             guard = 0
    62:             while isinstance(rows, dict) and guard < 3:
    63:                 rows = (
    64:                     rows.get("data") or rows.get("result") or rows.get("records") or
    65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
    66:                 )
    67:                 guard += 1
    68:         elif isinstance(data, (list, tuple)):
    69:             rows = list(data)
    70: 
    71:         out = self.normalize_rows(rows)[-limit:]
    72:         if out: return out
    73: 
    74:         # 3) Fallback strict via ticker -> bougie synthétique
    75:         try:
    76:             tkr = self.exchange.get_ticker(symbol)
    77:             items = []
    78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
    79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
    80:             if items:
    81:                 last = items[0]
    82:                 if isinstance(last, dict):
    83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
    84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
    85:                 else:
    86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
    87:                 ts = int(time.time()*1000)
    88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
    89:         except Exception:
    90:             pass
    91:         return []

## scalper/live/orchestrator.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/orchestrator.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import dataclasses
     6: import logging
     7: import time
     8: from dataclasses import dataclass
     9: from pathlib import Path
    10: from typing import Any, AsyncIterator, Iterable, List, Optional, Sequence, Tuple
    11: 
    12: log = logging.getLogger("scalper.live.orchestrator")
    13: 
    14: 
    15: # -----------------------------------------------------------------------------
    16: # Contrat d'exécution
    17: # -----------------------------------------------------------------------------
    18: @dataclass(slots=True)
    19: class RunConfig:
    20:     symbols: Sequence[str]
    21:     timeframe: str = "1m"
    22:     refresh_secs: int = 5
    23:     cache_dir: str = "/notebooks/data"
    24: 
    25: 
    26: # -----------------------------------------------------------------------------
    27: # Utils
    28: # -----------------------------------------------------------------------------
    29: def _ensure_dir(p: str | Path) -> Path:
    30:     path = Path(p)
    31:     path.mkdir(parents=True, exist_ok=True)
    32:     return path
    33: 
    34: 
    35: def _ts_ms() -> int:
    36:     return int(time.time() * 1000)
    37: 
    38: 
    39: def _parse_last_price_from_ohlcv(ohlcv: List[List[float]]) -> float:
    40:     # OHLCV format attendu : [ts, open, high, low, close, volume]
    41:     if not ohlcv:
    42:         return 0.0
    43:     row = ohlcv[-1]
    44:     try:
    45:         return float(row[4])
    46:     except Exception:
    47:         return 0.0
    48: 
    49: 
    50: # -----------------------------------------------------------------------------
    51: # Abstraction d'accès OHLCV
    52: # -----------------------------------------------------------------------------
    53: async def _fetch_ohlcv_any(
    54:     exchange: Any, symbol: str, timeframe: str, limit: int = 150
    55: ) -> List[List[float]]:
    56:     """
    57:     Essaie, dans l'ordre :
    58:       1) exchange.fetch_ohlcv(symbol, timeframe, limit=..)
    59:       2) exchange.get_klines(symbol, interval=.., limit=..)
    60:     Retourne une liste de bougies [ts, o, h, l, c, v] (liste de listes).
    61:     """
    62:     # 1) Style CCXT
    63:     fetch = getattr(exchange, "fetch_ohlcv", None)
    64:     if callable(fetch):
    65:         try:
    66:             data = await fetch(symbol, timeframe, limit=limit)  # type: ignore[arg-type]
    67:             # data CCXT: [[ts, open, high, low, close, volume], ...]
    68:             return list(data or [])
    69:         except TypeError:
    70:             # si fetch_ohlcv est sync
    71:             data = fetch(symbol, timeframe, limit=limit)  # type: ignore[misc]
    72:             return list(data or [])
    73:         except Exception as exc:
    74:             log.debug("fetch_ohlcv CCXT a échoué (%s), on tente REST", exc)
    75: 
    76:     # 2) REST interne
    77:     get_klines = getattr(exchange, "get_klines", None)
    78:     if callable(get_klines):
    79:         try:
    80:             resp = get_klines(symbol, interval=timeframe, limit=int(limit))
    81:             rows = resp.get("data") or []
    82:             out: List[List[float]] = []
    83:             for r in rows:
    84:                 # API Bitget mix candles renvoie souvent: [start, open, high, low, close, volume, ...]
    85:                 try:
    86:                     ts = int(r[0])
    87:                     o = float(r[1])
    88:                     h = float(r[2])
    89:                     l = float(r[3])
    90:                     c = float(r[4])
    91:                     v = float(r[5]) if len(r) > 5 else 0.0
    92:                     out.append([ts, o, h, l, c, v])
    93:                 except Exception:
    94:                     continue
    95:             out.sort(key=lambda x: x[0])
    96:             return out
    97:         except Exception as exc:
    98:             log.warning("get_klines REST a échoué pour %s (%s)", symbol, exc)
    99: 
   100:     return []
   101: 
   102: 
   103: # -----------------------------------------------------------------------------
   104: # Notifier minimal (duck-typed)
   105: # -----------------------------------------------------------------------------
   106: class _NullNotifier:
   107:     async def send(self, text: str) -> None:
   108:         log.info("[NOTIFY] %s", text)
   109: 
   110: 
   111: # -----------------------------------------------------------------------------
   112: # Journalisation légère (CSV dans cache_dir/logs)
   113: # -----------------------------------------------------------------------------
   114: def _csv_row(path: Path, headers: Sequence[str], row: Sequence[Any]) -> None:
   115:     path.parent.mkdir(parents=True, exist_ok=True)
   116:     new = not path.exists()
   117:     with path.open("a", encoding="utf-8") as f:
   118:         if new:
   119:             f.write(",".join(headers) + "\n")
   120:         vals = []
   121:         for v in row:
   122:             if isinstance(v, str):
   123:                 vals.append(v.replace(",", " "))
   124:             else:
   125:                 vals.append(str(v))
   126:         f.write(",".join(vals) + "\n")
   127: 
   128: 
   129: # -----------------------------------------------------------------------------
   130: # Boucle principale
   131: # -----------------------------------------------------------------------------
   132: async def run_orchestrator(
   133:     exchange: Any,
   134:     cfg: RunConfig,
   135:     notifier: Any | None = None,
   136:     command_stream: AsyncIterator[dict] | None = None,
   137: ) -> None:
   138:     """
   139:     Boucle asynchrone simple :
   140:       - fetch OHLCV par symbole
   141:       - journalise un signal minimal (dernier close)
   142:       - notifications heartbeat
   143:       - support d'un flux de commandes (facultatif)
   144:     """
   145:     notifier = notifier or _NullNotifier()
   146:     cache_dir = _ensure_dir(cfg.cache_dir)
   147:     log_dir = _ensure_dir(cache_dir / "live" / "logs")
   148: 
   149:     log.info("RunConfig: tf=%s symbols=%s refresh=%ss cache=%s",
   150:              cfg.timeframe, ",".join(cfg.symbols), cfg.refresh_secs, cache_dir)
   151: 
   152:     # Heartbeat initial
   153:     try:
   154:         await notifier.send(f"Bot démarré • tf={cfg.timeframe} • {len(cfg.symbols)} symboles")
   155:     except Exception:
   156:         log.debug("Notifier indisponible au démarrage", exc_info=True)
   157: 
   158:     # Prépare fichiers CSV
   159:     sig_path = log_dir / "signals.csv"
   160: 
   161:     async def _handle_commands() -> None:
   162:         if command_stream is None:
   163:             return
   164:         async for cmd in command_stream:
   165:             try:
   166:                 kind = (cmd.get("type") or "").lower()
   167:                 if kind == "ping":
   168:                     await notifier.send("pong")
   169:                 elif kind == "symbols.set":
   170:                     new_syms = cmd.get("payload") or []
   171:                     if isinstance(new_syms, (list, tuple)) and new_syms:
   172:                         cfg.symbols = list(map(str, new_syms))  # type: ignore[assignment]
   173:                         await notifier.send(f"Watchlist mise à jour ({len(cfg.symbols)})")
   174:                 else:
   175:                     await notifier.send(f"Commande inconnue: {cmd!r}")
   176:             except Exception:
   177:                 log.exception("Erreur traitement commande: %s", cmd)
   178: 
   179:     async def _tick_once() -> None:
   180:         ts = _ts_ms()
   181:         for sym in cfg.symbols:
   182:             ohlcv = await _fetch_ohlcv_any(exchange, sym, cfg.timeframe, limit=200)
   183:             price = _parse_last_price_from_ohlcv(ohlcv)
   184:             if price <= 0:
   185:                 continue
   186:             # journal minimal
   187:             _csv_row(
   188:                 sig_path,
   189:                 headers=["ts", "symbol", "price", "timeframe"],
   190:                 row=[ts, sym, price, cfg.timeframe],
   191:             )
   192:             log.debug("tick %s %s -> %s", cfg.timeframe, sym, price)
   193: 
   194:     # Boucle
   195:     last_hb = 0.0
   196:     try:
   197:         while True:
   198:             # commands (non bloquant)
   199:             cmd_task = asyncio.create_task(_handle_commands())
   200:             await _tick_once()
   201:             cmd_task.cancel()
   202: 
   203:             now = time.time()
   204:             if now - last_hb > max(30, cfg.refresh_secs * 6):
   205:                 try:
   206:                     await notifier.send("Listing ok ✅")
   207:                 except Exception:
   208:                     pass
   209:                 last_hb = now
   210: 
   211:             await asyncio.sleep(max(1, int(cfg.refresh_secs)))
   212:     except asyncio.CancelledError:
   213:         raise
   214:     except KeyboardInterrupt:
   215:         log.info("Arrêt orchestrateur (Ctrl+C)")
   216:     except Exception:
   217:         log.exception("Erreur orchestrateur")
   218:     finally:
   219:         try:
   220:             await notifier.send("Bot arrêté proprement 📴")
   221:         except Exception:
   222:             pass

## scalper/live/orders.py (last modified: 2025-08-24 10:15:51)
     1: # live/orders.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Any, Optional
     5: 
     6: from scalper.services.order_service import OrderService, OrderRequest
     7: 
     8: @dataclass
     9: class OrderResult:
    10:     accepted: bool
    11:     order_id: str | None = None
    12:     status: str | None = None
    13:     reason: str | None = None
    14: 
    15: class OrderExecutor:
    16:     """
    17:     Fine couche autour d'OrderService + exchange :
    18:       - calcule l'équité USDT
    19:       - place une entrée (risk_pct)
    20:       - récupère les fills (normalisés)
    21:     L'orchestrateur n’appelle plus OrderService directement.
    22:     """
    23: 
    24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
    25:         self.order_service = order_service
    26:         self.exchange = exchange
    27:         self.config = config
    28: 
    29:     # ---------- Equity ----------
    30:     def get_equity_usdt(self) -> float:
    31:         equity = 0.0
    32:         try:
    33:             assets = self.exchange.get_assets()
    34:             if isinstance(assets, dict):
    35:                 for a in (assets.get("data") or []):
    36:                     if str(a.get("currency")).upper() == "USDT":
    37:                         equity = float(a.get("equity", 0.0))
    38:                         break
    39:         except Exception:
    40:             pass
    41:         return equity
    42: 
    43:     # ---------- Entrée ----------
    44:     def place_entry(self, *, symbol: str, side: str, price: float,
    45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
    46:         """
    47:         side: 'long' | 'short'
    48:         Retourne OrderResult(accepted, order_id, status, reason)
    49:         """
    50:         equity = self.get_equity_usdt()
    51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
    52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
    53:                            risk_pct=float(risk_pct))
    54:         try:
    55:             res = self.order_service.prepare_and_place(equity, req)
    56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
    57:                                order_id=getattr(res, "order_id", None),
    58:                                status=getattr(res, "status", None),
    59:                                reason=getattr(res, "reason", None))
    60:         except Exception as e:
    61:             return OrderResult(accepted=False, reason=str(e))
    62: 
    63:     # ---------- Fills ----------
    64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
    65:         """
    66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
    67:         """
    68:         try:
    69:             raw = self.exchange.get_fills(symbol, order_id, limit)
    70:         except Exception:
    71:             return []
    72: 
    73:         items: list = []
    74:         if isinstance(raw, dict):
    75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
    76:         elif isinstance(raw, (list, tuple)):
    77:             items = list(raw)
    78: 
    79:         out: list[dict] = []
    80:         for f in items:
    81:             if isinstance(f, dict):
    82:                 out.append({
    83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
    84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
    85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
    86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
    87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
    88:                 })
    89:             else:
    90:                 try:
    91:                     seq = list(f)
    92:                     out.append({
    93:                         "orderId": str(seq[0]) if seq else "",
    94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
    95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
    96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
    97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
    98:                     })
    99:                 except Exception:
   100:                     continue
   101:         return out

## scalper/live/position_fsm.py (last modified: 2025-08-24 10:15:51)
     1: # live/position_fsm.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any, List
     5: 
     6: 
     7: STATE_FLAT = "FLAT"
     8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
     9: STATE_OPEN = "OPEN"
    10: STATE_PENDING_EXIT = "PENDING_EXIT"
    11: 
    12: 
    13: @dataclass
    14: class PositionState:
    15:     symbol: str
    16:     state: str = STATE_FLAT
    17:     order_id: Optional[str] = None
    18:     side: Optional[str] = None   # "long" | "short"
    19:     qty: float = 0.0
    20:     entry: float = 0.0
    21: 
    22: 
    23: class PositionFSM:
    24:     """
    25:     FSM ultra-simple par symbole.
    26:     - set_pending_entry(order_id, side)
    27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
    28:     """
    29: 
    30:     def __init__(self, symbols: List[str]) -> None:
    31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
    32: 
    33:     # -------- API utilisateur --------
    34:     def ensure_symbol(self, symbol: str) -> None:
    35:         if symbol not in self._by_symbol:
    36:             self._by_symbol[symbol] = PositionState(symbol)
    37: 
    38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
    39:         self.ensure_symbol(symbol)
    40:         st = self._by_symbol[symbol]
    41:         st.state = STATE_PENDING_ENTRY
    42:         st.order_id = order_id
    43:         st.side = side
    44: 
    45:     def mark_pending_exit(self, symbol: str) -> None:
    46:         self.ensure_symbol(symbol)
    47:         st = self._by_symbol[symbol]
    48:         st.state = STATE_PENDING_EXIT
    49: 
    50:     def force_flat(self, symbol: str) -> None:
    51:         self._by_symbol[symbol] = PositionState(symbol)
    52: 
    53:     # -------- Lecture --------
    54:     def get(self, symbol: str) -> PositionState:
    55:         self.ensure_symbol(symbol)
    56:         return self._by_symbol[symbol]
    57: 
    58:     def all(self) -> Dict[str, PositionState]:
    59:         return self._by_symbol
    60: 
    61:     # -------- Réconciliation --------
    62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
    63:         """
    64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
    65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
    66:         """
    67:         # indexer positions ouvertes
    68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
    69: 
    70:         for sym, st in self._by_symbol.items():
    71:             p = idx_open.get(sym)
    72: 
    73:             if st.state == STATE_PENDING_ENTRY:
    74:                 # si on voit des fills de l'ordre en attente -> OPEN
    75:                 f_list = fills.get(sym) or []
    76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
    77:                 if qty_filled > 0.0 or p:
    78:                     st.state = STATE_OPEN
    79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
    80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
    81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
    82:             elif st.state == STATE_OPEN:
    83:                 # si plus de position ouverte -> FLAT
    84:                 if not p:
    85:                     st.state = STATE_FLAT
    86:                     st.order_id = None
    87:                     st.side = None
    88:                     st.qty = 0.0
    89:                     st.entry = 0.0
    90:                 else:
    91:                     st.qty = float(p.get("qty", st.qty))
    92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
    93:             elif st.state == STATE_PENDING_EXIT:
    94:                 # si plus de position -> FLAT ; sinon reste OPEN
    95:                 if not p:
    96:                     st.state = STATE_FLAT
    97:                     st.order_id = None
    98:                     st.side = None
    99:                     st.qty = 0.0
   100:                     st.entry = 0.0
   101:                 else:
   102:                     st.state = STATE_OPEN  # pas encore clos
   103:             else:
   104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
   105:                 if p:
   106:                     st.state = STATE_OPEN
   107:                     st.qty = float(p.get("qty", 0.0))
   108:                     st.entry = float(p.get("avgEntryPrice", 0.0))

## scalper/live/runner.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/live/runner.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional
     4: from scalper.signals.factory import resolve_signal_fn
     5: 
     6: class JobRunner:
     7:     def __init__(self, strategies_cfg: dict, equity: float, risk_pct: float) -> None:
     8:         self.cfg = strategies_cfg
     9:         self.equity = float(equity)
    10:         self.risk = float(risk_pct)
    11: 
    12:     def run_once(
    13:         self, *, symbol: str, timeframe: str,
    14:         ohlcv: Dict[str, List[float]],
    15:         ohlcv_1h: Optional[Dict[str, List[float]]] = None
    16:     ):
    17:         fn = resolve_signal_fn(symbol, timeframe, self.cfg)
    18:         return fn(
    19:             symbol=symbol, timeframe=timeframe, ohlcv=ohlcv,
    20:             equity=self.equity, risk_pct=self.risk, ohlcv_1h=ohlcv_1h
    21:         )

## scalper/live/setup_wizard.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: import asyncio, os
     3: from dataclasses import dataclass
     4: from typing import List, Dict, Optional, Callable
     5: from ..signals.factory import load_signal
     6: from ..backtest.runner import BacktestRunner
     7: from .notify import Notifier, CommandStream
     8: 
     9: @dataclass
    10: class SetupResult:
    11:     strategy: str
    12:     symbols: List[str]
    13:     timeframes: List[str]
    14:     risk_pct: float
    15:     accepted: bool
    16:     summary_path: str
    17: 
    18: class SetupWizard:
    19:     """
    20:     Wizard interactif Telegram avant lancement des trades.
    21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
    22:     """
    23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
    24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
    25:                  admin_chat_id: Optional[int]=None):
    26:         self.notifier = notifier
    27:         self.cmd_stream = cmd_stream
    28:         self.loader = ohlcv_loader_sync
    29:         self.out_dir = out_dir
    30:         self.admin_chat_id = admin_chat_id
    31: 
    32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
    33:         await self.notifier.send_menu(prompt, choices)
    34:         async for msg in self.cmd_stream:
    35:             txt = msg.strip()
    36:             if allow_multi and ("," in txt or " " in txt):
    37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
    38:                 return sel
    39:             if txt.isdigit():
    40:                 i = int(txt)-1
    41:                 if 0 <= i < len(choices):
    42:                     return [choices[i]]
    43:             if txt in choices:
    44:                 return [txt]
    45:             await self.notifier.send("Entrée invalide. Réessaie.")
    46: 
    47:     async def _ask_value(self, prompt: str, cast: Callable, default):
    48:         await self.notifier.send(f"{prompt} (défaut: {default})")
    49:         async for msg in self.cmd_stream:
    50:             txt = msg.strip()
    51:             if txt == "" or txt.lower() in ("d","defaut","default"):
    52:                 return default
    53:             try:
    54:                 return cast(txt)
    55:             except Exception:
    56:                 await self.notifier.send("Entrée invalide. Réessaie.")
    57: 
    58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
    59:                   default_strategy: str="current") -> SetupResult:
    60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
    61:         # 1) stratégie
    62:         strategies = ["current","ema_cross","vwap_break"]
    63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
    64: 
    65:         # 2) symboles
    66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
    67: 
    68:         # 3) timeframes
    69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
    70: 
    71:         # 4) risk %
    72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
    73: 
    74:         # 5) période backtest
    75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
    76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
    77: 
    78:         # 6) run backtest
    79:         from ..backtest.cli import parse_ts
    80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
    81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
    82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
    83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
    84: 
    85:         # 7) résumé
    86:         sum_path = os.path.join(self.out_dir, "metrics.json")
    87:         prop = res["proposal"]
    88:         lines = ["**Proposition** :"]
    89:         for sym, best in prop["per_symbol_best"].items():
    90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
    91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
    92: 
    93:         # 8) décision
    94:         async for msg in self.cmd_stream:
    95:             t = msg.strip().lower()
    96:             if t in ("accepter","accept","ok","go","start"):
    97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
    98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
    99:             if t in ("modifier","again","repeat"):
   100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
   101:             if t in ("annuler","cancel","stop"):
   102:                 await self.notifier.send("❌ Annulé.")
   103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)

## scalper/live/state_store.py (last modified: 2025-08-24 10:15:51)
     1: # live/state_store.py
     2: from __future__ import annotations
     3: import json, os, time, asyncio
     4: from typing import Callable, Dict, Any
     5: 
     6: class StateStore:
     7:     """
     8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
     9:     - save_state(snapshot: dict) -> écrit sur disque
    10:     - load_state() -> dict
    11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
    12:     """
    13: 
    14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
    15:         self.filepath = filepath
    16:         self.period_s = period_s
    17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
    18:         self._running = False
    19: 
    20:     # -------- I/O --------
    21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
    22:         tmp = self.filepath + ".tmp"
    23:         with open(tmp, "w", encoding="utf-8") as f:
    24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
    25:         os.replace(tmp, self.filepath)
    26: 
    27:     def load_state(self) -> Dict[str, Any]:
    28:         if not os.path.exists(self.filepath):
    29:             return {}
    30:         try:
    31:             with open(self.filepath, "r", encoding="utf-8") as f:
    32:                 return json.load(f)
    33:         except Exception:
    34:             return {}
    35: 
    36:     # -------- Autosave --------
    37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
    38:         self._running = True
    39:         while self._running:
    40:             try:
    41:                 snap = get_snapshot()
    42:                 snap["saved_at"] = int(time.time() * 1000)
    43:                 self.save_state(snap)
    44:             except Exception:
    45:                 pass
    46:             await asyncio.sleep(self.period_s)
    47: 
    48:     def stop(self): self._running = False

## scalper/live/telegram_async.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: import time
     3: import requests
     4: import asyncio
     5: from typing import Optional, Dict, Any, List
     6: 
     7: 
     8: class TelegramAsync:
     9:     """
    10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
    11:     Sans nouvelle dépendance.
    12:     """
    13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
    14:         self.token = token
    15:         self.chat_id = chat_id
    16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
    17:         self._offset = 0
    18:         self._enabled = bool(token and chat_id)
    19: 
    20:     def enabled(self) -> bool:
    21:         return self._enabled
    22: 
    23:     # ---------- sync I/O (appelées via to_thread) ----------
    24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
    25:         if not self._enabled:
    26:             return {"ok": False, "reason": "disabled"}
    27:         url = f"{self.base}/sendMessage"
    28:         payload = {"chat_id": self.chat_id, "text": text}
    29:         try:
    30:             r = requests.post(url, json=payload, timeout=10)
    31:             return r.json()
    32:         except Exception as e:
    33:             return {"ok": False, "error": repr(e)}
    34: 
    35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
    36:         if not self._enabled:
    37:             return {"ok": True, "result": []}
    38:         url = f"{self.base}/getUpdates"
    39:         params = {"timeout": timeout_s, "offset": self._offset}
    40:         try:
    41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
    42:             return r.json()
    43:         except Exception as e:
    44:             return {"ok": False, "error": repr(e), "result": []}
    45: 
    46:     # ---------- async wrappers ----------
    47:     async def send_message(self, text: str) -> None:
    48:         await asyncio.to_thread(self._send_message_sync, text)
    49: 
    50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
    51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
    52:         if not data.get("ok"):
    53:             return []
    54:         out = []
    55:         for upd in data.get("result", []):
    56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
    57:             msg = upd.get("message") or {}
    58:             text = (msg.get("text") or "").strip()
    59:             if not text:
    60:                 continue
    61:             out.append({
    62:                 "date": msg.get("date"),
    63:                 "chat": str((msg.get("chat") or {}).get("id")),
    64:                 "text": text,
    65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
    66:             })
    67:         return out


## scalper/live/watchlist.py (last modified: 2025-08-24 10:15:51)
     1: # -*- coding: utf-8 -*-
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import List
     5: 
     6: 
     7: @dataclass
     8: class WatchlistManager:
     9:     symbols: List[str]
    10: 
    11:     @classmethod
    12:     def from_env_or_default(cls) -> "WatchlistManager":
    13:         # Tu peux lire une variable d'env ici si tu veux surcharger
    14:         default = [
    15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
    16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
    17:         ]
    18:         return cls(default)

## scalper/logging_utils.py (last modified: 2025-08-24 10:15:51)
     1: """Logging helpers for the Scalp bot."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import atexit
     6: import csv
     7: import json
     8: import os
     9: import sqlite3
    10: import time
    11: from pathlib import Path
    12: from typing import Any, Dict, List
    13: 
    14: 
    15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    16:     """Return a callable that logs events as JSON lines.
    17: 
    18:     Parameters
    19:     ----------
    20:     path: str
    21:         Target file path for JSON lines.
    22:     max_bytes: int, optional
    23:         If >0, rotate the file when its size exceeds this value.
    24:     backup_count: int, optional
    25:         Number of rotated files to keep when ``max_bytes`` is set.
    26:     """
    27:     os.makedirs(os.path.dirname(path), exist_ok=True)
    28:     log_file = open(path, "a", encoding="utf-8")
    29: 
    30:     def _close_file() -> None:
    31:         try:
    32:             log_file.close()
    33:         except Exception:
    34:             pass
    35: 
    36:     atexit.register(_close_file)
    37: 
    38:     def _rotate() -> None:
    39:         nonlocal log_file
    40:         log_file.close()
    41:         for i in range(backup_count - 1, 0, -1):
    42:             src = f"{path}.{i}"
    43:             dst = f"{path}.{i + 1}"
    44:             if os.path.exists(src):
    45:                 os.replace(src, dst)
    46:         os.replace(path, f"{path}.1")
    47:         log_file = open(path, "a", encoding="utf-8")
    48: 
    49:     def _log(event: str, payload: Dict[str, Any]) -> None:
    50:         nonlocal log_file
    51:         payload = dict(payload or {})
    52:         payload["event"] = event
    53:         payload["ts"] = int(time.time() * 1000)
    54:         line = json.dumps(payload, ensure_ascii=False)
    55:         if max_bytes and backup_count > 0:
    56:             if log_file.tell() + len(line) + 1 > max_bytes:
    57:                 _rotate()
    58:         log_file.write(line + "\n")
    59:         log_file.flush()
    60: 
    61:     return _log
    62: 
    63: 
    64: class TradeLogger:
    65:     """Helper writing trade information to CSV and SQLite files."""
    66: 
    67:     fields = [
    68:         "pair",
    69:         "tf",
    70:         "dir",
    71:         "entry",
    72:         "sl",
    73:         "tp",
    74:         "score",
    75:         "reasons",
    76:         "pnl",
    77:     ]
    78: 
    79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
    80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
    81:         self.csv_path = csv_path
    82:         self.sqlite_path = sqlite_path
    83: 
    84:         # Ensure CSV has header
    85:         if not os.path.exists(csv_path):
    86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
    87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
    88:                 writer.writeheader()
    89: 
    90:         # Setup SQLite store
    91:         self.conn = sqlite3.connect(sqlite_path)
    92:         cur = self.conn.cursor()
    93:         cur.execute(
    94:             """
    95:             CREATE TABLE IF NOT EXISTS trades (
    96:                 pair TEXT,
    97:                 tf TEXT,
    98:                 dir TEXT,
    99:                 entry REAL,
   100:                 sl REAL,
   101:                 tp REAL,
   102:                 score REAL,
   103:                 reasons TEXT,
   104:                 pnl REAL
   105:             )
   106:             """
   107:         )
   108:         self.conn.commit()
   109:         atexit.register(self.conn.close)
   110: 
   111:     def log(self, data: Dict[str, Any]) -> None:
   112:         row = {k: data.get(k) for k in self.fields}
   113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
   114:             writer = csv.DictWriter(f, fieldnames=self.fields)
   115:             writer.writerow(row)
   116:         cur = self.conn.cursor()
   117:         cur.execute(
   118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
   119:             (
   120:                 row["pair"],
   121:                 row["tf"],
   122:                 row["dir"],
   123:                 row["entry"],
   124:                 row["sl"],
   125:                 row["tp"],
   126:                 row["score"],
   127:                 row["reasons"],
   128:                 row["pnl"],
   129:             ),
   130:         )
   131:         self.conn.commit()
   132: 
   133: 
   134: BASE_DIR = Path(__file__).resolve().parents[2]
   135: 
   136: 
   137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
   138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
   139:     path.parent.mkdir(parents=True, exist_ok=True)
   140:     file_exists = path.exists()
   141:     with path.open("a", newline="", encoding="utf-8") as f:
   142:         writer = csv.DictWriter(f, fieldnames=fields)
   143:         if not file_exists:
   144:             writer.writeheader()
   145:         writer.writerow({k: row.get(k) for k in fields})
   146: 
   147: 
   148: def log_position(data: Dict[str, Any]) -> None:
   149:     """Log a closed position to ``../positions.csv``."""
   150:     fields = [
   151:         "timestamp",
   152:         "pair",
   153:         "direction",
   154:         "entry",
   155:         "exit",
   156:         "pnl_pct",
   157:         "fee_rate",
   158:         "notes",
   159:     ]
   160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
   161: 
   162: 
   163: def log_operation_memo(data: Dict[str, Any]) -> None:
   164:     """Log operation details to ``../operations_memo.csv``."""
   165:     fields = ["timestamp", "pair", "details"]
   166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)


## scalper/metrics.py (last modified: 2025-08-24 10:15:51)
     1: """Utility metrics for trading calculations."""
     2: 
     3: from __future__ import annotations
     4: 
     5: 
     6: from typing import Iterable
     7: 
     8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
     9: 
    10: 
    11: def calc_pnl_pct(
    12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
    13: ) -> float:
    14:     """Return percentage PnL between entry and exit prices minus fees.
    15: 
    16: 
    17:     Parameters
    18:     ----------
    19:     entry_price: float
    20:         Trade entry price (>0).
    21:     exit_price: float
    22:         Trade exit price (>0).
    23:     side: int
    24:         +1 for long, -1 for short.
    25:     fee_rate: float, optional
    26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
    27:         applied twice (entry + exit).
    28:     """
    29:     if entry_price <= 0 or exit_price <= 0:
    30:         raise ValueError("Prices must be positive")
    31:     if side not in (1, -1):
    32:         raise ValueError("side must be +1 (long) or -1 (short)")
    33: 
    34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
    36:     return pnl - fee_pct
    37: 
    38: 
    39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
    41: 
    42: 
    43:     Parameters
    44:     ----------
    45:     prices:
    46:         Ordered sequence of closing prices.
    47:     period:
    48:         Number of periods to use for the calculation. Must be positive and the
    49:         length of ``prices`` must be at least ``period + 1``.
    50:     """
    51: 
    52:     prices_list = [float(p) for p in prices]
    53: 
    54:     if period <= 0:
    55:         raise ValueError("period must be positive")
    56:     if len(prices_list) < period + 1:
    57: 
    58:         raise ValueError("len(prices) must be >= period + 1")
    59: 
    60:     gains: list[float] = []
    61:     losses: list[float] = []
    62:     for i in range(1, period + 1):
    63: 
    64:         diff = prices_list[i] - prices_list[i - 1]
    65: 
    66:         if diff >= 0:
    67:             gains.append(diff)
    68:             losses.append(0.0)
    69:         else:
    70:             gains.append(0.0)
    71:             losses.append(-diff)
    72: 
    73:     avg_gain = sum(gains) / period
    74:     avg_loss = sum(losses) / period
    75: 
    76:     for i in range(period + 1, len(prices_list)):
    77:         diff = prices_list[i] - prices_list[i - 1]
    78: 
    79:         gain = max(diff, 0.0)
    80:         loss = max(-diff, 0.0)
    81:         avg_gain = (avg_gain * (period - 1) + gain) / period
    82:         avg_loss = (avg_loss * (period - 1) + loss) / period
    83: 
    84:     if avg_gain == 0 and avg_loss == 0:
    85:         return 50.0
    86:     if avg_loss == 0:
    87:         return 100.0
    88:     if avg_gain == 0:
    89:         return 0.0
    90:     rs = avg_gain / avg_loss
    91:     return 100.0 - (100.0 / (1.0 + rs))
    92: 
    93: 
    94: def calc_atr(
    95:     highs: Iterable[float],
    96:     lows: Iterable[float],
    97:     closes: Iterable[float],
    98:     period: int = 14,
    99: ) -> float:
   100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
   101: 
   102: 
   103:     Parameters
   104:     ----------
   105:     highs, lows, closes:
   106:         Ordered sequences of high, low and close prices. All sequences must
   107:         have the same length and contain at least ``period + 1`` elements.
   108:     period:
   109:         Number of periods to use for the calculation. Must be positive.
   110:     """
   111: 
   112:     highs_list = [float(h) for h in highs]
   113:     lows_list = [float(low) for low in lows]
   114:     closes_list = [float(c) for c in closes]
   115: 
   116:     length = len(highs_list)
   117:     if length != len(lows_list) or length != len(closes_list):
   118: 
   119:         raise ValueError("Input sequences must have the same length")
   120:     if period <= 0:
   121:         raise ValueError("period must be positive")
   122:     if length < period + 1:
   123:         raise ValueError("Input sequences must have at least period + 1 elements")
   124: 
   125:     trs: list[float] = []
   126:     for i in range(1, len(highs_list)):
   127:         tr = max(
   128:             highs_list[i] - lows_list[i],
   129:             abs(highs_list[i] - closes_list[i - 1]),
   130:             abs(lows_list[i] - closes_list[i - 1]),
   131:         )
   132:         trs.append(tr)
   133: 
   134:     atr = sum(trs[:period]) / period
   135:     for tr in trs[period:]:
   136:         atr = (atr * (period - 1) + tr) / period
   137:     return atr
   138: 
   139: 
   140: def calc_macd(
   141:     prices: Sequence[float],
   142:     fast: int = 12,
   143:     slow: int = 26,
   144:     signal: int = 9,
   145: ) -> tuple[float, float, float]:
   146:     """Return MACD, signal line and histogram values.
   147: 
   148:     The implementation computes exponential moving averages using Wilder's
   149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
   150:     """
   151: 
   152:     prices_list = [float(p) for p in prices]
   153:     if fast <= 0 or slow <= 0 or signal <= 0:
   154:         raise ValueError("periods must be positive")
   155:     min_len = max(fast, slow) + signal
   156:     if len(prices_list) < min_len:
   157:         raise ValueError("len(prices) must be >= slow + signal")
   158: 
   159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
   160:         k = 2.0 / (window + 1.0)
   161:         out = [float(series[0])]
   162:         for x in series[1:]:
   163:             out.append(float(x) * k + out[-1] * (1.0 - k))
   164:         return out
   165: 
   166:     fast_ema = _ema_series(prices_list, fast)
   167:     slow_ema = _ema_series(prices_list, slow)
   168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
   169:     signal_series = _ema_series(macd_series, signal)
   170:     macd_val = macd_series[-1]
   171:     signal_val = signal_series[-1]
   172:     hist = macd_val - signal_val
   173:     return macd_val, signal_val, hist
   174: 
   175: 
   176: def backtest_position(
   177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
   178: ) -> bool:
   179:     """Run a basic backtest to verify a position's coherence.
   180: 
   181:     Parameters
   182:     ----------
   183:     prices: list[float]
   184:         Sequential list of prices to evaluate.
   185:     entry_idx: int
   186:         Index in ``prices`` where the position is opened.
   187:     exit_idx: int
   188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
   189:     side: int
   190:         +1 for long, -1 for short.
   191: 
   192:     Returns
   193:     -------
   194:     bool
   195:         ``True`` if the resulting PnL is non-negative, meaning the position is
   196:         coherent with the direction of price movement. ``False`` otherwise.
   197:     """
   198:     if side not in (1, -1):
   199:         raise ValueError("side must be +1 (long) or -1 (short)")
   200:     if not (0 <= entry_idx < exit_idx < len(prices)):
   201:         raise ValueError(
   202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
   203:         )
   204: 
   205:     entry_price = float(prices[entry_idx])
   206:     exit_price = float(prices[exit_idx])
   207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
   208:     return pnl >= 0.0


## scalper/pairs.py (last modified: 2025-08-24 10:15:51)
     1: """Utilities to select trading pairs and detect signals."""
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Callable
     4: from scalper.strategy import Signal
     5: 
     6: from scalper.bot_config import CONFIG
     7: from scalper.strategy import ema as default_ema, cross as default_cross
     8: from scalper.notifier import notify
     9: 
    10: 
    11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    12:     """Return all trading pairs using the client's ``get_ticker`` method."""
    13:     tick = client.get_ticker()
    14:     data = tick.get("data") if isinstance(tick, dict) else []
    15:     if not data:
    16:         return []
    17:     return data if isinstance(data, list) else [data]
    18: 
    19: 
    20: def filter_trade_pairs(
    21:     client: Any,
    22:     *,
    23:     volume_min: float = 5_000_000,
    24:     max_spread_bps: float = 5.0,
    25:     top_n: int = 40,
    26: ) -> List[Dict[str, Any]]:
    27:     """Filter pairs by volume and spread."""
    28:     pairs = get_trade_pairs(client)
    29:     eligible: List[Dict[str, Any]] = []
    30: 
    31:     for info in pairs:
    32:         sym = info.get("symbol")
    33:         if not sym:
    34:             continue
    35:         try:
    36:             vol = float(info.get("volume", 0))
    37:         except (TypeError, ValueError):
    38:             continue
    39:         if vol < volume_min:
    40:             continue
    41:         try:
    42:             bid = float(info.get("bidPrice", 0))
    43:             ask = float(info.get("askPrice", 0))
    44:         except (TypeError, ValueError):
    45:             continue
    46:         if bid <= 0 or ask <= 0:
    47:             continue
    48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
    49:         if spread_bps >= max_spread_bps:
    50:             continue
    51:         eligible.append(info)
    52: 
    53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    54:     return eligible[:top_n]
    55: 
    56: 
    57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
    58:     """Return ``top_n`` pairs sorted by ``key``."""
    59:     pairs = get_trade_pairs(client)
    60: 
    61:     def volume(row: Dict[str, Any]) -> float:
    62:         try:
    63:             return float(row.get(key, 0))
    64:         except (TypeError, ValueError):
    65:             return 0.0
    66: 
    67:     pairs.sort(key=volume, reverse=True)
    68:     return pairs[:top_n]
    69: 
    70: 
    71: def _ancienne_impl(
    72:     client: Any,
    73:     pairs: List[Dict[str, Any]],
    74:     *,
    75:     interval: str = "1m",
    76:     ema_fast_n: Optional[int] = None,
    77:     ema_slow_n: Optional[int] = None,
    78:     ema_func=default_ema,
    79:     cross_func=default_cross,
    80: ) -> List[Dict[str, Any]]:
    81:     """Original implementation returning dicts."""
    82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    84:     results: List[Dict[str, Any]] = []
    85: 
    86:     for info in pairs:
    87:         symbol = info.get("symbol")
    88:         if not symbol:
    89:             continue
    90:         k = client.get_kline(symbol, interval=interval)
    91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
    92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
    93:             continue
    94:         efull = ema_func(closes, ema_fast_n)
    95:         eslow = ema_func(closes, ema_slow_n)
    96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
    97:         if signal == 1:
    98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
    99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
   100:         elif signal == -1:
   101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
   102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
   103:     return results
   104: 
   105: 
   106: def _to_signal(d: dict) -> Signal:
   107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
   108:     return Signal(
   109:         symbol=d.get("symbol"),
   110:         side=side,
   111:         entry=float(d.get("price", d.get("entry", 0))),
   112:         sl=float(d.get("sl", 0)),
   113:         tp1=float(d.get("tp1", 0)) or None,
   114:         tp2=float(d.get("tp2", 0)) or None,
   115:         score=d.get("score"),
   116:         quality=d.get("quality"),
   117:         reasons=d.get("reasons", []),
   118:     )
   119: 
   120: 
   121: def find_trade_positions(
   122:     client: Any,
   123:     pairs: List[Dict[str, Any]],
   124:     *,
   125:     interval: str = "1m",
   126:     ema_fast_n: Optional[int] = None,
   127:     ema_slow_n: Optional[int] = None,
   128:     ema_func=default_ema,
   129:     cross_func=default_cross,
   130: ) -> List[Signal]:
   131:     raw = _ancienne_impl(
   132:         client,
   133:         pairs,
   134:         interval=interval,
   135:         ema_fast_n=ema_fast_n,
   136:         ema_slow_n=ema_slow_n,
   137:         ema_func=ema_func,
   138:         cross_func=cross_func,
   139:     )
   140:     return [_to_signal(x) for x in raw]
   141: 
   142: 
   143: def send_selected_pairs(
   144:     client: Any,
   145:     top_n: int = 40,
   146:     *,
   147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
   148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
   149: ) -> Dict[str, str]:
   150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
   151: 
   152:     Returns the payload sent to ``notify_fn``. The mapping contains the
   153:     comma-separated symbols for each color group (``green``, ``orange`` and
   154:     ``red``) or an empty dictionary when no pairs are available.
   155:     """
   156: 
   157:     def split_symbol(sym: str) -> tuple[str, str]:
   158:         if "_" in sym:
   159:             left, right = sym.split("_", 1)
   160:             # Legacy style: BTC_USDT
   161:             if len(right) <= 4:
   162:                 return left, right
   163:             # Bitget futures style: BTCUSDT_UMCBL
   164:             main = left
   165:             if main.endswith("USDT"):
   166:                 return main[:-4], "USDT"
   167:             if main.endswith("USDC"):
   168:                 return main[:-4], "USDC"
   169:             if main.endswith("USD"):
   170:                 return main[:-3], "USD"
   171:             return main, ""
   172:         if sym.endswith("USDT"):
   173:             return sym[:-4], "USDT"
   174:         if sym.endswith("USDC"):
   175:             return sym[:-4], "USDC"
   176:         if sym.endswith("USD"):
   177:             return sym[:-3], "USD"
   178:         return sym, ""
   179: 
   180:     pairs = select_fn(client, top_n=top_n * 3)
   181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
   182:     by_base: Dict[str, Dict[str, Any]] = {}
   183:     for info in pairs:
   184:         sym = info.get("symbol")
   185:         if not sym:
   186:             continue
   187:         norm_sym = sym.split("_")[0].upper()
   188:         if allowed and norm_sym not in allowed:
   189:             continue
   190:         base, quote = split_symbol(sym)
   191:         existing = by_base.get(base)
   192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
   193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
   194:             by_base[base] = {"data": info, "quote": quote}
   195: 
   196:     unique = sorted(
   197:         (v["data"] for v in by_base.values()),
   198:         key=lambda row: float(row.get("volume", 0)),
   199:         reverse=True,
   200:     )
   201:     symbols: list[str] = []
   202:     for row in unique[:top_n]:
   203:         sym = row.get("symbol")
   204:         if not sym:
   205:             continue
   206:         base, _ = split_symbol(sym)
   207:         symbols.append(base)
   208:     if symbols:
   209:         n = len(symbols)
   210:         third = max(n // 3, 1)
   211:         green = symbols[:third]
   212:         orange = symbols[third : 2 * third]
   213:         red = symbols[2 * third :]
   214:         payload: Dict[str, str] = {}
   215:         if green:
   216:             payload["green"] = ", ".join(green)
   217:         if orange:
   218:             payload["orange"] = ", ".join(orange)
   219:         if red:
   220:             payload["red"] = ", ".join(red)
   221:         notify_fn("pair_list", payload)
   222:         return payload
   223:     return {}
   224: 
   225: 
   226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
   227:     """Return a heat score combining volatility, volume and a news flag."""
   228:     mult = 2.0 if news else 1.0
   229:     return volatility * volume * mult
   230: 
   231: 
   232: def select_top_heat_pairs(
   233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
   234: ) -> List[Dict[str, Any]]:
   235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
   236: 
   237:     scored: List[Dict[str, Any]] = []
   238:     for info in pairs:
   239:         try:
   240:             vol = float(info.get("volatility", 0))
   241:             volume = float(info.get("volume", 0))
   242:         except (TypeError, ValueError):
   243:             continue
   244:         score = heat_score(vol, volume, bool(info.get("news")))
   245:         row = dict(info)
   246:         row["heat_score"] = score
   247:         scored.append(row)
   248: 
   249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
   250:     return scored[:top_n]
   251: 
   252: 
   253: def decorrelate_pairs(
   254:     pairs: List[Dict[str, Any]],
   255:     corr: Dict[str, Dict[str, float]],
   256:     *,
   257:     threshold: float = 0.8,
   258:     top_n: int = 3,
   259: ) -> List[Dict[str, Any]]:
   260:     """Return top pairs while avoiding highly correlated symbols.
   261: 
   262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
   263:     pairs are considered too correlated when the absolute value of the
   264:     correlation exceeds ``threshold``.
   265:     """
   266: 
   267:     selected: List[Dict[str, Any]] = []
   268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
   269:         sym = info.get("symbol")
   270:         if not sym:
   271:             continue
   272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
   273:             selected.append(info)
   274:         if len(selected) >= top_n:
   275:             break
   276:     return selected


## scalper/positions/__init__.py (last modified: 2025-08-24 10:15:51)


## scalper/positions/state.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: from dataclasses import dataclass, field
     3: from enum import Enum, auto
     4: from typing import List, Optional
     5: import time
     6: 
     7: class PositionStatus(Enum):
     8:     IDLE = auto()
     9:     PENDING_ENTRY = auto()
    10:     OPEN = auto()
    11:     PENDING_EXIT = auto()
    12:     CLOSED = auto()
    13: 
    14: class PositionSide(Enum):
    15:     LONG = 1
    16:     SHORT = -1
    17: 
    18: @dataclass
    19: class Fill:
    20:     order_id: str
    21:     trade_id: str
    22:     price: float
    23:     qty: float
    24:     fee: float
    25:     ts: int
    26: 
    27: @dataclass
    28: class PositionState:
    29:     symbol: str
    30:     side: PositionSide
    31:     status: PositionStatus = PositionStatus.IDLE
    32:     entry_order_id: Optional[str] = None
    33:     exit_order_id: Optional[str] = None
    34:     req_qty: float = 0.0
    35:     filled_qty: float = 0.0
    36:     avg_entry_price: float = 0.0
    37:     avg_exit_price: float = 0.0
    38:     sl: Optional[float] = None
    39:     tp: Optional[float] = None
    40:     realized_pnl: float = 0.0
    41:     fees: float = 0.0
    42:     opened_ts: Optional[int] = None
    43:     closed_ts: Optional[int] = None
    44:     fills: List[Fill] = field(default_factory=list)
    45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
    46: 
    47:     def apply_fill_entry(self, f: Fill) -> None:
    48:         self.fills.append(f)
    49:         self.filled_qty += f.qty
    50:         # moyenne pondérée
    51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
    52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
    53:         self.fees += abs(f.fee)
    54:         if self.opened_ts is None:
    55:             self.opened_ts = f.ts
    56:         if self.filled_qty > 1e-12:
    57:             self.status = PositionStatus.OPEN
    58: 
    59:     def apply_fill_exit(self, f: Fill) -> None:
    60:         self.fills.append(f)
    61:         qty = min(self.filled_qty, f.qty)
    62:         # realized pnl sur la quantité fermée
    63:         if self.side == PositionSide.LONG:
    64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
    65:         else:
    66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
    67:         self.fees += abs(f.fee)
    68:         self.filled_qty = max(0.0, self.filled_qty - qty)
    69:         # moyenne de sortie indicative
    70:         closed_q = (self.req_qty - self.filled_qty)
    71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
    72:         if self.filled_qty <= 1e-12:
    73:             self.status = PositionStatus.CLOSED
    74:             self.closed_ts = f.ts
    75: 


## scalper/risk/__init__.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/risk/__init__.py
     2: from .manager import (
     3:     Caps,
     4:     compute_size,
     5:     calc_position_size,  # alias legacy
     6:     RiskManager,         # shim legacy
     7: )
     8: 
     9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]

## scalper/risk/manager.py (last modified: 2025-08-24 10:15:51)
     1: # scalp/risk/manager.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any
     5: 
     6: @dataclass
     7: class Caps:
     8:     min_qty: float = 0.0
     9:     min_notional: float = 0.0
    10:     max_leverage: float = 20.0
    11: 
    12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
    13:     if not caps_by_symbol:
    14:         return Caps()
    15:     c = caps_by_symbol.get(symbol, {})
    16:     return Caps(
    17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
    18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
    19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
    20:     )
    21: 
    22: def compute_size(
    23:     *,
    24:     symbol: str,
    25:     price: float,
    26:     balance_cash: float,
    27:     risk_pct: float = 0.5,
    28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
    29: ) -> float:
    30:     """Sizing robuste avec gardes min_notional / min_qty."""
    31:     price = max(1e-9, float(price))
    32:     balance_cash = max(0.0, float(balance_cash))
    33:     risk_pct = max(0.0, float(risk_pct))
    34: 
    35:     notionnel = balance_cash * risk_pct
    36:     qty = notionnel / price
    37: 
    38:     caps = _get_caps(caps_by_symbol, symbol)
    39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
    40:         qty = caps.min_notional / price
    41:     if caps.min_qty > 0 and qty < caps.min_qty:
    42:         qty = caps.min_qty
    43:     return max(0.0, qty)
    44: 
    45: # --- Shims pour compatibilité ancienne API -----------------------------------
    46: 
    47: def calc_position_size(symbol: str, price: float, balance_cash: float,
    48:                        risk_pct: float = 0.5,
    49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
    50:     """Alias legacy → compute_size."""
    51:     return compute_size(
    52:         symbol=symbol, price=price, balance_cash=balance_cash,
    53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
    54:     )
    55: 
    56: class RiskManager:
    57:     """
    58:     Shim minimal compatible avec l'ancien code:
    59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
    60:       qty = rm.size(symbol, price, balance_cash)
    61:     """
    62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
    63:         self.risk_pct = float(risk_pct)
    64:         self.caps_by_symbol = caps_by_symbol or {}
    65: 
    66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
    67:         return compute_size(
    68:             symbol=symbol, price=price, balance_cash=balance_cash,
    69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
    70:         )

## scalper/selection/__init__.py (last modified: 2025-08-24 10:15:51)
     1: """Pair selection helpers for the Scalp bot.
     2: 
     3: This package exposes two utilities used during the preparation phase of the
     4: trading strategy:
     5: 
     6: ``scan_pairs``
     7:     Performs the first level market scan by filtering pairs based on volume,
     8:     spread and hourly volatility.
     9: 
    10: ``select_active_pairs``
    11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
    12:     crossover and a sufficiently high ATR.
    13: """
    14: 
    15: from .scanner import scan_pairs
    16: from .momentum import select_active_pairs
    17: 
    18: __all__ = ["scan_pairs", "select_active_pairs"]
    19: 


## scalper/selection/momentum.py (last modified: 2025-08-24 10:15:51)
     1: """Utilities to select pairs exhibiting strong momentum."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List, Sequence
     6: 
     7: from ..metrics import calc_atr
     8: 
     9: 
    10: def ema(series: Sequence[float], window: int) -> List[float]:
    11:     """Simple exponential moving average implementation."""
    12: 
    13:     if window <= 1 or not series:
    14:         return list(series)
    15:     k = 2.0 / (window + 1.0)
    16:     out: List[float] = [float(series[0])]
    17:     prev = out[0]
    18:     for x in series[1:]:
    19:         prev = float(x) * k + prev * (1.0 - k)
    20:         out.append(prev)
    21:     return out
    22: 
    23: 
    24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
    26: 
    27:     if prev_fast <= prev_slow and last_fast > last_slow:
    28:         return 1
    29:     if prev_fast >= prev_slow and last_fast < last_slow:
    30:         return -1
    31:     return 0
    32: 
    33: 
    34: def _quantile(values: Sequence[float], q: float) -> float:
    35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
    36: 
    37:     if not values:
    38:         return 0.0
    39:     q = min(max(q, 0.0), 1.0)
    40:     vals = sorted(values)
    41:     idx = int((len(vals) - 1) * q)
    42:     return vals[idx]
    43: 
    44: 
    45: def select_active_pairs(
    46:     client: Any,
    47:     pairs: Sequence[Dict[str, Any]],
    48:     *,
    49:     interval: str = "Min5",
    50:     ema_fast: int = 20,
    51:     ema_slow: int = 50,
    52:     atr_period: int = 14,
    53:     atr_quantile: float = 0.5,
    54:     top_n: int = 5,
    55: ) -> List[Dict[str, Any]]:
    56:     """Return pairs with an EMA crossover and high ATR.
    57: 
    58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    59:     Among those candidates, the Average True Range is computed and only pairs
    60:     whose ATR is above the provided quantile are returned.  The resulting
    61:     dictionaries include an ``atr`` key for convenience.
    62:     """
    63: 
    64:     candidates: List[Dict[str, Any]] = []
    65:     atrs: List[float] = []
    66: 
    67:     for info in pairs:
    68:         sym = info.get("symbol")
    69:         if not sym:
    70:             continue
    71:         k = client.get_kline(sym, interval=interval)
    72:         kdata = k.get("data") if isinstance(k, dict) else {}
    73:         closes = kdata.get("close", [])
    74:         highs = kdata.get("high", [])
    75:         lows = kdata.get("low", [])
    76:         if len(closes) < max(ema_slow, atr_period) + 2:
    77:             continue
    78:         efast = ema(closes, ema_fast)
    79:         eslow = ema(closes, ema_slow)
    80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
    81:             continue
    82:         atr_val = calc_atr(highs, lows, closes, atr_period)
    83:         row = dict(info)
    84:         row["atr"] = atr_val
    85:         candidates.append(row)
    86:         atrs.append(atr_val)
    87: 
    88:     if not candidates:
    89:         return []
    90: 
    91:     threshold = _quantile(atrs, atr_quantile)
    92:     selected = [row for row in candidates if row["atr"] >= threshold]
    93:     selected.sort(key=lambda r: r["atr"], reverse=True)
    94:     return selected[:top_n]
    95: 
    96: 
    97: __all__ = ["select_active_pairs"]
    98: 


## scalper/selection/scanner.py (last modified: 2025-08-24 10:15:51)
     1: """Utilities for scanning tradable pairs on the exchange."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List
     6: 
     7: 
     8: def scan_pairs(
     9:     client: Any,
    10:     *,
    11:     volume_min: float = 5_000_000,
    12:     max_spread_bps: float = 5.0,
    13:     min_hourly_vol: float = 0.0,
    14:     top_n: int = 40,
    15: ) -> List[Dict[str, Any]]:
    16:     """Return pairs satisfying basic liquidity and volatility filters.
    17: 
    18:     Parameters
    19:     ----------
    20:     client: Any
    21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    22:     volume_min: float, optional
    23:         Minimum 24h volume required to keep a pair.
    24:     max_spread_bps: float, optional
    25:         Maximum allowed bid/ask spread expressed in basis points.
    26:     min_hourly_vol: float, optional
    27:         Minimum volatility over the last hour expressed as ``(high - low) /
    28:         close``.  When set to ``0`` the filter is disabled.
    29:     top_n: int, optional
    30:         Limit the number of returned pairs.
    31:     """
    32: 
    33:     tick = client.get_ticker()
    34:     data = tick.get("data") if isinstance(tick, dict) else []
    35:     if not isinstance(data, list):
    36:         data = [data]
    37: 
    38:     eligible: List[Dict[str, Any]] = []
    39: 
    40:     for row in data:
    41:         sym = row.get("symbol")
    42:         if not sym:
    43:             continue
    44:         try:
    45:             vol = float(row.get("volume", 0))
    46:             bid = float(row.get("bidPrice", 0))
    47:             ask = float(row.get("askPrice", 0))
    48:         except (TypeError, ValueError):
    49:             continue
    50:         if vol < volume_min or bid <= 0 or ask <= 0:
    51:             continue
    52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
    53:         if spread_bps >= max_spread_bps:
    54:             continue
    55: 
    56:         if min_hourly_vol > 0:
    57:             k = client.get_kline(sym, interval="Min60")
    58:             kdata = k.get("data") if isinstance(k, dict) else {}
    59:             highs = kdata.get("high", [])
    60:             lows = kdata.get("low", [])
    61:             closes = kdata.get("close", [])
    62:             if not highs or not lows or not closes:
    63:                 continue
    64:             try:
    65:                 h = float(highs[-1])
    66:                 l = float(lows[-1])
    67:                 c = float(closes[-1])
    68:             except (TypeError, ValueError):
    69:                 continue
    70:             hourly_vol = (h - l) / c if c else 0.0
    71:             if hourly_vol < min_hourly_vol:
    72:                 continue
    73: 
    74:         eligible.append(row)
    75: 
    76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    77:     return eligible[:top_n]
    78: 
    79: 
    80: __all__ = ["scan_pairs"]
    81: 


## scalper/selfcheck.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/selfcheck.py
     2: from __future__ import annotations
     3: 
     4: import json
     5: from pathlib import Path
     6: from typing import Dict, Any, List
     7: 
     8: def _missing_secrets(cfg: Dict[str, Any]) -> List[str]:
     9:     miss: List[str] = []
    10:     if not (cfg.get("secrets", {}).get("bitget", {}).get("access")):
    11:         miss.append("BITGET_ACCESS_KEY")
    12:     if not (cfg.get("secrets", {}).get("bitget", {}).get("secret")):
    13:         miss.append("BITGET_SECRET_KEY")
    14:     # passphrase peut être vide selon le compte → on ne la force pas
    15:     return miss
    16: 
    17: def _missing_config(cfg: Dict[str, Any]) -> List[str]:
    18:     req: List[str] = []
    19:     rt = (cfg.get("runtime") or {})
    20:     strat = (cfg.get("strategy") or {})
    21:     if not strat.get("live_timeframe"):
    22:         req.append("strategy.live_timeframe")
    23:     if not rt.get("data_dir"):
    24:         req.append("runtime.data_dir")
    25:     return req
    26: 
    27: def preflight_or_die(verbose: bool = False) -> None:
    28:     """
    29:     Valide secrets (.env) + paramètres généraux (config.yaml).
    30:     Écrit un green‑flag persistant si tout est OK.
    31:     """
    32:     from scalper.config.loader import load_config
    33:     cfg = load_config()
    34: 
    35:     miss_sec = _missing_secrets(cfg)
    36:     miss_cfg = _missing_config(cfg)
    37: 
    38:     issues: List[str] = []
    39:     if miss_sec:
    40:         issues.append("Secrets manquants: " + ", ".join(miss_sec))
    41:     if miss_cfg:
    42:         issues.append("Paramètres manquants: " + ", ".join(miss_cfg))
    43: 
    44:     if issues:
    45:         for i in issues:
    46:             print("[-]", i)
    47:         raise SystemExit(1)
    48: 
    49:     # Green flag
    50:     ready = Path("/notebooks/.scalper/READY.json")
    51:     ready.parent.mkdir(parents=True, exist_ok=True)
    52:     ready.write_text(
    53:         json.dumps({"status": "ok", "reason": "preflight"}, ensure_ascii=False, indent=2),
    54:         encoding="utf-8",
    55:     )
    56:     if verbose:
    57:         print(f"[✓] Préflight OK — ready flag écrit: {ready}")

## scalper/services/__init__.py (last modified: 2025-08-24 10:15:51)


## scalper/services/data_cache.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/services/data_cache.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Iterable, List, Optional, Tuple, Dict
     9: 
    10: # ---------------------------------------------------------------------
    11: # Réglages via env (valeurs sûres par défaut)
    12: # ---------------------------------------------------------------------
    13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
    14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
    15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
    16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
    17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
    18: 
    19: os.makedirs(DATA_DIR, exist_ok=True)
    20: 
    21: 
    22: # ---------------------------------------------------------------------
    23: # Helpers
    24: # ---------------------------------------------------------------------
    25: def parse_timeframe_to_seconds(tf: str) -> int:
    26:     tf = tf.strip().lower()
    27:     unit = tf[-1]
    28:     try:
    29:         n = int(tf[:-1])
    30:     except Exception as e:
    31:         raise ValueError(f"timeframe invalide: {tf}") from e
    32:     if unit == "m":
    33:         return n * 60
    34:     if unit == "h":
    35:         return n * 3600
    36:     if unit == "d":
    37:         return n * 86400
    38:     raise ValueError(f"timeframe invalide: {tf}")
    39: 
    40: 
    41: def csv_path(symbol: str, timeframe: str) -> str:
    42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
    43: 
    44: 
    45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
    46:     rows: List[Tuple[int, float, float, float, float, float]] = []
    47:     if not os.path.exists(path):
    48:         return rows
    49:     with open(path, "r", newline="") as f:
    50:         r = csv.reader(f)
    51:         header = next(r, None)  # accepte avec ou sans header
    52:         for line in r:
    53:             if not line:
    54:                 continue
    55:             ts, o, h, l, c, v = line[:6]
    56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
    57:     return rows
    58: 
    59: 
    60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
    61:     first = not os.path.exists(path)
    62:     os.makedirs(os.path.dirname(path), exist_ok=True)
    63:     with open(path, "a", newline="") as f:
    64:         w = csv.writer(f)
    65:         if first:
    66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    67:         for row in data:
    68:             w.writerow(row)
    69: 
    70: 
    71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
    72:     return rows[-1][0] if rows else None
    73: 
    74: 
    75: # ---------------------------------------------------------------------
    76: # Fetch CCXT paginé
    77: # ---------------------------------------------------------------------
    78: async def ccxt_fetch_ohlcv_all(
    79:     exchange,
    80:     symbol: str,
    81:     timeframe: str,
    82:     since_ms: Optional[int],
    83:     limit: int = 1000,
    84: ) -> List[Tuple[int, float, float, float, float, float]]:
    85:     """
    86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
    87:     Retourne une liste triée/dédupliquée.
    88:     """
    89:     out: List[Tuple[int, float, float, float, float, float]] = []
    90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
    91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
    92: 
    93:     cursor = since_ms or (now_ms - 200 * tf_ms)
    94:     while True:
    95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
    96:         if not batch:
    97:             break
    98:         for ts, o, h, l, c, v in batch:
    99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
   100:         next_cursor = batch[-1][0] + tf_ms
   101:         if next_cursor <= cursor:
   102:             break
   103:         cursor = next_cursor
   104:         if cursor >= now_ms + (2 * tf_ms):
   105:             break
   106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
   107: 
   108:     out.sort(key=lambda x: x[0])
   109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
   110:     seen = set()
   111:     for row in out:
   112:         if row[0] in seen:
   113:             continue
   114:         seen.add(row[0])
   115:         dedup.append(row)
   116:     return dedup
   117: 
   118: 
   119: # ---------------------------------------------------------------------
   120: # Cache manager
   121: # ---------------------------------------------------------------------
   122: async def ensure_symbol_csv_cache(
   123:     exchange,
   124:     symbol: str,
   125:     timeframe: str,
   126:     min_rows: int = CSV_MIN_ROWS,
   127: ) -> str:
   128:     """
   129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
   130:     Crée/append si nécessaire. Retourne le chemin.
   131:     """
   132:     path = csv_path(symbol, timeframe)
   133:     rows = read_csv_ohlcv(path)
   134:     tf_sec = parse_timeframe_to_seconds(timeframe)
   135:     tf_ms = tf_sec * 1000
   136:     now_ms = int(time.time() * 1000)
   137: 
   138:     # âge max
   139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
   140: 
   141:     need_full = False
   142:     need_append = False
   143: 
   144:     if not rows:
   145:         need_full = True
   146:     else:
   147:         last = last_ts(rows) or 0
   148:         age_sec = max(0, (now_ms - last) // 1000)
   149:         if age_sec > max_age or len(rows) < min_rows:
   150:             need_append = True
   151: 
   152:     if need_full:
   153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
   154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   155:         if len(fresh) < min_rows:
   156:             since = now_ms - (tf_ms * 5000)
   157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   158:         if os.path.exists(path):
   159:             os.remove(path)
   160:         write_csv_ohlcv(path, fresh)
   161:         return path
   162: 
   163:     if need_append:
   164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
   165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   166:         if fresh:
   167:             write_csv_ohlcv(path, fresh)
   168: 
   169:     return path
   170: 
   171: 
   172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
   173:     """
   174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
   175:     Retourne {symbol: path}.
   176:     """
   177:     sem = asyncio.Semaphore(PREFETCH_CONC)
   178:     result: Dict[str, str] = {}
   179: 
   180:     async def _one(sym: str):
   181:         async with sem:
   182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
   183:             result[sym] = p
   184: 
   185:     await asyncio.gather(*[_one(s) for s in symbols])
   186:     return result

## scalper/services/order_service.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: from dataclasses import dataclass
     3: from typing import Any, Dict, Optional, Protocol
     4: from scalper.trade_utils import extract_available_balance
     5: 
     6: 
     7: @dataclass
     8: class OrderCaps:
     9:     min_trade_usdt: float = 5.0
    10:     leverage: float = 1.0
    11: 
    12: 
    13: @dataclass
    14: class OrderRequest:
    15:     symbol: str
    16:     side: str
    17:     price: float
    18:     sl: float
    19:     tp: Optional[float]
    20:     risk_pct: float
    21: 
    22: 
    23: @dataclass
    24: class OrderResult:
    25:     accepted: bool
    26:     reason: str = ""
    27:     payload: Dict[str, Any] = None
    28:     order_id: Optional[str] = None
    29:     status: Optional[str] = None
    30:     avg_price: Optional[float] = None
    31:     filled_qty: Optional[float] = None
    32: 
    33: 
    34: class Exchange(Protocol):
    35:     def get_assets(self) -> Dict[str, Any]: ...
    36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
    37:     def place_order(
    38:         self,
    39:         symbol: str,
    40:         side: str,
    41:         quantity: float,
    42:         order_type: str,
    43:         price: Optional[float] = None,
    44:         stop_loss: Optional[float] = None,
    45:         take_profit: Optional[float] = None,
    46:     ) -> Dict[str, Any]: ...
    47: 
    48: 
    49: class OrderService:
    50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
    51:         self.exchange = exchange
    52:         self.caps = caps
    53: 
    54:     @staticmethod
    55:     def _abs(x: float) -> float:
    56:         return -x if x < 0 else x
    57: 
    58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
    59:         dist = self._abs(price - sl)
    60:         if dist <= 0:
    61:             return 0.0
    62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
    63:         return 0.0 if price <= 0 else (risk_usdt / dist)
    64: 
    65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
    66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
    67:         if qty <= 0:
    68:             return OrderResult(False, "invalid_size")
    69:         notional = qty * req.price
    70:         if notional < self.caps.min_trade_usdt:
    71:             return OrderResult(False, "under_min_notional")
    72:         assets = self.exchange.get_assets()
    73:         available = extract_available_balance(assets)
    74:         required_margin = notional / max(1.0, self.caps.leverage)
    75:         if available < required_margin:
    76:             return OrderResult(False, "insufficient_margin")
    77:         side = "BUY" if req.side == "long" else "SELL"
    78:         out = self.exchange.place_order(
    79:             symbol=req.symbol, side=side, quantity=qty,
    80:             order_type="limit", price=req.price,
    81:             stop_loss=req.sl, take_profit=req.tp
    82:         )
    83:         # extraire infos utiles
    84:         oid = None; status = None; avg = None; filled = None
    85:         try:
    86:             data = out.get("data") if isinstance(out, dict) else out
    87:             if isinstance(data, dict):
    88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
    89:                 status = (data.get("status") or data.get("state") or "new").lower()
    90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
    91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
    92:         except Exception:
    93:             pass
    94:         return OrderResult(True, "", out, oid, status, avg, filled)


## scalper/services/utils.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/services/utils.py
     2: from __future__ import annotations
     3: import asyncio
     4: from typing import Callable, Any
     5: 
     6: 
     7: class NullNotifier:
     8:     async def send(self, _msg: str) -> None:
     9:         return
    10: 
    11: 
    12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
    13:     if notifier is None:
    14:         notifier = NullNotifier()
    15:     try:
    16:         while running_getter():
    17:             await notifier.send("heartbeat alive")
    18:             await asyncio.sleep(period)
    19:     except asyncio.CancelledError:
    20:         pass
    21: 
    22: 
    23: async def log_stats_task(
    24:     notifier: Any,
    25:     ticks_getter: Callable[[], int],
    26:     symbols_getter: Callable[[], list[str]],
    27:     period: float = 30.0,
    28: ) -> None:
    29:     if notifier is None:
    30:         notifier = NullNotifier()
    31:     last = 0
    32:     try:
    33:         while True:
    34:             total = int(ticks_getter() or 0)
    35:             delta = total - last
    36:             last = total
    37:             syms = symbols_getter() or []
    38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
    39:             print(msg)
    40:             await notifier.send(msg)
    41:             await asyncio.sleep(period)
    42:     except asyncio.CancelledError:
    43:         pass

## scalper/signals/__init__.py (last modified: 2025-08-24 10:15:51)
     1: __all__ = ["factory"]

## scalper/signals/current.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/signals/current.py
     2: from __future__ import annotations
     3: 
     4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
     5: from scalper.strategy import generate_signal as _generate_signal
     6: 
     7: def generate_signal(**kwargs):
     8:     """
     9:     Expose la même signature que scalper.strategy.generate_signal.
    10:     Sert d’adaptateur pour la factory.
    11:     """
    12:     return _generate_signal(**kwargs)

## scalper/signals/factory.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/signals/factory.py
     2: from __future__ import annotations
     3: from typing import Callable, Dict, Any
     4: import importlib
     5: import os
     6: import json
     7: 
     8: try:
     9:     import yaml  # type: ignore
    10: except Exception:
    11:     yaml = None  # type: ignore
    12: 
    13: SignalFn = Callable[..., Any]
    14: 
    15: # IMPORTANT : on pointe par défaut sur TA stratégie actuelle dans scalper/strategy.py
    16: _REGISTRY: Dict[str, str] = {
    17:     "current": "scalper.strategy:generate_signal",
    18:     # Tu pourras ajouter d'autres stratégies ici, par ex :
    19:     # "ema_cross": "scalper.strategies.ema_cross:generate_signal",
    20: }
    21: 
    22: def _load_callable(path: str) -> SignalFn:
    23:     if ":" not in path:
    24:         raise ValueError(f"Chemin callable invalide: {path}")
    25:     module_name, attr = path.split(":", 1)
    26:     mod = importlib.import_module(module_name)
    27:     fn = getattr(mod, attr, None)
    28:     if not callable(fn):
    29:         raise ValueError(f"{attr} n'est pas callable dans {module_name}")
    30:     return fn  # type: ignore
    31: 
    32: def load_signal(name: str) -> SignalFn:
    33:     key = (name or "").strip().lower()
    34:     if key not in _REGISTRY:
    35:         raise KeyError(f"Stratégie inconnue: '{name}'. Registre: {list(_REGISTRY)}")
    36:     return _load_callable(_REGISTRY[key])
    37: 
    38: def _read_yaml(path: str) -> dict:
    39:     if yaml is None:
    40:         with open(path, "r", encoding="utf-8") as f:
    41:             return json.load(f)
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         return yaml.safe_load(f) or {}
    44: 
    45: def load_strategies_cfg(path: str | None) -> dict:
    46:     """
    47:     Charge le mapping (symbole, timeframe) -> nom de stratégie.
    48:     Si le fichier n'existe pas, retourne une config par défaut fonctionnelle.
    49:     """
    50:     default_cfg = {"default": "current", "by_timeframe": {}, "by_symbol": {}}
    51:     if not path:
    52:         return default_cfg
    53:     if not os.path.isfile(path):
    54:         # Pas de fichier ? On continue avec les valeurs par défaut.
    55:         return default_cfg
    56:     cfg = _read_yaml(path)
    57:     cfg.setdefault("default", "current")
    58:     cfg.setdefault("by_timeframe", {})
    59:     cfg.setdefault("by_symbol", {})
    60:     return cfg
    61: 
    62: def resolve_strategy_name(symbol: str, timeframe: str, cfg: dict) -> str:
    63:     symbol = (symbol or "").upper()
    64:     timeframe = (timeframe or "").lower()
    65:     return (
    66:         cfg.get("by_symbol", {}).get(symbol, {}).get(timeframe)
    67:         or cfg.get("by_timeframe", {}).get(timeframe)
    68:         or cfg.get("default", "current")
    69:     )
    70: 
    71: def resolve_signal_fn(symbol: str, timeframe: str, cfg: dict) -> SignalFn:
    72:     return load_signal(resolve_strategy_name(symbol, timeframe, cfg))

## scalper/signals/generator.py (last modified: 2025-08-24 10:15:51)
     1: from __future__ import annotations
     2: 
     3: from typing import Any, Dict, List, Optional
     4: 
     5: import pandas as pd
     6: 
     7: from data.indicators import compute_all
     8: 
     9: __all__ = ["generate_signal"]
    10: 
    11: 
    12: def _quality_from_score(score: float) -> str:
    13:     if score >= 0.8:
    14:         return "A"
    15:     if score >= 0.5:
    16:         return "B"
    17:     return "C"
    18: 
    19: 
    20: def generate_signal(
    21:     df: pd.DataFrame,
    22:     *,
    23:     trend_tf: Optional[pd.DataFrame] = None,
    24:     confirm_tf: Optional[pd.DataFrame] = None,
    25:     atr_mult: float = 1.0,
    26:     trailing: bool = False,
    27:     **_: Any,
    28: ) -> Optional[Dict[str, Any]]:
    29:     """Generate a trading signal with confluence scoring.
    30: 
    31:     Parameters
    32:     ----------
    33:     df: pd.DataFrame
    34:         Primary timeframe OHLCV data.
    35:     trend_tf: pd.DataFrame, optional
    36:         Higher timeframe used for trend filtering.
    37:     confirm_tf: pd.DataFrame, optional
    38:         Lower timeframe used for confirmation.
    39:     atr_mult: float, optional
    40:         Multiplier applied to ATR for stop/target calculation.
    41:     trailing: bool, optional
    42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
    43: 
    44:     Returns
    45:     -------
    46:     dict | None
    47:         Dictionary describing the signal or ``None`` if no trade setup exists.
    48:     """
    49: 
    50:     if df is None or len(df) < 2:
    51:         return None
    52: 
    53:     df = compute_all(df)
    54:     last = df.iloc[-1]
    55: 
    56:     conditions: List[bool] = []
    57:     reasons: List[str] = []
    58:     direction: Optional[str] = None
    59: 
    60:     # --- Basic trend via EMAs ----------------------------------------------
    61:     if last["close"] > last["ema20"] > last["ema50"]:
    62:         direction = "long"
    63:         reasons.append("price_above_ema")
    64:         conditions.append(True)
    65:     elif last["close"] < last["ema20"] < last["ema50"]:
    66:         direction = "short"
    67:         reasons.append("price_below_ema")
    68:         conditions.append(True)
    69:     else:
    70:         conditions.append(False)
    71:         return None
    72: 
    73:     # --- RSI ---------------------------------------------------------------
    74:     if direction == "long":
    75:         cond = last["rsi"] > 55
    76:         if cond:
    77:             reasons.append("rsi_bullish")
    78:         conditions.append(cond)
    79:     else:
    80:         cond = last["rsi"] < 45
    81:         if cond:
    82:             reasons.append("rsi_bearish")
    83:         conditions.append(cond)
    84: 
    85:     # --- MACD --------------------------------------------------------------
    86:     if direction == "long":
    87:         cond = last["macd"] > last["macd_signal"]
    88:         if cond:
    89:             reasons.append("macd_bullish")
    90:         conditions.append(cond)
    91:     else:
    92:         cond = last["macd"] < last["macd_signal"]
    93:         if cond:
    94:             reasons.append("macd_bearish")
    95:         conditions.append(cond)
    96: 
    97:     # --- OBV momentum ------------------------------------------------------
    98:     if len(df) >= 2:
    99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
   100:         if obv_up:
   101:             reasons.append("obv_trending")
   102:         conditions.append(obv_up)
   103: 
   104:     # --- Trend timeframe filter -------------------------------------------
   105:     if trend_tf is not None and len(trend_tf) >= 2:
   106:         tdf = compute_all(trend_tf)
   107:         ema50 = tdf["ema50"]
   108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
   109:         if direction == "long":
   110:             cond = slope > 0
   111:             if cond:
   112:                 reasons.append("trend_up")
   113:             conditions.append(cond)
   114:         else:
   115:             cond = slope < 0
   116:             if cond:
   117:                 reasons.append("trend_down")
   118:             conditions.append(cond)
   119: 
   120:     # --- Confirmation timeframe filter ------------------------------------
   121:     if confirm_tf is not None and len(confirm_tf) > 0:
   122:         cdf = compute_all(confirm_tf)
   123:         rsi = cdf["rsi"].iloc[-1]
   124:         if direction == "long":
   125:             cond = rsi > 50
   126:             if cond:
   127:                 reasons.append("confirm_rsi_bullish")
   128:             conditions.append(cond)
   129:         else:
   130:             cond = rsi < 50
   131:             if cond:
   132:                 reasons.append("confirm_rsi_bearish")
   133:             conditions.append(cond)
   134: 
   135:     score = (
   136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
   137:     )
   138:     quality = _quality_from_score(score)
   139: 
   140:     atr = last.get("atr")
   141:     if pd.isna(atr) or atr == 0:
   142:         return None
   143: 
   144:     entry = float(last["close"])
   145:     if direction == "long":
   146:         sl = entry - atr * atr_mult
   147:         tp = entry + atr * atr_mult * 2
   148:     else:
   149:         sl = entry + atr * atr_mult
   150:         tp = entry - atr * atr_mult * 2
   151: 
   152:     result: Dict[str, Any] = {
   153:         "direction": direction,
   154:         "entry": entry,
   155:         "sl": sl,
   156:         "tp": tp,
   157:         "score": round(score, 3),
   158:         "reasons": reasons,
   159:         "quality": quality,
   160:     }
   161: 
   162:     if trailing:
   163:         result["trail"] = atr * atr_mult
   164: 
   165:     return result


## scalper/strategy/factory.py (last modified: 2025-08-24 10:15:51)
     1: annulé

## scalper/strategy/startegies/current.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/strategy/strategies/current.py
     2: from __future__ import annotations
     3: from typing import Optional, Any, Dict, List
     4: from scalper.core.signal import Signal
     5: from scalper.core import indicators as ta
     6: 
     7: def _extract_ohlcv(ohlcv: Any) -> Dict[str, List[float]]:
     8:     cols = ("timestamp", "open", "high", "low", "close", "volume")
     9: 
    10:     def to_float_list(seq) -> List[float]:
    11:         return [float(x) for x in seq]
    12: 
    13:     # pandas.DataFrame
    14:     if hasattr(ohlcv, "columns"):
    15:         missing = [c for c in cols if c not in ohlcv.columns]
    16:         if missing:
    17:             raise ValueError(f"Colonnes OHLCV manquantes: {missing}")
    18:         return {k: to_float_list(ohlcv[k].tolist()) for k in cols}
    19: 
    20:     # dict de listes
    21:     if isinstance(ohlcv, dict):
    22:         missing = [c for c in cols if c not in ohlcv]
    23:         if missing:
    24:             raise ValueError(f"Clés OHLCV manquantes: {missing}")
    25:         return {k: to_float_list(ohlcv[k]) for k in cols}
    26: 
    27:     # liste de dicts
    28:     if isinstance(ohlcv, (list, tuple)) and ohlcv and isinstance(ohlcv[0], dict):
    29:         out: Dict[str, List[float]] = {k: [] for k in cols}
    30:         for row in ohlcv:
    31:             for k in cols:
    32:                 out[k].append(float(row[k]))
    33:         return out
    34: 
    35:     raise TypeError("Format OHLCV non supporté. Attendu DataFrame|dict de listes|liste de dicts.")
    36: 
    37: def _last(lst: List[float]) -> float:
    38:     return float(lst[-1])
    39: 
    40: def _b(x: bool) -> int:
    41:     return 1 if x else 0
    42: 
    43: def _score_to_quality(score: int, total: int) -> float:
    44:     if total <= 0:
    45:         return 0.0
    46:     q = score / float(total)
    47:     return max(0.0, min(1.0, q))
    48: 
    49: def generate_signal(
    50:     *,
    51:     symbol: str,
    52:     timeframe: str,
    53:     ohlcv: Any,
    54:     equity: float,
    55:     risk_pct: float = 0.01,
    56:     ohlcv_15m: Optional[Any] = None,
    57:     ohlcv_1h: Optional[Any] = None,
    58:     **kwargs,
    59: ) -> Optional[Signal]:
    60:     """
    61:     Stratégie 'current' multi-indicateurs:
    62:       - Tendance: EMA20/50/200 (+ pente EMA200 en 1h si dispo)
    63:       - Momentum: RSI(14), MACD(12,26,9)
    64:       - Confiance: OBV, VWAP, ATR
    65:       - SL/TP: ATR-multipliers
    66:     Retour: Signal ou None
    67:     """
    68:     data = _extract_ohlcv(ohlcv)
    69:     ts, h, l, c, v = data["timestamp"], data["high"], data["low"], data["close"], data["volume"]
    70:     n = len(c)
    71:     if n < 230:  # besoin EMA200 + MACD warmup
    72:         return None
    73: 
    74:     ema20 = ta.ema(c, 20)
    75:     ema50 = ta.ema(c, 50)
    76:     ema200 = ta.ema(c, 200)
    77:     macd_line, macd_sig, macd_hist = ta.macd(c, 12, 26, 9)
    78:     rsi14 = ta.rsi(c, 14)
    79:     atr14 = ta.atr(h, l, c, 14)
    80:     obv = ta.obv(c, v)
    81:     vwap = ta.vwap(h, l, c, v)
    82: 
    83:     # MTF (facultatif)
    84:     mtf_long = mtf_short = True
    85:     reasons: List[str] = []
    86:     if ohlcv_1h is not None:
    87:         hd = _extract_ohlcv(ohlcv_1h)
    88:         ema200_1h = ta.ema(hd["close"], 200)
    89:         slope_1h = ta.slope(ema200_1h, lookback=5)
    90:         mtf_long = _last(slope_1h) > 0
    91:         mtf_short = _last(slope_1h) < 0
    92:         reasons.append(f"MTF1h={'up' if mtf_long else ('down' if mtf_short else 'flat')}")
    93: 
    94:     cond_trend_long = _last(c) > _last(ema20) > _last(ema50) > _last(ema200)
    95:     cond_mom_long = _last(macd_hist) > 0 and _last(rsi14) >= 55.0
    96:     cond_vol_long = _last(obv) > obv[-5] and _last(atr14) > 0.0005 * _last(c)
    97: 
    98:     cond_trend_short = _last(c) < _last(ema20) < _last(ema50) < _last(ema200)
    99:     cond_mom_short = _last(macd_hist) < 0 and _last(rsi14) <= 45.0
   100:     cond_vol_short = _last(obv) < obv[-5] and _last(atr14) > 0.0005 * _last(c)
   101: 
   102:     score_L = sum([_b(cond_trend_long), _b(cond_mom_long), _b(cond_vol_long), _b(mtf_long), _b(_last(c) > _last(vwap))])
   103:     score_S = sum([_b(cond_trend_short), _b(cond_mom_short), _b(cond_vol_short), _b(mtf_short), _b(_last(c) < _last(vwap))])
   104:     total = 5
   105: 
   106:     side = None
   107:     score = 0
   108:     if score_L > score_S and score_L >= 3:
   109:         side, score = "long", score_L
   110:     elif score_S > score_L and score_S >= 3:
   111:         side, score = "short", score_S
   112:     if side is None:
   113:         return None
   114: 
   115:     price = _last(c)
   116:     vol = max(_last(atr14), 1e-8)
   117:     atr_mult_sl, tp1_mult, tp2_mult = 1.5, 1.0, 2.0
   118: 
   119:     if side == "long":
   120:         sl = price - atr_mult_sl * vol
   121:         tp1 = price + tp1_mult * vol
   122:         tp2 = price + tp2_mult * vol
   123:     else:
   124:         sl = price + atr_mult_sl * vol
   125:         tp1 = price - tp1_mult * vol
   126:         tp2 = price - tp2_mult * vol
   127: 
   128:     reasons += [
   129:         f"side={side}",
   130:         f"rsi={_last(rsi14):.1f}",
   131:         f"macd_hist={_last(macd_hist):.5f}",
   132:         f"atr={vol:.5f}",
   133:         f"vwap_rel={'above' if price>_last(vwap) else 'below'}",
   134:     ]
   135: 
   136:     return Signal(
   137:         symbol=symbol, timeframe=timeframe, side=side, entry=price, sl=sl, tp1=tp1, tp2=tp2,
   138:         score=float(score), quality=_score_to_quality(score, total), reasons=reasons,
   139:         timestamp=int(_last(ts)), extra={"risk_pct": float(risk_pct)},
   140:     )

## scalper/strategy.py (last modified: 2025-08-24 10:15:51)
     1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
     2: 
     3: This module implements a minimal but functional version of the strategy
     4: outlined in the project specification.  The focus is on pure Python
     5: implementations so the logic can easily be unit tested without requiring
     6: external services or heavy third‑party dependencies.
     7: 
     8: The strategy is deliberately stateless; functions operate on passed data and
     9: return simple data structures.  This makes it easy to plug the logic into
    10: real‑time trading loops or backtest engines.
    11: """
    12: 
    13: from __future__ import annotations
    14: 
    15: from dataclasses import dataclass
    16: from typing import Sequence, List, Dict, Optional, Tuple, Any
    17: 
    18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
    19: from .risk import calc_position_size
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Helpers
    23: # ---------------------------------------------------------------------------
    24: 
    25: def ema(series: Sequence[float], window: int) -> List[float]:
    26:     """Return the exponential moving average of *series*.
    27: 
    28:     The first value is the raw input to remain consistent with most trading
    29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
    30:     returned unchanged.
    31:     """
    32: 
    33:     if window <= 1 or not series:
    34:         return list(series)
    35:     k = 2.0 / (window + 1.0)
    36:     out: List[float] = [float(series[0])]
    37:     prev = out[0]
    38:     for x in series[1:]:
    39:         prev = float(x) * k + prev * (1.0 - k)
    40:         out.append(prev)
    41:     return out
    42: 
    43: def vwap(highs: Sequence[float], lows: Sequence[float],
    44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
    45:     """Compute the volume weighted average price (VWAP).
    46: 
    47:     Parameters
    48:     ----------
    49:     highs, lows, closes, volumes: Sequence[float]
    50:         Matching sequences for the period considered.
    51:     """
    52: 
    53:     tp_vol = 0.0
    54:     vol_sum = 0.0
    55:     for h, low, c, v in zip(highs, lows, closes, volumes):
    56:         tp = (h + low + c) / 3.0
    57:         tp_vol += tp * v
    58:         vol_sum += v
    59:     return tp_vol / vol_sum if vol_sum else 0.0
    60: 
    61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    62:     """Return the On Balance Volume (OBV) series."""
    63: 
    64:     if not closes:
    65:         return []
    66:     out: List[float] = [0.0]
    67:     for i in range(1, len(closes)):
    68:         if closes[i] > closes[i - 1]:
    69:             out.append(out[-1] + volumes[i])
    70:         elif closes[i] < closes[i - 1]:
    71:             out.append(out[-1] - volumes[i])
    72:         else:
    73:             out.append(out[-1])
    74:     return out
    75: 
    76: 
    77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    78:     """Detect a crossing between two series.
    79: 
    80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    81:     ``0`` otherwise.
    82:     """
    83: 
    84:     if prev_fast <= prev_slow and last_fast > last_slow:
    85:         return 1
    86:     if prev_fast >= prev_slow and last_fast < last_slow:
    87:         return -1
    88:     return 0
    89: 
    90: 
    91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    92:     """Compute order book imbalance.
    93: 
    94:     The value is normalised between ``-1`` and ``1`` where positive numbers
    95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
    96:     """
    97: 
    98:     total = bid_vol + ask_vol
    99:     return (bid_vol - ask_vol) / total if total else 0.0
   100: 
   101: 
   102: def swing_levels(
   103:     highs: Sequence[float], lows: Sequence[float], lookback: int
   104: ) -> Tuple[float, float]:
   105:     """Return the most recent swing high and swing low.
   106: 
   107:     ``lookback`` defines how many completed candles are inspected.  The current
   108:     candle is excluded to avoid look‑ahead bias.
   109:     """
   110: 
   111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
   112:         return highs[-1], lows[-1]
   113:     high = max(highs[-lookback - 1 : -1])
   114:     low = min(lows[-lookback - 1 : -1])
   115:     return high, low
   116: 
   117: # ---------------------------------------------------------------------------
   118: # Pair selection
   119: # ---------------------------------------------------------------------------
   120: 
   121: # The first and second level pair selection helpers now live in
   122: # :mod:`scalper.selection`.  They are re-exported here for backward compatibility
   123: # and to keep the public API unchanged.
   124: from .selection.scanner import scan_pairs  # noqa: E402
   125: from .selection.momentum import select_active_pairs  # noqa: E402
   126: 
   127: # ---------------------------------------------------------------------------
   128: # Signal generation
   129: # ---------------------------------------------------------------------------
   130: 
   131: @dataclass
   132: class Signal:
   133:     """Trading signal with risk parameters."""
   134: 
   135:     symbol: str
   136:     side: int  # 1 for long, -1 for short
   137:     entry: float
   138:     sl: float
   139:     tp1: float
   140:     tp2: float
   141:     qty: float = 0.0
   142:     score: Optional[float] = None
   143:     quality: Optional[float] = None
   144:     reasons: Optional[List[str]] = None
   145: 
   146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
   147:         if isinstance(self.side, str):
   148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
   149: 
   150:     @property
   151:     def price(self) -> float:
   152:         return self.entry
   153: 
   154: 
   155: def _generate_signal(
   156:     symbol: str,
   157:     ohlcv: Dict[str, Sequence[float]],
   158:     *,
   159:     equity: float,
   160:     risk_pct: float,
   161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
   162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
   163:     order_book: Optional[Dict[str, float]] = None,
   164:     tick_ratio_buy: Optional[float] = None,
   165:     atr_disable_pct: float = 0.2,
   166:     atr_reduce_pct: float = 2.0,
   167:     swing_lookback: int = 5,
   168:     macd_fast: int = 12,
   169:     macd_slow: int = 26,
   170:     macd_signal: int = 9,
   171:     trend_ema_period: int = 200,
   172: ) -> Optional[Signal]:
   173:     """Return a trading :class:`Signal` if conditions are met.
   174: 
   175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
   176:     sequences ordered from oldest to newest.  The function checks the following
   177:     rules:
   178: 
   179:     * price positioned relative to VWAP and EMA20/EMA50 trend
   180:     * RSI(14) crossing key levels (40/60)
   181:     * OBV rising or high short‑term volume
   182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
   183:     * Micro‑structure breakout of last swing high/low
   184:     * MACD trend filter
   185:     * Long‑term trend via configurable EMA filter
   186:     * Order book imbalance and tape filters
   187:     * Dynamic ATR‑based stop‑loss and take‑profit
   188:     * Position sizing via ``calc_position_size``
   189:     """
   190: 
   191:     closes = [float(x) for x in ohlcv.get("close", [])]
   192:     highs = [float(x) for x in ohlcv.get("high", [])]
   193:     lows = [float(x) for x in ohlcv.get("low", [])]
   194:     vols = [float(x) for x in ohlcv.get("volume", [])]
   195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
   196:         return None
   197: 
   198:     price = closes[-1]
   199:     ema20 = ema(closes, 20)
   200:     ema50 = ema(closes, 50)
   201:     ema_trend = ema(closes, trend_ema_period)
   202:     v = vwap(highs, lows, closes, vols)
   203:     obv_series = obv(closes, vols)
   204:     obv_rising = obv_series[-1] > obv_series[-2]
   205:     vol_last3 = sum(vols[-3:])
   206:     vol_ma20 = sum(vols[-20:]) / 20.0
   207:     vol_rising = vol_last3 > vol_ma20
   208: 
   209:     macd_val, macd_sig, _ = calc_macd(
   210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
   211:     )
   212: 
   213:     # Multi timeframe filters -------------------------------------------------
   214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
   215:     if ohlcv_1h:
   216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
   217:         if len(h_closes) >= 52:
   218:             h_ema50 = ema(h_closes, 50)
   219:             if len(h_ema50) >= 2:
   220:                 slope = h_ema50[-1] - h_ema50[-2]
   221:                 if slope > 0:
   222:                     trend_dir = 1
   223:                 elif slope < 0:
   224:                     trend_dir = -1
   225: 
   226:     rsi_15 = None
   227:     if ohlcv_15m:
   228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
   229:         if len(m_closes) >= 15:
   230:             rsi_15 = calc_rsi(m_closes, 14)
   231: 
   232:     # RSI crossing logic (5m)
   233:     rsi_curr = calc_rsi(closes[-15:], 14)
   234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
   235: 
   236:     atr = calc_atr(highs, lows, closes, 14)
   237:     atr_pct = atr / price * 100.0 if price else 0.0
   238:     if atr_pct < atr_disable_pct:
   239:         return None
   240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
   241: 
   242:     sl_dist = 0.5 * atr
   243:     tp1_dist = 1.0 * atr
   244:     tp2_dist = 1.5 * atr
   245: 
   246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
   247: 
   248:     obi_ok_long = obi_ok_short = True
   249:     if order_book is not None:
   250:         bid = float(order_book.get("bid_vol_aggreg", 0))
   251:         ask = float(order_book.get("ask_vol_aggreg", 0))
   252:         obi = order_book_imbalance(bid, ask)
   253:         obi_ok_long = obi > 0.1
   254:         obi_ok_short = obi < -0.1
   255: 
   256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
   257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
   258: 
   259:     def _size(dist: float) -> float:
   260:         return calc_position_size(equity, risk_pct, dist) * size_mult
   261:     weights = {
   262:         "ema": 15.0,
   263:         "macd": 15.0,
   264:         "vwap": 15.0,
   265:         "rsi": 15.0,
   266:         "obv": 10.0,
   267:         "swing": 10.0,
   268:         "atr": 20.0,
   269:     }
   270: 
   271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
   272: 
   273:     long_score = atr_score
   274:     long_reasons: List[str] = []
   275:     if price > v:
   276:         long_score += weights["vwap"]
   277:         long_reasons.append("vwap")
   278:     if ema20[-1] > ema50[-1]:
   279:         long_score += weights["ema"]
   280:         long_reasons.append("ema")
   281:     if rsi_prev <= 40 < rsi_curr:
   282:         long_score += weights["rsi"]
   283:         long_reasons.append("rsi")
   284:     if macd_val > macd_sig:
   285:         long_score += weights["macd"]
   286:         long_reasons.append("macd")
   287:     if obv_rising or vol_rising:
   288:         long_score += weights["obv"]
   289:         long_reasons.append("obv")
   290:     if price > swing_high:
   291:         long_score += weights["swing"]
   292:         long_reasons.append("swing")
   293: 
   294:     short_score = atr_score
   295:     short_reasons: List[str] = []
   296:     if price < v:
   297:         short_score += weights["vwap"]
   298:         short_reasons.append("vwap")
   299:     if ema20[-1] < ema50[-1]:
   300:         short_score += weights["ema"]
   301:         short_reasons.append("ema")
   302:     if rsi_prev >= 60 > rsi_curr:
   303:         short_score += weights["rsi"]
   304:         short_reasons.append("rsi")
   305:     if macd_val < macd_sig:
   306:         short_score += weights["macd"]
   307:         short_reasons.append("macd")
   308:     if obv_series[-1] < obv_series[-2] or vol_rising:
   309:         short_score += weights["obv"]
   310:         short_reasons.append("obv")
   311:     if price < swing_low:
   312:         short_score += weights["swing"]
   313:         short_reasons.append("swing")
   314: 
   315:     side: Optional[str] = None
   316:     score: float = 0.0
   317:     reasons: List[str] = []
   318:     if (
   319:         long_score >= short_score
   320:         and long_score > 0
   321:         and macd_val > macd_sig
   322:         and obi_ok_long
   323:         and tick_ok_long
   324:         and trend_dir >= 0
   325:         and price > ema_trend[-1]
   326:     ):
   327:         side = "long"
   328:         score = long_score
   329:         reasons = long_reasons
   330:         sl = price - sl_dist
   331:         tp1 = price + tp1_dist
   332:         tp2 = price + tp2_dist
   333:     elif (
   334:         short_score > long_score
   335:         and short_score > 0
   336:         and macd_val < macd_sig
   337:         and obi_ok_short
   338:         and tick_ok_short
   339:         and trend_dir <= 0
   340:         and price < ema_trend[-1]
   341:     ):
   342:         side = "short"
   343:         score = short_score
   344:         reasons = short_reasons
   345:         sl = price + sl_dist
   346:         tp1 = price - tp1_dist
   347:         tp2 = price - tp2_dist
   348:     else:
   349:         return None
   350: 
   351:     qty = _size(sl_dist)
   352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
   353: 
   354: 
   355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
   356:     if "config" in kwargs:
   357:         config = kwargs.pop("config")
   358:         symbol = kwargs.pop("symbol", None)
   359:         ohlcv = kwargs.pop("ohlcv", None)
   360:         if ohlcv is None:
   361:             raise TypeError("ohlcv argument required")
   362:         return _generate_signal(
   363:             symbol or ohlcv.get("symbol", ""),
   364:             ohlcv,
   365:             equity=kwargs.pop("equity", 0.0),
   366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
   367:             **kwargs,
   368:         )
   369:     return _generate_signal(*args, **kwargs)
   370: 
   371: # ---------------------------------------------------------------------------
   372: # Backtesting utilities
   373: # ---------------------------------------------------------------------------
   374: 
   375: def max_drawdown(equity_curve: Sequence[float]) -> float:
   376:     peak = equity_curve[0]
   377:     mdd = 0.0
   378:     for x in equity_curve:
   379:         if x > peak:
   380:             peak = x
   381:         dd = (peak - x) / peak * 100.0
   382:         if dd > mdd:
   383:             mdd = dd
   384:     return mdd
   385: 
   386: def backtest(
   387:     trades: Sequence[Dict[str, Any]],
   388:     *,
   389:     equity_start: float = 1_000.0,
   390:     fee_rate: float = 0.0,
   391: ) -> Dict[str, float]:
   392:     """Evaluate a list of trade dictionaries.
   393: 
   394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
   395:     optionally include ``duration`` in minutes.  Results are aggregated into
   396:     common performance metrics to quickly evaluate the strategy.
   397:     """
   398: 
   399:     equity = equity_start
   400:     equity_curve = [equity]
   401:     pnl_pct_list: List[float] = []
   402:     wins = losses = 0
   403:     win_sum = loss_sum = 0.0
   404:     total_duration = 0.0
   405: 
   406:     for t in trades:
   407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
   408:         pnl_pct_list.append(pnl_pct)
   409:         if pnl_pct >= 0:
   410:             wins += 1
   411:             win_sum += pnl_pct
   412:         else:
   413:             losses += 1
   414:             loss_sum += pnl_pct
   415:         equity *= 1 + pnl_pct / 100.0
   416:         equity_curve.append(equity)
   417:         total_duration += float(t.get("duration", 0.0))
   418: 
   419:     pnl_pct_total = sum(pnl_pct_list)
   420:     pnl_usdt = equity - equity_start
   421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
   422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
   423:     mdd = max_drawdown(equity_curve)
   424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
   425:     exposure = total_duration  # in minutes, callers can normalise if desired
   426:     # Sharpe ratio based on per-trade returns
   427:     if len(pnl_pct_list) > 1:
   428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
   429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
   430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
   431:     else:
   432:         sharpe = 0.0
   433: 
   434:     return {
   435:         "pnl_usdt": pnl_usdt,
   436:         "pnl_pct": pnl_pct_total,
   437:         "profit_factor": profit_factor,
   438:         "winrate": winrate,
   439:         "max_drawdown": mdd,
   440:         "avg_trade_time": avg_trade_time,
   441:         "exposure": exposure,
   442:         "sharpe": sharpe,
   443:     }


## scalper/trade_utils.py (last modified: 2025-08-24 10:15:51)
     1: # scalper/trade_utils.py
     2: from __future__ import annotations
     3: 
     4: from typing import Optional
     5: 
     6: 
     7: def compute_position_size(
     8:     equity: float,
     9:     price: float,
    10:     risk_pct: float,
    11:     *,
    12:     symbol: Optional[str] = None,
    13:     min_qty: float = 0.0,
    14:     max_leverage: float = 1.0,
    15: ) -> float:
    16:     """
    17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
    18:     qty = notionnel / price
    19:     - min_qty : borne basse éventuelle (0 pour ignorer)
    20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
    21:     """
    22:     equity = float(max(0.0, equity))
    23:     price = float(max(1e-12, price))
    24:     risk_pct = float(max(0.0, risk_pct))
    25:     notionnel = equity * risk_pct * max_leverage
    26:     qty = notionnel / price
    27:     if min_qty > 0 and qty < min_qty:
    28:         return 0.0
    29:     return float(qty)

## scalper/version.py (last modified: 2025-08-24 10:15:51)
     1: """Utilities for managing the Scalp bot version."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from pathlib import Path
     6: import re
     7: 
     8: import subprocess
     9: 
    10: 
    11: # Path to the VERSION file within the package
    12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
    13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
    14: 
    15: 
    16: def get_version() -> str:
    17:     """Return the current version of the bot.
    18: 
    19:     If the VERSION file does not exist the default version ``0.0.0`` is
    20:     returned.
    21:     """
    22:     if not _VERSION_FILE.exists():
    23:         return "0.0.0"
    24:     return _VERSION_FILE.read_text().strip()
    25: 
    26: 
    27: def _parse(version: str) -> tuple[int, int, int]:
    28:     match = _VERSION_RE.match(version)
    29:     if not match:
    30:         raise ValueError(f"Invalid version: {version!r}")
    31:     return tuple(int(x) for x in match.groups())
    32: 
    33: 
    34: def bump_version(part: str = "patch") -> str:
    35:     """Bump the version stored in the VERSION file.
    36: 
    37:     Parameters
    38:     ----------
    39:     part:
    40:         Which component to increment. Accepted values are ``"major"``,
    41:         ``"minor"`` and ``"patch"`` (default).
    42:     """
    43:     major, minor, patch = _parse(get_version())
    44:     if part == "major":
    45:         major += 1
    46:         minor = 0
    47:         patch = 0
    48:     elif part == "minor":
    49:         minor += 1
    50:         patch = 0
    51: 
    52:     elif part == "patch":
    53:         patch += 1
    54:     else:
    55:         raise ValueError(f"Unknown part: {part}")
    56:     new_version = f"{major}.{minor}.{patch}"
    57:     _VERSION_FILE.write_text(f"{new_version}\n")
    58:     return new_version
    59: 
    60: 
    61: def bump_version_from_message(message: str) -> str:
    62:     """Bump the version according to a commit message.
    63: 
    64:     ``message`` is evaluated using a tiny subset of the Conventional
    65:     Commits spec. Messages starting with ``feat`` bump the *minor*
    66:     version, messages whose header ends with ``!`` or contain
    67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
    68:     bump the *patch* component.
    69:     """
    70: 
    71:     header = message.strip().splitlines()[0].lower()
    72:     lower = message.lower()
    73:     type_part = header.split(":")[0]
    74:     if "!" in type_part or "breaking change" in lower:
    75:         part = "major"
    76:     elif type_part.startswith("feat"):
    77:         part = "minor"
    78:     else:
    79:         part = "patch"
    80:     return bump_version(part)
    81: 
    82: 
    83: def bump_version_from_git() -> str:
    84:     """Read the latest git commit message and bump the version accordingly."""
    85:     try:
    86:         message = subprocess.check_output(
    87:             ["git", "log", "-1", "--pretty=%B"], text=True
    88:         ).strip()
    89:     except Exception:
    90:         message = ""
    91:     return bump_version_from_message(message)
    92: 
    93: 
    94: if __name__ == "__main__":
    95:     print(bump_version_from_git())


## scalper/ws.py (last modified: 2025-08-24 10:15:51)
     1: """Minimal websocket manager with heartbeat and auto-resubscribe.
     2: 
     3: This module provides a light-weight framework to maintain a realtime
     4: connection to an exchange.  The actual network layer is expected to be
     5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
     6: manager handles retrying failed connections and periodically invoking the
     7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
     8: without opening real network sockets.
     9: """
    10: from __future__ import annotations
    11: 
    12: import asyncio
    13: import logging
    14: from typing import Awaitable, Callable, Optional
    15: 
    16: 
    17: class WebsocketManager:
    18:     """Maintain a websocket connection with heartbeat and retry."""
    19: 
    20:     def __init__(
    21:         self,
    22:         connect: Callable[[], Awaitable[None]],
    23:         subscribe: Callable[[], Awaitable[None]],
    24:         *,
    25:         heartbeat_interval: float = 30.0,
    26:         max_retries: int = 3,
    27:     ) -> None:
    28:         self._connect = connect
    29:         self._subscribe = subscribe
    30:         self.heartbeat_interval = heartbeat_interval
    31:         self.max_retries = max_retries
    32:         self._heartbeat_task: Optional[asyncio.Task] = None
    33: 
    34:     async def run(self) -> None:
    35:         """Open the connection retrying on failure."""
    36:         retries = 0
    37:         while True:
    38:             try:
    39:                 await self._connect()
    40:                 await self._subscribe()
    41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
    42:                 return
    43:             except Exception as exc:  # pragma: no cover - network errors
    44:                 logging.error("websocket connect failed: %s", exc)
    45:                 retries += 1
    46:                 if retries > self.max_retries:
    47:                     raise
    48:                 await asyncio.sleep(1)
    49: 
    50:     async def _heartbeat(self) -> None:
    51:         """Send periodic heartbeats and resubscribe on failure."""
    52:         while True:
    53:             await asyncio.sleep(self.heartbeat_interval)
    54:             try:
    55:                 await self._subscribe()
    56:             except Exception as exc:  # pragma: no cover - network errors
    57:                 logging.warning("websocket heartbeat failed: %s", exc)
    58:                 await self.run()
    59:                 break
    60: 
    61:     async def stop(self) -> None:
    62:         """Cancel the heartbeat task if it is running."""
    63:         task = self._heartbeat_task
    64:         if task and not task.done():
    65:             task.cancel()
    66:             try:
    67:                 await task
    68:             except BaseException:  # pragma: no cover - cancellation
    69:                 pass
    70:         self._heartbeat_task = None


## sitecustomize.py (last modified: 2025-08-24 10:15:51)
     1: # sitecustomize.py
     2: # Importé automatiquement par Python si présent sur le PYTHONPATH (répertoire courant).
     3: # Rôle : charger les secrets depuis /notebooks/.env, normaliser les alias,
     4: # charger la config YAML, puis lancer un pré‑flight et écrire un green‑flag.
     5: 
     6: from __future__ import annotations
     7: 
     8: import os
     9: 
    10: def _load_dotenv_parent():
    11:     try:
    12:         from dotenv import load_dotenv  # pip install python-dotenv si manquant
    13:     except Exception:
    14:         return
    15:     # Règle historique du projet : .env au parent des notebooks (ex: /notebooks/.env)
    16:     load_dotenv("/notebooks/.env")
    17: 
    18: def _apply_aliases_and_prefetch_cfg():
    19:     try:
    20:         from scalper.config.loader import apply_env_aliases, load_yaml_config
    21:         apply_env_aliases()           # ne traite que les secrets (BITGET_*, TELEGRAM_*)
    22:         # Chargement anticipé (au cas où certains modules le lisent tôt)
    23:         _ = load_yaml_config()
    24:     except Exception:
    25:         pass
    26: 
    27: def _run_preflight():
    28:     if os.getenv("SKIP_PREFLIGHT", "0").lower() in ("1", "true", "yes", "on"):
    29:         return
    30:     try:
    31:         from scalper.selfcheck import preflight_or_die
    32:         preflight_or_die(verbose=False)
    33:     except SystemExit:
    34:         raise
    35:     except Exception:
    36:         # On n'empêche pas l'exécution si le selfcheck plante pour une raison non critique
    37:         pass
    38: 
    39: # Boot sequence
    40: try:
    41:     _load_dotenv_parent()            # charge /notebooks/.env
    42:     _apply_aliases_and_prefetch_cfg()# normalise + précharge config.yaml
    43:     _run_preflight()                 # valide et écrit le green-flag
    44: except Exception:
    45:     # Jamais bloquant
    46:     pass

## tests/conftest.py (last modified: 2025-08-24 10:15:51)
     1: """Test configuration and shared fixtures."""
     2: 
     3: import sys
     4: import types
     5: from pathlib import Path
     6: 
     7: 
     8: # Ensure the project root is importable so tests can ``import bot``.
     9: ROOT = Path(__file__).resolve().parents[1]
    10: sys.path.insert(0, str(ROOT))
    11: 
    12: 
    13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
    14: # the real dependency during test collection. Individual tests patch the
    15: # functions they need (``request``/``post``/``get``).
    16: sys.modules.setdefault(
    17:     "requests",
    18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
    19: )
    20: 


## tests/test_analyse_risque.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.SimpleNamespace(
     7:     request=lambda *a, **k: None,
     8:     post=lambda *a, **k: None,
     9:     HTTPError=Exception,
    10: )
    11: 
    12: from bot import analyse_risque  # noqa: E402
    13: 
    14: 
    15: def make_contract_detail():
    16:     return {
    17:         "data": [
    18:             {
    19:                 "symbol": "BTC_USDT",
    20:                 "contractSize": 0.01,
    21:                 "volUnit": 1,
    22:                 "minVol": 1,
    23:             }
    24:         ]
    25:     }
    26: 
    27: 
    28: def test_analyse_risque_limits_and_leverage():
    29:     contract_detail = make_contract_detail()
    30:     # Risk level 1: leverage halved, limit 1 position
    31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
    32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    33:                                symbol="BTC_USDT", side="long", risk_level=1)
    34:     assert lev == 5
    35:     assert vol == 0  # already one long position
    36: 
    37:     # Risk level 2: base leverage, limit 3 positions
    38:     open_pos = [
    39:         {"symbol": "BTC_USDT", "side": "long"},
    40:         {"symbol": "BTC_USDT", "side": "long"},
    41:         {"symbol": "BTC_USDT", "side": "long"},
    42:     ]
    43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    44:                                symbol="BTC_USDT", side="long", risk_level=2)
    45:     assert lev == 10
    46:     assert vol == 0
    47: 
    48:     # Risk level 3: leverage doubled, no existing position
    49:     open_pos = []
    50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    51:                                symbol="BTC_USDT", side="long", risk_level=3)
    52:     assert lev == 20
    53:     assert vol == 1


## tests/test_backtest.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: 
     3: import bot
     4: 
     5: 
     6: def test_backtest_trades():
     7:     trades = [
     8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
     9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
    10:     ]
    11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
    12:     # Both trades: 10% - 0.2% fee = 9.8% each
    13:     assert pnl == pytest.approx(19.6)


## tests/test_backtest_multi.py (last modified: 2025-08-24 10:15:51)
     1: import csv
     2: import random
     3: from datetime import datetime, timedelta, timezone
     4: from pathlib import Path
     5: 
     6: import pytest
     7: 
     8: from scalper.backtest.run_multi import run_backtest_multi
     9: from scalper.strategy import Signal
    10: 
    11: 
    12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
    13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
    14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
    15:     with open(filename, "w", newline="") as fh:
    16:         writer = csv.writer(fh)
    17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    18:         for i in range(200):
    19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
    20:             price = 100 + i
    21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
    22: 
    23: 
    24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    25:     closes = ohlcv["close"]
    26:     if len(closes) < 10:
    27:         return None
    28:     price = closes[-1]
    29:     sl = price * 0.99
    30:     tp = price * 1.01
    31:     qty = equity * risk_pct / (price - sl)
    32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
    33: 
    34: 
    35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
    37:         return None
    38:     price = ohlcv["close"][-1]
    39:     sl = price * 0.99
    40:     tp = price * 1.01
    41:     qty = equity * risk_pct / (price - sl)
    42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
    43: 
    44: 
    45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    46:     closes = ohlcv["close"]
    47:     if len(closes) < 10:
    48:         return None
    49:     price = closes[-1]
    50:     sl = price * 0.99
    51:     tp = price * 1.01
    52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
    53: 
    54: 
    55: def find_row(summary, symbol):
    56:     for row in summary:
    57:         if row["symbol"] == symbol:
    58:             return row
    59:     raise KeyError(symbol)
    60: 
    61: 
    62: def test_csv_multi_pairs(tmp_path, monkeypatch):
    63:     for sym in ["BTC/USDT", "ETH/USDT"]:
    64:         make_csv(tmp_path, sym)
    65:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
    66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
    67:     out = tmp_path / "out"
    68:     summary, trades = run_backtest_multi(
    69:         symbols=["BTC/USDT", "ETH/USDT"],
    70:         exchange="csv",
    71:         timeframe="1m",
    72:         csv_dir=str(tmp_path),
    73:         fee_rate=0.0,
    74:         slippage_bps=0.0,
    75:         risk_pct=0.01,
    76:         initial_equity=1000,
    77:         leverage=1.0,
    78:         paper_constraints=True,
    79:         seed=42,
    80:         out_dir=str(out),
    81:         plot=False,
    82:     )
    83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
    84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
    85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
    86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
    87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
    88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
    89:     # files
    90:     assert (out / "report_summary.csv").exists()
    91:     assert (out / "report_trades.csv").exists()
    92:     assert (out / "equity_curve_total.csv").exists()
    93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
    94:     # columns in trades
    95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
    96:         assert col in trades[0]
    97: 
    98: 
    99: def test_fee_slippage(tmp_path, monkeypatch):
   100:     make_csv(tmp_path, "BTC/USDT")
   101:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
   102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
   103:     summary1, _ = run_backtest_multi(
   104:         symbols=["BTC/USDT"],
   105:         exchange="csv",
   106:         timeframe="1m",
   107:         csv_dir=str(tmp_path),
   108:         fee_rate=0.0,
   109:         slippage_bps=0.0,
   110:         out_dir=str(tmp_path / "o1"),
   111:     )
   112:     summary2, _ = run_backtest_multi(
   113:         symbols=["BTC/USDT"],
   114:         exchange="csv",
   115:         timeframe="1m",
   116:         csv_dir=str(tmp_path),
   117:         fee_rate=0.01,
   118:         slippage_bps=100,
   119:         out_dir=str(tmp_path / "o2"),
   120:     )
   121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
   122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
   123:     assert pnl2 < pnl1
   124: 
   125: 
   126: def test_paper_constraints(tmp_path, monkeypatch):
   127:     make_csv(tmp_path, "BTC/USDT")
   128:     monkeypatch.setattr("scalper.strategy.generate_signal", tiny_qty_signal)
   129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
   130:     summary, trades = run_backtest_multi(
   131:         symbols=["BTC/USDT"],
   132:         exchange="csv",
   133:         timeframe="1m",
   134:         csv_dir=str(tmp_path),
   135:         paper_constraints=True,
   136:         out_dir=str(tmp_path / "o"),
   137:     )
   138:     assert all(t["qty"] >= 0.001 for t in trades)
   139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
   140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
   141: 
   142: 
   143: def test_seed_reproducible(tmp_path, monkeypatch):
   144:     make_csv(tmp_path, "BTC/USDT")
   145:     monkeypatch.setattr("scalper.strategy.generate_signal", random_signal)
   146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
   147:     s1, t1 = run_backtest_multi(
   148:         symbols=["BTC/USDT"],
   149:         exchange="csv",
   150:         timeframe="1m",
   151:         csv_dir=str(tmp_path),
   152:         seed=7,
   153:         out_dir=str(tmp_path / "o1"),
   154:     )
   155:     s2, t2 = run_backtest_multi(
   156:         symbols=["BTC/USDT"],
   157:         exchange="csv",
   158:         timeframe="1m",
   159:         csv_dir=str(tmp_path),
   160:         seed=7,
   161:         out_dir=str(tmp_path / "o2"),
   162:     )
   163:     assert t1 == t2
   164:     assert s1 == s2


## tests/test_backtest_position.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import pytest
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: 
     7: from scalper.metrics import backtest_position
     8: 
     9: 
    10: def test_backtest_position_long():
    11:     prices = [100.0, 110.0, 120.0]
    12:     assert backtest_position(prices, 0, 2, 1) is True
    13: 
    14: 
    15: def test_backtest_position_short():
    16:     prices = [100.0, 90.0, 80.0]
    17:     assert backtest_position(prices, 0, 2, -1) is True
    18: 
    19: 
    20: def test_backtest_position_incoherent():
    21:     prices = [100.0, 110.0, 120.0]
    22:     assert backtest_position(prices, 0, 2, -1) is False
    23: 
    24: 
    25: def test_backtest_position_bad_indices():
    26:     prices = [100.0, 110.0]
    27:     with pytest.raises(ValueError):
    28:         backtest_position(prices, 1, 0, 1)


## tests/test_bitget_futures_pairs.py (last modified: 2025-08-24 10:15:51)
     1: import json
     2: from pathlib import Path
     3: from typing import Any, Dict
     4: 
     5: import pytest
     6: 
     7: import bitget_futures_pairs as bfp
     8: 
     9: 
    10: class DummyResponse:
    11:     def __init__(self, status: int, payload: Dict[str, Any]):
    12:         self.status_code = status
    13:         self._payload = payload
    14:         self.text = json.dumps(payload)
    15: 
    16:     def json(self):
    17:         return self._payload
    18: 
    19: 
    20: def test_fetch_contracts_success(monkeypatch):
    21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
    22: 
    23:     def fake_get(url, params=None, timeout=0):
    24:         return DummyResponse(200, payload)
    25: 
    26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
    28:     assert contracts == payload["data"]
    29: 
    30: 
    31: def test_fetch_contracts_error(monkeypatch):
    32:     payload = {"code": "10001"}
    33: 
    34:     def fake_get(url, params=None, timeout=0):
    35:         return DummyResponse(200, payload)
    36: 
    37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    38:     with pytest.raises(RuntimeError):
    39:         bfp.fetch_contracts("USDT-FUTURES")
    40: 
    41: 
    42: def test_normalize_rows():
    43:     contracts = [
    44:         {
    45:             "symbol": "BTCUSDT",
    46:             "baseCoin": "BTC",
    47:             "quoteCoin": "USDT",
    48:             "symbolType": "perpetual",
    49:             "symbolStatus": "normal",
    50:             "maxLever": "50",
    51:             "minLever": "1",
    52:             "minTradeNum": "0.001",
    53:             "sizeMultiplier": "1",
    54:             "pricePlace": "2",
    55:             "volumePlace": "3",
    56:             "launchTime": 0,
    57:             "deliveryTime": 0,
    58:         }
    59:     ]
    60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
    61:     assert rows[0]["symbol"] == "BTCUSDT"
    62:     assert rows[0]["productType"] == "USDT-FUTURES"
    63: 
    64: 
    65: def test_write_csv(tmp_path: Path):
    66:     path = tmp_path / "pairs.csv"
    67:     bfp.write_csv([], str(path))
    68:     assert path.exists()
    69:     content = path.read_text().splitlines()
    70:     assert content[0].startswith("productType,")


## tests/test_bot_place_order_caps.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import types
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: sys.modules['requests'] = types.ModuleType('requests')
     6: 
     7: from bot import attempt_entry, Signal
     8: 
     9: 
    10: class DummyClient:
    11:     def __init__(self):
    12:         self.last_order = None
    13: 
    14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
    15:         self.last_order = (args, kwargs)
    16:         return {"code": "00000"}
    17: 
    18: 
    19: class DummyRisk:
    20:     def __init__(self, pct):
    21:         self.risk_pct = pct
    22: 
    23: 
    24: def _detail():
    25:     return {
    26:         "data": [
    27:             {
    28:                 "symbol": "BTC_USDT",
    29:                 "contractSize": 0.001,
    30:                 "volUnit": 1,
    31:                 "minVol": 1,
    32:                 "minTradeUSDT": 5,
    33:             }
    34:         ]
    35:     }
    36: 
    37: 
    38: def test_attempt_entry_respects_caps(monkeypatch):
    39:     captured = {}
    40: 
    41:     def fake_notify(event, payload):
    42:         captured[event] = payload
    43: 
    44:     monkeypatch.setattr("bot.notify", fake_notify)
    45:     client = DummyClient()
    46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    47:     rm = DummyRisk(0.02)
    48:     equity = 100
    49:     available = 2.2  # just enough for 1 contract with buffer
    50:     params = attempt_entry(
    51:         client,
    52:         _detail(),
    53:         sig,
    54:         equity_usdt=equity,
    55:         available_usdt=available,
    56:         cfg={"LEVERAGE": 10},
    57:         risk_mgr=rm,
    58:         user_risk_level=1,
    59:     )
    60:     assert client.last_order is not None
    61:     assert params["vol"] >= 1
    62:     opened = captured["position_opened"]
    63:     assert opened["notional_usdt"] >= 5
    64:     assert opened["vol"] >= 1
    65: 
    66: 
    67: def test_attempt_entry_insufficient_margin(monkeypatch):
    68:     captured = {}
    69: 
    70:     def fake_notify(event, payload):
    71:         captured[event] = payload
    72: 
    73:     monkeypatch.setattr("bot.notify", fake_notify)
    74:     client = DummyClient()
    75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    76:     rm = DummyRisk(0.02)
    77:     equity = 100
    78:     available = 1.0  # below required margin
    79:     params = attempt_entry(
    80:         client,
    81:         _detail(),
    82:         sig,
    83:         equity_usdt=equity,
    84:         available_usdt=available,
    85:         cfg={"LEVERAGE": 10},
    86:         risk_mgr=rm,
    87:         user_risk_level=1,
    88:     )
    89:     assert client.last_order is None
    90:     assert params["vol"] == 0
    91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
    92: 
    93: 
    94: def test_attempt_entry_under_min_trade(monkeypatch):
    95:     captured = {}
    96: 
    97:     def fake_notify(event, payload):
    98:         captured[event] = payload
    99: 
   100:     monkeypatch.setattr("bot.notify", fake_notify)
   101:     client = DummyClient()
   102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
   103:     rm = DummyRisk(0.02)
   104:     detail = {
   105:         "data": [
   106:             {
   107:                 "symbol": "BTC_USDT",
   108:                 "contractSize": 0.001,
   109:                 "volUnit": 1,
   110:                 "minVol": 1,
   111:                 "minTradeUSDT": 50,
   112:             }
   113:         ]
   114:     }
   115:     equity = 100
   116:     available = 100
   117:     params = attempt_entry(
   118:         client,
   119:         detail,
   120:         sig,
   121:         equity_usdt=equity,
   122:         available_usdt=available,
   123:         cfg={"LEVERAGE": 10},
   124:         risk_mgr=rm,
   125:         user_risk_level=1,
   126:     )
   127:     assert client.last_order is None
   128:     assert params["vol"] == 0
   129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")


## tests/test_bot_update.py (last modified: 2025-08-24 10:15:51)
     1: import logging
     2: import bot
     3: 
     4: 
     5: def test_update_displays_pairs(monkeypatch, caplog):
     6:     def fake_send(client, top_n=40):
     7:         assert (client, top_n) == ("cli", 5)
     8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
     9: 
    10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
    11:     with caplog.at_level(logging.INFO):
    12:         payload = bot.update("cli", top_n=5)
    13:     assert payload["green"] == "BTC"
    14:     assert "Listing ok" in caplog.text
    15: 
    16: 
    17: def test_update_survives_errors(monkeypatch, caplog):
    18:     """``update`` should never raise even if pair selection fails."""
    19: 
    20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
    21:         raise RuntimeError("network down")
    22: 
    23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
    24:     with caplog.at_level(logging.INFO):
    25:         payload = bot.update("cli", top_n=5)
    26: 
    27:     # The function returns an empty payload and logs the error, but still logs
    28:     # the "Listing ok" acknowledgement so callers can proceed.
    29:     assert payload == {}
    30:     assert "network down" in caplog.text
    31:     assert "Listing ok" in caplog.text
    32: 


## tests/test_break_even_stop.py (last modified: 2025-08-24 10:15:51)
     1: from scalper.trade_utils import break_even_stop
     2: 
     3: 
     4: def test_break_even_stop_long() -> None:
     5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
     6:     assert sl == 100
     7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
     8:     assert sl == 95
     9: 
    10: 
    11: def test_break_even_stop_short() -> None:
    12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
    13:     assert sl == 100
    14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
    15:     assert sl == 105


## tests/test_calc_pnl_pct.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import pytest
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: 
     6: from scalper.metrics import calc_pnl_pct
     7: 
     8: 
     9: def test_calc_pnl_pct_long():
    10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
    11: 
    12: def test_calc_pnl_pct_short():
    13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
    14: 
    15: 
    16: def test_calc_pnl_pct_with_fee():
    17:     # 10% move minus 0.1%*2 fees = 9.8%
    18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)


## tests/test_check_config.py (last modified: 2025-08-24 10:15:51)
     1: import logging
     2: from bot import check_config
     3: 
     4: 
     5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
     6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
     7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
     8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
     9:     with caplog.at_level(logging.INFO):
    10:         check_config()
    11:     messages = [r.getMessage() for r in caplog.records]
    12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
    13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
    14:     assert all("NOTIFY_URL" not in m for m in messages)
    15: 
    16: 
    17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
    18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
    19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
    20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
    21:     with caplog.at_level(logging.INFO):
    22:         check_config()
    23:     assert caplog.records == []


## tests/test_cli.py (last modified: 2025-08-24 10:15:51)
     1: """Tests for the command line interface defined in :mod:`cli`."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import cli
     6: 
     7: 
     8: def test_opt_invokes_parallel_optimization(monkeypatch):
     9:     """The ``opt`` command should call ``run_parallel_optimization``."""
    10: 
    11:     called = {}
    12: 
    13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
    14:         called["args"] = (pairs, tf, jobs)
    15: 
    16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
    17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
    18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
    19: 
    20: 
    21: def test_walkforward_invokes_analysis(monkeypatch):
    22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
    23: 
    24:     called = {}
    25: 
    26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
    27:         called["args"] = (pair, tf, splits, train_ratio)
    28: 
    29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
    30:     cli.main(
    31:         [
    32:             "walkforward",
    33:             "--pair",
    34:             "BTCUSDT",
    35:             "--tf",
    36:             "1m",
    37:             "--splits",
    38:             "3",
    39:             "--train-ratio",
    40:             "0.8",
    41:         ]
    42:     )
    43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
    44: 
    45: 
    46: def test_live_invokes_async_pipeline(monkeypatch):
    47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
    48: 
    49:     called = {}
    50: 
    51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
    52:         called["args"] = (pairs, list(tfs))
    53: 
    54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
    55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
    56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
    57: 
    58: 
    59: def test_bump_version_invokes_helper(monkeypatch):
    60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
    61: 
    62:     called = {}
    63: 
    64:     def fake_bump():  # pragma: no cover - executed via CLI
    65:         called["called"] = True
    66:         return "0.1.0"
    67: 
    68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
    69:     cli.main(["bump-version"])
    70:     assert called["called"] is True
    71: 


## tests/test_client.py (last modified: 2025-08-24 10:15:51)
     1: import json
     2: import hmac
     3: import hashlib
     4: import base64
     5: import pytest
     6: import bot
     7: from bot import BitgetFuturesClient
     8: 
     9: 
    10: @pytest.fixture(autouse=True)
    11: def no_log_event(monkeypatch):
    12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
    13: 
    14: 
    15: def test_private_request_get_signature(monkeypatch):
    16:     client = BitgetFuturesClient("key", "secret", "https://test")
    17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    18: 
    19:     called = {}
    20: 
    21:     def fake_request(method, url, headers=None, timeout=None):
    22:         called["method"] = method
    23:         called["url"] = url
    24:         called["headers"] = headers
    25: 
    26:         class Resp:
    27:             def raise_for_status(self):
    28:                 pass
    29: 
    30:             def json(self):
    31:                 return {"success": True}
    32: 
    33:         return Resp()
    34: 
    35:     monkeypatch.setattr(bot.requests, "request", fake_request)
    36: 
    37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
    38:     assert resp["success"] is True
    39:     qs = "a=1&b=2"
    40:     prehash = f"1000GET/api/test?{qs}"
    41:     expected = base64.b64encode(
    42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    43:     ).decode()
    44:     assert called["headers"]["ACCESS-SIGN"] == expected
    45:     assert called["headers"]["ACCESS-KEY"] == "key"
    46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    48:     assert called["url"] == "https://test/api/test?a=1&b=2"
    49: 
    50: 
    51: def test_private_request_post_signature(monkeypatch):
    52:     client = BitgetFuturesClient("key", "secret", "https://test")
    53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    54: 
    55:     called = {}
    56: 
    57:     def fake_post(url, data=None, headers=None, timeout=None):
    58:         called["url"] = url
    59:         called["data"] = data
    60:         called["headers"] = headers
    61: 
    62:         class Resp:
    63:             def raise_for_status(self):
    64:                 pass
    65: 
    66:             def json(self):
    67:                 return {"success": True}
    68: 
    69:         return Resp()
    70: 
    71:     monkeypatch.setattr(bot.requests, "post", fake_post)
    72: 
    73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
    74:     assert resp["success"] is True
    75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
    76:     prehash = f"1000POST/api/test{body}"
    77:     expected = base64.b64encode(
    78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    79:     ).decode()
    80:     assert called["headers"]["ACCESS-SIGN"] == expected
    81:     assert called["headers"]["ACCESS-KEY"] == "key"
    82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    84:     assert called["data"].decode("utf-8") == body
    85:     assert called["url"] == "https://test/api/test"
    86: 
    87: 
    88: def test_private_request_http_error(monkeypatch):
    89:     client = BitgetFuturesClient("key", "secret", "https://test")
    90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    91: 
    92:     class Resp:
    93:         status_code = 418
    94: 
    95:         def raise_for_status(self):
    96:             raise bot.requests.HTTPError("teapot")
    97: 
    98:         def json(self):
    99:             return {"unused": True}
   100: 
   101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
   102: 
   103:     resp = client._private_request("GET", "/api/test")
   104:     assert resp["success"] is False
   105:     assert resp["status_code"] == 418
   106:     assert "teapot" in resp["error"]
   107: 
   108: 
   109: def test_get_assets_normalization(monkeypatch):
   110:     client = BitgetFuturesClient("key", "secret", "https://test")
   111: 
   112:     called = {}
   113: 
   114:     def fake_private(self, method, path, params=None, body=None):
   115:         called["method"] = method
   116:         called["path"] = path
   117:         called["params"] = params
   118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
   119: 
   120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   121: 
   122:     assets = client.get_assets()
   123: 
   124:     assert assets["success"] is True
   125:     usdt = assets.get("data", [])[0]
   126:     assert usdt["currency"].upper() == "USDT"
   127:     assert usdt["equity"] == 1.0
   128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
   129: 
   130: 
   131: def test_get_assets_equity_fallback(monkeypatch):
   132:     client = BitgetFuturesClient("key", "secret", "https://test")
   133: 
   134:     def fake_private(self, method, path, params=None, body=None):
   135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
   136: 
   137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   138: 
   139:     assets = client.get_assets()
   140:     usdt = assets.get("data", [])[0]
   141:     assert usdt["currency"] == "USDT"
   142:     assert usdt["equity"] == 2.0
   143: 
   144: 
   145: def test_get_assets_prefers_available(monkeypatch):
   146:     """When both equity and available are returned, available should win."""
   147:     client = BitgetFuturesClient("key", "secret", "https://test")
   148: 
   149:     def fake_private(self, method, path, params=None, body=None):
   150:         return {
   151:             "code": "00000",
   152:             "data": [
   153:                 {
   154:                     "marginCoin": "USDT",
   155:                     "equity": "5",
   156:                     "available": "1",
   157:                 }
   158:             ],
   159:         }
   160: 
   161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   162: 
   163:     assets = client.get_assets()
   164:     usdt = assets.get("data", [])[0]
   165:     assert usdt["equity"] == 1.0
   166: 
   167: 
   168: 
   169: def test_get_assets_zero_available(monkeypatch):
   170:     """Zero available balance should propagate as zero equity."""
   171:     client = BitgetFuturesClient("key", "secret", "https://test")
   172: 
   173:     def fake_private(self, method, path, params=None, body=None):
   174:         return {
   175:             "code": "00000",
   176:             "data": [
   177:                 {
   178:                     "marginCoin": "USDT",
   179:                     "available": "0",
   180:                     "equity": "5",
   181:                 }
   182:             ],
   183:         }
   184: 
   185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   186: 
   187:     assets = client.get_assets()
   188:     usdt = assets.get("data", [])[0]
   189:     assert usdt["equity"] == 0.0
   190: 
   191: 
   192: def test_get_assets_available_balance(monkeypatch):
   193:     """Support alternative ``availableBalance`` field name."""
   194:     client = BitgetFuturesClient("key", "secret", "https://test")
   195: 
   196:     def fake_private(self, method, path, params=None, body=None):
   197:         return {
   198:             "code": "00000",
   199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
   200:         }
   201: 
   202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   203: 
   204:     assets = client.get_assets()
   205:     usdt = assets.get("data", [])[0]
   206:     assert usdt["equity"] == 3.5
   207: 
   208: 
   209: def test_get_ticker_normalization(monkeypatch):
   210:     client = BitgetFuturesClient("key", "secret", "https://test")
   211: 
   212:     called = {}
   213: 
   214:     def fake_get(url, params=None, timeout=None):
   215:         called["url"] = url
   216:         called["params"] = params
   217: 
   218:         class Resp:
   219:             def raise_for_status(self):
   220:                 pass
   221: 
   222:             def json(self):
   223:                 return {
   224:                     "data": {
   225:                         "instId": "BTCUSDT",
   226:                         "lastPr": "1",
   227:                         "bestBidPrice": "0.9",
   228:                         "bestAskPrice": "1.1",
   229:                         "usdtVolume": "100",
   230:                     }
   231:                 }
   232: 
   233:         return Resp()
   234: 
   235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   236: 
   237:     ticker = client.get_ticker("BTC_USDT")
   238: 
   239:     assert ticker["success"] is True
   240:     data = ticker["data"][0]
   241:     assert data["symbol"] == "BTCUSDT"
   242:     assert data["lastPrice"] == "1"
   243:     assert data["bidPrice"] == "0.9"
   244:     assert data["askPrice"] == "1.1"
   245:     assert data["volume"] == 100.0
   246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
   247: 
   248: 
   249: def test_http_client_context_manager(monkeypatch):
   250:     import sys
   251:     import importlib
   252:     sys.modules.pop('requests', None)
   253:     real_requests = importlib.import_module('requests')
   254:     sys.modules['requests'] = real_requests
   255:     import scalper.client as http_client
   256:     importlib.reload(http_client)
   257: 
   258:     closed = {"count": 0}
   259: 
   260:     class DummySession:
   261:         def mount(self, *a, **k):
   262:             pass
   263: 
   264:         def request(self, *a, **k):
   265:             class Resp:
   266:                 def raise_for_status(self):
   267:                     pass
   268: 
   269:                 def json(self):
   270:                     return {}
   271: 
   272:                 text = "{}"
   273: 
   274:             return Resp()
   275: 
   276:         def close(self):
   277:             closed["count"] += 1
   278: 
   279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
   280: 
   281:     http = http_client.HttpClient("http://example.com")
   282:     http.close()
   283:     assert closed["count"] == 1
   284: 
   285:     closed["count"] = 0
   286:     with http_client.HttpClient("http://example.com") as hc:
   287:         hc.request("GET", "/")
   288:     assert closed["count"] == 1
   289: 
   290: 
   291: def test_get_kline_query_params(monkeypatch):
   292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
   293:     query parameter. The previous implementation embedded the symbol in the
   294:     path which resulted in a 404 from Bitget."""
   295: 
   296:     client = BitgetFuturesClient("key", "secret", "https://test")
   297: 
   298:     called = {}
   299: 
   300:     def fake_get(url, params=None, timeout=None):
   301:         called["url"] = url
   302:         called["params"] = params
   303: 
   304:         class Resp:
   305:             def raise_for_status(self):
   306:                 pass
   307: 
   308:             def json(self):
   309:                 return {"data": []}
   310: 
   311:         return Resp()
   312: 
   313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
   314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
   315:     # even if missing so we can observe the call.
   316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   317: 
   318:     client.get_kline("BTC_USDT", interval="Min1")
   319: 
   320:     assert called["url"].endswith("/api/v2/mix/market/candles")
   321:     assert called["params"] == {
   322:         "symbol": "BTCUSDT",
   323:         "productType": "USDT-FUTURES",
   324:         "granularity": "1m",
   325:     }
   326: 
   327: 
   328: def test_get_open_orders_endpoint(monkeypatch):
   329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   330: 
   331:     called = {}
   332: 
   333:     def fake_private(self, method, path, params=None, body=None):
   334:         called["method"] = method
   335:         called["path"] = path
   336:         called["params"] = params
   337:         return {"success": True}
   338: 
   339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   340: 
   341:     client.get_open_orders("BTCUSDT_UMCBL")
   342: 
   343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
   344:     assert called["params"] == {
   345:         "productType": "USDT-FUTURES",
   346:         "symbol": "BTCUSDT",
   347:     }
   348: 
   349: 
   350: def test_product_type_alias():
   351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
   352:     assert client.product_type == "USDT-FUTURES"
   353: 
   354: 
   355: def test_get_contract_detail_endpoint(monkeypatch):
   356:     client = BitgetFuturesClient("key", "secret", "https://test")
   357: 
   358:     called = {}
   359: 
   360:     def fake_get(url, params=None, timeout=None):
   361:         called["url"] = url
   362:         called["params"] = params
   363: 
   364:         class Resp:
   365:             status_code = 200
   366: 
   367:             def raise_for_status(self):
   368:                 pass
   369: 
   370:             def json(self):
   371:                 return {"data": []}
   372: 
   373:         return Resp()
   374: 
   375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   376: 
   377:     client.get_contract_detail("BTCUSDT_UMCBL")
   378: 
   379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
   380:     assert called["params"] == {
   381:         "productType": "USDT-FUTURES",
   382:         "symbol": "BTCUSDT",
   383:     }
   384: 
   385: 
   386: def test_cancel_all_endpoint(monkeypatch):
   387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   388: 
   389:     called = {}
   390: 
   391:     def fake_private(self, method, path, params=None, body=None):
   392:         called["method"] = method
   393:         called["path"] = path
   394:         called["params"] = params
   395:         called["body"] = body
   396:         return {"success": True}
   397: 
   398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   399: 
   400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   401: 
   402:     assert called["method"] == "POST"
   403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
   404:     assert called["params"] is None
   405:     assert called["body"] == {
   406:         "productType": "USDT-FUTURES",
   407:         "symbol": "BTCUSDT",
   408:         "marginCoin": "USDT",
   409:     }
   410: 
   411: 
   412: def test_place_order_endpoint(monkeypatch):
   413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   414: 
   415:     called = {}
   416: 
   417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   418: 
   419:     def fake_private(self, method, path, params=None, body=None):
   420:         called["method"] = method
   421:         called["path"] = path
   422:         called["body"] = body
   423:         return {"success": True}
   424: 
   425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   426: 
   427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
   428: 
   429:     assert resp["success"] is True
   430:     assert called["method"] == "POST"
   431:     assert called["path"] == "/api/v2/mix/order/place-order"
   432:     body = called["body"]
   433:     assert body["symbol"] == "BTCUSDT"
   434:     assert body["marginCoin"] == "USDT"
   435:     assert body["marginMode"] == "crossed"
   436:     assert body["side"] == "buy"
   437:     assert body["posSide"] == "long"
   438:     assert "reduceOnly" not in body
   439:     assert body["posMode"] == "hedge_mode"
   440: 
   441: 
   442: @pytest.mark.parametrize(
   443:     "code, side_str, pos_side",
   444:     [
   445:         (4, "sell", "long"),
   446:         (2, "buy", "short"),
   447:     ],
   448: )
   449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
   450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   451: 
   452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   453: 
   454:     called = {}
   455: 
   456:     def fake_private(self, method, path, params=None, body=None):
   457:         called["body"] = body
   458:         return {"success": True}
   459: 
   460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   461: 
   462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
   463: 
   464:     body = called["body"]
   465:     assert body["side"] == side_str
   466:     assert body["posSide"] == pos_side
   467:     assert "reduceOnly" not in body
   468: 
   469: 
   470: def test_place_order_precision(monkeypatch):
   471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   472: 
   473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
   474: 
   475:     called = {}
   476: 
   477:     def fake_private(self, method, path, params=None, body=None):
   478:         called["body"] = body
   479:         return {"success": True}
   480: 
   481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   482: 
   483:     client.place_order(
   484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
   485:     )
   486: 
   487:     assert called["body"]["price"] == 1234.57
   488:     assert called["body"]["size"] == 1.235
   489: 
   490: 
   491: def test_margin_cap_skips_order(monkeypatch):
   492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   493:     called = {}
   494: 
   495:     def fake_private(method, path, **kwargs):
   496:         called["path"] = path
   497:         return {"code": "00000"}
   498: 
   499:     monkeypatch.setattr(client, "_private_request", fake_private)
   500:     contract_detail = {
   501:         "data": {
   502:             "symbol": "BTCUSDT_UMCBL",
   503:             "contractSize": 1,
   504:             "volUnit": 1,
   505:             "minVol": 1,
   506:             "minTradeUSDT": 5,
   507:         }
   508:     }
   509:     price = 100.0
   510:     available = 0.5
   511:     vol = bot.compute_position_size(
   512:         contract_detail,
   513:         equity_usdt=available,
   514:         price=price,
   515:         risk_pct=1.0,
   516:         leverage=10,
   517:         symbol="BTCUSDT_UMCBL",
   518:         available_usdt=available,
   519:     )
   520:     if vol > 0:
   521:         client.place_order(
   522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
   523:         )
   524:     assert called == {}
   525: 
   526: 
   527: def test_margin_cap_reduces_volume(monkeypatch):
   528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   529:     called = {}
   530: 
   531:     def fake_private(method, path, **kwargs):
   532:         called["body"] = kwargs.get("body")
   533:         return {"code": "00000"}
   534: 
   535:     monkeypatch.setattr(client, "_private_request", fake_private)
   536:     contract_detail = {
   537:         "data": {
   538:             "symbol": "BTCUSDT_UMCBL",
   539:             "contractSize": 1,
   540:             "volUnit": 1,
   541:             "minVol": 1,
   542:             "minTradeUSDT": 5,
   543:         }
   544:     }
   545:     price = 10.0
   546:     vol_theoretical = bot.compute_position_size(
   547:         contract_detail,
   548:         equity_usdt=100,
   549:         price=price,
   550:         risk_pct=1.0,
   551:         leverage=10,
   552:         symbol="BTCUSDT_UMCBL",
   553:     )
   554:     available = 20.0
   555:     vol_final = bot.compute_position_size(
   556:         contract_detail,
   557:         equity_usdt=available,
   558:         price=price,
   559:         risk_pct=1.0,
   560:         leverage=10,
   561:         symbol="BTCUSDT_UMCBL",
   562:         available_usdt=available,
   563:     )
   564:     assert vol_final < vol_theoretical
   565:     client.place_order(
   566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
   567:     )
   568:     assert called["body"]["size"] == vol_final
   569: 
   570: def test_get_open_orders_paper_trade(monkeypatch):
   571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   572: 
   573:     called = {"count": 0}
   574: 
   575:     def fake_private(*a, **k):
   576:         called["count"] += 1
   577:         return {"success": True}
   578: 
   579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   580: 
   581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
   582: 
   583:     assert resp["success"] is True
   584:     assert resp["data"] == []
   585:     assert called["count"] == 0
   586: 
   587: 
   588: def test_cancel_all_paper_trade(monkeypatch):
   589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   590: 
   591:     called = {"count": 0}
   592: 
   593:     def fake_private(*a, **k):
   594:         called["count"] += 1
   595:         return {"success": True}
   596: 
   597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   598: 
   599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   600: 
   601:     assert resp["success"] is True
   602:     assert called["count"] == 0
   603: 
   604: 
   605: def test_get_kline_transforms_data(monkeypatch):
   606:     client = BitgetFuturesClient("key", "secret", "https://test")
   607: 
   608:     def fake_get(url, params=None, timeout=None):
   609:         class Resp:
   610:             def raise_for_status(self):
   611:                 pass
   612: 
   613:             def json(self):
   614:                 return {
   615:                     "data": [
   616:                         ["1", "2", "3", "1", "2", "10", "20"],
   617:                         ["2", "3", "4", "2", "3", "11", "21"],
   618:                     ]
   619:                 }
   620: 
   621:         return Resp()
   622: 
   623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   624: 
   625:     data = client.get_kline("BTC_USDT", interval="1m")
   626:     kdata = data["data"]
   627:     assert kdata["open"] == [2.0, 3.0]
   628:     assert kdata["high"] == [3.0, 4.0]
   629:     assert kdata["low"] == [1.0, 2.0]
   630:     assert kdata["close"] == [2.0, 3.0]
   631:     assert kdata["volume"] == [10.0, 11.0]
   632:     assert kdata["quoteVolume"] == [20.0, 21.0]


## tests/test_compute_position_size.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules["requests"] = types.ModuleType("requests")
     8: import bot  # noqa: E402
     9: from bot import compute_position_size  # noqa: E402
    10: 
    11: 
    12: def test_compute_position_size_basic():
    13:     contract_detail = {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.01,
    18:                 "volUnit": 1,
    19:                 "minVol": 1,
    20:             }
    21:         ]
    22:     }
    23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
    24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    25:     assert vol == 1
    26: 
    27: 
    28: def test_compute_position_size_symbol_not_found():
    29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
    30:     with pytest.raises(ValueError):
    31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
    32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    33: 
    34: 
    35: def test_compute_position_size_invalid_price():
    36:     contract_detail = {
    37:         "data": [
    38:             {
    39:                 "symbol": "BTC_USDT",
    40:                 "contractSize": 0.01,
    41:                 "volUnit": 1,
    42:                 "minVol": 1,
    43:             }
    44:         ]
    45:     }
    46:     vol = compute_position_size(
    47:         contract_detail,
    48:         equity_usdt=1000,
    49:         price=0,
    50:         risk_pct=0.01,
    51:         leverage=10,
    52:         symbol="BTC_USDT",
    53:     )
    54:     assert vol == 0
    55: 
    56: 
    57: def test_compute_position_size_respects_equity():
    58:     contract_detail = {
    59:         "data": [
    60:             {
    61:                 "symbol": "BTC_USDT",
    62:                 "contractSize": 1,
    63:                 "volUnit": 1,
    64:                 "minVol": 1,
    65:             }
    66:         ]
    67:     }
    68:     vol = compute_position_size(
    69:         contract_detail,
    70:         equity_usdt=5,
    71:         price=100,
    72:         risk_pct=0.01,
    73:         leverage=10,
    74:         symbol="BTC_USDT",
    75:     )
    76:     assert vol == 0
    77: 
    78: 
    79: def test_compute_position_size_leaves_fee_buffer():
    80:     contract_detail = {
    81:         "data": [
    82:             {
    83:                 "symbol": "BTC_USDT",
    84:                 "contractSize": 1,
    85:                 "volUnit": 1,
    86:                 "minVol": 1,
    87:             }
    88:         ]
    89:     }
    90:     vol = compute_position_size(
    91:         contract_detail,
    92:         equity_usdt=100,
    93:         price=100,
    94:         risk_pct=1.0,
    95:         leverage=1,
    96:         symbol="BTC_USDT",
    97:     )
    98:     assert vol == 0
    99: 
   100: 
   101: def test_compute_position_size_under_min_notional_returns_zero():
   102:     contract_detail = {
   103:         "data": [
   104:             {
   105:                 "symbol": "PI_USDT",
   106:                 "contractSize": 1,
   107:                 "volUnit": 1,
   108:                 "minVol": 1,
   109:                 "minTradeUSDT": 5,
   110:             }
   111:         ]
   112:     }
   113:     vol = compute_position_size(
   114:         contract_detail,
   115:         equity_usdt=100,
   116:         price=0.5,
   117:         risk_pct=0.0001,
   118:         leverage=20,
   119:         symbol="PI_USDT",
   120:     )
   121:     assert vol == 0
   122: 
   123: 
   124: def test_compute_position_size_cap_by_available():
   125:     contract_detail = {
   126:         "data": [
   127:             {
   128:                 "symbol": "BTC_USDT",
   129:                 "contractSize": 1,
   130:                 "volUnit": 2,
   131:                 "minVol": 2,
   132:                 "minTradeUSDT": 5,
   133:             }
   134:         ]
   135:     }
   136:     vol = compute_position_size(
   137:         contract_detail,
   138:         equity_usdt=100,
   139:         price=10,
   140:         risk_pct=0.5,
   141:         leverage=10,
   142:         symbol="BTC_USDT",
   143:         available_usdt=0.5,
   144:     )
   145:     assert vol == 0
   146:     vol = compute_position_size(
   147:         contract_detail,
   148:         equity_usdt=100,
   149:         price=10,
   150:         risk_pct=0.5,
   151:         leverage=10,
   152:         symbol="BTC_USDT",
   153:         available_usdt=10,
   154:     )
   155:     assert vol == 8
   156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
   157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
   158:     assert required <= 10


## tests/test_compute_position_size_cap.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules['requests'] = types.ModuleType('requests')
     8: 
     9: from bot import compute_position_size, CONFIG
    10: 
    11: 
    12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
    13:     return {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.001,
    18:                 "volUnit": vol_unit,
    19:                 "minVol": min_vol,
    20:                 "minTradeUSDT": min_trade,
    21:             }
    22:         ]
    23:     }
    24: 
    25: 
    26: def test_volume_zero_when_available_low():
    27:     detail = _detail()
    28:     vol = compute_position_size(
    29:         detail,
    30:         equity_usdt=1000,
    31:         price=10000,
    32:         risk_pct=0.01,
    33:         leverage=10,
    34:         symbol="BTC_USDT",
    35:         available_usdt=0.5,
    36:     )
    37:     assert vol == 0
    38: 
    39: 
    40: def test_margin_close_to_available():
    41:     detail = _detail()
    42:     CONFIG["FEE_RATE"] = 0.001
    43:     available = 1.05
    44:     vol = compute_position_size(
    45:         detail,
    46:         equity_usdt=1000,
    47:         price=10000,
    48:         risk_pct=1,
    49:         leverage=10,
    50:         symbol="BTC_USDT",
    51:         available_usdt=available,
    52:     )
    53:     assert vol == 1
    54:     notional = 10000 * 0.001 * vol
    55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
    56:     required = (notional / 10 + fee) * 1.03
    57:     assert required == pytest.approx(available, rel=0.05)
    58: 
    59: 
    60: def test_respects_units_and_minimums():
    61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
    62:     vol = compute_position_size(
    63:         detail,
    64:         equity_usdt=1000,
    65:         price=1000,
    66:         risk_pct=1,
    67:         leverage=5,
    68:         symbol="BTC_USDT",
    69:         available_usdt=1000,
    70:     )
    71:     assert vol % 2 == 0 and vol >= 2


## tests/test_dynamic_allocation.py (last modified: 2025-08-24 10:15:51)
     1: import math
     2: from scalper.risk import adjust_risk_pct
     3: 
     4: 
     5: def test_adjust_risk_pct_increase_decrease():
     6:     base = 0.01
     7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
     8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
     9: 
    10: 
    11: def test_adjust_risk_pct_bounds():
    12:     assert math.isclose(
    13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
    14:     )
    15:     assert math.isclose(
    16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
    17:     )


## tests/test_effective_leverage.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: from scalper.trade_utils import effective_leverage
     3: 
     4: 
     5: def test_effective_leverage_basic():
     6:     lev = effective_leverage(
     7:         entry_price=100.0,
     8:         liquidation_price=90.0,
     9:         position_margin=10.0,
    10:         position_size=1.0,
    11:     )
    12:     assert lev == pytest.approx(10.0)
    13: 
    14: 
    15: def test_effective_leverage_estimated_margin():
    16:     lev = effective_leverage(
    17:         entry_price=200.0,
    18:         liquidation_price=180.0,
    19:         position_margin=0.0,
    20:         position_size=2.0,
    21:     )
    22:     # price diff 20 * size 2 -> margin 40; notional 400
    23:     assert lev == pytest.approx(10.0)
    24: 
    25: 
    26: def test_effective_leverage_short_position():
    27:     lev = effective_leverage(
    28:         entry_price=100.0,
    29:         liquidation_price=110.0,
    30:         position_margin=10.0,
    31:         position_size=-1.5,
    32:     )
    33:     assert lev == pytest.approx(15.0)
    34: 
    35: 
    36: def test_effective_leverage_invalid():
    37:     assert effective_leverage(0, 0, 0, 0) == 0.0


## tests/test_env_loading.py (last modified: 2025-08-24 10:15:51)
     1: """Tests for loading environment variables from ``notebook/.env``."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import importlib
     6: import os
     7: import sys
     8: from pathlib import Path
     9: 
    10: 
    11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
    12:     """Module should load variables from ``notebook/.env`` if present."""
    13: 
    14:     notebook = tmp_path / "notebook"
    15:     spot = notebook / "spot"
    16:     spot.mkdir(parents=True)
    17:     bitget_bot = spot / "bitget_bot.py"
    18:     bitget_bot.write_text("")
    19:     env_file = notebook / ".env"
    20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
    21: 
    22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
    23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
    24:     import scalp
    25: 
    26:     importlib.reload(scalp)
    27: 
    28:     try:
    29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
    30:     finally:
    31:         env_file.unlink(missing_ok=True)
    32:         if old is None:
    33:             os.environ.pop("BITGET_ACCESS_KEY", None)
    34:         else:
    35:             os.environ["BITGET_ACCESS_KEY"] = old


## tests/test_grid_search.py (last modified: 2025-08-24 10:15:51)
     1: import json
     2: import random
     3: 
     4: import pytest
     5: 
     6: from scalper.backtest import grid_search
     7: 
     8: 
     9: def test_build_grid_sampling():
    10:     param_lists = {
    11:         "timeframe": ["1m", "5m", "15m"],
    12:         "score_min": [50, 55, 60],
    13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
    14:     }
    15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
    16:     assert len(combos) == 6
    17:     tfs = {c["timeframe"] for c in combos}
    18:     assert {"1m", "5m", "15m"}.issubset(tfs)
    19: 
    20: 
    21: def test_run_grid_search_with_mock(tmp_path):
    22:     calls = []
    23: 
    24:     def fake_run_backtest_multi(**kwargs):
    25:         tf = kwargs.get("timeframe")
    26:         risk = kwargs.get("risk_pct")
    27:         # fabricate metrics based on params
    28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
    29:         pf += risk  # tiny variation
    30:         metrics = {
    31:             "symbol": "TOTAL",
    32:             "pnl_usdt": 100 * risk,
    33:             "profit_factor": pf,
    34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
    35:             "winrate_pct": 50.0,
    36:             "trades": 40 if tf == "1m" else 30,
    37:         }
    38:         calls.append((tf, risk))
    39:         return [metrics], []
    40: 
    41:     param_lists = {
    42:         "timeframe": ["1m", "5m"],
    43:         "risk_pct": [0.005, 0.01],
    44:     }
    45:     base_params = {
    46:         "timeframe": "1m",
    47:         "risk_pct": 0.005,
    48:     }
    49:     out_dir = tmp_path / "grid"
    50:     grid_search.run_grid_search(
    51:         symbols=["BTC/USDT"],
    52:         exchange="csv",
    53:         base_params=base_params,
    54:         param_lists=param_lists,
    55:         grid_max=4,
    56:         csv_dir="/dev/null",
    57:         out_dir=str(out_dir),
    58:         run_func=fake_run_backtest_multi,
    59:     )
    60:     best = json.loads((out_dir / "best_config.json").read_text())
    61:     # best PF should be timeframe 5m risk 0.01
    62:     assert best["params"]["timeframe"] == "5m"
    63:     assert best["params"]["risk_pct"] == 0.01
    64:     assert len(calls) == 4
    65: 
    66: 
    67: def test_parse_hours():
    68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
    69: 
    70: 
    71: def test_deterministic_results(tmp_path):
    72:     def fake_run_backtest_multi(**kwargs):
    73:         # metrics vary with global random state
    74:         pf = random.uniform(1.0, 3.0)
    75:         metrics = {
    76:             "symbol": "TOTAL",
    77:             "pnl_usdt": random.uniform(-10, 10),
    78:             "profit_factor": pf,
    79:             "max_drawdown_pct": random.uniform(1, 5),
    80:             "winrate_pct": 50.0,
    81:             "trades": random.randint(10, 50),
    82:         }
    83:         return [metrics], []
    84: 
    85:     param_lists = {"timeframe": ["1m", "5m"]}
    86:     base_params = {"timeframe": "1m"}
    87:     out_dir = tmp_path / "grid"
    88:     res1 = grid_search.run_grid_search(
    89:         symbols=["BTC/USDT"],
    90:         exchange="csv",
    91:         base_params=base_params,
    92:         param_lists=param_lists,
    93:         grid_max=2,
    94:         csv_dir="/dev/null",
    95:         out_dir=str(out_dir),
    96:         seed=42,
    97:         run_func=fake_run_backtest_multi,
    98:     )
    99:     best1 = json.loads((out_dir / "best_config.json").read_text())
   100:     # run again
   101:     out_dir2 = tmp_path / "grid2"
   102:     res2 = grid_search.run_grid_search(
   103:         symbols=["BTC/USDT"],
   104:         exchange="csv",
   105:         base_params=base_params,
   106:         param_lists=param_lists,
   107:         grid_max=2,
   108:         csv_dir="/dev/null",
   109:         out_dir=str(out_dir2),
   110:         seed=42,
   111:         run_func=fake_run_backtest_multi,
   112:     )
   113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
   114:     assert best1 == best2
   115:     # also ensure results object same best params
   116:     assert res1[0].params == res2[0].params


## tests/test_heat_score.py (last modified: 2025-08-24 10:15:51)
     1: from scalper.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
     2: 
     3: 
     4: def test_heat_score_value():
     5:     assert heat_score(2.0, 100.0) == 200.0
     6:     assert heat_score(2.0, 100.0, news=True) == 400.0
     7: 
     8: 
     9: def test_select_and_decorrelate_pairs():
    10:     pairs = [
    11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
    12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
    13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
    14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
    15:     ]
    16:     top = select_top_heat_pairs(pairs, top_n=3)
    17:     assert len(top) == 3
    18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
    19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
    20:     syms = {p["symbol"] for p in selected}
    21:     assert not ("A" in syms and "B" in syms)


## tests/test_indicators.py (last modified: 2025-08-24 10:15:51)
     1: 
     2: 
     3: import os
     4: import sys
     5: import pytest
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: 
     8: 
     9: 
    10: 
    11: from scalper.metrics import calc_rsi, calc_atr, calc_macd
    12: 
    13: 
    14: def test_calc_rsi_uptrend():
    15:     prices = list(range(1, 16))  # strictly increasing
    16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
    17: 
    18: 
    19: def test_calc_rsi_downtrend():
    20:     prices = list(range(15, 0, -1))  # strictly decreasing
    21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
    22: 
    23: 
    24: 
    25: def test_calc_rsi_flat():
    26:     prices = [1.0] * 15  # no movement
    27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
    28: 
    29: 
    30: 
    31:     highs = [10, 11, 12, 13, 14]
    32:     lows = [9, 10, 11, 12, 13]
    33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
    34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
    35: 
    36: 
    37: def test_calc_macd_trend():
    38:     prices = list(range(1, 60))
    39:     macd, signal, hist = calc_macd(prices)
    40:     assert macd > signal
    41:     assert hist > 0
    42: 
    43: 
    44: def test_calc_macd_flat():
    45:     prices = [100.0] * 60
    46:     macd, signal, hist = calc_macd(prices)
    47:     assert macd == pytest.approx(0.0)
    48:     assert signal == pytest.approx(0.0)
    49:     assert hist == pytest.approx(0.0)
    50: 
    51: 
    52: 
    53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
    54: def test_calc_rsi_invalid_inputs(prices, period):
    55:     with pytest.raises(ValueError):
    56:         calc_rsi(prices, period=period)
    57: 
    58: 
    59: @pytest.mark.parametrize(
    60:     "highs, lows, closes, period",
    61:     [
    62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
    63:         ([1, 2], [1, 1], [1, 1], 3),
    64:     ],
    65: )
    66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
    67:     with pytest.raises(ValueError):
    68:         calc_atr(highs, lows, closes, period=period)
    69: 


## tests/test_min_qty_rules.py (last modified: 2025-08-24 10:15:51)
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import _apply_contract_checks
     9: 
    10: 
    11: def _detail():
    12:     return {
    13:         "data": [
    14:             {
    15:                 "symbol": "BTC_USDT",
    16:                 "contractSize": 1,
    17:                 "volUnit": 5,
    18:                 "minVol": 10,
    19:                 "minTradeUSDT": 5,
    20:             }
    21:         ]
    22:     }
    23: 
    24: 
    25: def test_min_qty_floor_and_validation():
    26:     detail = _detail()
    27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
    28:     assert vol == 10
    29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
    30:     assert vol2 == 0


## tests/test_notifier.py (last modified: 2025-08-24 10:15:51)
     1: import scalper.notifier as notifier
     2: 
     3: 
     4: def test_notify_skips_without_targets(monkeypatch):
     5:     called = False
     6: 
     7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
     8:         nonlocal called
     9:         called = True
    10: 
    11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    15:     notifier.notify("test", {"foo": 1})
    16:     assert called is False
    17: 
    18: 
    19: def test_notify_posts_http(monkeypatch):
    20:     payload = {}
    21: 
    22:     def fake_post(url, json=None, timeout=5):
    23:         payload["url"] = url
    24:         payload["json"] = json
    25:         payload["timeout"] = timeout
    26: 
    27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    31:     notifier.notify("evt", {"bar": 2})
    32:     assert payload["url"] == "http://example.com"
    33:     assert payload["json"]["event"] == "evt"
    34:     assert payload["json"]["bar"] == 2
    35: 
    36: 
    37: def test_notify_posts_telegram(monkeypatch):
    38:     payload = {}
    39: 
    40:     def fake_post(url, json=None, timeout=5):
    41:         payload["url"] = url
    42:         payload["json"] = json
    43:         payload["timeout"] = timeout
    44: 
    45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    49: 
    50:     notifier.notify("evt", {"bar": 2})
    51: 
    52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
    53:     assert payload["json"]["chat_id"] == "123"
    54:     assert "evt" in payload["json"]["text"]
    55: 
    56: 
    57: def test_notify_posts_both(monkeypatch):
    58:     calls = []
    59: 
    60:     def fake_post(url, json=None, timeout=5):
    61:         calls.append({"url": url, "json": json, "timeout": timeout})
    62: 
    63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    67: 
    68:     notifier.notify("evt", {"bar": 2})
    69: 
    70:     assert len(calls) == 2
    71:     urls = {c["url"] for c in calls}
    72:     assert "http://example.com" in urls
    73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
    74: 
    75: 
    76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
    77:     calls = []
    78: 
    79:     def fake_post(url, json=None, timeout=5):
    80:         calls.append(url)
    81: 
    82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    86: 
    87:     notifier.notify("pair_list", {"pairs": "BTC"})
    88: 
    89:     # Only the generic webhook should be called, not Telegram
    90:     assert calls == ["http://example.com"]
    91: 
    92: 
    93: def test_format_text_open_position():
    94:     payload = {
    95:         "symbol": "BTCUSDT",
    96:         "side": "short",
    97:         "price": 18350,
    98:         "vol": 37,
    99:         "contract_size": 1,
   100:         "notional_usdt": 120.5,
   101:         "leverage": 5,
   102:         "required_margin_usdt": 25.3,
   103:         "available_usdt": 134,
   104:         "risk_level_user": 3,
   105:         "signal_level": 2,
   106:         "risk_color": "🟡",
   107:         "risk_pct_eff": 0.01,
   108:         "fee_rate": 0.001,
   109:     }
   110:     text = notifier._format_text("position_opened", payload)
   111:     lines = text.splitlines()
   112: 
   113:     assert lines[0] == "🟡 Ouvre short BTC"
   114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
   115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
   116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
   117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
   118: 
   119: 
   120: def test_format_text_closed_position():
   121:     payload = {
   122:         "symbol": "BTCUSDT",
   123:         "side": "short",
   124:         "entry_price": 18350,
   125:         "exit_price": 18328,
   126:         "vol": 37,
   127:         "contract_size": 1,
   128:         "notional_entry_usdt": 120.5,
   129:         "notional_exit_usdt": 120.3,
   130:         "fees_usdt": 0.03,
   131:         "pnl_usdt": 0.84,
   132:         "pnl_pct_on_margin": 3.25,
   133:         "leverage": 5,
   134:         "risk_color": "🟡",
   135:         "fee_rate": 0.001,
   136:     }
   137:     text = notifier._format_text("position_closed", payload)
   138:     lines = text.splitlines()
   139:     assert lines[0] == "Ferme short BTC 🟡"
   140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
   141:     assert lines[2] == "% sur marge: 3.25%"
   142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
   143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
   144: 
   145: 
   146: def test_format_text_pair_list_and_start():
   147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
   148:     text = notifier._format_text(
   149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
   150:     )
   151:     assert text == "Listing ok"
   152: 
   153: 
   154: def test_format_pair_list_helper():
   155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
   156:     text = notifier._format_pair_list(payload)
   157:     assert text == "Listing ok"
   158: 
   159: 
   160: def test_format_position_event_helper():
   161:     payload = {
   162:         "symbol": "BTCUSDT",
   163:         "side": "short",
   164:         "price": 18350,
   165:         "vol": 37,
   166:         "contract_size": 1,
   167:         "notional_usdt": 120.5,
   168:         "leverage": 5,
   169:         "required_margin_usdt": 25.3,
   170:         "available_usdt": 134,
   171:         "risk_level_user": 3,
   172:         "signal_level": 2,
   173:         "risk_color": "🟡",
   174:         "risk_pct_eff": 0.01,
   175:         "fee_rate": 0.001,
   176:     }
   177:     text = notifier._format_position_event("position_opened", payload)
   178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
   179: 
   180: 


## tests/test_notional_and_pnl_units.py (last modified: 2025-08-24 10:15:51)
     1: import os, sys, types, pytest
     2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     3: sys.modules['requests'] = types.ModuleType('requests')
     4: 
     5: from scalper.trade_utils import (
     6:     get_contract_size,
     7:     notional as calc_notional,
     8:     required_margin as calc_required_margin,
     9:     compute_pnl_usdt,
    10:     compute_pnl_with_fees,
    11: )
    12: 
    13: 
    14: def _detail():
    15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
    16: 
    17: 
    18: def test_notional_and_pnl_units():
    19:     detail = _detail()
    20:     cs = get_contract_size(detail, "BTC_USDT")
    21:     N = calc_notional(10000, 2, cs)
    22:     assert N == pytest.approx(10000 * 0.001 * 2)
    23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
    24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
    25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
    26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
    27:     pnl_net, pct = compute_pnl_with_fees(
    28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
    29:     )
    30:     gross = (10100 - 10000) * cs * 2
    31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
    32:     expected = gross - fees
    33:     expected_pct = expected / (N / 10) * 100
    34:     assert pnl_net == pytest.approx(expected)
    35:     assert pct == pytest.approx(expected_pct)


## tests/test_pair_selection.py (last modified: 2025-08-24 10:15:51)
     1: import bot
     2: 
     3: 
     4: def test_get_trade_pairs():
     5:     class Client:
     6:         def get_ticker(self, symbol=None):
     7:             return {
     8:                 "success": True,
     9:                 "data": [
    10:                     {"symbol": "BTC_USDT"},
    11:                     {"symbol": "ETH_USDT"},
    12:                 ],
    13:             }
    14: 
    15:     pairs = bot.get_trade_pairs(Client())
    16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
    17: 
    18: 
    19: def test_select_top_pairs():
    20:     class Client:
    21:         def get_ticker(self, symbol=None):
    22:             return {
    23:                 "success": True,
    24:                 "data": [
    25:                     {"symbol": "A", "volume": "1"},
    26:                     {"symbol": "B", "volume": "3"},
    27:                     {"symbol": "C", "volume": "2"},
    28:                 ],
    29:             }
    30: 
    31:     top = bot.select_top_pairs(Client(), top_n=2)
    32:     assert [p["symbol"] for p in top] == ["B", "C"]
    33: 
    34: 
    35: def test_select_top_pairs_default_count():
    36:     class Client:
    37:         def get_ticker(self, symbol=None):
    38:             data = []
    39:             for i in range(100):
    40:                 data.append({"symbol": str(i), "volume": str(i)})
    41:             return {"success": True, "data": data}
    42: 
    43:     top = bot.select_top_pairs(Client())
    44:     assert len(top) == 40
    45: 
    46: 
    47: def test_filter_trade_pairs():
    48:     class Client:
    49:         def get_ticker(self, symbol=None):
    50:             return {
    51:                 "success": True,
    52:                 "data": [
    53:                     {
    54:                         "symbol": "AAA",
    55:                         "volume": "6000000",
    56:                         "bidPrice": "100",
    57:                         "askPrice": "100.03",
    58:                     },  # spread ~3 bps
    59:                     {
    60:                         "symbol": "BBB",
    61:                         "volume": "10000000",
    62:                         "bidPrice": "50",
    63:                         "askPrice": "50.1",
    64:                     },  # spread ~200 bps
    65:                     {
    66:                         "symbol": "CCC",
    67:                         "volume": "7000000",
    68:                         "bidPrice": "10",
    69:                         "askPrice": "10.01",
    70:                     },  # spread ~100 bps
    71:                     {
    72:                         "symbol": "DDD",
    73:                         "volume": "4000000",
    74:                         "bidPrice": "20",
    75:                         "askPrice": "20.01",
    76:                     },  # volume trop faible
    77:                 ],
    78:             }
    79: 
    80:     pairs = bot.filter_trade_pairs(
    81:         Client(),
    82:         volume_min=5_000_000,
    83:         max_spread_bps=5,
    84:     )
    85:     assert [p["symbol"] for p in pairs] == ["AAA"]
    86: 
    87: 
    88: def test_find_trade_positions(monkeypatch):
    89:     class Client:
    90:         def __init__(self):
    91:             self.data = {
    92:                 "AAA": {"data": {"close": [1, 2, 3]}},
    93:                 "BBB": {"data": {"close": [3, 2, 1]}},
    94:             }
    95: 
    96:         def get_kline(self, symbol, interval="1m"):
    97:             return self.data[symbol]
    98: 
    99:     pairs = [
   100:         {"symbol": "AAA", "lastPrice": "1"},
   101:         {"symbol": "BBB", "lastPrice": "1"},
   102:     ]
   103: 
   104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
   105: 
   106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
   107:         if last_fast > prev_fast:
   108:             return 1
   109:         if last_fast < prev_fast:
   110:             return -1
   111:         return 0
   112: 
   113:     monkeypatch.setattr(bot, "cross", fake_cross)
   114: 
   115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
   116:     assert signals == [
   117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
   118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
   119:     ]


## tests/test_pairs.py (last modified: 2025-08-24 10:15:51)
     1: import bot
     2: 
     3: 
     4: def test_send_selected_pairs(monkeypatch):
     5:     sent = {}
     6: 
     7:     def fake_notify(event, payload=None):
     8:         sent["event"] = event
     9:         sent["payload"] = payload
    10: 
    11:     monkeypatch.setattr(bot, "notify", fake_notify)
    12:     monkeypatch.setattr(
    13:         bot,
    14:         "filter_trade_pairs",
    15:         lambda client, top_n=120: [
    16:             {"symbol": "WIFUSDT", "volume": 10},
    17:             {"symbol": "WIFUSDT", "volume": 9},
    18:             {"symbol": "BTCUSD", "volume": 8},
    19:             {"symbol": "BTCUSDT", "volume": 7},
    20:             {"symbol": "DOGEUSDT", "volume": 6},
    21:             {"symbol": "ETHUSDC", "volume": 5},
    22:             {"symbol": "ETHUSDT", "volume": 4},
    23:         ],
    24:     )
    25: 
    26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
    27: 
    28:     payload = bot.send_selected_pairs(object(), top_n=4)
    29: 
    30:     assert sent["event"] == "pair_list"
    31:     assert sent["payload"]["green"] == "BTC"
    32:     assert sent["payload"]["orange"] == "ETH"
    33:     assert "red" not in sent["payload"]
    34:     assert payload == sent["payload"]
    35: 
    36: 
    37: def test_send_selected_pairs_no_whitelist(monkeypatch):
    38:     sent = {}
    39: 
    40:     def fake_notify(event, payload=None):
    41:         sent["payload"] = payload
    42: 
    43:     monkeypatch.setattr(bot, "notify", fake_notify)
    44:     monkeypatch.setattr(
    45:         bot,
    46:         "filter_trade_pairs",
    47:         lambda client, top_n=120: [
    48:             {"symbol": "AAAUSDT", "volume": 10},
    49:             {"symbol": "BBBUSD", "volume": 9},
    50:             {"symbol": "CCCUSDC", "volume": 8},
    51:             {"symbol": "DDDUSDT", "volume": 7},
    52:         ],
    53:     )
    54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
    55: 
    56:     payload = bot.send_selected_pairs(object(), top_n=4)
    57: 
    58:     assert payload == sent["payload"]
    59:     assert payload["green"] == "AAA"
    60:     assert payload["orange"] == "BBB"
    61:     assert payload["red"] == "CCC, DDD"
    62: 
    63: 
    64: def test_filter_trade_pairs_all_pairs(monkeypatch):
    65:     class DummyClient:
    66:         def get_ticker(self):
    67:             return {
    68:                 "data": [
    69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
    70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
    71:                 ]
    72:             }
    73: 
    74:     client = DummyClient()
    75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
    76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
    77: 


## tests/test_risk_manager.py (last modified: 2025-08-24 10:15:51)
     1: from scalp import RiskManager
     2: 
     3: 
     4: def test_kill_switch_triggered() -> None:
     5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
     6:     rm.record_trade(-1.0)
     7:     rm.record_trade(-1.5)
     8:     assert rm.kill_switch is True
     9: 
    10: 
    11: def test_profit_kill_switch_triggered() -> None:
    12:     rm = RiskManager(
    13:         max_daily_loss_pct=10.0,
    14:         max_daily_profit_pct=3.0,
    15:         max_positions=1,
    16:         risk_pct=0.01,
    17:     )
    18:     rm.record_trade(1.5)
    19:     rm.record_trade(1.6)
    20:     assert rm.kill_switch is True
    21: 
    22: 
    23: def test_pause_and_can_open() -> None:
    24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    25:     rm.record_trade(-0.5)
    26:     rm.record_trade(-0.6)
    27:     rm.record_trade(-0.7)
    28:     assert rm.pause_duration() == 15 * 60
    29:     rm.record_trade(-0.8)
    30:     rm.record_trade(-0.9)
    31:     assert rm.pause_duration() == 60 * 60
    32:     assert rm.can_open(0) is True
    33:     assert rm.can_open(1) is False
    34: 
    35: 
    36: def test_risk_pct_scaling() -> None:
    37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    38:     rm.record_trade(1.0)
    39:     rm.record_trade(1.0)
    40:     assert rm.risk_pct > 0.01
    41:     rm.record_trade(-1.0)
    42:     rm.record_trade(-1.0)
    43:     assert rm.risk_pct < 0.01


## tests/test_risk_utils.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: 
     3: from scalper.risk import calc_risk_amount, calc_position_size
     4: 
     5: 
     6: def test_calc_risk_amount_basic():
     7:     assert calc_risk_amount(1000, 0.01) == 10.0
     8: 
     9: 
    10: def test_calc_position_size_basic():
    11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
    12:     assert calc_position_size(1000, 0.01, 50) == 0.2
    13: 
    14: 
    15: @pytest.mark.parametrize("equity,risk_pct", [
    16:     (0, 0.01),
    17:     (-100, 0.01),
    18:     (1000, 0),
    19:     (1000, -0.1),
    20:     (1000, 1.5),
    21: ])
    22: def test_calc_risk_amount_invalid(equity, risk_pct):
    23:     with pytest.raises(ValueError):
    24:         calc_risk_amount(equity, risk_pct)
    25: 
    26: 
    27: @pytest.mark.parametrize("stop_distance", [0, -1])
    28: def test_calc_position_size_invalid_stop(stop_distance):
    29:     with pytest.raises(ValueError):
    30:         calc_position_size(1000, 0.01, stop_distance)


## tests/test_signal_risk.py (last modified: 2025-08-24 10:15:51)
     1: import types
     2: import os
     3: import sys
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import (
     9:     map_score_to_sig_level,
    10:     compute_risk_params,
    11:     prepare_order,
    12:     Signal,
    13:     CONFIG,
    14: )
    15: 
    16: 
    17: class DummyRisk:
    18:     def __init__(self, pct: float) -> None:
    19:         self.risk_pct = pct
    20: 
    21: 
    22: def _contract_detail():
    23:     return {
    24:         "data": [
    25:             {
    26:                 "symbol": "BTC_USDT",
    27:                 "contractSize": 0.001,
    28:                 "volUnit": 1,
    29:                 "minVol": 1,
    30:                 "minTradeUSDT": 5,
    31:             }
    32:         ]
    33:     }
    34: 
    35: 
    36: def test_score_to_level_mapping():
    37:     assert map_score_to_sig_level(10) == 1
    38:     assert map_score_to_sig_level(35) == 2
    39:     assert map_score_to_sig_level(69.9) == 2
    40:     assert map_score_to_sig_level(70) == 3
    41: 
    42: 
    43: def test_risk_tables():
    44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
    45:     assert rp == 0.01 * 1.25
    46:     assert lev == int(20 * 0.75)
    47:     assert cap == 0.55
    48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
    49:     assert rp2 == 0.01 * 1.0
    50:     assert lev2 == int(20 * 0.5)
    51:     assert cap2 == 0.35
    52: 
    53: 
    54: def test_notional_cap():
    55:     rm = DummyRisk(0.05)
    56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    57:     available = 1000
    58:     params = prepare_order(
    59:         sig,
    60:         _contract_detail(),
    61:         equity_usdt=available,
    62:         available_usdt=available,
    63:         base_leverage=10,
    64:         risk_mgr=rm,
    65:         user_risk_level=2,
    66:     )
    67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6


## tests/test_slippage.py (last modified: 2025-08-24 10:15:51)
     1: from scalper.trade_utils import marketable_limit_price
     2: 
     3: 
     4: def test_marketable_limit_price_buy_sell():
     5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
     6:     assert price_buy == 10.0 * 1.001
     7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
     8:     assert price_sell == 9.9 * (1 - 0.001)


## tests/test_strategy_v2.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: 
     3: from scalp import strategy
     4: from scalper.trade_utils import trailing_stop, should_scale_in, timeout_exit
     5: 
     6: 
     7: def make_ohlcv(n=60, start=100, step=1):
     8:     closes = [start + i * step for i in range(n)]
     9:     highs = [c + 1 for c in closes]
    10:     lows = [c - 1 for c in closes]
    11:     vols = [1 for _ in closes]
    12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
    13: 
    14: 
    15: def test_generate_signal_atr_adaptation(monkeypatch):
    16:     base = make_ohlcv(step=2)
    17:     ohlcv_15 = make_ohlcv(n=15, step=2)
    18:     ohlcv_1h = make_ohlcv(step=2)
    19: 
    20:     # patches for deterministic RSI values
    21:     rsi_vals = iter([60, 41, 39])
    22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    24:     # low ATR -> signal disabled
    25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
    26:     sig = strategy.generate_signal(
    27:         "AAA",
    28:         base,
    29:         equity=1_000,
    30:         risk_pct=0.01,
    31:         ohlcv_15m=ohlcv_15,
    32:         ohlcv_1h=ohlcv_1h,
    33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    34:         tick_ratio_buy=0.6,
    35:     )
    36:     assert sig is None
    37: 
    38:     # high ATR -> size reduced
    39:     rsi_vals = iter([60, 41, 39])
    40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
    42:     sig = strategy.generate_signal(
    43:         "AAA",
    44:         base,
    45:         equity=1_000,
    46:         risk_pct=0.01,
    47:         ohlcv_15m=ohlcv_15,
    48:         ohlcv_1h=ohlcv_1h,
    49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    50:         tick_ratio_buy=0.6,
    51:     )
    52:     assert sig and sig.side == "long"
    53:     assert sig.qty == 50
    54: 
    55: 
    56: def test_generate_signal_short_with_filters(monkeypatch):
    57:     base = make_ohlcv(start=200, step=-2)
    58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
    59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
    60: 
    61:     rsi_vals = iter([40, 59, 61])
    62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
    65: 
    66:     sig = strategy.generate_signal(
    67:         "AAA",
    68:         base,
    69:         equity=1_000,
    70:         risk_pct=0.01,
    71:         ohlcv_15m=ohlcv_15,
    72:         ohlcv_1h=ohlcv_1h,
    73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
    74:         tick_ratio_buy=0.4,
    75:     )
    76:     assert sig and sig.side == "short"
    77:     assert sig.qty == 100
    78: 
    79: 
    80: def test_trailing_and_timeout():
    81:     # trailing stop
    82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
    83:     assert sl == pytest.approx(102.5)
    84:     # scaling
    85:     assert should_scale_in(100, 105, 100, 10, "long") is True
    86:     assert should_scale_in(100, 95, 100, 10, "short") is True
    87:     # timeout
    88:     # before the progress window no exit should be triggered
    89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    90:     # after ``progress_min`` minutes without favourable movement we close
    91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    92: 
    93: 
    94: def test_generate_signal_macd_filter(monkeypatch):
    95:     base = make_ohlcv(step=2)
    96:     ohlcv_15 = make_ohlcv(n=15, step=2)
    97:     ohlcv_1h = make_ohlcv(step=2)
    98: 
    99:     rsi_vals = iter([60, 41, 39])
   100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
   104: 
   105:     sig = strategy.generate_signal(
   106:         "AAA",
   107:         base,
   108:         equity=1_000,
   109:         risk_pct=0.01,
   110:         ohlcv_15m=ohlcv_15,
   111:         ohlcv_1h=ohlcv_1h,
   112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   113:         tick_ratio_buy=0.6,
   114:     )
   115:     assert sig is None
   116: 
   117: 
   118: 
   119: def test_generate_signal_trend_ema_filter(monkeypatch):
   120:     base = make_ohlcv(step=2)
   121:     ohlcv_15 = make_ohlcv(n=15, step=2)
   122:     ohlcv_1h = make_ohlcv(step=2)
   123: 
   124:     rsi_vals = iter([60, 41, 39])
   125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   128: 
   129:     orig_ema = strategy.ema
   130: 
   131:     def fake_ema(series, window):
   132:         if window == 200:
   133:             return [x + 1000 for x in orig_ema(series, window)]
   134:         return orig_ema(series, window)
   135: 
   136:     monkeypatch.setattr(strategy, "ema", fake_ema)
   137: 
   138:     sig = strategy.generate_signal(
   139:         "AAA",
   140:         base,
   141:         equity=1_000,
   142:         risk_pct=0.01,
   143:         ohlcv_15m=ohlcv_15,
   144:         ohlcv_1h=ohlcv_1h,
   145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   146:         tick_ratio_buy=0.6,
   147:         trend_ema_period=200,
   148:     )
   149:     assert sig is None
   150:     

## tests/test_telegram_bot.py (last modified: 2025-08-24 10:15:51)
     1: from scalper.telegram_bot import TelegramBot
     2: 
     3: 
     4: class DummyClient:
     5: 
     6:     def __init__(self):
     7:         self.closed = []
     8:         self.closed_all = False
     9: 
    10: 
    11:     def get_assets(self):
    12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
    13: 
    14:     def get_positions(self):
    15:         return {
    16:             "data": [
    17:                 {
    18:                     "symbol": "BTC_USDT",
    19:                     "side": "long",
    20:                     "vol": 2,
    21:                     "pnl_usd": 1.0,
    22:                     "pnl_pct": 5.0,
    23:                 }
    24:             ]
    25:         }
    26: 
    27:     def close_position(self, sym):
    28:         self.closed.append(sym)
    29: 
    30:     def close_all_positions(self):
    31:         self.closed_all = True
    32: 
    33: 
    34: 
    35: class DummyRiskMgr:
    36: 
    37:     def __init__(self):
    38:         self.reset_called = False
    39:         self.max_positions = 1
    40:         self.risk_pct = 0.01
    41: 
    42:     def reset_day(self):
    43:         self.reset_called = True
    44: 
    45: 
    46: class DummyRequests:
    47:     def __init__(self):
    48:         self.posts = []
    49: 
    50:     def post(self, url, json=None, timeout=5):
    51:         self.posts.append((url, json))
    52: 
    53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
    54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
    55: 
    56: 
    57: def make_bot(config=None, requests_module=None):
    58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
    59:     if config:
    60:         cfg.update(config)
    61:     if requests_module is None:
    62:         requests_module = DummyRequests()
    63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
    64: 
    65: 
    66: def test_handle_balance():
    67:     bot = make_bot()
    68: 
    69:     resp, kb = bot.handle_callback("balance", 0.0)
    70:     assert "123.45" in resp
    71:     assert kb == bot.main_keyboard
    72: 
    73: 
    74: 
    75: def test_handle_positions():
    76:     bot = make_bot()
    77:     resp, _ = bot.handle_callback("positions", 0.0)
    78:     assert "BTC" in resp
    79:     assert "PnL" in resp
    80: 
    81: 
    82: def test_handle_positions_zero_pnl():
    83:     bot = make_bot()
    84: 
    85:     def zero_positions():
    86:         return {
    87:             "data": [
    88:                 {
    89:                     "symbol": "BTC_USDT",
    90:                     "side": "long",
    91:                     "vol": 1,
    92:                     "pnl_usd": 0.0,
    93:                     "pnl_pct": 0.0,
    94:                 }
    95:             ]
    96:         }
    97: 
    98:     bot.client.get_positions = zero_positions
    99:     resp, _ = bot.handle_callback("positions", 0.0)
   100:     assert "PnL: 0.00 USDT" in resp
   101: 
   102: 
   103: 
   104: def test_handle_pnl():
   105:     bot = make_bot()
   106:     resp, _ = bot.handle_callback("pnl", 5.0)
   107: 
   108:     assert "5.00" in resp
   109: 
   110: 
   111: def test_handle_risk_change():
   112:     bot = make_bot()
   113: 
   114:     resp, kb = bot.handle_callback("risk_red", 0.0)
   115:     assert "3" in resp
   116:     assert bot.config["RISK_LEVEL"] == 3
   117:     assert kb == bot.main_keyboard
   118: 
   119: 
   120: def test_risk_menu():
   121:     bot = make_bot()
   122:     resp, kb = bot.handle_callback("risk", 0.0)
   123:     assert "risque" in resp.lower()
   124:     assert kb == bot.risk_keyboard
   125: 
   126: 
   127: 
   128: def test_stop_menu_and_actions():
   129:     bot = make_bot()
   130:     resp, kb = bot.handle_callback("stop", 0.0)
   131:     assert any(
   132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
   133:     )
   134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
   135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
   136:     assert "fermée" in resp.lower()
   137:     assert bot.client.closed == ["BTC_USDT"]
   138:     resp, _ = bot.handle_callback("stop_all", 0.0)
   139:     assert bot.client.closed_all is True
   140: 
   141: 
   142: def test_handle_unknown():
   143:     bot = make_bot()
   144:     resp, kb = bot.handle_callback("foobar", 0.0)
   145:     assert resp is None
   146:     assert kb is None
   147: 
   148: 
   149: def test_reset_all():
   150:     bot = make_bot()
   151:     resp, kb = bot.handle_callback("reset_all", 0.0)
   152:     assert "réinitialisés" in resp.lower()
   153:     assert bot.risk_mgr.reset_called is True
   154:     assert bot.client.closed_all is True
   155:     assert kb == bot.settings_keyboard
   156: 
   157: 
   158: def test_shutdown_bot():
   159:     bot = make_bot()
   160:     resp, kb = bot.handle_callback("shutdown", 0.0)
   161:     assert "arrêt" in resp.lower()
   162:     assert bot.stop_requested is True
   163:     assert kb == bot.main_keyboard
   164: 
   165: 
   166: def test_start_sends_menu():
   167:     req = DummyRequests()
   168:     make_bot(requests_module=req)
   169:     assert req.posts
   170:     text = req.posts[0][1]["text"]
   171:     assert "Solde" in text and "PnL session" in text
   172:     assert "Positions max" in text
   173:     assert "Risque actuel" in text
   174: 
   175: 
   176: def test_settings_menu_and_reset_risk():
   177:     bot = make_bot()
   178:     resp, kb = bot.handle_callback("settings", 0.0)
   179:     assert "réglages" in resp.lower()
   180:     assert kb == bot.settings_keyboard
   181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
   182:     assert "risque" in resp.lower()
   183:     assert bot.risk_mgr.reset_called is True
   184:     assert kb == bot.settings_keyboard
   185: 
   186: 
   187: def test_update_button(monkeypatch):
   188:     bot = make_bot()
   189:     called = {}
   190: 
   191:     def fake_update():
   192:         called["called"] = True
   193: 
   194:     bot.update_pairs = fake_update
   195:     resp, kb = bot.handle_callback("update", 0.0)
   196:     assert called["called"] is True
   197:     assert "mise à jour" in resp.lower()
   198:     assert kb == bot.main_keyboard
   199: 
   200: 
   201: def test_maxpos_menu_and_change():
   202:     bot = make_bot()
   203:     resp, kb = bot.handle_callback("maxpos", 0.0)
   204:     assert "nombre" in resp.lower()
   205:     assert kb == bot.maxpos_keyboard
   206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
   207:     assert "3" in resp
   208:     assert bot.config["MAX_POSITIONS"] == 3
   209:     assert bot.risk_mgr.max_positions == 3
   210:     assert kb == bot.main_keyboard
   211: 
   212: 
   213: def test_stop_no_positions():
   214:     bot = make_bot()
   215:     bot.client.get_positions = lambda: {"data": []}
   216:     resp, kb = bot.handle_callback("stop", 0.0)
   217:     assert "aucune crypto" in resp.lower()
   218:     assert kb == bot.settings_keyboard
   219: 


## tests/test_utils.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: from bot import ema, cross, compute_position_size, CONFIG
     3: from scalper.trade_utils import extract_available_balance
     4: 
     5: 
     6: def test_ema_basic():
     7:     data = [1, 2, 3, 4, 5]
     8:     result = ema(data, 3)
     9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
    10: 
    11: 
    12: def test_cross_up_down_none():
    13:     assert cross(3, 2, 1, 2) == 1  # up cross
    14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
    15:     assert cross(2, 2, 2, 2) == 0  # no cross
    16: 
    17: 
    18: def test_compute_position_size():
    19:     detail = {
    20:         "data": [
    21:             {
    22:                 "symbol": CONFIG["SYMBOL"],
    23:                 "contractSize": 0.001,
    24:                 "volUnit": 1,
    25:                 "minVol": 1,
    26:             }
    27:         ]
    28:     }
    29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
    30:                                 risk_pct=0.01, leverage=5)
    31:     assert vol == 1
    32: 
    33: 
    34: def test_compute_position_size_missing_symbol():
    35:     with pytest.raises(ValueError):
    36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
    37: 
    38: 
    39: def test_extract_available_balance_fallback():
    40:     assets = {
    41:         "data": [
    42:             {
    43:                 "currency": "USDT",
    44:                 "available": 0,
    45:                 "cashBalance": "150.5",
    46:                 "equity": "200",
    47:             }
    48:         ]
    49:     }
    50:     assert extract_available_balance(assets) == 150.5
    51: 
    52: 
    53: def test_extract_available_balance_equity_only():
    54:     assets = {
    55:         "data": [
    56:             {
    57:                 "currency": "USDT",
    58:                 "equity": "42",
    59:             }
    60:         ]
    61:     }
    62:     assert extract_available_balance(assets) == 42.0
    63: 
    64: 
    65: def test_extract_available_balance_zero_available_returns_zero():
    66:     assets = {
    67:         "data": [
    68:             {
    69:                 "currency": "USDT",
    70:                 "available": 0,
    71:                 "availableBalance": 0,
    72:                 "equity": "42",
    73:             }
    74:         ]
    75:     }
    76:     assert extract_available_balance(assets) == 0.0


## tests/test_version.py (last modified: 2025-08-24 10:15:51)
     1: import pytest
     2: from scalp import version
     3: 
     4: 
     5: def test_get_version(monkeypatch, tmp_path):
     6:     vfile = tmp_path / "VERSION"
     7:     vfile.write_text("1.2.3")
     8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
     9:     assert version.get_version() == "1.2.3"
    10: 
    11: 
    12: def test_bump_version(monkeypatch, tmp_path):
    13:     vfile = tmp_path / "VERSION"
    14: 
    15:     vfile.write_text("0.1.2\n")
    16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    17:     assert version.bump_version("minor") == "0.2.0"
    18:     assert vfile.read_text().strip() == "0.2.0"
    19: 
    20: 
    21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
    22:     vfile = tmp_path / "VERSION"
    23:     vfile.write_text("0.1.0\n")
    24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    25:     with pytest.raises(ValueError):
    26:         version.bump_version("foo")
    27: 
    28: 
    29: def test_bump_from_message(monkeypatch, tmp_path):
    30:     vfile = tmp_path / "VERSION"
    31:     vfile.write_text("1.0.0\n")
    32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
    34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
    35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
    36: 


## tests/test_walk_forward.py (last modified: 2025-08-24 10:15:51)
     1: from scalper.backtest import walk_forward_windows
     2: 
     3: 
     4: def test_walk_forward_windows():
     5:     data = list(range(10))
     6:     windows = list(walk_forward_windows(data, train=4, test=2))
     7:     assert windows == [
     8:         ([0, 1, 2, 3], [4, 5]),
     9:         ([2, 3, 4, 5], [6, 7]),
    10:         ([4, 5, 6, 7], [8, 9]),
    11:     ]


## tests/test_ws.py (last modified: 2025-08-24 10:15:51)
     1: import asyncio
     2: 
     3: from scalper.ws import WebsocketManager
     4: 
     5: 
     6: def test_websocket_manager_stop():
     7:     async def connect():
     8:         return None
     9: 
    10:     async def subscribe():
    11:         return None
    12: 
    13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
    14: 
    15:     async def run_and_stop():
    16:         await ws.run()
    17:         assert ws._heartbeat_task is not None
    18:         await ws.stop()
    19:         assert ws._heartbeat_task is None
    20: 
    21:     asyncio.run(run_and_stop())


## tg_diag.py (last modified: 2025-08-24 10:15:51)
     1: # tg_diag.py
     2: import asyncio, os, aiohttp
     3: 
     4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
     5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
     6: 
     7: async def main():
     8:     if not TOKEN or not CHAT:
     9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
    10:         return
    11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
    13:     try:
    14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
    15:             async with s.post(url, json=payload) as r:
    16:                 body = await r.text()
    17:                 print("HTTP:", r.status)
    18:                 print("Body:", body[:500])
    19:     except Exception as e:
    20:         print("❌ Exception:", repr(e))
    21: 
    22: if __name__ == "__main__":
    23:     asyncio.run(main())

