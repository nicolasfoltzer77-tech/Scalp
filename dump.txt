Dump created: 2025-08-23 09:50:02
Repository tree:
Scalp/
    CHANGELOG.md
    Makefile
    PROMPT.md
    README.md
    STRATEGY.md
    bitget_futures_pairs.py
    bot.py
    cli.py
    dashboard.py
    dump_repo.py
    init.py
    pytest.ini
    quick_order.py
    requirements-dev.txt
    requirements.txt
    run_backtest.py
    short_one_way.py
    scalp/
        VERSION
        __init__.py
        bitget_client.py
        bot_config.py
        client.py
        config.py
        logging_utils.py
        metrics.py
        notifier.py
        pairs.py
        strategy.py
        telegram_bot.py
        trade_utils.py
        version.py
        ws.py
        risk/
            __init__.py
            manager.py
        selection/
            __init__.py
            momentum.py
            scanner.py
        backtest/
            __init__.py
            walkforward.py
        services/
            __init__.py
            order_service.py
            utils.py
        adapters/
            __init__.py
            bitget.py
            market_data.py
        positions/
            __init__.py
            state.py
    tests/
        conftest.py
        test_analyse_risque.py
        test_backtest.py
        test_backtest_multi.py
        test_backtest_position.py
        test_bitget_futures_pairs.py
        test_bot_place_order_caps.py
        test_bot_update.py
        test_break_even_stop.py
        test_calc_pnl_pct.py
        test_check_config.py
        test_cli.py
        test_client.py
        test_compute_position_size.py
        test_compute_position_size_cap.py
        test_dynamic_allocation.py
        test_effective_leverage.py
        test_env_loading.py
        test_grid_search.py
        test_heat_score.py
        test_indicators.py
        test_min_qty_rules.py
        test_notifier.py
        test_notional_and_pnl_units.py
        test_pair_selection.py
        test_pairs.py
        test_risk_manager.py
        test_risk_utils.py
        test_signal_risk.py
        test_slippage.py
        test_strategy_v2.py
        test_telegram_bot.py
        test_utils.py
        test_version.py
        test_walk_forward.py
        test_ws.py
    result/
    data/
        BTCUSDT-1m.csv
        __init__.py
        indicators.py
    live/
        __init__.py
        commands.py
        journal.py
        logs.py
        notify.py
        ohlcv_service.py
        orchestrator.py
        orders.py
        position_fsm.py
        setup_wizard.py
        state_store.py
        telegram_async.py
        watchlist.py
        loops/
            trade.py
    backtest/
        __init__.py
        cli.py
        engine.py
        grid_search.py
        metrics.py
        optimize.py
        run_multi.py
        runner.py
    notebooks/
        spot/
            bitget_bot.py
    config/
        __init__.py
        loader.py
    signals/
        __init__.py
        factory.py
        generator.py
    exchange/
        fees.py

## CHANGELOG.md (last modified: 2025-08-23 09:47:18)
     1: # Changelog
     2: 
     3: ## Unreleased
     4: 
     5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
     6:   signal levels.
     7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
     8:   user risk level.
     9: - Notional and margin caps with available balance check to avoid Bitget error
    10:   `40762`.
    11: - Risk notifications with green/yellow/red indicators for terminal and
    12:   Telegram.


## Makefile (last modified: 2025-08-23 09:47:18)
     1: .PHONY: test
     2: 
     3: test:
     4: 	pytest


## PROMPT.md (last modified: 2025-08-23 09:47:18)
     1: # Prompt de re-création du bot Scalp (version spot)
     2: 
     3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
     4: 
     5: ## Structure principale
     6: 
     7: ### bot.py
     8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
     9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
    10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
    11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
    12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
    13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
    14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
    15: 
    16: ### cli.py
    17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
    18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
    19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
    20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
    21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
    22: 
    23: ### init.py
    24: - `install_packages(*args)` : installe des paquets via `pip`.
    25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
    26: 
    27: ## Modules `scalp`
    28: 
    29: ### bot_config.py
    30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
    31: 
    32: ### metrics.py
    33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
    34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
    35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
    36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
    37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
    38: 
    39: ### strategy.py
    40: - `ema(series, window)` : moyenne mobile exponentielle.
    41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
    42: - `obv(closes, volumes)` : série On Balance Volume.
    43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
    44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
    45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
    46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
    47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
    48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
    49: 
    50: ### trade_utils.py
    51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
    52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
    53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
    54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
    55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
    56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
    57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
    58: 
    59: ### risk
    60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
    61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
    62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
    63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
    64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
    65: 
    66: ### notifier.py
    67: - `_pair_name(symbol)` : formatte le nom d’une paire.
    68: - `_format_text(event, payload=None)` : construit un message lisible.
    69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
    70: 
    71: ### logging_utils.py
    72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
    73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
    74: 
    75: ### bitget_client.py
    76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
    77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
    78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
    79:   - `get_account()`, `get_open_orders(symbol=None)`.
    80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
    81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
    82: 
    83: ### pairs.py
    84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
    85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
    86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
    87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
    88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
    89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
    90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
    91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
    92: 
    93: ### telegram_bot.py
    94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
    95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
    96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
    97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
    98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
    99: 
   100: ## Utilisation
   101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   102: 2. Exécuter `init.py` pour installer les dépendances.
   103: 3. Lancer `bot.py` pour démarrer le trading.
   104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   105: 
   106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   107: 


## README.md (last modified: 2025-08-23 09:47:18)
     1: # Scalp
     2: 
     3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
     4: 
     5: ## Installation
     6: 
     7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
     8: 
     9: ```bash
    10: pip install -r requirements.txt
    11: ```
    12: 
    13: Pour développer ou exécuter les tests :
    14: 
    15: ```bash
    16: pip install -r requirements-dev.txt
    17: pytest  # ou make test
    18: ```
    19: 
    20: ## Configuration
    21: 
    22: Le bot lit sa configuration via des variables d'environnement :
    23: 
    24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
    25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
    26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
    27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
    28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
    29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
    30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
    31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
    32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
    33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
    34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
    35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
    36: 
    37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
    38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
    39: 
    40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
    41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
    42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
    43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
    44: bot.
    45: 
    46: 
    47: Exemple :
    48: 
    49: ```bash
    50: export BITGET_ACCESS_KEY="votre_cle"
    51: export BITGET_SECRET_KEY="votre_secret"
    52: export PAPER_TRADE=true
    53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
    54: export TELEGRAM_CHAT_ID="123456789"
    55: python bot.py
    56: ```
    57: 
    58: ## Lancement
    59: 
    60: Après configuration, lancez simplement :
    61: 
    62: ```bash
    63: python bot.py
    64: ```
    65: 
    66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
    67: 
    68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
    69: 
    70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
    71: 
    72: 
    73: ## Stratégie
    74: 
    75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
    76: rapidement les pertes.
    77: 
    78: Principes généraux :
    79: 
    80: - sélection de paires liquides au fort momentum ;
    81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
    82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
    83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
    84:   calculée selon le risque ;
    85: - limites quotidiennes pour protéger le capital.
    86: 
    87: Les règles détaillées et l’algorithme complet sont décrits dans
    88: `STRATEGY.md`.
    89: 
    90: ## Version
    91: 
    92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
    93: le code via la variable `scalp.__version__` :
    94: 
    95: ```python
    96: from scalp import __version__
    97: print(__version__)
    98: ```
    99: 
   100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   101: 
   102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   103: `scalp.version.bump_version_from_message` permet également de déterminer
   104: automatiquement l'incrément à appliquer à partir d'un message de commit
   105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   106: 
   107: Exemple d'incrément basé sur un message :
   108: 
   109: ```python
   110: from scalp.version import bump_version_from_message
   111: bump_version_from_message("feat: add new strategy")
   112: ```
   113: 
   114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   115: message de commit `git` et met à jour le fichier `VERSION` en
   116: conséquence.
   117: 
   118: La même opération peut être déclenchée depuis la ligne de commande via
   119: `cli.py` :
   120: 
   121: ```bash
   122: python cli.py bump-version
   123: ```
   124: 
   125: 
   126: ## Changelog
   127: 
   128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   129: 
   130: ## Avertissement
   131: 
   132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.


## STRATEGY.md (last modified: 2025-08-23 09:47:18)
     1: # Stratégie de trading
     2: 
     3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
     4: 
     5: ## Principes généraux
     6: 
     7: - ne traiter que des actifs liquides à fort momentum ;
     8: - suivre la tendance dominante et éviter les marchés plats ;
     9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
    10: - dimensionner chaque position selon un pourcentage fixe du capital ;
    11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
    12: 
    13: ## Sélection des paires
    14: 
    15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
    16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
    17:    - croisement entre EMA20 et EMA50 ;
    18:    - ATR élevé pour privilégier les actifs volatils.
    19: 
    20: ## Génération du signal
    21: 
    22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
    23: 
    24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
    25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
    26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
    27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
    28: - cassure du dernier **swing high/low** ;
    29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
    30: 
    31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
    32: 
    33: ## Gestion du risque
    34: 
    35: La classe `RiskManager` applique plusieurs garde‑fous :
    36: 
    37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
    38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
    39: - pause forcée en cas de pertes consécutives prolongées ;
    40: - contrôle du nombre maximal de positions ouvertes.
    41: 
    42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.


## backtest/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Backtesting helpers and optimisation utilities."""
     2: 
     3: from .optimize import (
     4:     param_space_default,
     5:     eval_params_one,
     6:     run_param_sweep,
     7:     optimize,
     8: )
     9: 
    10: __all__ = [
    11:     "param_space_default",
    12:     "eval_params_one",
    13:     "run_param_sweep",
    14:     "optimize",
    15: ]


## backtest/cli.py (last modified: 2025-08-23 09:47:18)
     1: import argparse, asyncio, os, datetime as dt
     2: from .runner import BacktestRunner
     3: 
     4: def parse_ts(s: str) -> int:
     5:     d = dt.datetime.strptime(s, "%Y-%m-%d").replace(tzinfo=dt.timezone.utc)
     6:     return int(d.timestamp()*1000)
     7: 
     8: # Exemple de loader sync à remplacer par ton vrai fetch
     9: def fetch_ohlcv_sync(symbol: str, timeframe: str, start_ms: int, end_ms: int):
    10:     raise NotImplementedError("Brancher fetch_ohlcv_sync(...) sur tes données historiques")
    11: 
    12: def main():
    13:     ap = argparse.ArgumentParser()
    14:     ap.add_argument("--strategy", required=True)
    15:     ap.add_argument("--symbols", required=True)
    16:     ap.add_argument("--timeframes", required=True)
    17:     ap.add_argument("--start", required=True)
    18:     ap.add_argument("--end", required=True)
    19:     ap.add_argument("--out", default="out_backtest")
    20:     ap.add_argument("--cash", type=float, default=10000.0)
    21:     ap.add_argument("--risk", type=float, default=0.5)
    22:     ap.add_argument("--conc", type=int, default=4)
    23:     args = ap.parse_args()
    24: 
    25:     symbols = [s.strip() for s in args.symbols.split(",")]
    26:     tfs = [s.strip() for s in args.timeframes.split(",")]
    27:     start_ms, end_ms = parse_ts(args.start), parse_ts(args.end)
    28: 
    29:     runner = BacktestRunner(fetch_ohlcv_sync, args.out, args.strategy, cfg={}, cash=args.cash, risk_pct=args.risk, max_conc=args.conc)
    30:     res = asyncio.run(runner.run_all(symbols, tfs, start_ms, end_ms))
    31:     print("== Résumé ==")
    32:     for sym, best in res["proposal"]["per_symbol_best"].items():
    33:         print(f"{sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
    34: 
    35: if __name__ == "__main__":
    36:     main()

## backtest/engine.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/backtest/engine.py
     2: from __future__ import annotations
     3: import csv, os
     4: from typing import Dict, Any, List
     5: from .metrics import Trade, summarize
     6: from ..risk.manager import compute_size
     7: 
     8: class BacktestEngine:
     9:     def __init__(self, loader, strategy_fn, cfg: Dict[str, Any], out_dir: str, cash: float, risk_pct: float=0.5):
    10:         self.loader = loader
    11:         self.strategy_fn = strategy_fn
    12:         self.cfg = dict(cfg)
    13:         self.out_dir = out_dir
    14:         self.cash0 = float(cash)
    15:         self.risk_pct = float(risk_pct)
    16:         self.caps_by_symbol = self.cfg.get("caps", {})
    17:         self.fees_by_symbol = self.cfg.get("fees_by_symbol", {})  # << ici
    18:         self.slippage_bps = float(self.cfg.get("slippage_bps", 0.0))
    19: 
    20:     def _taker_bps(self, symbol: str) -> float:
    21:         f = self.fees_by_symbol.get(symbol, {})
    22:         return float(f.get("taker_bps", 0.0))
    23: 
    24:     def run_pair(self, symbol: str, timeframe: str, start: int, end: int, lookback: int=200) -> Dict[str, Any]:
    25:         ohlcv = self.loader(symbol, timeframe, start, end)
    26:         if len(ohlcv) <= lookback + 1:
    27:             return {"symbol": symbol, "timeframe": timeframe, "error": "not_enough_data"}
    28: 
    29:         equity = [self.cash0]
    30:         bar_returns = []
    31:         trades: List[Trade] = []
    32:         pos_side = "flat"; pos_qty = 0.0; pos_entry = 0.0
    33:         last_open_ts = None
    34: 
    35:         os.makedirs(self.out_dir, exist_ok=True)
    36:         eq_path = os.path.join(self.out_dir, f"equity_curve_{symbol}_{timeframe}.csv")
    37:         tr_path = os.path.join(self.out_dir, f"trades_{symbol}_{timeframe}.csv")
    38:         with open(eq_path, "w", newline="") as eqf, open(tr_path, "w", newline="") as trf:
    39:             eqw = csv.writer(eqf); trw = csv.writer(trf)
    40:             eqw.writerow(["ts","equity"])
    41:             trw.writerow(["ts","side","entry","exit","pnl_abs","pnl_pct","dur_min"])
    42: 
    43:             for i in range(lookback, len(ohlcv)-1):
    44:                 window = ohlcv[i-lookback:i+1]
    45:                 ts, o, h, l, c, v = window[-1]
    46:                 sig = self.strategy_fn(window, self.cfg) or {}
    47:                 side = sig.get("side","flat")
    48: 
    49:                 # sortie
    50:                 if pos_side != "flat" and (side == "flat" or (side != pos_side and side in ("long","short"))):
    51:                     exit_price = float(c)
    52:                     exit_price *= (1 + (self.slippage_bps/10000.0)) if pos_side=="short" else (1 - (self.slippage_bps/10000.0))
    53:                     pnl_abs = (exit_price - pos_entry) * pos_qty if pos_side=="long" else (pos_entry - exit_price) * pos_qty
    54:                     # frais taker sur 2 jambes (entrée+sortie) — approximation réaliste pour market orders
    55:                     taker_bps = self._taker_bps(symbol)
    56:                     fees = (abs(pos_entry) + abs(exit_price)) * pos_qty * (taker_bps/10000.0)
    57:                     pnl_abs -= fees
    58:                     pnl_pct = pnl_abs / max(equity[-1],1e-9)
    59:                     equity.append(equity[-1] + pnl_abs)
    60:                     bar_returns.append(pnl_abs / max(equity[-2],1e-9))
    61:                     dur_min = ((ts - last_open_ts)/60000) if last_open_ts else 0.0
    62:                     trw.writerow([ts, pos_side, pos_entry, exit_price, pnl_abs, pnl_pct, dur_min])
    63:                     trades.append(Trade(ts, pos_side, pos_entry, exit_price, pnl_abs, pnl_pct, dur_min))
    64:                     pos_side, pos_qty, pos_entry, last_open_ts = "flat", 0.0, 0.0, None
    65: 
    66:                 # entrée
    67:                 if pos_side == "flat" and side in ("long","short"):
    68:                     price = float(sig.get("entry", c) or c)
    69:                     qty = compute_size(
    70:                         symbol=symbol, price=price, balance_cash=equity[-1],
    71:                         risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
    72:                     )
    73:                     if qty > 0:
    74:                         pos_side, pos_qty, pos_entry = side, qty, price
    75:                         last_open_ts = ts
    76: 
    77:                 eqw.writerow([ts, equity[-1]])
    78: 
    79:         start_ts = ohlcv[lookback][0]; end_ts = ohlcv[-1][0]
    80:         m = summarize(trades, equity, bar_returns, start_ts, end_ts)
    81:         m.update({"symbol": symbol, "timeframe": timeframe})
    82:         return m

## backtest/grid_search.py (last modified: 2025-08-23 09:47:18)
     1: """Grid-search express module to evaluate hyperparameter combinations.
     2: 
     3: This module builds combinations of strategy and engine parameters, runs the
     4: existing multi symbol backtester for each combination, collects key metrics and
     5: selects the best configuration according to:
     6: 
     7: 1. Profit factor (descending)
     8: 2. Maximum drawdown percentage (ascending)
     9: 3. Net PnL in USDT (descending)
    10: 4. Number of trades (ascending)
    11: 
    12: Results are written under ``result/grid`` by default and a short summary is
    13: printed to the console.
    14: """
    15: from __future__ import annotations
    16: 
    17: from dataclasses import dataclass
    18: import csv
    19: import json
    20: import os
    21: import random
    22: from itertools import product
    23: from typing import Any, Callable, Dict, Iterable, List, Sequence
    24: 
    25: # ---------------------------------------------------------------------------
    26: # Utilities
    27: # ---------------------------------------------------------------------------
    28: 
    29: 
    30: def parse_hours(hours: str) -> List[int]:
    31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
    32: 
    33:     Each comma separated element can either be a single hour (``"8"``) or a
    34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
    35:     """
    36: 
    37:     if not hours:
    38:         return []
    39:     result: List[int] = []
    40:     for part in hours.split(","):
    41:         part = part.strip()
    42:         if not part:
    43:             continue
    44:         if "-" in part:
    45:             start_s, end_s = part.split("-", 1)
    46:             start, end = int(start_s), int(end_s)
    47:             result.extend(range(start, end + 1))
    48:         else:
    49:             result.append(int(part))
    50:     return sorted(set(result))
    51: 
    52: 
    53: # Order of parameters used throughout the module and in CSV output
    54: PARAM_KEYS = [
    55:     "timeframe",
    56:     "score_min",
    57:     "atr_min_ratio",
    58:     "rr_min",
    59:     "risk_pct",
    60:     "slippage_bps",
    61:     "fee_rate",
    62:     "cooldown_secs",
    63:     "hours",
    64: ]
    65: 
    66: # Default values used if a parameter is not provided in the grid
    67: DEFAULTS = {
    68:     "score_min": 55,
    69:     "atr_min_ratio": 0.002,
    70:     "rr_min": 1.2,
    71:     "risk_pct": 0.01,
    72:     "slippage_bps": 2,
    73:     "fee_rate": 0.001,
    74:     "cooldown_secs": 300,
    75:     "hours": "7-11,13-17",
    76: }
    77: 
    78: 
    79: @dataclass
    80: class GridResult:
    81:     params: Dict[str, Any]
    82:     metrics: Dict[str, float]
    83: 
    84: 
    85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
    86:     if isinstance(val, (list, tuple, set)):
    87:         return list(val)
    88:     return [val]
    89: 
    90: 
    91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
    92:     """Return a list of parameter combinations.
    93: 
    94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
    95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
    96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
    97:     variety of timeframes and ``atr_min_ratio`` values.
    98:     """
    99: 
   100:     lists: Dict[str, List[Any]] = {}
   101:     for key in PARAM_KEYS:
   102:         if key == "timeframe":
   103:             # timeframe must be explicitly provided; default empty -> "1m"
   104:             vals = param_lists.get(key) or ["1m"]
   105:         else:
   106:             vals = param_lists.get(key)
   107:             if not vals:
   108:                 default = DEFAULTS[key]
   109:                 vals = [default]
   110:         lists[key] = _ensure_list(vals)
   111: 
   112:     combos: List[Dict[str, Any]] = [
   113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
   114:     ]
   115: 
   116:     # Uniform sampling if exceeding grid_max
   117:     if len(combos) > grid_max:
   118:         step = len(combos) / float(grid_max)
   119:         sampled = []
   120:         for i in range(grid_max):
   121:             idx = int(round(i * step))
   122:             if idx >= len(combos):
   123:                 idx = len(combos) - 1
   124:             sampled.append(combos[idx])
   125:         # ensure each timeframe appears at least once
   126:         wanted_tfs = set(lists["timeframe"])
   127:         present_tfs = {c["timeframe"] for c in sampled}
   128:         missing = list(wanted_tfs - present_tfs)
   129:         if missing:
   130:             for tf in missing:
   131:                 for c in combos:
   132:                     if c["timeframe"] == tf and c not in sampled:
   133:                         sampled.append(c)
   134:                         break
   135:             sampled = sampled[:grid_max]
   136:         combos = sampled
   137:     return combos
   138: 
   139: 
   140: # ---------------------------------------------------------------------------
   141: # Core runner
   142: # ---------------------------------------------------------------------------
   143: 
   144: 
   145: def run_grid_search(
   146:     *,
   147:     symbols: Sequence[str],
   148:     exchange: str,
   149:     base_params: Dict[str, Any],
   150:     param_lists: Dict[str, Sequence[Any]],
   151:     grid_max: int = 12,
   152:     csv_dir: str | None = None,
   153:     initial_equity: float = 1000.0,
   154:     leverage: float = 1.0,
   155:     paper_constraints: bool = True,
   156:     seed: int | None = None,
   157:     out_dir: str = "./result/grid",
   158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
   159:     run_func: Callable[..., Any] | None = None,
   160: ) -> List[GridResult]:
   161:     """Execute grid search across parameter combinations.
   162: 
   163:     ``base_params`` provides default single values for parameters. ``param_lists``
   164:     contains the grid specifications from CLI (already parsed into sequences).
   165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
   166:     """
   167: 
   168:     if seed is not None:
   169:         random.seed(seed)
   170: 
   171:     if run_func is None:  # avoid circular import at module load
   172:         from .run_multi import run_backtest_multi  # late import
   173: 
   174:         run_func = run_backtest_multi
   175: 
   176:     # merge lists with defaults
   177:     full_lists: Dict[str, Sequence[Any]] = {}
   178:     for k in PARAM_KEYS:
   179:         if k == "timeframe":
   180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
   181:         else:
   182:             if param_lists.get(k) is not None:
   183:                 full_lists[k] = param_lists[k]
   184:             else:
   185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
   186: 
   187:     combos = build_param_grid(full_lists, grid_max)
   188: 
   189:     results: List[GridResult] = []
   190:     os.makedirs(out_dir, exist_ok=True)
   191: 
   192:     for combo in combos:
   193:         # Build parameters for backtester
   194:         tf = combo["timeframe"]
   195:         fee = float(combo["fee_rate"])
   196:         slip = float(combo["slippage_bps"])
   197:         risk = float(combo["risk_pct"])
   198: 
   199:         summary, _trades = run_func(
   200:             symbols=list(symbols),
   201:             exchange=exchange,
   202:             timeframe=tf,
   203:             csv_dir=csv_dir,
   204:             fee_rate=fee,
   205:             slippage_bps=slip,
   206:             risk_pct=risk,
   207:             initial_equity=initial_equity,
   208:             leverage=leverage,
   209:             paper_constraints=paper_constraints,
   210:             seed=seed,
   211:             out_dir=os.path.join(out_dir, "tmp"),
   212:             plot=False,
   213:             dry_run=True,
   214:         )
   215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
   216:         metrics = {
   217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
   218:             "profit_factor": float(total.get("profit_factor", 0.0)),
   219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
   220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
   221:             "trades": float(total.get("trades", 0.0)),
   222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
   223:         }
   224:         results.append(GridResult(params=combo, metrics=metrics))
   225: 
   226:     # sort results
   227:     results.sort(
   228:         key=lambda r: (
   229:             -r.metrics["profit_factor"],
   230:             r.metrics["max_dd_pct"],
   231:             -r.metrics["pnl_usdt"],
   232:             r.metrics["trades"],
   233:         )
   234:     )
   235: 
   236:     # console output -------------------------------------------------------
   237:     print(
   238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
   239:     )
   240:     header = (
   241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
   242:     )
   243:     print(header)
   244:     for r in results[:10]:
   245:         m = r.metrics
   246:         print(
   247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
   248:         )
   249: 
   250:     # write csv ------------------------------------------------------------
   251:     csv_cols = PARAM_KEYS + [
   252:         "pnl_usdt",
   253:         "profit_factor",
   254:         "max_dd_pct",
   255:         "winrate_pct",
   256:         "trades",
   257:         "final_equity",
   258:     ]
   259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
   260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
   261:         writer.writeheader()
   262:         for r in results:
   263:             row = {**r.params, **r.metrics}
   264:             writer.writerow(row)
   265: 
   266:     best = results[0]
   267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
   268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
   269: 
   270:     # markdown summary -----------------------------------------------------
   271:     md_path = os.path.join(out_dir, "grid_summary.md")
   272:     with open(md_path, "w", encoding="utf8") as fh:
   273:         fh.write(
   274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
   275:         )
   276:         for r in results[:10]:
   277:             m = r.metrics
   278:             fh.write(
   279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
   280:             )
   281: 
   282:     # optional scatter plot ------------------------------------------------
   283:     try:  # pragma: no cover - optional dependency
   284:         import matplotlib.pyplot as plt
   285: 
   286:         pf = [r.metrics["profit_factor"] for r in results]
   287:         dd = [r.metrics["max_dd_pct"] for r in results]
   288:         trades = [r.metrics["trades"] for r in results]
   289:         tfs = [r.params["timeframe"] for r in results]
   290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
   291:         c = [colors[tf] for tf in tfs]
   292:         plt.figure(figsize=(6, 4))
   293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
   294:         plt.xlabel("MaxDD%")
   295:         plt.ylabel("Profit Factor")
   296:         plt.title("PF vs MaxDD")
   297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
   298:         plt.close()
   299:     except Exception:  # pragma: no cover
   300:         pass
   301: 
   302:     return results
   303: 
   304: 
   305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]


## backtest/metrics.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: import math
     3: from dataclasses import dataclass
     4: from typing import List, Dict
     5: 
     6: @dataclass
     7: class Trade:
     8:     ts: int
     9:     side: str
    10:     entry: float
    11:     exit: float
    12:     pnl_abs: float
    13:     pnl_pct: float
    14:     dur_min: float
    15: 
    16: def equity_to_drawdown(equity: List[float]) -> float:
    17:     peak = -1e18; maxdd = 0.0
    18:     for v in equity:
    19:         if v > peak: peak = v
    20:         dd = 0.0 if peak == 0 else (peak - v) / peak
    21:         if dd > maxdd: maxdd = dd
    22:     return maxdd
    23: 
    24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
    25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
    26:     if not returns: return 0.0
    27:     mean = sum(returns)/len(returns)
    28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
    29:     std = math.sqrt(var) if var>0 else 0.0
    30:     if std == 0: return 0.0
    31:     return (mean - rf) / std * math.sqrt(period_per_year)
    32: 
    33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
    34:     wins = [t for t in trades if t.pnl_abs > 0]
    35:     losses = [t for t in trades if t.pnl_abs < 0]
    36:     wr = len(wins)/len(trades) if trades else 0.0
    37:     gross_win = sum(t.pnl_abs for t in wins)
    38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
    39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
    40:     mdd = equity_to_drawdown(equity)
    41:     shp = sharpe(bar_returns)
    42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
    43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
    44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
    45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
    46:     return {
    47:         "trades": len(trades),
    48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
    49:         "expectancy": expectancy, "cagr": cagr, "score": score,
    50:         "equity_start": equity[0] if equity else None,
    51:         "equity_end": equity[-1] if equity else None,
    52:     }

## backtest/optimize.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: 
     3: """Parameter sweep utilities for strategy optimisation.
     4: 
     5: This module performs a grid search over a parameter space in parallel.  It
     6: tries to use :mod:`ray` for distributed execution when available and falls
     7: back to :mod:`multiprocessing` otherwise.
     8: """
     9: 
    10: import itertools
    11: import json
    12: import multiprocessing as mp
    13: import os
    14: from typing import Any, Dict, Iterable, List, Sequence
    15: 
    16: try:  # Optional dependency
    17:     import ray  # type: ignore
    18: except Exception:  # pragma: no cover - ray is optional
    19:     ray = None
    20: 
    21: from scalp.backtest import backtest_trades
    22: 
    23: 
    24: # ---------------------------------------------------------------------------
    25: # Parameter space
    26: # ---------------------------------------------------------------------------
    27: 
    28: def param_space_default() -> Dict[str, Sequence[Any]]:
    29:     """Return the default parameter search space.
    30: 
    31:     The keys correspond to strategy parameters while the values are iterables
    32:     of possible settings.  The defaults represent a small but representative
    33:     grid and can be overridden by callers.
    34:     """
    35: 
    36:     return {
    37:         "ema_fast": [10, 20, 30],
    38:         "ema_slow": [50, 100, 200],
    39:         "rsi_period": [14, 21],
    40:         "atr_period": [14, 21],
    41:     }
    42: 
    43: 
    44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    45:     """Expand *space* into a list of parameter combinations."""
    46: 
    47:     keys = list(space)
    48:     values = [space[k] for k in keys]
    49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
    50: 
    51: 
    52: # ---------------------------------------------------------------------------
    53: # Evaluation
    54: # ---------------------------------------------------------------------------
    55: 
    56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    57:     """Run a backtest for a single parameter combination.
    58: 
    59:     ``grid_item`` contains the parameter values along with optional ``trades``
    60:     to evaluate.  The function returns a copy of the parameters augmented with
    61:     the computed PnL under the key ``pnl``.
    62:     """
    63: 
    64:     params = dict(grid_item)
    65:     trades = params.pop("trades", [])
    66:     fee_rate = params.pop("fee_rate", None)
    67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
    68:     params["pnl"] = pnl
    69:     return params
    70: 
    71: 
    72: # ---------------------------------------------------------------------------
    73: # Orchestration
    74: # ---------------------------------------------------------------------------
    75: 
    76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    77:     """Evaluate the full parameter grid in parallel and return results."""
    78: 
    79:     space = space or param_space_default()
    80:     grid = _param_grid(space)
    81: 
    82:     # Determine execution backend
    83:     use_ray = False
    84:     if ray is not None:
    85:         try:  # pragma: no cover - depends on ray
    86:             ray.init(ignore_reinit_error=True)
    87:             use_ray = True
    88:         except Exception:
    89:             use_ray = False
    90: 
    91:     if use_ray:
    92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
    93:         futures = [remote_eval.remote(g) for g in grid]
    94:         results = ray.get(futures)
    95:     else:
    96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
    97:         with mp.Pool(processes=jobs) as pool:
    98:             results = pool.map(eval_params_one, grid)
    99: 
   100:     return results
   101: 
   102: 
   103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
   104:     """High level helper executing the sweep and saving aggregated results."""
   105: 
   106:     results = run_param_sweep(space, jobs=jobs)
   107:     with open(outfile, "w", encoding="utf8") as fh:
   108:         json.dump(results, fh, indent=2, sort_keys=True)
   109:     return results
   110: 
   111: 
   112: def main() -> None:  # pragma: no cover - convenience CLI
   113:     optimize()
   114: 
   115: 
   116: if __name__ == "__main__":  # pragma: no cover
   117:     main()


## backtest/run_multi.py (last modified: 2025-08-23 09:47:18)
     1: """Run multi-symbol backtests from the command line.
     2: 
     3: Example:
     4:     python backtest/run_multi.py --symbols "BTC/USDT,ETH/USDT" --exchange csv --csv-dir ./data
     5: """
     6: import argparse
     7: import csv
     8: import json
     9: import os
    10: import random
    11: import statistics
    12: from datetime import datetime, timezone
    13: from typing import Dict, List, Tuple
    14: 
    15: from .engine import backtest_symbol
    16: from .grid_search import run_grid_search
    17: 
    18: 
    19: def _load_csv(symbol: str, timeframe: str, csv_dir: str) -> List[Dict[str, object]]:
    20:     sym = symbol.replace("/", "")
    21:     patterns = [
    22:         f"{sym}-{timeframe}.csv",
    23:         f"{sym}_{timeframe}.csv",
    24:         f"{symbol.replace('/', '_')}-{timeframe}.csv",
    25:         f"{symbol.replace('/', '_')}_{timeframe}.csv",
    26:     ]
    27:     for pat in patterns:
    28:         path = os.path.join(csv_dir, pat)
    29:         if os.path.exists(path):
    30:             rows: List[Dict[str, object]] = []
    31:             with open(path, newline="", encoding="utf8") as fh:
    32:                 reader = csv.DictReader(fh)
    33:                 for r in reader:
    34:                     ts = datetime.fromtimestamp(float(r["timestamp"]) / 1000.0, tz=timezone.utc)
    35:                     rows.append(
    36:                         {
    37:                             "timestamp": ts,
    38:                             "open": float(r["open"]),
    39:                             "high": float(r["high"]),
    40:                             "low": float(r["low"]),
    41:                             "close": float(r["close"]),
    42:                             "volume": float(r["volume"]),
    43:                         }
    44:                     )
    45:             return rows
    46:     raise FileNotFoundError(f"CSV for {symbol} not found in {csv_dir}")
    47: 
    48: 
    49: def load_data(symbols: List[str], exchange: str, timeframe: str, csv_dir: str | None) -> Dict[str, List[Dict[str, object]]]:
    50:     data: Dict[str, List[Dict[str, object]]] = {}
    51:     for sym in symbols:
    52:         if exchange != "csv":
    53:             raise ValueError("Only csv exchange supported in test environment")
    54:         if not csv_dir:
    55:             raise ValueError("csv_dir required")
    56:         data[sym] = _load_csv(sym, timeframe, csv_dir)
    57:     return data
    58: 
    59: 
    60: def compute_metrics(trades: List[Dict[str, float]], equity_curve: List[Dict[str, float]], initial_equity: float) -> Dict[str, float]:
    61:     trades_count = len(trades)
    62:     pnl_usdt = sum(t["pnl_usdt"] for t in trades)
    63:     pnl_pct = pnl_usdt / initial_equity * 100.0 if initial_equity else 0.0
    64:     wins = [t for t in trades if t["pnl_usdt"] > 0]
    65:     losses = [t for t in trades if t["pnl_usdt"] < 0]
    66:     winrate = len(wins) / trades_count * 100.0 if trades_count else 0.0
    67:     expectancy = statistics.mean([t["pnl_pct"] for t in trades]) if trades else 0.0
    68:     profit_factor = sum(t["pnl_usdt"] for t in wins) / abs(sum(t["pnl_usdt"] for t in losses)) if losses else float("inf")
    69:     peak = equity_curve[0]["equity"] if equity_curve else initial_equity
    70:     max_dd = 0.0
    71:     for p in equity_curve:
    72:         if p["equity"] > peak:
    73:             peak = p["equity"]
    74:         dd = (peak - p["equity"]) / peak if peak else 0.0
    75:         if dd > max_dd:
    76:             max_dd = dd
    77:     returns: List[float] = []
    78:     prev = None
    79:     for p in equity_curve:
    80:         if prev is not None and prev > 0:
    81:             returns.append((p["equity"] - prev) / prev)
    82:         prev = p["equity"]
    83:     sharpe = 0.0
    84:     if returns:
    85:         mean = statistics.mean(returns)
    86:         std = statistics.pstdev(returns)
    87:         if std:
    88:             sharpe = mean / std * (len(returns) ** 0.5)
    89:     avg_hold = statistics.mean([t["holding_s"] for t in trades]) if trades else 0.0
    90:     turnover = sum(abs(t["notional"]) for t in trades) / initial_equity if trades else 0.0
    91:     return {
    92:         "trades": trades_count,
    93:         "winrate_pct": winrate,
    94:         "pnl_pct": pnl_pct,
    95:         "pnl_usdt": pnl_usdt,
    96:         "expectancy_pct": expectancy,
    97:         "profit_factor": profit_factor,
    98:         "max_drawdown_pct": max_dd * 100.0,
    99:         "sharpe": sharpe,
   100:         "avg_hold_s": avg_hold,
   101:         "turnover": turnover,
   102:     }
   103: 
   104: 
   105: def run_backtest_multi(
   106:     *,
   107:     symbols: List[str],
   108:     exchange: str,
   109:     timeframe: str,
   110:     csv_dir: str | None = None,
   111:     fee_rate: float = 0.0,
   112:     slippage_bps: float = 0.0,
   113:     risk_pct: float = 0.01,
   114:     initial_equity: float = 1000.0,
   115:     leverage: float = 1.0,
   116:     paper_constraints: bool = True,
   117:     seed: int | None = None,
   118:     out_dir: str = "./result",
   119:     plot: bool = False,
   120:     dry_run: bool = False,
   121: ) -> Tuple[List[Dict[str, float]], List[Dict[str, float]]]:
   122:     if seed is not None:
   123:         random.seed(seed)
   124:     data = load_data(symbols, exchange, timeframe, csv_dir)
   125:     os.makedirs(out_dir, exist_ok=True)
   126: 
   127:     per_symbol_summary: List[Dict[str, float]] = []
   128:     all_trades: List[Dict[str, float]] = []
   129:     equity_maps: Dict[str, List[Dict[str, float]]] = {}
   130:     init_per_symbol = initial_equity / len(symbols)
   131: 
   132:     for sym in symbols:
   133:         trades, eq = backtest_symbol(
   134:             data[sym],
   135:             sym,
   136:             fee_rate=fee_rate,
   137:             slippage_bps=slippage_bps,
   138:             risk_pct=risk_pct,
   139:             initial_equity=init_per_symbol,
   140:             leverage=leverage,
   141:             paper_constraints=paper_constraints,
   142:             seed=seed,
   143:         )
   144:         all_trades.extend(trades)
   145:         equity_maps[sym] = eq
   146:         met = compute_metrics(trades, eq, init_per_symbol)
   147:         row = {"symbol": sym}
   148:         row.update(met)
   149:         per_symbol_summary.append(row)
   150:         if not dry_run:
   151:             with open(os.path.join(out_dir, f"equity_curve_{sym.replace('/', '_')}.csv"), "w", newline="") as fh:
   152:                 w = csv.writer(fh)
   153:                 w.writerow(["timestamp", "equity"])
   154:                 for e in eq:
   155:                     w.writerow([e["timestamp"].isoformat(), f"{e['equity']:.6f}"])
   156: 
   157:     # total equity curve based on trade order
   158:     eq_total: List[Dict[str, float]] = []
   159:     eq = initial_equity
   160:     for tr in sorted(all_trades, key=lambda x: x["exit_time"]):
   161:         eq += tr["pnl_usdt"]
   162:         eq_total.append({"timestamp": tr["exit_time"], "equity": eq})
   163:     total_metrics = compute_metrics(all_trades, eq_total, initial_equity)
   164:     total_row = {"symbol": "TOTAL", **total_metrics, "avg_corr": 0.0}
   165:     summary = per_symbol_summary + [total_row]
   166: 
   167:     if not dry_run:
   168:         # summary csv
   169:         cols = [
   170:             "symbol",
   171:             "trades",
   172:             "winrate_pct",
   173:             "pnl_pct",
   174:             "pnl_usdt",
   175:             "expectancy_pct",
   176:             "profit_factor",
   177:             "max_drawdown_pct",
   178:             "sharpe",
   179:             "avg_hold_s",
   180:             "turnover",
   181:             "avg_corr",
   182:         ]
   183:         with open(os.path.join(out_dir, "report_summary.csv"), "w", newline="") as fh:
   184:             w = csv.writer(fh)
   185:             w.writerow(cols)
   186:             for row in summary:
   187:                 w.writerow([row.get(c, "") for c in cols])
   188:         # trades csv
   189:         trade_cols = [
   190:             "entry_time",
   191:             "exit_time",
   192:             "symbol",
   193:             "side",
   194:             "entry",
   195:             "exit",
   196:             "qty",
   197:             "pnl_pct",
   198:             "pnl_usdt",
   199:             "fee_pct",
   200:             "slippage_bps",
   201:             "reason",
   202:             "score",
   203:             "notional",
   204:             "holding_s",
   205:         ]
   206:         with open(os.path.join(out_dir, "report_trades.csv"), "w", newline="") as fh:
   207:             w = csv.writer(fh)
   208:             w.writerow(trade_cols)
   209:             for tr in all_trades:
   210:                 w.writerow([tr.get(c, "") if not isinstance(tr.get(c, ""), datetime) else tr.get(c).isoformat() for c in trade_cols])
   211:         with open(os.path.join(out_dir, "equity_curve_total.csv"), "w", newline="") as fh:
   212:             w = csv.writer(fh)
   213:             w.writerow(["timestamp", "equity"])
   214:             for e in eq_total:
   215:                 w.writerow([e["timestamp"].isoformat(), f"{e['equity']:.6f}"])
   216:         with open(os.path.join(out_dir, "metrics.json"), "w", encoding="utf8") as fh:
   217:             json.dump({
   218:                 "parameters": {
   219:                     "symbols": symbols,
   220:                     "exchange": exchange,
   221:                     "timeframe": timeframe,
   222:                     "fee_rate": fee_rate,
   223:                     "slippage_bps": slippage_bps,
   224:                     "risk_pct": risk_pct,
   225:                     "initial_equity": initial_equity,
   226:                     "leverage": leverage,
   227:                     "paper_constraints": paper_constraints,
   228:                     "seed": seed,
   229:                 },
   230:                 "summary": summary,
   231:             }, fh, indent=2, default=str)
   232:     # console output
   233:     header = f"{'symbol':<10} {'trades':>6} {'win%':>6} {'pnl%':>8} {'pnl_usdt':>10}"
   234:     print(header)
   235:     for row in summary:
   236:         print(
   237:             f"{row['symbol']:<10} {int(row['trades']):>6} {row['winrate_pct']:>6.2f} {row['pnl_pct']:>8.2f} {row['pnl_usdt']:>10.2f}"
   238:         )
   239:     return summary, all_trades
   240: 
   241: 
   242: def build_arg_parser() -> argparse.ArgumentParser:
   243:     p = argparse.ArgumentParser(description="Run multi-pair backtest")
   244:     p.add_argument("--symbols", required=True)
   245:     p.add_argument("--exchange", default="csv")
   246:     p.add_argument("--timeframe", default="1m")
   247:     p.add_argument("--csv-dir")
   248:     p.add_argument("--fee-rate", type=float, default=0.0)
   249:     p.add_argument("--slippage-bps", type=float, default=0.0)
   250:     p.add_argument("--risk-pct", type=float, default=0.01)
   251:     p.add_argument("--initial-equity", type=float, default=1000.0)
   252:     p.add_argument("--leverage", type=float, default=1.0)
   253:     p.add_argument("--paper-constraints", action="store_true")
   254:     p.add_argument("--seed", type=int)
   255:     p.add_argument("--out-dir", default="./result")
   256:     p.add_argument("--plot", action="store_true")
   257:     p.add_argument("--dry-run", action="store_true")
   258:     # grid search options
   259:     p.add_argument("--grid", action="store_true", help="activate grid search")
   260:     p.add_argument("--grid-max", type=int, default=12)
   261:     p.add_argument("--grid-tf")
   262:     p.add_argument("--grid-score-min")
   263:     p.add_argument("--grid-atr-min")
   264:     p.add_argument("--grid-rr-min")
   265:     p.add_argument("--grid-risk-pct")
   266:     p.add_argument("--grid-slippage-bps")
   267:     p.add_argument("--grid-fee")
   268:     p.add_argument("--grid-cooldown")
   269:     p.add_argument("--grid-hours")
   270:     p.add_argument("--match-exchange-semantics", action="store_true")
   271:     return p
   272: 
   273: 
   274: def main(args: List[str] | None = None):
   275:     parser = build_arg_parser()
   276:     ns = parser.parse_args(args=args)
   277:     symbols = [s.strip() for s in ns.symbols.split(",") if s.strip()]
   278:     if ns.grid:
   279:         # helper to parse comma separated values
   280:         def _parse(val: str | None, cast):
   281:             if not val:
   282:                 return None
   283:             return [cast(v) for v in val.split(",") if v.strip()]
   284: 
   285:         param_lists: Dict[str, List] = {}
   286:         if ns.grid_tf:
   287:             param_lists["timeframe"] = _parse(ns.grid_tf, str)
   288:         if ns.grid_score_min:
   289:             param_lists["score_min"] = _parse(ns.grid_score_min, float)
   290:         if ns.grid_atr_min:
   291:             param_lists["atr_min_ratio"] = _parse(ns.grid_atr_min, float)
   292:         if ns.grid_rr_min:
   293:             param_lists["rr_min"] = _parse(ns.grid_rr_min, float)
   294:         if ns.grid_risk_pct:
   295:             param_lists["risk_pct"] = _parse(ns.grid_risk_pct, float)
   296:         if ns.grid_slippage_bps:
   297:             param_lists["slippage_bps"] = _parse(ns.grid_slippage_bps, float)
   298:         if ns.grid_fee:
   299:             param_lists["fee_rate"] = _parse(ns.grid_fee, float)
   300:         if ns.grid_cooldown:
   301:             param_lists["cooldown_secs"] = _parse(ns.grid_cooldown, int)
   302:         if ns.grid_hours:
   303:             param_lists["hours"] = _parse(ns.grid_hours, str)
   304: 
   305:         base_params = {
   306:             "timeframe": ns.timeframe,
   307:             "score_min": 55,
   308:             "atr_min_ratio": 0.002,
   309:             "rr_min": 1.2,
   310:             "risk_pct": ns.risk_pct,
   311:             "slippage_bps": ns.slippage_bps,
   312:             "fee_rate": ns.fee_rate,
   313:             "cooldown_secs": 300,
   314:             "hours": "7-11,13-17",
   315:         }
   316: 
   317:         return run_grid_search(
   318:             symbols=symbols,
   319:             exchange=ns.exchange,
   320:             base_params=base_params,
   321:             param_lists=param_lists,
   322:             grid_max=ns.grid_max,
   323:             csv_dir=ns.csv_dir,
   324:             initial_equity=ns.initial_equity,
   325:             leverage=ns.leverage,
   326:             paper_constraints=ns.paper_constraints,
   327:             seed=ns.seed,
   328:             out_dir=os.path.join(ns.out_dir, "grid"),
   329:             match_exchange_semantics=ns.match_exchange_semantics,
   330:         )
   331: 
   332:     return run_backtest_multi(
   333:         symbols=symbols,
   334:         exchange=ns.exchange,
   335:         timeframe=ns.timeframe,
   336:         csv_dir=ns.csv_dir,
   337:         fee_rate=ns.fee_rate,
   338:         slippage_bps=ns.slippage_bps,
   339:         risk_pct=ns.risk_pct,
   340:         initial_equity=ns.initial_equity,
   341:         leverage=ns.leverage,
   342:         paper_constraints=ns.paper_constraints,
   343:         seed=ns.seed,
   344:         out_dir=ns.out_dir,
   345:         plot=ns.plot,
   346:         dry_run=ns.dry_run,
   347:     )
   348: 
   349: 
   350: if __name__ == "__main__":  # pragma: no cover
   351:     main()


## backtest/runner.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/backtest/runner.py
     2: from __future__ import annotations
     3: import json, os, asyncio
     4: from typing import List, Dict, Callable
     5: from .engine import BacktestEngine
     6: from ..signals.factory import load_signal
     7: 
     8: def default_loader(fetch_sync: Callable) -> Callable:
     9:     return fetch_sync
    10: 
    11: class BacktestRunner:
    12:     def __init__(self, loader, out_dir: str, strategy: str, cfg: Dict,
    13:                  cash: float, risk_pct: float, max_conc: int=4):
    14:         self.loader = loader
    15:         self.out_dir = out_dir
    16:         self.strategy_fn = load_signal(strategy)
    17:         self.cfg = dict(cfg)
    18:         self.cash = cash
    19:         self.risk_pct = risk_pct
    20:         self.sem = asyncio.Semaphore(max_conc)
    21: 
    22:     async def _run_one(self, symbol: str, timeframe: str, start: int, end: int) -> Dict:
    23:         async with self.sem:
    24:             engine = BacktestEngine(self.loader, self.strategy_fn, self.cfg,
    25:                                     os.path.join(self.out_dir, f"{symbol}_{timeframe}"),
    26:                                     self.cash, self.risk_pct)
    27:             loop = asyncio.get_running_loop()
    28:             return await loop.run_in_executor(None, engine.run_pair, symbol, timeframe, start, end)
    29: 
    30:     async def run_all(self, symbols: List[str], timeframes: List[str], start: int, end: int) -> Dict:
    31:         os.makedirs(self.out_dir, exist_ok=True)
    32:         tasks = [self._run_one(sym, tf, start, end) for sym in symbols for tf in timeframes]
    33:         results = await asyncio.gather(*tasks)
    34: 
    35:         per_symbol_best = {}
    36:         for r in results:
    37:             if "error" in r: continue
    38:             sym = r["symbol"]
    39:             if sym not in per_symbol_best or r["score"] > per_symbol_best[sym]["score"]:
    40:                 per_symbol_best[sym] = r
    41: 
    42:         top_overall = sorted([r for r in results if "error" not in r], key=lambda x: x["score"], reverse=True)[:10]
    43:         proposal = {
    44:             "per_symbol_best": {k: {"timeframe": v["timeframe"], "score": v["score"], "pf": v["pf"],
    45:                                     "winrate": v["winrate"], "maxdd": v["maxdd"]}
    46:                                 for k,v in per_symbol_best.items()},
    47:             "top_overall": top_overall,
    48:             "suggested_timeframes": {k: v["timeframe"] for k,v in per_symbol_best.items()},
    49:             "note": "Suggestion basée sur score composite (WR, PF, MaxDD, Sharpe)."
    50:         }
    51:         with open(os.path.join(self.out_dir, "metrics.json"), "w") as f:
    52:             json.dump({"results": results, "proposal": proposal}, f, indent=2)
    53:         return {"results": results, "proposal": proposal}

## bitget_futures_pairs.py (last modified: 2025-08-23 09:47:18)
     1: #!/usr/bin/env python3
     2: """Fetch the list of Bitget futures contracts.
     3: 
     4: This helper script queries the public Bitget REST API to retrieve futures
     5: trading pairs for the specified product types and saves them to CSV and JSON
     6: files. It mirrors the standalone example provided by the user but integrates
     7: with the repository's configuration system.
     8: 
     9: Usage examples::
    10: 
    11:     python bitget_futures_pairs.py
    12:     python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
    13:     python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
    14: """
    15: from __future__ import annotations
    16: 
    17: import argparse
    18: import csv
    19: import json
    20: import sys
    21: import time
    22: from typing import Any, Dict, List
    23: 
    24: from scalp.bot_config import CONFIG
    25: 
    26: try:  # pragma: no cover - import guard
    27:     import requests
    28: except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
    29:     sys.stderr.write(
    30:         "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
    31:     )
    32:     raise
    33: 
    34: BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
    35: CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
    36: DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]
    37: 
    38: 
    39: def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
    40:     """Return contract metadata for ``product_type``."""
    41:     url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
    42:     params = {"productType": product_type}
    43:     resp = requests.get(url, params=params, timeout=timeout)
    44:     try:
    45:         data = resp.json()
    46:     except json.JSONDecodeError as exc:  # pragma: no cover - network failure
    47:         raise RuntimeError(
    48:             f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
    49:         ) from exc
    50:     if resp.status_code != 200 or data.get("code") != "00000":
    51:         raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
    52:     return data.get("data", [])
    53: 
    54: 
    55: def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    56:     """Select and rename key fields for CSV/JSON output."""
    57:     rows: List[Dict[str, Any]] = []
    58:     for c in contracts:
    59:         row = {
    60:             "productType": product_type,
    61:             "symbol": c.get("symbol"),
    62:             "baseCoin": c.get("baseCoin"),
    63:             "quoteCoin": c.get("quoteCoin"),
    64:             "symbolType": c.get("symbolType"),
    65:             "symbolStatus": c.get("symbolStatus"),
    66:             "maxLever": c.get("maxLever"),
    67:             "minLever": c.get("minLever"),
    68:             "minTradeNum": c.get("minTradeNum"),
    69:             "sizeMultiplier": c.get("sizeMultiplier"),
    70:             "pricePlace": c.get("pricePlace"),
    71:             "volumePlace": c.get("volumePlace"),
    72:             "launchTime": c.get("launchTime"),
    73:             "deliveryTime": c.get("deliveryTime"),
    74:         }
    75:         rows.append(row)
    76:     return rows
    77: 
    78: 
    79: def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
    80:     """Write ``rows`` to ``path`` in CSV format."""
    81:     headers = [
    82:         "productType",
    83:         "symbol",
    84:         "baseCoin",
    85:         "quoteCoin",
    86:         "symbolType",
    87:         "symbolStatus",
    88:         "maxLever",
    89:         "minLever",
    90:         "minTradeNum",
    91:         "sizeMultiplier",
    92:         "pricePlace",
    93:         "volumePlace",
    94:         "launchTime",
    95:         "deliveryTime",
    96:     ]
    97:     with open(path, "w", newline="", encoding="utf-8") as fh:
    98:         writer = csv.DictWriter(fh, fieldnames=headers)
    99:         writer.writeheader()
   100:         if rows:
   101:             writer.writerows(rows)
   102: 
   103: 
   104: def main(argv: List[str] | None = None) -> int:
   105:     parser = argparse.ArgumentParser(
   106:         description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
   107:     )
   108:     parser.add_argument(
   109:         "--types",
   110:         nargs="+",
   111:         default=DEFAULT_PRODUCT_TYPES,
   112:         help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
   113:     )
   114:     parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
   115:     parser.add_argument(
   116:         "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
   117:     )
   118:     parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
   119:     args = parser.parse_args(argv)
   120: 
   121:     all_rows: List[Dict[str, Any]] = []
   122:     merged_json: Dict[str, List[Dict[str, Any]]] = {}
   123: 
   124:     for i, pt in enumerate(args.types):
   125:         try:
   126:             contracts = fetch_contracts(pt)
   127:         except Exception as exc:  # pragma: no cover - network/runtime error
   128:             sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
   129:             continue
   130:         rows = normalize_rows(pt, contracts)
   131:         all_rows.extend(rows)
   132:         merged_json[pt] = contracts
   133:         if i < len(args.types) - 1 and args.sleep > 0:
   134:             time.sleep(args.sleep)
   135: 
   136:     all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))
   137: 
   138:     write_csv(all_rows, args.out)
   139:     with open(args.json_out, "w", encoding="utf-8") as fh:
   140:         json.dump(merged_json, fh, ensure_ascii=False, indent=2)
   141: 
   142:     counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
   143:     total = sum(counts.values())
   144:     print(
   145:         f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
   146:     )
   147:     for pt, n in counts.items():
   148:         print(f"  - {pt}: {n} pairs")
   149:     return 0
   150: 
   151: 
   152: if __name__ == "__main__":  # pragma: no cover - CLI execution
   153:     raise SystemExit(main())


## bot.py (last modified: 2025-08-23 09:47:18)
     1: # bot.py
     2: from __future__ import annotations
     3: import asyncio
     4: 
     5: from scalp.config import load_settings          # ✅ maintenant import direct
     6: from scalp.live.orchestrator import run_orchestrator
     7: from scalp.live.notify import build_notifier_and_stream
     8: 
     9: # >>>> TODO: remplace DummyExchange par ton client Bitget/CCXT asynchrone
    10: class DummyExchange:
    11:     async def fetch_ohlcv(self, symbol, timeframe="5m", limit=150):
    12:         raise NotImplementedError("Brancher fetch_ohlcv sur ta source historique/CCXT.")
    13:     async def create_order(self, symbol, type, side, qty):
    14:         return {"id": "dummy", "status": "filled", "side": side, "qty": qty}
    15: 
    16: async def main():
    17:     # Charge config (runtime) + secrets (.env)
    18:     config, secrets = load_settings()
    19: 
    20:     # TODO: branche ici ton vrai exchange Bitget avec secrets
    21:     # Exemple si tu utilises CCXT (asynchrone) :
    22:     # import ccxt.async_support as ccxt
    23:     # exchange = ccxt.bitget({
    24:     #     "apiKey": secrets["BITGET_API_KEY"],
    25:     #     "secret": secrets["BITGET_API_SECRET"],
    26:     #     "password": secrets["BITGET_API_PASSWORD"],
    27:     # })
    28:     exchange = DummyExchange()
    29: 
    30:     notifier, command_stream = await build_notifier_and_stream()
    31:     await run_orchestrator(
    32:         exchange,
    33:         config,
    34:         symbols=config.get("top_symbols", []),
    35:         notifier=notifier,
    36:         command_stream=command_stream,
    37:     )
    38: 
    39: if __name__ == "__main__":
    40:     asyncio.run(main())
    41:     

## cli.py (last modified: 2025-08-23 09:47:18)
     1: """Command line utilities for the Scalp project.
     2: 
     3: This module exposes a small command line interface used throughout the
     4: project.  The actual trading logic lives in other modules, however the CLI is
     5: responsible for parsing parameters and dispatching the appropriate routines.
     6: 
     7: The implementation intentionally keeps the invoked functions minimal so that
     8: tests can patch them easily.  In a real deployment these functions would
     9: perform optimisation, walk‑forward analysis or run the live pipeline.
    10: """
    11: 
    12: from __future__ import annotations
    13: 
    14: import argparse
    15: import asyncio
    16: from typing import Iterable, List
    17: 
    18: from scalp.version import bump_version_from_git
    19: 
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Placeholder implementations
    23: # ---------------------------------------------------------------------------
    24: 
    25: 
    26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    27:     """Run a parallel parameter optimisation.
    28: 
    29:     The real project dispatches a potentially heavy optimisation routine.  The
    30:     function is kept trivial so unit tests can verify that the CLI wiring works
    31:     without actually performing the optimisation.
    32:     """
    33: 
    34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
    35: 
    36: 
    37: def run_walkforward_analysis(
    38:     pair: str, timeframe: str, splits: int, train_ratio: float
    39: ) -> None:
    40:     """Execute a walk-forward analysis."""
    41: 
    42:     print(
    43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    44:     )
    45: 
    46: 
    47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    48:     """Run the live trading pipeline."""
    49: 
    50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
    51: 
    52: 
    53: # ---------------------------------------------------------------------------
    54: # Argument parsing
    55: # ---------------------------------------------------------------------------
    56: 
    57: 
    58: def create_parser() -> argparse.ArgumentParser:
    59:     """Create the top-level argument parser."""
    60: 
    61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
    62:     sub = parser.add_subparsers(dest="command")
    63: 
    64:     # --- ``opt`` command -------------------------------------------------
    65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    67:     opt_p.add_argument("--tf", required=True, help="timeframe")
    68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    69:     opt_p.set_defaults(
    70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    71:     )
    72: 
    73:     # --- ``walkforward`` command ----------------------------------------
    74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    75:     wf_p.add_argument("--pair", required=True, help="trading pair")
    76:     wf_p.add_argument("--tf", required=True, help="timeframe")
    77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    78:     wf_p.add_argument(
    79:         "--train-ratio",
    80:         type=float,
    81:         default=0.7,
    82:         help="portion of data used for training",
    83:     )
    84:     wf_p.set_defaults(
    85:         func=lambda a: run_walkforward_analysis(
    86:             a.pair, a.tf, a.splits, a.train_ratio
    87:         )
    88:     )
    89: 
    90:     # --- ``live`` command -----------------------------------------------
    91:     live_p = sub.add_parser("live", help="run the live async pipeline")
    92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
    95: 
    96:     # --- ``bump-version`` command -------------------------------------
    97:     bv_p = sub.add_parser(
    98:         "bump-version",
    99:         help="update the VERSION file based on the latest git commit",
   100:     )
   101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
   102: 
   103:     return parser
   104: 
   105: 
   106: def main(argv: Iterable[str] | None = None) -> int:
   107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
   108: 
   109:     parser = create_parser()
   110:     args = parser.parse_args(argv)
   111:     if not hasattr(args, "func"):
   112:         parser.print_help()
   113:         return 0
   114:     result = args.func(args)
   115:     return 0 if result is None else int(result)
   116: 
   117: 
   118: if __name__ == "__main__":  # pragma: no cover - manual invocation
   119:     raise SystemExit(main())
   120: 


## config/__init__.py (last modified: 2025-08-23 09:47:18)
     1:  # scalp/config/__init__.py
     2: from .loader import load_settings
     3: 
     4: __all__ = ["load_settings"]

## config/loader.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/config/loader.py
     2: from __future__ import annotations
     3: import os, json
     4: from typing import Any, Dict, Tuple
     5: 
     6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
     7: try:
     8:     import yaml  # type: ignore
     9: except Exception:
    10:     yaml = None  # fallback JSON si besoin
    11: 
    12: # dotenv (facultatif) pour charger un .env automatiquement
    13: try:
    14:     from dotenv import load_dotenv  # type: ignore
    15: except Exception:
    16:     load_dotenv = None
    17: 
    18: # ---------------- Utils ----------------
    19: 
    20: def _parse_bool(x: Any, default: bool = False) -> bool:
    21:     if isinstance(x, bool): return x
    22:     s = str(x).strip().lower()
    23:     if s in ("1","true","yes","y","on"): return True
    24:     if s in ("0","false","no","n","off",""): return False
    25:     return default
    26: 
    27: def _parse_float(x: Any, default: float | None = None) -> float | None:
    28:     try: return float(x)
    29:     except Exception: return default
    30: 
    31: def _parse_int(x: Any, default: int | None = None) -> int | None:
    32:     try: return int(str(x).strip())
    33:     except Exception: return default
    34: 
    35: def _parse_csv(x: Any) -> list[str]:
    36:     if x is None: return []
    37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
    38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
    39: 
    40: def _read_yaml(path: str) -> Dict[str, Any]:
    41:     if not os.path.exists(path): return {}
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         if yaml:
    44:             return yaml.safe_load(f) or {}
    45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
    46:         try:
    47:             return json.load(f)
    48:         except Exception:
    49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
    50: 
    51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    52:     # shallow merge suffisant ici (structure plate)
    53:     out = dict(a)
    54:     out.update({k: v for k, v in b.items() if v is not None})
    55:     return out
    56: 
    57: # ---------------- Public API ----------------
    58: 
    59: def load_settings(
    60:     config_path: str = "config.yml",
    61:     config_local_path: str = "config.local.yml",
    62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    63:     """
    64:     Retourne (config_runtime, secrets) :
    65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
    66:       - secrets        : clés API & tokens (NE PAS versionner)
    67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
    68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
    69:     """
    70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
    71:     if load_dotenv is not None:
    72:         load_dotenv(override=False)
    73: 
    74:     # 2) Charge YAML (config.yml + override local)
    75:     base = _read_yaml(config_path)
    76:     local = _read_yaml(config_local_path)
    77:     cfg = _merge_dict(base, local)
    78: 
    79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
    80:     env_overlay: Dict[str, Any] = {}
    81:     # Verbosité
    82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
    83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
    84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
    85:     # Runtime / Stratégie
    86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
    87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
    88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
    89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
    90:     # Watchlist
    91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
    92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
    93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
    94:     )
    95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
    96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
    97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
    98:     caps_env = os.getenv("CAPS_JSON")
    99:     if caps_env:
   100:         try:
   101:             env_overlay["CAPS"] = json.loads(caps_env)
   102:         except Exception:
   103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
   104:     else:
   105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
   106: 
   107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
   108:     secrets = {
   109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
   110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
   111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
   112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
   113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
   114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
   115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
   116:     }
   117: 
   118:     # 5) Runtime normalisé pour l’orchestrateur
   119:     runtime = {
   120:         "quiet": bool(env_overlay["QUIET"]),
   121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
   122:         "timeframe": str(env_overlay["TIMEFRAME"]),
   123:         "cash": float(env_overlay["CASH"]),
   124:         "risk_pct": float(env_overlay["RISK_PCT"]),
   125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
   126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
   127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
   128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
   129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
   130:         "caps": env_overlay["CAPS"],                        # dict
   131:         # rempli au boot par les frais Bitget
   132:         "fees_by_symbol": {}, 
   133:     }
   134: 
   135:     return runtime, secrets
   136:     

## dashboard.py (last modified: 2025-08-23 09:47:18)
     1: # dashboard.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: import time
     6: from pathlib import Path
     7: from typing import Dict, Tuple
     8: 
     9: import pandas as pd
    10: import streamlit as st
    11: 
    12: # ------------------------------------------------------------
    13: # Réglages
    14: # ------------------------------------------------------------
    15: LOG_DIR = Path("scalp/live/logs")  # emplacement des CSV créés par l'orchestrateur
    16: REFRESH_SECS = 5                   # auto-refresh UI
    17: MAX_ROWS_SHOW = 2000               # clamp mémoire
    18: 
    19: 
    20: # ------------------------------------------------------------
    21: # Utilitaires lecture robuste CSV
    22: # ------------------------------------------------------------
    23: def _safe_read_csv(path: Path) -> pd.DataFrame:
    24:     if not path.exists():
    25:         return pd.DataFrame()
    26:     try:
    27:         df = pd.read_csv(path)
    28:         # clamp pour éviter d’exploser en RAM si les logs deviennent énormes
    29:         if len(df) > MAX_ROWS_SHOW:
    30:             df = df.tail(MAX_ROWS_SHOW).reset_index(drop=True)
    31:         return df
    32:     except Exception:
    33:         # fichier en cours d’écriture → on réessaiera au prochain tick
    34:         return pd.DataFrame()
    35: 
    36: 
    37: def load_logs() -> Dict[str, pd.DataFrame]:
    38:     return {
    39:         "signals": _safe_read_csv(LOG_DIR / "signals.csv"),
    40:         "orders": _safe_read_csv(LOG_DIR / "orders.csv"),
    41:         "fills": _safe_read_csv(LOG_DIR / "fills.csv"),
    42:         "positions": _safe_read_csv(LOG_DIR / "positions.csv"),
    43:     }
    44: 
    45: 
    46: def _format_ts_ms_to_str(df: pd.DataFrame, col: str = "ts") -> pd.DataFrame:
    47:     if col in df.columns:
    48:         try:
    49:             df[col] = pd.to_datetime(df[col], unit="ms")
    50:         except Exception:
    51:             try:
    52:                 df[col] = pd.to_datetime(df[col])
    53:             except Exception:
    54:                 pass
    55:     return df
    56: 
    57: 
    58: # ------------------------------------------------------------
    59: # Métriques & agrégats simples
    60: # ------------------------------------------------------------
    61: def compute_activity_metrics(df_orders: pd.DataFrame, df_fills: pd.DataFrame) -> Tuple[float, float, int]:
    62:     """
    63:     Retourne: (volume notionnel approx, fees cumulés, nb fills)
    64:     - notionnel approx = somme(|price * qty|) sur les fills (indépendant du sens)
    65:     - fees = somme(fee) si dispo
    66:     """
    67:     notional = 0.0
    68:     fees = 0.0
    69:     n_fills = 0
    70: 
    71:     if not df_fills.empty:
    72:         # normalisation colonnes
    73:         price_col = next((c for c in ["price", "fillPrice", "fill_px"] if c in df_fills.columns), None)
    74:         qty_col = next((c for c in ["qty", "size", "fillQty", "fill_sz"] if c in df_fills.columns), None)
    75:         fee_col = next((c for c in ["fee", "fillFee"] if c in df_fills.columns), None)
    76: 
    77:         if price_col and qty_col:
    78:             notional = float((df_fills[price_col].abs() * df_fills[qty_col].abs()).sum())
    79:             n_fills = int(len(df_fills))
    80:         if fee_col:
    81:             fees = float(df_fills[fee_col].fillna(0).sum())
    82: 
    83:     return notional, fees, n_fills
    84: 
    85: 
    86: def last_positions_snapshot(df_positions: pd.DataFrame) -> pd.DataFrame:
    87:     """Dernier état par symbole (state/qty/entry)."""
    88:     if df_positions.empty:
    89:         return df_positions
    90:     df = df_positions.copy()
    91:     df = _format_ts_ms_to_str(df, "ts")
    92:     # on prend le dernier enregistrement par symbol
    93:     last = df.sort_values("ts").groupby("symbol", as_index=False).tail(1)
    94:     return last.sort_values("symbol").reset_index(drop=True)
    95: 
    96: 
    97: def recent_signals(df_signals: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
    98:     if df_signals.empty:
    99:         return df_signals
   100:     df = df_signals.copy()
   101:     df = _format_ts_ms_to_str(df, "ts")
   102:     df = df.sort_values("ts", ascending=False).head(limit)
   103:     return df.reset_index(drop=True)
   104: 
   105: 
   106: def recent_orders(df_orders: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   107:     if df_orders.empty:
   108:         return df_orders
   109:     df = df_orders.copy()
   110:     df = _format_ts_ms_to_str(df, "ts")
   111:     df = df.sort_values("ts", ascending=False).head(limit)
   112:     # petites colonnes utiles en premier
   113:     cols = [c for c in ["ts", "symbol", "side", "status", "price", "sl", "tp", "risk_pct", "order_id"] if c in df.columns]
   114:     other = [c for c in df.columns if c not in cols]
   115:     return df[cols + other]
   116: 
   117: 
   118: def recent_fills(df_fills: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
   119:     if df_fills.empty:
   120:         return df_fills
   121:     df = df_fills.copy()
   122:     df = _format_ts_ms_to_str(df, "ts")
   123:     df = df.sort_values("ts", ascending=False).head(limit)
   124:     cols = [c for c in ["ts", "symbol", "order_id", "trade_id", "price", "qty", "fee"] if c in df.columns]
   125:     other = [c for c in df.columns if c not in cols]
   126:     return df[cols + other]
   127: 
   128: 
   129: # ------------------------------------------------------------
   130: # UI
   131: # ------------------------------------------------------------
   132: st.set_page_config(page_title="ScalpBot Dashboard", layout="wide")
   133: st.title("📊 ScalpBot — Dashboard Live")
   134: 
   135: # auto-refresh
   136: st.caption("Auto-refresh toutes les {}s".format(REFRESH_SECS))
   137: st_autorefresh = st.experimental_rerun if False else None  # placeholder to keep code readable
   138: # Streamlit v1.32+ propose st.autorefresh :
   139: try:
   140:     st_autorefresh = st.experimental_rerun  # fallback compat
   141:     from streamlit.runtime.scriptrunner import add_script_run_ctx  # noqa: F401
   142:     st_autorefresh = None
   143: except Exception:
   144:     pass
   145: 
   146: try:
   147:     st_autorefresh = st.autorefresh(interval=REFRESH_SECS * 1000, key="autorf")
   148: except Exception:
   149:     pass
   150: 
   151: # Choix du dossier de logs (utile si on lance le dashboard depuis un autre cwd)
   152: default_dir = str(LOG_DIR.resolve())
   153: custom_dir = st.sidebar.text_input("Dossier de logs", value=default_dir)
   154: LOG_DIR = Path(custom_dir) if custom_dir else LOG_DIR
   155: 
   156: if not LOG_DIR.exists():
   157:     st.error(f"Dossier introuvable : {LOG_DIR}")
   158:     st.stop()
   159: 
   160: data = load_logs()
   161: df_sig, df_ord, df_fill, df_pos = data["signals"], data["orders"], data["fills"], data["positions"]
   162: 
   163: # KPIs rapides
   164: notional, fees, n_fills = compute_activity_metrics(df_ord, df_fill)
   165: col_a, col_b, col_c, col_d = st.columns(4)
   166: col_a.metric("Paires actives (Top 10)", "10")
   167: col_b.metric("Fills (total)", f"{n_fills}")
   168: col_c.metric("Notionnel cumulé (approx)", f"{notional:,.0f} USDT")
   169: col_d.metric("Frais cumulés", f"{fees:,.2f} USDT")
   170: 
   171: st.divider()
   172: 
   173: # 1) Positions snapshot
   174: st.subheader("📌 Positions (snapshot courant par symbole)")
   175: pos_snapshot = last_positions_snapshot(df_pos)
   176: if pos_snapshot.empty:
   177:     st.info("Aucune position pour l’instant.")
   178: else:
   179:     # Met un peu d'ordre dans les colonnes
   180:     order_cols = [c for c in ["symbol", "state", "qty", "entry", "ts"] if c in pos_snapshot.columns]
   181:     pos_snapshot = pos_snapshot[order_cols + [c for c in pos_snapshot.columns if c not in order_cols]]
   182:     st.dataframe(pos_snapshot, use_container_width=True, height=260)
   183: 
   184: # 2) Derniers signaux
   185: st.subheader("📣 Derniers signaux")
   186: sig_tbl = recent_signals(df_sig, limit=40)
   187: if sig_tbl.empty:
   188:     st.info("Pas encore de signaux.")
   189: else:
   190:     # comptage LONG/SHORT
   191:     try:
   192:         by_side = sig_tbl.assign(side_norm=sig_tbl["side"].astype(str).str.upper()).groupby("side_norm").size()
   193:         st.bar_chart(by_side)
   194:     except Exception:
   195:         pass
   196:     st.dataframe(sig_tbl, use_container_width=True, height=300)
   197: 
   198: # 3) Ordres récents
   199: st.subheader("🧾 Ordres récents")
   200: ord_tbl = recent_orders(df_ord, limit=40)
   201: if ord_tbl.empty:
   202:     st.info("Pas encore d’ordres.")
   203: else:
   204:     st.dataframe(ord_tbl, use_container_width=True, height=280)
   205: 
   206: # 4) Fills récents
   207: st.subheader("✅ Fills récents")
   208: fills_tbl = recent_fills(df_fill, limit=80)
   209: if fills_tbl.empty:
   210:     st.info("Pas encore d’exécutions (fills).")
   211: else:
   212:     st.dataframe(fills_tbl, use_container_width=True, height=320)
   213: 
   214: st.caption(f"Logs: {LOG_DIR}")

## data/BTCUSDT-1m.csv (last modified: 2025-08-23 09:47:18)
     1: ts,open,high,low,close,volume
     2: 1625097600000,34000,34100,33950,34050,123.4
     3: 1625097660000,34050,34200,34000,34150,150.7
     4: 1625097720000,34150,34300,34100,34250,180.3
     5: 1625097780000,34250,34400,34200,34350,200.1
     6: 1625097840000,34350,34500,34300,34450,220.8

## data/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Indicator computation helpers."""
     2: 
     3: from .indicators import compute_all
     4: 
     5: __all__ = ["compute_all"]


## data/indicators.py (last modified: 2025-08-23 09:47:18)
     1: import pandas as pd
     2: 
     3: __all__ = ["compute_all"]
     4: 
     5: def compute_all(
     6:     df: pd.DataFrame,
     7:     *,
     8:     ema_fast: int = 20,
     9:     ema_slow: int = 50,
    10:     rsi_period: int = 14,
    11:     macd_fast: int = 12,
    12:     macd_slow: int = 26,
    13:     macd_signal: int = 9,
    14:     atr_period: int = 14,
    15:     swing_lookback: int = 5,
    16: ) -> pd.DataFrame:
    17:     """Compute common indicators and return enriched DataFrame.
    18: 
    19:     Parameters
    20:     ----------
    21:     df : pd.DataFrame
    22:         DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
    23:         ``volume`` columns ordered chronologically.
    24: 
    25:     Returns
    26:     -------
    27:     pd.DataFrame
    28:         New DataFrame with additional indicator columns.
    29:     """
    30: 
    31:     if df.empty:
    32:         return df.copy()
    33: 
    34:     df = df.copy()
    35: 
    36:     # --- VWAP ---------------------------------------------------------------
    37:     typical = (df["high"] + df["low"] + df["close"]) / 3.0
    38:     vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
    39:     df["vwap"] = vwap
    40: 
    41:     # --- EMAs ---------------------------------------------------------------
    42:     df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
    43:     df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()
    44: 
    45:     # --- RSI ----------------------------------------------------------------
    46:     delta = df["close"].diff()
    47:     gain = delta.where(delta > 0, 0.0)
    48:     loss = -delta.where(delta < 0, 0.0)
    49:     avg_gain = gain.rolling(rsi_period).mean()
    50:     avg_loss = loss.rolling(rsi_period).mean()
    51:     rs = avg_gain / avg_loss
    52:     rsi = 100 - (100 / (1 + rs))
    53:     df["rsi"] = rsi.fillna(50.0)
    54: 
    55:     # --- MACD ---------------------------------------------------------------
    56:     ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
    57:     ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
    58:     macd = ema_fast_series - ema_slow_series
    59:     signal = macd.ewm(span=macd_signal, adjust=False).mean()
    60:     df["macd"] = macd
    61:     df["macd_signal"] = signal
    62:     df["macd_hist"] = macd - signal
    63: 
    64:     # --- OBV ----------------------------------------------------------------
    65:     obv = [0.0]
    66:     closes = df["close"].tolist()
    67:     vols = df["volume"].tolist()
    68:     for i in range(1, len(df)):
    69:         if closes[i] > closes[i - 1]:
    70:             obv.append(obv[-1] + vols[i])
    71:         elif closes[i] < closes[i - 1]:
    72:             obv.append(obv[-1] - vols[i])
    73:         else:
    74:             obv.append(obv[-1])
    75:     df["obv"] = obv
    76: 
    77:     # --- ATR ----------------------------------------------------------------
    78:     high_low = df["high"] - df["low"]
    79:     high_close = (df["high"] - df["close"].shift()).abs()
    80:     low_close = (df["low"] - df["close"].shift()).abs()
    81:     tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    82:     df["atr"] = tr.rolling(atr_period).mean()
    83: 
    84:     # --- Swing highs/lows ---------------------------------------------------
    85:     df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
    86:     df["swing_low"] = df["low"].rolling(window=swing_lookback).min()
    87: 
    88:     return df


## dump_repo.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: from datetime import datetime
     3: from pathlib import Path
     4: 
     5: IGNORE_EXTENSIONS = {'.log', '.pyc'}
     6: IGNORE_DIRS = {'__pycache__'}
     7: 
     8: 
     9: def _is_ignored(path: Path) -> bool:
    10:     """Return True if the path should be ignored."""
    11:     if any(part.startswith('.') for part in path.parts):
    12:         return True
    13:     if path.suffix in IGNORE_EXTENSIONS:
    14:         return True
    15:     if any(part in IGNORE_DIRS for part in path.parts):
    16:         return True
    17:     return False
    18: 
    19: 
    20: def _build_tree(root: Path, ignore_path: Path) -> str:
    21:     lines = []
    22:     for dirpath, dirnames, filenames in os.walk(root):
    23:         dirpath = Path(dirpath)
    24:         dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
    25:         depth = len(dirpath.relative_to(root).parts)
    26:         indent = '    ' * depth
    27:         lines.append(f"{indent}{dirpath.name}/")
    28:         for fname in sorted(filenames):
    29:             fpath = dirpath / fname
    30:             if fpath == ignore_path or _is_ignored(fpath):
    31:                 continue
    32:             lines.append(f"{indent}    {fname}")
    33:     return '\n'.join(lines)
    34: 
    35: 
    36: def _iter_files(root: Path):
    37:     for path in sorted(root.rglob('*')):
    38:         if path.is_file() and not _is_ignored(path):
    39:             yield path
    40: 
    41: 
    42: def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
    43:     """Create a text dump of the repository tree and file contents."""
    44:     root_path = Path(root).resolve()
    45:     output_path = root_path / output_path
    46:     now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    47:     with output_path.open('w', encoding='utf-8') as dump:
    48:         dump.write(f"Dump created: {now}\n")
    49:         dump.write('Repository tree:\n')
    50:         dump.write(_build_tree(root_path, output_path))
    51:         dump.write('\n\n')
    52:         for file_path in _iter_files(root_path):
    53:             rel_path = file_path.relative_to(root_path)
    54:             if file_path == output_path:
    55:                 continue
    56:             mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
    57:             dump.write(f"## {rel_path} (last modified: {mod_time})\n")
    58:             try:
    59:                 with file_path.open('r', encoding='utf-8') as f:
    60:                     for i, line in enumerate(f, 1):
    61:                         dump.write(f"{i:6}: {line}")
    62:             except Exception:
    63:                 dump.write('[unreadable file]\n')
    64:             dump.write('\n\n')
    65: 
    66: 
    67: if __name__ == '__main__':
    68:     create_dump_file()


## exchange/fees.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/exchange/fees.py
     2: from __future__ import annotations
     3: from typing import Dict, Any, List, Tuple
     4: 
     5: async def load_bitget_fees(exchange, symbols: List[str]) -> Dict[str, Dict[str, float]]:
     6:     """
     7:     Retourne un dict {symbol: {"maker_bps": float, "taker_bps": float}}
     8:     en se basant sur les marchés de l'exchange (ex: CCXT bitget).
     9:     - exchange.load_markets() doit remplir exchange.markets[symbol]["maker"/"taker"] (décimaux).
    10:     - Si l'exchange expose fetch_trading_fee(s), on tente aussi.
    11:     """
    12:     # 1) charge les marchés (public fees — peut différer de tes fees utilisateur)
    13:     try:
    14:         if hasattr(exchange, "load_markets"):
    15:             await exchange.load_markets()
    16:     except Exception:
    17:         pass
    18: 
    19:     fees: Dict[str, Dict[str, float]] = {}
    20:     # 2) essaie par marché
    21:     for sym in symbols:
    22:         maker = None; taker = None
    23:         m = None
    24:         try:
    25:             m = exchange.markets.get(sym) if hasattr(exchange, "markets") else None
    26:         except Exception:
    27:             m = None
    28:         if m:
    29:             maker = m.get("maker")
    30:             taker = m.get("taker")
    31: 
    32:         # 3) fallback : fetch_trading_fee (si dispo)
    33:         if (maker is None or taker is None) and hasattr(exchange, "fetch_trading_fee"):
    34:             try:
    35:                 tf = await exchange.fetch_trading_fee(sym)
    36:                 maker = tf.get("maker", maker)
    37:                 taker = tf.get("taker", taker)
    38:             except Exception:
    39:                 pass
    40: 
    41:         # 4) fallback global : fetch_trading_fees
    42:         if (maker is None or taker is None) and hasattr(exchange, "fetch_trading_fees"):
    43:             try:
    44:                 tfs = await exchange.fetch_trading_fees()
    45:                 tf = tfs.get(sym, {})
    46:                 maker = tf.get("maker", maker)
    47:                 taker = tf.get("taker", taker)
    48:             except Exception:
    49:                 pass
    50: 
    51:         # 5) si rien trouvé, on garde 0 (évite de sur-estimer perf)
    52:         maker_bps = float(maker * 10000.0) if isinstance(maker, (int, float)) else 0.0
    53:         taker_bps = float(taker * 10000.0) if isinstance(taker, (int, float)) else 0.0
    54:         fees[sym] = {"maker_bps": maker_bps, "taker_bps": taker_bps}
    55:     return fees

## init.py (last modified: 2025-08-23 09:47:18)
     1: #!/usr/bin/env python3
     2: """Install all project dependencies.
     3: 
     4: Run this script once to install every ``requirements*.txt`` file found in the
     5: repository as well as the packages needed for the test suite.  All subsequent
     6: invocations of the bot or its submodules will then share the same Python
     7: environment with the required dependencies available.
     8: """
     9: 
    10: from __future__ import annotations
    11: 
    12: import subprocess
    13: import sys
    14: from pathlib import Path
    15: 
    16: 
    17: def install_packages(*args: str) -> None:
    18:     """Install packages using pip for the current Python interpreter."""
    19:     cmd = [sys.executable, "-m", "pip", "install", *args]
    20:     subprocess.check_call(cmd)
    21: 
    22: 
    23: def main() -> None:
    24:     repo_root = Path(__file__).resolve().parent
    25: 
    26:     # Install from any requirements*.txt file across the repository so that
    27:     # sub-packages with their own dependency lists are also covered.
    28:     for req in sorted(repo_root.rglob("requirements*.txt")):
    29:         install_packages("-r", str(req))
    30: 
    31:     # Ensure test dependencies are available
    32:     install_packages("pytest")
    33: 
    34: 
    35: if __name__ == "__main__":
    36:     main()


## live/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Live trading helpers."""
     2: 
     3: from .orchestrator import Orchestrator, run_orchestrator
     4: 
     5: __all__ = ["Orchestrator", "run_orchestrator"]


## live/commands.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/commands.py
     2: from __future__ import annotations
     3: import time
     4: from typing import Callable, Dict, List, Optional
     5: 
     6: from .setup_wizard import SetupWizard
     7: from ..signals.factory import load_signal
     8: from ..backtest.cli import fetch_ohlcv_sync  # à brancher
     9: 
    10: class CommandHandler:
    11:     """
    12:     Ne gère que la logique des commandes (stateless au max).
    13:     """
    14:     def __init__(self, notifier, command_stream, status_getter: Callable[[], Dict], status_sender: Callable[[str], None]):
    15:         self.notifier = notifier
    16:         self.command_stream = command_stream
    17:         self._status_getter = status_getter
    18:         self._status_sender = status_sender
    19: 
    20:     async def run(self, on_pause: Callable[[], None], on_resume: Callable[[], None],
    21:                   on_stop: Callable[[], None], on_setup_apply: Callable[[Dict], None]):
    22:         if self.notifier:
    23:             await self.notifier.send("Commandes: /setup /status /pause /resume /stop")
    24:         async for text in self.command_stream:
    25:             cmd = (text or "").strip().lower()
    26:             if cmd == "/status":
    27:                 await self._status()
    28:             elif cmd == "/pause":
    29:                 on_pause(); await self.notifier.send("⏸️ Paused")
    30:             elif cmd == "/resume":
    31:                 on_resume(); await self.notifier.send("▶️ Running")
    32:             elif cmd == "/stop":
    33:                 await self.notifier.send("🛑 Stop demandé"); on_stop(); return
    34:             elif cmd == "/setup":
    35:                 await self._setup(on_setup_apply)
    36:             else:
    37:                 await self.notifier.send("Commande inconnue. Utilise /setup /status /pause /resume /stop")
    38: 
    39:     async def _status(self):
    40:         s = self._status_getter()
    41:         lines = [
    42:             f"mode={s['mode']} timeframe={s['timeframe']}",
    43:             f"symbols={','.join(s['symbols']) or '(aucun)'}",
    44:             f"ticks_total={s['ticks_total']} heartbeat_age_ms={s['hb_age_ms']}",
    45:         ]
    46:         await self.notifier.send("\n".join(lines))
    47: 
    48:     async def _setup(self, on_apply: Callable[[Dict], None]):
    49:         s = self._status_getter()
    50:         default_syms = s["symbols"] or ["BTCUSDT","ETHUSDT","SOLUSDT","XRPUSDT"]
    51:         default_tfs = ["5m","15m","1h","4h"]
    52:         wiz = SetupWizard(self.notifier, self.command_stream, fetch_ohlcv_sync, out_dir="out_bt_setup")
    53:         res = await wiz.run(default_syms, default_tfs, default_strategy=s["strategy"])
    54:         if res.accepted:
    55:             cfg = {"strategy": res.strategy, "symbols": res.symbols, "timeframes": res.timeframes, "risk_pct": res.risk_pct}
    56:             on_apply(cfg)
    57:             await self.notifier.send("✅ Configuration appliquée. Démarrage du trading (RUNNING).")
    58:         else:
    59:             await self.notifier.send("ℹ️ Setup annulé. Reste en PRELAUNCH.")

## live/journal.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: import os, csv
     3: from typing import Any, Dict, List
     4: 
     5: class LogWriter:
     6:     """Gestion simple des CSV (création à la volée + append)."""
     7:     def __init__(self, dirpath: str) -> None:
     8:         self.dir = dirpath
     9:         os.makedirs(self.dir, exist_ok=True)
    10: 
    11:     def init(self, fname: str, headers: List[str]) -> None:
    12:         p = os.path.join(self.dir, fname)
    13:         if not os.path.exists(p):
    14:             with open(p, "w", newline="", encoding="utf-8") as f:
    15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
    16: 
    17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
    18:         p = os.path.join(self.dir, fname)
    19:         with open(p, "a", newline="", encoding="utf-8") as f:
    20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)

## live/logs.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/logs.py
     2: from __future__ import annotations
     3: import os, csv
     4: from typing import Any, List, Dict
     5: 
     6: class CsvLog:
     7:     def __init__(self, path: str, headers: List[str]):
     8:         self.path = path
     9:         self.headers = headers
    10:         self._ensure_header()
    11: 
    12:     def _ensure_header(self):
    13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
    14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
    15:         if must_write:
    16:             with open(self.path, "w", newline="") as f:
    17:                 csv.writer(f).writerow(self.headers)
    18: 
    19:     def write_row(self, row: Dict[str, Any]):
    20:         with open(self.path, "a", newline="") as f:
    21:             w = csv.DictWriter(f, fieldnames=self.headers)
    22:             w.writerow({k: row.get(k, "") for k in self.headers})

## live/loops/trade.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/loops/trade.py
     2: from __future__ import annotations
     3: import asyncio, os
     4: from dataclasses import dataclass, field
     5: from typing import Any, Dict, List, Callable
     6: 
     7: from ...services.utils import safe_call
     8: from ...risk.manager import compute_size
     9: 
    10: QUIET = int(os.getenv("QUIET", "0") or "0")
    11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
    12: 
    13: class PositionFSM:
    14:     def __init__(self):
    15:         self.state = "FLAT"
    16:         self.side = "flat"
    17:         self.entry = 0.0
    18:         self.qty = 0.0
    19:     def can_open(self): return self.state == "FLAT"
    20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
    21:     def can_close(self): return self.state == "OPEN"
    22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
    23: 
    24: @dataclass
    25: class SymbolContext:
    26:     symbol: str
    27:     timeframe: str
    28:     ohlcv: List[List[float]] = field(default_factory=list)
    29:     ticks: int = 0
    30:     fsm: PositionFSM = field(default_factory=PositionFSM)
    31: 
    32: class TradeLoop:
    33:     """
    34:     Boucle par symbole, indépendante de l'orchestrateur.
    35:     """
    36:     def __init__(
    37:         self,
    38:         symbol: str,
    39:         timeframe: str,
    40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
    41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
    42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
    43:         config: Dict[str, Any],
    44:         mode_getter: Callable[[], str],
    45:         log_signals, log_orders, log_fills,
    46:         tick_counter_add: Callable[[int], None],
    47:     ):
    48:         self.symbol = symbol
    49:         self.timeframe = timeframe
    50:         self.fetch = ohlcv_fetch
    51:         self.order_market = order_market
    52:         self.generate_signal = generate_signal
    53:         self.config = config
    54:         self.get_mode = mode_getter
    55:         self.log_signals = log_signals
    56:         self.log_orders = log_orders
    57:         self.log_fills = log_fills
    58:         self.ctx = SymbolContext(symbol, timeframe)
    59:         self._tick_add = tick_counter_add
    60: 
    61:         # Risk/frais
    62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
    63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
    64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
    65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
    66: 
    67:     def _bps_for(self, order_type: str = "market") -> float:
    68:         # market -> taker; limit post-only -> maker
    69:         per = self.fees_map.get(self.symbol, {})
    70:         if order_type == "limit":
    71:             return float(per.get("maker_bps", 0.0))
    72:         return float(per.get("taker_bps", 0.0))
    73: 
    74:     async def run(self, running: Callable[[], bool]):
    75:         lookback = 200
    76:         while running():
    77:             if self.get_mode() != "RUNNING":
    78:                 await asyncio.sleep(0.5); continue
    79: 
    80:             async def _fetch():
    81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
    82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
    83:             if not ohlcv or len(ohlcv) < lookback+1:
    84:                 await asyncio.sleep(1.0); continue
    85: 
    86:             self.ctx.ohlcv = ohlcv
    87:             self.ctx.ticks += 1
    88:             self._tick_add(1)
    89: 
    90:             window = ohlcv[-(lookback+1):]
    91:             ts, _o, _h, _l, c, _v = window[-1]
    92: 
    93:             try:
    94:                 sig = self.generate_signal(window, self.config) or {}
    95:             except Exception as e:
    96:                 if not QUIET:
    97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
    98:                 await asyncio.sleep(0.5); continue
    99: 
   100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
   101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
   102: 
   103:             # --- Entrée (market -> taker)
   104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
   105:                 balance = float(self.config.get("cash", 10_000.0))
   106:                 qty = compute_size(
   107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
   108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
   109:                 )
   110:                 if qty > 0:
   111:                     async def _place():
   112:                         return await self.order_market(self.symbol, side, qty)
   113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
   114:                     self.ctx.fsm.on_open(side, entry or c, qty)
   115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
   116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
   117: 
   118:             # --- Sortie (market -> taker)
   119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
   120:                 qty = self.ctx.fsm.qty
   121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
   122:                 async def _close():
   123:                     return await self.order_market(self.symbol, exit_side, qty)
   124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
   125: 
   126:                 # fill avec slippage + frais (taker)
   127:                 price_fill = float(c)
   128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
   129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
   130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
   131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
   132:                                           "order_id": (order or {}).get("id","")})
   133:                 self.ctx.fsm.on_close()
   134: 
   135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
   136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
   137: 
   138:             await asyncio.sleep(0.1 if QUIET else 0.01)

## live/notify.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/notify.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import os
     6: from dataclasses import dataclass
     7: from typing import AsyncIterator, Callable, Optional, List, Union
     8: 
     9: # ---------------------------------------------------------------------
    10: # Config & utilitaires
    11: # ---------------------------------------------------------------------
    12: 
    13: QUIET = int(os.getenv("QUIET", "0") or "0")
    14: 
    15: def _log(msg: str) -> None:
    16:     if not QUIET:
    17:         print(f"[notify] {msg}", flush=True)
    18: 
    19: # ---------------------------------------------------------------------
    20: # Modèle de message de commande (transport-agnostic)
    21: # ---------------------------------------------------------------------
    22: 
    23: @dataclass
    24: class CommandMessage:
    25:     text: str
    26:     chat_id: Optional[int] = None
    27:     user: Optional[str] = None
    28:     ts: Optional[int] = None  # epoch ms
    29: 
    30: # ---------------------------------------------------------------------
    31: # Interface Notifier
    32: # ---------------------------------------------------------------------
    33: 
    34: class Notifier:
    35:     """Interface de notification + menus (fallback texte)."""
    36: 
    37:     async def start(self) -> None:  # pragma: no cover (interface)
    38:         raise NotImplementedError
    39: 
    40:     async def stop(self) -> None:  # pragma: no cover (interface)
    41:         raise NotImplementedError
    42: 
    43:     async def send(self, text: str) -> None:  # pragma: no cover (interface)
    44:         raise NotImplementedError
    45: 
    46:     async def send_menu(self, text: str, options: List[str]) -> None:
    47:         """
    48:         Envoie un menu. Fallback: simple liste numérotée.
    49:         Si ton backend Telegram gère un clavier, surcharge dans TelegramNotifier.
    50:         """
    51:         opts = "\n".join(f"{i+1}) {o}" for i, o in enumerate(options))
    52:         await self.send(f"{text}\n{opts}\nRéponds par le numéro ou la valeur exacte.")
    53: 
    54: # ---------------------------------------------------------------------
    55: # NullNotifier (no-op)
    56: # ---------------------------------------------------------------------
    57: 
    58: class NullNotifier(Notifier):
    59:     def __init__(self) -> None:
    60:         self._started = False
    61: 
    62:     async def start(self) -> None:
    63:         self._started = True
    64:         _log("NullNotifier started")
    65: 
    66:     async def stop(self) -> None:
    67:         self._started = False
    68:         _log("NullNotifier stopped")
    69: 
    70:     async def send(self, text: str) -> None:
    71:         _log(f"NULL >> {text}")
    72: 
    73: # ---------------------------------------------------------------------
    74: # CommandStream (basé sur une queue alimentée par le backend)
    75: # ---------------------------------------------------------------------
    76: 
    77: class CommandStream:
    78:     """
    79:     Flux asynchrone de CommandMessage. Le backend (TelegramNotifier) y pousse
    80:     les messages reçus, on les consomme via: `async for msg in stream: ...`
    81:     """
    82: 
    83:     def __init__(self, allowed_chat_id: Optional[int] = None) -> None:
    84:         self._q: asyncio.Queue[CommandMessage] = asyncio.Queue()
    85:         self._allowed_chat_id = allowed_chat_id
    86:         self._closed = False
    87: 
    88:     def push(self, msg: CommandMessage) -> None:
    89:         # Filtre optionnel par chat_id
    90:         if self._allowed_chat_id is not None and msg.chat_id is not None:
    91:             if msg.chat_id != self._allowed_chat_id:
    92:                 return
    93:         # Normalise le texte
    94:         msg.text = (msg.text or "").strip()
    95:         if msg.text == "":
    96:             return
    97:         self._q.put_nowait(msg)
    98: 
    99:     async def close(self) -> None:
   100:         self._closed = True
   101:         # Injecte un message spécial pour débloquer les consommateurs
   102:         await self._q.put(CommandMessage(text="__STREAM_CLOSED__"))
   103: 
   104:     def __aiter__(self) -> AsyncIterator[Union[str, CommandMessage]]:
   105:         return self._iter()
   106: 
   107:     async def _iter(self) -> AsyncIterator[Union[str, CommandMessage]]:
   108:         while not self._closed:
   109:             msg = await self._q.get()
   110:             if msg.text == "__STREAM_CLOSED__":
   111:                 break
   112:             # Par compatibilité: retourner .text (chaîne) si le consommateur ne veut que le texte
   113:             yield msg.text if isinstance(msg, CommandMessage) else msg
   114: 
   115: # ---------------------------------------------------------------------
   116: # TelegramNotifier
   117: # ---------------------------------------------------------------------
   118: 
   119: class TelegramNotifier(Notifier):
   120:     """
   121:     Notifier Telegram découplé.
   122:     - Utilise une implémentation 'TelegramAsync' fournie par ton projet.
   123:     - Construit un CommandStream et y pousse les messages entrants.
   124:     - Filtre par TELEGRAM_CHAT_ID si fourni.
   125:     """
   126: 
   127:     def __init__(
   128:         self,
   129:         token: Optional[str] = None,
   130:         chat_id: Optional[int] = None,
   131:         telegram_factory: Optional[Callable[..., object]] = None,
   132:     ) -> None:
   133:         """
   134:         Args:
   135:             token: BOT token (env TELEGRAM_BOT_TOKEN si None)
   136:             chat_id: chat id cible (env TELEGRAM_CHAT_ID si None). Si fourni, filtre les commandes entrantes.
   137:             telegram_factory: callable retournant une instance compatible avec:
   138:                 - await tg.start()
   139:                 - await tg.stop()
   140:                 - await tg.send_message(text, chat_id=...)
   141:                 - tg.set_message_handler(callback)  # callback(chat_id:int, user:str|None, text:str, ts_ms:int)
   142:         """
   143:         self.token = token or os.getenv("TELEGRAM_BOT_TOKEN")
   144:         env_chat = os.getenv("TELEGRAM_CHAT_ID")
   145:         self.chat_id = chat_id if chat_id is not None else (int(env_chat) if env_chat else None)
   146:         self.telegram_factory = telegram_factory or _default_telegram_factory
   147: 
   148:         if not self.token:
   149:             raise RuntimeError("TelegramNotifier: TELEGRAM_BOT_TOKEN manquant")
   150: 
   151:         self._tg = None  # type: ignore
   152:         self._started = False
   153:         self._stream = CommandStream(allowed_chat_id=self.chat_id)
   154: 
   155:     @property
   156:     def command_stream(self) -> CommandStream:
   157:         return self._stream
   158: 
   159:     async def start(self) -> None:
   160:         if self._started:
   161:             return
   162:         self._tg = self.telegram_factory(self.token)
   163:         if not hasattr(self._tg, "set_message_handler"):
   164:             raise RuntimeError("Telegram backend invalide: set_message_handler manquant")
   165: 
   166:         # Enregistre le callback pour alimenter le CommandStream
   167:         def _on_message(chat_id: int, user: Optional[str], text: str, ts_ms: int) -> None:
   168:             self._stream.push(CommandMessage(text=text, chat_id=chat_id, user=user, ts=ts_ms))
   169: 
   170:         self._tg.set_message_handler(_on_message)
   171:         await self._tg.start()
   172:         self._started = True
   173:         _log("TelegramNotifier started")
   174: 
   175:         # Message d’accueil
   176:         try:
   177:             await self.send("🤖 Bot prêt. Commandes: /setup /status /pause /resume /stop")
   178:         except Exception:
   179:             pass
   180: 
   181:     async def stop(self) -> None:
   182:         if not self._started:
   183:             return
   184:         try:
   185:             await self._stream.close()
   186:         except Exception:
   187:             pass
   188:         try:
   189:             if self._tg:
   190:                 await self._tg.stop()
   191:         finally:
   192:             self._started = False
   193:             _log("TelegramNotifier stopped")
   194: 
   195:     async def send(self, text: str) -> None:
   196:         if not self._started or not self._tg:
   197:             raise RuntimeError("TelegramNotifier non démarré")
   198:         # Si chat_id paramétré, on cible; sinon le backend peut avoir un défaut (ex: dernier chat)
   199:         await self._tg.send_message(text, chat_id=self.chat_id)
   200: 
   201:     async def send_menu(self, text: str, options: List[str]) -> None:
   202:         """
   203:         Essaie d’envoyer un clavier; sinon fallback numéroté.
   204:         On considère que le backend peut offrir send_message(..., reply_markup=...)
   205:         """
   206:         if not self._started or not self._tg:
   207:             raise RuntimeError("TelegramNotifier non démarré")
   208: 
   209:         keyboard_supported = hasattr(self._tg, "send_message")
   210:         reply_markup = None
   211:         # Tentative de clavier simple si le backend l'accepte (liste verticale)
   212:         try:
   213:             reply_markup = {"keyboard": [[o] for o in options], "resize_keyboard": True, "one_time_keyboard": True}
   214:             await self._tg.send_message(text, chat_id=self.chat_id, reply_markup=reply_markup)
   215:         except Exception:
   216:             # Fallback texte
   217:             opts = "\n".join(f"{i+1}) {o}" for i, o in enumerate(options))
   218:             await self._tg.send_message(f"{text}\n{opts}\nRéponds par le numéro ou la valeur exacte.", chat_id=self.chat_id)
   219: 
   220: # ---------------------------------------------------------------------
   221: # Backend Telegram par défaut (factory)
   222: # ---------------------------------------------------------------------
   223: 
   224: def _default_telegram_factory(token: str):
   225:     """
   226:     Essaie d’importer une implémentation TelegramAsync spécifique au repo.
   227:     On attend une API min :
   228:       - await tg.start()
   229:       - await tg.stop()
   230:       - await tg.send_message(text, chat_id=..., reply_markup: dict|None = None)
   231:       - tg.set_message_handler(cb)
   232:     """
   233:     # Essais de chemins courants dans le projet
   234:     candidates = (
   235:         # ex: scalp/live/telegram_async.py
   236:         ("scalp.live.telegram_async", "TelegramAsync"),
   237:         ("scalp.integrations.telegram_async", "TelegramAsync"),
   238:         ("telegram_async", "TelegramAsync"),
   239:     )
   240:     last_err = None
   241:     for mod_name, cls_name in candidates:
   242:         try:
   243:             mod = __import__(mod_name, fromlist=[cls_name])
   244:             cls = getattr(mod, cls_name)
   245:             return cls(token)
   246:         except Exception as e:
   247:             last_err = e
   248:             continue
   249:     # Si rien n’est dispo, on lève une erreur claire
   250:     raise RuntimeError(
   251:         "Aucune implémentation TelegramAsync trouvée. "
   252:         "Assure-toi d’avoir un module 'TelegramAsync' compatible (ex: scalp/live/telegram_async.py). "
   253:         f"Dernière erreur: {last_err!r}"
   254:     )
   255: 
   256: # ---------------------------------------------------------------------
   257: # Helper pour créer rapidement un Notifier+Stream depuis l’orchestrateur
   258: # ---------------------------------------------------------------------
   259: 
   260: async def build_notifier_and_stream() -> tuple[Notifier, CommandStream]:
   261:     """
   262:     Construit un TelegramNotifier si variables d’env sont présentes,
   263:     sinon retourne un NullNotifier. Renvoie aussi son CommandStream.
   264:     """
   265:     token = os.getenv("TELEGRAM_BOT_TOKEN")
   266:     chat = os.getenv("TELEGRAM_CHAT_ID")
   267:     if token:
   268:         tn = TelegramNotifier(token=token, chat_id=int(chat) if chat else None)
   269:         await tn.start()
   270:         return tn, tn.command_stream
   271:     else:
   272:         nn = NullNotifier()
   273:         await nn.start()
   274:         # CommandStream indépendant (aucune source n’y pousse par défaut)
   275:         cs = CommandStream()
   276:         return nn, cs

## live/ohlcv_service.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: import time
     3: from typing import Any, Dict, List, Optional
     4: 
     5: try:
     6:     from scalp.adapters.market_data import MarketData
     7: except Exception:
     8:     MarketData = None  # type: ignore
     9: 
    10: class OhlcvService:
    11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
    12:     def __init__(self, exchange) -> None:
    13:         self.exchange = exchange
    14:         self.md = MarketData(exchange) if MarketData is not None else None
    15: 
    16:     @staticmethod
    17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
    18:         out: List[Dict[str, float]] = []
    19:         if not rows: return out
    20:         for r in rows:
    21:             if isinstance(r, dict):
    22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
    23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
    24:                 v = float(r.get("volume", r.get("vol", 0.0)))
    25:             else:
    26:                 rr = list(r)
    27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
    28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
    29:                 else:
    30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
    31:                     h = float(rr[1]) if len(rr) > 1 else o
    32:                     l = float(rr[2]) if len(rr) > 2 else o
    33:                     c = float(rr[3]) if len(rr) > 3 else o
    34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
    35:                     ts = int(rr[5]) if len(rr) > 5 else 0
    36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
    37:         return out
    38: 
    39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
    40:         # 1) MarketData (si dispo)
    41:         if self.md is not None:
    42:             try:
    43:                 d = self.md.get_ohlcv(symbol, interval, limit)
    44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
    45:                     return self.normalize_rows(d["data"])
    46:             except Exception:
    47:                 pass
    48: 
    49:         # 2) Exchange natif
    50:         rows: List[Any] = []
    51:         try:
    52:             data = self.exchange.get_kline(symbol, interval=interval)
    53:         except Exception:
    54:             data = None
    55: 
    56:         if isinstance(data, dict):
    57:             rows = (
    58:                 data.get("data") or data.get("result") or data.get("records") or
    59:                 data.get("list") or data.get("items") or data.get("candles") or []
    60:             )
    61:             guard = 0
    62:             while isinstance(rows, dict) and guard < 3:
    63:                 rows = (
    64:                     rows.get("data") or rows.get("result") or rows.get("records") or
    65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
    66:                 )
    67:                 guard += 1
    68:         elif isinstance(data, (list, tuple)):
    69:             rows = list(data)
    70: 
    71:         out = self.normalize_rows(rows)[-limit:]
    72:         if out: return out
    73: 
    74:         # 3) Fallback strict via ticker -> bougie synthétique
    75:         try:
    76:             tkr = self.exchange.get_ticker(symbol)
    77:             items = []
    78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
    79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
    80:             if items:
    81:                 last = items[0]
    82:                 if isinstance(last, dict):
    83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
    84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
    85:                 else:
    86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
    87:                 ts = int(time.time()*1000)
    88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
    89:         except Exception:
    90:             pass
    91:         return []

## live/orchestrator.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/orchestrator.py
     2: from __future__ import annotations
     3: import asyncio, os, time, signal
     4: from typing import Any, Dict, List, Optional
     5: 
     6: from ..services.utils import heartbeat_task, log_stats_task
     7: from .notify import Notifier, CommandStream, build_notifier_and_stream
     8: from .watchlist import WatchlistManager
     9: from .loops.trade import TradeLoop
    10: from .commands import CommandHandler
    11: from .logs import CsvLog
    12: from ..signals.factory import load_signal
    13: from ..exchange.fees import load_bitget_fees
    14: 
    15: QUIET = int(os.getenv("QUIET", "0") or "0")
    16: LOG_DIR = os.path.join(os.path.dirname(__file__), "logs")
    17: os.makedirs(LOG_DIR, exist_ok=True)
    18: 
    19: # ---------------- Services simples (wrappers vers l'exchange) ----------------
    20: class OhlcvService:
    21:     def __init__(self, exchange): self.exchange = exchange
    22:     async def fetch_once(self, symbol, timeframe="5m", limit=150):
    23:         # Doit renvoyer [[ts,o,h,l,c,v], ...]
    24:         return await self.exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    25: 
    26: class OrderService:
    27:     def __init__(self, exchange): self.exchange = exchange
    28:     async def market(self, symbol, side, qty):
    29:         # Renvoie {id, status, ...} selon ton client exchange
    30:         return await self.exchange.create_order(symbol, "market", side, qty)
    31: 
    32: # ---------------- Orchestrator (maigre) ----------------
    33: class Orchestrator:
    34:     def __init__(self, exchange, config: Dict[str, Any], symbols: Optional[List[str]] = None,
    35:                  notifier: Optional[Notifier] = None, command_stream: Optional[CommandStream] = None):
    36:         self.exchange = exchange
    37:         self.config = dict(config)  # ex: {"timeframe":"5m","cash":10000, ...}
    38:         self._running = True
    39: 
    40:         # État d’exécution
    41:         self.mode = "PRELAUNCH"  # PRELAUNCH | RUNNING | PAUSED | STOPPING
    42:         self.selected = {
    43:             "strategy": "current",
    44:             "symbols": symbols or [],
    45:             "timeframes": [self.config.get("timeframe", "5m")],
    46:             "risk_pct": float(self.config.get("risk_pct", 0.5)),
    47:         }
    48:         # Defaults Risk/Frais/Slippage/Caps
    49:         self.config.setdefault("risk_pct", self.selected["risk_pct"])
    50:         self.config.setdefault("slippage_bps", float(os.getenv("SLIPPAGE_BPS", "0") or "0"))
    51:         self.config.setdefault("caps", {})                 # {"BTCUSDT": {"min_qty":..., "min_notional":...}}
    52:         self.config.setdefault("fees_by_symbol", {})      # rempli au boot via Bitget
    53: 
    54:         # Notifier / commandes
    55:         self.notifier = notifier
    56:         self.command_stream = command_stream
    57: 
    58:         # Services
    59:         self.ohlcv = OhlcvService(exchange)
    60:         self.order = OrderService(exchange)
    61: 
    62:         # Stratégie
    63:         self.generate_signal = load_signal(self.selected["strategy"])
    64: 
    65:         # Watchlist
    66:         self.watchlist = WatchlistManager(
    67:             watchlist_mode=os.getenv("WATCHLIST_MODE","static"),
    68:             top_candidates=os.getenv("TOP_CANDIDATES",""),
    69:             local_conc=int(os.getenv("WATCHLIST_LOCAL_CONC","4") or "4"),
    70:             ohlcv_fetch=self.ohlcv.fetch_once,
    71:         )
    72: 
    73:         # Symboles actifs
    74:         self.timeframe = self.selected["timeframes"][0]
    75:         self.symbols = list(self.selected["symbols"])
    76: 
    77:         # Stats
    78:         self._ticks_total = 0
    79:         self._last_heartbeat_ms = int(time.time()*1000)
    80: 
    81:         # Logs CSV
    82:         self.log_signals = CsvLog(os.path.join(LOG_DIR,"signals.csv"),   ["ts","symbol","side","entry","sl","tp","last"])
    83:         self.log_orders  = CsvLog(os.path.join(LOG_DIR,"orders.csv"),    ["ts","symbol","side","qty","status","order_id","note"])
    84:         self.log_fills   = CsvLog(os.path.join(LOG_DIR,"fills.csv"),     ["ts","symbol","side","price","qty","order_id"])
    85:         self.log_pos     = CsvLog(os.path.join(LOG_DIR,"positions.csv"), ["ts","symbol","state","side","entry","qty"])
    86:         self.log_wl      = CsvLog(os.path.join(LOG_DIR,"watchlist.csv"), ["ts","mode","symbols"])
    87: 
    88:     # ---------------- Helpers état ----------------
    89:     def get_running(self) -> bool: return self._running
    90:     def get_mode(self) -> str: return self.mode
    91:     def _add_ticks(self, n: int):
    92:         self._ticks_total += n
    93:         self._last_heartbeat_ms = int(time.time()*1000)
    94: 
    95:     async def stop(self, reason: str=""):
    96:         self._running = False
    97:         self.mode = "STOPPING"
    98:         if self.notifier:
    99:             try: await self.notifier.send(f"🛑 Arrêt orchestrateur. {reason}")
   100:             except: pass
   101: 
   102:     # ---------------- Watchlist / Fees / Positions ----------------
   103:     async def _watchlist_boot(self):
   104:         top = await self.watchlist.boot_topN()
   105:         now = int(time.time()*1000)
   106:         self.log_wl.write_row({"ts": now, "mode": self.watchlist.mode, "symbols": ",".join(top)})
   107:         if not self.symbols:
   108:             self.symbols = top
   109: 
   110:     async def _watchlist_refresh(self):
   111:         async for top in self.watchlist.task_auto_refresh():
   112:             now = int(time.time()*1000)
   113:             self.log_wl.write_row({"ts": now, "mode": self.watchlist.mode, "symbols": ",".join(top)})
   114: 
   115:     async def _refresh_fees(self):
   116:         """Charge les frais Bitget (maker/taker) par symbole et pousse dans config['fees_by_symbol']."""
   117:         if not self.symbols:
   118:             return
   119:         try:
   120:             fees = await load_bitget_fees(self.exchange, self.symbols)
   121:             self.config["fees_by_symbol"] = fees
   122:             if self.notifier:
   123:                 txt = ", ".join(f"{s}:{int(f['taker_bps'])}bps" for s,f in fees.items())
   124:                 await self.notifier.send("ℹ️ Frais Bitget (taker) chargés: " + (txt or "(aucun)"))
   125:         except Exception as e:
   126:             if self.notifier:
   127:                 await self.notifier.send(f"⚠️ Impossible de charger les frais Bitget: {e}. Utilisation 0 bps par défaut.")
   128: 
   129:     async def _positions_sync(self):
   130:         while self.get_running():
   131:             now = int(time.time()*1000)
   132:             # Placeholder : rapprochement réel à brancher
   133:             for s in self.symbols:
   134:                 self.log_pos.write_row({"ts": now, "symbol": s, "state": "N/A", "side": "N/A", "entry": "", "qty": ""})
   135:             await asyncio.sleep(10.0 if QUIET else 3.0)
   136: 
   137:     # ---------------- Commandes ----------------
   138:     def _status_snapshot(self) -> Dict[str, Any]:
   139:         return {
   140:             "mode": self.mode,
   141:             "timeframe": self.timeframe,
   142:             "symbols": list(self.symbols),
   143:             "ticks_total": self._ticks_total,
   144:             "hb_age_ms": int(time.time()*1000) - self._last_heartbeat_ms,
   145:             "strategy": self.selected["strategy"],
   146:         }
   147: 
   148:     def _apply_setup_cfg(self, cfg: Dict):
   149:         """
   150:         Appelé quand l'utilisateur 'ACCEPTE' depuis le wizard:
   151:         - met à jour stratégie, symboles, timeframe, risk_pct
   152:         - re-charge les frais
   153:         - bascule en RUNNING
   154:         """
   155:         self.selected.update(cfg)
   156:         self.config["risk_pct"] = float(cfg.get("risk_pct", self.config["risk_pct"]))
   157:         self.generate_signal = load_signal(cfg["strategy"])
   158:         self.symbols = list(cfg["symbols"])
   159:         self.timeframe = cfg["timeframes"][0]
   160:         self.mode = "RUNNING"
   161: 
   162:     # ---------------- Run ----------------
   163:     async def run(self):
   164:         # Notifier/commandes auto si non fournis
   165:         if not self.notifier or not self.command_stream:
   166:             self.notifier, self.command_stream = await build_notifier_and_stream()
   167: 
   168:         # Signaux OS
   169:         loop = asyncio.get_running_loop()
   170:         for sig in (signal.SIGINT, signal.SIGTERM):
   171:             try:
   172:                 loop.add_signal_handler(sig, lambda s=sig: asyncio.create_task(self.stop(f"os:{s.name}")))
   173:             except NotImplementedError:
   174:                 pass
   175: 
   176:         # Boot + frais
   177:         await self._watchlist_boot()
   178:         await self._refresh_fees()
   179: 
   180:         if self.notifier:
   181:             await self.notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup pour valider avant trading.")
   182: 
   183:         tasks: List[asyncio.Task] = []
   184: 
   185:         # Heartbeat & stats (respectent QUIET)
   186:         tasks += [
   187:             asyncio.create_task(heartbeat_task(self.get_running, period=15.0)),
   188:             asyncio.create_task(log_stats_task(self.get_running, lambda: self._ticks_total, lambda: self.symbols, period=30.0)),
   189:         ]
   190: 
   191:         # Watchlist / Positions
   192:         tasks += [
   193:             asyncio.create_task(self._watchlist_refresh()),
   194:             asyncio.create_task(self._positions_sync()),
   195:         ]
   196: 
   197:         # Commandes (wizard + pause/resume/stop/status)
   198:         cmd = CommandHandler(
   199:             notifier=self.notifier, command_stream=self.command_stream,
   200:             status_getter=self._status_snapshot, status_sender=lambda s: None,
   201:         )
   202:         tasks.append(asyncio.create_task(cmd.run(
   203:             on_pause=lambda: setattr(self, "mode", "PAUSED"),
   204:             on_resume=lambda: setattr(self, "mode", "RUNNING"),
   205:             on_stop=lambda: asyncio.create_task(self.stop("telegram:/stop")),
   206:             on_setup_apply=self._apply_setup_cfg
   207:         )))
   208: 
   209:         # Boucles trade par symbole (spawn + respawn si modifs)
   210:         trade_tasks: Dict[str, asyncio.Task] = {}
   211: 
   212:         async def spawn_loops():
   213:             for s in list(self.symbols):
   214:                 if s in trade_tasks and not trade_tasks[s].done():
   215:                     continue
   216:                 loop_obj = TradeLoop(
   217:                     symbol=s,
   218:                     timeframe=self.timeframe,
   219:                     ohlcv_fetch=self.ohlcv.fetch_once,
   220:                     order_market=self.order.market,
   221:                     generate_signal=self.generate_signal,
   222:                     config=self.config,                         # contient risk_pct, caps, slippage_bps, fees_by_symbol
   223:                     mode_getter=self.get_mode,
   224:                     log_signals=self.log_signals,
   225:                     log_orders=self.log_orders,
   226:                     log_fills=self.log_fills,
   227:                     tick_counter_add=self._add_ticks,
   228:                 )
   229:                 trade_tasks[s] = asyncio.create_task(loop_obj.run(self.get_running))
   230: 
   231:         await spawn_loops()
   232: 
   233:         async def supervisor():
   234:             """
   235:             Surveille changements (symbols/timeframe/strategy) et respawn les boucles.
   236:             Recharge aussi les frais si la liste de symboles change.
   237:             """
   238:             prev_sig = (tuple(self.symbols), self.timeframe, self.generate_signal.__name__)
   239:             while self.get_running():
   240:                 cur_sig = (tuple(self.symbols), self.timeframe, self.generate_signal.__name__)
   241:                 if cur_sig != prev_sig:
   242:                     # (Re)charge frais si symboles changés
   243:                     if cur_sig[0] != prev_sig[0]:
   244:                         await self._refresh_fees()
   245:                     # Respawn boucles
   246:                     for t in trade_tasks.values():
   247:                         t.cancel()
   248:                     trade_tasks.clear()
   249:                     await spawn_loops()
   250:                     prev_sig = cur_sig
   251:                 await asyncio.sleep(2.0)
   252: 
   253:         tasks.append(asyncio.create_task(supervisor()))
   254: 
   255:         try:
   256:             await asyncio.gather(*tasks)
   257:         finally:
   258:             if self.notifier:
   259:                 try: await self.notifier.send("🔴 Orchestrator stopped.")
   260:                 except: pass
   261: 
   262: # Entrée pratique (utilisée par bot.py)
   263: async def run_orchestrator(exchange, config: Dict[str, Any], symbols: Optional[List[str]] = None,
   264:                            notifier: Optional[Notifier] = None, command_stream: Optional[CommandStream] = None):
   265:     orch = Orchestrator(exchange, config, symbols, notifier, command_stream)
   266:     await orch.run()

## live/orders.py (last modified: 2025-08-23 09:47:18)
     1: # live/orders.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Any, Optional
     5: 
     6: from scalp.services.order_service import OrderService, OrderRequest
     7: 
     8: @dataclass
     9: class OrderResult:
    10:     accepted: bool
    11:     order_id: str | None = None
    12:     status: str | None = None
    13:     reason: str | None = None
    14: 
    15: class OrderExecutor:
    16:     """
    17:     Fine couche autour d'OrderService + exchange :
    18:       - calcule l'équité USDT
    19:       - place une entrée (risk_pct)
    20:       - récupère les fills (normalisés)
    21:     L'orchestrateur n’appelle plus OrderService directement.
    22:     """
    23: 
    24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
    25:         self.order_service = order_service
    26:         self.exchange = exchange
    27:         self.config = config
    28: 
    29:     # ---------- Equity ----------
    30:     def get_equity_usdt(self) -> float:
    31:         equity = 0.0
    32:         try:
    33:             assets = self.exchange.get_assets()
    34:             if isinstance(assets, dict):
    35:                 for a in (assets.get("data") or []):
    36:                     if str(a.get("currency")).upper() == "USDT":
    37:                         equity = float(a.get("equity", 0.0))
    38:                         break
    39:         except Exception:
    40:             pass
    41:         return equity
    42: 
    43:     # ---------- Entrée ----------
    44:     def place_entry(self, *, symbol: str, side: str, price: float,
    45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
    46:         """
    47:         side: 'long' | 'short'
    48:         Retourne OrderResult(accepted, order_id, status, reason)
    49:         """
    50:         equity = self.get_equity_usdt()
    51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
    52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
    53:                            risk_pct=float(risk_pct))
    54:         try:
    55:             res = self.order_service.prepare_and_place(equity, req)
    56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
    57:                                order_id=getattr(res, "order_id", None),
    58:                                status=getattr(res, "status", None),
    59:                                reason=getattr(res, "reason", None))
    60:         except Exception as e:
    61:             return OrderResult(accepted=False, reason=str(e))
    62: 
    63:     # ---------- Fills ----------
    64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
    65:         """
    66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
    67:         """
    68:         try:
    69:             raw = self.exchange.get_fills(symbol, order_id, limit)
    70:         except Exception:
    71:             return []
    72: 
    73:         items: list = []
    74:         if isinstance(raw, dict):
    75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
    76:         elif isinstance(raw, (list, tuple)):
    77:             items = list(raw)
    78: 
    79:         out: list[dict] = []
    80:         for f in items:
    81:             if isinstance(f, dict):
    82:                 out.append({
    83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
    84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
    85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
    86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
    87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
    88:                 })
    89:             else:
    90:                 try:
    91:                     seq = list(f)
    92:                     out.append({
    93:                         "orderId": str(seq[0]) if seq else "",
    94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
    95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
    96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
    97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
    98:                     })
    99:                 except Exception:
   100:                     continue
   101:         return out

## live/position_fsm.py (last modified: 2025-08-23 09:47:18)
     1: # live/position_fsm.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any, List
     5: 
     6: 
     7: STATE_FLAT = "FLAT"
     8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
     9: STATE_OPEN = "OPEN"
    10: STATE_PENDING_EXIT = "PENDING_EXIT"
    11: 
    12: 
    13: @dataclass
    14: class PositionState:
    15:     symbol: str
    16:     state: str = STATE_FLAT
    17:     order_id: Optional[str] = None
    18:     side: Optional[str] = None   # "long" | "short"
    19:     qty: float = 0.0
    20:     entry: float = 0.0
    21: 
    22: 
    23: class PositionFSM:
    24:     """
    25:     FSM ultra-simple par symbole.
    26:     - set_pending_entry(order_id, side)
    27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
    28:     """
    29: 
    30:     def __init__(self, symbols: List[str]) -> None:
    31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
    32: 
    33:     # -------- API utilisateur --------
    34:     def ensure_symbol(self, symbol: str) -> None:
    35:         if symbol not in self._by_symbol:
    36:             self._by_symbol[symbol] = PositionState(symbol)
    37: 
    38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
    39:         self.ensure_symbol(symbol)
    40:         st = self._by_symbol[symbol]
    41:         st.state = STATE_PENDING_ENTRY
    42:         st.order_id = order_id
    43:         st.side = side
    44: 
    45:     def mark_pending_exit(self, symbol: str) -> None:
    46:         self.ensure_symbol(symbol)
    47:         st = self._by_symbol[symbol]
    48:         st.state = STATE_PENDING_EXIT
    49: 
    50:     def force_flat(self, symbol: str) -> None:
    51:         self._by_symbol[symbol] = PositionState(symbol)
    52: 
    53:     # -------- Lecture --------
    54:     def get(self, symbol: str) -> PositionState:
    55:         self.ensure_symbol(symbol)
    56:         return self._by_symbol[symbol]
    57: 
    58:     def all(self) -> Dict[str, PositionState]:
    59:         return self._by_symbol
    60: 
    61:     # -------- Réconciliation --------
    62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
    63:         """
    64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
    65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
    66:         """
    67:         # indexer positions ouvertes
    68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
    69: 
    70:         for sym, st in self._by_symbol.items():
    71:             p = idx_open.get(sym)
    72: 
    73:             if st.state == STATE_PENDING_ENTRY:
    74:                 # si on voit des fills de l'ordre en attente -> OPEN
    75:                 f_list = fills.get(sym) or []
    76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
    77:                 if qty_filled > 0.0 or p:
    78:                     st.state = STATE_OPEN
    79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
    80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
    81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
    82:             elif st.state == STATE_OPEN:
    83:                 # si plus de position ouverte -> FLAT
    84:                 if not p:
    85:                     st.state = STATE_FLAT
    86:                     st.order_id = None
    87:                     st.side = None
    88:                     st.qty = 0.0
    89:                     st.entry = 0.0
    90:                 else:
    91:                     st.qty = float(p.get("qty", st.qty))
    92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
    93:             elif st.state == STATE_PENDING_EXIT:
    94:                 # si plus de position -> FLAT ; sinon reste OPEN
    95:                 if not p:
    96:                     st.state = STATE_FLAT
    97:                     st.order_id = None
    98:                     st.side = None
    99:                     st.qty = 0.0
   100:                     st.entry = 0.0
   101:                 else:
   102:                     st.state = STATE_OPEN  # pas encore clos
   103:             else:
   104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
   105:                 if p:
   106:                     st.state = STATE_OPEN
   107:                     st.qty = float(p.get("qty", 0.0))
   108:                     st.entry = float(p.get("avgEntryPrice", 0.0))

## live/setup_wizard.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: import asyncio, os
     3: from dataclasses import dataclass
     4: from typing import List, Dict, Optional, Callable
     5: from ..signals.factory import load_signal
     6: from ..backtest.runner import BacktestRunner
     7: from .notify import Notifier, CommandStream
     8: 
     9: @dataclass
    10: class SetupResult:
    11:     strategy: str
    12:     symbols: List[str]
    13:     timeframes: List[str]
    14:     risk_pct: float
    15:     accepted: bool
    16:     summary_path: str
    17: 
    18: class SetupWizard:
    19:     """
    20:     Wizard interactif Telegram avant lancement des trades.
    21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
    22:     """
    23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
    24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
    25:                  admin_chat_id: Optional[int]=None):
    26:         self.notifier = notifier
    27:         self.cmd_stream = cmd_stream
    28:         self.loader = ohlcv_loader_sync
    29:         self.out_dir = out_dir
    30:         self.admin_chat_id = admin_chat_id
    31: 
    32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
    33:         await self.notifier.send_menu(prompt, choices)
    34:         async for msg in self.cmd_stream:
    35:             txt = msg.strip()
    36:             if allow_multi and ("," in txt or " " in txt):
    37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
    38:                 return sel
    39:             if txt.isdigit():
    40:                 i = int(txt)-1
    41:                 if 0 <= i < len(choices):
    42:                     return [choices[i]]
    43:             if txt in choices:
    44:                 return [txt]
    45:             await self.notifier.send("Entrée invalide. Réessaie.")
    46: 
    47:     async def _ask_value(self, prompt: str, cast: Callable, default):
    48:         await self.notifier.send(f"{prompt} (défaut: {default})")
    49:         async for msg in self.cmd_stream:
    50:             txt = msg.strip()
    51:             if txt == "" or txt.lower() in ("d","defaut","default"):
    52:                 return default
    53:             try:
    54:                 return cast(txt)
    55:             except Exception:
    56:                 await self.notifier.send("Entrée invalide. Réessaie.")
    57: 
    58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
    59:                   default_strategy: str="current") -> SetupResult:
    60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
    61:         # 1) stratégie
    62:         strategies = ["current","ema_cross","vwap_break"]
    63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
    64: 
    65:         # 2) symboles
    66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
    67: 
    68:         # 3) timeframes
    69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
    70: 
    71:         # 4) risk %
    72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
    73: 
    74:         # 5) période backtest
    75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
    76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
    77: 
    78:         # 6) run backtest
    79:         from ..backtest.cli import parse_ts
    80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
    81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
    82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
    83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
    84: 
    85:         # 7) résumé
    86:         sum_path = os.path.join(self.out_dir, "metrics.json")
    87:         prop = res["proposal"]
    88:         lines = ["**Proposition** :"]
    89:         for sym, best in prop["per_symbol_best"].items():
    90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
    91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
    92: 
    93:         # 8) décision
    94:         async for msg in self.cmd_stream:
    95:             t = msg.strip().lower()
    96:             if t in ("accepter","accept","ok","go","start"):
    97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
    98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
    99:             if t in ("modifier","again","repeat"):
   100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
   101:             if t in ("annuler","cancel","stop"):
   102:                 await self.notifier.send("❌ Annulé.")
   103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)

## live/state_store.py (last modified: 2025-08-23 09:47:18)
     1: # live/state_store.py
     2: from __future__ import annotations
     3: import json, os, time, asyncio
     4: from typing import Callable, Dict, Any
     5: 
     6: class StateStore:
     7:     """
     8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
     9:     - save_state(snapshot: dict) -> écrit sur disque
    10:     - load_state() -> dict
    11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
    12:     """
    13: 
    14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
    15:         self.filepath = filepath
    16:         self.period_s = period_s
    17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
    18:         self._running = False
    19: 
    20:     # -------- I/O --------
    21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
    22:         tmp = self.filepath + ".tmp"
    23:         with open(tmp, "w", encoding="utf-8") as f:
    24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
    25:         os.replace(tmp, self.filepath)
    26: 
    27:     def load_state(self) -> Dict[str, Any]:
    28:         if not os.path.exists(self.filepath):
    29:             return {}
    30:         try:
    31:             with open(self.filepath, "r", encoding="utf-8") as f:
    32:                 return json.load(f)
    33:         except Exception:
    34:             return {}
    35: 
    36:     # -------- Autosave --------
    37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
    38:         self._running = True
    39:         while self._running:
    40:             try:
    41:                 snap = get_snapshot()
    42:                 snap["saved_at"] = int(time.time() * 1000)
    43:                 self.save_state(snap)
    44:             except Exception:
    45:                 pass
    46:             await asyncio.sleep(self.period_s)
    47: 
    48:     def stop(self): self._running = False

## live/telegram_async.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: import time
     3: import requests
     4: import asyncio
     5: from typing import Optional, Dict, Any, List
     6: 
     7: 
     8: class TelegramAsync:
     9:     """
    10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
    11:     Sans nouvelle dépendance.
    12:     """
    13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
    14:         self.token = token
    15:         self.chat_id = chat_id
    16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
    17:         self._offset = 0
    18:         self._enabled = bool(token and chat_id)
    19: 
    20:     def enabled(self) -> bool:
    21:         return self._enabled
    22: 
    23:     # ---------- sync I/O (appelées via to_thread) ----------
    24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
    25:         if not self._enabled:
    26:             return {"ok": False, "reason": "disabled"}
    27:         url = f"{self.base}/sendMessage"
    28:         payload = {"chat_id": self.chat_id, "text": text}
    29:         try:
    30:             r = requests.post(url, json=payload, timeout=10)
    31:             return r.json()
    32:         except Exception as e:
    33:             return {"ok": False, "error": repr(e)}
    34: 
    35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
    36:         if not self._enabled:
    37:             return {"ok": True, "result": []}
    38:         url = f"{self.base}/getUpdates"
    39:         params = {"timeout": timeout_s, "offset": self._offset}
    40:         try:
    41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
    42:             return r.json()
    43:         except Exception as e:
    44:             return {"ok": False, "error": repr(e), "result": []}
    45: 
    46:     # ---------- async wrappers ----------
    47:     async def send_message(self, text: str) -> None:
    48:         await asyncio.to_thread(self._send_message_sync, text)
    49: 
    50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
    51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
    52:         if not data.get("ok"):
    53:             return []
    54:         out = []
    55:         for upd in data.get("result", []):
    56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
    57:             msg = upd.get("message") or {}
    58:             text = (msg.get("text") or "").strip()
    59:             if not text:
    60:                 continue
    61:             out.append({
    62:                 "date": msg.get("date"),
    63:                 "chat": str((msg.get("chat") or {}).get("id")),
    64:                 "text": text,
    65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
    66:             })
    67:         return out


## live/watchlist.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/live/watchlist.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import os
     6: from typing import Any, Callable, Awaitable, List, Optional, Sequence, Tuple
     7: 
     8: DBG = os.getenv("WATCHLIST_DEBUG", "0") == "1"
     9: def _dprint(msg: str):
    10:     if DBG:
    11:         print(f"[watchlist:debug] {msg}")
    12: 
    13: 
    14: class WatchlistManager:
    15:     """
    16:     Génération de watchlist TOP N :
    17:       - mode='local'  : calcule TOPN via OHLCV (volume quote ~ 24h)
    18:       - mode='api'    : utilise un endpoint bulk (si disponible)
    19:       - mode='static' : valeurs fixes (TOP_SYMBOLS ou défaut)
    20:     """
    21: 
    22:     def __init__(
    23:         self,
    24:         exchange,
    25:         *,
    26:         only_suffix: str = "USDT",
    27:         top_n: int = 10,
    28:         period_s: float = 120.0,
    29:         on_update: Optional[Callable[[Sequence[str]], None]] = None,
    30:         safe_call: Optional[Callable[[Callable[[], Any], str], Any]] = None,
    31:         ohlcv_fetch: Optional[Callable[[str, str, int], Awaitable[List[Any]]]] = None,
    32:     ) -> None:
    33:         self.exchange = exchange
    34:         self.only_suffix = only_suffix.upper() if only_suffix else ""
    35:         self.top_n = top_n
    36:         self.period_s = period_s
    37:         self.on_update = on_update
    38:         self._safe = safe_call or (lambda f, _label: f())
    39:         self._running = False
    40:         self._ohlcv_fetch = ohlcv_fetch
    41:         self.mode = (os.getenv("WATCHLIST_MODE") or "static").lower()  # static | api | local
    42: 
    43:     # ---------- extraction API générique ----------
    44:     @staticmethod
    45:     def _extract_items(payload: Any) -> List[Any]:
    46:         if payload is None:
    47:             return []
    48:         if isinstance(payload, dict):
    49:             for k in ("data", "result", "tickers", "items", "list", "tickerList", "records"):
    50:                 v = payload.get(k)
    51:                 if isinstance(v, list):
    52:                     return v
    53:                 if isinstance(v, dict):
    54:                     # un niveau de plus
    55:                     for kk in ("data", "result", "tickers", "items", "list", "tickerList", "records"):
    56:                         vv = v.get(kk)
    57:                         if isinstance(vv, list):
    58:                             return vv
    59:             return []
    60:         if isinstance(payload, (list, tuple)):
    61:             return list(payload)
    62:         return []
    63: 
    64:     @staticmethod
    65:     def _norm_symbol_and_volume(item: Any) -> Tuple[str, float]:
    66:         if isinstance(item, dict):
    67:             s = (item.get("symbol") or item.get("instId") or "").replace("_", "").upper()
    68:             vol = item.get("volume", item.get("usdtVolume", item.get("quoteVolume", 0.0)))
    69:             try:
    70:                 v = float(vol or 0.0)
    71:             except Exception:
    72:                 v = 0.0
    73:             return s, v
    74:         try:
    75:             seq = list(item)
    76:             s = str(seq[0]).replace("_", "").upper() if seq else ""
    77:             v = float(seq[1]) if len(seq) > 1 else 0.0
    78:             return s, v
    79:         except Exception:
    80:             return "", 0.0
    81: 
    82:     def _pick_top(self, payload: Any) -> List[str]:
    83:         items = self._extract_items(payload)
    84:         pairs: List[Tuple[str, float]] = []
    85:         for it in items:
    86:             s, v = self._norm_symbol_and_volume(it)
    87:             if not s:
    88:                 continue
    89:             if self.only_suffix and not s.endswith(self.only_suffix):
    90:                 continue
    91:             pairs.append((s, v))
    92:         pairs.sort(key=lambda x: x[1], reverse=True)
    93:         return [s for s, _ in pairs[: self.top_n]]
    94: 
    95:     # ---------- TOPN local via OHLCV ----------
    96:     async def _build_top_local(self) -> List[str]:
    97:         if not self._ohlcv_fetch:
    98:             return []
    99:         # candidates : env ou liste par défaut (~40 liquides)
   100:         raw = (os.getenv("TOP_CANDIDATES") or "")
   101:         if raw:
   102:             candidates = [s.strip().upper().replace("_", "") for s in raw.split(",") if s.strip()]
   103:         else:
   104:             candidates = [
   105:                 "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","DOGEUSDT","ADAUSDT","TRXUSDT","TONUSDT","LTCUSDT",
   106:                 "LINKUSDT","ARBUSDT","OPUSDT","APTUSDT","SUIUSDT","PEPEUSDT","AVAXUSDT","DOTUSDT","MATICUSDT","ATOMUSDT",
   107:                 "NEARUSDT","SEIUSDT","RUNEUSDT","TIAUSDT","WIFUSDT","JUPUSDT","ICPUSDT","FILUSDT","ETCUSDT","BCHUSDT",
   108:                 "XLMUSDT","HBARUSDT","EOSUSDT","TRBUSDT","AAVEUSDT","UNIUSDT","FLOWUSDT","RNDRUSDT","ORDIUSDT","SEIUSDT",
   109:             ]
   110:         sem = asyncio.Semaphore(int(os.getenv("WATCHLIST_LOCAL_CONC", "5")))
   111: 
   112:         async def score(sym: str) -> Tuple[str, float]:
   113:             async with sem:
   114:                 try:
   115:                     rows = await self._ohlcv_fetch(sym, "1m", 1440)
   116:                     tot = 0.0
   117:                     for r in rows or []:
   118:                         if isinstance(r, dict):
   119:                             tot += float(r.get("close", 0.0)) * float(r.get("volume", 0.0))
   120:                         else:
   121:                             tot += float(r[4]) * float(r[5])  # [.., close, volume]
   122:                     return sym, tot
   123:                 except Exception:
   124:                     return sym, 0.0
   125: 
   126:         scores = await asyncio.gather(*(score(s) for s in candidates))
   127:         scores.sort(key=lambda x: x[1], reverse=True)
   128:         top = [s for s, v in scores if s.endswith(self.only_suffix)][: self.top_n]
   129:         if DBG:
   130:             _dprint(f"local scores top={top[:5]}")
   131:         return top
   132: 
   133:     # ---------- public ----------
   134:     async def boot_topN(self) -> List[str]:
   135:         # 1) local (réel) si demandé
   136:         if self.mode == "local":
   137:             try:
   138:                 top = await self._build_top_local()
   139:                 if top:
   140:                     if self.on_update: self.on_update(top)
   141:                     return top
   142:             except Exception as e:
   143:                 _dprint(f"local mode error: {e!r}")
   144: 
   145:         # 2) api (si un bulk existe un jour)
   146:         if self.mode in ("api", "local"):
   147:             try:
   148:                 payload = await self._safe(lambda: self.exchange.get_ticker(None), "get_ticker(None)")
   149:                 _dprint(f"payload via get_ticker(None): type={type(payload).__name__}")
   150:                 top = self._pick_top(payload)
   151:                 if top:
   152:                     if self.on_update: self.on_update(top)
   153:                     return top
   154:             except Exception as e:
   155:                 _dprint(f"api mode error: {e!r}")
   156: 
   157:         # 3) fallback statique
   158:         env_syms = (os.getenv("TOP_SYMBOLS") or "").replace(" ", "")
   159:         top = [s for s in env_syms.split(",") if s] if env_syms else \
   160:               ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","DOGEUSDT","ADAUSDT","TRXUSDT","TONUSDT","LTCUSDT"]
   161:         top = [s.replace("_", "").upper() for s in top][: self.top_n]
   162:         if DBG:
   163:             _dprint(f"using static TOP{len(top)} = {top}")
   164:         if self.on_update: self.on_update(top)
   165:         return top
   166: 
   167:     async def task_auto_refresh(self):
   168:         self._running = True
   169:         while self._running:
   170:             try:
   171:                 top = await self.boot_topN()
   172:                 _dprint(f"refresh -> {top}")
   173:             except Exception as e:
   174:                 print(f"[watchlist] refresh error: {e!r}")
   175:             await asyncio.sleep(self.period_s)
   176: 
   177:     def stop(self):
   178:         self._running = False

## notebooks/spot/bitget_bot.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import time
     3: import hmac
     4: import hashlib
     5: import base64
     6: import logging
     7: from argparse import ArgumentParser
     8: from pathlib import Path
     9: from typing import Any, Dict, List
    10: from urllib.parse import urlencode
    11: 
    12: import requests
    13: from dotenv import load_dotenv
    14: 
    15: BASE_URL = "https://api.bitget.com"
    16: RECV_WINDOW = 5000
    17: 
    18: 
    19: def load_keys() -> Dict[str, str]:
    20:     parent = Path(__file__).resolve().parent.parent
    21:     load_dotenv(parent / ".env")
    22:     api_key = os.getenv("BITGET_API_KEY")
    23:     api_secret = os.getenv("BITGET_API_SECRET")
    24:     if not api_key or not api_secret:
    25:         raise RuntimeError("API keys not found in environment")
    26:     return {"key": api_key, "secret": api_secret}
    27: 
    28: 
    29: class BitgetClient:
    30:     def __init__(self) -> None:
    31:         creds = load_keys()
    32:         self.api_key = creds["key"]
    33:         self.api_secret = creds["secret"]
    34:         self.session = requests.Session()
    35:         self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
    36:         self.time_offset = self._compute_time_offset()
    37: 
    38:     def _compute_time_offset(self) -> int:
    39:         server = self.server_time()
    40:         return int(server["serverTime"]) - int(time.time() * 1000)
    41: 
    42:     def _timestamp(self) -> int:
    43:         return int(time.time() * 1000) + self.time_offset
    44: 
    45:     def _request(
    46:         self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
    47:     ) -> Any:
    48:         params = params or {}
    49:         if signed:
    50:             params["timestamp"] = self._timestamp()
    51:             params["recvWindow"] = RECV_WINDOW
    52:             query = urlencode(params)
    53:             signature = base64.b64encode(
    54:                 hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
    55:             ).decode()
    56:             query += f"&signature={signature}"
    57:             headers = {"X-BITGET-APIKEY": self.api_key}
    58:             if method.upper() == "GET":
    59:                 url = f"{BASE_URL}{path}?{query}"
    60:                 resp = self.session.get(url, headers=headers)
    61:             else:
    62:                 url = f"{BASE_URL}{path}"
    63:                 headers["Content-Type"] = "application/x-www-form-urlencoded"
    64:                 resp = self.session.post(url, data=query, headers=headers)
    65:         else:
    66:             url = f"{BASE_URL}{path}"
    67:             resp = self.session.request(method, url, params=params)
    68: 
    69:         resp.raise_for_status()
    70:         if resp.text:
    71:             return resp.json()
    72:         return {}
    73: 
    74:     # Helpers
    75:     def server_time(self) -> Any:
    76:         return self._request("GET", "/api/v3/time")
    77: 
    78:     def ticker_price(self, symbol: str) -> Any:
    79:         return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})
    80: 
    81:     def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
    82:         return self._request(
    83:             "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
    84:         )
    85: 
    86:     def test_order(self, **params: Any) -> Any:
    87:         return self._request("POST", "/api/v3/order/test", params, signed=True)
    88: 
    89:     def place_order(self, **params: Any) -> Any:
    90:         return self._request("POST", "/api/v3/order", params, signed=True)
    91: 
    92:     def account_info(self) -> Any:
    93:         return self._request("GET", "/api/v3/account", signed=True)
    94: 
    95:     def book_ticker(self, symbol: str) -> Any:
    96:         return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})
    97: 
    98: 
    99: def sma(values: List[float], period: int) -> float:
   100:     if len(values) < period:
   101:         raise ValueError("Not enough data for SMA")
   102:     return sum(values[-period:]) / period
   103: 
   104: 
   105: def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
   106:     kl = client.klines(symbol, limit=50)
   107:     closes = [float(k[4]) for k in kl]
   108:     sma9_prev = sma(closes[:-1], 9)
   109:     sma21_prev = sma(closes[:-1], 21)
   110:     sma9_curr = sma(closes, 9)
   111:     sma21_curr = sma(closes, 21)
   112: 
   113:     cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
   114:     cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr
   115: 
   116:     log = logging.getLogger("bitget_bot")
   117: 
   118:     if cross_up:
   119:         book = client.book_ticker(symbol)
   120:         ask = float(book["askPrice"])
   121:         qty = quote_usdt / ask
   122:         params = {
   123:             "symbol": symbol,
   124:             "side": "BUY",
   125:             "type": "LIMIT",
   126:             "timeInForce": "IOC",
   127:             "quantity": f"{qty:.6f}",
   128:             "price": book["askPrice"],
   129:         }
   130:         log.info("BUY signal %s", params)
   131:         resp = client.test_order(**params) if dry_run else client.place_order(**params)
   132:         log.info("response %s", resp)
   133:     elif cross_down:
   134:         account = client.account_info()
   135:         base = symbol.rstrip("USDT")
   136:         bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
   137:         qty = float(bal["free"])
   138:         if qty > 0:
   139:             book = client.book_ticker(symbol)
   140:             params = {
   141:                 "symbol": symbol,
   142:                 "side": "SELL",
   143:                 "type": "LIMIT",
   144:                 "timeInForce": "IOC",
   145:                 "quantity": f"{qty:.6f}",
   146:                 "price": book["bidPrice"],
   147:             }
   148:             log.info("SELL signal %s", params)
   149:             resp = client.test_order(**params) if dry_run else client.place_order(**params)
   150:             log.info("response %s", resp)
   151:         else:
   152:             log.info("No balance to sell")
   153: 
   154: 
   155: def interval_seconds(interval: str) -> int:
   156:     unit = interval[-1]
   157:     qty = int(interval[:-1])
   158:     if unit == "m":
   159:         return qty * 60
   160:     if unit == "h":
   161:         return qty * 3600
   162:     if unit == "d":
   163:         return qty * 86400
   164:     return 60
   165: 
   166: 
   167: def main() -> None:
   168:     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
   169:     parser = ArgumentParser(description="Bitget SMA crossover bot")
   170:     parser.add_argument("--symbol", default="BTCUSDT")
   171:     parser.add_argument("--quote-usdt", type=float, default=10.0)
   172:     parser.add_argument("--interval", default="1m")
   173:     parser.add_argument("--loop", action="store_true")
   174:     parser.add_argument("--dry-run", dest="dry_run", action="store_true")
   175:     parser.add_argument("--live", dest="dry_run", action="store_false")
   176:     parser.set_defaults(dry_run=True)
   177:     args = parser.parse_args()
   178: 
   179:     client = BitgetClient()
   180:     delay = interval_seconds(args.interval)
   181: 
   182:     while True:
   183:         try:
   184:             analyze(client, args.symbol, args.quote_usdt, args.dry_run)
   185:         except Exception as exc:
   186:             logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
   187:         if not args.loop:
   188:             break
   189:         time.sleep(delay)
   190: 
   191: 
   192: if __name__ == "__main__":
   193:     main()


## pytest.ini (last modified: 2025-08-23 09:47:18)
     1: [pytest]
     2: addopts = -q


## quick_order.py (last modified: 2025-08-23 09:47:18)
     1: #!/usr/bin/env python3
     2: """Submit a simple market order on Bitget futures.
     3: 
     4: This helper reads API credentials and trade parameters from environment
     5: variables (optionally loaded from a `.env` file) and places a one-way
     6: market order.  Only the essential steps from the user's reference script
     7: are kept to minimise latency and redundant code.
     8: 
     9: Environment variables:
    10:     BITGET_API_KEY / BITGET_ACCESS_KEY
    11:     BITGET_API_SECRET / BITGET_SECRET_KEY
    12:     BITGET_API_PASSPHRASE
    13:     BITGET_BASE_URL (default https://api.bitget.com)
    14:     BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
    15:     BITGET_MARGIN_COIN (default ``USDT``)
    16:     BITGET_SYMBOL (e.g. ``BTCUSDT``)
    17:     BITGET_TEST_NOTIONAL_USDT (default ``5``)
    18: 
    19: Usage:
    20:     python quick_order.py buy
    21:     python quick_order.py sell
    22: """
    23: 
    24: from __future__ import annotations
    25: 
    26: import os
    27: import sys
    28: from pathlib import Path
    29: 
    30: from dotenv import load_dotenv
    31: 
    32: from scalp.bitget_client import BitgetFuturesClient
    33: 
    34: # Load variables from `.env` if present
    35: load_dotenv(Path(__file__).resolve().parent / ".env")
    36: 
    37: side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
    38: if side not in {"buy", "sell"}:
    39:     raise SystemExit("Usage: quick_order.py [buy|sell]")
    40: 
    41: base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
    42: ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
    43: sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
    44: ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
    45: product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
    46: margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
    47: symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
    48: notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))
    49: 
    50: if not (ak and sk and ph):
    51:     raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")
    52: 
    53: client = BitgetFuturesClient(
    54:     access_key=ak,
    55:     secret_key=sk,
    56:     base_url=base,
    57:     passphrase=ph,
    58:     paper_trade=False,
    59: )
    60: 
    61: tick = client.get_ticker(symbol)
    62: price = None
    63: try:
    64:     data = tick.get("data")
    65:     if isinstance(data, list) and data:
    66:         price_str = data[0].get("lastPr") or data[0].get("lastPrice")
    67:         if price_str is not None:
    68:             price = float(price_str)
    69:     elif isinstance(data, dict):
    70:         price_str = data.get("lastPr") or data.get("lastPrice")
    71:         if price_str is not None:
    72:             price = float(price_str)
    73: except Exception:
    74:     pass
    75: if price is None or price <= 0:
    76:     raise SystemExit("Prix introuvable pour le ticker")
    77: 
    78: size = round(notional / price, 6)
    79: client.set_position_mode_one_way(symbol, product_type)
    80: client.set_leverage(symbol, product_type, margin_coin, leverage=2)
    81: resp = client.place_market_order_one_way(
    82:     symbol, side, size, product_type, margin_coin
    83: )
    84: print(resp)


## requirements-dev.txt (last modified: 2025-08-23 09:47:18)
     1: pytest


## requirements.txt (last modified: 2025-08-23 09:47:18)
     1: requests
     2: python-dotenv
     3: pydantic==1.10.15 ; python_version < "3.11"
     4: 
     5: # pydantic v1 déjà pin si environnement ancien
     6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)


## run_backtest.py (last modified: 2025-08-23 09:47:18)
     1: #!/usr/bin/env python3
     2: import os
     3: from scalp.backtest.engine import BacktestEngine
     4: 
     5: def main():
     6:     print("[*] Lancement du backtest...")
     7:     
     8:     # ⚡ Tu pourras changer ces paramètres
     9:     pairs = ["BTCUSDT", "ETHUSDT"]  # pour commencer simple
    10:     start_date = "2024-01-01"
    11:     end_date = "2024-02-01"
    12: 
    13:     # Dossier résultat
    14:     result_dir = os.path.join(os.path.dirname(__file__), "result")
    15:     os.makedirs(result_dir, exist_ok=True)
    16: 
    17:     # Création du moteur
    18:     engine = BacktestEngine(
    19:         pairs=pairs,
    20:         start_date=start_date,
    21:         end_date=end_date,
    22:         result_dir=result_dir
    23:     )
    24: 
    25:     # Lancer le backtest
    26:     engine.run()
    27: 
    28:     print("[✅] Backtest terminé ! Résultats disponibles dans /result/")
    29: 
    30: if __name__ == "__main__":
    31:     main()

## scalp/VERSION (last modified: 2025-08-23 09:47:18)
     1: 0.3.0
     2: 


## scalp/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities and helpers for Scalp bot.
     2: 
     3: When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
     4: keys to live in ``notebook/.env``.  On import this module attempts to load the
     5: variables from that file so that API keys can remain outside of the repository
     6: yet still be available at runtime.
     7: """
     8: 
     9: from __future__ import annotations
    10: 
    11: import os
    12: from pathlib import Path
    13: import sys
    14: 
    15: 
    16: def _load_parent_env() -> None:
    17:     """Load environment variables from ``../.env`` relative to the entry script.
    18: 
    19:     The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
    20:     are expected to be stored one directory above (``notebook/.env``).  If that
    21:     file is not found the function falls back to the historical behaviour of
    22:     checking ``../.env`` relative to the package itself.
    23:     """
    24: 
    25:     script_path = Path(sys.argv[0]).resolve()
    26:     env_file = script_path.parent.parent / ".env"
    27:     if not env_file.exists():
    28:         env_file = Path(__file__).resolve().parents[2] / ".env"
    29:         if not env_file.exists():
    30:             return
    31: 
    32:     try:
    33:         from dotenv import load_dotenv
    34: 
    35:         load_dotenv(env_file)
    36:     except Exception:  # pragma: no cover - optional dependency
    37:         for line in env_file.read_text().splitlines():
    38:             line = line.strip()
    39:             if not line or line.startswith("#") or "=" not in line:
    40:                 continue
    41:             key, value = line.split("=", 1)
    42:             os.environ.setdefault(key.strip(), value.strip().strip("'\""))
    43: 
    44: 
    45: _load_parent_env()
    46: 
    47: from .version import get_version, bump_version_from_message  # noqa: E402
    48: from .strategy import (  # noqa: E402
    49:     Signal,
    50:     scan_pairs,
    51:     select_active_pairs,
    52:     generate_signal,
    53:     backtest,
    54: )
    55: from .risk.manager import RiskManager  # noqa: E402
    56: 
    57: __all__ = [
    58:     "get_version",
    59:     "bump_version_from_message",
    60:     "__version__",
    61:     "Signal",
    62:     "scan_pairs",
    63:     "select_active_pairs",
    64:     "generate_signal",
    65:     "RiskManager",
    66:     "backtest",
    67: ]
    68: 
    69: __version__ = get_version()


## scalp/adapters/__init__.py (last modified: 2025-08-23 09:47:18)


## scalp/adapters/bitget.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/adapters/bitget.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional
     4: import inspect, os
     5: import requests
     6: 
     7: # Client bas-niveau fourni par le repo
     8: from scalp.bitget_client import BitgetFuturesClient as _Base
     9: 
    10: 
    11: def _to_float(x, default: float = 0.0) -> float:
    12:     try:
    13:         return float(x)
    14:     except Exception:
    15:         return default
    16: 
    17: 
    18: def _select_base_url() -> str:
    19:     env = os.environ.get("BITGET_BASE_URL")
    20:     if env:
    21:         return env
    22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
    23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
    24: 
    25: 
    26: class BitgetFuturesClient(_Base):
    27:     """
    28:     Adaptateur Bitget:
    29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
    30:       - Normalisations robustes: assets, ticker(s), positions, fills
    31:     """
    32: 
    33:     # --------------------- INIT dynamique ---------------------
    34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
    35:         """
    36:         Accepte indifféremment:
    37:           api_key/apiKey/access_key/accessKey/key
    38:           api_secret/apiSecret/secret/secret_key/secretKey
    39:           passphrase/password/api_passphrase/apiPassphrase
    40:           base_url/baseUrl/host/endpoint (ou auto)
    41:         On n'envoie au client de base que les noms présents dans sa signature.
    42:         """
    43:         user_kwargs = dict(kwargs)
    44: 
    45:         # Collecte des valeurs possibles (tous alias)
    46:         incoming_key = (
    47:             user_kwargs.pop("api_key", None)
    48:             or user_kwargs.pop("apiKey", None)
    49:             or user_kwargs.pop("access_key", None)
    50:             or user_kwargs.pop("accessKey", None)
    51:             or user_kwargs.pop("key", None)
    52:             or user_kwargs.pop("API_KEY", None)
    53:         )
    54:         incoming_secret = (
    55:             user_kwargs.pop("api_secret", None)
    56:             or user_kwargs.pop("apiSecret", None)
    57:             or user_kwargs.pop("secret_key", None)
    58:             or user_kwargs.pop("secretKey", None)
    59:             or user_kwargs.pop("secret", None)
    60:             or user_kwargs.pop("API_SECRET", None)
    61:         )
    62:         incoming_pass = (
    63:             user_kwargs.pop("passphrase", None)
    64:             or user_kwargs.pop("password", None)
    65:             or user_kwargs.pop("api_passphrase", None)
    66:             or user_kwargs.pop("apiPassphrase", None)
    67:         )
    68:         incoming_base = (
    69:             user_kwargs.pop("base_url", None)
    70:             or user_kwargs.pop("baseUrl", None)
    71:             or user_kwargs.pop("host", None)
    72:             or user_kwargs.pop("endpoint", None)
    73:             or _select_base_url()
    74:         )
    75: 
    76:         # Signature réelle du client bas-niveau
    77:         sig = inspect.signature(_Base.__init__)
    78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
    79: 
    80:         def pick_name(cands: List[str]) -> Optional[str]:
    81:             for c in cands:
    82:                 if c in param_names:
    83:                     return c
    84:             return None
    85: 
    86:         # Noms réellement supportés
    87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
    88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
    89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
    90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
    91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
    92: 
    93:         # Construire kwargs à transmettre (une seule fois par nom)
    94:         base_kwargs: Dict[str, Any] = {}
    95:         if key_name and incoming_key is not None:
    96:             base_kwargs[key_name] = incoming_key
    97:         if sec_name and incoming_secret is not None:
    98:             base_kwargs[sec_name] = incoming_secret
    99:         if pas_name and incoming_pass is not None:
   100:             base_kwargs[pas_name] = incoming_pass
   101:         if base_name:
   102:             base_kwargs[base_name] = incoming_base
   103:         if req_mod_name:
   104:             base_kwargs[req_mod_name] = requests
   105: 
   106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
   107:         # qui n'a pas été défini ci-dessus, on le relaie.
   108:         for k, v in list(user_kwargs.items()):
   109:             if k in param_names and k not in base_kwargs:
   110:                 base_kwargs[k] = v
   111: 
   112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
   113:         super().__init__(**base_kwargs)
   114: 
   115:     # --------------------- COMPTES / ASSETS ---------------------
   116:     def get_assets(self) -> Dict[str, Any]:
   117:         raw = super().get_assets()
   118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
   119:         norm: List[Dict[str, Any]] = []
   120:         for a in data:
   121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
   122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
   123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
   124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
   125:         return {"success": True, "data": norm}
   126: 
   127:     # ------------------------ TICKER(S) -------------------------
   128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   129:         """
   130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
   131:         Tolère top-level dict/list et items dict/list.
   132:         """
   133:         try:
   134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
   135:         except Exception as e:
   136:             return {"success": False, "error": repr(e), "data": []}
   137: 
   138:         items: List[Any] = []
   139:         if isinstance(raw, dict):
   140:             d = raw.get("data")
   141:             if symbol and isinstance(d, dict):
   142:                 items = [d]
   143:             else:
   144:                 items = d or raw.get("result") or raw.get("tickers") or []
   145:         elif isinstance(raw, (list, tuple)):
   146:             items = list(raw)
   147: 
   148:         norm: List[Dict[str, Any]] = []
   149:         for t in items:
   150:             if isinstance(t, dict):
   151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
   152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
   153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
   154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
   155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
   156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
   157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
   158:                 norm.append({
   159:                     "symbol": s,
   160:                     "lastPrice": _to_float(last_),
   161:                     "bidPrice": _to_float(bid_),
   162:                     "askPrice": _to_float(ask_),
   163:                     "volume": volume
   164:                 })
   165:             else:
   166:                 seq = list(t)
   167:                 if len(seq) >= 5:
   168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
   169:                     if first_ts:
   170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
   171:                     else:
   172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
   173:                 else:
   174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
   175:                 s = (symbol or "").replace("_", "")
   176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
   177: 
   178:         return {"success": True, "data": norm}
   179: 
   180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
   181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
   183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
   184:         out: List[Dict[str, Any]] = []
   185:         for p in items:
   186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
   187:             if symbol and s != symbol:
   188:                 continue
   189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
   190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
   191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
   192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
   193:         return {"success": True, "data": out}
   194: 
   195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
   196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
   197:         items = raw.get("data") or raw.get("result") or []
   198:         out: List[Dict[str, Any]] = []
   199:         for f in items[:limit]:
   200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
   201:             if s != symbol:
   202:                 continue
   203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
   204:                 continue
   205:             out.append({
   206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
   207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
   208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
   209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
   210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
   211:                 "ts": int(f.get("ts", f.get("time", 0))),
   212:             })
   213:         return {"success": True, "data": out}
   214: 
   215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
   217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
   218:         return {"success": ok, "data": {"orderId": order_id}}

## scalp/adapters/market_data.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: from typing import List, Dict, Any
     3: 
     4: class MarketData:
     5:     """Adapter de données de marché normalisées."""
     6: 
     7:     def __init__(self, exchange: Any):
     8:         self.exchange = exchange
     9: 
    10:     def get_ohlcv(self, symbol: str, interval: str = "1m", limit: int = 100) -> Dict[str, List[Dict[str, float]]]:
    11:         """Retourne une liste normalisée de bougies OHLCV."""
    12:         try:
    13:             data = self.exchange.get_kline(symbol, interval=interval)
    14:         except Exception:
    15:             data = None
    16: 
    17:         rows: List[Any] = []
    18:         if data is not None:
    19:             if isinstance(data, dict):
    20:                 rows = (
    21:                     data.get("data")
    22:                     or data.get("result")
    23:                     or data.get("records")
    24:                     or data.get("list")
    25:                     or data.get("items")
    26:                     or data.get("candles")
    27:                     or []
    28:                 )
    29:                 depth_guard = 0
    30:                 while isinstance(rows, dict) and depth_guard < 3:
    31:                     rows = (
    32:                         rows.get("data")
    33:                         or rows.get("result")
    34:                         or rows.get("records")
    35:                         or rows.get("list")
    36:                         or rows.get("items")
    37:                         or rows.get("candles")
    38:                         or rows.get("klines")
    39:                         or rows.get("bars")
    40:                         or []
    41:                     )
    42:                     depth_guard += 1
    43:             elif isinstance(data, (list, tuple)):
    44:                 rows = list(data)
    45: 
    46:         seq = list(rows) if isinstance(rows, (list, tuple)) else []
    47:         out: List[Dict[str, float]] = []
    48:         for r in seq[-limit:]:
    49:             if isinstance(r, dict):
    50:                 t = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
    51:                 o = float(r.get("open", 0.0))
    52:                 h = float(r.get("high", o))
    53:                 l = float(r.get("low", o))
    54:                 c = float(r.get("close", o))
    55:                 v = float(r.get("volume", r.get("vol", 0.0)))
    56:             else:
    57:                 t = int(r[0]) if len(r) > 0 else 0
    58:                 o = float(r[1]) if len(r) > 1 else 0.0
    59:                 h = float(r[2]) if len(r) > 2 else o
    60:                 l = float(r[3]) if len(r) > 3 else o
    61:                 c = float(r[4]) if len(r) > 4 else o
    62:                 v = float(r[5]) if len(r) > 5 else 0.0
    63:             out.append({"ts": t, "open": o, "high": h, "low": l, "close": c, "volume": v})
    64:         return {"data": out}
    65: 
    66:     def get_ticker(self, symbol: str):
    67:         """Délègue à l'exchange le ticker non normalisé."""
    68:         return self.exchange.get_ticker(symbol)
    69:                        

## scalp/backtest/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Simple backtesting helpers."""
     2: from __future__ import annotations
     3: 
     4: from typing import Any, Dict, List, Optional
     5: 
     6: from scalp.bot_config import CONFIG
     7: from scalp.metrics import calc_pnl_pct
     8: from .walkforward import walk_forward
     9: 
    10: __all__ = ["backtest_trades", "walk_forward_windows", "walk_forward"]
    11: 
    12: 
    13: def _apply_slippage(price: float, side: int, bps: float, *, is_entry: bool) -> float:
    14:     """Return price adjusted for slippage in basis points.
    15: 
    16:     ``side`` is ``1`` for long entries and ``-1`` for shorts.  ``is_entry``
    17:     indicates whether the adjustment is for the entry or the exit leg.
    18:     """
    19: 
    20:     slip = bps / 10000.0
    21:     if side == 1:
    22:         return price * (1 + slip) if is_entry else price * (1 - slip)
    23:     return price * (1 - slip) if is_entry else price * (1 + slip)
    24: 
    25: 
    26: def backtest_trades(
    27:     trades: List[Dict[str, Any]],
    28:     *,
    29:     fee_rate: Optional[float] = None,
    30:     slippage_bps: float = 0.0,
    31:     logger: Any | None = None,
    32: ) -> float:
    33:     """Compute cumulative PnL for a series of trades.
    34: 
    35:     ``slippage_bps`` simulates execution slippage for both entry and exit.
    36:     If ``logger`` is provided it must expose a ``log(dict)`` method and each
    37:     trade will be recorded with the computed PnL using the executed prices.
    38:     """
    39:     fee_rate = fee_rate if fee_rate is not None else CONFIG.get("FEE_RATE", 0.0)
    40: 
    41:     pnl = 0.0
    42:     for tr in trades:
    43:         symbol = tr.get("symbol")
    44:         entry = tr.get("entry")
    45:         exit_ = tr.get("exit")
    46:         side = tr.get("side", 1)
    47:         if None in (symbol, entry, exit_):
    48:             continue
    49:         entry_exec = _apply_slippage(float(entry), side, slippage_bps, is_entry=True)
    50:         exit_exec = _apply_slippage(float(exit_), -side, slippage_bps, is_entry=False)
    51:         pnl_trade = calc_pnl_pct(entry_exec, exit_exec, side, fee_rate)
    52:         if logger is not None:
    53:             logger.log(
    54:                 {
    55:                     "pair": symbol,
    56:                     "tf": tr.get("tf"),
    57:                     "dir": "long" if side > 0 else "short",
    58:                     "entry": entry_exec,
    59:                     "sl": tr.get("sl"),
    60:                     "tp": tr.get("tp"),
    61:                     "score": tr.get("score"),
    62:                     "reasons": tr.get("reasons"),
    63:                     "pnl": pnl_trade,
    64:                 }
    65:             )
    66:         pnl += pnl_trade
    67:     return pnl
    68: 
    69: 
    70: def walk_forward_windows(series: List[Any], train: int, test: int):
    71:     """Yield sequential ``(train, test)`` windows for walk-forward analysis.
    72: 
    73:     Parameters
    74:     ----------
    75:     series:
    76:         Ordered data sequence.  The function simply slices the input and does
    77:         not inspect the values.
    78:     train, test:
    79:         Number of elements for the training and testing windows respectively.
    80:     """
    81: 
    82:     end = len(series) - train - test + 1
    83:     step = test if test > 0 else 1
    84:     for start in range(0, max(0, end), step):
    85:         train_slice = series[start : start + train]
    86:         test_slice = series[start + train : start + train + test]
    87:         if len(test_slice) < test or len(train_slice) < train:
    88:             break
    89:         yield train_slice, test_slice


## scalp/backtest/walkforward.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: 
     3: from itertools import product
     4: from statistics import mean, stdev
     5: from typing import Dict, Iterable, Optional
     6: 
     7: from ..strategy import max_drawdown
     8: 
     9: 
    10: def _sharpe(returns: Iterable[float]) -> float:
    11:     vals = list(returns)
    12:     if not vals:
    13:         return 0.0
    14:     mu = mean(vals)
    15:     if len(vals) > 1:
    16:         sd = stdev(vals)
    17:     else:
    18:         sd = 0.0
    19:     return mu / sd if sd > 0 else 0.0
    20: 
    21: 
    22: def _stability(equity: Iterable[float]) -> float:
    23:     curve = list(equity)
    24:     n = len(curve)
    25:     if n < 2:
    26:         return 0.0
    27:     x = list(range(n))
    28:     x_mean = sum(x) / n
    29:     y_mean = sum(curve) / n
    30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
    31:     denom = sum((xi - x_mean) ** 2 for xi in x)
    32:     if denom == 0 or ss_tot == 0:
    33:         return 0.0
    34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    35:     a = y_mean - b * x_mean
    36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    37:     return 1 - ss_res / ss_tot
    38: 
    39: 
    40: def walk_forward(
    41:     df,
    42:     splits: int = 5,
    43:     train_ratio: float = 0.7,
    44:     params: Optional[Dict[str, Iterable]] = None,
    45: ) -> Dict[str, float]:
    46:     """Perform walk-forward optimisation and evaluation.
    47: 
    48:     Parameters
    49:     ----------
    50:     df:
    51:         DataFrame containing per-period percentage returns. The first column is
    52:         used when a dedicated ``"returns"`` column is not found.
    53:     splits:
    54:         Number of walk-forward test windows.
    55:     train_ratio:
    56:         Proportion of the data used for training in the initial window.
    57:     params:
    58:         Optional parameter grid. If provided, columns in ``df`` matching each
    59:         parameter combination are evaluated and the best Sharpe ratio on the
    60:         training window is selected. When ``None``, the first column is used.
    61:     """
    62: 
    63:     if df.empty:
    64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
    65: 
    66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
    67:     data = df.copy()
    68: 
    69:     n = len(data)
    70:     train_len = max(1, int(n * train_ratio))
    71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
    72: 
    73:     sharpe_list = []
    74:     mdd_list = []
    75:     pnl_list = []
    76:     stability_list = []
    77: 
    78:     from . import walk_forward_windows
    79: 
    80:     indices = list(range(n))
    81: 
    82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
    83:         train_df = data.iloc[tr_idx]
    84:         test_df = data.iloc[te_idx]
    85: 
    86:         # Parameter optimisation based on Sharpe ratio
    87:         if params:
    88:             best_col = None
    89:             best_score = float("-inf")
    90:             keys, values = zip(*params.items()) if params else ([], [])
    91:             for combo in product(*values):
    92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
    93:                 if col_name not in data.columns:
    94:                     continue
    95:                 score = _sharpe(train_df[col_name])
    96:                 if score > best_score:
    97:                     best_score = score
    98:                     best_col = col_name
    99:             series = test_df[best_col] if best_col else test_df[returns_col]
   100:         else:
   101:             series = test_df[returns_col]
   102: 
   103:         sharpe_list.append(_sharpe(series))
   104:         equity = (1 + series / 100.0).cumprod()
   105:         mdd_list.append(max_drawdown(equity))
   106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
   107:         stability_list.append(_stability(equity))
   108: 
   109:     count = len(sharpe_list) or 1
   110:     mean_sharpe = sum(sharpe_list) / count
   111:     mean_mdd = sum(mdd_list) / count
   112:     mean_pnl = sum(pnl_list) / count
   113:     mean_stability = sum(stability_list) / count
   114: 
   115:     return {
   116:         "sharpe": mean_sharpe,
   117:         "mdd": mean_mdd,
   118:         "pnl": mean_pnl,
   119:         "stability": mean_stability,
   120:     }


## scalp/bitget_client.py (last modified: 2025-08-23 09:47:18)
     1: import json
     2: import logging
     3: import time
     4: import hmac
     5: import hashlib
     6: import base64
     7: import uuid
     8: from typing import Any, Dict, List, Optional
     9: 
    10: import requests
    11: 
    12: 
    13: # Mapping of deprecated v1 product type identifiers to the new v2 names
    14: _PRODUCT_TYPE_ALIASES = {
    15:     "UMCBL": "USDT-FUTURES",
    16:     "DMCBL": "USDC-FUTURES",
    17:     "CMCBL": "COIN-FUTURES",
    18: }
    19: 
    20: # Granularity aliases from v1 to v2 nomenclature
    21: _GRANULARITY_ALIASES = {
    22:     "MIN1": "1m",
    23:     "MIN3": "3m",
    24:     "MIN5": "5m",
    25:     "MIN15": "15m",
    26:     "MIN30": "30m",
    27:     "HOUR1": "1H",
    28:     "HOUR4": "4H",
    29:     "HOUR12": "12H",
    30:     "DAY1": "1D",
    31:     "WEEK1": "1W",
    32: }
    33: 
    34: 
    35: # Default margin coin for each product type. Some authenticated endpoints
    36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
    37: # default avoids ``400 Bad Request`` responses when the caller does not provide
    38: # it explicitly.
    39: _DEFAULT_MARGIN_COIN = {
    40:     "USDT-FUTURES": "USDT",
    41:     "USDC-FUTURES": "USDC",
    42: }
    43: 
    44: 
    45: class BitgetFuturesClient:
    46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
    47: 
    48:     def __init__(
    49:         self,
    50:         access_key: str,
    51:         secret_key: str,
    52:         base_url: str,
    53:         *,
    54:         product_type: str = "USDT-FUTURES",
    55:         recv_window: int = 30,
    56:         paper_trade: bool = True,
    57:         requests_module: Any = requests,
    58:         log_event: Optional[Any] = None,
    59:         passphrase: Optional[str] = None,
    60:     ) -> None:
    61:         self.ak = access_key
    62:         self.sk = secret_key
    63:         self.base = base_url.rstrip("/")
    64:         pt = product_type.upper()
    65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
    66:         self.recv_window = recv_window
    67:         self.paper_trade = paper_trade
    68:         self.requests = requests_module
    69:         self.log_event = log_event or (lambda *a, **k: None)
    70:         self.passphrase = passphrase
    71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
    72:             logging.warning(
    73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
    74:             )
    75:         # Cache for contract precision details to avoid repeated network calls
    76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
    77: 
    78:     # ------------------------------------------------------------------
    79:     # Helpers
    80:     # ------------------------------------------------------------------
    81:     @staticmethod
    82:     def _ms() -> int:
    83:         return int(time.time() * 1000)
    84: 
    85:     @staticmethod
    86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
    87:         if not params:
    88:             return ""
    89:         items = []
    90:         for k in sorted(params.keys()):
    91:             v = "" if params[k] is None else str(params[k])
    92:             items.append(f"{k}={v}")
    93:         return "&".join(items)
    94: 
    95:     def _sign(self, prehash: str) -> str:
    96:         """Return a base64-encoded HMAC SHA256 signature."""
    97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
    98:         return base64.b64encode(digest).decode()
    99: 
   100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
   101:         headers = {
   102:             "ACCESS-KEY": self.ak,
   103:             "ACCESS-SIGN": signature,
   104:             "ACCESS-TIMESTAMP": str(timestamp),
   105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
   106:             "Content-Type": "application/json",
   107:         }
   108:         if self.passphrase:
   109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
   110:         return headers
   111: 
   112:     def _format_symbol(self, symbol: str) -> str:
   113:         """Return ``symbol`` formatted for Bitget API.
   114: 
   115:         The v2 endpoints expect the trading pair without any product type
   116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
   117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
   118:         separators and any trailing product type string (legacy or v2).
   119:         """
   120: 
   121:         if not symbol:
   122:             return symbol
   123: 
   124:         sym = symbol.replace("_", "").upper()
   125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
   126:         if sym.endswith(self.product_type):
   127:             sym = sym[: -len(self.product_type)]
   128:         else:
   129:             for old in _PRODUCT_TYPE_ALIASES.keys():
   130:                 if sym.endswith(old):
   131:                     sym = sym[: -len(old)]
   132:                     break
   133:         return sym
   134: 
   135:     def _product_type(self, pt: Optional[str] = None) -> str:
   136:         """Normalise ``pt`` to a valid v2 product type identifier."""
   137:         key = (pt or self.product_type or "").upper()
   138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
   139: 
   140:     # ------------------------------------------------------------------
   141:     # Public endpoints
   142:     # ------------------------------------------------------------------
   143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   144:         """Return futures contract information.
   145: 
   146:         The previous implementation queried ``/contract-detail`` which does not
   147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
   148:         endpoint is ``/contracts`` with the symbol supplied as a query
   149:         parameter."""
   150: 
   151:         url = f"{self.base}/api/v2/mix/market/contracts"
   152:         params: Dict[str, Any] = {"productType": self.product_type}
   153:         if symbol:
   154:             params["symbol"] = self._format_symbol(symbol)
   155:         r = self.requests.get(url, params=params, timeout=15)
   156:         if r.status_code == 404:  # pragma: no cover - depends on network
   157:             logging.error("Contract detail introuvable pour %s", symbol)
   158:             return {"success": False, "code": 404, "data": None}
   159:         r.raise_for_status()
   160:         return r.json()
   161: 
   162:     # ------------------------------------------------------------------
   163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
   164:         """Return price and volume precision for ``symbol``.
   165: 
   166:         Results are cached to minimise HTTP requests. If the contract
   167:         information cannot be retrieved, ``(0, 0)`` is returned.
   168:         """
   169:         sym = self._format_symbol(symbol)
   170:         info = self._contract_cache.get(sym)
   171:         if info is None:
   172:             detail = self.get_contract_detail(sym)
   173:             try:
   174:                 data = detail.get("data", [])
   175:                 if isinstance(data, list) and data:
   176:                     info = data[0]
   177:                 else:
   178:                     info = {}
   179:             except Exception:
   180:                 info = {}
   181:             self._contract_cache[sym] = info
   182:         price_place = int(info.get("pricePlace") or 0)
   183:         volume_place = int(info.get("volumePlace") or 0)
   184:         return price_place, volume_place
   185: 
   186:     def get_kline(
   187:         self,
   188:         symbol: str,
   189:         interval: str = "1m",
   190:         start: Optional[int] = None,
   191:         end: Optional[int] = None,
   192:     ) -> Dict[str, Any]:
   193:         # Endpoint expects the trading pair in query parameters rather than
   194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
   195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
   196:         url = f"{self.base}/api/v2/mix/market/candles"
   197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
   198:         params: Dict[str, Any] = {
   199:             "symbol": self._format_symbol(symbol),
   200:             "productType": self.product_type,
   201:             "granularity": interval_norm,
   202:         }
   203:         if start is not None:
   204:             params["startTime"] = int(start)
   205:         if end is not None:
   206:             params["endTime"] = int(end)
   207:         r = self.requests.get(url, params=params, timeout=15)
   208:         r.raise_for_status()
   209:         data = r.json()
   210: 
   211:         rows = data.get("data") if isinstance(data, dict) else None
   212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
   213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   214:             for row in rows:
   215:                 if len(row) < 7:
   216:                     continue
   217:                 try:
   218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
   219:                     cols["ts"].append(int(ts))
   220:                     cols["open"].append(float(op))
   221:                     cols["high"].append(float(hi))
   222:                     cols["low"].append(float(lo))
   223:                     cols["close"].append(float(cl))
   224:                     cols["volume"].append(float(vol))
   225:                     cols["quoteVolume"].append(float(qv))
   226:                 except (TypeError, ValueError):
   227:                     continue
   228:             data["data"] = cols
   229:         elif isinstance(rows, list):
   230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   231:         return data
   232: 
   233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   234:         if symbol:
   235:             url = f"{self.base}/api/v2/mix/market/ticker"
   236:             params = {
   237:                 "symbol": self._format_symbol(symbol),
   238:                 "productType": self.product_type,
   239:             }
   240:         else:
   241:             url = f"{self.base}/api/v2/mix/market/tickers"
   242:             params = {"productType": self.product_type}
   243:         r = self.requests.get(url, params=params, timeout=15)
   244:         r.raise_for_status()
   245:         return r.json()
   246: 
   247:     # ------------------------------------------------------------------
   248:     # Private endpoints
   249:     # ------------------------------------------------------------------
   250:     def _private_request(
   251:         self,
   252:         method: str,
   253:         path: str,
   254:         *,
   255:         params: Optional[Dict[str, Any]] = None,
   256:         body: Optional[Dict[str, Any]] = None,
   257:     ) -> Dict[str, Any]:
   258:         method = method.upper()
   259:         ts = self._ms()
   260: 
   261:         if method in ("GET", "DELETE"):
   262:             qs = self._urlencode_sorted(params or {})
   263:             req_path = path + (f"?{qs}" if qs else "")
   264:             sig = self._sign(f"{ts}{method}{req_path}")
   265:             headers = self._headers(sig, ts)
   266:             url = f"{self.base}{req_path}"
   267:             r = self.requests.request(method, url, headers=headers, timeout=20)
   268:         elif method == "POST":
   269:             qs = self._urlencode_sorted(params or {})
   270:             req_path = path + (f"?{qs}" if qs else "")
   271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
   272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
   273:             headers = self._headers(sig, ts)
   274:             url = f"{self.base}{req_path}"
   275:             r = self.requests.post(
   276:                 url,
   277:                 data=body_str.encode("utf-8"),
   278:                 headers=headers,
   279:                 timeout=20,
   280:             )
   281:         else:
   282:             raise ValueError("M\u00e9thode non support\u00e9e")
   283: 
   284:         resp_text = getattr(r, "text", "")
   285:         try:
   286:             data = r.json()
   287:         except Exception:
   288:             data = {
   289:                 "success": False,
   290:                 "error": resp_text,
   291:                 "status_code": getattr(r, "status_code", None),
   292:             }
   293: 
   294:         status = getattr(r, "status_code", 0)
   295:         if status >= 400:
   296:             code = str(data.get("code")) if isinstance(data, dict) else ""
   297:             if code == "22001":
   298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
   299:             else:
   300:                 try:
   301:                     r.raise_for_status()
   302:                 except Exception as e:
   303:                     if not resp_text:
   304:                         resp_text = getattr(r, "text", "") or str(e)
   305:                 logging.error(
   306:                     "Erreur HTTP/JSON %s %s -> %s %s",
   307:                     method,
   308:                     path,
   309:                     status,
   310:                     resp_text,
   311:                 )
   312:                 if isinstance(data, dict):
   313:                     data.setdefault("success", False)
   314:                     data.setdefault("status_code", status)
   315:                     data.setdefault("error", resp_text)
   316: 
   317:         self.log_event(
   318:             "http_private",
   319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
   320:         )
   321:         return data
   322: 
   323:     # Accounts & positions -------------------------------------------------
   324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
   325:         if self.paper_trade:
   326:             return {
   327:                 "success": True,
   328:                 "code": 0,
   329:                 "data": [
   330:                     {
   331:                         "currency": "USDT",
   332:                         "equity": 100.0,
   333:                     }
   334:                 ],
   335:             }
   336: 
   337:         params = {"productType": self.product_type}
   338:         if margin_coin is None:
   339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   340:         if margin_coin:
   341:             params["marginCoin"] = margin_coin
   342:         data = self._private_request(
   343:             "GET", "/api/v2/mix/account/accounts", params=params
   344:         )
   345:         if isinstance(data, dict):
   346:             data.setdefault("success", str(data.get("code")) == "00000")
   347:         try:
   348:             for row in data.get("data", []):
   349:                 if "currency" not in row and row.get("marginCoin"):
   350:                     row["currency"] = str(row["marginCoin"]).upper()
   351:                 chosen = None
   352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
   353:                     val = row.get(key)
   354:                     if val is not None:
   355:                         chosen = val
   356:                         break
   357:                 if chosen is not None:
   358:                     row["equity"] = chosen
   359:                 try:
   360:                     row["equity"] = float(row["equity"])
   361:                 except Exception:
   362:                     pass
   363:         except Exception:  # pragma: no cover - best effort
   364:             pass
   365:         return data
   366: 
   367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   368:         if self.paper_trade:
   369:             return {"success": True, "code": 0, "data": []}
   370:         data = self._private_request(
   371:             "GET",
   372:             "/api/v2/mix/position/all-position",
   373:             params={"productType": self._product_type(product_type)},
   374:         )
   375:         try:
   376:             positions = data.get("data", [])
   377:             filtered = []
   378:             for pos in positions:
   379:                 vol = pos.get("vol")
   380:                 try:
   381:                     if vol is not None and float(vol) > 0:
   382:                         filtered.append(pos)
   383:                 except (TypeError, ValueError):
   384:                     continue
   385:             data["data"] = filtered
   386:         except Exception:  # pragma: no cover - best effort
   387:             pass
   388:         return data
   389: 
   390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   391:         if self.paper_trade:
   392:             return {"success": True, "code": 0, "data": []}
   393:         params: Dict[str, Any] = {"productType": self.product_type}
   394:         if symbol:
   395:             params["symbol"] = self._format_symbol(symbol)
   396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
   397: 
   398:     # Account configuration -------------------------------------------------
   399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
   400:         body = {
   401:             "productType": self._product_type(product_type),
   402:             "symbol": self._format_symbol(symbol),
   403:             "posMode": "one_way_mode",
   404:         }
   405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
   406: 
   407:     def set_leverage(
   408:         self,
   409:         symbol: str,
   410:         product_type: Optional[str] = None,
   411:         margin_coin: str = "USDT",
   412:         leverage: int = 1,
   413:     ) -> Dict[str, Any]:
   414:         body = {
   415:             "symbol": self._format_symbol(symbol),
   416:             "productType": self._product_type(product_type),
   417:             "marginCoin": margin_coin,
   418:             "leverage": int(leverage),
   419:         }
   420:         return self._private_request(
   421:             "POST", "/api/v2/mix/account/set-leverage", body=body
   422:         )
   423: 
   424:     def place_market_order_one_way(
   425:         self,
   426:         symbol: str,
   427:         side: str,
   428:         size: float,
   429:         product_type: Optional[str] = None,
   430:         margin_coin: str = "USDT",
   431:         *,
   432:         time_in_force: str = "normal",
   433:     ) -> Dict[str, Any]:
   434:         side = side.lower()
   435:         if side not in {"buy", "sell"}:
   436:             raise ValueError("side must be 'buy' or 'sell'")
   437:         body = {
   438:             "symbol": self._format_symbol(symbol),
   439:             "productType": self._product_type(product_type),
   440:             "marginCoin": margin_coin,
   441:             "marginMode": "crossed",
   442:             "posMode": "one_way_mode",
   443:             "orderType": "market",
   444:             "side": side,
   445:             "size": str(size),
   446:             "timeInForceValue": time_in_force,
   447:             "clientOid": str(uuid.uuid4())[:32],
   448:         }
   449:         return self._private_request(
   450:             "POST", "/api/v2/mix/order/place-order", body=body
   451:         )
   452: 
   453:     # Orders ---------------------------------------------------------------
   454:     def place_order(
   455:         self,
   456:         symbol: str,
   457:         side: int,
   458:         vol: int,
   459:         order_type: int,
   460:         *,
   461:         price: Optional[float] = None,
   462:         open_type: int = 1,
   463:         leverage: Optional[int] = None,
   464:         position_id: Optional[int] = None,
   465:         external_oid: Optional[str] = None,
   466:         stop_loss: Optional[float] = None,
   467:         take_profit: Optional[float] = None,
   468:         position_mode: Optional[int] = None,
   469:         margin_coin: Optional[str] = None,
   470:         time_in_force: str = "normal",
   471:     ) -> Dict[str, Any]:
   472:         """Submit an order.
   473: 
   474:         This helper keeps backward compatibility with the older numeric
   475:         parameters used by the bot while translating them to the string based
   476:         fields required by Bitget's v2 API.
   477:         """
   478:         if self.paper_trade:
   479:             logging.info(
   480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
   481:                 side,
   482:                 vol,
   483:                 order_type,
   484:                 price,
   485:             )
   486:             return {
   487:                 "success": True,
   488:                 "paperTrade": True,
   489:                 "simulated": {
   490:                     "symbol": symbol,
   491:                     "side": side,
   492:                     "vol": vol,
   493:                     "type": order_type,
   494:                     "price": price,
   495:                     "openType": open_type,
   496:                     "leverage": leverage,
   497:                     "stopLossPrice": stop_loss,
   498:                     "takeProfitPrice": take_profit,
   499:                 },
   500:             }
   501: 
   502:         # ------------------------------------------------------------------
   503:         # Parameter mapping
   504:         # ------------------------------------------------------------------
   505:         side_map = {
   506:             1: ("buy", "long"),
   507:             2: ("buy", "short"),
   508:             3: ("sell", "short"),
   509:             4: ("sell", "long"),
   510:         }
   511:         if isinstance(side, int):
   512:             mapped = side_map.get(side)
   513:             if not mapped:
   514:                 raise ValueError(f"Invalid side value: {side}")
   515:             side_str, pos_side = mapped
   516:         else:
   517:             side_str = str(side)
   518:             pos_side = None
   519: 
   520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
   521:         if isinstance(order_type, int):
   522:             order_str = order_map.get(order_type)
   523:             if order_str is None:
   524:                 order_str = "limit" if price is not None else "market"
   525:         else:
   526:             order_str = str(order_type)
   527: 
   528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
   529: 
   530:         if margin_coin is None:
   531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   532: 
   533:         # ------------------------------------------------------------------
   534:         # Precision handling
   535:         # ------------------------------------------------------------------
   536:         try:
   537:             price_place, volume_place = self._get_contract_precision(symbol)
   538:         except Exception:  # pragma: no cover - best effort
   539:             price_place = volume_place = 0
   540:         if price is not None:
   541:             price = round(float(price), price_place)
   542:         if vol is not None:
   543:             vol = round(float(vol), volume_place)
   544: 
   545:         body = {
   546:             "symbol": self._format_symbol(symbol),
   547:             "productType": self.product_type,
   548:             "marginMode": margin_mode,
   549:             "orderType": order_str,
   550:             "side": side_str,
   551:             "size": vol,
   552:             "timeInForceValue": time_in_force,
   553:         }
   554:         if pos_side is not None:
   555:             body["posSide"] = pos_side
   556:         if margin_coin:
   557:             body["marginCoin"] = margin_coin
   558:         if price is not None:
   559:             body["price"] = float(price)
   560:         if leverage is not None:
   561:             body["leverage"] = int(leverage)
   562:         if position_id is not None:
   563:             body["positionId"] = int(position_id)
   564:         if external_oid:
   565:             body["clientOid"] = str(external_oid)[:32]
   566:         else:
   567:             body["clientOid"] = str(uuid.uuid4())[:32]
   568:         if stop_loss is not None:
   569:             body["stopLossPrice"] = float(stop_loss)
   570:         if take_profit is not None:
   571:             body["takeProfitPrice"] = float(take_profit)
   572:         if position_mode is not None:
   573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
   574:         elif pos_side is not None:
   575:             body["posMode"] = "hedge_mode"
   576: 
   577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
   578: 
   579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
   580:         if self.paper_trade:
   581:             logging.info(
   582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
   583:             )
   584:             return {"success": True, "code": 0}
   585:         return self._private_request(
   586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
   587:         )
   588: 
   589:     def cancel_all(
   590:         self,
   591:         symbol: Optional[str] = None,
   592:         margin_coin: Optional[str] = None,
   593:     ) -> Dict[str, Any]:
   594:         if self.paper_trade:
   595:             logging.info(
   596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
   597:             )
   598:             return {"success": True, "code": 0}
   599:         body = {"productType": self.product_type}
   600:         if symbol:
   601:             body["symbol"] = self._format_symbol(symbol)
   602:         if margin_coin is None:
   603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   604:         if margin_coin:
   605:             body["marginCoin"] = margin_coin
   606:         return self._private_request(
   607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
   608:         )
   609: 
   610:     def close_position(
   611:         self,
   612:         symbol: str,
   613:         size: Optional[int] = None,
   614:         hold_side: Optional[str] = None,
   615:     ) -> Dict[str, Any]:
   616:         """Close an open position for ``symbol``.
   617: 
   618:         Parameters
   619:         ----------
   620:         symbol:
   621:             Trading symbol to close.
   622:         size:
   623:             Optional number of contracts to close. If omitted the entire
   624:             position is closed.
   625:         hold_side:
   626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
   627:             specified. If not provided the exchange will infer it.
   628:         """
   629: 
   630:         if self.paper_trade:
   631:             logging.info(
   632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
   633:             )
   634:             return {"success": True, "code": 0}
   635: 
   636:         body = {"symbol": self._format_symbol(symbol)}
   637:         if size is not None:
   638:             body["size"] = int(size)
   639:         if hold_side:
   640:             body["holdSide"] = hold_side
   641: 
   642:         body["productType"] = self.product_type
   643:         return self._private_request(
   644:             "POST", "/api/v2/mix/position/close-position", body=body
   645:         )
   646: 
   647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   648:         """Close all open positions."""
   649:         results = []
   650:         try:
   651:             for pos in self.get_positions(product_type).get("data", []):
   652:                 sym = pos.get("symbol")
   653:                 if sym:
   654:                     results.append(self.close_position(sym))
   655:         except Exception as exc:  # pragma: no cover - best effort
   656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
   657:         return {"success": True, "data": results}


## scalp/bot_config.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: 
     3: 
     4: DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"
     5: 
     6: CONFIG = {
     7:     "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
     8:     or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
     9:     "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
    10:     or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
    11:     "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
    12:     "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
    13:     "SYMBOL": DEFAULT_SYMBOL,
    14:     "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
    15:     "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
    16:     "INTERVAL": os.getenv("INTERVAL", "1m"),
    17:     "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
    18:     "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
    19:     "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
    20:     "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
    21:     "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
    22:     "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
    23:     "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
    24:     "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
    25:     "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
    26:     "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
    27:     "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
    28:     "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
    29:     "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
    30:     "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
    31:     "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
    32:     "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
    33:     "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
    34:     "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
    35:     "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
    36:     "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
    37:     "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
    38:     # --- Sécurité / Sizing -------------------------------------------------
    39:     "ALLOWED_SYMBOLS": [
    40:         s.strip().upper()
    41:         for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
    42:         if s.strip()
    43:     ],
    44:     "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
    45:     "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
    46:     "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
    47:     "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
    48:     "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
    49:     "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
    50:     "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
    51:     "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
    52:     "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
    53: }
    54: 


## scalp/client.py (last modified: 2025-08-23 09:47:18)
     1: import logging
     2: from typing import Any, Dict, Optional
     3: 
     4: import requests
     5: from requests.adapters import HTTPAdapter
     6: from urllib3.util.retry import Retry
     7: 
     8: 
     9: class HTTPError(RuntimeError):
    10:     """Raised when an HTTP request fails"""
    11: 
    12: 
    13: class HttpClient:
    14:     """Simple HTTP client with persistent session and retry logic.
    15: 
    16:     The client exposes a :py:meth:`close` method and implements the context
    17:     manager protocol so it can be used with ``with`` statements to ensure
    18:     that the underlying :class:`requests.Session` is properly closed.
    19:     """
    20: 
    21:     def __init__(
    22:         self,
    23:         base_url: str,
    24:         *,
    25:         timeout: float = 10.0,
    26:         max_retries: int = 3,
    27:         backoff_factor: float = 0.3,
    28:         status_forcelist: Optional[list[int]] = None,
    29:     ) -> None:
    30:         self.base_url = base_url.rstrip("/")
    31:         self.timeout = timeout
    32:         self.session = requests.Session()
    33:         retry = Retry(
    34:             total=max_retries,
    35:             backoff_factor=backoff_factor,
    36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
    37:             allowed_methods=[
    38:                 "HEAD",
    39:                 "GET",
    40:                 "OPTIONS",
    41:                 "POST",
    42:                 "PUT",
    43:                 "DELETE",
    44:                 "PATCH",
    45:             ],
    46:         )
    47:         adapter = HTTPAdapter(max_retries=retry)
    48:         self.session.mount("http://", adapter)
    49:         self.session.mount("https://", adapter)
    50: 
    51:     def close(self) -> None:
    52:         """Close the underlying :class:`requests.Session`."""
    53:         self.session.close()
    54: 
    55:     # ------------------------------------------------------------------
    56:     # Context manager support
    57:     # ------------------------------------------------------------------
    58:     def __enter__(self) -> "HttpClient":
    59:         return self
    60: 
    61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
    62:         self.close()
    63: 
    64:     def request(
    65:         self,
    66:         method: str,
    67:         path: str,
    68:         *,
    69:         params: Optional[Dict[str, Any]] = None,
    70:         json: Optional[Dict[str, Any]] = None,
    71:         headers: Optional[Dict[str, str]] = None,
    72:     ) -> Dict[str, Any]:
    73:         """Perform an HTTP request and return JSON data.
    74: 
    75:         Errors during the request raise ``HTTPError``. If the response cannot
    76:         be decoded as JSON, a dictionary describing the issue is returned.
    77:         """
    78:         url = f"{self.base_url}{path}"
    79:         try:
    80:             resp = self.session.request(
    81:                 method,
    82:                 url,
    83:                 params=params,
    84:                 json=json,
    85:                 headers=headers,
    86:                 timeout=self.timeout,
    87:             )
    88:             resp.raise_for_status()
    89:         except requests.RequestException as exc:  # network or HTTP errors
    90:             msg = f"HTTP error calling {url}: {exc}"
    91:             logging.error(msg)
    92:             raise HTTPError(msg) from exc
    93: 
    94:         try:
    95:             return resp.json()
    96:         except ValueError:  # invalid JSON
    97:             msg = "Invalid JSON in response"
    98:             logging.error("%s for %s: %s", msg, url, resp.text)
    99:             return {"success": False, "error": msg, "text": resp.text}


## scalp/config.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/config.py
     2: from __future__ import annotations
     3: import os, sys
     4: from typing import Optional
     5: 
     6: # ---------------------------
     7: #  Chargement .env (sans dep)
     8: # ---------------------------
     9: def _load_dotenv_if_present(path: str = ".env") -> None:
    10:     try:
    11:         if not os.path.isfile(path):
    12:             return
    13:         with open(path, "r", encoding="utf-8") as f:
    14:             for line in f:
    15:                 s = line.strip()
    16:                 if not s or s.startswith("#") or "=" not in s:
    17:                     continue
    18:                 k, v = s.split("=", 1)
    19:                 k = k.strip()
    20:                 v = v.strip().strip('"').strip("'")
    21:                 # ne pas écraser une var déjà définie par l'env
    22:                 os.environ.setdefault(k, v)
    23:     except Exception:
    24:         pass
    25: 
    26: _load_dotenv_if_present()
    27: 
    28: # ---------------------------
    29: #  Aliases variables d'env
    30: # ---------------------------
    31: def _env_alias(name: str, *aliases: str) -> Optional[str]:
    32:     """Retourne la première valeur non nulle parmi name et ses alias."""
    33:     if name in os.environ and os.environ[name]:
    34:         return os.environ[name]
    35:     for a in aliases:
    36:         v = os.environ.get(a)
    37:         if v:
    38:             return v
    39:     return None
    40: 
    41: def _env_bool(name: str, default: bool) -> bool:
    42:     raw = os.environ.get(name)
    43:     if raw is None:
    44:         return default
    45:     return raw.lower() in ("1", "true", "yes", "on")
    46: 
    47: # ---------------------------
    48: #  Pydantic v1 si dispo
    49: # ---------------------------
    50: try:
    51:     from pydantic import BaseModel, Field, ValidationError  # type: ignore
    52:     _HAVE_PYDANTIC = True
    53: except Exception:
    54:     _HAVE_PYDANTIC = False
    55: 
    56: if _HAVE_PYDANTIC:
    57: 
    58:     class AppConfig(BaseModel):
    59:         # Clés Bitget
    60:         BITGET_API_KEY: str = Field(..., min_length=3)
    61:         BITGET_API_SECRET: str = Field(..., min_length=3)
    62:         BITGET_PASSPHRASE: str = Field(..., min_length=1)
    63: 
    64:         # Trading
    65:         RISK_PCT: float = Field(0.01, ge=0.0, le=0.2)
    66:         MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
    67:         LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
    68:         PAPER_TRADE: bool = Field(True)
    69: 
    70:         # Telegram (facultatif)
    71:         TELEGRAM_BOT_TOKEN: Optional[str] = None
    72:         TELEGRAM_CHAT_ID: Optional[str] = None
    73: 
    74:     def load_or_exit() -> "AppConfig":
    75:         try:
    76:             # supporte aussi ACCESS_KEY/SECRET_KEY (alias)
    77:             api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
    78:             api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
    79:             api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
    80: 
    81:             return AppConfig(
    82:                 BITGET_API_KEY=api_key,
    83:                 BITGET_API_SECRET=api_sec,
    84:                 BITGET_PASSPHRASE=api_pass,
    85:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
    86:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
    87:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
    88:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
    89:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
    90:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
    91:             )
    92:         except ValidationError as e:
    93:             print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
    94:             sys.exit(2)
    95: 
    96: else:
    97:     # ---------------------------
    98:     #  Fallback dataclass simple
    99:     # ---------------------------
   100:     from dataclasses import dataclass
   101: 
   102:     @dataclass
   103:     class AppConfig:
   104:         BITGET_API_KEY: str
   105:         BITGET_API_SECRET: str
   106:         BITGET_PASSPHRASE: str
   107: 
   108:         RISK_PCT: float = 0.01
   109:         MIN_TRADE_USDT: float = 5.0
   110:         LEVERAGE: float = 1.0
   111:         PAPER_TRADE: bool = True
   112: 
   113:         TELEGRAM_BOT_TOKEN: Optional[str] = None
   114:         TELEGRAM_CHAT_ID: Optional[str] = None
   115: 
   116:     def load_or_exit() -> "AppConfig":
   117:         api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
   118:         api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
   119:         api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
   120: 
   121:         if not api_key or not api_sec or not api_pass:
   122:             print("[CONFIG] Missing Bitget credentials. Expected either:", file=sys.stderr)
   123:             print("        - BITGET_API_KEY / BITGET_API_SECRET / BITGET_PASSPHRASE", file=sys.stderr)
   124:             print("          or", file=sys.stderr)
   125:             print("        - BITGET_ACCESS_KEY / BITGET_SECRET_KEY / BITGET_PASSPHRASE", file=sys.stderr)
   126:             sys.exit(2)
   127: 
   128:         try:
   129:             return AppConfig(
   130:                 BITGET_API_KEY=api_key,
   131:                 BITGET_API_SECRET=api_sec,
   132:                 BITGET_PASSPHRASE=api_pass,
   133:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
   134:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
   135:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
   136:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
   137:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
   138:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
   139:             )
   140:         except Exception as e:
   141:             print(f"[CONFIG] Invalid configuration values: {e!r}", file=sys.stderr)
   142:             sys.exit(2)

## scalp/logging_utils.py (last modified: 2025-08-23 09:47:18)
     1: """Logging helpers for the Scalp bot."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import atexit
     6: import csv
     7: import json
     8: import os
     9: import sqlite3
    10: import time
    11: from pathlib import Path
    12: from typing import Any, Dict, List
    13: 
    14: 
    15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    16:     """Return a callable that logs events as JSON lines.
    17: 
    18:     Parameters
    19:     ----------
    20:     path: str
    21:         Target file path for JSON lines.
    22:     max_bytes: int, optional
    23:         If >0, rotate the file when its size exceeds this value.
    24:     backup_count: int, optional
    25:         Number of rotated files to keep when ``max_bytes`` is set.
    26:     """
    27:     os.makedirs(os.path.dirname(path), exist_ok=True)
    28:     log_file = open(path, "a", encoding="utf-8")
    29: 
    30:     def _close_file() -> None:
    31:         try:
    32:             log_file.close()
    33:         except Exception:
    34:             pass
    35: 
    36:     atexit.register(_close_file)
    37: 
    38:     def _rotate() -> None:
    39:         nonlocal log_file
    40:         log_file.close()
    41:         for i in range(backup_count - 1, 0, -1):
    42:             src = f"{path}.{i}"
    43:             dst = f"{path}.{i + 1}"
    44:             if os.path.exists(src):
    45:                 os.replace(src, dst)
    46:         os.replace(path, f"{path}.1")
    47:         log_file = open(path, "a", encoding="utf-8")
    48: 
    49:     def _log(event: str, payload: Dict[str, Any]) -> None:
    50:         nonlocal log_file
    51:         payload = dict(payload or {})
    52:         payload["event"] = event
    53:         payload["ts"] = int(time.time() * 1000)
    54:         line = json.dumps(payload, ensure_ascii=False)
    55:         if max_bytes and backup_count > 0:
    56:             if log_file.tell() + len(line) + 1 > max_bytes:
    57:                 _rotate()
    58:         log_file.write(line + "\n")
    59:         log_file.flush()
    60: 
    61:     return _log
    62: 
    63: 
    64: class TradeLogger:
    65:     """Helper writing trade information to CSV and SQLite files."""
    66: 
    67:     fields = [
    68:         "pair",
    69:         "tf",
    70:         "dir",
    71:         "entry",
    72:         "sl",
    73:         "tp",
    74:         "score",
    75:         "reasons",
    76:         "pnl",
    77:     ]
    78: 
    79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
    80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
    81:         self.csv_path = csv_path
    82:         self.sqlite_path = sqlite_path
    83: 
    84:         # Ensure CSV has header
    85:         if not os.path.exists(csv_path):
    86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
    87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
    88:                 writer.writeheader()
    89: 
    90:         # Setup SQLite store
    91:         self.conn = sqlite3.connect(sqlite_path)
    92:         cur = self.conn.cursor()
    93:         cur.execute(
    94:             """
    95:             CREATE TABLE IF NOT EXISTS trades (
    96:                 pair TEXT,
    97:                 tf TEXT,
    98:                 dir TEXT,
    99:                 entry REAL,
   100:                 sl REAL,
   101:                 tp REAL,
   102:                 score REAL,
   103:                 reasons TEXT,
   104:                 pnl REAL
   105:             )
   106:             """
   107:         )
   108:         self.conn.commit()
   109:         atexit.register(self.conn.close)
   110: 
   111:     def log(self, data: Dict[str, Any]) -> None:
   112:         row = {k: data.get(k) for k in self.fields}
   113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
   114:             writer = csv.DictWriter(f, fieldnames=self.fields)
   115:             writer.writerow(row)
   116:         cur = self.conn.cursor()
   117:         cur.execute(
   118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
   119:             (
   120:                 row["pair"],
   121:                 row["tf"],
   122:                 row["dir"],
   123:                 row["entry"],
   124:                 row["sl"],
   125:                 row["tp"],
   126:                 row["score"],
   127:                 row["reasons"],
   128:                 row["pnl"],
   129:             ),
   130:         )
   131:         self.conn.commit()
   132: 
   133: 
   134: BASE_DIR = Path(__file__).resolve().parents[2]
   135: 
   136: 
   137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
   138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
   139:     path.parent.mkdir(parents=True, exist_ok=True)
   140:     file_exists = path.exists()
   141:     with path.open("a", newline="", encoding="utf-8") as f:
   142:         writer = csv.DictWriter(f, fieldnames=fields)
   143:         if not file_exists:
   144:             writer.writeheader()
   145:         writer.writerow({k: row.get(k) for k in fields})
   146: 
   147: 
   148: def log_position(data: Dict[str, Any]) -> None:
   149:     """Log a closed position to ``../positions.csv``."""
   150:     fields = [
   151:         "timestamp",
   152:         "pair",
   153:         "direction",
   154:         "entry",
   155:         "exit",
   156:         "pnl_pct",
   157:         "fee_rate",
   158:         "notes",
   159:     ]
   160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
   161: 
   162: 
   163: def log_operation_memo(data: Dict[str, Any]) -> None:
   164:     """Log operation details to ``../operations_memo.csv``."""
   165:     fields = ["timestamp", "pair", "details"]
   166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)


## scalp/metrics.py (last modified: 2025-08-23 09:47:18)
     1: """Utility metrics for trading calculations."""
     2: 
     3: from __future__ import annotations
     4: 
     5: 
     6: from typing import Iterable
     7: 
     8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
     9: 
    10: 
    11: def calc_pnl_pct(
    12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
    13: ) -> float:
    14:     """Return percentage PnL between entry and exit prices minus fees.
    15: 
    16: 
    17:     Parameters
    18:     ----------
    19:     entry_price: float
    20:         Trade entry price (>0).
    21:     exit_price: float
    22:         Trade exit price (>0).
    23:     side: int
    24:         +1 for long, -1 for short.
    25:     fee_rate: float, optional
    26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
    27:         applied twice (entry + exit).
    28:     """
    29:     if entry_price <= 0 or exit_price <= 0:
    30:         raise ValueError("Prices must be positive")
    31:     if side not in (1, -1):
    32:         raise ValueError("side must be +1 (long) or -1 (short)")
    33: 
    34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
    36:     return pnl - fee_pct
    37: 
    38: 
    39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
    41: 
    42: 
    43:     Parameters
    44:     ----------
    45:     prices:
    46:         Ordered sequence of closing prices.
    47:     period:
    48:         Number of periods to use for the calculation. Must be positive and the
    49:         length of ``prices`` must be at least ``period + 1``.
    50:     """
    51: 
    52:     prices_list = [float(p) for p in prices]
    53: 
    54:     if period <= 0:
    55:         raise ValueError("period must be positive")
    56:     if len(prices_list) < period + 1:
    57: 
    58:         raise ValueError("len(prices) must be >= period + 1")
    59: 
    60:     gains: list[float] = []
    61:     losses: list[float] = []
    62:     for i in range(1, period + 1):
    63: 
    64:         diff = prices_list[i] - prices_list[i - 1]
    65: 
    66:         if diff >= 0:
    67:             gains.append(diff)
    68:             losses.append(0.0)
    69:         else:
    70:             gains.append(0.0)
    71:             losses.append(-diff)
    72: 
    73:     avg_gain = sum(gains) / period
    74:     avg_loss = sum(losses) / period
    75: 
    76:     for i in range(period + 1, len(prices_list)):
    77:         diff = prices_list[i] - prices_list[i - 1]
    78: 
    79:         gain = max(diff, 0.0)
    80:         loss = max(-diff, 0.0)
    81:         avg_gain = (avg_gain * (period - 1) + gain) / period
    82:         avg_loss = (avg_loss * (period - 1) + loss) / period
    83: 
    84:     if avg_gain == 0 and avg_loss == 0:
    85:         return 50.0
    86:     if avg_loss == 0:
    87:         return 100.0
    88:     if avg_gain == 0:
    89:         return 0.0
    90:     rs = avg_gain / avg_loss
    91:     return 100.0 - (100.0 / (1.0 + rs))
    92: 
    93: 
    94: def calc_atr(
    95:     highs: Iterable[float],
    96:     lows: Iterable[float],
    97:     closes: Iterable[float],
    98:     period: int = 14,
    99: ) -> float:
   100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
   101: 
   102: 
   103:     Parameters
   104:     ----------
   105:     highs, lows, closes:
   106:         Ordered sequences of high, low and close prices. All sequences must
   107:         have the same length and contain at least ``period + 1`` elements.
   108:     period:
   109:         Number of periods to use for the calculation. Must be positive.
   110:     """
   111: 
   112:     highs_list = [float(h) for h in highs]
   113:     lows_list = [float(low) for low in lows]
   114:     closes_list = [float(c) for c in closes]
   115: 
   116:     length = len(highs_list)
   117:     if length != len(lows_list) or length != len(closes_list):
   118: 
   119:         raise ValueError("Input sequences must have the same length")
   120:     if period <= 0:
   121:         raise ValueError("period must be positive")
   122:     if length < period + 1:
   123:         raise ValueError("Input sequences must have at least period + 1 elements")
   124: 
   125:     trs: list[float] = []
   126:     for i in range(1, len(highs_list)):
   127:         tr = max(
   128:             highs_list[i] - lows_list[i],
   129:             abs(highs_list[i] - closes_list[i - 1]),
   130:             abs(lows_list[i] - closes_list[i - 1]),
   131:         )
   132:         trs.append(tr)
   133: 
   134:     atr = sum(trs[:period]) / period
   135:     for tr in trs[period:]:
   136:         atr = (atr * (period - 1) + tr) / period
   137:     return atr
   138: 
   139: 
   140: def calc_macd(
   141:     prices: Sequence[float],
   142:     fast: int = 12,
   143:     slow: int = 26,
   144:     signal: int = 9,
   145: ) -> tuple[float, float, float]:
   146:     """Return MACD, signal line and histogram values.
   147: 
   148:     The implementation computes exponential moving averages using Wilder's
   149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
   150:     """
   151: 
   152:     prices_list = [float(p) for p in prices]
   153:     if fast <= 0 or slow <= 0 or signal <= 0:
   154:         raise ValueError("periods must be positive")
   155:     min_len = max(fast, slow) + signal
   156:     if len(prices_list) < min_len:
   157:         raise ValueError("len(prices) must be >= slow + signal")
   158: 
   159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
   160:         k = 2.0 / (window + 1.0)
   161:         out = [float(series[0])]
   162:         for x in series[1:]:
   163:             out.append(float(x) * k + out[-1] * (1.0 - k))
   164:         return out
   165: 
   166:     fast_ema = _ema_series(prices_list, fast)
   167:     slow_ema = _ema_series(prices_list, slow)
   168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
   169:     signal_series = _ema_series(macd_series, signal)
   170:     macd_val = macd_series[-1]
   171:     signal_val = signal_series[-1]
   172:     hist = macd_val - signal_val
   173:     return macd_val, signal_val, hist
   174: 
   175: 
   176: def backtest_position(
   177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
   178: ) -> bool:
   179:     """Run a basic backtest to verify a position's coherence.
   180: 
   181:     Parameters
   182:     ----------
   183:     prices: list[float]
   184:         Sequential list of prices to evaluate.
   185:     entry_idx: int
   186:         Index in ``prices`` where the position is opened.
   187:     exit_idx: int
   188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
   189:     side: int
   190:         +1 for long, -1 for short.
   191: 
   192:     Returns
   193:     -------
   194:     bool
   195:         ``True`` if the resulting PnL is non-negative, meaning the position is
   196:         coherent with the direction of price movement. ``False`` otherwise.
   197:     """
   198:     if side not in (1, -1):
   199:         raise ValueError("side must be +1 (long) or -1 (short)")
   200:     if not (0 <= entry_idx < exit_idx < len(prices)):
   201:         raise ValueError(
   202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
   203:         )
   204: 
   205:     entry_price = float(prices[entry_idx])
   206:     exit_price = float(prices[exit_idx])
   207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
   208:     return pnl >= 0.0


## scalp/notifier.py (last modified: 2025-08-23 09:47:18)
     1: """Simple notifier for bot events."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import logging
     6: import os
     7: from typing import Any, Dict
     8: 
     9: try:  # pragma: no cover - guarded import for optional dependency
    10:     import requests as _requests
    11: 
    12:     # ``requests`` may be provided as a stub during tests. Ensure it exposes a
    13:     # ``post`` attribute so callers can monkeypatch it reliably.
    14:     if not hasattr(_requests, "post"):
    15:         raise ImportError
    16:     requests = _requests
    17: except Exception:  # pragma: no cover - fallback when ``requests`` is missing
    18: 
    19:     class _Requests:
    20:         """Minimal stand‑in for :mod:`requests` when the real library is absent."""
    21: 
    22:         def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
    23:             raise RuntimeError("requests.post unavailable")
    24: 
    25:     requests = _Requests()  # type: ignore[assignment]
    26: 
    27: 
    28: def _pair_name(symbol: str) -> str:
    29:     """Return a human friendly pair name without the base ``USDT``."""
    30:     if "_" in symbol:
    31:         base, quote = symbol.split("_", 1)
    32:     elif symbol.endswith("USDT"):
    33:         base, quote = symbol[:-4], "USDT"
    34:     else:
    35:         base, quote = symbol, ""
    36:     if not quote or quote == "USDT":
    37:         return base
    38:     return f"{base}/{quote}"
    39: 
    40: 
    41: def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
    42:     """Format a position open/close payload."""
    43: 
    44:     side = payload.get("side")
    45:     symbol = payload.get("symbol")
    46:     if symbol:
    47:         symbol = _pair_name(symbol)
    48: 
    49:     if event == "position_opened":
    50:         rc = payload.get("risk_color", "")
    51:         head = f"{rc} Ouvre {side} {symbol}".strip()
    52:         lines = [head]
    53:         lines.append(
    54:             f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
    55:         )
    56:         lines.append(
    57:             "Marge estimée: {} USDT (dispo: {} USDT)".format(
    58:                 payload.get("required_margin_usdt"), payload.get("available_usdt")
    59:             )
    60:         )
    61:         lines.append(
    62:             "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
    63:                 payload.get("signal_level"),
    64:                 payload.get("risk_level_user"),
    65:                 float(payload.get("risk_pct_eff", 0.0)) * 100,
    66:             )
    67:         )
    68:         lines.append(
    69:             "Prix: {}   Vol: {} (cs={})".format(
    70:                 payload.get("price"),
    71:                 payload.get("vol"),
    72:                 payload.get("contract_size"),
    73:             )
    74:         )
    75:         return "\n".join(lines)
    76: 
    77:     # position_closed
    78:     rc = payload.get("risk_color", "")
    79:     head = f"Ferme {side} {symbol} {rc}".strip()
    80:     lines = [head]
    81:     pnl_usdt = payload.get("pnl_usdt")
    82:     fees = payload.get("fees_usdt")
    83:     if pnl_usdt is not None and fees is not None:
    84:         lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
    85:     pct = payload.get("pnl_pct_on_margin")
    86:     if pct is not None:
    87:         lines.append(f"% sur marge: {pct:.2f}%")
    88:     lines.append(
    89:         "Entrée: {}  Sortie: {}".format(
    90:             payload.get("entry_price"), payload.get("exit_price")
    91:         )
    92:     )
    93:     lines.append(
    94:         "Vol: {}  Notional: in {} → out {} USDT".format(
    95:             payload.get("vol"),
    96:             payload.get("notional_entry_usdt"),
    97:             payload.get("notional_exit_usdt"),
    98:         )
    99:     )
   100:     return "\n".join(lines)
   101: 
   102: 
   103: def _format_pair_list(payload: Dict[str, Any]) -> str:
   104:     """Format the pair list payload.
   105: 
   106:     The detailed pair listing is intentionally hidden from terminal output to
   107:     reduce noise. Only an acknowledgement message is returned.
   108:     """
   109: 
   110:     return "Listing ok"
   111: 
   112: 
   113: def _format_generic(event: str, payload: Dict[str, Any]) -> str:
   114:     text = event
   115:     if payload:
   116:         items = "\n".join(f"{k}={v}" for k, v in payload.items())
   117:         text = f"{text}\n{items}"
   118:     return text
   119: 
   120: 
   121: def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
   122:     """Return a human readable text describing the event payload."""
   123:     payload = payload or {}
   124:     if event in {"position_opened", "position_closed"}:
   125:         return _format_position_event(event, payload)
   126:     if event == "pair_list":
   127:         return _format_pair_list(payload)
   128:     if event == "bot_started":
   129:         return "🤖 Bot démarré"
   130:     return _format_generic(event, payload)
   131: 
   132: 
   133: def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
   134:     """Send an event payload to configured endpoints.
   135: 
   136:     Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
   137:     and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
   138:     ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
   139:     ignored so they do not interrupt the bot's execution.
   140:     """
   141: 
   142:     data = {"event": event}
   143:     if payload:
   144:         data.update(payload)
   145: 
   146:     # Generic HTTP webhook
   147:     url = os.getenv("NOTIFY_URL")
   148:     if url:
   149:         try:
   150:             requests.post(url, json=data, timeout=5)
   151:         except Exception as exc:  # pragma: no cover - best effort only
   152:             logging.error("Notification error for %s: %s", event, exc)
   153: 
   154:     # Telegram notification
   155:     token = os.getenv("TELEGRAM_BOT_TOKEN")
   156:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
   157:     # ``pair_list`` notifications are intentionally not forwarded to Telegram
   158:     if token and chat_id and event != "pair_list":
   159:         text = _format_text(event, payload or {})
   160:         t_url = f"https://api.telegram.org/bot{token}/sendMessage"
   161:         t_payload = {"chat_id": chat_id, "text": text}
   162:         try:  # pragma: no cover - network
   163:             requests.post(t_url, json=t_payload, timeout=5)
   164:         except Exception as exc:  # pragma: no cover - best effort only
   165:             logging.error("Telegram notification error for %s: %s", event, exc)


## scalp/pairs.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities to select trading pairs and detect signals."""
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Callable
     4: from scalp.strategy import Signal
     5: 
     6: from scalp.bot_config import CONFIG
     7: from scalp.strategy import ema as default_ema, cross as default_cross
     8: from scalp.notifier import notify
     9: 
    10: 
    11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    12:     """Return all trading pairs using the client's ``get_ticker`` method."""
    13:     tick = client.get_ticker()
    14:     data = tick.get("data") if isinstance(tick, dict) else []
    15:     if not data:
    16:         return []
    17:     return data if isinstance(data, list) else [data]
    18: 
    19: 
    20: def filter_trade_pairs(
    21:     client: Any,
    22:     *,
    23:     volume_min: float = 5_000_000,
    24:     max_spread_bps: float = 5.0,
    25:     top_n: int = 40,
    26: ) -> List[Dict[str, Any]]:
    27:     """Filter pairs by volume and spread."""
    28:     pairs = get_trade_pairs(client)
    29:     eligible: List[Dict[str, Any]] = []
    30: 
    31:     for info in pairs:
    32:         sym = info.get("symbol")
    33:         if not sym:
    34:             continue
    35:         try:
    36:             vol = float(info.get("volume", 0))
    37:         except (TypeError, ValueError):
    38:             continue
    39:         if vol < volume_min:
    40:             continue
    41:         try:
    42:             bid = float(info.get("bidPrice", 0))
    43:             ask = float(info.get("askPrice", 0))
    44:         except (TypeError, ValueError):
    45:             continue
    46:         if bid <= 0 or ask <= 0:
    47:             continue
    48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
    49:         if spread_bps >= max_spread_bps:
    50:             continue
    51:         eligible.append(info)
    52: 
    53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    54:     return eligible[:top_n]
    55: 
    56: 
    57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
    58:     """Return ``top_n`` pairs sorted by ``key``."""
    59:     pairs = get_trade_pairs(client)
    60: 
    61:     def volume(row: Dict[str, Any]) -> float:
    62:         try:
    63:             return float(row.get(key, 0))
    64:         except (TypeError, ValueError):
    65:             return 0.0
    66: 
    67:     pairs.sort(key=volume, reverse=True)
    68:     return pairs[:top_n]
    69: 
    70: 
    71: def _ancienne_impl(
    72:     client: Any,
    73:     pairs: List[Dict[str, Any]],
    74:     *,
    75:     interval: str = "1m",
    76:     ema_fast_n: Optional[int] = None,
    77:     ema_slow_n: Optional[int] = None,
    78:     ema_func=default_ema,
    79:     cross_func=default_cross,
    80: ) -> List[Dict[str, Any]]:
    81:     """Original implementation returning dicts."""
    82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    84:     results: List[Dict[str, Any]] = []
    85: 
    86:     for info in pairs:
    87:         symbol = info.get("symbol")
    88:         if not symbol:
    89:             continue
    90:         k = client.get_kline(symbol, interval=interval)
    91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
    92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
    93:             continue
    94:         efull = ema_func(closes, ema_fast_n)
    95:         eslow = ema_func(closes, ema_slow_n)
    96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
    97:         if signal == 1:
    98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
    99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
   100:         elif signal == -1:
   101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
   102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
   103:     return results
   104: 
   105: 
   106: def _to_signal(d: dict) -> Signal:
   107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
   108:     return Signal(
   109:         symbol=d.get("symbol"),
   110:         side=side,
   111:         entry=float(d.get("price", d.get("entry", 0))),
   112:         sl=float(d.get("sl", 0)),
   113:         tp1=float(d.get("tp1", 0)) or None,
   114:         tp2=float(d.get("tp2", 0)) or None,
   115:         score=d.get("score"),
   116:         quality=d.get("quality"),
   117:         reasons=d.get("reasons", []),
   118:     )
   119: 
   120: 
   121: def find_trade_positions(
   122:     client: Any,
   123:     pairs: List[Dict[str, Any]],
   124:     *,
   125:     interval: str = "1m",
   126:     ema_fast_n: Optional[int] = None,
   127:     ema_slow_n: Optional[int] = None,
   128:     ema_func=default_ema,
   129:     cross_func=default_cross,
   130: ) -> List[Signal]:
   131:     raw = _ancienne_impl(
   132:         client,
   133:         pairs,
   134:         interval=interval,
   135:         ema_fast_n=ema_fast_n,
   136:         ema_slow_n=ema_slow_n,
   137:         ema_func=ema_func,
   138:         cross_func=cross_func,
   139:     )
   140:     return [_to_signal(x) for x in raw]
   141: 
   142: 
   143: def send_selected_pairs(
   144:     client: Any,
   145:     top_n: int = 40,
   146:     *,
   147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
   148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
   149: ) -> Dict[str, str]:
   150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
   151: 
   152:     Returns the payload sent to ``notify_fn``. The mapping contains the
   153:     comma-separated symbols for each color group (``green``, ``orange`` and
   154:     ``red``) or an empty dictionary when no pairs are available.
   155:     """
   156: 
   157:     def split_symbol(sym: str) -> tuple[str, str]:
   158:         if "_" in sym:
   159:             left, right = sym.split("_", 1)
   160:             # Legacy style: BTC_USDT
   161:             if len(right) <= 4:
   162:                 return left, right
   163:             # Bitget futures style: BTCUSDT_UMCBL
   164:             main = left
   165:             if main.endswith("USDT"):
   166:                 return main[:-4], "USDT"
   167:             if main.endswith("USDC"):
   168:                 return main[:-4], "USDC"
   169:             if main.endswith("USD"):
   170:                 return main[:-3], "USD"
   171:             return main, ""
   172:         if sym.endswith("USDT"):
   173:             return sym[:-4], "USDT"
   174:         if sym.endswith("USDC"):
   175:             return sym[:-4], "USDC"
   176:         if sym.endswith("USD"):
   177:             return sym[:-3], "USD"
   178:         return sym, ""
   179: 
   180:     pairs = select_fn(client, top_n=top_n * 3)
   181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
   182:     by_base: Dict[str, Dict[str, Any]] = {}
   183:     for info in pairs:
   184:         sym = info.get("symbol")
   185:         if not sym:
   186:             continue
   187:         norm_sym = sym.split("_")[0].upper()
   188:         if allowed and norm_sym not in allowed:
   189:             continue
   190:         base, quote = split_symbol(sym)
   191:         existing = by_base.get(base)
   192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
   193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
   194:             by_base[base] = {"data": info, "quote": quote}
   195: 
   196:     unique = sorted(
   197:         (v["data"] for v in by_base.values()),
   198:         key=lambda row: float(row.get("volume", 0)),
   199:         reverse=True,
   200:     )
   201:     symbols: list[str] = []
   202:     for row in unique[:top_n]:
   203:         sym = row.get("symbol")
   204:         if not sym:
   205:             continue
   206:         base, _ = split_symbol(sym)
   207:         symbols.append(base)
   208:     if symbols:
   209:         n = len(symbols)
   210:         third = max(n // 3, 1)
   211:         green = symbols[:third]
   212:         orange = symbols[third : 2 * third]
   213:         red = symbols[2 * third :]
   214:         payload: Dict[str, str] = {}
   215:         if green:
   216:             payload["green"] = ", ".join(green)
   217:         if orange:
   218:             payload["orange"] = ", ".join(orange)
   219:         if red:
   220:             payload["red"] = ", ".join(red)
   221:         notify_fn("pair_list", payload)
   222:         return payload
   223:     return {}
   224: 
   225: 
   226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
   227:     """Return a heat score combining volatility, volume and a news flag."""
   228:     mult = 2.0 if news else 1.0
   229:     return volatility * volume * mult
   230: 
   231: 
   232: def select_top_heat_pairs(
   233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
   234: ) -> List[Dict[str, Any]]:
   235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
   236: 
   237:     scored: List[Dict[str, Any]] = []
   238:     for info in pairs:
   239:         try:
   240:             vol = float(info.get("volatility", 0))
   241:             volume = float(info.get("volume", 0))
   242:         except (TypeError, ValueError):
   243:             continue
   244:         score = heat_score(vol, volume, bool(info.get("news")))
   245:         row = dict(info)
   246:         row["heat_score"] = score
   247:         scored.append(row)
   248: 
   249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
   250:     return scored[:top_n]
   251: 
   252: 
   253: def decorrelate_pairs(
   254:     pairs: List[Dict[str, Any]],
   255:     corr: Dict[str, Dict[str, float]],
   256:     *,
   257:     threshold: float = 0.8,
   258:     top_n: int = 3,
   259: ) -> List[Dict[str, Any]]:
   260:     """Return top pairs while avoiding highly correlated symbols.
   261: 
   262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
   263:     pairs are considered too correlated when the absolute value of the
   264:     correlation exceeds ``threshold``.
   265:     """
   266: 
   267:     selected: List[Dict[str, Any]] = []
   268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
   269:         sym = info.get("symbol")
   270:         if not sym:
   271:             continue
   272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
   273:             selected.append(info)
   274:         if len(selected) >= top_n:
   275:             break
   276:     return selected


## scalp/positions/__init__.py (last modified: 2025-08-23 09:47:18)


## scalp/positions/state.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: from dataclasses import dataclass, field
     3: from enum import Enum, auto
     4: from typing import List, Optional
     5: import time
     6: 
     7: class PositionStatus(Enum):
     8:     IDLE = auto()
     9:     PENDING_ENTRY = auto()
    10:     OPEN = auto()
    11:     PENDING_EXIT = auto()
    12:     CLOSED = auto()
    13: 
    14: class PositionSide(Enum):
    15:     LONG = 1
    16:     SHORT = -1
    17: 
    18: @dataclass
    19: class Fill:
    20:     order_id: str
    21:     trade_id: str
    22:     price: float
    23:     qty: float
    24:     fee: float
    25:     ts: int
    26: 
    27: @dataclass
    28: class PositionState:
    29:     symbol: str
    30:     side: PositionSide
    31:     status: PositionStatus = PositionStatus.IDLE
    32:     entry_order_id: Optional[str] = None
    33:     exit_order_id: Optional[str] = None
    34:     req_qty: float = 0.0
    35:     filled_qty: float = 0.0
    36:     avg_entry_price: float = 0.0
    37:     avg_exit_price: float = 0.0
    38:     sl: Optional[float] = None
    39:     tp: Optional[float] = None
    40:     realized_pnl: float = 0.0
    41:     fees: float = 0.0
    42:     opened_ts: Optional[int] = None
    43:     closed_ts: Optional[int] = None
    44:     fills: List[Fill] = field(default_factory=list)
    45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
    46: 
    47:     def apply_fill_entry(self, f: Fill) -> None:
    48:         self.fills.append(f)
    49:         self.filled_qty += f.qty
    50:         # moyenne pondérée
    51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
    52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
    53:         self.fees += abs(f.fee)
    54:         if self.opened_ts is None:
    55:             self.opened_ts = f.ts
    56:         if self.filled_qty > 1e-12:
    57:             self.status = PositionStatus.OPEN
    58: 
    59:     def apply_fill_exit(self, f: Fill) -> None:
    60:         self.fills.append(f)
    61:         qty = min(self.filled_qty, f.qty)
    62:         # realized pnl sur la quantité fermée
    63:         if self.side == PositionSide.LONG:
    64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
    65:         else:
    66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
    67:         self.fees += abs(f.fee)
    68:         self.filled_qty = max(0.0, self.filled_qty - qty)
    69:         # moyenne de sortie indicative
    70:         closed_q = (self.req_qty - self.filled_qty)
    71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
    72:         if self.filled_qty <= 1e-12:
    73:             self.status = PositionStatus.CLOSED
    74:             self.closed_ts = f.ts
    75: 


## scalp/risk/__init__.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/risk/__init__.py
     2: from .manager import (
     3:     Caps,
     4:     compute_size,
     5:     calc_position_size,  # alias legacy
     6:     RiskManager,         # shim legacy
     7: )
     8: 
     9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]

## scalp/risk/manager.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/risk/manager.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any
     5: 
     6: @dataclass
     7: class Caps:
     8:     min_qty: float = 0.0
     9:     min_notional: float = 0.0
    10:     max_leverage: float = 20.0
    11: 
    12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
    13:     if not caps_by_symbol:
    14:         return Caps()
    15:     c = caps_by_symbol.get(symbol, {})
    16:     return Caps(
    17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
    18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
    19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
    20:     )
    21: 
    22: def compute_size(
    23:     *,
    24:     symbol: str,
    25:     price: float,
    26:     balance_cash: float,
    27:     risk_pct: float = 0.5,
    28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
    29: ) -> float:
    30:     """Sizing robuste avec gardes min_notional / min_qty."""
    31:     price = max(1e-9, float(price))
    32:     balance_cash = max(0.0, float(balance_cash))
    33:     risk_pct = max(0.0, float(risk_pct))
    34: 
    35:     notionnel = balance_cash * risk_pct
    36:     qty = notionnel / price
    37: 
    38:     caps = _get_caps(caps_by_symbol, symbol)
    39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
    40:         qty = caps.min_notional / price
    41:     if caps.min_qty > 0 and qty < caps.min_qty:
    42:         qty = caps.min_qty
    43:     return max(0.0, qty)
    44: 
    45: # --- Shims pour compatibilité ancienne API -----------------------------------
    46: 
    47: def calc_position_size(symbol: str, price: float, balance_cash: float,
    48:                        risk_pct: float = 0.5,
    49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
    50:     """Alias legacy → compute_size."""
    51:     return compute_size(
    52:         symbol=symbol, price=price, balance_cash=balance_cash,
    53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
    54:     )
    55: 
    56: class RiskManager:
    57:     """
    58:     Shim minimal compatible avec l'ancien code:
    59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
    60:       qty = rm.size(symbol, price, balance_cash)
    61:     """
    62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
    63:         self.risk_pct = float(risk_pct)
    64:         self.caps_by_symbol = caps_by_symbol or {}
    65: 
    66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
    67:         return compute_size(
    68:             symbol=symbol, price=price, balance_cash=balance_cash,
    69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
    70:         )

## scalp/selection/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Pair selection helpers for the Scalp bot.
     2: 
     3: This package exposes two utilities used during the preparation phase of the
     4: trading strategy:
     5: 
     6: ``scan_pairs``
     7:     Performs the first level market scan by filtering pairs based on volume,
     8:     spread and hourly volatility.
     9: 
    10: ``select_active_pairs``
    11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
    12:     crossover and a sufficiently high ATR.
    13: """
    14: 
    15: from .scanner import scan_pairs
    16: from .momentum import select_active_pairs
    17: 
    18: __all__ = ["scan_pairs", "select_active_pairs"]
    19: 


## scalp/selection/momentum.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities to select pairs exhibiting strong momentum."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List, Sequence
     6: 
     7: from ..metrics import calc_atr
     8: 
     9: 
    10: def ema(series: Sequence[float], window: int) -> List[float]:
    11:     """Simple exponential moving average implementation."""
    12: 
    13:     if window <= 1 or not series:
    14:         return list(series)
    15:     k = 2.0 / (window + 1.0)
    16:     out: List[float] = [float(series[0])]
    17:     prev = out[0]
    18:     for x in series[1:]:
    19:         prev = float(x) * k + prev * (1.0 - k)
    20:         out.append(prev)
    21:     return out
    22: 
    23: 
    24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
    26: 
    27:     if prev_fast <= prev_slow and last_fast > last_slow:
    28:         return 1
    29:     if prev_fast >= prev_slow and last_fast < last_slow:
    30:         return -1
    31:     return 0
    32: 
    33: 
    34: def _quantile(values: Sequence[float], q: float) -> float:
    35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
    36: 
    37:     if not values:
    38:         return 0.0
    39:     q = min(max(q, 0.0), 1.0)
    40:     vals = sorted(values)
    41:     idx = int((len(vals) - 1) * q)
    42:     return vals[idx]
    43: 
    44: 
    45: def select_active_pairs(
    46:     client: Any,
    47:     pairs: Sequence[Dict[str, Any]],
    48:     *,
    49:     interval: str = "Min5",
    50:     ema_fast: int = 20,
    51:     ema_slow: int = 50,
    52:     atr_period: int = 14,
    53:     atr_quantile: float = 0.5,
    54:     top_n: int = 5,
    55: ) -> List[Dict[str, Any]]:
    56:     """Return pairs with an EMA crossover and high ATR.
    57: 
    58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    59:     Among those candidates, the Average True Range is computed and only pairs
    60:     whose ATR is above the provided quantile are returned.  The resulting
    61:     dictionaries include an ``atr`` key for convenience.
    62:     """
    63: 
    64:     candidates: List[Dict[str, Any]] = []
    65:     atrs: List[float] = []
    66: 
    67:     for info in pairs:
    68:         sym = info.get("symbol")
    69:         if not sym:
    70:             continue
    71:         k = client.get_kline(sym, interval=interval)
    72:         kdata = k.get("data") if isinstance(k, dict) else {}
    73:         closes = kdata.get("close", [])
    74:         highs = kdata.get("high", [])
    75:         lows = kdata.get("low", [])
    76:         if len(closes) < max(ema_slow, atr_period) + 2:
    77:             continue
    78:         efast = ema(closes, ema_fast)
    79:         eslow = ema(closes, ema_slow)
    80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
    81:             continue
    82:         atr_val = calc_atr(highs, lows, closes, atr_period)
    83:         row = dict(info)
    84:         row["atr"] = atr_val
    85:         candidates.append(row)
    86:         atrs.append(atr_val)
    87: 
    88:     if not candidates:
    89:         return []
    90: 
    91:     threshold = _quantile(atrs, atr_quantile)
    92:     selected = [row for row in candidates if row["atr"] >= threshold]
    93:     selected.sort(key=lambda r: r["atr"], reverse=True)
    94:     return selected[:top_n]
    95: 
    96: 
    97: __all__ = ["select_active_pairs"]
    98: 


## scalp/selection/scanner.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities for scanning tradable pairs on the exchange."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List
     6: 
     7: 
     8: def scan_pairs(
     9:     client: Any,
    10:     *,
    11:     volume_min: float = 5_000_000,
    12:     max_spread_bps: float = 5.0,
    13:     min_hourly_vol: float = 0.0,
    14:     top_n: int = 40,
    15: ) -> List[Dict[str, Any]]:
    16:     """Return pairs satisfying basic liquidity and volatility filters.
    17: 
    18:     Parameters
    19:     ----------
    20:     client: Any
    21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    22:     volume_min: float, optional
    23:         Minimum 24h volume required to keep a pair.
    24:     max_spread_bps: float, optional
    25:         Maximum allowed bid/ask spread expressed in basis points.
    26:     min_hourly_vol: float, optional
    27:         Minimum volatility over the last hour expressed as ``(high - low) /
    28:         close``.  When set to ``0`` the filter is disabled.
    29:     top_n: int, optional
    30:         Limit the number of returned pairs.
    31:     """
    32: 
    33:     tick = client.get_ticker()
    34:     data = tick.get("data") if isinstance(tick, dict) else []
    35:     if not isinstance(data, list):
    36:         data = [data]
    37: 
    38:     eligible: List[Dict[str, Any]] = []
    39: 
    40:     for row in data:
    41:         sym = row.get("symbol")
    42:         if not sym:
    43:             continue
    44:         try:
    45:             vol = float(row.get("volume", 0))
    46:             bid = float(row.get("bidPrice", 0))
    47:             ask = float(row.get("askPrice", 0))
    48:         except (TypeError, ValueError):
    49:             continue
    50:         if vol < volume_min or bid <= 0 or ask <= 0:
    51:             continue
    52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
    53:         if spread_bps >= max_spread_bps:
    54:             continue
    55: 
    56:         if min_hourly_vol > 0:
    57:             k = client.get_kline(sym, interval="Min60")
    58:             kdata = k.get("data") if isinstance(k, dict) else {}
    59:             highs = kdata.get("high", [])
    60:             lows = kdata.get("low", [])
    61:             closes = kdata.get("close", [])
    62:             if not highs or not lows or not closes:
    63:                 continue
    64:             try:
    65:                 h = float(highs[-1])
    66:                 l = float(lows[-1])
    67:                 c = float(closes[-1])
    68:             except (TypeError, ValueError):
    69:                 continue
    70:             hourly_vol = (h - l) / c if c else 0.0
    71:             if hourly_vol < min_hourly_vol:
    72:                 continue
    73: 
    74:         eligible.append(row)
    75: 
    76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    77:     return eligible[:top_n]
    78: 
    79: 
    80: __all__ = ["scan_pairs"]
    81: 


## scalp/services/__init__.py (last modified: 2025-08-23 09:47:18)


## scalp/services/order_service.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: from dataclasses import dataclass
     3: from typing import Any, Dict, Optional, Protocol
     4: from scalp.trade_utils import extract_available_balance
     5: 
     6: 
     7: @dataclass
     8: class OrderCaps:
     9:     min_trade_usdt: float = 5.0
    10:     leverage: float = 1.0
    11: 
    12: 
    13: @dataclass
    14: class OrderRequest:
    15:     symbol: str
    16:     side: str
    17:     price: float
    18:     sl: float
    19:     tp: Optional[float]
    20:     risk_pct: float
    21: 
    22: 
    23: @dataclass
    24: class OrderResult:
    25:     accepted: bool
    26:     reason: str = ""
    27:     payload: Dict[str, Any] = None
    28:     order_id: Optional[str] = None
    29:     status: Optional[str] = None
    30:     avg_price: Optional[float] = None
    31:     filled_qty: Optional[float] = None
    32: 
    33: 
    34: class Exchange(Protocol):
    35:     def get_assets(self) -> Dict[str, Any]: ...
    36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
    37:     def place_order(
    38:         self,
    39:         symbol: str,
    40:         side: str,
    41:         quantity: float,
    42:         order_type: str,
    43:         price: Optional[float] = None,
    44:         stop_loss: Optional[float] = None,
    45:         take_profit: Optional[float] = None,
    46:     ) -> Dict[str, Any]: ...
    47: 
    48: 
    49: class OrderService:
    50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
    51:         self.exchange = exchange
    52:         self.caps = caps
    53: 
    54:     @staticmethod
    55:     def _abs(x: float) -> float:
    56:         return -x if x < 0 else x
    57: 
    58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
    59:         dist = self._abs(price - sl)
    60:         if dist <= 0:
    61:             return 0.0
    62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
    63:         return 0.0 if price <= 0 else (risk_usdt / dist)
    64: 
    65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
    66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
    67:         if qty <= 0:
    68:             return OrderResult(False, "invalid_size")
    69:         notional = qty * req.price
    70:         if notional < self.caps.min_trade_usdt:
    71:             return OrderResult(False, "under_min_notional")
    72:         assets = self.exchange.get_assets()
    73:         available = extract_available_balance(assets)
    74:         required_margin = notional / max(1.0, self.caps.leverage)
    75:         if available < required_margin:
    76:             return OrderResult(False, "insufficient_margin")
    77:         side = "BUY" if req.side == "long" else "SELL"
    78:         out = self.exchange.place_order(
    79:             symbol=req.symbol, side=side, quantity=qty,
    80:             order_type="limit", price=req.price,
    81:             stop_loss=req.sl, take_profit=req.tp
    82:         )
    83:         # extraire infos utiles
    84:         oid = None; status = None; avg = None; filled = None
    85:         try:
    86:             data = out.get("data") if isinstance(out, dict) else out
    87:             if isinstance(data, dict):
    88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
    89:                 status = (data.get("status") or data.get("state") or "new").lower()
    90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
    91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
    92:         except Exception:
    93:             pass
    94:         return OrderResult(True, "", out, oid, status, avg, filled)


## scalp/services/utils.py (last modified: 2025-08-23 09:47:18)
     1: # scalp/services/utils.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import inspect
     6: import os
     7: import time
     8: from typing import Any, Callable, Optional
     9: 
    10: QUIET = os.getenv("QUIET", "0") == "1"
    11: 
    12: 
    13: async def safe_call(
    14:     fn: Callable[[], Any],
    15:     *,
    16:     label: str = "call",
    17:     backoff_start: float = 1.0,
    18:     backoff_max: float = 30.0,
    19:     running_flag: Optional[Callable[[], bool]] = None,
    20: ) -> Any:
    21:     """
    22:     Enveloppe de sécurité commune (sync/async) avec retry exponentiel.
    23:     - fn : lambda sans arg qui retourne un objet ou une coroutine
    24:     - running_flag : fonction booléenne pour sortir proprement
    25:     """
    26:     delay = backoff_start
    27:     while True:
    28:         if running_flag and not running_flag():
    29:             return None
    30:         try:
    31:             res = fn()
    32:             if inspect.iscoroutine(res):
    33:                 return await res
    34:             return res
    35:         except asyncio.CancelledError:
    36:             raise
    37:         except Exception as e:
    38:             if not QUIET:
    39:                 print(f"[safe:{label}] {e!r} -> retry in {delay:.1f}s")
    40:             await asyncio.sleep(delay)
    41:             delay = min(backoff_max, delay * 1.7)
    42: 
    43: 
    44: async def heartbeat_task(get_running: Callable[[], bool], period: float = 15.0) -> None:
    45:     """Heartbeat périodique (silencieux si QUIET=1)."""
    46:     while get_running():
    47:         if not QUIET:
    48:             print("[heartbeat] alive")
    49:         await asyncio.sleep(period)
    50: 
    51: 
    52: async def log_stats_task(
    53:     get_running: Callable[[], bool],
    54:     *,
    55:     get_ticks: Callable[[], int],
    56:     get_pairs: Callable[[], int],
    57:     period: float = 30.0,
    58: ) -> None:
    59:     """Stats périodiques (ralenties et/ou masquées si QUIET=1)."""
    60:     last_t = time.time()
    61:     last_ticks = get_ticks()
    62:     while get_running():
    63:         await asyncio.sleep(120.0 if QUIET else period)
    64:         now = time.time()
    65:         ticks = get_ticks()
    66:         dt = max(1.0, now - last_t)
    67:         d_ticks = max(0, ticks - last_ticks)
    68:         rate = d_ticks / dt
    69:         if not QUIET:
    70:             print(f"[stats] ticks_total={ticks} (+{d_ticks}) rate={rate:.1f}/s | pairs={get_pairs()}")
    71:         last_t, last_ticks = now, ticks

## scalp/strategy.py (last modified: 2025-08-23 09:47:18)
     1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
     2: 
     3: This module implements a minimal but functional version of the strategy
     4: outlined in the project specification.  The focus is on pure Python
     5: implementations so the logic can easily be unit tested without requiring
     6: external services or heavy third‑party dependencies.
     7: 
     8: The strategy is deliberately stateless; functions operate on passed data and
     9: return simple data structures.  This makes it easy to plug the logic into
    10: real‑time trading loops or backtest engines.
    11: """
    12: 
    13: from __future__ import annotations
    14: 
    15: from dataclasses import dataclass
    16: from typing import Sequence, List, Dict, Optional, Tuple, Any
    17: 
    18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
    19: from .risk import calc_position_size
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Helpers
    23: # ---------------------------------------------------------------------------
    24: 
    25: def ema(series: Sequence[float], window: int) -> List[float]:
    26:     """Return the exponential moving average of *series*.
    27: 
    28:     The first value is the raw input to remain consistent with most trading
    29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
    30:     returned unchanged.
    31:     """
    32: 
    33:     if window <= 1 or not series:
    34:         return list(series)
    35:     k = 2.0 / (window + 1.0)
    36:     out: List[float] = [float(series[0])]
    37:     prev = out[0]
    38:     for x in series[1:]:
    39:         prev = float(x) * k + prev * (1.0 - k)
    40:         out.append(prev)
    41:     return out
    42: 
    43: def vwap(highs: Sequence[float], lows: Sequence[float],
    44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
    45:     """Compute the volume weighted average price (VWAP).
    46: 
    47:     Parameters
    48:     ----------
    49:     highs, lows, closes, volumes: Sequence[float]
    50:         Matching sequences for the period considered.
    51:     """
    52: 
    53:     tp_vol = 0.0
    54:     vol_sum = 0.0
    55:     for h, low, c, v in zip(highs, lows, closes, volumes):
    56:         tp = (h + low + c) / 3.0
    57:         tp_vol += tp * v
    58:         vol_sum += v
    59:     return tp_vol / vol_sum if vol_sum else 0.0
    60: 
    61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    62:     """Return the On Balance Volume (OBV) series."""
    63: 
    64:     if not closes:
    65:         return []
    66:     out: List[float] = [0.0]
    67:     for i in range(1, len(closes)):
    68:         if closes[i] > closes[i - 1]:
    69:             out.append(out[-1] + volumes[i])
    70:         elif closes[i] < closes[i - 1]:
    71:             out.append(out[-1] - volumes[i])
    72:         else:
    73:             out.append(out[-1])
    74:     return out
    75: 
    76: 
    77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    78:     """Detect a crossing between two series.
    79: 
    80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    81:     ``0`` otherwise.
    82:     """
    83: 
    84:     if prev_fast <= prev_slow and last_fast > last_slow:
    85:         return 1
    86:     if prev_fast >= prev_slow and last_fast < last_slow:
    87:         return -1
    88:     return 0
    89: 
    90: 
    91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    92:     """Compute order book imbalance.
    93: 
    94:     The value is normalised between ``-1`` and ``1`` where positive numbers
    95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
    96:     """
    97: 
    98:     total = bid_vol + ask_vol
    99:     return (bid_vol - ask_vol) / total if total else 0.0
   100: 
   101: 
   102: def swing_levels(
   103:     highs: Sequence[float], lows: Sequence[float], lookback: int
   104: ) -> Tuple[float, float]:
   105:     """Return the most recent swing high and swing low.
   106: 
   107:     ``lookback`` defines how many completed candles are inspected.  The current
   108:     candle is excluded to avoid look‑ahead bias.
   109:     """
   110: 
   111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
   112:         return highs[-1], lows[-1]
   113:     high = max(highs[-lookback - 1 : -1])
   114:     low = min(lows[-lookback - 1 : -1])
   115:     return high, low
   116: 
   117: # ---------------------------------------------------------------------------
   118: # Pair selection
   119: # ---------------------------------------------------------------------------
   120: 
   121: # The first and second level pair selection helpers now live in
   122: # :mod:`scalp.selection`.  They are re-exported here for backward compatibility
   123: # and to keep the public API unchanged.
   124: from .selection.scanner import scan_pairs  # noqa: E402
   125: from .selection.momentum import select_active_pairs  # noqa: E402
   126: 
   127: # ---------------------------------------------------------------------------
   128: # Signal generation
   129: # ---------------------------------------------------------------------------
   130: 
   131: @dataclass
   132: class Signal:
   133:     """Trading signal with risk parameters."""
   134: 
   135:     symbol: str
   136:     side: int  # 1 for long, -1 for short
   137:     entry: float
   138:     sl: float
   139:     tp1: float
   140:     tp2: float
   141:     qty: float = 0.0
   142:     score: Optional[float] = None
   143:     quality: Optional[float] = None
   144:     reasons: Optional[List[str]] = None
   145: 
   146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
   147:         if isinstance(self.side, str):
   148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
   149: 
   150:     @property
   151:     def price(self) -> float:
   152:         return self.entry
   153: 
   154: 
   155: def _generate_signal(
   156:     symbol: str,
   157:     ohlcv: Dict[str, Sequence[float]],
   158:     *,
   159:     equity: float,
   160:     risk_pct: float,
   161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
   162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
   163:     order_book: Optional[Dict[str, float]] = None,
   164:     tick_ratio_buy: Optional[float] = None,
   165:     atr_disable_pct: float = 0.2,
   166:     atr_reduce_pct: float = 2.0,
   167:     swing_lookback: int = 5,
   168:     macd_fast: int = 12,
   169:     macd_slow: int = 26,
   170:     macd_signal: int = 9,
   171:     trend_ema_period: int = 200,
   172: ) -> Optional[Signal]:
   173:     """Return a trading :class:`Signal` if conditions are met.
   174: 
   175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
   176:     sequences ordered from oldest to newest.  The function checks the following
   177:     rules:
   178: 
   179:     * price positioned relative to VWAP and EMA20/EMA50 trend
   180:     * RSI(14) crossing key levels (40/60)
   181:     * OBV rising or high short‑term volume
   182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
   183:     * Micro‑structure breakout of last swing high/low
   184:     * MACD trend filter
   185:     * Long‑term trend via configurable EMA filter
   186:     * Order book imbalance and tape filters
   187:     * Dynamic ATR‑based stop‑loss and take‑profit
   188:     * Position sizing via ``calc_position_size``
   189:     """
   190: 
   191:     closes = [float(x) for x in ohlcv.get("close", [])]
   192:     highs = [float(x) for x in ohlcv.get("high", [])]
   193:     lows = [float(x) for x in ohlcv.get("low", [])]
   194:     vols = [float(x) for x in ohlcv.get("volume", [])]
   195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
   196:         return None
   197: 
   198:     price = closes[-1]
   199:     ema20 = ema(closes, 20)
   200:     ema50 = ema(closes, 50)
   201:     ema_trend = ema(closes, trend_ema_period)
   202:     v = vwap(highs, lows, closes, vols)
   203:     obv_series = obv(closes, vols)
   204:     obv_rising = obv_series[-1] > obv_series[-2]
   205:     vol_last3 = sum(vols[-3:])
   206:     vol_ma20 = sum(vols[-20:]) / 20.0
   207:     vol_rising = vol_last3 > vol_ma20
   208: 
   209:     macd_val, macd_sig, _ = calc_macd(
   210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
   211:     )
   212: 
   213:     # Multi timeframe filters -------------------------------------------------
   214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
   215:     if ohlcv_1h:
   216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
   217:         if len(h_closes) >= 52:
   218:             h_ema50 = ema(h_closes, 50)
   219:             if len(h_ema50) >= 2:
   220:                 slope = h_ema50[-1] - h_ema50[-2]
   221:                 if slope > 0:
   222:                     trend_dir = 1
   223:                 elif slope < 0:
   224:                     trend_dir = -1
   225: 
   226:     rsi_15 = None
   227:     if ohlcv_15m:
   228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
   229:         if len(m_closes) >= 15:
   230:             rsi_15 = calc_rsi(m_closes, 14)
   231: 
   232:     # RSI crossing logic (5m)
   233:     rsi_curr = calc_rsi(closes[-15:], 14)
   234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
   235: 
   236:     atr = calc_atr(highs, lows, closes, 14)
   237:     atr_pct = atr / price * 100.0 if price else 0.0
   238:     if atr_pct < atr_disable_pct:
   239:         return None
   240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
   241: 
   242:     sl_dist = 0.5 * atr
   243:     tp1_dist = 1.0 * atr
   244:     tp2_dist = 1.5 * atr
   245: 
   246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
   247: 
   248:     obi_ok_long = obi_ok_short = True
   249:     if order_book is not None:
   250:         bid = float(order_book.get("bid_vol_aggreg", 0))
   251:         ask = float(order_book.get("ask_vol_aggreg", 0))
   252:         obi = order_book_imbalance(bid, ask)
   253:         obi_ok_long = obi > 0.1
   254:         obi_ok_short = obi < -0.1
   255: 
   256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
   257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
   258: 
   259:     def _size(dist: float) -> float:
   260:         return calc_position_size(equity, risk_pct, dist) * size_mult
   261:     weights = {
   262:         "ema": 15.0,
   263:         "macd": 15.0,
   264:         "vwap": 15.0,
   265:         "rsi": 15.0,
   266:         "obv": 10.0,
   267:         "swing": 10.0,
   268:         "atr": 20.0,
   269:     }
   270: 
   271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
   272: 
   273:     long_score = atr_score
   274:     long_reasons: List[str] = []
   275:     if price > v:
   276:         long_score += weights["vwap"]
   277:         long_reasons.append("vwap")
   278:     if ema20[-1] > ema50[-1]:
   279:         long_score += weights["ema"]
   280:         long_reasons.append("ema")
   281:     if rsi_prev <= 40 < rsi_curr:
   282:         long_score += weights["rsi"]
   283:         long_reasons.append("rsi")
   284:     if macd_val > macd_sig:
   285:         long_score += weights["macd"]
   286:         long_reasons.append("macd")
   287:     if obv_rising or vol_rising:
   288:         long_score += weights["obv"]
   289:         long_reasons.append("obv")
   290:     if price > swing_high:
   291:         long_score += weights["swing"]
   292:         long_reasons.append("swing")
   293: 
   294:     short_score = atr_score
   295:     short_reasons: List[str] = []
   296:     if price < v:
   297:         short_score += weights["vwap"]
   298:         short_reasons.append("vwap")
   299:     if ema20[-1] < ema50[-1]:
   300:         short_score += weights["ema"]
   301:         short_reasons.append("ema")
   302:     if rsi_prev >= 60 > rsi_curr:
   303:         short_score += weights["rsi"]
   304:         short_reasons.append("rsi")
   305:     if macd_val < macd_sig:
   306:         short_score += weights["macd"]
   307:         short_reasons.append("macd")
   308:     if obv_series[-1] < obv_series[-2] or vol_rising:
   309:         short_score += weights["obv"]
   310:         short_reasons.append("obv")
   311:     if price < swing_low:
   312:         short_score += weights["swing"]
   313:         short_reasons.append("swing")
   314: 
   315:     side: Optional[str] = None
   316:     score: float = 0.0
   317:     reasons: List[str] = []
   318:     if (
   319:         long_score >= short_score
   320:         and long_score > 0
   321:         and macd_val > macd_sig
   322:         and obi_ok_long
   323:         and tick_ok_long
   324:         and trend_dir >= 0
   325:         and price > ema_trend[-1]
   326:     ):
   327:         side = "long"
   328:         score = long_score
   329:         reasons = long_reasons
   330:         sl = price - sl_dist
   331:         tp1 = price + tp1_dist
   332:         tp2 = price + tp2_dist
   333:     elif (
   334:         short_score > long_score
   335:         and short_score > 0
   336:         and macd_val < macd_sig
   337:         and obi_ok_short
   338:         and tick_ok_short
   339:         and trend_dir <= 0
   340:         and price < ema_trend[-1]
   341:     ):
   342:         side = "short"
   343:         score = short_score
   344:         reasons = short_reasons
   345:         sl = price + sl_dist
   346:         tp1 = price - tp1_dist
   347:         tp2 = price - tp2_dist
   348:     else:
   349:         return None
   350: 
   351:     qty = _size(sl_dist)
   352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
   353: 
   354: 
   355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
   356:     if "config" in kwargs:
   357:         config = kwargs.pop("config")
   358:         symbol = kwargs.pop("symbol", None)
   359:         ohlcv = kwargs.pop("ohlcv", None)
   360:         if ohlcv is None:
   361:             raise TypeError("ohlcv argument required")
   362:         return _generate_signal(
   363:             symbol or ohlcv.get("symbol", ""),
   364:             ohlcv,
   365:             equity=kwargs.pop("equity", 0.0),
   366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
   367:             **kwargs,
   368:         )
   369:     return _generate_signal(*args, **kwargs)
   370: 
   371: # ---------------------------------------------------------------------------
   372: # Backtesting utilities
   373: # ---------------------------------------------------------------------------
   374: 
   375: def max_drawdown(equity_curve: Sequence[float]) -> float:
   376:     peak = equity_curve[0]
   377:     mdd = 0.0
   378:     for x in equity_curve:
   379:         if x > peak:
   380:             peak = x
   381:         dd = (peak - x) / peak * 100.0
   382:         if dd > mdd:
   383:             mdd = dd
   384:     return mdd
   385: 
   386: def backtest(
   387:     trades: Sequence[Dict[str, Any]],
   388:     *,
   389:     equity_start: float = 1_000.0,
   390:     fee_rate: float = 0.0,
   391: ) -> Dict[str, float]:
   392:     """Evaluate a list of trade dictionaries.
   393: 
   394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
   395:     optionally include ``duration`` in minutes.  Results are aggregated into
   396:     common performance metrics to quickly evaluate the strategy.
   397:     """
   398: 
   399:     equity = equity_start
   400:     equity_curve = [equity]
   401:     pnl_pct_list: List[float] = []
   402:     wins = losses = 0
   403:     win_sum = loss_sum = 0.0
   404:     total_duration = 0.0
   405: 
   406:     for t in trades:
   407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
   408:         pnl_pct_list.append(pnl_pct)
   409:         if pnl_pct >= 0:
   410:             wins += 1
   411:             win_sum += pnl_pct
   412:         else:
   413:             losses += 1
   414:             loss_sum += pnl_pct
   415:         equity *= 1 + pnl_pct / 100.0
   416:         equity_curve.append(equity)
   417:         total_duration += float(t.get("duration", 0.0))
   418: 
   419:     pnl_pct_total = sum(pnl_pct_list)
   420:     pnl_usdt = equity - equity_start
   421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
   422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
   423:     mdd = max_drawdown(equity_curve)
   424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
   425:     exposure = total_duration  # in minutes, callers can normalise if desired
   426:     # Sharpe ratio based on per-trade returns
   427:     if len(pnl_pct_list) > 1:
   428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
   429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
   430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
   431:     else:
   432:         sharpe = 0.0
   433: 
   434:     return {
   435:         "pnl_usdt": pnl_usdt,
   436:         "pnl_pct": pnl_pct_total,
   437:         "profit_factor": profit_factor,
   438:         "winrate": winrate,
   439:         "max_drawdown": mdd,
   440:         "avg_trade_time": avg_trade_time,
   441:         "exposure": exposure,
   442:         "sharpe": sharpe,
   443:     }


## scalp/telegram_bot.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: 
     3: import logging
     4: import os
     5: from typing import Any, Dict, Optional
     6: 
     7: try:  # pragma: no cover - optional dependency
     8:     import requests as _requests
     9:     requests = _requests
    10: except Exception:  # pragma: no cover
    11:     class _Requests:
    12:         def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
    13:             raise RuntimeError("requests.get unavailable")
    14: 
    15:         def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
    16:             raise RuntimeError("requests.post unavailable")
    17: 
    18:     requests = _Requests()  # type: ignore[assignment]
    19: 
    20: 
    21: class TelegramBot:
    22:     """Minimal Telegram bot using the HTTP API.
    23: 
    24: 
    25:     The bot exposes a simple *menu* based interface with clickable buttons so
    26:     users do not have to remember text commands.  A sub-menu lets the user set
    27:     the risk level.
    28: 
    29:     """
    30: 
    31:     def __init__(
    32:         self,
    33:         token: str,
    34:         chat_id: str,
    35:         client: Any,
    36:         config: Dict[str, Any],
    37:         risk_mgr: Any,
    38:         *,
    39:         requests_module: Any = requests,
    40:     ) -> None:
    41:         self.token = token
    42:         self.chat_id = str(chat_id)
    43:         self.client = client
    44:         self.config = config
    45:         self.risk_mgr = risk_mgr
    46:         self.requests = requests_module
    47:         self.last_update_id: Optional[int] = None
    48:         self.stop_requested = False
    49: 
    50: 
    51:         self.main_keyboard = [
    52:             [{"text": "Positions ouvertes", "callback_data": "positions"}],
    53:             [{"text": "Update Cryptos", "callback_data": "update"}],
    54:             [{"text": "Réglages", "callback_data": "settings"}],
    55:             [{"text": "Arrêt bot", "callback_data": "shutdown"}],
    56:         ]
    57:         self.settings_keyboard = [
    58:             [{"text": "Stop trade", "callback_data": "stop"}],
    59:             [{"text": "Réglage risk", "callback_data": "risk"}],
    60:             [{"text": "Nb positions", "callback_data": "maxpos"}],
    61:             [{"text": "Reset risk", "callback_data": "reset_risk"}],
    62:             [{"text": "Reset total", "callback_data": "reset_all"}],
    63:             [{"text": "Retour", "callback_data": "back"}],
    64:         ]
    65:         self.risk_keyboard = [
    66:             [
    67:                 {"text": "🟢", "callback_data": "risk_green"},
    68:                 {"text": "🟠", "callback_data": "risk_orange"},
    69:                 {"text": "🔴", "callback_data": "risk_red"},
    70:             ],
    71:             [{"text": "Retour", "callback_data": "back"}],
    72:         ]
    73:         self.maxpos_keyboard = [
    74:             [
    75:                 {"text": "1", "callback_data": "maxpos_1"},
    76:                 {"text": "2", "callback_data": "maxpos_2"},
    77:                 {"text": "3", "callback_data": "maxpos_3"},
    78:             ],
    79:             [
    80:                 {"text": "4", "callback_data": "maxpos_4"},
    81:                 {"text": "5", "callback_data": "maxpos_5"},
    82:             ],
    83:             [{"text": "Retour", "callback_data": "back"}],
    84:         ]
    85: 
    86:         # Show menu on startup with zero PnL session
    87:         self.send_main_menu(0.0)
    88: 
    89: 
    90:     def _base_symbol(self, symbol: str) -> str:
    91:         sym = symbol.replace("_", "")
    92:         return sym[:-4] if sym.endswith("USDT") else sym
    93: 
    94:     def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
    95:         pos = self.client.get_positions() or {}
    96:         buttons: list[list[Dict[str, str]]] = []
    97:         for p in pos.get("data") or []:
    98:             sym = p.get("symbol")
    99:             if not sym:
   100:                 continue
   101:             base = self._base_symbol(sym)
   102:             # Use the full symbol in the callback so we can properly
   103:             # identify the position to close.  Only the label shows the
   104:             # base asset to keep the interface concise.
   105:             buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
   106:         buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
   107:         buttons.append([{"text": "Retour", "callback_data": "back"}])
   108:         return buttons
   109: 
   110: 
   111:     def _menu_text(self, session_pnl: float) -> str:
   112:         assets = self.client.get_assets() or {}
   113:         equity = 0.0
   114:         for row in assets.get("data") or []:
   115:             if row.get("currency") == "USDT":
   116:                 try:
   117:                     equity = float(row.get("equity", 0.0))
   118:                 except Exception:
   119:                     equity = 0.0
   120:                 break
   121:         return (
   122:             f"Solde: {equity:.2f} USDT\n"
   123:             f"PnL session: {session_pnl:.2f} USDT\n"
   124:             f"Positions max: {self.risk_mgr.max_positions}\n"
   125:             f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
   126:             "Choisissez une option:"
   127:         )
   128: 
   129:     def send_main_menu(self, session_pnl: float) -> None:
   130:         self.send(self._menu_text(session_pnl), self.main_keyboard)
   131: 
   132:     def update_pairs(self) -> None:
   133:         from bot import update as _update  # lazy import to avoid cycle
   134:         _update(self.client, top_n=40)
   135: 
   136:     # ------------------------------------------------------------------
   137:     def _api_url(self, method: str) -> str:
   138:         return f"https://api.telegram.org/bot{self.token}/{method}"
   139: 
   140: 
   141:     def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
   142:         payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
   143:         if keyboard:
   144:             payload["reply_markup"] = {"inline_keyboard": keyboard}
   145: 
   146:         try:  # pragma: no cover - network
   147:             self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
   148:         except Exception as exc:  # pragma: no cover - best effort
   149:             logging.error("Telegram send error: %s", exc)
   150: 
   151:     def answer_callback(self, cb_id: str) -> None:
   152:         payload = {"callback_query_id": cb_id}
   153:         try:  # pragma: no cover - network
   154:             self.requests.post(
   155:                 self._api_url("answerCallbackQuery"), json=payload, timeout=5
   156:             )
   157:         except Exception as exc:  # pragma: no cover - best effort
   158:             logging.error("Telegram answerCallback error: %s", exc)
   159: 
   160: 
   161:     # ------------------------------------------------------------------
   162:     def fetch_updates(self) -> list[Dict[str, Any]]:
   163:         params: Dict[str, Any] = {}
   164:         if self.last_update_id is not None:
   165:             params["offset"] = self.last_update_id + 1
   166:         try:  # pragma: no cover - network
   167:             r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
   168:             r.raise_for_status()
   169:             data = r.json()
   170:         except Exception as exc:  # pragma: no cover - best effort
   171:             logging.error("Telegram getUpdates error: %s", exc)
   172:             return []
   173:         updates = data.get("result", [])
   174:         if updates:
   175:             self.last_update_id = updates[-1].get("update_id")
   176:         return updates
   177: 
   178:     # ------------------------------------------------------------------
   179:     def handle_updates(self, session_pnl: float) -> None:
   180:         for update in self.fetch_updates():
   181: 
   182:             callback = update.get("callback_query")
   183:             if callback:
   184:                 if str(callback.get("from", {}).get("id")) != self.chat_id:
   185:                     continue
   186:                 data = callback.get("data", "")
   187:                 reply, kb = self.handle_callback(data, session_pnl)
   188:                 if reply:
   189:                     self.send(reply, kb)
   190:                 cb_id = callback.get("id")
   191:                 if cb_id:
   192:                     self.answer_callback(cb_id)
   193:                 continue
   194: 
   195: 
   196:             msg = update.get("message") or {}
   197:             chat = msg.get("chat") or {}
   198:             if str(chat.get("id")) != self.chat_id:
   199:                 continue
   200: 
   201:             # Any text message triggers the main menu with balance and PnL
   202:             self.send_main_menu(session_pnl)
   203: 
   204:     # ------------------------------------------------------------------
   205:     def handle_callback(
   206:         self, data: str, session_pnl: float
   207:     ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
   208:         if not data:
   209:             return None, None
   210:         if data == "balance":
   211:             assets = self.client.get_assets() or {}
   212:             equity = 0.0
   213:             for row in assets.get("data") or []:
   214:                 if row.get("currency") == "USDT":
   215:                     try:
   216:                         equity = float(row.get("equity", 0.0))
   217:                     except Exception:
   218:                         equity = 0.0
   219:                     break
   220: 
   221:             return f"Solde: {equity:.2f} USDT", self.main_keyboard
   222:         if data == "positions":
   223:             pos = self.client.get_positions() or {}
   224:             lines = []
   225:             for p in pos.get("data") or []:
   226:                 symbol = p.get("symbol", "")
   227:                 base = self._base_symbol(symbol)
   228:                 side = p.get("side")
   229:                 vol = p.get("vol")
   230:                 pnl = p.get("pnl_usdt")
   231:                 if pnl is None:
   232:                     pnl = p.get("pnl_usd")
   233:                 if pnl is None:
   234:                     pnl = p.get("pnl")
   235:                 pnl_pct = p.get("pnl_pct_on_margin")
   236:                 if pnl_pct is None:
   237:                     pnl_pct = p.get("pnl_pct")
   238:                 line = f"{base} {side} {vol}"
   239:                 if pnl is not None and pnl_pct is not None:
   240:                     line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
   241:                 lines.append(line)
   242:             if not lines:
   243: 
   244:                 return "Aucune position ouverte", self.main_keyboard
   245:             return "Positions:\n" + "\n".join(lines), self.main_keyboard
   246:         if data == "pnl":
   247:             return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
   248:         if data == "risk":
   249:             return "Choisissez le niveau de risque:", self.risk_keyboard
   250:         if data == "settings":
   251:             return "Réglages:", self.settings_keyboard
   252:         if data == "maxpos":
   253:             return "Choisissez le nombre de positions:", self.maxpos_keyboard
   254:         if data == "reset_risk":
   255:             try:
   256:                 self.risk_mgr.reset_day()
   257:                 return "Risque réinitialisé", self.settings_keyboard
   258:             except Exception:
   259:                 return "Erreur reset risque", self.settings_keyboard
   260:         if data == "update":
   261:             try:
   262:                 self.update_pairs()
   263:                 return "Liste cryptos mise à jour", self.main_keyboard
   264:             except Exception:
   265:                 return "Erreur mise à jour", self.main_keyboard
   266:         if data.startswith("risk"):
   267:             mapping = {
   268:                 "risk_green": 1,
   269:                 "risk_orange": 2,
   270:                 "risk_red": 3,
   271:             }
   272:             lvl = mapping.get(data)
   273:             if lvl:
   274:                 self.config["RISK_LEVEL"] = lvl
   275:                 return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
   276:             return "Niveau de risque inchangé", self.main_keyboard
   277: 
   278:         if data.startswith("maxpos_"):
   279:             try:
   280:                 lvl = int(data.split("_", 1)[1])
   281:             except Exception:
   282:                 lvl = None
   283:             if lvl:
   284:                 self.config["MAX_POSITIONS"] = lvl
   285:                 self.risk_mgr.max_positions = lvl
   286:                 return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
   287:             return "Nombre de positions inchangé", self.main_keyboard
   288: 
   289:         if data == "reset_all":
   290:             try:
   291:                 self.client.close_all_positions()
   292:                 self.risk_mgr.reset_day()
   293:                 return "Positions et risque réinitialisés", self.settings_keyboard
   294:             except Exception:
   295:                 return "Erreur lors du reset total", self.settings_keyboard
   296: 
   297:         if data == "stop":
   298:             pos = self.client.get_positions() or {}
   299:             if not (pos.get("data") or []):
   300:                 return "Aucune crypto sélectionnée", self.settings_keyboard
   301:             return "Choisissez la position à fermer:", self._build_stop_keyboard()
   302:         if data == "stop_all":
   303:             try:
   304:                 self.client.close_all_positions()
   305:                 return "Toutes les positions fermées", self.settings_keyboard
   306:             except Exception:
   307:                 return "Erreur arrêt trade", self.settings_keyboard
   308:         if data.startswith("stop_"):
   309:             sym = data[5:]
   310:             try:
   311:                 self.client.close_position(sym)
   312:                 return f"Position {sym} fermée", self.settings_keyboard
   313:             except Exception:
   314:                 return f"Erreur arrêt trade {sym}", self.settings_keyboard
   315: 
   316:         if data == "shutdown":
   317:             self.stop_requested = True
   318:             return "Arrêt du bot demandé", self.main_keyboard
   319: 
   320:         if data == "back":
   321:             return self._menu_text(session_pnl), self.main_keyboard
   322:         return None, None
   323: 
   324: 
   325: def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
   326:     token = os.getenv("TELEGRAM_BOT_TOKEN")
   327:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
   328:     if token and chat_id:
   329:         return TelegramBot(token, chat_id, client, config, risk_mgr)
   330:     return None


## scalp/trade_utils.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities for risk analysis and position sizing."""
     2: from __future__ import annotations
     3: 
     4: import logging
     5: import math
     6: from typing import Any, Dict, List, Optional, Tuple
     7: 
     8: from scalp.bot_config import CONFIG
     9: 
    10: 
    11: def get_contract_size(contract_detail: Dict[str, Any], symbol: Optional[str] = None) -> float:
    12:     """Return the contract size for ``symbol``.
    13: 
    14:     Bitget may expose the contract unit as ``contractSize`` or
    15:     ``sizeMultiplier`` depending on the endpoint.  This helper normalises the
    16:     two so the rest of the code base has a single source of truth for
    17:     conversions between contract volume and notional value.
    18:     """
    19: 
    20:     symbol = symbol or CONFIG.get("SYMBOL")
    21:     data = contract_detail.get("data") if isinstance(contract_detail, dict) else None
    22:     if isinstance(data, list):
    23:         contract = next((c for c in data if c and c.get("symbol") == symbol), data[0] if data else {})
    24:     else:
    25:         contract = data or {}
    26:     size = contract.get("contractSize") or contract.get("sizeMultiplier") or 1.0
    27:     try:
    28:         return float(size)
    29:     except (TypeError, ValueError):
    30:         return 1.0
    31: 
    32: 
    33: # Backwards compatibility: old name used internally/tests
    34: extract_contract_size = get_contract_size
    35: 
    36: 
    37: def notional(price: float, vol: float, contract_size: float) -> float:
    38:     """Return the notional value in USDT for ``vol`` contracts."""
    39: 
    40:     return float(price) * float(vol) * float(contract_size)
    41: 
    42: 
    43: def required_margin(
    44:     notion: float,
    45:     lev: float,
    46:     fee_rate: float,
    47:     buffer: float = 0.03,
    48: ) -> float:
    49:     """Return estimated required margin including fees and buffer.
    50: 
    51:     The margin is the sum of the collateral required by the leverage and the
    52:     estimated taker fees for both sides of the trade.  ``buffer`` adds an extra
    53:     safety margin to account for slight price movements between order placement
    54:     and execution.
    55:     """
    56: 
    57:     lev = max(float(lev), 1.0)
    58:     fee = float(fee_rate)
    59:     return (notion / lev + fee * notion) * (1.0 + buffer)
    60: 
    61: 
    62: def extract_available_balance(assets: Dict[str, Any], currency: str = "USDT") -> float:
    63:     """Return available balance for ``currency`` from Bitget assets payload.
    64: 
    65:     The exchange may expose multiple fields depending on account mode and API
    66:     version.  We iterate through the known keys, returning the first positive
    67:     value encountered.  ``0.0`` is returned when no usable balance can be
    68:     determined.  The helper only falls back to the more generic ``equity``
    69:     fields when the granular balance keys are absent; if the exchange reports
    70:     them with a ``0`` value we honour that and return ``0.0`` to avoid sizing
    71:     orders against unavailable funds.
    72:     """
    73: 
    74:     for row in assets.get("data", []):
    75:         if row.get("currency") != currency:
    76:             continue
    77: 
    78:         has_balance_field = False
    79:         for key in (
    80:             "available",
    81:             "availableBalance",
    82:             "availableMargin",
    83:             "cashBalance",
    84:         ):
    85:             if key in row:
    86:                 has_balance_field = True
    87:             val = row.get(key)
    88:             if val is None:
    89:                 continue
    90:             try:
    91:                 eq = float(val)
    92:             except (TypeError, ValueError):
    93:                 continue
    94:             if eq > 0:
    95:                 return eq
    96: 
    97:         if has_balance_field:
    98:             return 0.0
    99: 
   100:         for key in ("equity", "usdtEquity"):
   101:             val = row.get(key)
   102:             if val is None:
   103:                 continue
   104:             try:
   105:                 eq = float(val)
   106:             except (TypeError, ValueError):
   107:                 continue
   108:             if eq > 0:
   109:                 return eq
   110:         break
   111:     return 0.0
   112: 
   113: 
   114: def compute_execution_metrics(
   115:     fills: List[Dict[str, Any]], *, contract_size: float = 1.0
   116: ) -> Tuple[float, float, float]:
   117:     """Aggregate Bitget fills into execution metrics.
   118: 
   119:     Parameters
   120:     ----------
   121:     fills:
   122:         Sequence of fill dictionaries containing price and quantity.  The
   123:         helper accepts the common Bitget keys ``fillPrice``/``price`` and
   124:         ``fillQty``/``size``/``vol`` for the executed quantity.  Unknown or
   125:         malformed entries are ignored.
   126:     contract_size:
   127:         Multiplier to convert contract volume into notional value.
   128: 
   129:     Returns
   130:     -------
   131:     tuple
   132:         ``(exec_qty, exec_notional, avg_exec_price)`` where quantities are in
   133:         contract units and notional is expressed in quote currency.
   134:     """
   135: 
   136:     exec_qty = 0.0
   137:     exec_notional = 0.0
   138:     for f in fills:
   139:         price = f.get("fillPrice") or f.get("price")
   140:         qty = f.get("fillQty") or f.get("size") or f.get("vol") or f.get("qty")
   141:         try:
   142:             price_f = float(price)
   143:             qty_f = float(qty)
   144:         except (TypeError, ValueError):
   145:             continue
   146:         exec_qty += qty_f
   147:         exec_notional += price_f * qty_f * contract_size
   148: 
   149:     avg_price = exec_notional / (exec_qty * contract_size) if exec_qty else 0.0
   150:     return exec_qty, exec_notional, avg_price
   151: 
   152: 
   153: def compute_position_size(
   154:     contract_detail: Dict[str, Any],
   155:     equity_usdt: float,
   156:     price: float,
   157:     risk_pct: float,
   158:     leverage: int,
   159:     symbol: Optional[str] = None,
   160:     available_usdt: Optional[float] = None,
   161: ) -> int:
   162:     """Return contract volume to trade for the given risk parameters.
   163: 
   164:     The original implementation assumed ``price`` and contract metadata were
   165:     always valid which could lead to divide-by-zero errors or negative volumes
   166:     when the upstream API returned incomplete data.  To harden the sizing logic
   167:     we now validate these inputs and simply return ``0`` whenever they are
   168:     non‑positive.  The caller interprets a zero volume as a cue to skip the
   169:     trade, keeping the bot running without raising exceptions.
   170:     """
   171: 
   172:     symbol = symbol or CONFIG.get("SYMBOL")
   173:     contracts = contract_detail.get("data") or []
   174:     if not isinstance(contracts, list):
   175:         contracts = [contracts]
   176:     contract = next((c for c in contracts if c and c.get("symbol") == symbol), None)
   177:     if contract is None:
   178:         raise ValueError("Contract detail introuvable pour le symbole")
   179: 
   180:     contract_size = get_contract_size(contract_detail, symbol)
   181:     vol_unit = int(contract.get("volUnit", 1))
   182:     min_vol = int(contract.get("minVol", 1))
   183:     min_usdt = float(contract.get("minTradeUSDT", 5))
   184: 
   185:     if price <= 0 or contract_size <= 0 or vol_unit <= 0 or min_vol <= 0:
   186:         return 0
   187: 
   188:     notional_target = equity_usdt * float(risk_pct) * float(leverage)
   189:     if notional_target <= 0.0:
   190:         return 0
   191: 
   192:     denom = price * contract_size
   193:     if denom <= 0:
   194:         return 0
   195: 
   196:     vol = notional_target / denom
   197:     vol = int(math.floor(vol / vol_unit) * vol_unit)
   198:     vol = max(min_vol, vol)
   199:     notional = vol * denom
   200:     if notional < min_usdt:
   201:         return 0
   202: 
   203:     fee_rate = max(CONFIG.get("FEE_RATE", 0.0), 0.001)
   204:     max_notional = equity_usdt / (1 / float(leverage) + fee_rate)
   205:     max_vol = int(math.floor(max_notional / denom / vol_unit) * vol_unit)
   206:     if max_vol < min_vol:
   207:         return 0
   208:     if vol > max_vol:
   209:         vol = max_vol
   210:         notional = vol * denom
   211:         if notional < min_usdt:
   212:             return 0
   213: 
   214:     if available_usdt is not None:
   215:         cap = available_usdt / (1 / float(leverage) + fee_rate)
   216:         cap_vol = int(math.floor(cap / denom / vol_unit) * vol_unit)
   217:         if cap_vol < min_vol:
   218:             return 0
   219:         if vol > cap_vol:
   220:             vol = cap_vol
   221:             notional = vol * denom
   222:             if notional < min_usdt:
   223:                 return 0
   224: 
   225:     return vol
   226: 
   227: 
   228: def compute_pnl_usdt(
   229:     contract_detail: Dict[str, Any],
   230:     entry_price: float,
   231:     exit_price: float,
   232:     vol: float,
   233:     side: int,
   234:     symbol: Optional[str] = None,
   235: ) -> float:
   236:     """Return PnL in USDT using contract size for ``vol`` contracts."""
   237: 
   238:     size = get_contract_size(contract_detail, symbol)
   239:     diff = (exit_price - entry_price) * (1 if side > 0 else -1)
   240:     return diff * size * vol
   241: 
   242: 
   243: def compute_pnl_with_fees(
   244:     contract_detail: Dict[str, Any],
   245:     entry_price: float,
   246:     exit_price: float,
   247:     vol: float,
   248:     side: int,
   249:     leverage: float,
   250:     fee_rate: float,
   251:     symbol: Optional[str] = None,
   252: ) -> Tuple[float, float]:
   253:     """Return net PnL in USDT and percentage on margin.
   254: 
   255:     ``side`` should be ``1`` for long positions and ``-1`` for shorts.
   256:     """
   257: 
   258:     cs = get_contract_size(contract_detail, symbol)
   259:     n_entry = notional(entry_price, vol, cs)
   260:     n_exit = notional(exit_price, vol, cs)
   261:     gross = (exit_price - entry_price) * vol * cs * (1 if side > 0 else -1)
   262:     fees = fee_rate * (n_entry + n_exit)
   263:     pnl = gross - fees
   264:     margin = n_entry / max(float(leverage), 1.0)
   265:     pct = 0.0 if margin == 0 else pnl / margin * 100.0
   266:     return pnl, pct
   267: 
   268: def effective_leverage(
   269:     entry_price: float,
   270:     liquidation_price: float,
   271:     position_margin: float,
   272:     position_size: float,
   273: ) -> float:
   274:     """Return the effective leverage of a futures position.
   275: 
   276:     ``effective_leverage`` is defined as the ratio between the position's
   277:     notional value and the collateral backing it.  The collateral is primarily
   278:     taken from ``position_margin`` but, when unavailable, it can be inferred
   279:     from the distance to the liquidation price.
   280: 
   281:     The function is resilient to missing or non‑positive inputs and falls back
   282:     to ``0.0`` whenever leverage cannot be determined.
   283:     """
   284: 
   285:     try:
   286:         entry = float(entry_price)
   287:         liq = float(liquidation_price)
   288:         margin = float(position_margin)
   289:         size = float(position_size)
   290:     except (TypeError, ValueError):
   291:         return 0.0
   292: 
   293:     if entry <= 0 or size == 0:
   294:         return 0.0
   295: 
   296:     notional = abs(size) * entry
   297: 
   298:     if margin <= 0:
   299:         price_diff = abs(entry - liq)
   300:         margin = price_diff * abs(size)
   301: 
   302:     if margin <= 0:
   303:         return 0.0
   304: 
   305:     return notional / margin
   306: 
   307: 
   308: def analyse_risque(
   309:     contract_detail: Dict[str, Any],
   310:     open_positions: List[Dict[str, Any]],
   311:     equity_usdt: float,
   312:     price: float,
   313:     risk_pct: float,
   314:     base_leverage: int,
   315:     symbol: Optional[str] = None,
   316:     side: str = "long",
   317:     risk_level: int = 2,
   318: ) -> Tuple[int, int]:
   319:     """Analyse le risque avant l'ouverture d'une position."""
   320:     symbol = symbol or CONFIG.get("SYMBOL")
   321:     side = side.lower()
   322: 
   323:     max_positions_map = {1: 1, 2: 3, 3: 5}
   324:     leverage_map = {1: max(1, base_leverage // 2), 2: base_leverage, 3: base_leverage * 2}
   325: 
   326:     max_pos = max_positions_map.get(risk_level, max_positions_map[2])
   327:     leverage = leverage_map.get(risk_level, base_leverage)
   328: 
   329:     current = 0
   330:     for pos in open_positions or []:
   331:         if pos and pos.get("symbol") == symbol:
   332:             if str(pos.get("side", "")).lower() == side:
   333:                 current += 1
   334: 
   335:     if current >= max_pos:
   336:         return 0, leverage
   337: 
   338:     vol = compute_position_size(
   339:         contract_detail,
   340:         equity_usdt=equity_usdt,
   341:         price=price,
   342:         risk_pct=risk_pct,
   343:         leverage=leverage,
   344:         symbol=symbol,
   345:     )
   346:     return vol, leverage
   347: 
   348: 
   349: def trailing_stop(side: str, current_price: float, atr: float, sl: float, *, mult: float = 0.75) -> float:
   350:     """Update a stop loss using a trailing ATR multiple."""
   351: 
   352:     if side.lower() == "long":
   353:         new_sl = current_price - mult * atr
   354:         return max(sl, new_sl)
   355:     new_sl = current_price + mult * atr
   356:     return min(sl, new_sl)
   357: 
   358: 
   359: def break_even_stop(
   360:     side: str,
   361:     entry_price: float,
   362:     current_price: float,
   363:     atr: float,
   364:     sl: float,
   365:     *,
   366:     mult: float = 1.0,
   367: ) -> float:
   368:     """Move stop loss to break-even after a favourable move.
   369: 
   370:     Once price advances ``mult`` times the ``atr`` from ``entry_price`` the
   371:     original stop loss ``sl`` is tightened to the entry.  This helps lock in
   372:     profits while still giving the trade room to develop.
   373:     """
   374: 
   375:     side = side.lower()
   376:     if side == "long":
   377:         if current_price - entry_price >= mult * atr:
   378:             return max(sl, entry_price)
   379:         return sl
   380:     if side == "short":
   381:         if entry_price - current_price >= mult * atr:
   382:             return min(sl, entry_price)
   383:         return sl
   384:     raise ValueError("side must be 'long' or 'short'")
   385: 
   386: 
   387: def should_scale_in(
   388:     entry_price: float,
   389:     current_price: float,
   390:     last_entry: float,
   391:     atr: float,
   392:     side: str,
   393:     *,
   394:     distance_mult: float = 0.5,
   395: ) -> bool:
   396:     """Return ``True`` when price moved sufficiently to add to the position."""
   397: 
   398:     if side.lower() == "long":
   399:         target = last_entry + distance_mult * atr
   400:         return current_price >= target
   401:     target = last_entry - distance_mult * atr
   402:     return current_price <= target
   403: 
   404: 
   405: def timeout_exit(
   406:     entry_time: float,
   407:     now: float,
   408:     entry_price: float,
   409:     current_price: float,
   410:     side: str,
   411:     *,
   412:     progress_min: float = 15.0,
   413:     timeout_min: float = 30.0,
   414: ) -> bool:
   415:     """Return ``True`` when a position should be closed for lack of progress.
   416: 
   417:     Parameters
   418:     ----------
   419:     entry_time, now:
   420:         Timestamps in **seconds**.  ``progress_min`` and ``timeout_min`` are
   421:         expressed in minutes and converted to seconds inside the function so
   422:         callers can provide human-friendly minute values.
   423:     """
   424: 
   425:     # Convert the minute based thresholds to seconds for comparison with the
   426:     # epoch based ``entry_time``/``now`` values.
   427:     progress_sec = progress_min * 60.0
   428:     timeout_sec = timeout_min * 60.0
   429: 
   430:     elapsed = now - entry_time
   431:     if elapsed >= timeout_sec:
   432:         return True
   433:     if elapsed >= progress_sec:
   434:         progress = (
   435:             current_price - entry_price
   436:             if side.lower() == "long"
   437:             else entry_price - current_price
   438:         )
   439:         return progress <= 0
   440:     return False
   441: 
   442: 
   443: def marketable_limit_price(
   444:     side: str,
   445:     *,
   446:     best_bid: float,
   447:     best_ask: float,
   448:     slippage: float = 0.001,
   449: ) -> float:
   450:     """Return price for a marketable limit order with slippage cap.
   451: 
   452:     Parameters
   453:     ----------
   454:     side:
   455:         ``"buy"`` or ``"sell"``.
   456:     best_bid, best_ask:
   457:         Current best bid and ask prices.
   458:     slippage:
   459:         Maximum relative slippage allowed (e.g. ``0.001`` = 0.1%).
   460:     """
   461: 
   462:     if slippage < 0:
   463:         raise ValueError("slippage must be non-negative")
   464:     side = side.lower()
   465:     if side == "buy":
   466:         return best_ask * (1.0 + slippage)
   467:     if side == "sell":
   468:         return best_bid * (1.0 - slippage)
   469:     raise ValueError("side must be 'buy' or 'sell'")


## scalp/version.py (last modified: 2025-08-23 09:47:18)
     1: """Utilities for managing the Scalp bot version."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from pathlib import Path
     6: import re
     7: 
     8: import subprocess
     9: 
    10: 
    11: # Path to the VERSION file within the package
    12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
    13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
    14: 
    15: 
    16: def get_version() -> str:
    17:     """Return the current version of the bot.
    18: 
    19:     If the VERSION file does not exist the default version ``0.0.0`` is
    20:     returned.
    21:     """
    22:     if not _VERSION_FILE.exists():
    23:         return "0.0.0"
    24:     return _VERSION_FILE.read_text().strip()
    25: 
    26: 
    27: def _parse(version: str) -> tuple[int, int, int]:
    28:     match = _VERSION_RE.match(version)
    29:     if not match:
    30:         raise ValueError(f"Invalid version: {version!r}")
    31:     return tuple(int(x) for x in match.groups())
    32: 
    33: 
    34: def bump_version(part: str = "patch") -> str:
    35:     """Bump the version stored in the VERSION file.
    36: 
    37:     Parameters
    38:     ----------
    39:     part:
    40:         Which component to increment. Accepted values are ``"major"``,
    41:         ``"minor"`` and ``"patch"`` (default).
    42:     """
    43:     major, minor, patch = _parse(get_version())
    44:     if part == "major":
    45:         major += 1
    46:         minor = 0
    47:         patch = 0
    48:     elif part == "minor":
    49:         minor += 1
    50:         patch = 0
    51: 
    52:     elif part == "patch":
    53:         patch += 1
    54:     else:
    55:         raise ValueError(f"Unknown part: {part}")
    56:     new_version = f"{major}.{minor}.{patch}"
    57:     _VERSION_FILE.write_text(f"{new_version}\n")
    58:     return new_version
    59: 
    60: 
    61: def bump_version_from_message(message: str) -> str:
    62:     """Bump the version according to a commit message.
    63: 
    64:     ``message`` is evaluated using a tiny subset of the Conventional
    65:     Commits spec. Messages starting with ``feat`` bump the *minor*
    66:     version, messages whose header ends with ``!`` or contain
    67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
    68:     bump the *patch* component.
    69:     """
    70: 
    71:     header = message.strip().splitlines()[0].lower()
    72:     lower = message.lower()
    73:     type_part = header.split(":")[0]
    74:     if "!" in type_part or "breaking change" in lower:
    75:         part = "major"
    76:     elif type_part.startswith("feat"):
    77:         part = "minor"
    78:     else:
    79:         part = "patch"
    80:     return bump_version(part)
    81: 
    82: 
    83: def bump_version_from_git() -> str:
    84:     """Read the latest git commit message and bump the version accordingly."""
    85:     try:
    86:         message = subprocess.check_output(
    87:             ["git", "log", "-1", "--pretty=%B"], text=True
    88:         ).strip()
    89:     except Exception:
    90:         message = ""
    91:     return bump_version_from_message(message)
    92: 
    93: 
    94: if __name__ == "__main__":
    95:     print(bump_version_from_git())


## scalp/ws.py (last modified: 2025-08-23 09:47:18)
     1: """Minimal websocket manager with heartbeat and auto-resubscribe.
     2: 
     3: This module provides a light-weight framework to maintain a realtime
     4: connection to an exchange.  The actual network layer is expected to be
     5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
     6: manager handles retrying failed connections and periodically invoking the
     7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
     8: without opening real network sockets.
     9: """
    10: from __future__ import annotations
    11: 
    12: import asyncio
    13: import logging
    14: from typing import Awaitable, Callable, Optional
    15: 
    16: 
    17: class WebsocketManager:
    18:     """Maintain a websocket connection with heartbeat and retry."""
    19: 
    20:     def __init__(
    21:         self,
    22:         connect: Callable[[], Awaitable[None]],
    23:         subscribe: Callable[[], Awaitable[None]],
    24:         *,
    25:         heartbeat_interval: float = 30.0,
    26:         max_retries: int = 3,
    27:     ) -> None:
    28:         self._connect = connect
    29:         self._subscribe = subscribe
    30:         self.heartbeat_interval = heartbeat_interval
    31:         self.max_retries = max_retries
    32:         self._heartbeat_task: Optional[asyncio.Task] = None
    33: 
    34:     async def run(self) -> None:
    35:         """Open the connection retrying on failure."""
    36:         retries = 0
    37:         while True:
    38:             try:
    39:                 await self._connect()
    40:                 await self._subscribe()
    41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
    42:                 return
    43:             except Exception as exc:  # pragma: no cover - network errors
    44:                 logging.error("websocket connect failed: %s", exc)
    45:                 retries += 1
    46:                 if retries > self.max_retries:
    47:                     raise
    48:                 await asyncio.sleep(1)
    49: 
    50:     async def _heartbeat(self) -> None:
    51:         """Send periodic heartbeats and resubscribe on failure."""
    52:         while True:
    53:             await asyncio.sleep(self.heartbeat_interval)
    54:             try:
    55:                 await self._subscribe()
    56:             except Exception as exc:  # pragma: no cover - network errors
    57:                 logging.warning("websocket heartbeat failed: %s", exc)
    58:                 await self.run()
    59:                 break
    60: 
    61:     async def stop(self) -> None:
    62:         """Cancel the heartbeat task if it is running."""
    63:         task = self._heartbeat_task
    64:         if task and not task.done():
    65:             task.cancel()
    66:             try:
    67:                 await task
    68:             except BaseException:  # pragma: no cover - cancellation
    69:                 pass
    70:         self._heartbeat_task = None


## short_one_way.py (last modified: 2025-08-23 09:47:18)
     1: #!/usr/bin/env python3
     2: # -*- coding: utf-8 -*-
     3: """Example script to open a one-way short on Bitget futures.
     4: 
     5: This standalone script signs and sends a market sell order using the
     6: Bitget REST API. Environment variables required (defined in a `.env`
     7: file alongside this script):
     8: 
     9: - ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
    10: - ``BITGET_API_KEY``
    11: - ``BITGET_API_SECRET``
    12: - ``BITGET_API_PASSPHRASE``
    13: - ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
    14: - ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
    15: - ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
    16: - ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)
    17: 
    18: The script retrieves the current contract specification and price,
    19: ensures account settings (one-way mode & leverage) and finally places a
    20: market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.
    21: 
    22: The intent is purely demonstrational; use at your own risk.
    23: """
    24: 
    25: import base64
    26: import hashlib
    27: import hmac
    28: import json
    29: import os
    30: import sys
    31: import time
    32: import uuid
    33: from pathlib import Path
    34: 
    35: import requests
    36: 
    37: try:  # lazy dependency import for dotenv
    38:     from dotenv import load_dotenv
    39: except ImportError:  # pragma: no cover - installation fallback
    40:     import subprocess
    41: 
    42:     subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
    43:     from dotenv import load_dotenv
    44: 
    45: # load environment variables
    46: load_dotenv(Path(__file__).resolve().parent / ".env")
    47: 
    48: 
    49: def T(x):  # small helper used throughout configuration
    50:     return x.strip() if isinstance(x, str) else x
    51: 
    52: 
    53: BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
    54: AK = T(os.getenv("BITGET_API_KEY"))
    55: SK = T(os.getenv("BITGET_API_SECRET"))
    56: PH = T(os.getenv("BITGET_API_PASSPHRASE"))
    57: PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
    58: MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
    59: SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
    60: NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))
    61: 
    62: if not (AK and SK and PH):
    63:     sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")
    64: 
    65: print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")
    66: 
    67: 
    68: # ---------- signing helpers ----------
    69: def sign_get(ts, path, params):
    70:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    71:     pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
    72:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    73:     return sig, qs
    74: 
    75: 
    76: def sign_post(ts, path, body, params=None):
    77:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    78:     body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
    79:     pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
    80:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    81:     return sig, body_str, qs
    82: 
    83: 
    84: def headers(sig, ts):
    85:     return {
    86:         "ACCESS-KEY": AK,
    87:         "ACCESS-SIGN": sig,
    88:         "ACCESS-TIMESTAMP": str(ts),
    89:         "ACCESS-PASSPHRASE": PH,
    90:         "ACCESS-RECV-WINDOW": "60000",
    91:         "Content-Type": "application/json",
    92:     }
    93: 
    94: 
    95: def pick_price(d: dict):
    96:     for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
    97:         try:
    98:             v = float(d.get(k))
    99:             if v > 0:
   100:                 return v
   101:         except Exception:
   102:             pass
   103:     return None
   104: 
   105: 
   106: # ---------- public endpoints ----------
   107: def get_contract_spec():
   108:     r = requests.get(
   109:         f"{BASE}/api/v2/mix/market/contracts",
   110:         params={"productType": PT, "symbol": SYMB},
   111:         timeout=12,
   112:     )
   113:     r.raise_for_status()
   114:     arr = r.json().get("data") or []
   115:     if not arr:
   116:         raise RuntimeError("Contrat introuvable")
   117:     return arr[0]
   118: 
   119: 
   120: def get_price():
   121:     # 1) ticker (obj/list) avec productType
   122:     try:
   123:         r = requests.get(
   124:             f"{BASE}/api/v2/mix/market/ticker",
   125:             params={"symbol": SYMB, "productType": PT},
   126:             timeout=10,
   127:         )
   128:         r.raise_for_status()
   129:         data = r.json().get("data")
   130:         if isinstance(data, dict):
   131:             p = pick_price(data)
   132:             if p:
   133:                 return p
   134:         if isinstance(data, list) and data:
   135:             p = pick_price(data[0])
   136:             if p:
   137:                 return p
   138:     except requests.HTTPError as e:
   139:         print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
   140:     except Exception as e:
   141:         print("⚠️ ticker err:", e)
   142: 
   143:     # 2) tickers (liste entière)
   144:     try:
   145:         r = requests.get(
   146:             f"{BASE}/api/v2/mix/market/tickers",
   147:             params={"productType": PT},
   148:             timeout=10,
   149:         )
   150:         r.raise_for_status()
   151:         arr = r.json().get("data") or []
   152:         row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
   153:         p = pick_price(row or {})
   154:         if p:
   155:             return p
   156:     except requests.HTTPError as e:
   157:         print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
   158:     except Exception as e:
   159:         print("⚠️ tickers err:", e)
   160: 
   161:     # 3) candles 1m (close)
   162:     try:
   163:         # ``symbol`` must be provided as a query parameter; placing it in the
   164:         # path triggers a 404 response from Bitget.
   165:         r = requests.get(
   166:             f"{BASE}/api/v2/mix/market/candles",
   167:             params={"symbol": SYMB, "granularity": "1m"},
   168:             timeout=10,
   169:         )
   170:         r.raise_for_status()
   171:         arr = r.json().get("data") or []
   172:         if arr:
   173:             return float(arr[0][4])
   174:     except requests.HTTPError as e:
   175:         print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
   176:     except Exception as e:
   177:         print("⚠️ candles err:", e)
   178: 
   179:     raise RuntimeError("prix indisponible")
   180: 
   181: 
   182: # ---------- private endpoints ----------
   183: def check_accounts():
   184:     path = "/api/v2/mix/account/accounts"
   185:     ts = int(time.time() * 1000)
   186:     params = {"productType": PT}
   187:     sig, qs = sign_get(ts, path, params)
   188:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   189:     r = requests.get(url, headers=headers(sig, ts), timeout=12)
   190:     print("accounts", r.status_code, r.text[:160])
   191:     r.raise_for_status()
   192:     j = r.json()
   193:     if str(j.get("code")) not in ("00000", "0"):
   194:         raise RuntimeError(j)
   195: 
   196: 
   197: def set_position_mode_one_way():
   198:     path = "/api/v2/mix/account/set-position-mode"
   199:     ts = int(time.time() * 1000)
   200:     body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
   201:     sig, b, qs = sign_post(ts, path, body)
   202:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   203:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
   204:     print("set-position-mode(one-way)", r.status_code, r.text[:160])
   205:     r.raise_for_status()
   206: 
   207: 
   208: def set_leverage(lv: int = 2):
   209:     path = "/api/v2/mix/account/set-leverage"
   210:     ts = int(time.time() * 1000)
   211:     body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
   212:     sig, b, qs = sign_post(ts, path, body)
   213:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   214:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
   215:     print("set-leverage", r.status_code, r.text[:160])
   216:     r.raise_for_status()
   217: 
   218: 
   219: def place_one_way_sell(size_coin: float):
   220:     """Ouvre un SHORT en one_way_mode (market SELL)."""
   221:     path = "/api/v2/mix/order/place-order"
   222:     ts = int(time.time() * 1000)
   223:     body = {
   224:         "symbol": SYMB,
   225:         "productType": PT,
   226:         "marginCoin": MC,
   227:         "marginMode": "crossed",
   228:         "posMode": "one_way_mode",
   229:         "orderType": "market",
   230:         "side": "sell",  # <-- SHORT
   231:         "size": str(size_coin),
   232:         "timeInForceValue": "normal",
   233:         "clientOid": str(uuid.uuid4())[:32],
   234:     }
   235:     sig, b, qs = sign_post(ts, path, body)
   236:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
   237:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
   238:     print("place-order(one-way SELL)", r.status_code, r.text[:220])
   239:     r.raise_for_status()
   240:     j = r.json()
   241:     if str(j.get("code")) not in ("00000", "0"):
   242:         raise RuntimeError(j)
   243:     return j
   244: 
   245: 
   246: # ---------- main ----------
   247: def main():
   248:     spec = get_contract_spec()
   249:     min_usdt = float(spec.get("minTradeUSDT") or 5)
   250:     min_num = float(spec.get("minTradeNum") or 0)
   251:     size_place = int(spec.get("sizePlace") or 6)
   252:     print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")
   253: 
   254:     px = get_price()
   255:     print(f"Prix OK ≈ {px}")
   256: 
   257:     check_accounts()
   258:     set_position_mode_one_way()
   259:     set_leverage(2)
   260: 
   261:     target = max(NOTIONAL, min_usdt)
   262:     size = max(target / px, min_num)
   263:     size = float(f"{size:.{size_place}f}")
   264:     print(f"Taille={size} (target≈{target}USDT)")
   265: 
   266:     j = place_one_way_sell(size)
   267:     print("✅ SHORT OK")
   268:     print(json.dumps(j, indent=2, ensure_ascii=False))
   269: 
   270: 
   271: if __name__ == "__main__":  # pragma: no cover - script entrypoint
   272:     main()


## signals/__init__.py (last modified: 2025-08-23 09:47:18)
     1: """Signal generation utilities."""
     2: 
     3: from .generator import generate_signal
     4: 
     5: __all__ = ["generate_signal"]


## signals/factory.py (last modified: 2025-08-23 09:47:18)
     1: from importlib import import_module
     2: from typing import Callable, Any, Dict
     3: 
     4: SignalFn = Callable[[list, Dict[str, Any]], Dict[str, Any]]
     5: 
     6: def load_signal(name: str) -> SignalFn:
     7:     mod = import_module(f"scalp.signals.{name}")
     8:     if not hasattr(mod, "generate_signal"):
     9:         raise ImportError(f"Strategy '{name}' missing generate_signal()")
    10:     return getattr(mod, "generate_signal")

## signals/generator.py (last modified: 2025-08-23 09:47:18)
     1: from __future__ import annotations
     2: 
     3: from typing import Any, Dict, List, Optional
     4: 
     5: import pandas as pd
     6: 
     7: from data.indicators import compute_all
     8: 
     9: __all__ = ["generate_signal"]
    10: 
    11: 
    12: def _quality_from_score(score: float) -> str:
    13:     if score >= 0.8:
    14:         return "A"
    15:     if score >= 0.5:
    16:         return "B"
    17:     return "C"
    18: 
    19: 
    20: def generate_signal(
    21:     df: pd.DataFrame,
    22:     *,
    23:     trend_tf: Optional[pd.DataFrame] = None,
    24:     confirm_tf: Optional[pd.DataFrame] = None,
    25:     atr_mult: float = 1.0,
    26:     trailing: bool = False,
    27:     **_: Any,
    28: ) -> Optional[Dict[str, Any]]:
    29:     """Generate a trading signal with confluence scoring.
    30: 
    31:     Parameters
    32:     ----------
    33:     df: pd.DataFrame
    34:         Primary timeframe OHLCV data.
    35:     trend_tf: pd.DataFrame, optional
    36:         Higher timeframe used for trend filtering.
    37:     confirm_tf: pd.DataFrame, optional
    38:         Lower timeframe used for confirmation.
    39:     atr_mult: float, optional
    40:         Multiplier applied to ATR for stop/target calculation.
    41:     trailing: bool, optional
    42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
    43: 
    44:     Returns
    45:     -------
    46:     dict | None
    47:         Dictionary describing the signal or ``None`` if no trade setup exists.
    48:     """
    49: 
    50:     if df is None or len(df) < 2:
    51:         return None
    52: 
    53:     df = compute_all(df)
    54:     last = df.iloc[-1]
    55: 
    56:     conditions: List[bool] = []
    57:     reasons: List[str] = []
    58:     direction: Optional[str] = None
    59: 
    60:     # --- Basic trend via EMAs ----------------------------------------------
    61:     if last["close"] > last["ema20"] > last["ema50"]:
    62:         direction = "long"
    63:         reasons.append("price_above_ema")
    64:         conditions.append(True)
    65:     elif last["close"] < last["ema20"] < last["ema50"]:
    66:         direction = "short"
    67:         reasons.append("price_below_ema")
    68:         conditions.append(True)
    69:     else:
    70:         conditions.append(False)
    71:         return None
    72: 
    73:     # --- RSI ---------------------------------------------------------------
    74:     if direction == "long":
    75:         cond = last["rsi"] > 55
    76:         if cond:
    77:             reasons.append("rsi_bullish")
    78:         conditions.append(cond)
    79:     else:
    80:         cond = last["rsi"] < 45
    81:         if cond:
    82:             reasons.append("rsi_bearish")
    83:         conditions.append(cond)
    84: 
    85:     # --- MACD --------------------------------------------------------------
    86:     if direction == "long":
    87:         cond = last["macd"] > last["macd_signal"]
    88:         if cond:
    89:             reasons.append("macd_bullish")
    90:         conditions.append(cond)
    91:     else:
    92:         cond = last["macd"] < last["macd_signal"]
    93:         if cond:
    94:             reasons.append("macd_bearish")
    95:         conditions.append(cond)
    96: 
    97:     # --- OBV momentum ------------------------------------------------------
    98:     if len(df) >= 2:
    99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
   100:         if obv_up:
   101:             reasons.append("obv_trending")
   102:         conditions.append(obv_up)
   103: 
   104:     # --- Trend timeframe filter -------------------------------------------
   105:     if trend_tf is not None and len(trend_tf) >= 2:
   106:         tdf = compute_all(trend_tf)
   107:         ema50 = tdf["ema50"]
   108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
   109:         if direction == "long":
   110:             cond = slope > 0
   111:             if cond:
   112:                 reasons.append("trend_up")
   113:             conditions.append(cond)
   114:         else:
   115:             cond = slope < 0
   116:             if cond:
   117:                 reasons.append("trend_down")
   118:             conditions.append(cond)
   119: 
   120:     # --- Confirmation timeframe filter ------------------------------------
   121:     if confirm_tf is not None and len(confirm_tf) > 0:
   122:         cdf = compute_all(confirm_tf)
   123:         rsi = cdf["rsi"].iloc[-1]
   124:         if direction == "long":
   125:             cond = rsi > 50
   126:             if cond:
   127:                 reasons.append("confirm_rsi_bullish")
   128:             conditions.append(cond)
   129:         else:
   130:             cond = rsi < 50
   131:             if cond:
   132:                 reasons.append("confirm_rsi_bearish")
   133:             conditions.append(cond)
   134: 
   135:     score = (
   136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
   137:     )
   138:     quality = _quality_from_score(score)
   139: 
   140:     atr = last.get("atr")
   141:     if pd.isna(atr) or atr == 0:
   142:         return None
   143: 
   144:     entry = float(last["close"])
   145:     if direction == "long":
   146:         sl = entry - atr * atr_mult
   147:         tp = entry + atr * atr_mult * 2
   148:     else:
   149:         sl = entry + atr * atr_mult
   150:         tp = entry - atr * atr_mult * 2
   151: 
   152:     result: Dict[str, Any] = {
   153:         "direction": direction,
   154:         "entry": entry,
   155:         "sl": sl,
   156:         "tp": tp,
   157:         "score": round(score, 3),
   158:         "reasons": reasons,
   159:         "quality": quality,
   160:     }
   161: 
   162:     if trailing:
   163:         result["trail"] = atr * atr_mult
   164: 
   165:     return result


## tests/conftest.py (last modified: 2025-08-23 09:47:18)
     1: """Test configuration and shared fixtures."""
     2: 
     3: import sys
     4: import types
     5: from pathlib import Path
     6: 
     7: 
     8: # Ensure the project root is importable so tests can ``import bot``.
     9: ROOT = Path(__file__).resolve().parents[1]
    10: sys.path.insert(0, str(ROOT))
    11: 
    12: 
    13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
    14: # the real dependency during test collection. Individual tests patch the
    15: # functions they need (``request``/``post``/``get``).
    16: sys.modules.setdefault(
    17:     "requests",
    18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
    19: )
    20: 


## tests/test_analyse_risque.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.SimpleNamespace(
     7:     request=lambda *a, **k: None,
     8:     post=lambda *a, **k: None,
     9:     HTTPError=Exception,
    10: )
    11: 
    12: from bot import analyse_risque  # noqa: E402
    13: 
    14: 
    15: def make_contract_detail():
    16:     return {
    17:         "data": [
    18:             {
    19:                 "symbol": "BTC_USDT",
    20:                 "contractSize": 0.01,
    21:                 "volUnit": 1,
    22:                 "minVol": 1,
    23:             }
    24:         ]
    25:     }
    26: 
    27: 
    28: def test_analyse_risque_limits_and_leverage():
    29:     contract_detail = make_contract_detail()
    30:     # Risk level 1: leverage halved, limit 1 position
    31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
    32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    33:                                symbol="BTC_USDT", side="long", risk_level=1)
    34:     assert lev == 5
    35:     assert vol == 0  # already one long position
    36: 
    37:     # Risk level 2: base leverage, limit 3 positions
    38:     open_pos = [
    39:         {"symbol": "BTC_USDT", "side": "long"},
    40:         {"symbol": "BTC_USDT", "side": "long"},
    41:         {"symbol": "BTC_USDT", "side": "long"},
    42:     ]
    43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    44:                                symbol="BTC_USDT", side="long", risk_level=2)
    45:     assert lev == 10
    46:     assert vol == 0
    47: 
    48:     # Risk level 3: leverage doubled, no existing position
    49:     open_pos = []
    50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    51:                                symbol="BTC_USDT", side="long", risk_level=3)
    52:     assert lev == 20
    53:     assert vol == 1


## tests/test_backtest.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: 
     3: import bot
     4: 
     5: 
     6: def test_backtest_trades():
     7:     trades = [
     8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
     9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
    10:     ]
    11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
    12:     # Both trades: 10% - 0.2% fee = 9.8% each
    13:     assert pnl == pytest.approx(19.6)


## tests/test_backtest_multi.py (last modified: 2025-08-23 09:47:18)
     1: import csv
     2: import random
     3: from datetime import datetime, timedelta, timezone
     4: from pathlib import Path
     5: 
     6: import pytest
     7: 
     8: from backtest.run_multi import run_backtest_multi
     9: from scalp.strategy import Signal
    10: 
    11: 
    12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
    13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
    14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
    15:     with open(filename, "w", newline="") as fh:
    16:         writer = csv.writer(fh)
    17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    18:         for i in range(200):
    19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
    20:             price = 100 + i
    21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
    22: 
    23: 
    24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    25:     closes = ohlcv["close"]
    26:     if len(closes) < 10:
    27:         return None
    28:     price = closes[-1]
    29:     sl = price * 0.99
    30:     tp = price * 1.01
    31:     qty = equity * risk_pct / (price - sl)
    32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
    33: 
    34: 
    35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
    37:         return None
    38:     price = ohlcv["close"][-1]
    39:     sl = price * 0.99
    40:     tp = price * 1.01
    41:     qty = equity * risk_pct / (price - sl)
    42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
    43: 
    44: 
    45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    46:     closes = ohlcv["close"]
    47:     if len(closes) < 10:
    48:         return None
    49:     price = closes[-1]
    50:     sl = price * 0.99
    51:     tp = price * 1.01
    52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
    53: 
    54: 
    55: def find_row(summary, symbol):
    56:     for row in summary:
    57:         if row["symbol"] == symbol:
    58:             return row
    59:     raise KeyError(symbol)
    60: 
    61: 
    62: def test_csv_multi_pairs(tmp_path, monkeypatch):
    63:     for sym in ["BTC/USDT", "ETH/USDT"]:
    64:         make_csv(tmp_path, sym)
    65:     monkeypatch.setattr("scalp.strategy.generate_signal", simple_signal)
    66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
    67:     out = tmp_path / "out"
    68:     summary, trades = run_backtest_multi(
    69:         symbols=["BTC/USDT", "ETH/USDT"],
    70:         exchange="csv",
    71:         timeframe="1m",
    72:         csv_dir=str(tmp_path),
    73:         fee_rate=0.0,
    74:         slippage_bps=0.0,
    75:         risk_pct=0.01,
    76:         initial_equity=1000,
    77:         leverage=1.0,
    78:         paper_constraints=True,
    79:         seed=42,
    80:         out_dir=str(out),
    81:         plot=False,
    82:     )
    83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
    84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
    85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
    86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
    87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
    88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
    89:     # files
    90:     assert (out / "report_summary.csv").exists()
    91:     assert (out / "report_trades.csv").exists()
    92:     assert (out / "equity_curve_total.csv").exists()
    93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
    94:     # columns in trades
    95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
    96:         assert col in trades[0]
    97: 
    98: 
    99: def test_fee_slippage(tmp_path, monkeypatch):
   100:     make_csv(tmp_path, "BTC/USDT")
   101:     monkeypatch.setattr("scalp.strategy.generate_signal", simple_signal)
   102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
   103:     summary1, _ = run_backtest_multi(
   104:         symbols=["BTC/USDT"],
   105:         exchange="csv",
   106:         timeframe="1m",
   107:         csv_dir=str(tmp_path),
   108:         fee_rate=0.0,
   109:         slippage_bps=0.0,
   110:         out_dir=str(tmp_path / "o1"),
   111:     )
   112:     summary2, _ = run_backtest_multi(
   113:         symbols=["BTC/USDT"],
   114:         exchange="csv",
   115:         timeframe="1m",
   116:         csv_dir=str(tmp_path),
   117:         fee_rate=0.01,
   118:         slippage_bps=100,
   119:         out_dir=str(tmp_path / "o2"),
   120:     )
   121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
   122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
   123:     assert pnl2 < pnl1
   124: 
   125: 
   126: def test_paper_constraints(tmp_path, monkeypatch):
   127:     make_csv(tmp_path, "BTC/USDT")
   128:     monkeypatch.setattr("scalp.strategy.generate_signal", tiny_qty_signal)
   129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
   130:     summary, trades = run_backtest_multi(
   131:         symbols=["BTC/USDT"],
   132:         exchange="csv",
   133:         timeframe="1m",
   134:         csv_dir=str(tmp_path),
   135:         paper_constraints=True,
   136:         out_dir=str(tmp_path / "o"),
   137:     )
   138:     assert all(t["qty"] >= 0.001 for t in trades)
   139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
   140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
   141: 
   142: 
   143: def test_seed_reproducible(tmp_path, monkeypatch):
   144:     make_csv(tmp_path, "BTC/USDT")
   145:     monkeypatch.setattr("scalp.strategy.generate_signal", random_signal)
   146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
   147:     s1, t1 = run_backtest_multi(
   148:         symbols=["BTC/USDT"],
   149:         exchange="csv",
   150:         timeframe="1m",
   151:         csv_dir=str(tmp_path),
   152:         seed=7,
   153:         out_dir=str(tmp_path / "o1"),
   154:     )
   155:     s2, t2 = run_backtest_multi(
   156:         symbols=["BTC/USDT"],
   157:         exchange="csv",
   158:         timeframe="1m",
   159:         csv_dir=str(tmp_path),
   160:         seed=7,
   161:         out_dir=str(tmp_path / "o2"),
   162:     )
   163:     assert t1 == t2
   164:     assert s1 == s2


## tests/test_backtest_position.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import pytest
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: 
     7: from scalp.metrics import backtest_position
     8: 
     9: 
    10: def test_backtest_position_long():
    11:     prices = [100.0, 110.0, 120.0]
    12:     assert backtest_position(prices, 0, 2, 1) is True
    13: 
    14: 
    15: def test_backtest_position_short():
    16:     prices = [100.0, 90.0, 80.0]
    17:     assert backtest_position(prices, 0, 2, -1) is True
    18: 
    19: 
    20: def test_backtest_position_incoherent():
    21:     prices = [100.0, 110.0, 120.0]
    22:     assert backtest_position(prices, 0, 2, -1) is False
    23: 
    24: 
    25: def test_backtest_position_bad_indices():
    26:     prices = [100.0, 110.0]
    27:     with pytest.raises(ValueError):
    28:         backtest_position(prices, 1, 0, 1)


## tests/test_bitget_futures_pairs.py (last modified: 2025-08-23 09:47:18)
     1: import json
     2: from pathlib import Path
     3: from typing import Any, Dict
     4: 
     5: import pytest
     6: 
     7: import bitget_futures_pairs as bfp
     8: 
     9: 
    10: class DummyResponse:
    11:     def __init__(self, status: int, payload: Dict[str, Any]):
    12:         self.status_code = status
    13:         self._payload = payload
    14:         self.text = json.dumps(payload)
    15: 
    16:     def json(self):
    17:         return self._payload
    18: 
    19: 
    20: def test_fetch_contracts_success(monkeypatch):
    21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
    22: 
    23:     def fake_get(url, params=None, timeout=0):
    24:         return DummyResponse(200, payload)
    25: 
    26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
    28:     assert contracts == payload["data"]
    29: 
    30: 
    31: def test_fetch_contracts_error(monkeypatch):
    32:     payload = {"code": "10001"}
    33: 
    34:     def fake_get(url, params=None, timeout=0):
    35:         return DummyResponse(200, payload)
    36: 
    37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    38:     with pytest.raises(RuntimeError):
    39:         bfp.fetch_contracts("USDT-FUTURES")
    40: 
    41: 
    42: def test_normalize_rows():
    43:     contracts = [
    44:         {
    45:             "symbol": "BTCUSDT",
    46:             "baseCoin": "BTC",
    47:             "quoteCoin": "USDT",
    48:             "symbolType": "perpetual",
    49:             "symbolStatus": "normal",
    50:             "maxLever": "50",
    51:             "minLever": "1",
    52:             "minTradeNum": "0.001",
    53:             "sizeMultiplier": "1",
    54:             "pricePlace": "2",
    55:             "volumePlace": "3",
    56:             "launchTime": 0,
    57:             "deliveryTime": 0,
    58:         }
    59:     ]
    60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
    61:     assert rows[0]["symbol"] == "BTCUSDT"
    62:     assert rows[0]["productType"] == "USDT-FUTURES"
    63: 
    64: 
    65: def test_write_csv(tmp_path: Path):
    66:     path = tmp_path / "pairs.csv"
    67:     bfp.write_csv([], str(path))
    68:     assert path.exists()
    69:     content = path.read_text().splitlines()
    70:     assert content[0].startswith("productType,")


## tests/test_bot_place_order_caps.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import types
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: sys.modules['requests'] = types.ModuleType('requests')
     6: 
     7: from bot import attempt_entry, Signal
     8: 
     9: 
    10: class DummyClient:
    11:     def __init__(self):
    12:         self.last_order = None
    13: 
    14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
    15:         self.last_order = (args, kwargs)
    16:         return {"code": "00000"}
    17: 
    18: 
    19: class DummyRisk:
    20:     def __init__(self, pct):
    21:         self.risk_pct = pct
    22: 
    23: 
    24: def _detail():
    25:     return {
    26:         "data": [
    27:             {
    28:                 "symbol": "BTC_USDT",
    29:                 "contractSize": 0.001,
    30:                 "volUnit": 1,
    31:                 "minVol": 1,
    32:                 "minTradeUSDT": 5,
    33:             }
    34:         ]
    35:     }
    36: 
    37: 
    38: def test_attempt_entry_respects_caps(monkeypatch):
    39:     captured = {}
    40: 
    41:     def fake_notify(event, payload):
    42:         captured[event] = payload
    43: 
    44:     monkeypatch.setattr("bot.notify", fake_notify)
    45:     client = DummyClient()
    46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    47:     rm = DummyRisk(0.02)
    48:     equity = 100
    49:     available = 2.2  # just enough for 1 contract with buffer
    50:     params = attempt_entry(
    51:         client,
    52:         _detail(),
    53:         sig,
    54:         equity_usdt=equity,
    55:         available_usdt=available,
    56:         cfg={"LEVERAGE": 10},
    57:         risk_mgr=rm,
    58:         user_risk_level=1,
    59:     )
    60:     assert client.last_order is not None
    61:     assert params["vol"] >= 1
    62:     opened = captured["position_opened"]
    63:     assert opened["notional_usdt"] >= 5
    64:     assert opened["vol"] >= 1
    65: 
    66: 
    67: def test_attempt_entry_insufficient_margin(monkeypatch):
    68:     captured = {}
    69: 
    70:     def fake_notify(event, payload):
    71:         captured[event] = payload
    72: 
    73:     monkeypatch.setattr("bot.notify", fake_notify)
    74:     client = DummyClient()
    75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    76:     rm = DummyRisk(0.02)
    77:     equity = 100
    78:     available = 1.0  # below required margin
    79:     params = attempt_entry(
    80:         client,
    81:         _detail(),
    82:         sig,
    83:         equity_usdt=equity,
    84:         available_usdt=available,
    85:         cfg={"LEVERAGE": 10},
    86:         risk_mgr=rm,
    87:         user_risk_level=1,
    88:     )
    89:     assert client.last_order is None
    90:     assert params["vol"] == 0
    91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
    92: 
    93: 
    94: def test_attempt_entry_under_min_trade(monkeypatch):
    95:     captured = {}
    96: 
    97:     def fake_notify(event, payload):
    98:         captured[event] = payload
    99: 
   100:     monkeypatch.setattr("bot.notify", fake_notify)
   101:     client = DummyClient()
   102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
   103:     rm = DummyRisk(0.02)
   104:     detail = {
   105:         "data": [
   106:             {
   107:                 "symbol": "BTC_USDT",
   108:                 "contractSize": 0.001,
   109:                 "volUnit": 1,
   110:                 "minVol": 1,
   111:                 "minTradeUSDT": 50,
   112:             }
   113:         ]
   114:     }
   115:     equity = 100
   116:     available = 100
   117:     params = attempt_entry(
   118:         client,
   119:         detail,
   120:         sig,
   121:         equity_usdt=equity,
   122:         available_usdt=available,
   123:         cfg={"LEVERAGE": 10},
   124:         risk_mgr=rm,
   125:         user_risk_level=1,
   126:     )
   127:     assert client.last_order is None
   128:     assert params["vol"] == 0
   129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")


## tests/test_bot_update.py (last modified: 2025-08-23 09:47:18)
     1: import logging
     2: import bot
     3: 
     4: 
     5: def test_update_displays_pairs(monkeypatch, caplog):
     6:     def fake_send(client, top_n=40):
     7:         assert (client, top_n) == ("cli", 5)
     8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
     9: 
    10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
    11:     with caplog.at_level(logging.INFO):
    12:         payload = bot.update("cli", top_n=5)
    13:     assert payload["green"] == "BTC"
    14:     assert "Listing ok" in caplog.text
    15: 
    16: 
    17: def test_update_survives_errors(monkeypatch, caplog):
    18:     """``update`` should never raise even if pair selection fails."""
    19: 
    20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
    21:         raise RuntimeError("network down")
    22: 
    23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
    24:     with caplog.at_level(logging.INFO):
    25:         payload = bot.update("cli", top_n=5)
    26: 
    27:     # The function returns an empty payload and logs the error, but still logs
    28:     # the "Listing ok" acknowledgement so callers can proceed.
    29:     assert payload == {}
    30:     assert "network down" in caplog.text
    31:     assert "Listing ok" in caplog.text
    32: 


## tests/test_break_even_stop.py (last modified: 2025-08-23 09:47:18)
     1: from scalp.trade_utils import break_even_stop
     2: 
     3: 
     4: def test_break_even_stop_long() -> None:
     5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
     6:     assert sl == 100
     7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
     8:     assert sl == 95
     9: 
    10: 
    11: def test_break_even_stop_short() -> None:
    12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
    13:     assert sl == 100
    14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
    15:     assert sl == 105


## tests/test_calc_pnl_pct.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import pytest
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: 
     6: from scalp.metrics import calc_pnl_pct
     7: 
     8: 
     9: def test_calc_pnl_pct_long():
    10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
    11: 
    12: def test_calc_pnl_pct_short():
    13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
    14: 
    15: 
    16: def test_calc_pnl_pct_with_fee():
    17:     # 10% move minus 0.1%*2 fees = 9.8%
    18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)


## tests/test_check_config.py (last modified: 2025-08-23 09:47:18)
     1: import logging
     2: from bot import check_config
     3: 
     4: 
     5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
     6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
     7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
     8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
     9:     with caplog.at_level(logging.INFO):
    10:         check_config()
    11:     messages = [r.getMessage() for r in caplog.records]
    12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
    13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
    14:     assert all("NOTIFY_URL" not in m for m in messages)
    15: 
    16: 
    17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
    18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
    19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
    20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
    21:     with caplog.at_level(logging.INFO):
    22:         check_config()
    23:     assert caplog.records == []


## tests/test_cli.py (last modified: 2025-08-23 09:47:18)
     1: """Tests for the command line interface defined in :mod:`cli`."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import cli
     6: 
     7: 
     8: def test_opt_invokes_parallel_optimization(monkeypatch):
     9:     """The ``opt`` command should call ``run_parallel_optimization``."""
    10: 
    11:     called = {}
    12: 
    13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
    14:         called["args"] = (pairs, tf, jobs)
    15: 
    16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
    17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
    18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
    19: 
    20: 
    21: def test_walkforward_invokes_analysis(monkeypatch):
    22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
    23: 
    24:     called = {}
    25: 
    26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
    27:         called["args"] = (pair, tf, splits, train_ratio)
    28: 
    29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
    30:     cli.main(
    31:         [
    32:             "walkforward",
    33:             "--pair",
    34:             "BTCUSDT",
    35:             "--tf",
    36:             "1m",
    37:             "--splits",
    38:             "3",
    39:             "--train-ratio",
    40:             "0.8",
    41:         ]
    42:     )
    43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
    44: 
    45: 
    46: def test_live_invokes_async_pipeline(monkeypatch):
    47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
    48: 
    49:     called = {}
    50: 
    51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
    52:         called["args"] = (pairs, list(tfs))
    53: 
    54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
    55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
    56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
    57: 
    58: 
    59: def test_bump_version_invokes_helper(monkeypatch):
    60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
    61: 
    62:     called = {}
    63: 
    64:     def fake_bump():  # pragma: no cover - executed via CLI
    65:         called["called"] = True
    66:         return "0.1.0"
    67: 
    68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
    69:     cli.main(["bump-version"])
    70:     assert called["called"] is True
    71: 


## tests/test_client.py (last modified: 2025-08-23 09:47:18)
     1: import json
     2: import hmac
     3: import hashlib
     4: import base64
     5: import pytest
     6: import bot
     7: from bot import BitgetFuturesClient
     8: 
     9: 
    10: @pytest.fixture(autouse=True)
    11: def no_log_event(monkeypatch):
    12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
    13: 
    14: 
    15: def test_private_request_get_signature(monkeypatch):
    16:     client = BitgetFuturesClient("key", "secret", "https://test")
    17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    18: 
    19:     called = {}
    20: 
    21:     def fake_request(method, url, headers=None, timeout=None):
    22:         called["method"] = method
    23:         called["url"] = url
    24:         called["headers"] = headers
    25: 
    26:         class Resp:
    27:             def raise_for_status(self):
    28:                 pass
    29: 
    30:             def json(self):
    31:                 return {"success": True}
    32: 
    33:         return Resp()
    34: 
    35:     monkeypatch.setattr(bot.requests, "request", fake_request)
    36: 
    37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
    38:     assert resp["success"] is True
    39:     qs = "a=1&b=2"
    40:     prehash = f"1000GET/api/test?{qs}"
    41:     expected = base64.b64encode(
    42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    43:     ).decode()
    44:     assert called["headers"]["ACCESS-SIGN"] == expected
    45:     assert called["headers"]["ACCESS-KEY"] == "key"
    46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    48:     assert called["url"] == "https://test/api/test?a=1&b=2"
    49: 
    50: 
    51: def test_private_request_post_signature(monkeypatch):
    52:     client = BitgetFuturesClient("key", "secret", "https://test")
    53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    54: 
    55:     called = {}
    56: 
    57:     def fake_post(url, data=None, headers=None, timeout=None):
    58:         called["url"] = url
    59:         called["data"] = data
    60:         called["headers"] = headers
    61: 
    62:         class Resp:
    63:             def raise_for_status(self):
    64:                 pass
    65: 
    66:             def json(self):
    67:                 return {"success": True}
    68: 
    69:         return Resp()
    70: 
    71:     monkeypatch.setattr(bot.requests, "post", fake_post)
    72: 
    73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
    74:     assert resp["success"] is True
    75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
    76:     prehash = f"1000POST/api/test{body}"
    77:     expected = base64.b64encode(
    78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    79:     ).decode()
    80:     assert called["headers"]["ACCESS-SIGN"] == expected
    81:     assert called["headers"]["ACCESS-KEY"] == "key"
    82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    84:     assert called["data"].decode("utf-8") == body
    85:     assert called["url"] == "https://test/api/test"
    86: 
    87: 
    88: def test_private_request_http_error(monkeypatch):
    89:     client = BitgetFuturesClient("key", "secret", "https://test")
    90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    91: 
    92:     class Resp:
    93:         status_code = 418
    94: 
    95:         def raise_for_status(self):
    96:             raise bot.requests.HTTPError("teapot")
    97: 
    98:         def json(self):
    99:             return {"unused": True}
   100: 
   101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
   102: 
   103:     resp = client._private_request("GET", "/api/test")
   104:     assert resp["success"] is False
   105:     assert resp["status_code"] == 418
   106:     assert "teapot" in resp["error"]
   107: 
   108: 
   109: def test_get_assets_normalization(monkeypatch):
   110:     client = BitgetFuturesClient("key", "secret", "https://test")
   111: 
   112:     called = {}
   113: 
   114:     def fake_private(self, method, path, params=None, body=None):
   115:         called["method"] = method
   116:         called["path"] = path
   117:         called["params"] = params
   118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
   119: 
   120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   121: 
   122:     assets = client.get_assets()
   123: 
   124:     assert assets["success"] is True
   125:     usdt = assets.get("data", [])[0]
   126:     assert usdt["currency"].upper() == "USDT"
   127:     assert usdt["equity"] == 1.0
   128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
   129: 
   130: 
   131: def test_get_assets_equity_fallback(monkeypatch):
   132:     client = BitgetFuturesClient("key", "secret", "https://test")
   133: 
   134:     def fake_private(self, method, path, params=None, body=None):
   135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
   136: 
   137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   138: 
   139:     assets = client.get_assets()
   140:     usdt = assets.get("data", [])[0]
   141:     assert usdt["currency"] == "USDT"
   142:     assert usdt["equity"] == 2.0
   143: 
   144: 
   145: def test_get_assets_prefers_available(monkeypatch):
   146:     """When both equity and available are returned, available should win."""
   147:     client = BitgetFuturesClient("key", "secret", "https://test")
   148: 
   149:     def fake_private(self, method, path, params=None, body=None):
   150:         return {
   151:             "code": "00000",
   152:             "data": [
   153:                 {
   154:                     "marginCoin": "USDT",
   155:                     "equity": "5",
   156:                     "available": "1",
   157:                 }
   158:             ],
   159:         }
   160: 
   161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   162: 
   163:     assets = client.get_assets()
   164:     usdt = assets.get("data", [])[0]
   165:     assert usdt["equity"] == 1.0
   166: 
   167: 
   168: 
   169: def test_get_assets_zero_available(monkeypatch):
   170:     """Zero available balance should propagate as zero equity."""
   171:     client = BitgetFuturesClient("key", "secret", "https://test")
   172: 
   173:     def fake_private(self, method, path, params=None, body=None):
   174:         return {
   175:             "code": "00000",
   176:             "data": [
   177:                 {
   178:                     "marginCoin": "USDT",
   179:                     "available": "0",
   180:                     "equity": "5",
   181:                 }
   182:             ],
   183:         }
   184: 
   185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   186: 
   187:     assets = client.get_assets()
   188:     usdt = assets.get("data", [])[0]
   189:     assert usdt["equity"] == 0.0
   190: 
   191: 
   192: def test_get_assets_available_balance(monkeypatch):
   193:     """Support alternative ``availableBalance`` field name."""
   194:     client = BitgetFuturesClient("key", "secret", "https://test")
   195: 
   196:     def fake_private(self, method, path, params=None, body=None):
   197:         return {
   198:             "code": "00000",
   199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
   200:         }
   201: 
   202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   203: 
   204:     assets = client.get_assets()
   205:     usdt = assets.get("data", [])[0]
   206:     assert usdt["equity"] == 3.5
   207: 
   208: 
   209: def test_get_ticker_normalization(monkeypatch):
   210:     client = BitgetFuturesClient("key", "secret", "https://test")
   211: 
   212:     called = {}
   213: 
   214:     def fake_get(url, params=None, timeout=None):
   215:         called["url"] = url
   216:         called["params"] = params
   217: 
   218:         class Resp:
   219:             def raise_for_status(self):
   220:                 pass
   221: 
   222:             def json(self):
   223:                 return {
   224:                     "data": {
   225:                         "instId": "BTCUSDT",
   226:                         "lastPr": "1",
   227:                         "bestBidPrice": "0.9",
   228:                         "bestAskPrice": "1.1",
   229:                         "usdtVolume": "100",
   230:                     }
   231:                 }
   232: 
   233:         return Resp()
   234: 
   235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   236: 
   237:     ticker = client.get_ticker("BTC_USDT")
   238: 
   239:     assert ticker["success"] is True
   240:     data = ticker["data"][0]
   241:     assert data["symbol"] == "BTCUSDT"
   242:     assert data["lastPrice"] == "1"
   243:     assert data["bidPrice"] == "0.9"
   244:     assert data["askPrice"] == "1.1"
   245:     assert data["volume"] == 100.0
   246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
   247: 
   248: 
   249: def test_http_client_context_manager(monkeypatch):
   250:     import sys
   251:     import importlib
   252:     sys.modules.pop('requests', None)
   253:     real_requests = importlib.import_module('requests')
   254:     sys.modules['requests'] = real_requests
   255:     import scalp.client as http_client
   256:     importlib.reload(http_client)
   257: 
   258:     closed = {"count": 0}
   259: 
   260:     class DummySession:
   261:         def mount(self, *a, **k):
   262:             pass
   263: 
   264:         def request(self, *a, **k):
   265:             class Resp:
   266:                 def raise_for_status(self):
   267:                     pass
   268: 
   269:                 def json(self):
   270:                     return {}
   271: 
   272:                 text = "{}"
   273: 
   274:             return Resp()
   275: 
   276:         def close(self):
   277:             closed["count"] += 1
   278: 
   279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
   280: 
   281:     http = http_client.HttpClient("http://example.com")
   282:     http.close()
   283:     assert closed["count"] == 1
   284: 
   285:     closed["count"] = 0
   286:     with http_client.HttpClient("http://example.com") as hc:
   287:         hc.request("GET", "/")
   288:     assert closed["count"] == 1
   289: 
   290: 
   291: def test_get_kline_query_params(monkeypatch):
   292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
   293:     query parameter. The previous implementation embedded the symbol in the
   294:     path which resulted in a 404 from Bitget."""
   295: 
   296:     client = BitgetFuturesClient("key", "secret", "https://test")
   297: 
   298:     called = {}
   299: 
   300:     def fake_get(url, params=None, timeout=None):
   301:         called["url"] = url
   302:         called["params"] = params
   303: 
   304:         class Resp:
   305:             def raise_for_status(self):
   306:                 pass
   307: 
   308:             def json(self):
   309:                 return {"data": []}
   310: 
   311:         return Resp()
   312: 
   313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
   314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
   315:     # even if missing so we can observe the call.
   316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   317: 
   318:     client.get_kline("BTC_USDT", interval="Min1")
   319: 
   320:     assert called["url"].endswith("/api/v2/mix/market/candles")
   321:     assert called["params"] == {
   322:         "symbol": "BTCUSDT",
   323:         "productType": "USDT-FUTURES",
   324:         "granularity": "1m",
   325:     }
   326: 
   327: 
   328: def test_get_open_orders_endpoint(monkeypatch):
   329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   330: 
   331:     called = {}
   332: 
   333:     def fake_private(self, method, path, params=None, body=None):
   334:         called["method"] = method
   335:         called["path"] = path
   336:         called["params"] = params
   337:         return {"success": True}
   338: 
   339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   340: 
   341:     client.get_open_orders("BTCUSDT_UMCBL")
   342: 
   343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
   344:     assert called["params"] == {
   345:         "productType": "USDT-FUTURES",
   346:         "symbol": "BTCUSDT",
   347:     }
   348: 
   349: 
   350: def test_product_type_alias():
   351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
   352:     assert client.product_type == "USDT-FUTURES"
   353: 
   354: 
   355: def test_get_contract_detail_endpoint(monkeypatch):
   356:     client = BitgetFuturesClient("key", "secret", "https://test")
   357: 
   358:     called = {}
   359: 
   360:     def fake_get(url, params=None, timeout=None):
   361:         called["url"] = url
   362:         called["params"] = params
   363: 
   364:         class Resp:
   365:             status_code = 200
   366: 
   367:             def raise_for_status(self):
   368:                 pass
   369: 
   370:             def json(self):
   371:                 return {"data": []}
   372: 
   373:         return Resp()
   374: 
   375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   376: 
   377:     client.get_contract_detail("BTCUSDT_UMCBL")
   378: 
   379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
   380:     assert called["params"] == {
   381:         "productType": "USDT-FUTURES",
   382:         "symbol": "BTCUSDT",
   383:     }
   384: 
   385: 
   386: def test_cancel_all_endpoint(monkeypatch):
   387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   388: 
   389:     called = {}
   390: 
   391:     def fake_private(self, method, path, params=None, body=None):
   392:         called["method"] = method
   393:         called["path"] = path
   394:         called["params"] = params
   395:         called["body"] = body
   396:         return {"success": True}
   397: 
   398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   399: 
   400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   401: 
   402:     assert called["method"] == "POST"
   403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
   404:     assert called["params"] is None
   405:     assert called["body"] == {
   406:         "productType": "USDT-FUTURES",
   407:         "symbol": "BTCUSDT",
   408:         "marginCoin": "USDT",
   409:     }
   410: 
   411: 
   412: def test_place_order_endpoint(monkeypatch):
   413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   414: 
   415:     called = {}
   416: 
   417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   418: 
   419:     def fake_private(self, method, path, params=None, body=None):
   420:         called["method"] = method
   421:         called["path"] = path
   422:         called["body"] = body
   423:         return {"success": True}
   424: 
   425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   426: 
   427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
   428: 
   429:     assert resp["success"] is True
   430:     assert called["method"] == "POST"
   431:     assert called["path"] == "/api/v2/mix/order/place-order"
   432:     body = called["body"]
   433:     assert body["symbol"] == "BTCUSDT"
   434:     assert body["marginCoin"] == "USDT"
   435:     assert body["marginMode"] == "crossed"
   436:     assert body["side"] == "buy"
   437:     assert body["posSide"] == "long"
   438:     assert "reduceOnly" not in body
   439:     assert body["posMode"] == "hedge_mode"
   440: 
   441: 
   442: @pytest.mark.parametrize(
   443:     "code, side_str, pos_side",
   444:     [
   445:         (4, "sell", "long"),
   446:         (2, "buy", "short"),
   447:     ],
   448: )
   449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
   450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   451: 
   452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   453: 
   454:     called = {}
   455: 
   456:     def fake_private(self, method, path, params=None, body=None):
   457:         called["body"] = body
   458:         return {"success": True}
   459: 
   460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   461: 
   462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
   463: 
   464:     body = called["body"]
   465:     assert body["side"] == side_str
   466:     assert body["posSide"] == pos_side
   467:     assert "reduceOnly" not in body
   468: 
   469: 
   470: def test_place_order_precision(monkeypatch):
   471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   472: 
   473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
   474: 
   475:     called = {}
   476: 
   477:     def fake_private(self, method, path, params=None, body=None):
   478:         called["body"] = body
   479:         return {"success": True}
   480: 
   481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   482: 
   483:     client.place_order(
   484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
   485:     )
   486: 
   487:     assert called["body"]["price"] == 1234.57
   488:     assert called["body"]["size"] == 1.235
   489: 
   490: 
   491: def test_margin_cap_skips_order(monkeypatch):
   492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   493:     called = {}
   494: 
   495:     def fake_private(method, path, **kwargs):
   496:         called["path"] = path
   497:         return {"code": "00000"}
   498: 
   499:     monkeypatch.setattr(client, "_private_request", fake_private)
   500:     contract_detail = {
   501:         "data": {
   502:             "symbol": "BTCUSDT_UMCBL",
   503:             "contractSize": 1,
   504:             "volUnit": 1,
   505:             "minVol": 1,
   506:             "minTradeUSDT": 5,
   507:         }
   508:     }
   509:     price = 100.0
   510:     available = 0.5
   511:     vol = bot.compute_position_size(
   512:         contract_detail,
   513:         equity_usdt=available,
   514:         price=price,
   515:         risk_pct=1.0,
   516:         leverage=10,
   517:         symbol="BTCUSDT_UMCBL",
   518:         available_usdt=available,
   519:     )
   520:     if vol > 0:
   521:         client.place_order(
   522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
   523:         )
   524:     assert called == {}
   525: 
   526: 
   527: def test_margin_cap_reduces_volume(monkeypatch):
   528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   529:     called = {}
   530: 
   531:     def fake_private(method, path, **kwargs):
   532:         called["body"] = kwargs.get("body")
   533:         return {"code": "00000"}
   534: 
   535:     monkeypatch.setattr(client, "_private_request", fake_private)
   536:     contract_detail = {
   537:         "data": {
   538:             "symbol": "BTCUSDT_UMCBL",
   539:             "contractSize": 1,
   540:             "volUnit": 1,
   541:             "minVol": 1,
   542:             "minTradeUSDT": 5,
   543:         }
   544:     }
   545:     price = 10.0
   546:     vol_theoretical = bot.compute_position_size(
   547:         contract_detail,
   548:         equity_usdt=100,
   549:         price=price,
   550:         risk_pct=1.0,
   551:         leverage=10,
   552:         symbol="BTCUSDT_UMCBL",
   553:     )
   554:     available = 20.0
   555:     vol_final = bot.compute_position_size(
   556:         contract_detail,
   557:         equity_usdt=available,
   558:         price=price,
   559:         risk_pct=1.0,
   560:         leverage=10,
   561:         symbol="BTCUSDT_UMCBL",
   562:         available_usdt=available,
   563:     )
   564:     assert vol_final < vol_theoretical
   565:     client.place_order(
   566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
   567:     )
   568:     assert called["body"]["size"] == vol_final
   569: 
   570: def test_get_open_orders_paper_trade(monkeypatch):
   571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   572: 
   573:     called = {"count": 0}
   574: 
   575:     def fake_private(*a, **k):
   576:         called["count"] += 1
   577:         return {"success": True}
   578: 
   579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   580: 
   581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
   582: 
   583:     assert resp["success"] is True
   584:     assert resp["data"] == []
   585:     assert called["count"] == 0
   586: 
   587: 
   588: def test_cancel_all_paper_trade(monkeypatch):
   589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   590: 
   591:     called = {"count": 0}
   592: 
   593:     def fake_private(*a, **k):
   594:         called["count"] += 1
   595:         return {"success": True}
   596: 
   597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   598: 
   599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   600: 
   601:     assert resp["success"] is True
   602:     assert called["count"] == 0
   603: 
   604: 
   605: def test_get_kline_transforms_data(monkeypatch):
   606:     client = BitgetFuturesClient("key", "secret", "https://test")
   607: 
   608:     def fake_get(url, params=None, timeout=None):
   609:         class Resp:
   610:             def raise_for_status(self):
   611:                 pass
   612: 
   613:             def json(self):
   614:                 return {
   615:                     "data": [
   616:                         ["1", "2", "3", "1", "2", "10", "20"],
   617:                         ["2", "3", "4", "2", "3", "11", "21"],
   618:                     ]
   619:                 }
   620: 
   621:         return Resp()
   622: 
   623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   624: 
   625:     data = client.get_kline("BTC_USDT", interval="1m")
   626:     kdata = data["data"]
   627:     assert kdata["open"] == [2.0, 3.0]
   628:     assert kdata["high"] == [3.0, 4.0]
   629:     assert kdata["low"] == [1.0, 2.0]
   630:     assert kdata["close"] == [2.0, 3.0]
   631:     assert kdata["volume"] == [10.0, 11.0]
   632:     assert kdata["quoteVolume"] == [20.0, 21.0]


## tests/test_compute_position_size.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules["requests"] = types.ModuleType("requests")
     8: import bot  # noqa: E402
     9: from bot import compute_position_size  # noqa: E402
    10: 
    11: 
    12: def test_compute_position_size_basic():
    13:     contract_detail = {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.01,
    18:                 "volUnit": 1,
    19:                 "minVol": 1,
    20:             }
    21:         ]
    22:     }
    23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
    24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    25:     assert vol == 1
    26: 
    27: 
    28: def test_compute_position_size_symbol_not_found():
    29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
    30:     with pytest.raises(ValueError):
    31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
    32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    33: 
    34: 
    35: def test_compute_position_size_invalid_price():
    36:     contract_detail = {
    37:         "data": [
    38:             {
    39:                 "symbol": "BTC_USDT",
    40:                 "contractSize": 0.01,
    41:                 "volUnit": 1,
    42:                 "minVol": 1,
    43:             }
    44:         ]
    45:     }
    46:     vol = compute_position_size(
    47:         contract_detail,
    48:         equity_usdt=1000,
    49:         price=0,
    50:         risk_pct=0.01,
    51:         leverage=10,
    52:         symbol="BTC_USDT",
    53:     )
    54:     assert vol == 0
    55: 
    56: 
    57: def test_compute_position_size_respects_equity():
    58:     contract_detail = {
    59:         "data": [
    60:             {
    61:                 "symbol": "BTC_USDT",
    62:                 "contractSize": 1,
    63:                 "volUnit": 1,
    64:                 "minVol": 1,
    65:             }
    66:         ]
    67:     }
    68:     vol = compute_position_size(
    69:         contract_detail,
    70:         equity_usdt=5,
    71:         price=100,
    72:         risk_pct=0.01,
    73:         leverage=10,
    74:         symbol="BTC_USDT",
    75:     )
    76:     assert vol == 0
    77: 
    78: 
    79: def test_compute_position_size_leaves_fee_buffer():
    80:     contract_detail = {
    81:         "data": [
    82:             {
    83:                 "symbol": "BTC_USDT",
    84:                 "contractSize": 1,
    85:                 "volUnit": 1,
    86:                 "minVol": 1,
    87:             }
    88:         ]
    89:     }
    90:     vol = compute_position_size(
    91:         contract_detail,
    92:         equity_usdt=100,
    93:         price=100,
    94:         risk_pct=1.0,
    95:         leverage=1,
    96:         symbol="BTC_USDT",
    97:     )
    98:     assert vol == 0
    99: 
   100: 
   101: def test_compute_position_size_under_min_notional_returns_zero():
   102:     contract_detail = {
   103:         "data": [
   104:             {
   105:                 "symbol": "PI_USDT",
   106:                 "contractSize": 1,
   107:                 "volUnit": 1,
   108:                 "minVol": 1,
   109:                 "minTradeUSDT": 5,
   110:             }
   111:         ]
   112:     }
   113:     vol = compute_position_size(
   114:         contract_detail,
   115:         equity_usdt=100,
   116:         price=0.5,
   117:         risk_pct=0.0001,
   118:         leverage=20,
   119:         symbol="PI_USDT",
   120:     )
   121:     assert vol == 0
   122: 
   123: 
   124: def test_compute_position_size_cap_by_available():
   125:     contract_detail = {
   126:         "data": [
   127:             {
   128:                 "symbol": "BTC_USDT",
   129:                 "contractSize": 1,
   130:                 "volUnit": 2,
   131:                 "minVol": 2,
   132:                 "minTradeUSDT": 5,
   133:             }
   134:         ]
   135:     }
   136:     vol = compute_position_size(
   137:         contract_detail,
   138:         equity_usdt=100,
   139:         price=10,
   140:         risk_pct=0.5,
   141:         leverage=10,
   142:         symbol="BTC_USDT",
   143:         available_usdt=0.5,
   144:     )
   145:     assert vol == 0
   146:     vol = compute_position_size(
   147:         contract_detail,
   148:         equity_usdt=100,
   149:         price=10,
   150:         risk_pct=0.5,
   151:         leverage=10,
   152:         symbol="BTC_USDT",
   153:         available_usdt=10,
   154:     )
   155:     assert vol == 8
   156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
   157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
   158:     assert required <= 10


## tests/test_compute_position_size_cap.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules['requests'] = types.ModuleType('requests')
     8: 
     9: from bot import compute_position_size, CONFIG
    10: 
    11: 
    12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
    13:     return {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.001,
    18:                 "volUnit": vol_unit,
    19:                 "minVol": min_vol,
    20:                 "minTradeUSDT": min_trade,
    21:             }
    22:         ]
    23:     }
    24: 
    25: 
    26: def test_volume_zero_when_available_low():
    27:     detail = _detail()
    28:     vol = compute_position_size(
    29:         detail,
    30:         equity_usdt=1000,
    31:         price=10000,
    32:         risk_pct=0.01,
    33:         leverage=10,
    34:         symbol="BTC_USDT",
    35:         available_usdt=0.5,
    36:     )
    37:     assert vol == 0
    38: 
    39: 
    40: def test_margin_close_to_available():
    41:     detail = _detail()
    42:     CONFIG["FEE_RATE"] = 0.001
    43:     available = 1.05
    44:     vol = compute_position_size(
    45:         detail,
    46:         equity_usdt=1000,
    47:         price=10000,
    48:         risk_pct=1,
    49:         leverage=10,
    50:         symbol="BTC_USDT",
    51:         available_usdt=available,
    52:     )
    53:     assert vol == 1
    54:     notional = 10000 * 0.001 * vol
    55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
    56:     required = (notional / 10 + fee) * 1.03
    57:     assert required == pytest.approx(available, rel=0.05)
    58: 
    59: 
    60: def test_respects_units_and_minimums():
    61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
    62:     vol = compute_position_size(
    63:         detail,
    64:         equity_usdt=1000,
    65:         price=1000,
    66:         risk_pct=1,
    67:         leverage=5,
    68:         symbol="BTC_USDT",
    69:         available_usdt=1000,
    70:     )
    71:     assert vol % 2 == 0 and vol >= 2


## tests/test_dynamic_allocation.py (last modified: 2025-08-23 09:47:18)
     1: import math
     2: from scalp.risk import adjust_risk_pct
     3: 
     4: 
     5: def test_adjust_risk_pct_increase_decrease():
     6:     base = 0.01
     7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
     8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
     9: 
    10: 
    11: def test_adjust_risk_pct_bounds():
    12:     assert math.isclose(
    13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
    14:     )
    15:     assert math.isclose(
    16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
    17:     )


## tests/test_effective_leverage.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: from scalp.trade_utils import effective_leverage
     3: 
     4: 
     5: def test_effective_leverage_basic():
     6:     lev = effective_leverage(
     7:         entry_price=100.0,
     8:         liquidation_price=90.0,
     9:         position_margin=10.0,
    10:         position_size=1.0,
    11:     )
    12:     assert lev == pytest.approx(10.0)
    13: 
    14: 
    15: def test_effective_leverage_estimated_margin():
    16:     lev = effective_leverage(
    17:         entry_price=200.0,
    18:         liquidation_price=180.0,
    19:         position_margin=0.0,
    20:         position_size=2.0,
    21:     )
    22:     # price diff 20 * size 2 -> margin 40; notional 400
    23:     assert lev == pytest.approx(10.0)
    24: 
    25: 
    26: def test_effective_leverage_short_position():
    27:     lev = effective_leverage(
    28:         entry_price=100.0,
    29:         liquidation_price=110.0,
    30:         position_margin=10.0,
    31:         position_size=-1.5,
    32:     )
    33:     assert lev == pytest.approx(15.0)
    34: 
    35: 
    36: def test_effective_leverage_invalid():
    37:     assert effective_leverage(0, 0, 0, 0) == 0.0


## tests/test_env_loading.py (last modified: 2025-08-23 09:47:18)
     1: """Tests for loading environment variables from ``notebook/.env``."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import importlib
     6: import os
     7: import sys
     8: from pathlib import Path
     9: 
    10: 
    11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
    12:     """Module should load variables from ``notebook/.env`` if present."""
    13: 
    14:     notebook = tmp_path / "notebook"
    15:     spot = notebook / "spot"
    16:     spot.mkdir(parents=True)
    17:     bitget_bot = spot / "bitget_bot.py"
    18:     bitget_bot.write_text("")
    19:     env_file = notebook / ".env"
    20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
    21: 
    22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
    23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
    24:     import scalp
    25: 
    26:     importlib.reload(scalp)
    27: 
    28:     try:
    29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
    30:     finally:
    31:         env_file.unlink(missing_ok=True)
    32:         if old is None:
    33:             os.environ.pop("BITGET_ACCESS_KEY", None)
    34:         else:
    35:             os.environ["BITGET_ACCESS_KEY"] = old


## tests/test_grid_search.py (last modified: 2025-08-23 09:47:18)
     1: import json
     2: import random
     3: 
     4: import pytest
     5: 
     6: from backtest import grid_search
     7: 
     8: 
     9: def test_build_grid_sampling():
    10:     param_lists = {
    11:         "timeframe": ["1m", "5m", "15m"],
    12:         "score_min": [50, 55, 60],
    13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
    14:     }
    15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
    16:     assert len(combos) == 6
    17:     tfs = {c["timeframe"] for c in combos}
    18:     assert {"1m", "5m", "15m"}.issubset(tfs)
    19: 
    20: 
    21: def test_run_grid_search_with_mock(tmp_path):
    22:     calls = []
    23: 
    24:     def fake_run_backtest_multi(**kwargs):
    25:         tf = kwargs.get("timeframe")
    26:         risk = kwargs.get("risk_pct")
    27:         # fabricate metrics based on params
    28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
    29:         pf += risk  # tiny variation
    30:         metrics = {
    31:             "symbol": "TOTAL",
    32:             "pnl_usdt": 100 * risk,
    33:             "profit_factor": pf,
    34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
    35:             "winrate_pct": 50.0,
    36:             "trades": 40 if tf == "1m" else 30,
    37:         }
    38:         calls.append((tf, risk))
    39:         return [metrics], []
    40: 
    41:     param_lists = {
    42:         "timeframe": ["1m", "5m"],
    43:         "risk_pct": [0.005, 0.01],
    44:     }
    45:     base_params = {
    46:         "timeframe": "1m",
    47:         "risk_pct": 0.005,
    48:     }
    49:     out_dir = tmp_path / "grid"
    50:     grid_search.run_grid_search(
    51:         symbols=["BTC/USDT"],
    52:         exchange="csv",
    53:         base_params=base_params,
    54:         param_lists=param_lists,
    55:         grid_max=4,
    56:         csv_dir="/dev/null",
    57:         out_dir=str(out_dir),
    58:         run_func=fake_run_backtest_multi,
    59:     )
    60:     best = json.loads((out_dir / "best_config.json").read_text())
    61:     # best PF should be timeframe 5m risk 0.01
    62:     assert best["params"]["timeframe"] == "5m"
    63:     assert best["params"]["risk_pct"] == 0.01
    64:     assert len(calls) == 4
    65: 
    66: 
    67: def test_parse_hours():
    68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
    69: 
    70: 
    71: def test_deterministic_results(tmp_path):
    72:     def fake_run_backtest_multi(**kwargs):
    73:         # metrics vary with global random state
    74:         pf = random.uniform(1.0, 3.0)
    75:         metrics = {
    76:             "symbol": "TOTAL",
    77:             "pnl_usdt": random.uniform(-10, 10),
    78:             "profit_factor": pf,
    79:             "max_drawdown_pct": random.uniform(1, 5),
    80:             "winrate_pct": 50.0,
    81:             "trades": random.randint(10, 50),
    82:         }
    83:         return [metrics], []
    84: 
    85:     param_lists = {"timeframe": ["1m", "5m"]}
    86:     base_params = {"timeframe": "1m"}
    87:     out_dir = tmp_path / "grid"
    88:     res1 = grid_search.run_grid_search(
    89:         symbols=["BTC/USDT"],
    90:         exchange="csv",
    91:         base_params=base_params,
    92:         param_lists=param_lists,
    93:         grid_max=2,
    94:         csv_dir="/dev/null",
    95:         out_dir=str(out_dir),
    96:         seed=42,
    97:         run_func=fake_run_backtest_multi,
    98:     )
    99:     best1 = json.loads((out_dir / "best_config.json").read_text())
   100:     # run again
   101:     out_dir2 = tmp_path / "grid2"
   102:     res2 = grid_search.run_grid_search(
   103:         symbols=["BTC/USDT"],
   104:         exchange="csv",
   105:         base_params=base_params,
   106:         param_lists=param_lists,
   107:         grid_max=2,
   108:         csv_dir="/dev/null",
   109:         out_dir=str(out_dir2),
   110:         seed=42,
   111:         run_func=fake_run_backtest_multi,
   112:     )
   113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
   114:     assert best1 == best2
   115:     # also ensure results object same best params
   116:     assert res1[0].params == res2[0].params


## tests/test_heat_score.py (last modified: 2025-08-23 09:47:18)
     1: from scalp.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
     2: 
     3: 
     4: def test_heat_score_value():
     5:     assert heat_score(2.0, 100.0) == 200.0
     6:     assert heat_score(2.0, 100.0, news=True) == 400.0
     7: 
     8: 
     9: def test_select_and_decorrelate_pairs():
    10:     pairs = [
    11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
    12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
    13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
    14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
    15:     ]
    16:     top = select_top_heat_pairs(pairs, top_n=3)
    17:     assert len(top) == 3
    18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
    19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
    20:     syms = {p["symbol"] for p in selected}
    21:     assert not ("A" in syms and "B" in syms)


## tests/test_indicators.py (last modified: 2025-08-23 09:47:18)
     1: 
     2: 
     3: import os
     4: import sys
     5: import pytest
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: 
     8: 
     9: 
    10: 
    11: from scalp.metrics import calc_rsi, calc_atr, calc_macd
    12: 
    13: 
    14: def test_calc_rsi_uptrend():
    15:     prices = list(range(1, 16))  # strictly increasing
    16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
    17: 
    18: 
    19: def test_calc_rsi_downtrend():
    20:     prices = list(range(15, 0, -1))  # strictly decreasing
    21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
    22: 
    23: 
    24: 
    25: def test_calc_rsi_flat():
    26:     prices = [1.0] * 15  # no movement
    27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
    28: 
    29: 
    30: 
    31:     highs = [10, 11, 12, 13, 14]
    32:     lows = [9, 10, 11, 12, 13]
    33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
    34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
    35: 
    36: 
    37: def test_calc_macd_trend():
    38:     prices = list(range(1, 60))
    39:     macd, signal, hist = calc_macd(prices)
    40:     assert macd > signal
    41:     assert hist > 0
    42: 
    43: 
    44: def test_calc_macd_flat():
    45:     prices = [100.0] * 60
    46:     macd, signal, hist = calc_macd(prices)
    47:     assert macd == pytest.approx(0.0)
    48:     assert signal == pytest.approx(0.0)
    49:     assert hist == pytest.approx(0.0)
    50: 
    51: 
    52: 
    53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
    54: def test_calc_rsi_invalid_inputs(prices, period):
    55:     with pytest.raises(ValueError):
    56:         calc_rsi(prices, period=period)
    57: 
    58: 
    59: @pytest.mark.parametrize(
    60:     "highs, lows, closes, period",
    61:     [
    62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
    63:         ([1, 2], [1, 1], [1, 1], 3),
    64:     ],
    65: )
    66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
    67:     with pytest.raises(ValueError):
    68:         calc_atr(highs, lows, closes, period=period)
    69: 


## tests/test_min_qty_rules.py (last modified: 2025-08-23 09:47:18)
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import _apply_contract_checks
     9: 
    10: 
    11: def _detail():
    12:     return {
    13:         "data": [
    14:             {
    15:                 "symbol": "BTC_USDT",
    16:                 "contractSize": 1,
    17:                 "volUnit": 5,
    18:                 "minVol": 10,
    19:                 "minTradeUSDT": 5,
    20:             }
    21:         ]
    22:     }
    23: 
    24: 
    25: def test_min_qty_floor_and_validation():
    26:     detail = _detail()
    27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
    28:     assert vol == 10
    29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
    30:     assert vol2 == 0


## tests/test_notifier.py (last modified: 2025-08-23 09:47:18)
     1: import scalp.notifier as notifier
     2: 
     3: 
     4: def test_notify_skips_without_targets(monkeypatch):
     5:     called = False
     6: 
     7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
     8:         nonlocal called
     9:         called = True
    10: 
    11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    15:     notifier.notify("test", {"foo": 1})
    16:     assert called is False
    17: 
    18: 
    19: def test_notify_posts_http(monkeypatch):
    20:     payload = {}
    21: 
    22:     def fake_post(url, json=None, timeout=5):
    23:         payload["url"] = url
    24:         payload["json"] = json
    25:         payload["timeout"] = timeout
    26: 
    27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    31:     notifier.notify("evt", {"bar": 2})
    32:     assert payload["url"] == "http://example.com"
    33:     assert payload["json"]["event"] == "evt"
    34:     assert payload["json"]["bar"] == 2
    35: 
    36: 
    37: def test_notify_posts_telegram(monkeypatch):
    38:     payload = {}
    39: 
    40:     def fake_post(url, json=None, timeout=5):
    41:         payload["url"] = url
    42:         payload["json"] = json
    43:         payload["timeout"] = timeout
    44: 
    45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    49: 
    50:     notifier.notify("evt", {"bar": 2})
    51: 
    52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
    53:     assert payload["json"]["chat_id"] == "123"
    54:     assert "evt" in payload["json"]["text"]
    55: 
    56: 
    57: def test_notify_posts_both(monkeypatch):
    58:     calls = []
    59: 
    60:     def fake_post(url, json=None, timeout=5):
    61:         calls.append({"url": url, "json": json, "timeout": timeout})
    62: 
    63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    67: 
    68:     notifier.notify("evt", {"bar": 2})
    69: 
    70:     assert len(calls) == 2
    71:     urls = {c["url"] for c in calls}
    72:     assert "http://example.com" in urls
    73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
    74: 
    75: 
    76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
    77:     calls = []
    78: 
    79:     def fake_post(url, json=None, timeout=5):
    80:         calls.append(url)
    81: 
    82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    86: 
    87:     notifier.notify("pair_list", {"pairs": "BTC"})
    88: 
    89:     # Only the generic webhook should be called, not Telegram
    90:     assert calls == ["http://example.com"]
    91: 
    92: 
    93: def test_format_text_open_position():
    94:     payload = {
    95:         "symbol": "BTCUSDT",
    96:         "side": "short",
    97:         "price": 18350,
    98:         "vol": 37,
    99:         "contract_size": 1,
   100:         "notional_usdt": 120.5,
   101:         "leverage": 5,
   102:         "required_margin_usdt": 25.3,
   103:         "available_usdt": 134,
   104:         "risk_level_user": 3,
   105:         "signal_level": 2,
   106:         "risk_color": "🟡",
   107:         "risk_pct_eff": 0.01,
   108:         "fee_rate": 0.001,
   109:     }
   110:     text = notifier._format_text("position_opened", payload)
   111:     lines = text.splitlines()
   112: 
   113:     assert lines[0] == "🟡 Ouvre short BTC"
   114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
   115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
   116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
   117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
   118: 
   119: 
   120: def test_format_text_closed_position():
   121:     payload = {
   122:         "symbol": "BTCUSDT",
   123:         "side": "short",
   124:         "entry_price": 18350,
   125:         "exit_price": 18328,
   126:         "vol": 37,
   127:         "contract_size": 1,
   128:         "notional_entry_usdt": 120.5,
   129:         "notional_exit_usdt": 120.3,
   130:         "fees_usdt": 0.03,
   131:         "pnl_usdt": 0.84,
   132:         "pnl_pct_on_margin": 3.25,
   133:         "leverage": 5,
   134:         "risk_color": "🟡",
   135:         "fee_rate": 0.001,
   136:     }
   137:     text = notifier._format_text("position_closed", payload)
   138:     lines = text.splitlines()
   139:     assert lines[0] == "Ferme short BTC 🟡"
   140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
   141:     assert lines[2] == "% sur marge: 3.25%"
   142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
   143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
   144: 
   145: 
   146: def test_format_text_pair_list_and_start():
   147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
   148:     text = notifier._format_text(
   149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
   150:     )
   151:     assert text == "Listing ok"
   152: 
   153: 
   154: def test_format_pair_list_helper():
   155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
   156:     text = notifier._format_pair_list(payload)
   157:     assert text == "Listing ok"
   158: 
   159: 
   160: def test_format_position_event_helper():
   161:     payload = {
   162:         "symbol": "BTCUSDT",
   163:         "side": "short",
   164:         "price": 18350,
   165:         "vol": 37,
   166:         "contract_size": 1,
   167:         "notional_usdt": 120.5,
   168:         "leverage": 5,
   169:         "required_margin_usdt": 25.3,
   170:         "available_usdt": 134,
   171:         "risk_level_user": 3,
   172:         "signal_level": 2,
   173:         "risk_color": "🟡",
   174:         "risk_pct_eff": 0.01,
   175:         "fee_rate": 0.001,
   176:     }
   177:     text = notifier._format_position_event("position_opened", payload)
   178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
   179: 
   180: 


## tests/test_notional_and_pnl_units.py (last modified: 2025-08-23 09:47:18)
     1: import os, sys, types, pytest
     2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     3: sys.modules['requests'] = types.ModuleType('requests')
     4: 
     5: from scalp.trade_utils import (
     6:     get_contract_size,
     7:     notional as calc_notional,
     8:     required_margin as calc_required_margin,
     9:     compute_pnl_usdt,
    10:     compute_pnl_with_fees,
    11: )
    12: 
    13: 
    14: def _detail():
    15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
    16: 
    17: 
    18: def test_notional_and_pnl_units():
    19:     detail = _detail()
    20:     cs = get_contract_size(detail, "BTC_USDT")
    21:     N = calc_notional(10000, 2, cs)
    22:     assert N == pytest.approx(10000 * 0.001 * 2)
    23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
    24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
    25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
    26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
    27:     pnl_net, pct = compute_pnl_with_fees(
    28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
    29:     )
    30:     gross = (10100 - 10000) * cs * 2
    31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
    32:     expected = gross - fees
    33:     expected_pct = expected / (N / 10) * 100
    34:     assert pnl_net == pytest.approx(expected)
    35:     assert pct == pytest.approx(expected_pct)


## tests/test_pair_selection.py (last modified: 2025-08-23 09:47:18)
     1: import bot
     2: 
     3: 
     4: def test_get_trade_pairs():
     5:     class Client:
     6:         def get_ticker(self, symbol=None):
     7:             return {
     8:                 "success": True,
     9:                 "data": [
    10:                     {"symbol": "BTC_USDT"},
    11:                     {"symbol": "ETH_USDT"},
    12:                 ],
    13:             }
    14: 
    15:     pairs = bot.get_trade_pairs(Client())
    16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
    17: 
    18: 
    19: def test_select_top_pairs():
    20:     class Client:
    21:         def get_ticker(self, symbol=None):
    22:             return {
    23:                 "success": True,
    24:                 "data": [
    25:                     {"symbol": "A", "volume": "1"},
    26:                     {"symbol": "B", "volume": "3"},
    27:                     {"symbol": "C", "volume": "2"},
    28:                 ],
    29:             }
    30: 
    31:     top = bot.select_top_pairs(Client(), top_n=2)
    32:     assert [p["symbol"] for p in top] == ["B", "C"]
    33: 
    34: 
    35: def test_select_top_pairs_default_count():
    36:     class Client:
    37:         def get_ticker(self, symbol=None):
    38:             data = []
    39:             for i in range(100):
    40:                 data.append({"symbol": str(i), "volume": str(i)})
    41:             return {"success": True, "data": data}
    42: 
    43:     top = bot.select_top_pairs(Client())
    44:     assert len(top) == 40
    45: 
    46: 
    47: def test_filter_trade_pairs():
    48:     class Client:
    49:         def get_ticker(self, symbol=None):
    50:             return {
    51:                 "success": True,
    52:                 "data": [
    53:                     {
    54:                         "symbol": "AAA",
    55:                         "volume": "6000000",
    56:                         "bidPrice": "100",
    57:                         "askPrice": "100.03",
    58:                     },  # spread ~3 bps
    59:                     {
    60:                         "symbol": "BBB",
    61:                         "volume": "10000000",
    62:                         "bidPrice": "50",
    63:                         "askPrice": "50.1",
    64:                     },  # spread ~200 bps
    65:                     {
    66:                         "symbol": "CCC",
    67:                         "volume": "7000000",
    68:                         "bidPrice": "10",
    69:                         "askPrice": "10.01",
    70:                     },  # spread ~100 bps
    71:                     {
    72:                         "symbol": "DDD",
    73:                         "volume": "4000000",
    74:                         "bidPrice": "20",
    75:                         "askPrice": "20.01",
    76:                     },  # volume trop faible
    77:                 ],
    78:             }
    79: 
    80:     pairs = bot.filter_trade_pairs(
    81:         Client(),
    82:         volume_min=5_000_000,
    83:         max_spread_bps=5,
    84:     )
    85:     assert [p["symbol"] for p in pairs] == ["AAA"]
    86: 
    87: 
    88: def test_find_trade_positions(monkeypatch):
    89:     class Client:
    90:         def __init__(self):
    91:             self.data = {
    92:                 "AAA": {"data": {"close": [1, 2, 3]}},
    93:                 "BBB": {"data": {"close": [3, 2, 1]}},
    94:             }
    95: 
    96:         def get_kline(self, symbol, interval="1m"):
    97:             return self.data[symbol]
    98: 
    99:     pairs = [
   100:         {"symbol": "AAA", "lastPrice": "1"},
   101:         {"symbol": "BBB", "lastPrice": "1"},
   102:     ]
   103: 
   104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
   105: 
   106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
   107:         if last_fast > prev_fast:
   108:             return 1
   109:         if last_fast < prev_fast:
   110:             return -1
   111:         return 0
   112: 
   113:     monkeypatch.setattr(bot, "cross", fake_cross)
   114: 
   115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
   116:     assert signals == [
   117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
   118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
   119:     ]


## tests/test_pairs.py (last modified: 2025-08-23 09:47:18)
     1: import bot
     2: 
     3: 
     4: def test_send_selected_pairs(monkeypatch):
     5:     sent = {}
     6: 
     7:     def fake_notify(event, payload=None):
     8:         sent["event"] = event
     9:         sent["payload"] = payload
    10: 
    11:     monkeypatch.setattr(bot, "notify", fake_notify)
    12:     monkeypatch.setattr(
    13:         bot,
    14:         "filter_trade_pairs",
    15:         lambda client, top_n=120: [
    16:             {"symbol": "WIFUSDT", "volume": 10},
    17:             {"symbol": "WIFUSDT", "volume": 9},
    18:             {"symbol": "BTCUSD", "volume": 8},
    19:             {"symbol": "BTCUSDT", "volume": 7},
    20:             {"symbol": "DOGEUSDT", "volume": 6},
    21:             {"symbol": "ETHUSDC", "volume": 5},
    22:             {"symbol": "ETHUSDT", "volume": 4},
    23:         ],
    24:     )
    25: 
    26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
    27: 
    28:     payload = bot.send_selected_pairs(object(), top_n=4)
    29: 
    30:     assert sent["event"] == "pair_list"
    31:     assert sent["payload"]["green"] == "BTC"
    32:     assert sent["payload"]["orange"] == "ETH"
    33:     assert "red" not in sent["payload"]
    34:     assert payload == sent["payload"]
    35: 
    36: 
    37: def test_send_selected_pairs_no_whitelist(monkeypatch):
    38:     sent = {}
    39: 
    40:     def fake_notify(event, payload=None):
    41:         sent["payload"] = payload
    42: 
    43:     monkeypatch.setattr(bot, "notify", fake_notify)
    44:     monkeypatch.setattr(
    45:         bot,
    46:         "filter_trade_pairs",
    47:         lambda client, top_n=120: [
    48:             {"symbol": "AAAUSDT", "volume": 10},
    49:             {"symbol": "BBBUSD", "volume": 9},
    50:             {"symbol": "CCCUSDC", "volume": 8},
    51:             {"symbol": "DDDUSDT", "volume": 7},
    52:         ],
    53:     )
    54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
    55: 
    56:     payload = bot.send_selected_pairs(object(), top_n=4)
    57: 
    58:     assert payload == sent["payload"]
    59:     assert payload["green"] == "AAA"
    60:     assert payload["orange"] == "BBB"
    61:     assert payload["red"] == "CCC, DDD"
    62: 
    63: 
    64: def test_filter_trade_pairs_all_pairs(monkeypatch):
    65:     class DummyClient:
    66:         def get_ticker(self):
    67:             return {
    68:                 "data": [
    69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
    70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
    71:                 ]
    72:             }
    73: 
    74:     client = DummyClient()
    75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
    76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
    77: 


## tests/test_risk_manager.py (last modified: 2025-08-23 09:47:18)
     1: from scalp import RiskManager
     2: 
     3: 
     4: def test_kill_switch_triggered() -> None:
     5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
     6:     rm.record_trade(-1.0)
     7:     rm.record_trade(-1.5)
     8:     assert rm.kill_switch is True
     9: 
    10: 
    11: def test_profit_kill_switch_triggered() -> None:
    12:     rm = RiskManager(
    13:         max_daily_loss_pct=10.0,
    14:         max_daily_profit_pct=3.0,
    15:         max_positions=1,
    16:         risk_pct=0.01,
    17:     )
    18:     rm.record_trade(1.5)
    19:     rm.record_trade(1.6)
    20:     assert rm.kill_switch is True
    21: 
    22: 
    23: def test_pause_and_can_open() -> None:
    24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    25:     rm.record_trade(-0.5)
    26:     rm.record_trade(-0.6)
    27:     rm.record_trade(-0.7)
    28:     assert rm.pause_duration() == 15 * 60
    29:     rm.record_trade(-0.8)
    30:     rm.record_trade(-0.9)
    31:     assert rm.pause_duration() == 60 * 60
    32:     assert rm.can_open(0) is True
    33:     assert rm.can_open(1) is False
    34: 
    35: 
    36: def test_risk_pct_scaling() -> None:
    37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    38:     rm.record_trade(1.0)
    39:     rm.record_trade(1.0)
    40:     assert rm.risk_pct > 0.01
    41:     rm.record_trade(-1.0)
    42:     rm.record_trade(-1.0)
    43:     assert rm.risk_pct < 0.01


## tests/test_risk_utils.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: 
     3: from scalp.risk import calc_risk_amount, calc_position_size
     4: 
     5: 
     6: def test_calc_risk_amount_basic():
     7:     assert calc_risk_amount(1000, 0.01) == 10.0
     8: 
     9: 
    10: def test_calc_position_size_basic():
    11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
    12:     assert calc_position_size(1000, 0.01, 50) == 0.2
    13: 
    14: 
    15: @pytest.mark.parametrize("equity,risk_pct", [
    16:     (0, 0.01),
    17:     (-100, 0.01),
    18:     (1000, 0),
    19:     (1000, -0.1),
    20:     (1000, 1.5),
    21: ])
    22: def test_calc_risk_amount_invalid(equity, risk_pct):
    23:     with pytest.raises(ValueError):
    24:         calc_risk_amount(equity, risk_pct)
    25: 
    26: 
    27: @pytest.mark.parametrize("stop_distance", [0, -1])
    28: def test_calc_position_size_invalid_stop(stop_distance):
    29:     with pytest.raises(ValueError):
    30:         calc_position_size(1000, 0.01, stop_distance)


## tests/test_signal_risk.py (last modified: 2025-08-23 09:47:18)
     1: import types
     2: import os
     3: import sys
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import (
     9:     map_score_to_sig_level,
    10:     compute_risk_params,
    11:     prepare_order,
    12:     Signal,
    13:     CONFIG,
    14: )
    15: 
    16: 
    17: class DummyRisk:
    18:     def __init__(self, pct: float) -> None:
    19:         self.risk_pct = pct
    20: 
    21: 
    22: def _contract_detail():
    23:     return {
    24:         "data": [
    25:             {
    26:                 "symbol": "BTC_USDT",
    27:                 "contractSize": 0.001,
    28:                 "volUnit": 1,
    29:                 "minVol": 1,
    30:                 "minTradeUSDT": 5,
    31:             }
    32:         ]
    33:     }
    34: 
    35: 
    36: def test_score_to_level_mapping():
    37:     assert map_score_to_sig_level(10) == 1
    38:     assert map_score_to_sig_level(35) == 2
    39:     assert map_score_to_sig_level(69.9) == 2
    40:     assert map_score_to_sig_level(70) == 3
    41: 
    42: 
    43: def test_risk_tables():
    44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
    45:     assert rp == 0.01 * 1.25
    46:     assert lev == int(20 * 0.75)
    47:     assert cap == 0.55
    48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
    49:     assert rp2 == 0.01 * 1.0
    50:     assert lev2 == int(20 * 0.5)
    51:     assert cap2 == 0.35
    52: 
    53: 
    54: def test_notional_cap():
    55:     rm = DummyRisk(0.05)
    56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    57:     available = 1000
    58:     params = prepare_order(
    59:         sig,
    60:         _contract_detail(),
    61:         equity_usdt=available,
    62:         available_usdt=available,
    63:         base_leverage=10,
    64:         risk_mgr=rm,
    65:         user_risk_level=2,
    66:     )
    67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6


## tests/test_slippage.py (last modified: 2025-08-23 09:47:18)
     1: from scalp.trade_utils import marketable_limit_price
     2: 
     3: 
     4: def test_marketable_limit_price_buy_sell():
     5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
     6:     assert price_buy == 10.0 * 1.001
     7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
     8:     assert price_sell == 9.9 * (1 - 0.001)


## tests/test_strategy_v2.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: 
     3: from scalp import strategy
     4: from scalp.trade_utils import trailing_stop, should_scale_in, timeout_exit
     5: 
     6: 
     7: def make_ohlcv(n=60, start=100, step=1):
     8:     closes = [start + i * step for i in range(n)]
     9:     highs = [c + 1 for c in closes]
    10:     lows = [c - 1 for c in closes]
    11:     vols = [1 for _ in closes]
    12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
    13: 
    14: 
    15: def test_generate_signal_atr_adaptation(monkeypatch):
    16:     base = make_ohlcv(step=2)
    17:     ohlcv_15 = make_ohlcv(n=15, step=2)
    18:     ohlcv_1h = make_ohlcv(step=2)
    19: 
    20:     # patches for deterministic RSI values
    21:     rsi_vals = iter([60, 41, 39])
    22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    24:     # low ATR -> signal disabled
    25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
    26:     sig = strategy.generate_signal(
    27:         "AAA",
    28:         base,
    29:         equity=1_000,
    30:         risk_pct=0.01,
    31:         ohlcv_15m=ohlcv_15,
    32:         ohlcv_1h=ohlcv_1h,
    33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    34:         tick_ratio_buy=0.6,
    35:     )
    36:     assert sig is None
    37: 
    38:     # high ATR -> size reduced
    39:     rsi_vals = iter([60, 41, 39])
    40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
    42:     sig = strategy.generate_signal(
    43:         "AAA",
    44:         base,
    45:         equity=1_000,
    46:         risk_pct=0.01,
    47:         ohlcv_15m=ohlcv_15,
    48:         ohlcv_1h=ohlcv_1h,
    49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    50:         tick_ratio_buy=0.6,
    51:     )
    52:     assert sig and sig.side == "long"
    53:     assert sig.qty == 50
    54: 
    55: 
    56: def test_generate_signal_short_with_filters(monkeypatch):
    57:     base = make_ohlcv(start=200, step=-2)
    58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
    59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
    60: 
    61:     rsi_vals = iter([40, 59, 61])
    62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
    65: 
    66:     sig = strategy.generate_signal(
    67:         "AAA",
    68:         base,
    69:         equity=1_000,
    70:         risk_pct=0.01,
    71:         ohlcv_15m=ohlcv_15,
    72:         ohlcv_1h=ohlcv_1h,
    73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
    74:         tick_ratio_buy=0.4,
    75:     )
    76:     assert sig and sig.side == "short"
    77:     assert sig.qty == 100
    78: 
    79: 
    80: def test_trailing_and_timeout():
    81:     # trailing stop
    82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
    83:     assert sl == pytest.approx(102.5)
    84:     # scaling
    85:     assert should_scale_in(100, 105, 100, 10, "long") is True
    86:     assert should_scale_in(100, 95, 100, 10, "short") is True
    87:     # timeout
    88:     # before the progress window no exit should be triggered
    89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    90:     # after ``progress_min`` minutes without favourable movement we close
    91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    92: 
    93: 
    94: def test_generate_signal_macd_filter(monkeypatch):
    95:     base = make_ohlcv(step=2)
    96:     ohlcv_15 = make_ohlcv(n=15, step=2)
    97:     ohlcv_1h = make_ohlcv(step=2)
    98: 
    99:     rsi_vals = iter([60, 41, 39])
   100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
   104: 
   105:     sig = strategy.generate_signal(
   106:         "AAA",
   107:         base,
   108:         equity=1_000,
   109:         risk_pct=0.01,
   110:         ohlcv_15m=ohlcv_15,
   111:         ohlcv_1h=ohlcv_1h,
   112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   113:         tick_ratio_buy=0.6,
   114:     )
   115:     assert sig is None
   116: 
   117: 
   118: 
   119: def test_generate_signal_trend_ema_filter(monkeypatch):
   120:     base = make_ohlcv(step=2)
   121:     ohlcv_15 = make_ohlcv(n=15, step=2)
   122:     ohlcv_1h = make_ohlcv(step=2)
   123: 
   124:     rsi_vals = iter([60, 41, 39])
   125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   128: 
   129:     orig_ema = strategy.ema
   130: 
   131:     def fake_ema(series, window):
   132:         if window == 200:
   133:             return [x + 1000 for x in orig_ema(series, window)]
   134:         return orig_ema(series, window)
   135: 
   136:     monkeypatch.setattr(strategy, "ema", fake_ema)
   137: 
   138:     sig = strategy.generate_signal(
   139:         "AAA",
   140:         base,
   141:         equity=1_000,
   142:         risk_pct=0.01,
   143:         ohlcv_15m=ohlcv_15,
   144:         ohlcv_1h=ohlcv_1h,
   145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   146:         tick_ratio_buy=0.6,
   147:         trend_ema_period=200,
   148:     )
   149:     assert sig is None
   150:     

## tests/test_telegram_bot.py (last modified: 2025-08-23 09:47:18)
     1: from scalp.telegram_bot import TelegramBot
     2: 
     3: 
     4: class DummyClient:
     5: 
     6:     def __init__(self):
     7:         self.closed = []
     8:         self.closed_all = False
     9: 
    10: 
    11:     def get_assets(self):
    12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
    13: 
    14:     def get_positions(self):
    15:         return {
    16:             "data": [
    17:                 {
    18:                     "symbol": "BTC_USDT",
    19:                     "side": "long",
    20:                     "vol": 2,
    21:                     "pnl_usd": 1.0,
    22:                     "pnl_pct": 5.0,
    23:                 }
    24:             ]
    25:         }
    26: 
    27:     def close_position(self, sym):
    28:         self.closed.append(sym)
    29: 
    30:     def close_all_positions(self):
    31:         self.closed_all = True
    32: 
    33: 
    34: 
    35: class DummyRiskMgr:
    36: 
    37:     def __init__(self):
    38:         self.reset_called = False
    39:         self.max_positions = 1
    40:         self.risk_pct = 0.01
    41: 
    42:     def reset_day(self):
    43:         self.reset_called = True
    44: 
    45: 
    46: class DummyRequests:
    47:     def __init__(self):
    48:         self.posts = []
    49: 
    50:     def post(self, url, json=None, timeout=5):
    51:         self.posts.append((url, json))
    52: 
    53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
    54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
    55: 
    56: 
    57: def make_bot(config=None, requests_module=None):
    58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
    59:     if config:
    60:         cfg.update(config)
    61:     if requests_module is None:
    62:         requests_module = DummyRequests()
    63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
    64: 
    65: 
    66: def test_handle_balance():
    67:     bot = make_bot()
    68: 
    69:     resp, kb = bot.handle_callback("balance", 0.0)
    70:     assert "123.45" in resp
    71:     assert kb == bot.main_keyboard
    72: 
    73: 
    74: 
    75: def test_handle_positions():
    76:     bot = make_bot()
    77:     resp, _ = bot.handle_callback("positions", 0.0)
    78:     assert "BTC" in resp
    79:     assert "PnL" in resp
    80: 
    81: 
    82: def test_handle_positions_zero_pnl():
    83:     bot = make_bot()
    84: 
    85:     def zero_positions():
    86:         return {
    87:             "data": [
    88:                 {
    89:                     "symbol": "BTC_USDT",
    90:                     "side": "long",
    91:                     "vol": 1,
    92:                     "pnl_usd": 0.0,
    93:                     "pnl_pct": 0.0,
    94:                 }
    95:             ]
    96:         }
    97: 
    98:     bot.client.get_positions = zero_positions
    99:     resp, _ = bot.handle_callback("positions", 0.0)
   100:     assert "PnL: 0.00 USDT" in resp
   101: 
   102: 
   103: 
   104: def test_handle_pnl():
   105:     bot = make_bot()
   106:     resp, _ = bot.handle_callback("pnl", 5.0)
   107: 
   108:     assert "5.00" in resp
   109: 
   110: 
   111: def test_handle_risk_change():
   112:     bot = make_bot()
   113: 
   114:     resp, kb = bot.handle_callback("risk_red", 0.0)
   115:     assert "3" in resp
   116:     assert bot.config["RISK_LEVEL"] == 3
   117:     assert kb == bot.main_keyboard
   118: 
   119: 
   120: def test_risk_menu():
   121:     bot = make_bot()
   122:     resp, kb = bot.handle_callback("risk", 0.0)
   123:     assert "risque" in resp.lower()
   124:     assert kb == bot.risk_keyboard
   125: 
   126: 
   127: 
   128: def test_stop_menu_and_actions():
   129:     bot = make_bot()
   130:     resp, kb = bot.handle_callback("stop", 0.0)
   131:     assert any(
   132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
   133:     )
   134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
   135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
   136:     assert "fermée" in resp.lower()
   137:     assert bot.client.closed == ["BTC_USDT"]
   138:     resp, _ = bot.handle_callback("stop_all", 0.0)
   139:     assert bot.client.closed_all is True
   140: 
   141: 
   142: def test_handle_unknown():
   143:     bot = make_bot()
   144:     resp, kb = bot.handle_callback("foobar", 0.0)
   145:     assert resp is None
   146:     assert kb is None
   147: 
   148: 
   149: def test_reset_all():
   150:     bot = make_bot()
   151:     resp, kb = bot.handle_callback("reset_all", 0.0)
   152:     assert "réinitialisés" in resp.lower()
   153:     assert bot.risk_mgr.reset_called is True
   154:     assert bot.client.closed_all is True
   155:     assert kb == bot.settings_keyboard
   156: 
   157: 
   158: def test_shutdown_bot():
   159:     bot = make_bot()
   160:     resp, kb = bot.handle_callback("shutdown", 0.0)
   161:     assert "arrêt" in resp.lower()
   162:     assert bot.stop_requested is True
   163:     assert kb == bot.main_keyboard
   164: 
   165: 
   166: def test_start_sends_menu():
   167:     req = DummyRequests()
   168:     make_bot(requests_module=req)
   169:     assert req.posts
   170:     text = req.posts[0][1]["text"]
   171:     assert "Solde" in text and "PnL session" in text
   172:     assert "Positions max" in text
   173:     assert "Risque actuel" in text
   174: 
   175: 
   176: def test_settings_menu_and_reset_risk():
   177:     bot = make_bot()
   178:     resp, kb = bot.handle_callback("settings", 0.0)
   179:     assert "réglages" in resp.lower()
   180:     assert kb == bot.settings_keyboard
   181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
   182:     assert "risque" in resp.lower()
   183:     assert bot.risk_mgr.reset_called is True
   184:     assert kb == bot.settings_keyboard
   185: 
   186: 
   187: def test_update_button(monkeypatch):
   188:     bot = make_bot()
   189:     called = {}
   190: 
   191:     def fake_update():
   192:         called["called"] = True
   193: 
   194:     bot.update_pairs = fake_update
   195:     resp, kb = bot.handle_callback("update", 0.0)
   196:     assert called["called"] is True
   197:     assert "mise à jour" in resp.lower()
   198:     assert kb == bot.main_keyboard
   199: 
   200: 
   201: def test_maxpos_menu_and_change():
   202:     bot = make_bot()
   203:     resp, kb = bot.handle_callback("maxpos", 0.0)
   204:     assert "nombre" in resp.lower()
   205:     assert kb == bot.maxpos_keyboard
   206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
   207:     assert "3" in resp
   208:     assert bot.config["MAX_POSITIONS"] == 3
   209:     assert bot.risk_mgr.max_positions == 3
   210:     assert kb == bot.main_keyboard
   211: 
   212: 
   213: def test_stop_no_positions():
   214:     bot = make_bot()
   215:     bot.client.get_positions = lambda: {"data": []}
   216:     resp, kb = bot.handle_callback("stop", 0.0)
   217:     assert "aucune crypto" in resp.lower()
   218:     assert kb == bot.settings_keyboard
   219: 


## tests/test_utils.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: from bot import ema, cross, compute_position_size, CONFIG
     3: from scalp.trade_utils import extract_available_balance
     4: 
     5: 
     6: def test_ema_basic():
     7:     data = [1, 2, 3, 4, 5]
     8:     result = ema(data, 3)
     9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
    10: 
    11: 
    12: def test_cross_up_down_none():
    13:     assert cross(3, 2, 1, 2) == 1  # up cross
    14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
    15:     assert cross(2, 2, 2, 2) == 0  # no cross
    16: 
    17: 
    18: def test_compute_position_size():
    19:     detail = {
    20:         "data": [
    21:             {
    22:                 "symbol": CONFIG["SYMBOL"],
    23:                 "contractSize": 0.001,
    24:                 "volUnit": 1,
    25:                 "minVol": 1,
    26:             }
    27:         ]
    28:     }
    29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
    30:                                 risk_pct=0.01, leverage=5)
    31:     assert vol == 1
    32: 
    33: 
    34: def test_compute_position_size_missing_symbol():
    35:     with pytest.raises(ValueError):
    36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
    37: 
    38: 
    39: def test_extract_available_balance_fallback():
    40:     assets = {
    41:         "data": [
    42:             {
    43:                 "currency": "USDT",
    44:                 "available": 0,
    45:                 "cashBalance": "150.5",
    46:                 "equity": "200",
    47:             }
    48:         ]
    49:     }
    50:     assert extract_available_balance(assets) == 150.5
    51: 
    52: 
    53: def test_extract_available_balance_equity_only():
    54:     assets = {
    55:         "data": [
    56:             {
    57:                 "currency": "USDT",
    58:                 "equity": "42",
    59:             }
    60:         ]
    61:     }
    62:     assert extract_available_balance(assets) == 42.0
    63: 
    64: 
    65: def test_extract_available_balance_zero_available_returns_zero():
    66:     assets = {
    67:         "data": [
    68:             {
    69:                 "currency": "USDT",
    70:                 "available": 0,
    71:                 "availableBalance": 0,
    72:                 "equity": "42",
    73:             }
    74:         ]
    75:     }
    76:     assert extract_available_balance(assets) == 0.0


## tests/test_version.py (last modified: 2025-08-23 09:47:18)
     1: import pytest
     2: from scalp import version
     3: 
     4: 
     5: def test_get_version(monkeypatch, tmp_path):
     6:     vfile = tmp_path / "VERSION"
     7:     vfile.write_text("1.2.3")
     8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
     9:     assert version.get_version() == "1.2.3"
    10: 
    11: 
    12: def test_bump_version(monkeypatch, tmp_path):
    13:     vfile = tmp_path / "VERSION"
    14: 
    15:     vfile.write_text("0.1.2\n")
    16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    17:     assert version.bump_version("minor") == "0.2.0"
    18:     assert vfile.read_text().strip() == "0.2.0"
    19: 
    20: 
    21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
    22:     vfile = tmp_path / "VERSION"
    23:     vfile.write_text("0.1.0\n")
    24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    25:     with pytest.raises(ValueError):
    26:         version.bump_version("foo")
    27: 
    28: 
    29: def test_bump_from_message(monkeypatch, tmp_path):
    30:     vfile = tmp_path / "VERSION"
    31:     vfile.write_text("1.0.0\n")
    32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
    34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
    35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
    36: 


## tests/test_walk_forward.py (last modified: 2025-08-23 09:47:18)
     1: from scalp.backtest import walk_forward_windows
     2: 
     3: 
     4: def test_walk_forward_windows():
     5:     data = list(range(10))
     6:     windows = list(walk_forward_windows(data, train=4, test=2))
     7:     assert windows == [
     8:         ([0, 1, 2, 3], [4, 5]),
     9:         ([2, 3, 4, 5], [6, 7]),
    10:         ([4, 5, 6, 7], [8, 9]),
    11:     ]


## tests/test_ws.py (last modified: 2025-08-23 09:47:18)
     1: import asyncio
     2: 
     3: from scalp.ws import WebsocketManager
     4: 
     5: 
     6: def test_websocket_manager_stop():
     7:     async def connect():
     8:         return None
     9: 
    10:     async def subscribe():
    11:         return None
    12: 
    13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
    14: 
    15:     async def run_and_stop():
    16:         await ws.run()
    17:         assert ws._heartbeat_task is not None
    18:         await ws.stop()
    19:         assert ws._heartbeat_task is None
    20: 
    21:     asyncio.run(run_and_stop())


