# Scalp Project Code Dump
# Generated: 2025-10-27 13:06:57 UTC
# Root: /opt/scalp
# Caps: 512KB/file, max 4000 files
# Exclusions: hidden, .git, __pycache__, venv/.venv, var, logs, data, reports, dump
# Extensions: py, pyi, sh, bash, ini, cfg, conf, toml, yaml/yml, md, txt, sql, json, csv

========== TREE (size, mtime) ==========
/opt/scalp/project/bin/a_analyse.sh                                                         88  2025-10-26 18:03:22.883271493 +0100
/opt/scalp/project/bin/b_dash.sh                                                            85  2025-10-27 06:42:34.110928924 +0100
/opt/scalp/project/bin/b_signals.sh                                                         88  2025-10-26 19:01:24.741873511 +0100
/opt/scalp/project/bin/oa_ohlcv.sh                                                          89  2025-10-26 18:03:16.207265495 +0100
/opt/scalp/project/bin/oa_ohlcv_A.sh                                                        89  2025-10-25 17:23:57.298226222 +0200
/opt/scalp/project/bin/ob_ohlcv_B.sh                                                        89  2025-10-25 13:12:44.107774002 +0200
/opt/scalp/project/bin/t_ticks.sh                                                           86  2025-10-25 17:24:36.322276510 +0200
/opt/scalp/project/bin/u_universe.sh                                                        89  2025-10-25 17:23:40.450204518 +0200
/opt/scalp/project/bin/x_close.sh                                                          102  2025-10-27 13:32:48.246660187 +0100
/opt/scalp/project/bin/x_dash.sh                                                          2086  2025-10-25 15:39:57.721793619 +0200
/opt/scalp/project/bin/x_follow.sh                                                         103  2025-10-27 13:32:41.118652027 +0100
/opt/scalp/project/bin/x_open.sh                                                           101  2025-10-27 13:32:31.822641387 +0100
/opt/scalp/project/bin/xclose.sh                                                            86  2025-10-27 06:43:25.474998597 +0100
/opt/scalp/project/bin/xfollow.sh                                                           87  2025-10-27 06:43:14.554983825 +0100
/opt/scalp/project/bin/xopen.sh                                                             85  2025-10-27 06:38:40.982605637 +0100
/opt/scalp/project/config/scalp.conf                                                        18  2025-10-25 17:08:55.549075009 +0200
/opt/scalp/project/scripts/A_analyse.py                                                   3244  2025-10-27 10:42:04.926983517 +0100
/opt/scalp/project/scripts/A_ctx_dash.py                                                   634  2025-10-27 10:42:38.399008054 +0100
/opt/scalp/project/scripts/B_dash.py                                                       472  2025-10-26 19:02:03.217938218 +0100
/opt/scalp/project/scripts/B_signals.py                                                   2658  2025-10-27 10:48:09.387284052 +0100
/opt/scalp/project/scripts/H_score.py                                                      368  2025-10-27 09:03:02.367929303 +0100
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482  2025-10-26 10:53:32.748328034 +0100
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1667  2025-10-25 13:12:20.467743772 +0200
/opt/scalp/project/scripts/T_ticks.py                                                      700  2025-10-25 17:24:28.282266152 +0200
/opt/scalp/project/scripts/U_universe.py                                                   572  2025-10-26 07:24:51.520542760 +0100
/opt/scalp/project/scripts/X_close.py                                                       94  2025-10-27 13:32:23.122631432 +0100
/opt/scalp/project/scripts/X_config.py                                                     862  2025-10-27 10:58:46.599909791 +0100
/opt/scalp/project/scripts/X_dash.py                                                      1761  2025-10-27 13:17:53.937659362 +0100
/opt/scalp/project/scripts/X_follow.py                                                    1970  2025-10-27 13:32:13.578620514 +0100
/opt/scalp/project/scripts/X_open.py                                                      2599  2025-10-27 13:31:41.682584047 +0100
/opt/scalp/project/scripts/b_dash.py                                                       572  2025-10-27 10:48:18.187292036 +0100
/opt/scalp/project/scripts/init_db.py                                                     1110  2025-10-26 07:32:15.285178016 +0100
/opt/scalp/project/scripts/x_dash.py                                                      1689  2025-10-27 09:06:10.048075732 +0100

========== TOP 10 BIGGEST FILES ==========
/opt/scalp/project/scripts/A_analyse.py                                                   3244
/opt/scalp/project/scripts/B_signals.py                                                   2658
/opt/scalp/project/scripts/X_open.py                                                      2599
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482
/opt/scalp/project/bin/x_dash.sh                                                          2086
/opt/scalp/project/scripts/X_follow.py                                                    1970
/opt/scalp/project/scripts/X_dash.py                                                      1761
/opt/scalp/project/scripts/x_dash.py                                                      1689
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1667
/opt/scalp/project/scripts/init_db.py                                                     1110

========== CONCAT CONTENT ==========

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_dash.py
Size: 472
MTime: 2025-10-26 19:02:03.217938218 +0100
----- CONTENT -----
import sqlite3
DB="/opt/scalp/project/data/signals.db"

con=sqlite3.connect(DB)
rows=con.execute("""
SELECT ts_signal,instId,side,reason,ctx,score_A,score_B,price
FROM signals
ORDER BY ts_signal DESC LIMIT 12
""").fetchall()
con.close()

print("\n===== LAST SIGNALS (B) =====")
for r in rows:
    ts,inst,side,reason,ctx,sA,sB,price = r
    print(f"{inst:10} | {side:4} | {reason:12} | {ctx:7} | A={sA:.3f} | B={sB:.3f} | {price}")
print("============================\n")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/H_score.py
Size: 368
MTime: 2025-10-27 09:03:02.367929303 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_H="/opt/scalp/project/data/x_history.db"

def latest_H():
    con=sqlite3.connect(DB_H)
    row=con.execute("SELECT score_H FROM v_H_latest").fetchone()
    con.close()
    return float(row[0]) if row and row[0] else 0.0

def run():
    h=latest_H()
    print(f"[H] score_H={h:.3f}")

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_close.py
Size: 94
MTime: 2025-10-27 13:32:23.122631432 +0100
----- CONTENT -----
#!/usr/bin/env python3
# CLOSE handled by X_follow
import time
while True:
    time.sleep(60)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/b_dash.py
Size: 572
MTime: 2025-10-27 10:48:18.187292036 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3
from datetime import datetime

DB="/opt/scalp/project/data/signals.db"
con=sqlite3.connect(DB)
rows=con.execute("""
SELECT instId,side,ctx,score_U,score_A,score_B,reason,ts_signal
FROM signals ORDER BY ts_signal DESC LIMIT 10
""").fetchall()
con.close()

print("===== LAST SIGNALS (B) =====")
for r in rows:
    inst,side,ctx,SU,SA,SB,reason,ts=r
    h=datetime.fromtimestamp(ts/1000).strftime("%H:%M:%S")
    print(f"{inst} | {side} | {ctx} | U={SU:.2f} A={SA:.2f} B={SB:.2f} | {reason} | {h}")
print("============================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OB_ohlcv_B.py
Size: 1667
MTime: 2025-10-25 13:12:20.467743772 +0200
----- CONTENT -----
import ccxt
import sqlite3
import time

DBu = "/opt/scalp/project/data/u.db"
DBo = "/opt/scalp/project/data/ob.db"

ex = ccxt.bitget()

def init_db():
    con = sqlite3.connect(DBo, timeout=5)
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_1m(
        instId TEXT,
        ts INTEGER,
        o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_3m(
        instId TEXT,
        ts INTEGER,
        o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.commit()
    con.close()

def get_universe():
    con = sqlite3.connect(DBu, timeout=5)
    rows = con.execute("SELECT instId FROM universe").fetchall()
    con.close()
    return [r[0] for r in rows]

def upsert(tf, inst, ohlcv):
    tbl = "kline_1m" if tf == "1m" else "kline_3m"
    con = sqlite3.connect(DBo, timeout=5)
    con.execute(f"INSERT OR REPLACE INTO {tbl}(instId,ts,o,h,l,c,v) VALUES(?,?,?,?,?,?,?)",
                (inst, ohlcv[0], ohlcv[1], ohlcv[2], ohlcv[3], ohlcv[4], ohlcv[5]))
    con.commit()
    con.close()

def fetch_tf(inst, tf):
    ohlc = ex.fetch_ohlcv(inst, tf, limit=150)
    for o in ohlc:
        upsert(tf, inst, o)
    print(f"[OB] {inst} {tf} stored ({len(ohlc)} candles)")

if __name__ == "__main__":
    init_db()
    while True:
        try:
            universe = get_universe()
            for inst in universe:
                fetch_tf(inst, "1m")
                fetch_tf(inst, "3m")
            time.sleep(10)
        except Exception as e:
            print("[OB ERROR]", e)
            time.sleep(5)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_signals.py
Size: 2658
MTime: 2025-10-27 10:48:09.387284052 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time, math

DB_T = "/opt/scalp/project/data/t.db"
DB_A = "/opt/scalp/project/data/a.db"
DB_S = "/opt/scalp/project/data/signals.db"
COOLDOWN = 60  # seconds

def now(): return int(time.time()*1000)

def last_tick(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price, ts FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return (float(r[0]), int(r[1])) if r else (None,None)

def last_ctx(inst):
    con = sqlite3.connect(DB_A)
    r = con.execute("""
        SELECT score_U, score_A, p_buy, p_sell, ctx
        FROM ctx_a_latest
        WHERE instId=?
    """,(inst,)).fetchone()
    con.close()
    return (r[0],r[1],r[2],r[3],r[4]) if r else (None,None,None,None,"none")

def last_signal_ts(inst):
    con=sqlite3.connect(DB_S)
    r=con.execute("SELECT ts_signal FROM signals WHERE instId=? ORDER BY ts_signal DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return int(r[0]) if r else 0

def insert(inst,side,ctx,SU,SA,SB,reason,ts):
    con=sqlite3.connect(DB_S)
    con.execute("""
        INSERT INTO signals(instId,side,ctx,score_U,score_A,score_B,reason,ts_signal)
        VALUES(?,?,?,?,?,?,?,?)
    """,(inst,side,ctx,SU,SA,SB,reason,ts))
    con.commit()
    con.close()

# Trend(-1..+1)
def trend_signal(p_buy,p_sell):
    return p_buy - p_sell

# MR(-1..+1)
def mr_signal(price,mid):
    return (mid-price)/mid

# Breakout/Pullback placeholders (light but clean)
def breakout_signal(price,closes):
    hi=max(closes); lo=min(closes)
    if price>hi: return 1
    if price<lo: return -1
    return 0

def pullback_signal(price,closes,ctx):
    ma=sum(closes[-10:])/10
    if ctx=="bullish" and price>ma: return 1
    if ctx=="bearish" and price<ma: return -1
    return 0

def run():
    con=sqlite3.connect(DB_A)
    insts=[r[0] for r in con.execute("SELECT instId FROM ctx_a_latest")]
    con.close()

    for inst in insts:
        if now()-last_signal_ts(inst)<COOLDOWN*1000: continue
        price,ts_tick=last_tick(inst)
        if not price: continue
        SU,SA,pb,ps,ctx=last_ctx(inst)

        trend = trend_signal(pb,ps)
        closes = [price]*10
        bo = breakout_signal(price,closes) if ctx!="range" else 0
        pbk = pullback_signal(price,closes,ctx) if ctx!="range" else 0
        mr = mr_signal(price,price) if ctx=="range" else 0

        # Fusion pondérée
        SB = 0.5*trend + 0.3*bo + 0.2*mr

        if SB>0.002:
            insert(inst,"buy",ctx,SU,SA,SB,"trend_up",ts_tick)
        elif SB<-0.002:
            insert(inst,"sell",ctx,SU,SA,SB,"trend_down",ts_tick)

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_open.py
Size: 2599
MTime: 2025-10-27 13:31:41.682584047 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from X_config import *
from datetime import datetime

def log(msg):
    print(f"[X_OPEN] {datetime.utcnow()} | {msg}")

def get_last_signal():
    con = sqlite3.connect(DB_SIG)
    row = con.execute("""
        SELECT instId, side, score_U, score_A, score_B, ts_signal
        FROM signals_for_open
        ORDER BY ts_signal DESC LIMIT 1
    """).fetchone()
    con.close()
    return row

def is_in_cooldown(ts_signal):
    return (time.time() - ts_signal/1000) < COOLDOWN_OPEN

def last_price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("""
        SELECT price FROM ticks
        WHERE instId=?
        ORDER BY ts DESC LIMIT 1
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def atr(inst):
    con = sqlite3.connect(DB_A)
    r = con.execute("""
        SELECT atr1m FROM feat_1m
        WHERE instId=?
        ORDER BY ts DESC LIMIT 1
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def already_open(inst):
    con = sqlite3.connect(DB_XOPEN)
    r = con.execute("SELECT instId FROM positions_open WHERE instId=?",(inst,)).fetchone()
    con.close()
    return r is not None

def open_trade(inst,side,entry,u,a,b,atr):
    sl = entry - ATR_SL_MULT*atr if side=="buy" else entry + ATR_SL_MULT*atr
    tp = entry + ATR_TP_MULT*atr if side=="buy" else entry - ATR_TP_MULT*atr
    qty = 1.0
    ts = int(time.time()*1000)

    con = sqlite3.connect(DB_XOPEN)
    con.execute("""
        INSERT INTO positions_open(instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open)
        VALUES(?,?,?,?,?,?,?,?,?,?)
    """,(inst,side,entry,sl,tp,qty,u,a,b,ts))
    con.commit()
    con.close()

    conF = sqlite3.connect(DB_XFOLLOW)
    conF.execute("""
        INSERT OR REPLACE INTO follow(instId,side,atr,be_active,trail_active,ts_update)
        VALUES(?,?,?,?,?,?)
    """,(inst,side,atr,0,0,ts))
    conF.commit()
    conF.close()

    log(f"OPEN {inst} {side} @ {entry}")

def run():
    log("READY")
    while True:
        sig = get_last_signal()
        if not sig:
            time.sleep(1)
            continue

        inst,side,u,a,b,ts_sig = sig
        if already_open(inst): 
            time.sleep(1)
            continue

        if is_in_cooldown(ts_sig):
            time.sleep(1)
            continue

        price = last_price(inst)
        aatr = atr(inst)
        if not price or not aatr:
            time.sleep(1)
            continue

        open_trade(inst,side,price,u,a,b,aatr)
        time.sleep(1)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_follow.py
Size: 1970
MTime: 2025-10-27 13:32:13.578620514 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from X_config import *
from datetime import datetime

def log(msg):
    print(f"[X_FOLLOW] {datetime.utcnow()} | {msg}")

def price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def close_trade(inst,side,entry,px,qty,u,a,b,ts_open,reason):
    pnl = (px-entry)*qty if side=="buy" else (entry-px)*qty
    ts = int(time.time()*1000)

    con = sqlite3.connect(DB_XHIST)
    con.execute("""
        INSERT INTO x_history(instId,side,entry,exit,qty,pnl,score_U,score_A,score_B,ts_open,ts_close,reason)
        VALUES(?,?,?,?,?,?,?,?,?,?,?,?)
    """,(inst,side,entry,px,qty,pnl,u,a,b,ts_open,ts,reason))
    con.commit()
    con.close()

    con2 = sqlite3.connect(DB_XOPEN)
    con2.execute("DELETE FROM positions_open WHERE instId=?",(inst,))
    con2.commit()
    con2.close()

    con3 = sqlite3.connect(DB_XFOLLOW)
    con3.execute("DELETE FROM follow WHERE instId=?",(inst,))
    con3.commit()
    con3.close()

    log(f"CLOSE {inst} {reason} @ {px} pnl={pnl:.4f}")

def run():
    log("READY")
    while True:
        con = sqlite3.connect(DB_XOPEN)
        rows = con.execute("""
            SELECT instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open
            FROM positions_open
        """).fetchall()
        con.close()

        for inst,side,entry,sl,tp,qty,u,a,b,ts_open in rows:
            px = price(inst)
            if not px: continue

            if (side=="buy" and px<=sl) or (side=="sell" and px>=sl):
                close_trade(inst,side,entry,px,qty,u,a,b,ts_open,"SL")
                continue

            if (side=="buy" and px>=tp) or (side=="sell" and px<=tp):
                close_trade(inst,side,entry,px,qty,u,a,b,ts_open,"TP")
                continue

        time.sleep(FOLLOW_INTERVAL)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OA_ohlcv_A.py
Size: 2482
MTime: 2025-10-26 10:53:32.748328034 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time, ccxt

DBU = "/opt/scalp/project/data/u.db"
DBO = "/opt/scalp/project/data/oa.db"
TF_LIST = ["5m","15m","30m"]
INIT = 150
MAX_ROWS = 300

ex = ccxt.bitget()

def to_bitget_symbol(inst: str) -> str:
    return inst if ":" in inst else f"{inst}:USDT"

def ensure_schema():
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    for tf in TF_LIST:
        cur.execute(f"DROP TABLE IF EXISTS ohlcv_{tf}")
        cur.execute(f"""
        CREATE TABLE IF NOT EXISTS ohlcv_{tf}(
          instId TEXT,
          ts INTEGER,
          open REAL, high REAL, low REAL, close REAL, volume REAL,
          PRIMARY KEY(instId, ts)
        )
        """)
    con.commit()
    con.close()

def load_universe():
    con = sqlite3.connect(DBU, timeout=5)
    rows = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()
    return rows

def last_ts(con, tf, inst):
    row = con.execute(f"SELECT MAX(ts) FROM ohlcv_{tf} WHERE instId=?", (inst,)).fetchone()
    return row[0] if row and row[0] is not None else None

def upsert_batch(tf, inst, batch):
    if not batch:
        return
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    cur.executemany(
        f"INSERT OR REPLACE INTO ohlcv_{tf}(instId,ts,open,high,low,close,volume) VALUES (?,?,?,?,?,?,?)",
        [(inst, o[0], o[1], o[2], o[3], o[4], o[5]) for o in batch]
    )
    cur.execute(f"""
        DELETE FROM ohlcv_{tf}
        WHERE instId=?
          AND ts NOT IN (
            SELECT ts FROM ohlcv_{tf}
            WHERE instId=?
            ORDER BY ts DESC
            LIMIT {MAX_ROWS}
          )
    """, (inst, inst))
    con.commit()
    con.close()

def sync_inst_tf(inst, tf):
    inst_ccxt = to_bitget_symbol(inst)
    con = sqlite3.connect(DBO, timeout=5)
    ts_last = last_ts(con, tf, inst)
    con.close()

    if ts_last is None:
        data = ex.fetch_ohlcv(inst_ccxt, tf, limit=INIT)
        upsert_batch(tf, inst, data)
        return

    data = ex.fetch_ohlcv(inst_ccxt, tf, since=ts_last + 1, limit=150)
    upsert_batch(tf, inst, data)

def main():
    ensure_schema()
    insts = load_universe()
    for inst in insts:
        for tf in TF_LIST:
            try:
                sync_inst_tf(inst, tf)
                time.sleep(0.25)
            except Exception as e:
                print(f"[OA][{inst}][{tf}] WARN: {e}")
    print("[OA] ✅ Multi-TF sync to oa.db")

if __name__ == "__main__":
    main()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/T_ticks.py
Size: 700
MTime: 2025-10-25 17:24:28.282266152 +0200
----- CONTENT -----
import ccxt.pro as ccxtpro, sqlite3, time

UDB = "/opt/scalp/project/data/u.db"
TDB = "/opt/scalp/project/data/t.db"

async def run():
    con = sqlite3.connect(UDB)
    insts = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()

    ex = ccxtpro.bitget()

    while True:
        for inst in insts:
            ticker = await ex.watch_ticker(inst)
            ts = int(time.time() * 1000)
            price = ticker['last']
            conT = sqlite3.connect(TDB, timeout=5)
            conT.execute("INSERT INTO ticks VALUES(?,?,?)", (inst, ts, price))
            conT.commit()
            conT.close()

if __name__ == "__main__":
    import asyncio
    asyncio.run(run())
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_analyse.py
Size: 3244
MTime: 2025-10-27 10:42:04.926983517 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, math, time
from datetime import datetime

DB_A  = "/opt/scalp/project/data/a.db"
DB_OA = "/opt/scalp/project/data/oa.db"
DB_U  = "/opt/scalp/project/data/u.db"
MAX_ROWS = 10  # historique par coin

# =========================================================
# TOOLS
# =========================================================
def now_ts():
    return int(time.time() * 1000)

def softmax(v):
    e = [math.exp(x) for x in v]
    s = sum(e)
    return [x / s for x in e]

# =========================================================
# U2 SCORE (softmax volu / vola / ratio) → clamp[-1;1]
# =========================================================
def compute_U(volu, vola):
    volu = max(volu, 1)
    vola = max(vola, 1)
    ratio = volu / (volu + vola)
    s1, s2, s3 = softmax([volu, vola, ratio])
    U = s1 - s2
    return max(-1.0, min(1.0, U))

# =========================================================
# LOAD UNIVERSE + OHLCV
# =========================================================
def get_universe():
    con = sqlite3.connect(DB_U)
    rows = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()
    return rows

def load_ohlcv(inst):
    con = sqlite3.connect(DB_OA)
    rows = con.execute("""
        SELECT close, volume FROM ohlcv_5m
        WHERE instId=? ORDER BY ts DESC LIMIT 50
    """,(inst,)).fetchall()
    con.close()
    return rows[::-1]

# =========================================================
# CALCUL SCORE A + CTX (A2 avec range)
# =========================================================
def compute_A(closes):
    if len(closes) < 20:
        return 0,0,"none"

    ma_fast = sum(closes[-5:]) / 5
    ma_slow = sum(closes[-20:]) / 20
    diff = ma_fast - ma_slow

    # Softmax -> p_buy,p_hold,p_sell
    raw = [diff, 0, -diff]
    p_buy, p_hold, p_sell = softmax(raw)

    # ctx A2
    if abs(p_buy - p_sell) < 0.02:
        ctx = "range"
    else:
        ctx = "bullish" if diff > 0 else "bearish"

    return p_buy, p_sell, diff, ctx

# =========================================================
# SAVE CTX
# =========================================================
def save_ctx(inst, ts, score_U, score_A, p_buy, p_sell, ctx):
    con = sqlite3.connect(DB_A)
    cur = con.cursor()
    cur.execute("INSERT INTO ctx_a VALUES(?,?,?,?,?,?,?)",
                (inst, ts, score_U, score_A, p_buy, p_sell, ctx))
    cur.execute("""
        DELETE FROM ctx_a
        WHERE instId=? AND ts NOT IN (
            SELECT ts FROM ctx_a WHERE instId=?
            ORDER BY ts DESC LIMIT ?
        )
    """,(inst,inst,MAX_ROWS))
    con.commit()
    con.close()

# =========================================================
# MAIN
# =========================================================
def run():
    ts = now_ts()
    for inst in get_universe():
        data = load_ohlcv(inst)
        if not data: 
            continue

        closes = [c[0] for c in data]
        vols   = [c[1] for c in data]

        # U2
        score_U = compute_U(sum(vols[-10:]), sum(vols))

        # A2
        p_buy, p_sell, score_A, ctx = compute_A(closes)

        save_ctx(inst, ts, score_U, score_A, p_buy, p_sell, ctx)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/x_dash.py
Size: 1689
MTime: 2025-10-27 09:06:10.048075732 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DBP="/opt/scalp/project/data/x_open.db"
DBF="/opt/scalp/project/data/x_follow.db"
DBH="/opt/scalp/project/data/x_history.db"

def h(ts):return datetime.fromtimestamp(ts/1000).strftime("%H:%M:%S")

def get_H(inst):
    con=sqlite3.connect(DBH)
    r=con.execute("""
    WITH last20 AS (
        SELECT pnl FROM history WHERE instId=?
        ORDER BY ts_close DESC LIMIT 20
    ),
    stats AS (
        SELECT 
            (SELECT COUNT(*) FROM last20 WHERE pnl>0)*1.0/(SELECT COUNT(*) FROM last20) AS winrate,
            (SELECT SUM(pnl) FROM last20 WHERE pnl>0) AS sum_win,
            (SELECT SUM(ABS(pnl)) FROM last20 WHERE pnl<0) AS sum_loss
    )
    SELECT 
        CASE WHEN sum_loss IS NULL OR sum_loss=0 THEN 1.0 
        ELSE (0.50*winrate + 0.50*MIN(1.0, (sum_win/sum_loss)/2.0))
        END AS H
    FROM stats
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r and r[0] else 0.0

print("===== X DASH =====")

# OPEN
con=sqlite3.connect(DBP)
rows=con.execute("SELECT instId,side,entry,qty,lev,risk,score_G,ts_open FROM positions_open").fetchall()
con.close()
if not rows:
    print("No open position")
else:
    for r in rows:
        inst,side,e,qty,lev,risk,sg,ts=r
        Hs=get_H(inst)
        print(f"{inst} | {side} | entry={e} | lev={lev:.2f} | risk={risk:.3f} | G={sg:.3f} | H={Hs:.3f} | {h(ts)}")

# FOLLOW
con=sqlite3.connect(DBF)
rows=con.execute("SELECT instId,current,upnl,stage,ts_update FROM follow").fetchall()
con.close()
for r in rows:
    inst,cur,u,st,ts=r
    print(f"FOLLOW -> {inst} | {cur} | upnl={u:.4f} | {st} | {h(ts)}")

print("===================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_dash.py
Size: 1761
MTime: 2025-10-27 13:17:53.937659362 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_O = "/opt/scalp/project/data/x_open.db"
DB_H = "/opt/scalp/project/data/x_history.db"
DB_T = "/opt/scalp/project/data/t.db"

def h(ts): 
    return time.strftime("%H:%M:%S", time.localtime(ts/1000))

def price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

# ===== OPEN POSITIONS =====
print("===== OPEN POSITIONS =====")
con = sqlite3.connect(DB_O)
rows = con.execute("SELECT instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open FROM positions_open").fetchall()
con.close()

if not rows:
    print("No open positions")
else:
    for r in rows:
        inst,side,e,sl,tp,qty,u,a,b,ts = r
        p = price(inst)
        pnl = (p-e)*qty if side=="buy" else (e-p)*qty
        print(f"{inst} | {side} | entry={e:.6f} | sl={sl:.6f} | tp={tp:.6f} | pnl={pnl:.4f} | {h(ts)}")
print("==========================\n")

# ===== LAST CLOSED =====
print("===== LAST CLOSED =====")
con = sqlite3.connect(DB_H)
hist = con.execute("""
SELECT instId,side,entry,exit,qty,pnl,ts_close,reason
FROM x_history ORDER BY ts_close DESC LIMIT 5
""").fetchall()
con.close()

if not hist:
    print("No closed positions")
else:
    for inst,side,e,x,qty,pnl,tsc,reason in hist:
        print(f"{inst} | {side} | {e:.4f}->{x:.4f} | pnl={pnl:.4f} | {h(tsc)} | {reason}")
print("==========================\n")

print("===== ACCOUNT =====")
BAL = 1000.0
total_pnl = sum([h[5] for h in hist]) if hist else 0
print(f"Balance paper  : {BAL:.2f} USDT")
print(f"Equity paper   : {BAL+total_pnl:.2f} USDT")
print(f"Closed PnL     : {total_pnl:.4f} USDT")
print("==========================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_config.py
Size: 862
MTime: 2025-10-27 10:58:46.599909791 +0100
----- CONTENT -----
#!/usr/bin/env python3

# ==========================
# CONFIG X (PAPER MODE)
# ==========================

# --- Risk Management ---
RISK_PER_TRADE = 0.01     # 1% du capital
MAX_LEVERAGE   = 5        # en PAPER uniquement
COOLDOWN_OPEN  = 60       # en secondes

# --- ATR / SL / TP / Trailing ---
ATR_SL_MULT     = 1.2     # SL = ATR * MULT
ATR_TP_MULT     = 2.0     # TP initial = 2R
ATR_TRAIL_MULT  = 1.0     # trailing = ATR * MULT
RR_BE_TRIGGER   = 1.0     # break-even à 1R

# --- Follow Loop ---
FOLLOW_INTERVAL = 4       # secondes entre 2 updates

# --- DB ---
DB_T       = "/opt/scalp/project/data/t.db"
DB_XOPEN   = "/opt/scalp/project/data/x_open.db"
DB_XFOLLOW = "/opt/scalp/project/data/x_follow.db"
DB_XHIST   = "/opt/scalp/project/data/x_history.db"
DB_SIG     = "/opt/scalp/project/data/signals.db"
DB_A       = "/opt/scalp/project/data/a.db"
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/U_universe.py
Size: 572
MTime: 2025-10-26 07:24:51.520542760 +0100
----- CONTENT -----
import ccxt, sqlite3

DBU = "/opt/scalp/project/data/u.db"
TOP = 20

exchange = ccxt.bitget()
markets = exchange.load_markets()

perps = []
for s,info in markets.items():
    if info.get('swap',False) and info['quote'] == 'USDT':
        inst = s.replace(":USDT","")  # -> BTC/USDT:USDT → BTC/USDT
        perps.append(inst)

perps = perps[:TOP]

con = sqlite3.connect(DBU, timeout=5)
con.execute("DELETE FROM universe;")
for inst in perps:
    con.execute("INSERT OR IGNORE INTO universe(instId) VALUES (?)", (inst,))
con.commit()
con.close()

print("[U] OK :", perps)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/init_db.py
Size: 1110
MTime: 2025-10-26 07:32:15.285178016 +0100
----- CONTENT -----
import sqlite3

DB_A = "/opt/scalp/project/data/a.db"

def init_db():
    con = sqlite3.connect(DB_A, timeout=5)
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_5m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_15m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_30m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ctx_a (
        instId TEXT,
        ts INTEGER,
        p_buy REAL,
        p_hold REAL,
        p_sell REAL,
        score REAL,
        ctx TEXT
    );
    """)

    con.commit()
    con.close()
    print("[INIT_DB] OK – A DB ready")

if __name__ == "__main__":
    init_db()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_ctx_dash.py
Size: 634
MTime: 2025-10-27 10:42:38.399008054 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3
from datetime import datetime

DB_A = "/opt/scalp/project/data/a.db"

def hms(ts):
    return datetime.fromtimestamp(ts/1000).strftime("%H:%M:%S")

con = sqlite3.connect(DB_A)
rows = con.execute("""
SELECT ctx, COUNT(*), GROUP_CONCAT(instId), MAX(ts)
FROM ctx_a_latest
GROUP BY ctx
ORDER BY ctx ASC
""").fetchall()
con.close()

print("===== CTX SUMMARY (A) =====")
if not rows:
    print("No ctx data")
else:
    for ctx, n, insts, ts in rows:
        insts_list = insts.split(",")[:3]
        print(f"{ctx:<7} | {n:<3} | {' '.join(insts_list)} | {hms(ts)}")
print("===========================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/config/scalp.conf
Size: 18
MTime: 2025-10-25 17:08:55.549075009 +0200
----- CONTENT -----
UNIVERSE_LIMIT=20
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xopen.sh
Size: 85
MTime: 2025-10-27 06:38:40.982605637 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_close.sh
Size: 102
MTime: 2025-10-27 13:32:48.246660187 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/a_analyse.sh
Size: 88
MTime: 2025-10-26 18:03:22.883271493 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/A_analyse.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/u_universe.sh
Size: 89
MTime: 2025-10-25 17:23:40.450204518 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/U_universe.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv_A.sh
Size: 89
MTime: 2025-10-25 17:23:57.298226222 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_dash.sh
Size: 2086
MTime: 2025-10-25 15:39:57.721793619 +0200
----- CONTENT -----
#!/bin/bash

DB_OPEN="/opt/scalp/project/data/x_open.db"
DB_FOLLOW="/opt/scalp/project/data/x_follow.db"
DB_ACCOUNT="/opt/scalp/project/data/x_account.db"
DB_HISTORY="/opt/scalp/project/data/x_history.db"
DB_SIGNALS="/opt/scalp/project/data/signals.db"

clear
echo "============= SCALP DASH =============  ($(date '+%Y-%m-%d %H:%M:%S'))"
echo

BAL=$(sqlite3 $DB_ACCOUNT "SELECT balance FROM account LIMIT 1;")
TOTAL_PNL=$(sqlite3 $DB_HISTORY "SELECT printf('%.4f', SUM(pnl)) FROM history;")
COUNT=$(sqlite3 $DB_HISTORY "SELECT COUNT(*) FROM history;")
WINS=$(sqlite3 $DB_HISTORY "SELECT COUNT(*) FROM history WHERE pnl > 0;")
WINRATE=$(sqlite3 $DB_HISTORY "SELECT ROUND(100.0 * (SELECT COUNT(*) FROM history WHERE pnl > 0) / CASE WHEN (SELECT COUNT(*) FROM history)=0 THEN 1 ELSE (SELECT COUNT(*) FROM history) END, 1);")

echo "[ACCOUNT]"
echo "Balance : $BAL USDT"
echo "PnL Total : $TOTAL_PNL USDT  | Trades : $COUNT  | Winrate : $WINRATE%"
echo

OPEN=$(sqlite3 $DB_OPEN "SELECT instId, side, qty, entry FROM positions_open LIMIT 1;")

echo "[OPEN POSITION]"
if [ -n "$OPEN" ]; then
    INST=$(echo $OPEN | cut -d'|' -f1)
    SIDE=$(echo $OPEN | cut -d'|' -f2)
    QTY=$(echo $OPEN | cut -d'|' -f3)
    ENTRY=$(echo $OPEN | cut -d'|' -f4)
    LAST=$(sqlite3 $DB_FOLLOW "SELECT last_price FROM follow WHERE instId='$INST' LIMIT 1;")
    echo "$INST | $SIDE | qty $QTY | entry $ENTRY | last $LAST"
else
    echo "No open position"
fi
echo

echo "[SIGNALS]"
echo "BUY  : $(sqlite3 $DB_SIGNALS "SELECT group_concat(instId) FROM signals WHERE side='buy';")"
echo "SELL : $(sqlite3 $DB_SIGNALS "SELECT group_concat(instId) FROM signals WHERE side='sell';")"
echo

echo "[SERVICES]"
for S in scalp-universe scalp-ohlcva.timer scalp-analysea.timer scalp-ohlcvb scalp-ticks scalp-signals scalp-xopen scalp-xfollow scalp-xclose
do
 if [[ "$S" == *".timer" ]]; then
   systemctl is-active --quiet $S && printf "%-20s ⏳ (timer)\n" "$S"
 else
   systemctl is-active --quiet $S && printf "%-20s ✅\n" "$S" || printf "%-20s ❌\n" "$S"
 fi
done

echo
echo "============= END DASH ============="
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_signals.sh
Size: 88
MTime: 2025-10-26 19:01:24.741873511 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/B_signals.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_follow.sh
Size: 103
MTime: 2025-10-27 13:32:41.118652027 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_follow.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv.sh
Size: 89
MTime: 2025-10-26 18:03:16.207265495 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_dash.sh
Size: 85
MTime: 2025-10-27 06:42:34.110928924 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/b_dash.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/ob_ohlcv_B.sh
Size: 89
MTime: 2025-10-25 13:12:44.107774002 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OB_ohlcv_B.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_open.sh
Size: 101
MTime: 2025-10-27 13:32:31.822641387 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xclose.sh
Size: 86
MTime: 2025-10-27 06:43:25.474998597 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/t_ticks.sh
Size: 86
MTime: 2025-10-25 17:24:36.322276510 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/T_ticks.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xfollow.sh
Size: 87
MTime: 2025-10-27 06:43:14.554983825 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_follow.py
----- FILE END -----
=== Export /opt/scalp/project/data/a.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/b.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/oa.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/ob.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/signals.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/t.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/ticks.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/u.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/x.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/x_account.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/x_follow.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/x_history.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
=== Export /opt/scalp/project/data/x_open.db → /opt/scalp/dump/scalp_db_20251027_140656.sql
Export DB global créé: /opt/scalp/dump/scalp_db_20251027_140656.sql
