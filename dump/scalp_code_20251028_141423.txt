# Scalp Project Code Dump
# Generated: 2025-10-28 13:14:23 UTC
# Root: /opt/scalp
# Caps: 512KB/file, max 4000 files

========== TREE (size, mtime) ==========
/opt/scalp/dp.sh                                                                          4650  2025-10-27 14:49:38.355844764 +0100
/opt/scalp/project/bin/a_analyse.sh                                                        110  2025-10-28 08:32:18.783561566 +0100
/opt/scalp/project/bin/b_dash.sh                                                            85  2025-10-27 06:42:34.110928924 +0100
/opt/scalp/project/bin/b_signals.sh                                                         88  2025-10-26 19:01:24.741873511 +0100
/opt/scalp/project/bin/oa_ohlcv.sh                                                          89  2025-10-26 18:03:16.207265495 +0100
/opt/scalp/project/bin/oa_ohlcv_A.sh                                                        89  2025-10-25 17:23:57.298226222 +0200
/opt/scalp/project/bin/ob_ohlcv_B.sh                                                        89  2025-10-25 13:12:44.107774002 +0200
/opt/scalp/project/bin/t_ticks.sh                                                           86  2025-10-25 17:24:36.322276510 +0200
/opt/scalp/project/bin/u_universe.sh                                                        89  2025-10-25 17:23:40.450204518 +0200
/opt/scalp/project/bin/x_close.sh                                                          102  2025-10-27 13:32:48.246660187 +0100
/opt/scalp/project/bin/x_dash.sh                                                          2858  2025-10-28 10:38:00.295906518 +0100
/opt/scalp/project/bin/x_follow.sh                                                         103  2025-10-27 13:32:41.118652027 +0100
/opt/scalp/project/bin/x_open.sh                                                           101  2025-10-27 13:32:31.822641387 +0100
/opt/scalp/project/bin/xclose.sh                                                            86  2025-10-27 06:43:25.474998597 +0100
/opt/scalp/project/bin/xfollow.sh                                                           87  2025-10-27 06:43:14.554983825 +0100
/opt/scalp/project/bin/xopen.sh                                                             85  2025-10-27 06:38:40.982605637 +0100
/opt/scalp/project/config/scalp.conf                                                        18  2025-10-25 17:08:55.549075009 +0200
/opt/scalp/project/scripts/A_analyse.py                                                   1601  2025-10-27 15:11:28.706394879 +0100
/opt/scalp/project/scripts/A_config.py                                                     336  2025-10-27 16:45:18.992784773 +0100
/opt/scalp/project/scripts/A_ctx.py                                                       3012  2025-10-28 08:04:00.885850656 +0100
/opt/scalp/project/scripts/A_ctx_dash.py                                                  1524  2025-10-27 19:45:33.204806371 +0100
/opt/scalp/project/scripts/B_dash.py                                                       472  2025-10-26 19:02:03.217938218 +0100
/opt/scalp/project/scripts/B_signals.py                                                   2693  2025-10-27 15:05:29.101656409 +0100
/opt/scalp/project/scripts/H_perf.py                                                      2240  2025-10-28 08:54:02.341534221 +0100
/opt/scalp/project/scripts/H_score.py                                                      368  2025-10-27 09:03:02.367929303 +0100
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482  2025-10-26 10:53:32.748328034 +0100
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1799  2025-10-28 08:32:48.743592782 +0100
/opt/scalp/project/scripts/S_cleanup_signals.sh                                            267  2025-10-28 09:52:03.409264353 +0100
/opt/scalp/project/scripts/S_cleanup_ticks.sh                                              147  2025-10-28 10:25:52.647287857 +0100
/opt/scalp/project/scripts/T_ticks.py                                                     1505  2025-10-28 10:25:28.927271695 +0100
/opt/scalp/project/scripts/U_universe.py                                                   572  2025-10-26 07:24:51.520542760 +0100
/opt/scalp/project/scripts/X_close.py                                                       94  2025-10-27 13:32:23.122631432 +0100
/opt/scalp/project/scripts/X_config.py                                                     417  2025-10-28 09:28:51.879734225 +0100
/opt/scalp/project/scripts/X_dash.py                                                      1761  2025-10-27 13:17:53.937659362 +0100
/opt/scalp/project/scripts/X_follow.py                                                    3353  2025-10-28 13:59:48.413499049 +0100
/opt/scalp/project/scripts/X_open.py                                                      4038  2025-10-28 09:25:35.451530788 +0100
/opt/scalp/project/scripts/b_dash.py                                                       543  2025-10-27 15:05:43.153688711 +0100
/opt/scalp/project/scripts/init_db.py                                                     1110  2025-10-26 07:32:15.285178016 +0100
/opt/scalp/project/scripts/x_dash.py                                                      1689  2025-10-27 09:06:10.048075732 +0100

========== TOP 10 BIGGEST FILES ==========
/opt/scalp/dp.sh                                                                          4650
/opt/scalp/project/scripts/X_open.py                                                      4038
/opt/scalp/project/scripts/X_follow.py                                                    3353
/opt/scalp/project/scripts/A_ctx.py                                                       3012
/opt/scalp/project/bin/x_dash.sh                                                          2858
/opt/scalp/project/scripts/B_signals.py                                                   2693
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482
/opt/scalp/project/scripts/H_perf.py                                                      2240
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1799
/opt/scalp/project/scripts/X_dash.py                                                      1761

========== CONCAT CONTENT ==========

----- FILE BEGIN -----
Path: /opt/scalp/dp.sh
Size: 4650
MTime: 2025-10-27 14:49:38.355844764 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail

# --------- Réglages ---------
ROOT="/opt/scalp"
DUMP_DIR="${ROOT}/dump"
TS="$(date +'%Y%m%d_%H%M%S')"
OUT="${DUMP_DIR}/scalp_code_${TS}.txt"
SQL_OUT="${DUMP_DIR}/scalp_db_${TS}.sql"
TMP_LIST="$(mktemp)"
MAX_FILE_SIZE_KB="${MAX_FILE_SIZE_KB:-512}"
MAX_FILES="${MAX_FILES:-4000}"
DRY_RUN="${DRY_RUN:-0}"

mkdir -p "$DUMP_DIR"
trap 'rm -f "$TMP_LIST"' EXIT

# --------- Git depuis /etc/scalp.env ---------
[ -f /etc/scalp.env ] && . /etc/scalp.env

: "${GIT_USERNAME:?manquant}"
: "${GIT_TOKEN:?manquant}"

GIT_BRANCH="${GIT_BRANCH:-main}"
GIT_EMAIL_USE="${GIT_EMAIL:-${GIT_USERNAME}@users.noreply.github.com}"
GIT_HOST="${GIT_HOST:-github.com}"
GIT_OWNER="${GIT_OWNER:-$GIT_USERNAME}"
GIT_REPO="${GIT_REPO:-Scalp}"
GIT_REMOTE="${GIT_REMOTE:-}"

if [ -n "$GIT_REMOTE" ]; then
  REMOTE_URL="$GIT_REMOTE"
else
  REMOTE_URL="https://${GIT_HOST}/${GIT_OWNER}/${GIT_REPO}.git"
fi

echo "[dump_and_push] branch=${GIT_BRANCH} dry_run=${DRY_RUN} remote=${REMOTE_URL}"

# --------- Collecte fichiers ---------
find "$ROOT" -type f \
  -not -path '*/.*' \
  -not -path '*/.git/*' \
  -not -path '*/__pycache__/*' \
  -not -path '*/venv/*' -not -path '*/.venv/*' \
  -not -path '*/var/*' \
  -not -path '*/logs/*' \
  -not -path '*/data/*' \
  -not -path '*/reports/*' \
  -not -path '*/dump/*' \
  -size -"${MAX_FILE_SIZE_KB}"k \
  \( -name '*.py' -o -name '*.pyi' -o -name '*.sh' -o -name '*.bash' \
     -name '*.ini' -o -name '*.cfg' -o -name '*.conf' -o -name '*.toml' \
     -name '*.yaml' -o -name '*.yml' -o -name '*.md' -o -name '*.txt' \
     -name '*.sql' -o -name '*.json' -o -name '*.csv' \) \
  -print0 > "$TMP_LIST"

# Limite MAX_FILES
TMP2="$(mktemp)"; trap 'rm -f "$TMP2"' EXIT
awk -v max="$MAX_FILES" -v RS='\0' -v ORS='\0' 'NR<=max{print}' "$TMP_LIST" > "$TMP2"
mv "$TMP2" "$TMP_LIST"

# En-tête dump TXT
{
  echo "# Scalp Project Code Dump"
  echo "# Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
  echo "# Root: ${ROOT}"
  echo "# Caps: ${MAX_FILE_SIZE_KB}KB/file, max ${MAX_FILES} files"
  echo
  echo "========== TREE (size, mtime) =========="
} > "$OUT"

# TREE
tr '\0' '\n' < "$TMP_LIST" | sort | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  mt="$(stat -c %y "$f" 2>/dev/null || echo unknown)"
  printf "%-80s  %12s  %s\n" "$f" "$sz" "$mt" >> "$OUT"
done

# TOP 10
{
  echo
  echo "========== TOP 10 BIGGEST FILES =========="
} >> "$OUT"

tr '\0' '\n' < "$TMP_LIST" | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  printf "%012d\t%s\n" "$sz" "$f"
done | sort -r | head -n 10 | awk -F'\t' '{printf "%-80s  %12d\n", $2, $1+0}' >> "$OUT"

# Contenu concaténé
{
  echo
  echo "========== CONCAT CONTENT =========="
} >> "$OUT"

tr '\0' '\n' < "$TMP_LIST" | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  mt="$(stat -c %y "$f" 2>/dev/null || echo unknown)"
  {
    echo
    echo "----- FILE BEGIN -----"
    echo "Path: $f"
    echo "Size: $sz"
    echo "MTime: $mt"
    echo "----- CONTENT -----"
  } >> "$OUT"

  if [ "$sz" -gt $((MAX_FILE_SIZE_KB*1024)) ]; then
    head -c $((MAX_FILE_SIZE_KB*1024)) "$f" 2>/dev/null >> "$OUT" || true
    echo -e "\n[TRUNCATED]" >> "$OUT"
  else
    cat "$f" 2>/dev/null >> "$OUT" || true
  fi
  echo "----- FILE END -----" >> "$OUT"
done

echo "Dump TXT prêt: $OUT"

# --------- Export DB (SCHÉMA UNIQUEMENT) ---------
SQL_OUT="${DUMP_DIR}/scalp_db_${TS}.sql"
: > "$SQL_OUT"

if command -v sqlite3 >/dev/null 2>&1; then
  for DB_PATH in /opt/scalp/project/data/*.db; do
    [ -s "$DB_PATH" ] || continue
    echo "=== Export ${DB_PATH}" | tee -a "$OUT"
    {
      echo ""
      echo "/* DB: ${DB_PATH} */"
      echo "-- SCHEMA ONLY --"
      sqlite3 "$DB_PATH" ".schema"
      echo ""
    } >> "$SQL_OUT"
  done
else
  echo "sqlite3 introuvable, export DB ignoré" | tee -a "$OUT"
fi

# --------- Git: commit + push ---------
cd "$ROOT"
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || git init -q .

git config user.name "${GIT_USERNAME}"
git config user.email "${GIT_EMAIL_USE}"
git remote get-url origin >/dev/null 2>&1 || git remote add origin "${REMOTE_URL}"

touch .gitignore
for p in var/ logs/ data/ dump/; do grep -qxF "$p" .gitignore || echo "$p" >> .gitignore; done

git add -f "$OUT"
[ -s "$SQL_OUT" ] && git add -f "$SQL_OUT"
git commit -m "dump: ${OUT##*/} (schema only)" || true

if [ "$DRY_RUN" = "1" ]; then
  echo "DRY_RUN=1 -> push désactivé"
else
  AUTH_URL="https://${GIT_USERNAME}:${GIT_TOKEN}@${GIT_HOST}/${GIT_OWNER}/${GIT_REPO}.git"
  git push -f "$AUTH_URL" HEAD:${GIT_BRANCH}
  echo "OK: push vers ${REMOTE_URL} sur ${GIT_BRANCH}"
fi
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_dash.py
Size: 472
MTime: 2025-10-26 19:02:03.217938218 +0100
----- CONTENT -----
import sqlite3
DB="/opt/scalp/project/data/signals.db"

con=sqlite3.connect(DB)
rows=con.execute("""
SELECT ts_signal,instId,side,reason,ctx,score_A,score_B,price
FROM signals
ORDER BY ts_signal DESC LIMIT 12
""").fetchall()
con.close()

print("\n===== LAST SIGNALS (B) =====")
for r in rows:
    ts,inst,side,reason,ctx,sA,sB,price = r
    print(f"{inst:10} | {side:4} | {reason:12} | {ctx:7} | A={sA:.3f} | B={sB:.3f} | {price}")
print("============================\n")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/H_score.py
Size: 368
MTime: 2025-10-27 09:03:02.367929303 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_H="/opt/scalp/project/data/x_history.db"

def latest_H():
    con=sqlite3.connect(DB_H)
    row=con.execute("SELECT score_H FROM v_H_latest").fetchone()
    con.close()
    return float(row[0]) if row and row[0] else 0.0

def run():
    h=latest_H()
    print(f"[H] score_H={h:.3f}")

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_close.py
Size: 94
MTime: 2025-10-27 13:32:23.122631432 +0100
----- CONTENT -----
#!/usr/bin/env python3
# CLOSE handled by X_follow
import time
while True:
    time.sleep(60)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/b_dash.py
Size: 543
MTime: 2025-10-27 15:05:43.153688711 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3
from datetime import datetime

DB = "/opt/scalp/project/data/signals.db"

con = sqlite3.connect(DB)
rows = con.execute("""
SELECT instId,side,ctx,score_U,score_A,score_B,ts_signal
FROM signals
ORDER BY ts_signal DESC
LIMIT 15
""").fetchall()
con.close()

print("===== LAST SIGNALS (B) =====")
for r in rows:
    ts=datetime.fromtimestamp(r[6]/1000).strftime("%H:%M:%S")
    print(f"{r[0]:8} | {r[1]:4} | ctx={r[2]:7} | U={r[3]:.2f} A={r[4]:.2f} B={r[5]:.2f} | {ts}")
print("============================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OB_ohlcv_B.py
Size: 1799
MTime: 2025-10-28 08:32:48.743592782 +0100
----- CONTENT -----
#!/usr/bin/env python3
import ccxt, sqlite3, time

DBu = "/opt/scalp/project/data/u.db"
DBo = "/opt/scalp/project/data/ob.db"
ex = ccxt.bitget()

def to_bitget_symbol(inst: str) -> str:
    return inst if ":USDT" in inst else f"{inst}:USDT"

def init_db():
    con = sqlite3.connect(DBo, timeout=30, isolation_level=None)
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_1m(
        instId TEXT, ts INTEGER, o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_3m(
        instId TEXT, ts INTEGER, o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.close()

def get_universe():
    con = sqlite3.connect(DBu, timeout=30, isolation_level=None)
    rows = con.execute("SELECT instId FROM universe").fetchall()
    con.close()
    return [r[0] for r in rows]

def upsert(tf, inst, ohlcv):
    tbl = "kline_1m" if tf == "1m" else "kline_3m"
    con = sqlite3.connect(DBo, timeout=30, isolation_level=None)
    con.execute(f"INSERT OR REPLACE INTO {tbl}(instId,ts,o,h,l,c,v) VALUES(?,?,?,?,?,?,?)",
                (inst, ohlcv[0], ohlcv[1], ohlcv[2], ohlcv[3], ohlcv[4], ohlcv[5]))
    con.close()

def fetch_tf(inst, tf):
    sym = to_bitget_symbol(inst)
    ohlc = ex.fetch_ohlcv(sym, tf, limit=150)
    for o in ohlc:
        upsert(tf, inst, o)
    print(f"[OB] {inst} {tf} stored ({len(ohlc)} candles)")

def main():
    init_db()
    while True:
        try:
            for inst in get_universe():
                fetch_tf(inst, "1m")
                fetch_tf(inst, "3m")
            time.sleep(5)
        except Exception as e:
            print("[OB ERROR]", e)
            time.sleep(2)

if __name__ == "__main__":
    main()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_signals.py
Size: 2693
MTime: 2025-10-27 15:05:29.101656409 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DB_A     = "/opt/scalp/project/data/a.db"
DB_SIG   = "/opt/scalp/project/data/signals.db"
DB_T     = "/opt/scalp/project/data/t.db"

# --- 6 SETUPS ---
def sig_trend(pb, ps):
    return (pb - ps)

def sig_breakout(price, hh, ll):
    if price > hh: return 1
    if price < ll: return -1
    return 0

def sig_pullback(price, ma):
    return 1 if price > ma else -1

def sig_meanrev(price, ma):
    dist = (price-ma)/ma
    if dist > 0.01: return -1
    if dist < -0.01: return 1
    return 0

def sig_range(ctx):
    return 0.3 if ctx=="range" else 0

def sig_volpush(vol, avg):
    return 1 if vol > 1.5*avg else 0

# -----------------------------------------
def compute(inst):

    # 1) get context A
    conA = sqlite3.connect(DB_A)
    row = conA.execute("SELECT ctx,score_U,score_A,p_buy,p_sell FROM ctx_a_latest WHERE instId=?",(inst,)).fetchone()
    conA.close()
    if not row: return None
    ctx,scoreU,scoreA,pb,ps = row

    # 2) get last tick (price)
    conT = sqlite3.connect(DB_T)
    t = conT.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    conT.close()
    if not t: return None
    price=float(t[0])

    # --- fake values / placeholders for BO/PB/MR/VOL (OK for now) ---
    hh, ll, ma, vol, avg = price*1.01, price*0.99, price, 1, 1

    # 3) compute 6 signals
    sTR = sig_trend(pb,ps)
    sBO = sig_breakout(price,hh,ll)
    sPB = sig_pullback(price,ma)
    sMR = sig_meanrev(price,ma)
    sRG = sig_range(ctx)
    sVP = sig_volpush(vol,avg)

    # 4) weighted score_B
    scoreB = 0.40*sTR + 0.25*sBO + 0.15*sPB + 0.10*sMR + 0.10*(sRG+sVP)

    # 5) decide side
    side="none"
    if scoreB>0.20: side="buy"
    elif scoreB<-0.20: side="sell"

    return side, ctx, scoreU, scoreA, scoreB

# -----------------------------------------
def save_signal(inst,side,ctx,u,a,b):
    con = sqlite3.connect(DB_SIG)
    con.execute("""
        INSERT INTO signals(instId,side,ctx,score_U,score_A,score_B,reason,ts_signal)
        VALUES(?,?,?,?,?,?,?,?)
    """,(inst,side,ctx,u,a,b,"auto",int(time.time()*1000)))
    con.commit()
    con.close()

# -----------------------------------------
def run():
    # get list of inst
    conA = sqlite3.connect(DB_A)
    insts=[r[0] for r in conA.execute("SELECT instId FROM ctx_a_latest")]
    conA.close()

    for inst in insts:
        sig=compute(inst)
        if not sig: continue
        side,ctx,u,a,b = sig
        if side!="none":
            save_signal(inst,side,ctx,u,a,b)

# -----------------------------------------
if __name__=="__main__":
    while True:
        run()
        time.sleep(4)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_open.py
Size: 4038
MTime: 2025-10-28 09:25:35.451530788 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from X_config import *
from datetime import datetime
from math import fabs

def log(msg): 
    print(f"[X_OPEN] {datetime.utcnow()} | {msg}")

def get_last_signal():
    con = sqlite3.connect(DB_SIG, timeout=30, isolation_level=None)
    row = con.execute("""
        SELECT instId, side, score_U, score_A, score_B, ts_signal
        FROM signals_for_open
        ORDER BY ts_signal DESC LIMIT 1
    """).fetchone()
    con.close()
    return row

def is_in_cooldown(ts_signal_ms): 
    return (time.time() - ts_signal_ms/1000.0) < COOLDOWN_OPEN

def last_price(inst):
    con = sqlite3.connect(DB_T, timeout=30, isolation_level=None)
    r = con.execute(
        "SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",
        (inst,)
    ).fetchone()
    con.close()
    return float(r[0]) if r else None

def atr14_from_oa_5m(inst):
    con = sqlite3.connect(DB_A, timeout=30, isolation_level=None)
    con.execute("ATTACH DATABASE ? AS oa", ("/opt/scalp/project/data/oa.db",))
    rows = con.execute("""
        SELECT open,high,low,close 
        FROM oa.ohlcv_5m
        WHERE instId=? ORDER BY ts DESC LIMIT 20
    """,(inst,)).fetchall()
    con.close()
    if len(rows)<15:
        return None
    rows = rows[::-1]
    trs=[]; pc = rows[0][3]
    for (o,h,l,c) in rows[1:]:
        tr = max(h-l, abs(h-pc), abs(l-pc))
        trs.append(tr)
        pc=c
    return sum(trs[-14:])/14.0

def already_open(inst):
    con = sqlite3.connect(DB_XOPEN, timeout=30, isolation_level=None)
    r = con.execute(
        "SELECT 1 FROM positions_open WHERE instId=?",
        (inst,)
    ).fetchone()
    con.close()
    return r is not None

# --- Récup score_H (pour sizing dynamique) ---
def get_score_H(inst):
    con = sqlite3.connect(DB_H, timeout=30, isolation_level=None)
    con.execute("""
        CREATE TABLE IF NOT EXISTS score_H(
            instId TEXT PRIMARY KEY,
            avg_pnl REAL,
            winrate REAL,
            trades INTEGER,
            last_update INTEGER
        )
    """)
    row = con.execute(
        "SELECT avg_pnl FROM score_H WHERE instId=?",
        (inst,)
    ).fetchone()
    con.close()
    return row[0] if row else None

# --- Fonction facteur H ---
def factor_from_H(avg_pnl):
    if avg_pnl is None:
        return 1.0
    if avg_pnl > 0:
        return 1.3
    if avg_pnl < 0:
        return 0.7
    return 1.0

def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def open_trade(inst, side, entry, u, a, b, atr):
    # base nominale
    taille_nominale_usdt = 10.0  # 1% du capital 1000 USDT
    avg_pnl = get_score_H(inst)
    fH = factor_from_H(avg_pnl)
    fH = clamp(fH, 0.5, 2.0)

    taille_usdt = taille_nominale_usdt * fH     # adaptation par historique
    qty = taille_usdt / entry                   # conversion USDT -> taille crypto

    sl = entry - ATR_SL_MULT*atr if side=="buy" else entry + ATR_SL_MULT*atr
    tp = entry + ATR_TP_MULT*atr if side=="buy" else entry - ATR_TP_MULT*atr
    ts = int(time.time()*1000)

    con = sqlite3.connect(DB_XOPEN, timeout=30, isolation_level=None)
    con.execute("""
        INSERT OR REPLACE INTO positions_open(instId,side,entry,sl,tp,qty,
        score_U,score_A,score_B,ts_open,usd_size)
        VALUES(?,?,?,?,?,?,?,?,?,?,?)
    """,(inst,side,entry,sl,tp,qty,u,a,b,ts,taille_usdt))
    con.close()

    log(f"OPEN {inst} {side} | entry={entry:.6f} qty={qty:.6f} usd={taille_usdt:.2f} SL={sl:.6f} TP={tp:.6f}")

def run():
    log("READY")
    while True:
        sig = get_last_signal()
        if not sig:
            time.sleep(1); continue
        inst,side,u,a,b,ts_sig = sig
        if already_open(inst):
            time.sleep(1); continue
        if is_in_cooldown(ts_sig):
            time.sleep(1); continue

        price = last_price(inst)
        atr = atr14_from_oa_5m(inst)
        if not price or not atr:
            time.sleep(1); continue

        open_trade(inst,side,price,u,a,b,atr)
        time.sleep(1)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_follow.py
Size: 3353
MTime: 2025-10-28 13:59:48.413499049 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DB_XOPEN = "/opt/scalp/project/data/x_open.db"
DB_XCLOSED = "/opt/scalp/project/data/x_closed.db"
DB_TICKS = "/opt/scalp/project/data/t.db"
DB_FEAT = "/opt/scalp/project/data/b.db"

STOP_TIME = 1800
BE_TRIGGER = 0.6

def now():
    return int(time.time())

def get_price(inst):
    con = sqlite3.connect(DB_TICKS, timeout=10, isolation_level=None)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return r[0] if r else None

def get_atr(inst):
    con = sqlite3.connect(DB_FEAT, timeout=10, isolation_level=None)
    r = con.execute("SELECT atr FROM feat_1m WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return r[0] if r and r[0] else None

def close_trade(inst,side,entry,sl,tp,ts_open,reason,exit_price):
    pnl = (entry - exit_price) if side=="sell" else (exit_price - entry)

    con = sqlite3.connect(DB_XCLOSED, timeout=10, isolation_level=None)
    con.execute("""INSERT INTO positions_closed(instId,side,entry,exit,pnl,reason,ts_close)
                   VALUES(?,?,?,?,?,?,?)""",
                (inst,side,entry,exit_price,pnl,reason,now()))
    con.close()

    con = sqlite3.connect(DB_XOPEN, timeout=10, isolation_level=None)
    con.execute("DELETE FROM positions_open WHERE instId=?", (inst,))
    con.close()

    print(f"[X_FOLLOW] {datetime.utcnow()} | CLOSE {inst} {side} @ {exit_price} ({reason}) PnL={pnl:.4f}")

def run():
    while True:
        con = sqlite3.connect(DB_XOPEN, timeout=10, isolation_level=None)
        rows = con.execute("""SELECT instId, side, entry, sl, tp, qty, score_U, score_A, score_B, ctx, reason, ts_open, usd_size
                              FROM positions_open""").fetchall()
        con.close()

        for inst, side, entry, sl, tp, qty, u, a, b, ctx, reason, ts_open, usd in rows:
            price = get_price(inst)
            if price is None:
                continue

            age = now() - ts_open
            if age > STOP_TIME:
                close_trade(inst,side,entry,sl,tp,ts_open,"TIME",price)
                continue

            atr = get_atr(inst)
            if atr:
                if side == "sell" and (entry - price) > (BE_TRIGGER * atr) and sl < entry:
                    con = sqlite3.connect(DB_XOPEN, timeout=10, isolation_level=None)
                    con.execute("UPDATE positions_open SET sl=? WHERE instId=?", (entry,inst))
                    con.close()
                elif side == "buy" and (price - entry) > (BE_TRIGGER * atr) and sl > entry:
                    con = sqlite3.connect(DB_XOPEN, timeout=10, isolation_level=None)
                    con.execute("UPDATE positions_open SET sl=? WHERE instId=?", (entry,inst))
                    con.close()

            if side=="sell":
                if price >= sl: close_trade(inst,side,entry,sl,tp,ts_open,"SL",price)
                elif price <= tp: close_trade(inst,side,entry,sl,tp,ts_open,"TP",price)
            else:
                if price <= sl: close_trade(inst,side,entry,sl,tp,ts_open,"SL",price)
                elif price >= tp: close_trade(inst,side,entry,sl,tp,ts_open,"TP",price)

        time.sleep(2)

if __name__ == "__main__":
    print(f"[X_FOLLOW] {datetime.utcnow()} | READY")
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/S_cleanup_signals.sh
Size: 267
MTime: 2025-10-28 09:52:03.409264353 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail
sqlite3 /opt/scalp/project/data/signals.db "
WITH ranked AS (
  SELECT rowid,
         ROW_NUMBER() OVER (PARTITION BY instId ORDER BY ts_signal DESC) AS rn
  FROM signals_for_open
)
DELETE FROM signals_for_open WHERE rn > 10;
"
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OA_ohlcv_A.py
Size: 2482
MTime: 2025-10-26 10:53:32.748328034 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time, ccxt

DBU = "/opt/scalp/project/data/u.db"
DBO = "/opt/scalp/project/data/oa.db"
TF_LIST = ["5m","15m","30m"]
INIT = 150
MAX_ROWS = 300

ex = ccxt.bitget()

def to_bitget_symbol(inst: str) -> str:
    return inst if ":" in inst else f"{inst}:USDT"

def ensure_schema():
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    for tf in TF_LIST:
        cur.execute(f"DROP TABLE IF EXISTS ohlcv_{tf}")
        cur.execute(f"""
        CREATE TABLE IF NOT EXISTS ohlcv_{tf}(
          instId TEXT,
          ts INTEGER,
          open REAL, high REAL, low REAL, close REAL, volume REAL,
          PRIMARY KEY(instId, ts)
        )
        """)
    con.commit()
    con.close()

def load_universe():
    con = sqlite3.connect(DBU, timeout=5)
    rows = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()
    return rows

def last_ts(con, tf, inst):
    row = con.execute(f"SELECT MAX(ts) FROM ohlcv_{tf} WHERE instId=?", (inst,)).fetchone()
    return row[0] if row and row[0] is not None else None

def upsert_batch(tf, inst, batch):
    if not batch:
        return
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    cur.executemany(
        f"INSERT OR REPLACE INTO ohlcv_{tf}(instId,ts,open,high,low,close,volume) VALUES (?,?,?,?,?,?,?)",
        [(inst, o[0], o[1], o[2], o[3], o[4], o[5]) for o in batch]
    )
    cur.execute(f"""
        DELETE FROM ohlcv_{tf}
        WHERE instId=?
          AND ts NOT IN (
            SELECT ts FROM ohlcv_{tf}
            WHERE instId=?
            ORDER BY ts DESC
            LIMIT {MAX_ROWS}
          )
    """, (inst, inst))
    con.commit()
    con.close()

def sync_inst_tf(inst, tf):
    inst_ccxt = to_bitget_symbol(inst)
    con = sqlite3.connect(DBO, timeout=5)
    ts_last = last_ts(con, tf, inst)
    con.close()

    if ts_last is None:
        data = ex.fetch_ohlcv(inst_ccxt, tf, limit=INIT)
        upsert_batch(tf, inst, data)
        return

    data = ex.fetch_ohlcv(inst_ccxt, tf, since=ts_last + 1, limit=150)
    upsert_batch(tf, inst, data)

def main():
    ensure_schema()
    insts = load_universe()
    for inst in insts:
        for tf in TF_LIST:
            try:
                sync_inst_tf(inst, tf)
                time.sleep(0.25)
            except Exception as e:
                print(f"[OA][{inst}][{tf}] WARN: {e}")
    print("[OA] ✅ Multi-TF sync to oa.db")

if __name__ == "__main__":
    main()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_config.py
Size: 336
MTime: 2025-10-27 16:45:18.992784773 +0100
----- CONTENT -----
#!/usr/bin/env python3

# DB paths
DB_A  = "/opt/scalp/project/data/a.db"
DB_OB = "/opt/scalp/project/data/ob.db"
DB_OA = "/opt/scalp/project/data/oa.db"
DB_U  = "/opt/scalp/project/data/u.db"

# TF used
TF_SHORT = "5m"
TF_MED   = "15m"
TF_LONG  = "30m"

# Weights for score (softmax later)
W_SHORT = 0.50
W_MED   = 0.30
W_LONG  = 0.20
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/T_ticks.py
Size: 1505
MTime: 2025-10-28 10:25:28.927271695 +0100
----- CONTENT -----
#!/usr/bin/env python3
import asyncio, time, sqlite3
import ccxt.pro as ccxtpro

UDB = "/opt/scalp/project/data/u.db"
TDB = "/opt/scalp/project/data/t.db"

def to_bitget_symbol(inst: str) -> str:
    return inst if ":USDT" in inst else f"{inst}:USDT"

def ensure_schema():
    con = sqlite3.connect(TDB, timeout=30, isolation_level=None)
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("CREATE TABLE IF NOT EXISTS ticks(instId TEXT, ts INTEGER, price REAL)")
    con.close()

async def run():
    ensure_schema()
    con = sqlite3.connect(UDB, timeout=30, isolation_level=None)
    insts = [r[0] for r in con.execute("SELECT instId FROM universe").fetchall()]
    con.close()
    sym_map = {inst: to_bitget_symbol(inst) for inst in insts}

    ex = ccxtpro.bitget()
    try:
        while True:
            for inst, sym in sym_map.items():
                try:
                    t = await ex.watch_ticker(sym)
                    ts = int(time.time()*1000)
                    price = float(t.get("last") or t.get("close"))
                    if price:
                        conT = sqlite3.connect(TDB, timeout=30, isolation_level=None)
                        conT.execute("INSERT INTO ticks(instId,ts,price) VALUES(?,?,?)", (inst, ts, price))
                        conT.close()
                except Exception:
                    await asyncio.sleep(0.5)
            await asyncio.sleep(0.1)
    finally:
        await ex.close()

if __name__ == "__main__":
    asyncio.run(run())
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/S_cleanup_ticks.sh
Size: 147
MTime: 2025-10-28 10:25:52.647287857 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail
sqlite3 /opt/scalp/project/data/t.db "
DELETE FROM ticks
WHERE ts < strftime('%s','now','-1 hour') * 1000;
"
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_analyse.py
Size: 1601
MTime: 2025-10-27 15:11:28.706394879 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, math, time

DB_A = "/opt/scalp/project/data/a.db"
DB_U = "/opt/scalp/project/data/u.db"
DB_OB = "/opt/scalp/project/data/ob.db"
TF = "5m"

def softmax(x):
    e = [math.exp(i) for i in x]
    s = sum(e)
    return [v/s for v in e]

def get_universe():
    con = sqlite3.connect(DB_U)
    rows = con.execute("SELECT instId FROM universe ORDER BY instId").fetchall()
    con.close()
    return [r[0] for r in rows]

def load_ob(inst):
    con = sqlite3.connect(DB_OB)
    row = con.execute(f"SELECT rsi FROM ob_{TF} WHERE instId=? ORDER BY ts DESC LIMIT 1", (inst,)).fetchone()
    con.close()
    return row[0] if row else None

def compute_ctx(rsi):
    if rsi < 30: return "bullish"
    if rsi > 70: return "bearish"
    if 45 <= rsi <= 55: return "range"
    return "none"

def compute_score_A(ctx):
    if ctx == "bullish": return 0.8
    if ctx == "bearish": return -0.8
    if ctx == "range": return 0.0
    return 0.0

def run():
    insts = get_universe()
    now = int(time.time()*1000)
    out = []

    for inst in insts:
        rsi = load_ob(inst)
        if rsi is None:
            continue
        ctx = compute_ctx(rsi)
        score_A = compute_score_A(ctx)
        p_buy, p_sell = softmax([score_A, -score_A])
        out.append((inst, now, 0.0, score_A, p_buy, p_sell, ctx))

    con = sqlite3.connect(DB_A)
    con.execute("DELETE FROM ctx_a_latest")
    con.executemany("INSERT INTO ctx_a_latest(instId,ts,score_U,score_A,p_buy,p_sell,ctx) VALUES (?,?,?,?,?,?,?)", out)
    con.commit()
    con.close()

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/H_perf.py
Size: 2240
MTime: 2025-10-28 08:54:02.341534221 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time, statistics, logging, sys
from pathlib import Path

LOG = "/opt/scalp/project/logs/H_perf.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    handlers=[logging.FileHandler(LOG), logging.StreamHandler(sys.stdout)]
)

DB_CLOSED = "/opt/scalp/project/data/x_closed.db"
DB_H = "/opt/scalp/project/data/h.db"

def connect_db(path):
    con = sqlite3.connect(path, timeout=30, isolation_level=None)
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("PRAGMA synchronous=NORMAL;")
    con.execute("PRAGMA busy_timeout=5000;")
    return con

def ensure_closed_schema():
    con = connect_db(DB_CLOSED)
    con.execute("""
        CREATE TABLE IF NOT EXISTS positions_closed(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            instId TEXT, side TEXT, entry REAL, exit REAL,
            sl REAL, tp REAL, pnl REAL, reason TEXT,
            ts_open INTEGER, ts_close INTEGER
        )
    """)
    con.close()

def migrate_h():
    con = connect_db(DB_H)
    con.execute("""
        CREATE TABLE IF NOT EXISTS score_H(
            instId TEXT PRIMARY KEY,
            avg_pnl REAL,
            winrate REAL,
            trades INTEGER,
            last_update INTEGER
        )
    """)
    con.close()

def compute_score():
    ensure_closed_schema()
    con_c = connect_db(DB_CLOSED)
    rows = con_c.execute("SELECT instId, pnl FROM positions_closed").fetchall()
    con_c.close()
    if not rows:
        logging.info("Aucun trade clos, pas de calcul.")
        return
    data = {}
    for inst,pnl in rows:
        data.setdefault(inst,[]).append(pnl)
    con_h = connect_db(DB_H)
    for inst,vals in data.items():
        avg = statistics.mean(vals)
        winrate = sum(1 for v in vals if v>0)/len(vals)
        con_h.execute("""
            INSERT OR REPLACE INTO score_H(instId,avg_pnl,winrate,trades,last_update)
            VALUES(?,?,?,?,?)
        """,(inst,avg,winrate,len(vals),int(time.time()*1000)))
    con_h.close()
    logging.info(f"Scores H mis à jour pour {len(data)} instruments.")

def main(argv):
    migrate_h()
    compute_score()

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/x_dash.py
Size: 1689
MTime: 2025-10-27 09:06:10.048075732 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DBP="/opt/scalp/project/data/x_open.db"
DBF="/opt/scalp/project/data/x_follow.db"
DBH="/opt/scalp/project/data/x_history.db"

def h(ts):return datetime.fromtimestamp(ts/1000).strftime("%H:%M:%S")

def get_H(inst):
    con=sqlite3.connect(DBH)
    r=con.execute("""
    WITH last20 AS (
        SELECT pnl FROM history WHERE instId=?
        ORDER BY ts_close DESC LIMIT 20
    ),
    stats AS (
        SELECT 
            (SELECT COUNT(*) FROM last20 WHERE pnl>0)*1.0/(SELECT COUNT(*) FROM last20) AS winrate,
            (SELECT SUM(pnl) FROM last20 WHERE pnl>0) AS sum_win,
            (SELECT SUM(ABS(pnl)) FROM last20 WHERE pnl<0) AS sum_loss
    )
    SELECT 
        CASE WHEN sum_loss IS NULL OR sum_loss=0 THEN 1.0 
        ELSE (0.50*winrate + 0.50*MIN(1.0, (sum_win/sum_loss)/2.0))
        END AS H
    FROM stats
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r and r[0] else 0.0

print("===== X DASH =====")

# OPEN
con=sqlite3.connect(DBP)
rows=con.execute("SELECT instId,side,entry,qty,lev,risk,score_G,ts_open FROM positions_open").fetchall()
con.close()
if not rows:
    print("No open position")
else:
    for r in rows:
        inst,side,e,qty,lev,risk,sg,ts=r
        Hs=get_H(inst)
        print(f"{inst} | {side} | entry={e} | lev={lev:.2f} | risk={risk:.3f} | G={sg:.3f} | H={Hs:.3f} | {h(ts)}")

# FOLLOW
con=sqlite3.connect(DBF)
rows=con.execute("SELECT instId,current,upnl,stage,ts_update FROM follow").fetchall()
con.close()
for r in rows:
    inst,cur,u,st,ts=r
    print(f"FOLLOW -> {inst} | {cur} | upnl={u:.4f} | {st} | {h(ts)}")

print("===================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_dash.py
Size: 1761
MTime: 2025-10-27 13:17:53.937659362 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_O = "/opt/scalp/project/data/x_open.db"
DB_H = "/opt/scalp/project/data/x_history.db"
DB_T = "/opt/scalp/project/data/t.db"

def h(ts): 
    return time.strftime("%H:%M:%S", time.localtime(ts/1000))

def price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

# ===== OPEN POSITIONS =====
print("===== OPEN POSITIONS =====")
con = sqlite3.connect(DB_O)
rows = con.execute("SELECT instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open FROM positions_open").fetchall()
con.close()

if not rows:
    print("No open positions")
else:
    for r in rows:
        inst,side,e,sl,tp,qty,u,a,b,ts = r
        p = price(inst)
        pnl = (p-e)*qty if side=="buy" else (e-p)*qty
        print(f"{inst} | {side} | entry={e:.6f} | sl={sl:.6f} | tp={tp:.6f} | pnl={pnl:.4f} | {h(ts)}")
print("==========================\n")

# ===== LAST CLOSED =====
print("===== LAST CLOSED =====")
con = sqlite3.connect(DB_H)
hist = con.execute("""
SELECT instId,side,entry,exit,qty,pnl,ts_close,reason
FROM x_history ORDER BY ts_close DESC LIMIT 5
""").fetchall()
con.close()

if not hist:
    print("No closed positions")
else:
    for inst,side,e,x,qty,pnl,tsc,reason in hist:
        print(f"{inst} | {side} | {e:.4f}->{x:.4f} | pnl={pnl:.4f} | {h(tsc)} | {reason}")
print("==========================\n")

print("===== ACCOUNT =====")
BAL = 1000.0
total_pnl = sum([h[5] for h in hist]) if hist else 0
print(f"Balance paper  : {BAL:.2f} USDT")
print(f"Equity paper   : {BAL+total_pnl:.2f} USDT")
print(f"Closed PnL     : {total_pnl:.4f} USDT")
print("==========================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_ctx.py
Size: 3012
MTime: 2025-10-28 08:04:00.885850656 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
import numpy as np

# ==============================
# CONFIG
# ==============================
DB_A  = "/opt/scalp/project/data/a.db"
DB_OA = "/opt/scalp/project/data/oa.db"
DB_U  = "/opt/scalp/project/data/u.db"


# ==============================
# UTILITAIRES
# ==============================
def ema(values, period):
    if len(values) < period:
        return None
    alpha = 2 / (period + 1)
    e = values[0]
    for v in values[1:]:
        e = alpha * v + (1 - alpha) * e
    return e


def macd(values):
    e12 = ema(values, 12)
    e26 = ema(values, 26)
    if e12 is None or e26 is None:
        return None
    return e12 - e26


def score_U(volume, vola, price):
    if vola == 0 or price == 0:
        return 0
    # Normalisation par le prix pour rester dans des ratios cohérents
    return (volume / vola) / price


# ==============================
# MAIN LOOP
# ==============================
def run():
    con = sqlite3.connect(DB_A)
    con.execute("ATTACH DATABASE ? AS oa", (DB_OA,))
    con.execute("ATTACH DATABASE ? AS u", (DB_U,))
    cur = con.cursor()

    insts = [r[0] for r in cur.execute("SELECT instId FROM u.universe LIMIT 20")]
    now_ts = int(time.time() * 1000)

    for inst in insts:
        # Récupère les données OHLCV sur 3 timeframes
        data5  = cur.execute("SELECT close, volume FROM oa.ohlcv_5m  WHERE instId=? ORDER BY ts DESC LIMIT 150", (inst,)).fetchall()
        data15 = cur.execute("SELECT close, volume FROM oa.ohlcv_15m WHERE instId=? ORDER BY ts DESC LIMIT 150", (inst,)).fetchall()
        data30 = cur.execute("SELECT close, volume FROM oa.ohlcv_30m WHERE instId=? ORDER BY ts DESC LIMIT 150", (inst,)).fetchall()
        if not data5 or not data15 or not data30:
            continue

        close5, vol5 = [c for c, _ in data5][::-1], [v for _, v in data5][::-1]
        close15 = [c for c, _ in data15][::-1]
        close30 = [c for c, _ in data30][::-1]

        macd5, macd15, macd30 = macd(close5), macd(close15), macd(close30)
        vola = np.std(close5)
        vol_mean = np.mean(vol5)
        last_price = close5[-1]
        sU = score_U(vol_mean, vola, last_price)
        sA = np.nanmean([abs(macd5 or 0), abs(macd15 or 0), abs(macd30 or 0)])

        # Détermination du contexte global
        if macd5 > 0 and macd15 > 0 and macd30 > 0:
            ctx = "bullish"; p_buy, p_sell = 0.9, 0.1
        elif macd5 < 0 and macd15 < 0 and macd30 < 0:
            ctx = "bearish"; p_buy, p_sell = 0.1, 0.9
        else:
            ctx = "range"; p_buy, p_sell = 0.5, 0.5

        cur.execute("""
            INSERT INTO ctx_A (instId, ts, score_U, score_A, p_buy, p_sell, ctx)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (inst, now_ts, sU, sA, p_buy, p_sell, ctx))

    con.commit()
    con.close()
    print(f"[A] ✅ ctx_A updated @ {time.strftime('%H:%M:%S')}")


# ==============================
# RUN
# ==============================
if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_config.py
Size: 417
MTime: 2025-10-28 09:28:51.879734225 +0100
----- CONTENT -----
DB_SIG="/opt/scalp/project/data/signals.db"
DB_T="/opt/scalp/project/data/t.db"
DB_A="/opt/scalp/project/data/a.db"
DB_XOPEN="/opt/scalp/project/data/x_open.db"
DB_XCLOSED="/opt/scalp/project/data/x_closed.db"   # <-- ajouté
DB_XFOLLOW="/opt/scalp/project/data/x_follow.db"
DB_H="/opt/scalp/project/data/h.db"

COOLDOWN_OPEN = 0        # tu pourras remonter plus tard (ex 45-120)
ATR_SL_MULT = 2.0
ATR_TP_MULT = 3.0
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/U_universe.py
Size: 572
MTime: 2025-10-26 07:24:51.520542760 +0100
----- CONTENT -----
import ccxt, sqlite3

DBU = "/opt/scalp/project/data/u.db"
TOP = 20

exchange = ccxt.bitget()
markets = exchange.load_markets()

perps = []
for s,info in markets.items():
    if info.get('swap',False) and info['quote'] == 'USDT':
        inst = s.replace(":USDT","")  # -> BTC/USDT:USDT → BTC/USDT
        perps.append(inst)

perps = perps[:TOP]

con = sqlite3.connect(DBU, timeout=5)
con.execute("DELETE FROM universe;")
for inst in perps:
    con.execute("INSERT OR IGNORE INTO universe(instId) VALUES (?)", (inst,))
con.commit()
con.close()

print("[U] OK :", perps)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/init_db.py
Size: 1110
MTime: 2025-10-26 07:32:15.285178016 +0100
----- CONTENT -----
import sqlite3

DB_A = "/opt/scalp/project/data/a.db"

def init_db():
    con = sqlite3.connect(DB_A, timeout=5)
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_5m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_15m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_30m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ctx_a (
        instId TEXT,
        ts INTEGER,
        p_buy REAL,
        p_hold REAL,
        p_sell REAL,
        score REAL,
        ctx TEXT
    );
    """)

    con.commit()
    con.close()
    print("[INIT_DB] OK – A DB ready")

if __name__ == "__main__":
    init_db()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_ctx_dash.py
Size: 1524
MTime: 2025-10-27 19:45:33.204806371 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_A = "/opt/scalp/project/data/a.db"

def hms(ts):
    if ts > 10_000_000_000: 
        ts = ts/1000
    return time.strftime("%H:%M:%S", time.localtime(ts))

def run():
    con = sqlite3.connect(DB_A)
    rows = con.execute("""
    SELECT instId, ctx, score_A, ts
    FROM ctx_a_latest
    ORDER BY ABS(score_A) DESC, instId
    """).fetchall()
    con.close()

    # remove duplicates by instId (keep first occurrence only)
    seen = set()
    clean_rows = []
    for r in rows:
        if r[0] not in seen:
            seen.add(r[0])
            clean_rows.append(r)

    # categories
    bull  = [r for r in clean_rows if r[1]=="bullish"]
    bear  = [r for r in clean_rows if r[1]=="bearish"]
    rang  = [r for r in clean_rows if r[1]=="range"]
    other = [r for r in clean_rows if r[1] not in ("bullish","bearish","range")]

    total = len(clean_rows)
    ts = clean_rows[0][3] if clean_rows else int(time.time())

    print("===== CTX SUMMARY (A) =====")
    print(f"bullish | {len(bull):<2} | {' '.join([r[0] for r in bull[:5]])} | {hms(ts)}")
    print(f"bearish | {len(bear):<2} | {' '.join([r[0] for r in bear[:5]])} | {hms(ts)}")
    print(f"range   | {len(rang):<2} | {' '.join([r[0] for r in rang[:5]])} | {hms(ts)}")
    print(f"other   | {len(other):<2} | {' '.join([r[0] for r in other[:5]])} | {hms(ts)}")
    print("---------------------------")
    print(f"TOTAL   | {total}")
    print("===========================")

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/config/scalp.conf
Size: 18
MTime: 2025-10-25 17:08:55.549075009 +0200
----- CONTENT -----
UNIVERSE_LIMIT=20
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xopen.sh
Size: 85
MTime: 2025-10-27 06:38:40.982605637 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_close.sh
Size: 102
MTime: 2025-10-27 13:32:48.246660187 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/a_analyse.sh
Size: 110
MTime: 2025-10-28 08:32:18.783561566 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/A_ctx.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/u_universe.sh
Size: 89
MTime: 2025-10-25 17:23:40.450204518 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/U_universe.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv_A.sh
Size: 89
MTime: 2025-10-25 17:23:57.298226222 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_dash.sh
Size: 2858
MTime: 2025-10-28 10:38:00.295906518 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail

DB_X="/opt/scalp/project/data/x_open.db"
DB_C="/opt/scalp/project/data/x_closed.db"
DB_T="/opt/scalp/project/data/t.db"
DB_H="/opt/scalp/project/data/h.db"

while true; do
  clear
  echo "===== DASH $(date '+%H:%M:%S') ====="

  pnl_lat_total="0"
  # --- Positions ouvertes (lecture sûre, read-only, prix depuis t.db) ---
  sqlite3 -readonly "$DB_X" "
    SELECT instId, side, entry, sl, tp, qty, break_even_set, pyramided, ts_open
    FROM positions_open;
  " | while IFS='|' read -r inst side entry sl tp qty be pyr tsO; do
      price="$(sqlite3 -readonly "$DB_T" "SELECT price FROM ticks WHERE instId='$inst' ORDER BY ts DESC LIMIT 1;")"
      [ -z "$price" ] && price="0"

      if [ "$side" = "buy" ]; then
        pnl=$(awk -v p="$price" -v e="$entry" -v q="$qty" 'BEGIN{printf "%.6f",(p-e)*q}')
      else
        pnl=$(awk -v p="$price" -v e="$entry" -v q="$qty" 'BEGIN{printf "%.6f",(e-p)*q}')
      fi

      now=$(date +%s)
      age=$(( now - tsO/1000 ))

      printf "%-10s %-4s entry=%-8.4f price=%-8.4f SL=%-8.4f TP=%-8.4f BE=%d PYR=%d pnl=%-8.6f age=%4ds\n" \
        "$inst" "$side" "$entry" "$price" "$sl" "$tp" "$be" "$pyr" "$pnl" "$age"

      # accumulate latent PnL (use a temp file because subshell)
      echo "$pnl" >> /tmp/.pnl_lat.$$ 2>/dev/null || true
  done

  # calc sum pnl_lat from temp file (if exists)
  if [ -f /tmp/.pnl_lat.$$ ]; then
    pnl_lat_total=$(awk '{s+=$1} END{printf "%.6f",s+0}' /tmp/.pnl_lat.$$)
    rm -f /tmp/.pnl_lat.$$ || true
  else
    pnl_lat_total="0"
  fi

  echo
  echo "--- SUMMARY ---"

  # PnL réalisé
  pnl_real=$(sqlite3 -readonly "$DB_C" "SELECT IFNULL(SUM(pnl),0) FROM positions_closed;")

  # Winrate 20 derniers
  win20=$(sqlite3 -readonly "$DB_C" "
    SELECT CASE WHEN COUNT(*)=0 THEN '0.0' ELSE
      ROUND((SUM(CASE WHEN pnl>0 THEN 1 ELSE 0 END)*100.0)/COUNT(*),1)
    END
    FROM (SELECT pnl FROM positions_closed ORDER BY ts_close DESC LIMIT 20);
  ")

  # Score_H moyen – détection de schéma
  cols=$(sqlite3 -readonly "$DB_H" "PRAGMA table_info(score_H);" 2>/dev/null | awk -F'|' '{print $2}' | tr '\n' ' ')
  if echo "$cols" | grep -q '\bscore_H\b'; then
    score_h=$(sqlite3 -readonly "$DB_H" "SELECT IFNULL(ROUND(AVG(score_H),3),0) FROM score_H;")
  elif echo "$cols" | grep -q '\bavg_pnl\b'; then
    score_h=$(sqlite3 -readonly "$DB_H" "SELECT IFNULL(ROUND(AVG(avg_pnl),3),0) FROM score_H;")
  else
    score_h="0"
  fi

  printf "PnL_real=%.4f   PnL_lat=%.4f   Win20=%s%%   Score_H=%s\n" \
    "$pnl_real" "$pnl_lat_total" "$win20" "$score_h"

  echo
  echo "--- LAST 5 CLOSED ---"
  sqlite3 -readonly "$DB_C" "
    SELECT instId, side, entry, exit, pnl, reason,
           strftime('%H:%M:%S', ts_close/1000, 'unixepoch','localtime') AS hms
    FROM positions_closed
    ORDER BY ts_close DESC LIMIT 5;
  "

  sleep 1
done
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_signals.sh
Size: 88
MTime: 2025-10-26 19:01:24.741873511 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/B_signals.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_follow.sh
Size: 103
MTime: 2025-10-27 13:32:41.118652027 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_follow.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv.sh
Size: 89
MTime: 2025-10-26 18:03:16.207265495 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_dash.sh
Size: 85
MTime: 2025-10-27 06:42:34.110928924 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/b_dash.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/ob_ohlcv_B.sh
Size: 89
MTime: 2025-10-25 13:12:44.107774002 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OB_ohlcv_B.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_open.sh
Size: 101
MTime: 2025-10-27 13:32:31.822641387 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xclose.sh
Size: 86
MTime: 2025-10-27 06:43:25.474998597 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/t_ticks.sh
Size: 86
MTime: 2025-10-25 17:24:36.322276510 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/T_ticks.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xfollow.sh
Size: 87
MTime: 2025-10-27 06:43:14.554983825 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_follow.py
----- FILE END -----
=== Export /opt/scalp/project/data/a.db
=== Export /opt/scalp/project/data/b.db
=== Export /opt/scalp/project/data/h.db
=== Export /opt/scalp/project/data/oa.db
=== Export /opt/scalp/project/data/ob.db
=== Export /opt/scalp/project/data/signals.db
=== Export /opt/scalp/project/data/t.db
=== Export /opt/scalp/project/data/ticks.db
=== Export /opt/scalp/project/data/u.db
=== Export /opt/scalp/project/data/x.db
=== Export /opt/scalp/project/data/x_account.db
=== Export /opt/scalp/project/data/x_closed.db
=== Export /opt/scalp/project/data/x_follow.db
=== Export /opt/scalp/project/data/x_history.db
=== Export /opt/scalp/project/data/x_open.db
