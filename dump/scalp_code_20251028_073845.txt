# Scalp Project Code Dump
# Generated: 2025-10-28 06:38:45 UTC
# Root: /opt/scalp
# Caps: 512KB/file, max 4000 files

========== TREE (size, mtime) ==========
/opt/scalp/dp.sh                                                                          4650  2025-10-27 14:49:38.355844764 +0100
/opt/scalp/project/bin/a_analyse.sh                                                         88  2025-10-26 18:03:22.883271493 +0100
/opt/scalp/project/bin/b_dash.sh                                                            85  2025-10-27 06:42:34.110928924 +0100
/opt/scalp/project/bin/b_signals.sh                                                         88  2025-10-26 19:01:24.741873511 +0100
/opt/scalp/project/bin/oa_ohlcv.sh                                                          89  2025-10-26 18:03:16.207265495 +0100
/opt/scalp/project/bin/oa_ohlcv_A.sh                                                        89  2025-10-25 17:23:57.298226222 +0200
/opt/scalp/project/bin/ob_ohlcv_B.sh                                                        89  2025-10-25 13:12:44.107774002 +0200
/opt/scalp/project/bin/t_ticks.sh                                                           86  2025-10-25 17:24:36.322276510 +0200
/opt/scalp/project/bin/u_universe.sh                                                        89  2025-10-25 17:23:40.450204518 +0200
/opt/scalp/project/bin/x_close.sh                                                          102  2025-10-27 13:32:48.246660187 +0100
/opt/scalp/project/bin/x_dash.sh                                                          2086  2025-10-25 15:39:57.721793619 +0200
/opt/scalp/project/bin/x_follow.sh                                                         103  2025-10-27 13:32:41.118652027 +0100
/opt/scalp/project/bin/x_open.sh                                                           101  2025-10-27 13:32:31.822641387 +0100
/opt/scalp/project/bin/xclose.sh                                                            86  2025-10-27 06:43:25.474998597 +0100
/opt/scalp/project/bin/xfollow.sh                                                           87  2025-10-27 06:43:14.554983825 +0100
/opt/scalp/project/bin/xopen.sh                                                             85  2025-10-27 06:38:40.982605637 +0100
/opt/scalp/project/config/scalp.conf                                                        18  2025-10-25 17:08:55.549075009 +0200
/opt/scalp/project/scripts/A_analyse.py                                                   1601  2025-10-27 15:11:28.706394879 +0100
/opt/scalp/project/scripts/A_config.py                                                     336  2025-10-27 16:45:18.992784773 +0100
/opt/scalp/project/scripts/A_ctx.py                                                       4281  2025-10-27 19:40:13.516350570 +0100
/opt/scalp/project/scripts/A_ctx_dash.py                                                  1524  2025-10-27 19:45:33.204806371 +0100
/opt/scalp/project/scripts/B_dash.py                                                       472  2025-10-26 19:02:03.217938218 +0100
/opt/scalp/project/scripts/B_signals.py                                                   2693  2025-10-27 15:05:29.101656409 +0100
/opt/scalp/project/scripts/H_score.py                                                      368  2025-10-27 09:03:02.367929303 +0100
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482  2025-10-26 10:53:32.748328034 +0100
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1667  2025-10-25 13:12:20.467743772 +0200
/opt/scalp/project/scripts/T_ticks.py                                                      700  2025-10-25 17:24:28.282266152 +0200
/opt/scalp/project/scripts/U_universe.py                                                   572  2025-10-26 07:24:51.520542760 +0100
/opt/scalp/project/scripts/X_close.py                                                       94  2025-10-27 13:32:23.122631432 +0100
/opt/scalp/project/scripts/X_config.py                                                     862  2025-10-27 10:58:46.599909791 +0100
/opt/scalp/project/scripts/X_dash.py                                                      1761  2025-10-27 13:17:53.937659362 +0100
/opt/scalp/project/scripts/X_follow.py                                                    1970  2025-10-27 13:32:13.578620514 +0100
/opt/scalp/project/scripts/X_open.py                                                      2599  2025-10-27 13:31:41.682584047 +0100
/opt/scalp/project/scripts/b_dash.py                                                       543  2025-10-27 15:05:43.153688711 +0100
/opt/scalp/project/scripts/init_db.py                                                     1110  2025-10-26 07:32:15.285178016 +0100
/opt/scalp/project/scripts/x_dash.py                                                      1689  2025-10-27 09:06:10.048075732 +0100

========== TOP 10 BIGGEST FILES ==========
/opt/scalp/dp.sh                                                                          4650
/opt/scalp/project/scripts/A_ctx.py                                                       4281
/opt/scalp/project/scripts/B_signals.py                                                   2693
/opt/scalp/project/scripts/X_open.py                                                      2599
/opt/scalp/project/scripts/OA_ohlcv_A.py                                                  2482
/opt/scalp/project/bin/x_dash.sh                                                          2086
/opt/scalp/project/scripts/X_follow.py                                                    1970
/opt/scalp/project/scripts/X_dash.py                                                      1761
/opt/scalp/project/scripts/x_dash.py                                                      1689
/opt/scalp/project/scripts/OB_ohlcv_B.py                                                  1667

========== CONCAT CONTENT ==========

----- FILE BEGIN -----
Path: /opt/scalp/dp.sh
Size: 4650
MTime: 2025-10-27 14:49:38.355844764 +0100
----- CONTENT -----
#!/usr/bin/env bash
set -euo pipefail

# --------- Réglages ---------
ROOT="/opt/scalp"
DUMP_DIR="${ROOT}/dump"
TS="$(date +'%Y%m%d_%H%M%S')"
OUT="${DUMP_DIR}/scalp_code_${TS}.txt"
SQL_OUT="${DUMP_DIR}/scalp_db_${TS}.sql"
TMP_LIST="$(mktemp)"
MAX_FILE_SIZE_KB="${MAX_FILE_SIZE_KB:-512}"
MAX_FILES="${MAX_FILES:-4000}"
DRY_RUN="${DRY_RUN:-0}"

mkdir -p "$DUMP_DIR"
trap 'rm -f "$TMP_LIST"' EXIT

# --------- Git depuis /etc/scalp.env ---------
[ -f /etc/scalp.env ] && . /etc/scalp.env

: "${GIT_USERNAME:?manquant}"
: "${GIT_TOKEN:?manquant}"

GIT_BRANCH="${GIT_BRANCH:-main}"
GIT_EMAIL_USE="${GIT_EMAIL:-${GIT_USERNAME}@users.noreply.github.com}"
GIT_HOST="${GIT_HOST:-github.com}"
GIT_OWNER="${GIT_OWNER:-$GIT_USERNAME}"
GIT_REPO="${GIT_REPO:-Scalp}"
GIT_REMOTE="${GIT_REMOTE:-}"

if [ -n "$GIT_REMOTE" ]; then
  REMOTE_URL="$GIT_REMOTE"
else
  REMOTE_URL="https://${GIT_HOST}/${GIT_OWNER}/${GIT_REPO}.git"
fi

echo "[dump_and_push] branch=${GIT_BRANCH} dry_run=${DRY_RUN} remote=${REMOTE_URL}"

# --------- Collecte fichiers ---------
find "$ROOT" -type f \
  -not -path '*/.*' \
  -not -path '*/.git/*' \
  -not -path '*/__pycache__/*' \
  -not -path '*/venv/*' -not -path '*/.venv/*' \
  -not -path '*/var/*' \
  -not -path '*/logs/*' \
  -not -path '*/data/*' \
  -not -path '*/reports/*' \
  -not -path '*/dump/*' \
  -size -"${MAX_FILE_SIZE_KB}"k \
  \( -name '*.py' -o -name '*.pyi' -o -name '*.sh' -o -name '*.bash' \
     -name '*.ini' -o -name '*.cfg' -o -name '*.conf' -o -name '*.toml' \
     -name '*.yaml' -o -name '*.yml' -o -name '*.md' -o -name '*.txt' \
     -name '*.sql' -o -name '*.json' -o -name '*.csv' \) \
  -print0 > "$TMP_LIST"

# Limite MAX_FILES
TMP2="$(mktemp)"; trap 'rm -f "$TMP2"' EXIT
awk -v max="$MAX_FILES" -v RS='\0' -v ORS='\0' 'NR<=max{print}' "$TMP_LIST" > "$TMP2"
mv "$TMP2" "$TMP_LIST"

# En-tête dump TXT
{
  echo "# Scalp Project Code Dump"
  echo "# Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
  echo "# Root: ${ROOT}"
  echo "# Caps: ${MAX_FILE_SIZE_KB}KB/file, max ${MAX_FILES} files"
  echo
  echo "========== TREE (size, mtime) =========="
} > "$OUT"

# TREE
tr '\0' '\n' < "$TMP_LIST" | sort | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  mt="$(stat -c %y "$f" 2>/dev/null || echo unknown)"
  printf "%-80s  %12s  %s\n" "$f" "$sz" "$mt" >> "$OUT"
done

# TOP 10
{
  echo
  echo "========== TOP 10 BIGGEST FILES =========="
} >> "$OUT"

tr '\0' '\n' < "$TMP_LIST" | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  printf "%012d\t%s\n" "$sz" "$f"
done | sort -r | head -n 10 | awk -F'\t' '{printf "%-80s  %12d\n", $2, $1+0}' >> "$OUT"

# Contenu concaténé
{
  echo
  echo "========== CONCAT CONTENT =========="
} >> "$OUT"

tr '\0' '\n' < "$TMP_LIST" | while IFS= read -r f; do
  sz="$(stat -c %s "$f" 2>/dev/null || echo 0)"
  mt="$(stat -c %y "$f" 2>/dev/null || echo unknown)"
  {
    echo
    echo "----- FILE BEGIN -----"
    echo "Path: $f"
    echo "Size: $sz"
    echo "MTime: $mt"
    echo "----- CONTENT -----"
  } >> "$OUT"

  if [ "$sz" -gt $((MAX_FILE_SIZE_KB*1024)) ]; then
    head -c $((MAX_FILE_SIZE_KB*1024)) "$f" 2>/dev/null >> "$OUT" || true
    echo -e "\n[TRUNCATED]" >> "$OUT"
  else
    cat "$f" 2>/dev/null >> "$OUT" || true
  fi
  echo "----- FILE END -----" >> "$OUT"
done

echo "Dump TXT prêt: $OUT"

# --------- Export DB (SCHÉMA UNIQUEMENT) ---------
SQL_OUT="${DUMP_DIR}/scalp_db_${TS}.sql"
: > "$SQL_OUT"

if command -v sqlite3 >/dev/null 2>&1; then
  for DB_PATH in /opt/scalp/project/data/*.db; do
    [ -s "$DB_PATH" ] || continue
    echo "=== Export ${DB_PATH}" | tee -a "$OUT"
    {
      echo ""
      echo "/* DB: ${DB_PATH} */"
      echo "-- SCHEMA ONLY --"
      sqlite3 "$DB_PATH" ".schema"
      echo ""
    } >> "$SQL_OUT"
  done
else
  echo "sqlite3 introuvable, export DB ignoré" | tee -a "$OUT"
fi

# --------- Git: commit + push ---------
cd "$ROOT"
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || git init -q .

git config user.name "${GIT_USERNAME}"
git config user.email "${GIT_EMAIL_USE}"
git remote get-url origin >/dev/null 2>&1 || git remote add origin "${REMOTE_URL}"

touch .gitignore
for p in var/ logs/ data/ dump/; do grep -qxF "$p" .gitignore || echo "$p" >> .gitignore; done

git add -f "$OUT"
[ -s "$SQL_OUT" ] && git add -f "$SQL_OUT"
git commit -m "dump: ${OUT##*/} (schema only)" || true

if [ "$DRY_RUN" = "1" ]; then
  echo "DRY_RUN=1 -> push désactivé"
else
  AUTH_URL="https://${GIT_USERNAME}:${GIT_TOKEN}@${GIT_HOST}/${GIT_OWNER}/${GIT_REPO}.git"
  git push -f "$AUTH_URL" HEAD:${GIT_BRANCH}
  echo "OK: push vers ${REMOTE_URL} sur ${GIT_BRANCH}"
fi
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_dash.py
Size: 472
MTime: 2025-10-26 19:02:03.217938218 +0100
----- CONTENT -----
import sqlite3
DB="/opt/scalp/project/data/signals.db"

con=sqlite3.connect(DB)
rows=con.execute("""
SELECT ts_signal,instId,side,reason,ctx,score_A,score_B,price
FROM signals
ORDER BY ts_signal DESC LIMIT 12
""").fetchall()
con.close()

print("\n===== LAST SIGNALS (B) =====")
for r in rows:
    ts,inst,side,reason,ctx,sA,sB,price = r
    print(f"{inst:10} | {side:4} | {reason:12} | {ctx:7} | A={sA:.3f} | B={sB:.3f} | {price}")
print("============================\n")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/H_score.py
Size: 368
MTime: 2025-10-27 09:03:02.367929303 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_H="/opt/scalp/project/data/x_history.db"

def latest_H():
    con=sqlite3.connect(DB_H)
    row=con.execute("SELECT score_H FROM v_H_latest").fetchone()
    con.close()
    return float(row[0]) if row and row[0] else 0.0

def run():
    h=latest_H()
    print(f"[H] score_H={h:.3f}")

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_close.py
Size: 94
MTime: 2025-10-27 13:32:23.122631432 +0100
----- CONTENT -----
#!/usr/bin/env python3
# CLOSE handled by X_follow
import time
while True:
    time.sleep(60)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/b_dash.py
Size: 543
MTime: 2025-10-27 15:05:43.153688711 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3
from datetime import datetime

DB = "/opt/scalp/project/data/signals.db"

con = sqlite3.connect(DB)
rows = con.execute("""
SELECT instId,side,ctx,score_U,score_A,score_B,ts_signal
FROM signals
ORDER BY ts_signal DESC
LIMIT 15
""").fetchall()
con.close()

print("===== LAST SIGNALS (B) =====")
for r in rows:
    ts=datetime.fromtimestamp(r[6]/1000).strftime("%H:%M:%S")
    print(f"{r[0]:8} | {r[1]:4} | ctx={r[2]:7} | U={r[3]:.2f} A={r[4]:.2f} B={r[5]:.2f} | {ts}")
print("============================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OB_ohlcv_B.py
Size: 1667
MTime: 2025-10-25 13:12:20.467743772 +0200
----- CONTENT -----
import ccxt
import sqlite3
import time

DBu = "/opt/scalp/project/data/u.db"
DBo = "/opt/scalp/project/data/ob.db"

ex = ccxt.bitget()

def init_db():
    con = sqlite3.connect(DBo, timeout=5)
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_1m(
        instId TEXT,
        ts INTEGER,
        o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.execute("""CREATE TABLE IF NOT EXISTS kline_3m(
        instId TEXT,
        ts INTEGER,
        o REAL, h REAL, l REAL, c REAL, v REAL,
        PRIMARY KEY(instId, ts)
    )""")
    con.commit()
    con.close()

def get_universe():
    con = sqlite3.connect(DBu, timeout=5)
    rows = con.execute("SELECT instId FROM universe").fetchall()
    con.close()
    return [r[0] for r in rows]

def upsert(tf, inst, ohlcv):
    tbl = "kline_1m" if tf == "1m" else "kline_3m"
    con = sqlite3.connect(DBo, timeout=5)
    con.execute(f"INSERT OR REPLACE INTO {tbl}(instId,ts,o,h,l,c,v) VALUES(?,?,?,?,?,?,?)",
                (inst, ohlcv[0], ohlcv[1], ohlcv[2], ohlcv[3], ohlcv[4], ohlcv[5]))
    con.commit()
    con.close()

def fetch_tf(inst, tf):
    ohlc = ex.fetch_ohlcv(inst, tf, limit=150)
    for o in ohlc:
        upsert(tf, inst, o)
    print(f"[OB] {inst} {tf} stored ({len(ohlc)} candles)")

if __name__ == "__main__":
    init_db()
    while True:
        try:
            universe = get_universe()
            for inst in universe:
                fetch_tf(inst, "1m")
                fetch_tf(inst, "3m")
            time.sleep(10)
        except Exception as e:
            print("[OB ERROR]", e)
            time.sleep(5)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/B_signals.py
Size: 2693
MTime: 2025-10-27 15:05:29.101656409 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DB_A     = "/opt/scalp/project/data/a.db"
DB_SIG   = "/opt/scalp/project/data/signals.db"
DB_T     = "/opt/scalp/project/data/t.db"

# --- 6 SETUPS ---
def sig_trend(pb, ps):
    return (pb - ps)

def sig_breakout(price, hh, ll):
    if price > hh: return 1
    if price < ll: return -1
    return 0

def sig_pullback(price, ma):
    return 1 if price > ma else -1

def sig_meanrev(price, ma):
    dist = (price-ma)/ma
    if dist > 0.01: return -1
    if dist < -0.01: return 1
    return 0

def sig_range(ctx):
    return 0.3 if ctx=="range" else 0

def sig_volpush(vol, avg):
    return 1 if vol > 1.5*avg else 0

# -----------------------------------------
def compute(inst):

    # 1) get context A
    conA = sqlite3.connect(DB_A)
    row = conA.execute("SELECT ctx,score_U,score_A,p_buy,p_sell FROM ctx_a_latest WHERE instId=?",(inst,)).fetchone()
    conA.close()
    if not row: return None
    ctx,scoreU,scoreA,pb,ps = row

    # 2) get last tick (price)
    conT = sqlite3.connect(DB_T)
    t = conT.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    conT.close()
    if not t: return None
    price=float(t[0])

    # --- fake values / placeholders for BO/PB/MR/VOL (OK for now) ---
    hh, ll, ma, vol, avg = price*1.01, price*0.99, price, 1, 1

    # 3) compute 6 signals
    sTR = sig_trend(pb,ps)
    sBO = sig_breakout(price,hh,ll)
    sPB = sig_pullback(price,ma)
    sMR = sig_meanrev(price,ma)
    sRG = sig_range(ctx)
    sVP = sig_volpush(vol,avg)

    # 4) weighted score_B
    scoreB = 0.40*sTR + 0.25*sBO + 0.15*sPB + 0.10*sMR + 0.10*(sRG+sVP)

    # 5) decide side
    side="none"
    if scoreB>0.20: side="buy"
    elif scoreB<-0.20: side="sell"

    return side, ctx, scoreU, scoreA, scoreB

# -----------------------------------------
def save_signal(inst,side,ctx,u,a,b):
    con = sqlite3.connect(DB_SIG)
    con.execute("""
        INSERT INTO signals(instId,side,ctx,score_U,score_A,score_B,reason,ts_signal)
        VALUES(?,?,?,?,?,?,?,?)
    """,(inst,side,ctx,u,a,b,"auto",int(time.time()*1000)))
    con.commit()
    con.close()

# -----------------------------------------
def run():
    # get list of inst
    conA = sqlite3.connect(DB_A)
    insts=[r[0] for r in conA.execute("SELECT instId FROM ctx_a_latest")]
    conA.close()

    for inst in insts:
        sig=compute(inst)
        if not sig: continue
        side,ctx,u,a,b = sig
        if side!="none":
            save_signal(inst,side,ctx,u,a,b)

# -----------------------------------------
if __name__=="__main__":
    while True:
        run()
        time.sleep(4)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_open.py
Size: 2599
MTime: 2025-10-27 13:31:41.682584047 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from X_config import *
from datetime import datetime

def log(msg):
    print(f"[X_OPEN] {datetime.utcnow()} | {msg}")

def get_last_signal():
    con = sqlite3.connect(DB_SIG)
    row = con.execute("""
        SELECT instId, side, score_U, score_A, score_B, ts_signal
        FROM signals_for_open
        ORDER BY ts_signal DESC LIMIT 1
    """).fetchone()
    con.close()
    return row

def is_in_cooldown(ts_signal):
    return (time.time() - ts_signal/1000) < COOLDOWN_OPEN

def last_price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("""
        SELECT price FROM ticks
        WHERE instId=?
        ORDER BY ts DESC LIMIT 1
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def atr(inst):
    con = sqlite3.connect(DB_A)
    r = con.execute("""
        SELECT atr1m FROM feat_1m
        WHERE instId=?
        ORDER BY ts DESC LIMIT 1
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def already_open(inst):
    con = sqlite3.connect(DB_XOPEN)
    r = con.execute("SELECT instId FROM positions_open WHERE instId=?",(inst,)).fetchone()
    con.close()
    return r is not None

def open_trade(inst,side,entry,u,a,b,atr):
    sl = entry - ATR_SL_MULT*atr if side=="buy" else entry + ATR_SL_MULT*atr
    tp = entry + ATR_TP_MULT*atr if side=="buy" else entry - ATR_TP_MULT*atr
    qty = 1.0
    ts = int(time.time()*1000)

    con = sqlite3.connect(DB_XOPEN)
    con.execute("""
        INSERT INTO positions_open(instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open)
        VALUES(?,?,?,?,?,?,?,?,?,?)
    """,(inst,side,entry,sl,tp,qty,u,a,b,ts))
    con.commit()
    con.close()

    conF = sqlite3.connect(DB_XFOLLOW)
    conF.execute("""
        INSERT OR REPLACE INTO follow(instId,side,atr,be_active,trail_active,ts_update)
        VALUES(?,?,?,?,?,?)
    """,(inst,side,atr,0,0,ts))
    conF.commit()
    conF.close()

    log(f"OPEN {inst} {side} @ {entry}")

def run():
    log("READY")
    while True:
        sig = get_last_signal()
        if not sig:
            time.sleep(1)
            continue

        inst,side,u,a,b,ts_sig = sig
        if already_open(inst): 
            time.sleep(1)
            continue

        if is_in_cooldown(ts_sig):
            time.sleep(1)
            continue

        price = last_price(inst)
        aatr = atr(inst)
        if not price or not aatr:
            time.sleep(1)
            continue

        open_trade(inst,side,price,u,a,b,aatr)
        time.sleep(1)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_follow.py
Size: 1970
MTime: 2025-10-27 13:32:13.578620514 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from X_config import *
from datetime import datetime

def log(msg):
    print(f"[X_FOLLOW] {datetime.utcnow()} | {msg}")

def price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

def close_trade(inst,side,entry,px,qty,u,a,b,ts_open,reason):
    pnl = (px-entry)*qty if side=="buy" else (entry-px)*qty
    ts = int(time.time()*1000)

    con = sqlite3.connect(DB_XHIST)
    con.execute("""
        INSERT INTO x_history(instId,side,entry,exit,qty,pnl,score_U,score_A,score_B,ts_open,ts_close,reason)
        VALUES(?,?,?,?,?,?,?,?,?,?,?,?)
    """,(inst,side,entry,px,qty,pnl,u,a,b,ts_open,ts,reason))
    con.commit()
    con.close()

    con2 = sqlite3.connect(DB_XOPEN)
    con2.execute("DELETE FROM positions_open WHERE instId=?",(inst,))
    con2.commit()
    con2.close()

    con3 = sqlite3.connect(DB_XFOLLOW)
    con3.execute("DELETE FROM follow WHERE instId=?",(inst,))
    con3.commit()
    con3.close()

    log(f"CLOSE {inst} {reason} @ {px} pnl={pnl:.4f}")

def run():
    log("READY")
    while True:
        con = sqlite3.connect(DB_XOPEN)
        rows = con.execute("""
            SELECT instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open
            FROM positions_open
        """).fetchall()
        con.close()

        for inst,side,entry,sl,tp,qty,u,a,b,ts_open in rows:
            px = price(inst)
            if not px: continue

            if (side=="buy" and px<=sl) or (side=="sell" and px>=sl):
                close_trade(inst,side,entry,px,qty,u,a,b,ts_open,"SL")
                continue

            if (side=="buy" and px>=tp) or (side=="sell" and px<=tp):
                close_trade(inst,side,entry,px,qty,u,a,b,ts_open,"TP")
                continue

        time.sleep(FOLLOW_INTERVAL)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/OA_ohlcv_A.py
Size: 2482
MTime: 2025-10-26 10:53:32.748328034 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time, ccxt

DBU = "/opt/scalp/project/data/u.db"
DBO = "/opt/scalp/project/data/oa.db"
TF_LIST = ["5m","15m","30m"]
INIT = 150
MAX_ROWS = 300

ex = ccxt.bitget()

def to_bitget_symbol(inst: str) -> str:
    return inst if ":" in inst else f"{inst}:USDT"

def ensure_schema():
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    for tf in TF_LIST:
        cur.execute(f"DROP TABLE IF EXISTS ohlcv_{tf}")
        cur.execute(f"""
        CREATE TABLE IF NOT EXISTS ohlcv_{tf}(
          instId TEXT,
          ts INTEGER,
          open REAL, high REAL, low REAL, close REAL, volume REAL,
          PRIMARY KEY(instId, ts)
        )
        """)
    con.commit()
    con.close()

def load_universe():
    con = sqlite3.connect(DBU, timeout=5)
    rows = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()
    return rows

def last_ts(con, tf, inst):
    row = con.execute(f"SELECT MAX(ts) FROM ohlcv_{tf} WHERE instId=?", (inst,)).fetchone()
    return row[0] if row and row[0] is not None else None

def upsert_batch(tf, inst, batch):
    if not batch:
        return
    con = sqlite3.connect(DBO, timeout=5)
    cur = con.cursor()
    cur.executemany(
        f"INSERT OR REPLACE INTO ohlcv_{tf}(instId,ts,open,high,low,close,volume) VALUES (?,?,?,?,?,?,?)",
        [(inst, o[0], o[1], o[2], o[3], o[4], o[5]) for o in batch]
    )
    cur.execute(f"""
        DELETE FROM ohlcv_{tf}
        WHERE instId=?
          AND ts NOT IN (
            SELECT ts FROM ohlcv_{tf}
            WHERE instId=?
            ORDER BY ts DESC
            LIMIT {MAX_ROWS}
          )
    """, (inst, inst))
    con.commit()
    con.close()

def sync_inst_tf(inst, tf):
    inst_ccxt = to_bitget_symbol(inst)
    con = sqlite3.connect(DBO, timeout=5)
    ts_last = last_ts(con, tf, inst)
    con.close()

    if ts_last is None:
        data = ex.fetch_ohlcv(inst_ccxt, tf, limit=INIT)
        upsert_batch(tf, inst, data)
        return

    data = ex.fetch_ohlcv(inst_ccxt, tf, since=ts_last + 1, limit=150)
    upsert_batch(tf, inst, data)

def main():
    ensure_schema()
    insts = load_universe()
    for inst in insts:
        for tf in TF_LIST:
            try:
                sync_inst_tf(inst, tf)
                time.sleep(0.25)
            except Exception as e:
                print(f"[OA][{inst}][{tf}] WARN: {e}")
    print("[OA] ✅ Multi-TF sync to oa.db")

if __name__ == "__main__":
    main()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_config.py
Size: 336
MTime: 2025-10-27 16:45:18.992784773 +0100
----- CONTENT -----
#!/usr/bin/env python3

# DB paths
DB_A  = "/opt/scalp/project/data/a.db"
DB_OB = "/opt/scalp/project/data/ob.db"
DB_OA = "/opt/scalp/project/data/oa.db"
DB_U  = "/opt/scalp/project/data/u.db"

# TF used
TF_SHORT = "5m"
TF_MED   = "15m"
TF_LONG  = "30m"

# Weights for score (softmax later)
W_SHORT = 0.50
W_MED   = 0.30
W_LONG  = 0.20
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/T_ticks.py
Size: 700
MTime: 2025-10-25 17:24:28.282266152 +0200
----- CONTENT -----
import ccxt.pro as ccxtpro, sqlite3, time

UDB = "/opt/scalp/project/data/u.db"
TDB = "/opt/scalp/project/data/t.db"

async def run():
    con = sqlite3.connect(UDB)
    insts = [r[0] for r in con.execute("SELECT instId FROM universe")]
    con.close()

    ex = ccxtpro.bitget()

    while True:
        for inst in insts:
            ticker = await ex.watch_ticker(inst)
            ts = int(time.time() * 1000)
            price = ticker['last']
            conT = sqlite3.connect(TDB, timeout=5)
            conT.execute("INSERT INTO ticks VALUES(?,?,?)", (inst, ts, price))
            conT.commit()
            conT.close()

if __name__ == "__main__":
    import asyncio
    asyncio.run(run())
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_analyse.py
Size: 1601
MTime: 2025-10-27 15:11:28.706394879 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, math, time

DB_A = "/opt/scalp/project/data/a.db"
DB_U = "/opt/scalp/project/data/u.db"
DB_OB = "/opt/scalp/project/data/ob.db"
TF = "5m"

def softmax(x):
    e = [math.exp(i) for i in x]
    s = sum(e)
    return [v/s for v in e]

def get_universe():
    con = sqlite3.connect(DB_U)
    rows = con.execute("SELECT instId FROM universe ORDER BY instId").fetchall()
    con.close()
    return [r[0] for r in rows]

def load_ob(inst):
    con = sqlite3.connect(DB_OB)
    row = con.execute(f"SELECT rsi FROM ob_{TF} WHERE instId=? ORDER BY ts DESC LIMIT 1", (inst,)).fetchone()
    con.close()
    return row[0] if row else None

def compute_ctx(rsi):
    if rsi < 30: return "bullish"
    if rsi > 70: return "bearish"
    if 45 <= rsi <= 55: return "range"
    return "none"

def compute_score_A(ctx):
    if ctx == "bullish": return 0.8
    if ctx == "bearish": return -0.8
    if ctx == "range": return 0.0
    return 0.0

def run():
    insts = get_universe()
    now = int(time.time()*1000)
    out = []

    for inst in insts:
        rsi = load_ob(inst)
        if rsi is None:
            continue
        ctx = compute_ctx(rsi)
        score_A = compute_score_A(ctx)
        p_buy, p_sell = softmax([score_A, -score_A])
        out.append((inst, now, 0.0, score_A, p_buy, p_sell, ctx))

    con = sqlite3.connect(DB_A)
    con.execute("DELETE FROM ctx_a_latest")
    con.executemany("INSERT INTO ctx_a_latest(instId,ts,score_U,score_A,p_buy,p_sell,ctx) VALUES (?,?,?,?,?,?,?)", out)
    con.commit()
    con.close()

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/x_dash.py
Size: 1689
MTime: 2025-10-27 09:06:10.048075732 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time
from datetime import datetime

DBP="/opt/scalp/project/data/x_open.db"
DBF="/opt/scalp/project/data/x_follow.db"
DBH="/opt/scalp/project/data/x_history.db"

def h(ts):return datetime.fromtimestamp(ts/1000).strftime("%H:%M:%S")

def get_H(inst):
    con=sqlite3.connect(DBH)
    r=con.execute("""
    WITH last20 AS (
        SELECT pnl FROM history WHERE instId=?
        ORDER BY ts_close DESC LIMIT 20
    ),
    stats AS (
        SELECT 
            (SELECT COUNT(*) FROM last20 WHERE pnl>0)*1.0/(SELECT COUNT(*) FROM last20) AS winrate,
            (SELECT SUM(pnl) FROM last20 WHERE pnl>0) AS sum_win,
            (SELECT SUM(ABS(pnl)) FROM last20 WHERE pnl<0) AS sum_loss
    )
    SELECT 
        CASE WHEN sum_loss IS NULL OR sum_loss=0 THEN 1.0 
        ELSE (0.50*winrate + 0.50*MIN(1.0, (sum_win/sum_loss)/2.0))
        END AS H
    FROM stats
    """,(inst,)).fetchone()
    con.close()
    return float(r[0]) if r and r[0] else 0.0

print("===== X DASH =====")

# OPEN
con=sqlite3.connect(DBP)
rows=con.execute("SELECT instId,side,entry,qty,lev,risk,score_G,ts_open FROM positions_open").fetchall()
con.close()
if not rows:
    print("No open position")
else:
    for r in rows:
        inst,side,e,qty,lev,risk,sg,ts=r
        Hs=get_H(inst)
        print(f"{inst} | {side} | entry={e} | lev={lev:.2f} | risk={risk:.3f} | G={sg:.3f} | H={Hs:.3f} | {h(ts)}")

# FOLLOW
con=sqlite3.connect(DBF)
rows=con.execute("SELECT instId,current,upnl,stage,ts_update FROM follow").fetchall()
con.close()
for r in rows:
    inst,cur,u,st,ts=r
    print(f"FOLLOW -> {inst} | {cur} | upnl={u:.4f} | {st} | {h(ts)}")

print("===================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_dash.py
Size: 1761
MTime: 2025-10-27 13:17:53.937659362 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_O = "/opt/scalp/project/data/x_open.db"
DB_H = "/opt/scalp/project/data/x_history.db"
DB_T = "/opt/scalp/project/data/t.db"

def h(ts): 
    return time.strftime("%H:%M:%S", time.localtime(ts/1000))

def price(inst):
    con = sqlite3.connect(DB_T)
    r = con.execute("SELECT price FROM ticks WHERE instId=? ORDER BY ts DESC LIMIT 1",(inst,)).fetchone()
    con.close()
    return float(r[0]) if r else None

# ===== OPEN POSITIONS =====
print("===== OPEN POSITIONS =====")
con = sqlite3.connect(DB_O)
rows = con.execute("SELECT instId,side,entry,sl,tp,qty,score_U,score_A,score_B,ts_open FROM positions_open").fetchall()
con.close()

if not rows:
    print("No open positions")
else:
    for r in rows:
        inst,side,e,sl,tp,qty,u,a,b,ts = r
        p = price(inst)
        pnl = (p-e)*qty if side=="buy" else (e-p)*qty
        print(f"{inst} | {side} | entry={e:.6f} | sl={sl:.6f} | tp={tp:.6f} | pnl={pnl:.4f} | {h(ts)}")
print("==========================\n")

# ===== LAST CLOSED =====
print("===== LAST CLOSED =====")
con = sqlite3.connect(DB_H)
hist = con.execute("""
SELECT instId,side,entry,exit,qty,pnl,ts_close,reason
FROM x_history ORDER BY ts_close DESC LIMIT 5
""").fetchall()
con.close()

if not hist:
    print("No closed positions")
else:
    for inst,side,e,x,qty,pnl,tsc,reason in hist:
        print(f"{inst} | {side} | {e:.4f}->{x:.4f} | pnl={pnl:.4f} | {h(tsc)} | {reason}")
print("==========================\n")

print("===== ACCOUNT =====")
BAL = 1000.0
total_pnl = sum([h[5] for h in hist]) if hist else 0
print(f"Balance paper  : {BAL:.2f} USDT")
print(f"Equity paper   : {BAL+total_pnl:.2f} USDT")
print(f"Closed PnL     : {total_pnl:.4f} USDT")
print("==========================")
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_ctx.py
Size: 4281
MTime: 2025-10-27 19:40:13.516350570 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, math

DB_A  = "/opt/scalp/project/data/a.db"
DB_U  = "/opt/scalp/project/data/u.db"
DB_OA = "/opt/scalp/project/data/oa.db"

# ---------- utils ----------
def softmax(v):
    m = max(v)
    ex = [math.exp(x - m) for x in v]
    s = sum(ex)
    return [x/s for x in ex] if s else [0.0]*len(v)

def exec_many(db, stmts):
    con = sqlite3.connect(db)
    cur = con.cursor()
    for s in stmts:
        cur.execute(s)
    con.commit()
    con.close()

def q(db, sql, params=()):
    con = sqlite3.connect(db)
    cur = con.cursor()
    cur.execute(sql, params)
    rows = cur.fetchall()
    con.close()
    return rows

# ---------- ensure schema (table + view) ----------
def ensure_schema():
    stmts = [
        "CREATE TABLE IF NOT EXISTS ctx_a (instId TEXT, ts INTEGER, score_U REAL, score_A REAL, p_buy REAL, p_sell REAL, ctx TEXT)",
        # recreate view if missing
        """CREATE VIEW IF NOT EXISTS ctx_a_latest AS
           SELECT c.*
           FROM ctx_a c
           JOIN (
              SELECT instId, MAX(ts) AS ts
              FROM ctx_a
              GROUP BY instId
           ) x ON c.instId=x.instId AND c.ts=x.ts"""
    ]
    exec_many(DB_A, stmts)

# ---------- load universe ----------
def load_universe(limit=20):
    rows = q(DB_U, "SELECT instId FROM universe LIMIT ?", (limit,))
    return [r[0] for r in rows]

# ---------- OHLCV helpers ----------
def last_close(inst, tf):
    rows = q(DB_OA, f"SELECT close, ts FROM ohlcv_{tf} WHERE instId=? ORDER BY ts DESC LIMIT 1", (inst,))
    return (rows[0][0], rows[0][1]) if rows else (None, None)

def load_rows_5m(inst, n=50):
    rows = q(DB_OA, "SELECT volume, close FROM ohlcv_5m WHERE instId=? ORDER BY ts DESC LIMIT ?", (inst, n))
    return rows  # [(vol, close), ...]

# ---------- score_U (unsigned [0..1]) ----------
def compute_score_U(inst):
    rows = load_rows_5m(inst, 50)
    if len(rows) < 10:
        return 0.0
    vols  = [r[0] for r in rows]
    closes= [r[1] for r in rows]
    rets_abs = [abs(closes[i] - closes[i-1]) for i in range(1, len(closes))]

    vol_avg  = sum(vols)/len(vols)
    vola_avg = sum(rets_abs)/len(rets_abs) if rets_abs else 0.0
    if vola_avg <= 0:
        return 0.0
    raw = vol_avg / vola_avg
    # squash in [0..1]
    return 1.0 - math.exp(-raw)

# ---------- score_A & ctx (multi-TF) ----------
WEIGHTS = {"5m": 0.50, "15m": 0.30, "30m": 0.20}

def compute_scoreA_ctx(inst):
    c5,  ts5  = last_close(inst, "5m")
    c15, ts15 = last_close(inst, "15m")
    c30, ts30 = last_close(inst, "30m")
    if None in (c5, c15, c30):
        return (0.0, 1/3, 1/3, "range", None)  # neutral fallback

    # simple directional components
    d5  =  1.0 if c5  > c15 else (-1.0 if c5  < c15 else 0.0)
    d15 =  1.0 if c15 > c30 else (-1.0 if c15 < c30 else 0.0)
    d30 =  1.0 if c30 > c5  else (-1.0 if c30 < c5  else 0.0)  # contrarian anchor to avoid constant +1
    score_raw = WEIGHTS["5m"]*d5 + WEIGHTS["15m"]*d15 + WEIGHTS["30m"]*d30

    # softmax tri-classe: [buy, hold, sell]
    p_buy, p_hold, p_sell = softmax([score_raw, 0.0, -score_raw])
    score_A = p_buy - p_sell
    if score_A > 0.10:
        ctx = "bullish"
    elif score_A < -0.10:
        ctx = "bearish"
    else:
        ctx = "range"

    # use the freshest ts among TFs
    ts = max(ts for ts in (ts5, ts15, ts30) if ts is not None)
    return (score_A, p_buy, p_sell, ctx, ts)

# ---------- insert into ctx_a ----------
def insert_ctx_row(inst, ts, score_U, score_A, p_buy, p_sell, ctx):
    con = sqlite3.connect(DB_A)
    con.execute(
        "INSERT INTO ctx_a(instId, ts, score_U, score_A, p_buy, p_sell, ctx) VALUES (?,?,?,?,?,?,?)",
        (inst, ts, score_U, score_A, p_buy, p_sell, ctx),
    )
    con.commit()
    con.close()

def run():
    ensure_schema()
    insts = load_universe(limit=20)
    if not insts:
        return

    for inst in insts:
        score_U = compute_score_U(inst)
        score_A, p_buy, p_sell, ctx, ts = compute_scoreA_ctx(inst)
        if ts is None:
            # fallback on current time (seconds -> ms align not mandatory for A)
            import time as _t
            ts = int(_t.time())
        insert_ctx_row(inst, ts, score_U, score_A, p_buy, p_sell, ctx)

if __name__ == "__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/X_config.py
Size: 862
MTime: 2025-10-27 10:58:46.599909791 +0100
----- CONTENT -----
#!/usr/bin/env python3

# ==========================
# CONFIG X (PAPER MODE)
# ==========================

# --- Risk Management ---
RISK_PER_TRADE = 0.01     # 1% du capital
MAX_LEVERAGE   = 5        # en PAPER uniquement
COOLDOWN_OPEN  = 60       # en secondes

# --- ATR / SL / TP / Trailing ---
ATR_SL_MULT     = 1.2     # SL = ATR * MULT
ATR_TP_MULT     = 2.0     # TP initial = 2R
ATR_TRAIL_MULT  = 1.0     # trailing = ATR * MULT
RR_BE_TRIGGER   = 1.0     # break-even à 1R

# --- Follow Loop ---
FOLLOW_INTERVAL = 4       # secondes entre 2 updates

# --- DB ---
DB_T       = "/opt/scalp/project/data/t.db"
DB_XOPEN   = "/opt/scalp/project/data/x_open.db"
DB_XFOLLOW = "/opt/scalp/project/data/x_follow.db"
DB_XHIST   = "/opt/scalp/project/data/x_history.db"
DB_SIG     = "/opt/scalp/project/data/signals.db"
DB_A       = "/opt/scalp/project/data/a.db"
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/U_universe.py
Size: 572
MTime: 2025-10-26 07:24:51.520542760 +0100
----- CONTENT -----
import ccxt, sqlite3

DBU = "/opt/scalp/project/data/u.db"
TOP = 20

exchange = ccxt.bitget()
markets = exchange.load_markets()

perps = []
for s,info in markets.items():
    if info.get('swap',False) and info['quote'] == 'USDT':
        inst = s.replace(":USDT","")  # -> BTC/USDT:USDT → BTC/USDT
        perps.append(inst)

perps = perps[:TOP]

con = sqlite3.connect(DBU, timeout=5)
con.execute("DELETE FROM universe;")
for inst in perps:
    con.execute("INSERT OR IGNORE INTO universe(instId) VALUES (?)", (inst,))
con.commit()
con.close()

print("[U] OK :", perps)
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/init_db.py
Size: 1110
MTime: 2025-10-26 07:32:15.285178016 +0100
----- CONTENT -----
import sqlite3

DB_A = "/opt/scalp/project/data/a.db"

def init_db():
    con = sqlite3.connect(DB_A, timeout=5)
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_5m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_15m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ohlcv_30m (
        instId TEXT,
        ts INTEGER,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        vol REAL
    );
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS ctx_a (
        instId TEXT,
        ts INTEGER,
        p_buy REAL,
        p_hold REAL,
        p_sell REAL,
        score REAL,
        ctx TEXT
    );
    """)

    con.commit()
    con.close()
    print("[INIT_DB] OK – A DB ready")

if __name__ == "__main__":
    init_db()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/scripts/A_ctx_dash.py
Size: 1524
MTime: 2025-10-27 19:45:33.204806371 +0100
----- CONTENT -----
#!/usr/bin/env python3
import sqlite3, time

DB_A = "/opt/scalp/project/data/a.db"

def hms(ts):
    if ts > 10_000_000_000: 
        ts = ts/1000
    return time.strftime("%H:%M:%S", time.localtime(ts))

def run():
    con = sqlite3.connect(DB_A)
    rows = con.execute("""
    SELECT instId, ctx, score_A, ts
    FROM ctx_a_latest
    ORDER BY ABS(score_A) DESC, instId
    """).fetchall()
    con.close()

    # remove duplicates by instId (keep first occurrence only)
    seen = set()
    clean_rows = []
    for r in rows:
        if r[0] not in seen:
            seen.add(r[0])
            clean_rows.append(r)

    # categories
    bull  = [r for r in clean_rows if r[1]=="bullish"]
    bear  = [r for r in clean_rows if r[1]=="bearish"]
    rang  = [r for r in clean_rows if r[1]=="range"]
    other = [r for r in clean_rows if r[1] not in ("bullish","bearish","range")]

    total = len(clean_rows)
    ts = clean_rows[0][3] if clean_rows else int(time.time())

    print("===== CTX SUMMARY (A) =====")
    print(f"bullish | {len(bull):<2} | {' '.join([r[0] for r in bull[:5]])} | {hms(ts)}")
    print(f"bearish | {len(bear):<2} | {' '.join([r[0] for r in bear[:5]])} | {hms(ts)}")
    print(f"range   | {len(rang):<2} | {' '.join([r[0] for r in rang[:5]])} | {hms(ts)}")
    print(f"other   | {len(other):<2} | {' '.join([r[0] for r in other[:5]])} | {hms(ts)}")
    print("---------------------------")
    print(f"TOTAL   | {total}")
    print("===========================")

if __name__=="__main__":
    run()
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/config/scalp.conf
Size: 18
MTime: 2025-10-25 17:08:55.549075009 +0200
----- CONTENT -----
UNIVERSE_LIMIT=20
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xopen.sh
Size: 85
MTime: 2025-10-27 06:38:40.982605637 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_close.sh
Size: 102
MTime: 2025-10-27 13:32:48.246660187 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/a_analyse.sh
Size: 88
MTime: 2025-10-26 18:03:22.883271493 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/A_analyse.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/u_universe.sh
Size: 89
MTime: 2025-10-25 17:23:40.450204518 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/U_universe.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv_A.sh
Size: 89
MTime: 2025-10-25 17:23:57.298226222 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_dash.sh
Size: 2086
MTime: 2025-10-25 15:39:57.721793619 +0200
----- CONTENT -----
#!/bin/bash

DB_OPEN="/opt/scalp/project/data/x_open.db"
DB_FOLLOW="/opt/scalp/project/data/x_follow.db"
DB_ACCOUNT="/opt/scalp/project/data/x_account.db"
DB_HISTORY="/opt/scalp/project/data/x_history.db"
DB_SIGNALS="/opt/scalp/project/data/signals.db"

clear
echo "============= SCALP DASH =============  ($(date '+%Y-%m-%d %H:%M:%S'))"
echo

BAL=$(sqlite3 $DB_ACCOUNT "SELECT balance FROM account LIMIT 1;")
TOTAL_PNL=$(sqlite3 $DB_HISTORY "SELECT printf('%.4f', SUM(pnl)) FROM history;")
COUNT=$(sqlite3 $DB_HISTORY "SELECT COUNT(*) FROM history;")
WINS=$(sqlite3 $DB_HISTORY "SELECT COUNT(*) FROM history WHERE pnl > 0;")
WINRATE=$(sqlite3 $DB_HISTORY "SELECT ROUND(100.0 * (SELECT COUNT(*) FROM history WHERE pnl > 0) / CASE WHEN (SELECT COUNT(*) FROM history)=0 THEN 1 ELSE (SELECT COUNT(*) FROM history) END, 1);")

echo "[ACCOUNT]"
echo "Balance : $BAL USDT"
echo "PnL Total : $TOTAL_PNL USDT  | Trades : $COUNT  | Winrate : $WINRATE%"
echo

OPEN=$(sqlite3 $DB_OPEN "SELECT instId, side, qty, entry FROM positions_open LIMIT 1;")

echo "[OPEN POSITION]"
if [ -n "$OPEN" ]; then
    INST=$(echo $OPEN | cut -d'|' -f1)
    SIDE=$(echo $OPEN | cut -d'|' -f2)
    QTY=$(echo $OPEN | cut -d'|' -f3)
    ENTRY=$(echo $OPEN | cut -d'|' -f4)
    LAST=$(sqlite3 $DB_FOLLOW "SELECT last_price FROM follow WHERE instId='$INST' LIMIT 1;")
    echo "$INST | $SIDE | qty $QTY | entry $ENTRY | last $LAST"
else
    echo "No open position"
fi
echo

echo "[SIGNALS]"
echo "BUY  : $(sqlite3 $DB_SIGNALS "SELECT group_concat(instId) FROM signals WHERE side='buy';")"
echo "SELL : $(sqlite3 $DB_SIGNALS "SELECT group_concat(instId) FROM signals WHERE side='sell';")"
echo

echo "[SERVICES]"
for S in scalp-universe scalp-ohlcva.timer scalp-analysea.timer scalp-ohlcvb scalp-ticks scalp-signals scalp-xopen scalp-xfollow scalp-xclose
do
 if [[ "$S" == *".timer" ]]; then
   systemctl is-active --quiet $S && printf "%-20s ⏳ (timer)\n" "$S"
 else
   systemctl is-active --quiet $S && printf "%-20s ✅\n" "$S" || printf "%-20s ❌\n" "$S"
 fi
done

echo
echo "============= END DASH ============="
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_signals.sh
Size: 88
MTime: 2025-10-26 19:01:24.741873511 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/B_signals.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_follow.sh
Size: 103
MTime: 2025-10-27 13:32:41.118652027 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_follow.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/oa_ohlcv.sh
Size: 89
MTime: 2025-10-26 18:03:16.207265495 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OA_ohlcv_A.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/b_dash.sh
Size: 85
MTime: 2025-10-27 06:42:34.110928924 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/b_dash.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/ob_ohlcv_B.sh
Size: 89
MTime: 2025-10-25 13:12:44.107774002 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/OB_ohlcv_B.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/x_open.sh
Size: 101
MTime: 2025-10-27 13:32:31.822641387 +0100
----- CONTENT -----
#!/bin/bash
source /opt/scalp/project/venv/bin/activate
python3 /opt/scalp/project/scripts/X_open.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xclose.sh
Size: 86
MTime: 2025-10-27 06:43:25.474998597 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_close.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/t_ticks.sh
Size: 86
MTime: 2025-10-25 17:24:36.322276510 +0200
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/T_ticks.py
----- FILE END -----

----- FILE BEGIN -----
Path: /opt/scalp/project/bin/xfollow.sh
Size: 87
MTime: 2025-10-27 06:43:14.554983825 +0100
----- CONTENT -----
#!/bin/bash
cd /opt/scalp/project
source venv/bin/activate
python3 scripts/X_follow.py
----- FILE END -----
=== Export /opt/scalp/project/data/a.db
=== Export /opt/scalp/project/data/b.db
=== Export /opt/scalp/project/data/oa.db
=== Export /opt/scalp/project/data/ob.db
=== Export /opt/scalp/project/data/signals.db
=== Export /opt/scalp/project/data/t.db
=== Export /opt/scalp/project/data/ticks.db
=== Export /opt/scalp/project/data/u.db
=== Export /opt/scalp/project/data/x.db
=== Export /opt/scalp/project/data/x_account.db
=== Export /opt/scalp/project/data/x_follow.db
=== Export /opt/scalp/project/data/x_history.db
=== Export /opt/scalp/project/data/x_open.db
