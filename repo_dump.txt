Repository tree:
Scalp/
    Makefile
    PROMPT.md
    README.md
    STRATEGY.md
    bitget_futures_pairs.py
    bot.py
    cli.py
    dump_repo.py
    init.py
    pytest.ini
    quick_order.py
    requirements-dev.txt
    requirements.txt
    short_one_way.py
    signals/
        __init__.py
        generator.py
    backtest/
        __init__.py
        engine.py
        optimize.py
    tests/
        conftest.py
        test_analyse_risque.py
        test_backtest.py
        test_backtest_position.py
        test_bitget_futures_pairs.py
        test_bot_update.py
        test_break_even_stop.py
        test_calc_pnl_pct.py
        test_check_config.py
        test_cli.py
        test_client.py
        test_compute_position_size.py
        test_dynamic_allocation.py
        test_env_loading.py
        test_heat_score.py
        test_indicators.py
        test_notifier.py
        test_pair_selection.py
        test_pairs.py
        test_risk_manager.py
        test_risk_utils.py
        test_slippage.py
        test_strategy_v2.py
        test_telegram_bot.py
        test_utils.py
        test_version.py
        test_walk_forward.py
        test_ws.py
    notebooks/
        spot/
            bitget_bot.py
    result/
    scalp/
        VERSION
        __init__.py
        bitget_client.py
        bot_config.py
        client.py
        logging_utils.py
        metrics.py
        notifier.py
        pairs.py
        strategy.py
        telegram_bot.py
        trade_utils.py
        version.py
        ws.py
        backtest/
            __init__.py
            walkforward.py
        selection/
            __init__.py
            momentum.py
            scanner.py
        risk/
            __init__.py
            manager.py
    logs/
    data/
        __init__.py
        indicators.py
    live/
        __init__.py
        orchestrator.py

## Makefile
.PHONY: test

test:
	pytest


## PROMPT.md
# Prompt de re-cr√©ation du bot Scalp (version spot)

Ce fichier r√©sume les modules et fonctions essentiels afin de recr√©er le bot de trading **spot** Bitget (paires USDT) √† partir de z√©ro. Chaque fonction liste son r√¥le principal et les param√®tres indispensables. Le fichier `.env` contenant les cl√©s API se trouve dans le dossier parent du bot.

## Structure principale

### bot.py
- `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'√©v√©nements.
- `check_config()` : v√©rifie la pr√©sence des cl√©s API Bitget et journalise un avertissement si elles manquent.
- `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
- `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la strat√©gie EMA sur une liste de paires et renvoie les signaux.
- `send_selected_pairs(client, top_n=20, tg_bot=None)` : s√©lectionne et notifie les paires les plus actives.
- `update(client, top_n=20, tg_bot=None)` : rafra√Æchit la liste des paires et renvoie la charge utile envoy√©e.
- `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et ex√©cute la boucle de trading.

### cli.py
- `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation param√©trique (exemple minimal).
- `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : ex√©cute une analyse walk-forward.
- `run_live_pipeline(pairs, tfs)` : ex√©cute la pipeline live asynchrone.
- `create_parser()` : construit l‚Äôanalyseur d‚Äôarguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
- `main(argv=None)` : point d'entr√©e qui d√©clenche la commande choisie.

### init.py
- `install_packages(*args)` : installe des paquets via `pip`.
- `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.

## Modules `scalp`

### bot_config.py
- `CONFIG` : dictionnaire global des param√®tres (cl√©s API, symbole, EMA, ATR, risques, etc.).

### metrics.py
- `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
- `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
- `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
- `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
- `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu‚Äôune position est coh√©rente avec le mouvement des prix.

### strategy.py
- `ema(series, window)` : moyenne mobile exponentielle.
- `vwap(highs, lows, closes, volumes)` : prix moyen pond√©r√© par le volume.
- `obv(closes, volumes)` : s√©rie On Balance Volume.
- `cross(last_fast, last_slow, prev_fast, prev_slow)` : d√©tecte les croisements EMA.
- `order_book_imbalance(bid_vol, ask_vol)` : mesure le d√©s√©quilibre du carnet d'ordres.
- `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
- `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
- `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de strat√©gie sont r√©unies.
- `scan_pairs` et `select_active_pairs` sont re-export√©s pour la s√©lection des paires.

### trade_utils.py
- `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantit√© √† acheter/vendre en fonction du risque et du prix.
- `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseill√©e selon l‚Äôexposition actuelle (sans effet de levier).
- `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met √† jour le stop loss en fonction de l'ATR.
- `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : d√©place le stop loss √† break-even apr√®s un mouvement favorable.
- `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit √™tre renforc√©e.
- `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n‚Äôest constat√©e.
- `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une ex√©cution quasi imm√©diate.

### risk
- `calc_risk_amount(equity, risk_pct)` : montant d'argent risqu√© sur un trade.
- `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
- `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les s√©ries de gains/pertes.
- `RiskManager` : classe g√©rant limites journali√®res, kill switch et ajustement de risque.
  - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.

### notifier.py
- `_pair_name(symbol)` : formatte le nom d‚Äôune paire.
- `_format_text(event, payload=None)` : construit un message lisible.
- `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.

### logging_utils.py
- `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
- `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).

### bitget_client.py
- `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST l√©ger pour le march√© spot.
  - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
  - `_private_request(method, path, params=None, body=None)` : signe et ex√©cute les requ√™tes priv√©es.
  - `get_account()`, `get_open_orders(symbol=None)`.
  - `place_order(symbol, side, quantity, order_type, price=None, reduce_only=False, stop_loss=None, take_profit=None)`.
  - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.

### pairs.py
- `get_trade_pairs(client)` : r√©cup√®re toutes les paires via `get_ticker`.
- `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=20)` : filtre par volume/spread.
- `select_top_pairs(client, top_n=10, key="volume")` : trie par volume ou autre cl√©.
- `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
- `send_selected_pairs(client, top_n=20, select_fn=select_top_pairs, notify_fn=notify)` : d√©duplique USD/USDT/USDC et notifie la liste.
- `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
- `select_top_heat_pairs(pairs, top_n=3)` : s√©lection des paires les plus "chaudes".
- `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corr√©l√©es.

### telegram_bot.py
- `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
  - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
  - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
  - Helpers priv√©s `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
- `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d‚Äôenvironnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont d√©finies.

## Utilisation
1. D√©finir les variables d‚Äôenvironnement (cl√©s Bitget, token Telegram, etc.).
2. Ex√©cuter `init.py` pour installer les d√©pendances.
3. Lancer `bot.py` pour d√©marrer le trading.
4. Utiliser `cli.py` pour les outils d‚Äôoptimisation ou de tests.

Ce r√©sum√© fournit les √©l√©ments n√©cessaires √† la reconstruction du bot et √† la compr√©hension de chaque fonction essentielle.



## README.md
# Scalp

Bot de trading pour les futures USDT-M de Bitget. Ce projet est **exp√©rimental** et fourni √† des fins √©ducatives.

## Installation

Assurez-vous d'avoir Python 3.8 ou sup√©rieur puis installez les d√©pendances :

```bash
pip install -r requirements.txt
```

Pour d√©velopper ou ex√©cuter les tests :

```bash
pip install -r requirements-dev.txt
pytest  # ou make test
```

## Configuration

Le bot lit sa configuration via des variables d'environnement :

- `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : cl√©s API Bitget (laisser les valeurs par d√©faut pour rester en mode papier).
- `PAPER_TRADE` (`true`/`false`) : par d√©faut `true`, n'envoie aucun ordre r√©el.
- `SYMBOL` : symbole du contrat futures (par d√©faut, `BTCUSDT`).
- `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
- `EMA_FAST`, `EMA_SLOW` : p√©riodes des EMA utilis√©es par la strat√©gie.
- `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : param√®tres du filtre de tendance MACD.
- `EMA_TREND_PERIOD` : p√©riode de l'EMA longue utilis√©e comme filtre de tendance g√©n√©ral.
- `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : param√®tres de gestion du risque.
- `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : r√©glages pour l'ATR, l'ajout √† la position, le trailing stop et la sortie par timeout.
- `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` : limites globales (kill switch apr√®s perte ou gain, nombre maximal de positions).
- `LOG_DIR` : dossier o√π seront √©crits les fichiers de log.

- `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les √©v√©nements (optionnel, peut √™tre utilis√© en plus de Telegram).
- `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut √™tre combin√© avec le webhook).

Pour √©viter de versionner vos cl√©s sensibles, vous pouvez cr√©er un fichier
`.env` dans le dossier parent du d√©p√¥t (par exemple `Notebooks/.env` si le
code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement charg√©
au d√©marrage et toutes les variables qu'il contient seront disponibles pour le
bot.


Exemple :

```bash
export BITGET_ACCESS_KEY="votre_cle"
export BITGET_SECRET_KEY="votre_secret"
export PAPER_TRADE=true
python bot.py
```

## Lancement

Apr√®s configuration, lancez simplement :

```bash
python bot.py
```

Le terminal reste silencieux au d√©marrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont √©crits dans `logs/` et affich√©s sur la console. Le bot tourne jusqu'√† `Ctrl+C`. Les ouvertures et fermetures de positions sont consign√©es dans `bot_events.jsonl`.

Lors du d√©marrage, deux notifications Telegram sont √©mises : la premi√®re affiche ¬´‚ÄØBot d√©marr√©‚ÄØ¬ª avec un logo, la seconde ¬´‚ÄØListing :‚ÄØ¬ª suivi des 20 paires s√©lectionn√©es class√©es par couleur (üü¢ < 1‚ÄØmin, üü† < 10‚ÄØmin, üî¥ > 10‚ÄØmin).

Ensuite, un rappel du march√© est envoy√© chaque minute et l'interface Telegram propose un bouton ¬´‚ÄØFermer Bot‚ÄØ¬ª pour arr√™ter proprement l'ex√©cution.


## Strat√©gie

Scalp cherche √† capter de courts mouvements de tendance tout en coupant
rapidement les pertes.

Principes g√©n√©raux¬†:

- s√©lection de paires liquides au fort momentum¬†;
- trade uniquement dans le sens de la tendance dominante (MACD + EMA longue)¬†;
- confirmation multi‚Äëindicateurs (VWAP, volume/OBV, RSI multi‚ÄëUT)¬†;
- stop‚Äëloss et take‚Äëprofit dynamiques bas√©s sur l‚ÄôATR avec taille de position
  calcul√©e selon le risque¬†;
- limites quotidiennes pour prot√©ger le capital.

Les r√®gles d√©taill√©es et l‚Äôalgorithme complet sont d√©crits dans
`STRATEGY.md`.

## Version

La version du bot est stock√©e dans le fichier `scalp/VERSION` et expos√©e dans
le code via la variable `scalp.__version__` :

```python
from scalp import __version__
print(__version__)
```

Pour incr√©menter la version, utilisez `scalp.version.bump_version` avec

`"major"`, `"minor"` ou `"patch"` comme argument. La fonction
`scalp.version.bump_version_from_message` permet √©galement de d√©terminer
automatiquement l'incr√©ment √† appliquer √† partir d'un message de commit
suivant la convention [Conventional Commits](https://www.conventionalcommits.org).

Exemple d'incr√©ment bas√© sur un message :

```python
from scalp.version import bump_version_from_message
bump_version_from_message("feat: add new strategy")
```

Ex√©cut√© en tant que script, `python -m scalp.version` lit le dernier
message de commit `git` et met √† jour le fichier `VERSION` en
cons√©quence.

La m√™me op√©ration peut √™tre d√©clench√©e depuis la ligne de commande via
`cli.py`¬†:

```bash
python cli.py bump-version
```


## Avertissement

¬© 2025 ‚Äî Usage √† vos risques. Ceci n'est pas un conseil financier.


## STRATEGY.md
# Strat√©gie de trading

Ce document d√©crit la logique de trading utilis√©e par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‚ÄëM de Bitget.

## Principes g√©n√©raux

- ne traiter que des actifs liquides √† fort momentum ;
- suivre la tendance dominante et √©viter les march√©s plats ;
- utiliser des confirmations multi‚Äëunit√©s de temps pour limiter les faux signaux ;
- dimensionner chaque position selon un pourcentage fixe du capital ;
- couper rapidement les pertes et laisser courir les gains via un suivi dynamique.

## S√©lection des paires

1. `scan_pairs` r√©cup√®re les tickers Bitget et filtre ceux qui poss√®dent un volume quotidien suffisant et un spread r√©duit.
2. `select_active_pairs` affine la liste en conservant les paires pr√©sentant le plus de **momentum** :
   - croisement entre EMA20 et EMA50 ;
   - ATR √©lev√© pour privil√©gier les actifs volatils.

## G√©n√©ration du signal

`generate_signal` produit un signal d‚Äôentr√©e long ou court lorsque les conditions suivantes sont r√©unies :

- prix au‚Äëdessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherch√©e ;
- **RSI(14)** traversant les niveaux 40/60 avec confirmation d‚Äôun **RSI 15‚ÄØmin** et de la pente de l‚Äô**EMA 1‚ÄØh** ;
- **MACD** align√©e avec la tendance et **EMA** longue en filtrage global ;
- hausse d‚Äô**OBV** ou volume sup√©rieur √† la moyenne ;
- cassure du dernier **swing high/low** ;
- √©ventuel filtre d‚Äô**order book imbalance** et de ratio de ticks.

Les distances de stop et de take profit sont calcul√©es √† partir de l‚Äô**ATR**, ce qui permet √©galement de dimensionner la taille de position via `calc_position_size`.

## Gestion du risque

La classe `RiskManager` applique plusieurs garde‚Äëfous :

- limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) d√©clenchant un *kill switch* ;
- suivi des s√©ries de gains/pertes pour ajuster le pourcentage de risque par trade ;
- pause forc√©e en cas de pertes cons√©cutives prolong√©es ;
- contr√¥le du nombre maximal de positions ouvertes.

Ces r√®gles combin√©es visent √† prot√©ger le capital tout en conservant une exposition opportuniste au march√©.


## backtest/__init__.py
"""Backtesting helpers and optimisation utilities."""

from .optimize import (
    param_space_default,
    eval_params_one,
    run_param_sweep,
    optimize,
)

__all__ = [
    "param_space_default",
    "eval_params_one",
    "run_param_sweep",
    "optimize",
]


## backtest/engine.py
"""Simple backtest engine with dynamic risk and trailing stops.

This module provides a lightweight framework to replay trades while
tracking risk exposure.  The engine supports adaptive risk sizing via
:func:`dynamic_risk_pct` and trailing stop losses through
:func:`apply_trailing`.  A trade log is produced which includes extra
informative fields such as ``score``, ``reasons`` and ``quality``.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Sequence

from scalp.metrics import calc_pnl_pct
from scalp.risk import adjust_risk_pct

__all__ = [
    "dynamic_risk_pct",
    "apply_trailing",
    "BacktestEngine",
    "run_backtest",
]


def dynamic_risk_pct(risk_pct: float, win_streak: int, loss_streak: int) -> float:
    """Return a risk percentage adjusted by recent performance.

    Parameters
    ----------
    risk_pct:
        Current fraction of equity risked per trade.
    win_streak / loss_streak:
        Number of consecutive winning or losing trades.

    Returns
    -------
    float
        The new risk percentage bounded by the constraints defined in
        :func:`scalp.risk.adjust_risk_pct`.
    """

    return adjust_risk_pct(risk_pct, win_streak, loss_streak)


def apply_trailing(
    side: str,
    high: float,
    low: float,
    exit_price: float,
    trail_pct: float,
) -> float:
    """Apply a trailing stop to an exit price.

    The function emulates a basic trailing stop mechanism.  ``high`` and
    ``low`` represent the extreme prices reached while the trade was open.
    ``trail_pct`` is the trailing distance expressed as a fraction (e.g.
    ``0.01`` for 1%).  When the trailing stop is hit before the provided
    ``exit_price`` the returned value reflects the stop level instead of the
    original exit.

    Parameters
    ----------
    side: str
        ``"long"`` or ``"short"``.
    high / low: float
        Highest and lowest prices observed during the trade's lifetime.
    exit_price: float
        Intended exit price without considering trailing stops.
    trail_pct: float
        Trailing distance as a fraction.  ``0`` disables trailing.
    """

    if trail_pct <= 0:
        return exit_price

    side = side.lower()
    if side == "long":
        trail_stop = high * (1 - trail_pct)
        return trail_stop if exit_price > trail_stop else exit_price
    if side == "short":
        trail_stop = low * (1 + trail_pct)
        return trail_stop if exit_price < trail_stop else exit_price
    raise ValueError("side must be 'long' or 'short'")


@dataclass
class BacktestEngine:
    """Iterate over trades applying dynamic risk and trailing stops."""

    risk_pct: float = 0.01
    log: List[Dict[str, Any]] = field(default_factory=list, init=False)
    _win_streak: int = field(default=0, init=False)
    _loss_streak: int = field(default=0, init=False)

    def _process_trade(self, trade: Dict[str, Any]) -> Dict[str, Any]:
        """Process a single trade dictionary.

        The input must at least provide ``entry``, ``exit`` and ``side``.  It
        may also include ``high``, ``low``, ``trail_pct`` and the extra logging
        fields ``score``, ``reasons`` and ``quality``.
        """

        # Dynamically adjust the risk percentage based on performance.
        self.risk_pct = dynamic_risk_pct(self.risk_pct, self._win_streak, self._loss_streak)

        entry = float(trade["entry"])
        exit_price = float(trade["exit"])
        side = int(trade.get("side", 1))

        # Apply optional trailing stop
        exit_price = apply_trailing(
            "long" if side == 1 else "short",
            float(trade.get("high", exit_price)),
            float(trade.get("low", exit_price)),
            exit_price,
            float(trade.get("trail_pct", 0.0)),
        )

        pnl_pct = calc_pnl_pct(entry, exit_price, side, trade.get("fee_rate", 0.0))
        if pnl_pct >= 0:
            self._win_streak += 1
            self._loss_streak = 0
        else:
            self._loss_streak += 1
            self._win_streak = 0

        record = {
            "entry": entry,
            "exit": exit_price,
            "side": side,
            "pnl_pct": pnl_pct,
            "risk_pct": self.risk_pct,
            "score": trade.get("score"),
            "reasons": trade.get("reasons"),
            "quality": trade.get("quality"),
        }
        self.log.append(record)
        return record

    def run(self, trades: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Run the engine on a sequence of trades.

        Parameters
        ----------
        trades:
            Iterable of trade dictionaries.  See :meth:`_process_trade` for the
            expected keys.
        """

        self.log.clear()
        self._win_streak = 0
        self._loss_streak = 0
        for tr in trades:
            self._process_trade(tr)
        return self.log


def run_backtest(
    trades: Sequence[Dict[str, Any]], *, risk_pct: float = 0.01
) -> List[Dict[str, Any]]:
    """Convenience function to execute a backtest in one call."""

    engine = BacktestEngine(risk_pct=risk_pct)
    return engine.run(trades)


## backtest/optimize.py
from __future__ import annotations

"""Parameter sweep utilities for strategy optimisation.

This module performs a grid search over a parameter space in parallel.  It
tries to use :mod:`ray` for distributed execution when available and falls
back to :mod:`multiprocessing` otherwise.
"""

import itertools
import json
import multiprocessing as mp
import os
from typing import Any, Dict, Iterable, List, Sequence

try:  # Optional dependency
    import ray  # type: ignore
except Exception:  # pragma: no cover - ray is optional
    ray = None

from scalp.backtest import backtest_trades


# ---------------------------------------------------------------------------
# Parameter space
# ---------------------------------------------------------------------------

def param_space_default() -> Dict[str, Sequence[Any]]:
    """Return the default parameter search space.

    The keys correspond to strategy parameters while the values are iterables
    of possible settings.  The defaults represent a small but representative
    grid and can be overridden by callers.
    """

    return {
        "ema_fast": [10, 20, 30],
        "ema_slow": [50, 100, 200],
        "rsi_period": [14, 21],
        "atr_period": [14, 21],
    }


def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    """Expand *space* into a list of parameter combinations."""

    keys = list(space)
    values = [space[k] for k in keys]
    return [dict(zip(keys, combo)) for combo in itertools.product(*values)]


# ---------------------------------------------------------------------------
# Evaluation
# ---------------------------------------------------------------------------

def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    """Run a backtest for a single parameter combination.

    ``grid_item`` contains the parameter values along with optional ``trades``
    to evaluate.  The function returns a copy of the parameters augmented with
    the computed PnL under the key ``pnl``.
    """

    params = dict(grid_item)
    trades = params.pop("trades", [])
    fee_rate = params.pop("fee_rate", None)
    pnl = backtest_trades(trades, fee_rate=fee_rate)
    params["pnl"] = pnl
    return params


# ---------------------------------------------------------------------------
# Orchestration
# ---------------------------------------------------------------------------

def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    """Evaluate the full parameter grid in parallel and return results."""

    space = space or param_space_default()
    grid = _param_grid(space)

    # Determine execution backend
    use_ray = False
    if ray is not None:
        try:  # pragma: no cover - depends on ray
            ray.init(ignore_reinit_error=True)
            use_ray = True
        except Exception:
            use_ray = False

    if use_ray:
        remote_eval = ray.remote(eval_params_one)  # type: ignore
        futures = [remote_eval.remote(g) for g in grid]
        results = ray.get(futures)
    else:
        jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
        with mp.Pool(processes=jobs) as pool:
            results = pool.map(eval_params_one, grid)

    return results


def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
    """High level helper executing the sweep and saving aggregated results."""

    results = run_param_sweep(space, jobs=jobs)
    with open(outfile, "w", encoding="utf8") as fh:
        json.dump(results, fh, indent=2, sort_keys=True)
    return results


def main() -> None:  # pragma: no cover - convenience CLI
    optimize()


if __name__ == "__main__":  # pragma: no cover
    main()


## bitget_futures_pairs.py
#!/usr/bin/env python3
"""Fetch the list of Bitget futures contracts.

This helper script queries the public Bitget REST API to retrieve futures
trading pairs for the specified product types and saves them to CSV and JSON
files. It mirrors the standalone example provided by the user but integrates
with the repository's configuration system.

Usage examples::

    python bitget_futures_pairs.py
    python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
    python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
"""
from __future__ import annotations

import argparse
import csv
import json
import sys
import time
from typing import Any, Dict, List

from scalp.bot_config import CONFIG

try:  # pragma: no cover - import guard
    import requests
except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
    sys.stderr.write(
        "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
    )
    raise

BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]


def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
    """Return contract metadata for ``product_type``."""
    url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
    params = {"productType": product_type}
    resp = requests.get(url, params=params, timeout=timeout)
    try:
        data = resp.json()
    except json.JSONDecodeError as exc:  # pragma: no cover - network failure
        raise RuntimeError(
            f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
        ) from exc
    if resp.status_code != 200 or data.get("code") != "00000":
        raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
    return data.get("data", [])


def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Select and rename key fields for CSV/JSON output."""
    rows: List[Dict[str, Any]] = []
    for c in contracts:
        row = {
            "productType": product_type,
            "symbol": c.get("symbol"),
            "baseCoin": c.get("baseCoin"),
            "quoteCoin": c.get("quoteCoin"),
            "symbolType": c.get("symbolType"),
            "symbolStatus": c.get("symbolStatus"),
            "maxLever": c.get("maxLever"),
            "minLever": c.get("minLever"),
            "minTradeNum": c.get("minTradeNum"),
            "sizeMultiplier": c.get("sizeMultiplier"),
            "pricePlace": c.get("pricePlace"),
            "volumePlace": c.get("volumePlace"),
            "launchTime": c.get("launchTime"),
            "deliveryTime": c.get("deliveryTime"),
        }
        rows.append(row)
    return rows


def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
    """Write ``rows`` to ``path`` in CSV format."""
    headers = [
        "productType",
        "symbol",
        "baseCoin",
        "quoteCoin",
        "symbolType",
        "symbolStatus",
        "maxLever",
        "minLever",
        "minTradeNum",
        "sizeMultiplier",
        "pricePlace",
        "volumePlace",
        "launchTime",
        "deliveryTime",
    ]
    with open(path, "w", newline="", encoding="utf-8") as fh:
        writer = csv.DictWriter(fh, fieldnames=headers)
        writer.writeheader()
        if rows:
            writer.writerows(rows)


def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
    )
    parser.add_argument(
        "--types",
        nargs="+",
        default=DEFAULT_PRODUCT_TYPES,
        help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
    )
    parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
    parser.add_argument(
        "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
    )
    parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
    args = parser.parse_args(argv)

    all_rows: List[Dict[str, Any]] = []
    merged_json: Dict[str, List[Dict[str, Any]]] = {}

    for i, pt in enumerate(args.types):
        try:
            contracts = fetch_contracts(pt)
        except Exception as exc:  # pragma: no cover - network/runtime error
            sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
            continue
        rows = normalize_rows(pt, contracts)
        all_rows.extend(rows)
        merged_json[pt] = contracts
        if i < len(args.types) - 1 and args.sleep > 0:
            time.sleep(args.sleep)

    all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))

    write_csv(all_rows, args.out)
    with open(args.json_out, "w", encoding="utf-8") as fh:
        json.dump(merged_json, fh, ensure_ascii=False, indent=2)

    counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
    total = sum(counts.values())
    print(
        f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
    )
    for pt, n in counts.items():
        print(f"  - {pt}: {n} pairs")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI execution
    raise SystemExit(main())


## bot.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Bitget USDT-M futures trading bot."""
import argparse
import logging
import os
import time
from typing import Any, Dict, Optional, List

import requests

from scalp.logging_utils import get_jsonl_logger, TradeLogger
from scalp.metrics import calc_pnl_pct, calc_atr
from scalp.notifier import notify, _format_text
from scalp import __version__, RiskManager
from scalp.telegram_bot import init_telegram_bot

from scalp.bot_config import CONFIG
from scalp.strategy import ema, cross
from scalp.trade_utils import (
    compute_position_size,
    analyse_risque,
    trailing_stop,
    should_scale_in,
    timeout_exit,
)
from scalp import pairs as _pairs
from scalp.backtest import backtest_trades  # noqa: F401
from scalp.bitget_client import BitgetFuturesClient as _BaseBitgetFuturesClient

# ---------------------------------------------------------------------------
# Logging setup
# ---------------------------------------------------------------------------
os.makedirs(CONFIG["LOG_DIR"], exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s.%(msecs)03d %(levelname)s %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[
        logging.FileHandler(os.path.join(CONFIG["LOG_DIR"], "bot.log"), encoding="utf-8"),
        logging.StreamHandler(),
    ],
)


def _noop_event(*_: Any, **__: Any) -> None:
    pass


log_event = _noop_event


def check_config() -> None:
    """Log only missing critical environment variables."""
    critical = {"BITGET_ACCESS_KEY", "BITGET_SECRET_KEY", "BITGET_PASSPHRASE"}
    for key in critical:
        val = os.getenv(key)
        if not val or val in {"", "A_METTRE", "B_METTRE"}:
            logging.warning("%s manquante", key)


class BitgetFuturesClient(_BaseBitgetFuturesClient):
    """Wrapper injecting the ``requests`` module and logger."""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        kwargs.setdefault("requests_module", requests)
        kwargs.setdefault("log_event", log_event)
        super().__init__(*args, **kwargs)


# Re-export pair utilities with ability to monkeypatch ``ema``/``cross`` ---------
get_trade_pairs = _pairs.get_trade_pairs
filter_trade_pairs = _pairs.filter_trade_pairs
select_top_pairs = _pairs.select_top_pairs


def find_trade_positions(
    client: Any,
    pairs: List[Dict[str, Any]],
    *,
    interval: str = "1m",
    ema_fast_n: Optional[int] = None,
    ema_slow_n: Optional[int] = None,
) -> List[Dict[str, Any]]:
    return _pairs.find_trade_positions(
        client,
        pairs,
        interval=interval,
        ema_fast_n=ema_fast_n,
        ema_slow_n=ema_slow_n,
        ema_func=ema,
        cross_func=cross,
    )


def send_selected_pairs(
    client: Any, top_n: int = 20, tg_bot: Any | None = None
) -> Dict[str, str]:
    """Send the selected trading pairs and return the payload."""
    payload = _pairs.send_selected_pairs(
        client,
        top_n=top_n,
        select_fn=filter_trade_pairs,
        notify_fn=notify,
    )
    if tg_bot and payload:
        tg_bot.send(_format_text("pair_list", payload))
    return payload


def update(client: Any, top_n: int = 20, tg_bot: Any | None = None) -> Dict[str, str]:
    """Send a fresh list of pairs to reflect current market conditions."""
    payload = send_selected_pairs(client, top_n=top_n, tg_bot=tg_bot)
    text = _format_text("pair_list", payload)
    logging.info(text)
    return payload


# ---------------------------------------------------------------------------
# Main trading loop
# ---------------------------------------------------------------------------

def main(argv: Optional[List[str]] = None) -> None:
    parser = argparse.ArgumentParser(description="Bitget USDT-M futures trading bot")
    parser.add_argument("--log-json", action="store_true", help="Enable JSON event logs")
    args = parser.parse_args(argv)

    cfg = CONFIG
    global log_event
    if args.log_json:
        log_event = get_jsonl_logger(
            os.path.join(cfg["LOG_DIR"], "bot_events.jsonl"),
            max_bytes=5_000_000,
            backup_count=5,
        )
    check_config()
    client = BitgetFuturesClient(
        access_key=cfg["BITGET_ACCESS_KEY"],
        secret_key=cfg["BITGET_SECRET_KEY"],
        base_url=cfg["BASE_URL"],
        product_type=cfg["PRODUCT_TYPE"],
        recv_window=cfg["RECV_WINDOW"],
        paper_trade=cfg["PAPER_TRADE"],
        passphrase=cfg.get("BITGET_PASSPHRASE"),
    )
    risk_mgr = RiskManager(
        max_daily_loss_pct=cfg["MAX_DAILY_LOSS_PCT"],
        max_daily_profit_pct=cfg["MAX_DAILY_PROFIT_PCT"],
        max_positions=cfg["MAX_POSITIONS"],
        risk_pct=cfg["RISK_PCT_EQUITY"],
    )

    # Ensure a clean state: cancel lingering orders and close leftover positions
    try:
        open_orders = client.get_open_orders(cfg["SYMBOL"])
        if open_orders.get("data"):
            logging.info("Annulation des ordres ouverts au d√©marrage")
            client.cancel_all(cfg["SYMBOL"], margin_coin=cfg["MARGIN_COIN"])
    except Exception as exc:  # pragma: no cover - best effort
        logging.error("Erreur annulation ordres ouverts: %s", exc)
    try:
        positions = client.get_positions(product_type=cfg["PRODUCT_TYPE"])
        if positions.get("data"):
            logging.info("Fermeture des positions ouvertes au d√©marrage")
            client.close_all_positions(product_type=cfg["PRODUCT_TYPE"])
    except Exception as exc:  # pragma: no cover - best effort
        logging.error("Erreur fermeture positions existantes: %s", exc)

    trade_logger = TradeLogger(
        os.path.join(cfg["LOG_DIR"], "trades.csv"),
        os.path.join(cfg["LOG_DIR"], "trades.sqlite"),
    )

    tg_bot = init_telegram_bot(client, cfg, risk_mgr)

    symbol = cfg["SYMBOL"]
    interval = cfg["INTERVAL"]
    ema_fast_n = cfg["EMA_FAST"]
    ema_slow_n = cfg["EMA_SLOW"]
    fee_rate = cfg.get("FEE_RATE", 0.0)

    try:
        contract_detail = client.get_contract_detail(symbol)
    except requests.HTTPError as exc:  # pragma: no cover - network issues
        logging.error("Erreur r\u00e9cup\u00e9ration contract detail: %s", exc)
        contract_detail = {"success": False, "code": 404}
    log_event("contract_detail", contract_detail)

    assets = client.get_assets()
    log_event("assets", assets)
    equity_usdt = 0.0
    try:
        for row in assets.get("data", []):
            if row.get("currency") == "USDT":
                equity_usdt = float(row.get("equity", 0.0))
                break
    except Exception:
        pass
    if equity_usdt <= 0:
        logging.warning(
            "Equity USDT non d√©tect√©e, fallback symbolique √† 100 USDT pour sizing."
        )
        equity_usdt = 100.0

    prev_fast = prev_slow = None
    current_pos = 0
    entry_price = None
    entry_time = None
    stop_long = stop_short = None
    take_profit = None
    session_pnl = 0.0
    last_entry_price = None

    def close_position(side: int, price: float, vol: int) -> bool:
        nonlocal current_pos, entry_price, entry_time, session_pnl, equity_usdt, stop_long, stop_short, take_profit
        pnl = round(calc_pnl_pct(entry_price, price, side, fee_rate), 2)
        payload = {
            "side": "long" if side > 0 else "short",
            "symbol": symbol,
            "entry": entry_price,
            "exit": price,
            "pnl_usd": round((price - entry_price) * vol, 2)
            if side > 0
            else round((entry_price - price) * vol, 2),
            "pnl_pct": pnl,
            "fee_pct": fee_rate * 2 * 100,
        }
        log_event("position_closed", payload)
        session_pnl += pnl
        payload["session_pnl"] = session_pnl
        notify("position_closed", payload)
        client.place_order(
            symbol,
            side=4 if side > 0 else 2,
            vol=vol,
            order_type=5,
            price=price,
            open_type=CONFIG["OPEN_TYPE"],
            leverage=CONFIG["LEVERAGE"],
            reduce_only=True,
        )
        equity_usdt *= 1 + pnl / 100.0
        risk_mgr.record_trade(pnl)
        logging.info("Nouveau risk_pct: %.4f", risk_mgr.risk_pct)
        kill = risk_mgr.kill_switch
        if kill:
            logging.warning("Kill switch activ√©, arr√™t du bot.")
        pause = risk_mgr.pause_duration()
        if pause:
            logging.info("Pause %s s apr√®s s√©rie de pertes", pause)
            time.sleep(pause)
        trade_logger.log(
            {
                "pair": symbol,
                "tf": interval,
                "dir": "long" if side > 0 else "short",
                "entry": entry_price,
                "sl": stop_long if side > 0 else stop_short,
                "tp": take_profit,
                "score": None,
                "reasons": None,
                "pnl": pnl,
            }
        )
        current_pos = 0
        entry_price = None
        entry_time = None
        stop_long = stop_short = None
        take_profit = None
        last_entry_price = None
        time.sleep(0.3)
        return kill

    notify("bot_started")
    try:
        update(client, top_n=20, tg_bot=tg_bot)
    except Exception as exc:  # pragma: no cover - network
        logging.error("Erreur s√©lection paires: %s", exc)
    if tg_bot:
        tg_bot.send_main_menu(0.0)
    next_update = time.time() + 60
    while True:
        if tg_bot:
            try:
                tg_bot.handle_updates(session_pnl)
                if getattr(tg_bot, "stop_requested", False):
                    break
            except Exception as exc:  # pragma: no cover - robustness
                logging.error("Erreur commandes Telegram: %s", exc)

        now = time.time()
        if now >= next_update:
            try:
                update(client, top_n=20, tg_bot=tg_bot)
            except Exception as exc:  # pragma: no cover - network
                logging.error("Erreur update march√©: %s", exc)
            next_update = now + 60

        try:
            if current_pos == 0:
                pairs = filter_trade_pairs(client, top_n=20)
                signals = find_trade_positions(
                    client,
                    pairs,
                    ema_fast_n=ema_fast_n,
                    ema_slow_n=ema_slow_n,
                )
                if signals:
                    next_symbol = signals[0].get("symbol")
                    if next_symbol and next_symbol != symbol:
                        symbol = next_symbol
                        try:
                            contract_detail = client.get_contract_detail(symbol)
                        except requests.HTTPError as exc:  # pragma: no cover - network
                            logging.error(
                                "Erreur r√©cup√©ration contract detail: %s", exc
                            )
                            contract_detail = {"success": False, "code": 404}
                        log_event("contract_detail", contract_detail)
                else:
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
            k = client.get_kline(symbol, interval=interval)
            ok = False
            if k:
                code = k.get("code")
                ok = (k.get("success") is True) or (isinstance(code, str) and code == "00000")
            if not (ok and "data" in k and "close" in k["data"]):
                logging.warning("R√©ponse klines inattendue: %s", k)
                time.sleep(cfg["LOOP_SLEEP_SECS"])
                continue

            data = k["data"]
            closes = data["close"][-cfg["MAX_KLINES"]:]
            highs = data["high"][-cfg["MAX_KLINES"]:]
            lows = data["low"][-cfg["MAX_KLINES"]:]
            min_len = max(ema_fast_n, ema_slow_n, cfg["ATR_PERIOD"]) + 2
            if len(closes) < min_len:
                logging.info("Pas assez d‚Äôhistorique pour EMA/ATR; retry...")
                time.sleep(cfg["LOOP_SLEEP_SECS"])
                continue

            efull = ema(closes, ema_fast_n)
            eslow = ema(closes, ema_slow_n)
            last_fast, prev_fast = efull[-1], efull[-2]
            last_slow, prev_slow = eslow[-1], eslow[-2]
            x = cross(last_fast, last_slow, prev_fast, prev_slow)
            atr = calc_atr(
                highs[-(cfg["ATR_PERIOD"] + 1) :],
                lows[-(cfg["ATR_PERIOD"] + 1) :],
                closes[-(cfg["ATR_PERIOD"] + 1) :],
                period=cfg["ATR_PERIOD"],
            )

            tick = client.get_ticker(symbol)
            if not (tick and tick.get("code") == "00000" and tick.get("data")):
                logging.warning("Ticker vide: %s", tick)
                time.sleep(cfg["LOOP_SLEEP_SECS"])
                continue
            tdata = tick["data"]
            if isinstance(tdata, list):
                price = None
                for row in tdata:
                    if row.get("symbol") == symbol:
                        price_str = row.get("lastPr") or row.get("lastPrice")
                        if price_str is not None:
                            price = float(price_str)
                        break
                if price is None:
                    logging.warning("Prix introuvable pour %s", symbol)
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
            else:
                price_str = tdata.get("lastPr") or tdata.get("lastPrice")
                price = float(price_str)

            vol_close = compute_position_size(
                contract_detail,
                equity_usdt,
                price,
                risk_mgr.risk_pct,
                cfg["LEVERAGE"],
                symbol,
            )
            if vol_close <= 0:
                logging.info("vol calcul√© = 0; on attend.")
                time.sleep(cfg["LOOP_SLEEP_SECS"])
                continue
            sl_long = price * (1.0 - cfg["STOP_LOSS_PCT"])
            tp_long = price * (1.0 + cfg["TAKE_PROFIT_PCT"])
            sl_short = price * (1.0 + cfg["STOP_LOSS_PCT"])
            tp_short = price * (1.0 - cfg["TAKE_PROFIT_PCT"])

            now_ts = time.time()
            if current_pos > 0 and entry_price is not None and stop_long is not None:
                stop_long = trailing_stop(
                    "long",
                    current_price=price,
                    atr=atr,
                    sl=stop_long,
                    mult=cfg["TRAIL_ATR_MULT"],
                )
                if price <= stop_long or timeout_exit(
                    entry_time,
                    now_ts,
                    entry_price,
                    price,
                    "long",
                    progress_min=cfg["PROGRESS_MIN"],
                    timeout_min=cfg["TIMEOUT_MIN"],
                ):
                    if close_position(1, price, vol_close):
                        break
                    continue
            elif current_pos < 0 and entry_price is not None and stop_short is not None:
                stop_short = trailing_stop(
                    "short",
                    current_price=price,
                    atr=atr,
                    sl=stop_short,
                    mult=cfg["TRAIL_ATR_MULT"],
                )
                if price >= stop_short or timeout_exit(
                    entry_time,
                    now_ts,
                    entry_price,
                    price,
                    "short",
                    progress_min=cfg["PROGRESS_MIN"],
                    timeout_min=cfg["TIMEOUT_MIN"],
                ):
                    if close_position(-1, price, vol_close):
                        break
                    continue

            if (
                current_pos > 0
                and entry_price is not None
                and last_entry_price is not None
                and should_scale_in(
                    entry_price,
                    price,
                    last_entry_price,
                    atr,
                    "long",
                    distance_mult=cfg["SCALE_IN_ATR_MULT"],
                )
            ):
                positions = client.get_positions(product_type=cfg["PRODUCT_TYPE"]).get("data", [])
                if risk_mgr.can_open(len(positions)):
                    vol_add = compute_position_size(
                        contract_detail,
                        equity_usdt,
                        price,
                        risk_mgr.risk_pct,
                        cfg["LEVERAGE"],
                        symbol,
                    )
                    if vol_add > 0:
                        resp = client.place_order(
                            symbol,
                            side=1,
                            vol=vol_add,
                            order_type=5,
                            price=price,
                            open_type=CONFIG["OPEN_TYPE"],
                            leverage=cfg["LEVERAGE"],
                        )
                        log_event("scale_in_long", resp)
                        last_entry_price = price
            elif (
                current_pos < 0
                and entry_price is not None
                and last_entry_price is not None
                and should_scale_in(
                    entry_price,
                    price,
                    last_entry_price,
                    atr,
                    "short",
                    distance_mult=cfg["SCALE_IN_ATR_MULT"],
                )
            ):
                positions = client.get_positions(product_type=cfg["PRODUCT_TYPE"]).get("data", [])
                if risk_mgr.can_open(len(positions)):
                    vol_add = compute_position_size(
                        contract_detail,
                        equity_usdt,
                        price,
                        risk_mgr.risk_pct,
                        cfg["LEVERAGE"],
                        symbol,
                    )
                    if vol_add > 0:
                        resp = client.place_order(
                            symbol,
                            side=3,
                            vol=vol_add,
                            order_type=5,
                            price=price,
                            open_type=CONFIG["OPEN_TYPE"],
                            leverage=cfg["LEVERAGE"],
                        )
                        log_event("scale_in_short", resp)
                        last_entry_price = price

            log_event(
                "signal",
                {
                    "fast": last_fast,
                    "slow": last_slow,
                    "cross": x,
                    "price": price,
                    "pos": current_pos,
                    "vol": vol_close,
                },
            )

            if x == +1 and current_pos <= 0:
                if current_pos < 0 and entry_price is not None:
                    if close_position(-1, price, vol_close):
                        break

                positions = client.get_positions(product_type=cfg["PRODUCT_TYPE"]).get("data", [])
                if not risk_mgr.can_open(len(positions)):
                    logging.info("RiskManager: limites atteintes, on attend.")
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
                vol_open, lev = analyse_risque(
                    contract_detail,
                    positions,
                    equity_usdt,
                    price,
                    risk_mgr.risk_pct,
                    cfg["LEVERAGE"],
                    symbol,
                    side="long",
                    risk_level=cfg.get("RISK_LEVEL", 2),
                )
                if vol_open <= 0:
                    logging.info("vol calcul√© = 0; on attend.")
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
                resp = client.place_order(
                    symbol,
                    side=1,
                    vol=vol_open,
                    order_type=5,
                    price=price,
                    open_type=CONFIG["OPEN_TYPE"],
                    leverage=lev,
                    stop_loss=sl_long,
                    take_profit=tp_long,
                )
                log_event("order_long", resp)
                logging.info(
                    "‚Üí LONG vol=%s @~%.2f (SL~%.2f / TP~%.2f) [%s]",
                    vol_open,
                    price,
                    sl_long,
                    tp_long,
                    "paper" if CONFIG["PAPER_TRADE"] else "live",
                )
                open_payload = {
                    "side": "long",
                    "symbol": symbol,
                    "price": price,
                    "vol": vol_open,
                    "leverage": CONFIG["LEVERAGE"],
                    "sl_usd": round((price - sl_long) * vol_open, 2),
                    "tp_usd": round((tp_long - price) * vol_open, 2),
                    "fee_rate": fee_rate,
                    "session_pnl": session_pnl,
                }
                log_event("position_opened", open_payload)
                notify("position_opened", open_payload)
                current_pos = +1
                entry_price = price
                entry_time = now_ts
                stop_long = sl_long
                stop_short = None
                take_profit = tp_long
                last_entry_price = entry_price

            elif x == -1 and current_pos >= 0:
                if current_pos > 0 and entry_price is not None:
                    if close_position(1, price, vol_close):
                        break

                positions = client.get_positions(product_type=cfg["PRODUCT_TYPE"]).get("data", [])
                if not risk_mgr.can_open(len(positions)):
                    logging.info("RiskManager: limites atteintes, on attend.")
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
                vol_open, lev = analyse_risque(
                    contract_detail,
                    positions,
                    equity_usdt,
                    price,
                    risk_mgr.risk_pct,
                    cfg["LEVERAGE"],
                    symbol,
                    side="short",
                    risk_level=cfg.get("RISK_LEVEL", 2),
                )
                if vol_open <= 0:
                    logging.info("vol calcul√© = 0; on attend.")
                    time.sleep(cfg["LOOP_SLEEP_SECS"])
                    continue
                resp = client.place_order(
                    symbol,
                    side=3,
                    vol=vol_open,
                    order_type=5,
                    price=price,
                    open_type=CONFIG["OPEN_TYPE"],
                    leverage=lev,
                    stop_loss=sl_short,
                    take_profit=tp_short,
                )
                log_event("order_short", resp)
                logging.info(
                    "‚Üí SHORT vol=%s @~%.2f (SL~%.2f / TP~%.2f) [%s]",
                    vol_open,
                    price,
                    sl_short,
                    tp_short,
                    "paper" if CONFIG["PAPER_TRADE"] else "live",
                )
                open_payload = {
                    "side": "short",
                    "symbol": symbol,
                    "price": price,
                    "vol": vol_open,
                    "leverage": CONFIG["LEVERAGE"],
                    "sl_usd": round((sl_short - price) * vol_open, 2),
                    "tp_usd": round((price - tp_short) * vol_open, 2),
                    "fee_rate": fee_rate,
                    "session_pnl": session_pnl,
                }
                log_event("position_opened", open_payload)
                notify("position_opened", open_payload)
                current_pos = -1
                entry_price = price
                entry_time = now_ts
                stop_short = sl_short
                stop_long = None
                take_profit = tp_short
                last_entry_price = entry_price

            time.sleep(cfg["LOOP_SLEEP_SECS"])

        except KeyboardInterrupt:
            logging.info("Arr√™t manuel.")
            break
        except Exception as e:  # pragma: no cover - safeguard
            logging.exception("Erreur boucle principale: %s", str(e))
            time.sleep(3)
    notify("bot_stopped", {"session_pnl": session_pnl})


if __name__ == "__main__":  # pragma: no cover - manual run
    try:
        main()
    except requests.HTTPError as exc:  # pragma: no cover - network issues
        logging.error("Erreur HTTP principale: %s", exc)


## cli.py
"""Command line utilities for the Scalp project.

This module exposes a small command line interface used throughout the
project.  The actual trading logic lives in other modules, however the CLI is
responsible for parsing parameters and dispatching the appropriate routines.

The implementation intentionally keeps the invoked functions minimal so that
tests can patch them easily.  In a real deployment these functions would
perform optimisation, walk‚Äëforward analysis or run the live pipeline.
"""

from __future__ import annotations

import argparse
import asyncio
from typing import Iterable, List

from scalp.version import bump_version_from_git


# ---------------------------------------------------------------------------
# Placeholder implementations
# ---------------------------------------------------------------------------


def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    """Run a parallel parameter optimisation.

    The real project dispatches a potentially heavy optimisation routine.  The
    function is kept trivial so unit tests can verify that the CLI wiring works
    without actually performing the optimisation.
    """

    print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")


def run_walkforward_analysis(
    pair: str, timeframe: str, splits: int, train_ratio: float
) -> None:
    """Execute a walk-forward analysis."""

    print(
        f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    )


async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    """Run the live trading pipeline."""

    print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")


# ---------------------------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------------------------


def create_parser() -> argparse.ArgumentParser:
    """Create the top-level argument parser."""

    parser = argparse.ArgumentParser(description="Scalp command line tools")
    sub = parser.add_subparsers(dest="command")

    # --- ``opt`` command -------------------------------------------------
    opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    opt_p.add_argument("--tf", required=True, help="timeframe")
    opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    opt_p.set_defaults(
        func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    )

    # --- ``walkforward`` command ----------------------------------------
    wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    wf_p.add_argument("--pair", required=True, help="trading pair")
    wf_p.add_argument("--tf", required=True, help="timeframe")
    wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    wf_p.add_argument(
        "--train-ratio",
        type=float,
        default=0.7,
        help="portion of data used for training",
    )
    wf_p.set_defaults(
        func=lambda a: run_walkforward_analysis(
            a.pair, a.tf, a.splits, a.train_ratio
        )
    )

    # --- ``live`` command -----------------------------------------------
    live_p = sub.add_parser("live", help="run the live async pipeline")
    live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))

    # --- ``bump-version`` command -------------------------------------
    bv_p = sub.add_parser(
        "bump-version",
        help="update the VERSION file based on the latest git commit",
    )
    bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))

    return parser


def main(argv: Iterable[str] | None = None) -> int:
    """Entry point used by tests and ``if __name__ == '__main__'`` block."""

    parser = create_parser()
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return 0
    result = args.func(args)
    return 0 if result is None else int(result)


if __name__ == "__main__":  # pragma: no cover - manual invocation
    raise SystemExit(main())



## data/__init__.py
"""Indicator computation helpers."""

from .indicators import compute_all

__all__ = ["compute_all"]


## data/indicators.py
import pandas as pd

__all__ = ["compute_all"]

def compute_all(
    df: pd.DataFrame,
    *,
    ema_fast: int = 20,
    ema_slow: int = 50,
    rsi_period: int = 14,
    macd_fast: int = 12,
    macd_slow: int = 26,
    macd_signal: int = 9,
    atr_period: int = 14,
    swing_lookback: int = 5,
) -> pd.DataFrame:
    """Compute common indicators and return enriched DataFrame.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
        ``volume`` columns ordered chronologically.

    Returns
    -------
    pd.DataFrame
        New DataFrame with additional indicator columns.
    """

    if df.empty:
        return df.copy()

    df = df.copy()

    # --- VWAP ---------------------------------------------------------------
    typical = (df["high"] + df["low"] + df["close"]) / 3.0
    vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
    df["vwap"] = vwap

    # --- EMAs ---------------------------------------------------------------
    df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
    df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()

    # --- RSI ----------------------------------------------------------------
    delta = df["close"].diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(rsi_period).mean()
    avg_loss = loss.rolling(rsi_period).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    df["rsi"] = rsi.fillna(50.0)

    # --- MACD ---------------------------------------------------------------
    ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
    ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
    macd = ema_fast_series - ema_slow_series
    signal = macd.ewm(span=macd_signal, adjust=False).mean()
    df["macd"] = macd
    df["macd_signal"] = signal
    df["macd_hist"] = macd - signal

    # --- OBV ----------------------------------------------------------------
    obv = [0.0]
    closes = df["close"].tolist()
    vols = df["volume"].tolist()
    for i in range(1, len(df)):
        if closes[i] > closes[i - 1]:
            obv.append(obv[-1] + vols[i])
        elif closes[i] < closes[i - 1]:
            obv.append(obv[-1] - vols[i])
        else:
            obv.append(obv[-1])
    df["obv"] = obv

    # --- ATR ----------------------------------------------------------------
    high_low = df["high"] - df["low"]
    high_close = (df["high"] - df["close"].shift()).abs()
    low_close = (df["low"] - df["close"].shift()).abs()
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = tr.rolling(atr_period).mean()

    # --- Swing highs/lows ---------------------------------------------------
    df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
    df["swing_low"] = df["low"].rolling(window=swing_lookback).min()

    return df


## dump_repo.py
import os
from pathlib import Path

IGNORE_EXTENSIONS = {'.log', '.pyc'}
IGNORE_DIRS = {'__pycache__'}


def _is_ignored(path: Path) -> bool:
    """Return True if the path should be ignored."""
    if any(part.startswith('.') for part in path.parts):
        return True
    if path.suffix in IGNORE_EXTENSIONS:
        return True
    if any(part in IGNORE_DIRS for part in path.parts):
        return True
    return False


def _build_tree(root: Path, ignore_path: Path) -> str:
    lines = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirpath = Path(dirpath)
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
        depth = len(dirpath.relative_to(root).parts)
        indent = '    ' * depth
        lines.append(f"{indent}{dirpath.name}/")
        for fname in sorted(filenames):
            fpath = dirpath / fname
            if fpath == ignore_path or _is_ignored(fpath):
                continue
            lines.append(f"{indent}    {fname}")
    return '\n'.join(lines)


def _iter_files(root: Path):
    for path in sorted(root.rglob('*')):
        if path.is_file() and not _is_ignored(path):
            yield path


def create_dump_file(output_path: str = 'repo_dump.txt', root: str = '.') -> None:
    """Create a text dump of the repository tree and file contents."""
    root_path = Path(root).resolve()
    output_path = root_path / output_path
    with output_path.open('w', encoding='utf-8') as dump:
        dump.write('Repository tree:\n')
        dump.write(_build_tree(root_path, output_path))
        dump.write('\n\n')
        for file_path in _iter_files(root_path):
            rel_path = file_path.relative_to(root_path)
            if file_path == output_path:
                continue
            dump.write(f"## {rel_path}\n")
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    dump.write(f.read())
            except Exception:
                dump.write('[unreadable file]\n')
            dump.write('\n\n')


if __name__ == '__main__':
    create_dump_file()


## init.py
#!/usr/bin/env python3
"""Install all project dependencies.

Run this script once to install every ``requirements*.txt`` file found in the
repository as well as the packages needed for the test suite.  All subsequent
invocations of the bot or its submodules will then share the same Python
environment with the required dependencies available.
"""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path


def install_packages(*args: str) -> None:
    """Install packages using pip for the current Python interpreter."""
    cmd = [sys.executable, "-m", "pip", "install", *args]
    subprocess.check_call(cmd)


def main() -> None:
    repo_root = Path(__file__).resolve().parent

    # Install from any requirements*.txt file across the repository so that
    # sub-packages with their own dependency lists are also covered.
    for req in sorted(repo_root.rglob("requirements*.txt")):
        install_packages("-r", str(req))

    # Ensure test dependencies are available
    install_packages("pytest")


if __name__ == "__main__":
    main()


## live/__init__.py
"""Live trading helpers."""

from .orchestrator import compute_for_pair_tf, pipeline

__all__ = ["compute_for_pair_tf", "pipeline"]


## live/orchestrator.py
import asyncio
from typing import Any, Callable, Dict, Iterable, Optional, Tuple


async def _maybe_await(func: Callable, *args: Any, **kwargs: Any) -> Any:
    """Run *func* which may be sync or async and return its result."""
    result = func(*args, **kwargs)
    if asyncio.iscoroutine(result) or isinstance(result, asyncio.Future):
        return await result
    return result


async def compute_for_pair_tf(
    pair: str,
    tf: str,
    cfg: Dict[str, Any],
    semaphore: Optional[asyncio.Semaphore] = None,
) -> Tuple[str, str, Any]:
    """Fetch data and generate a trading signal for ``pair``/``tf``.

    ``cfg`` must provide at least ``fetch_ohlcv`` and ``generate_signal`` callables.
    ``compute_indicators`` is optional.  Functions may be synchronous or
    asynchronous.  The return value is a tuple ``(pair, tf, signal)`` where
    ``signal`` is the output of ``generate_signal``.
    """

    fetch_ohlcv = cfg.get("fetch_ohlcv")
    if fetch_ohlcv is None:
        raise ValueError("fetch_ohlcv callable missing from cfg")

    compute_indic = cfg.get("compute_indicators")
    gen_signal = cfg.get("generate_signal")
    if gen_signal is None:
        raise ValueError("generate_signal callable missing from cfg")

    if semaphore is not None:
        async with semaphore:
            ohlcv = await _maybe_await(fetch_ohlcv, pair, tf, cfg)
    else:
        ohlcv = await _maybe_await(fetch_ohlcv, pair, tf, cfg)

    indics = (
        await _maybe_await(compute_indic, pair, tf, ohlcv, cfg)
        if compute_indic
        else None
    )

    signal = await _maybe_await(gen_signal, pair, tf, ohlcv, indics, cfg)
    return pair, tf, signal


async def pipeline(
    pairs: Iterable[str],
    tfs: Iterable[str],
    cfg: Dict[str, Any],
) -> Dict[str, Dict[str, Any]]:
    """Orchestrate computation of signals for all ``pairs`` and ``tfs``.

    ``cfg`` may specify ``max_connections`` to limit concurrent HTTP requests.
    Results are returned as ``{pair: {tf: signal}}``.
    """

    max_conn = cfg.get("max_connections")
    semaphore: Optional[asyncio.Semaphore] = None
    if max_conn is not None:
        semaphore = asyncio.Semaphore(int(max_conn))

    tasks = [
        compute_for_pair_tf(pair, tf, cfg, semaphore)
        for pair in pairs
        for tf in tfs
    ]

    results = await asyncio.gather(*tasks)
    out: Dict[str, Dict[str, Any]] = {}
    for pair, tf, sig in results:
        out.setdefault(pair, {})[tf] = sig
    return out


__all__ = ["compute_for_pair_tf", "pipeline"]


## notebooks/spot/bitget_bot.py
import os
import time
import hmac
import hashlib
import base64
import logging
from argparse import ArgumentParser
from pathlib import Path
from typing import Any, Dict, List
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv

BASE_URL = "https://api.bitget.com"
RECV_WINDOW = 5000


def load_keys() -> Dict[str, str]:
    parent = Path(__file__).resolve().parent.parent
    load_dotenv(parent / ".env")
    api_key = os.getenv("BITGET_API_KEY")
    api_secret = os.getenv("BITGET_API_SECRET")
    if not api_key or not api_secret:
        raise RuntimeError("API keys not found in environment")
    return {"key": api_key, "secret": api_secret}


class BitgetClient:
    def __init__(self) -> None:
        creds = load_keys()
        self.api_key = creds["key"]
        self.api_secret = creds["secret"]
        self.session = requests.Session()
        self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
        self.time_offset = self._compute_time_offset()

    def _compute_time_offset(self) -> int:
        server = self.server_time()
        return int(server["serverTime"]) - int(time.time() * 1000)

    def _timestamp(self) -> int:
        return int(time.time() * 1000) + self.time_offset

    def _request(
        self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
    ) -> Any:
        params = params or {}
        if signed:
            params["timestamp"] = self._timestamp()
            params["recvWindow"] = RECV_WINDOW
            query = urlencode(params)
            signature = base64.b64encode(
                hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
            ).decode()
            query += f"&signature={signature}"
            headers = {"X-BITGET-APIKEY": self.api_key}
            if method.upper() == "GET":
                url = f"{BASE_URL}{path}?{query}"
                resp = self.session.get(url, headers=headers)
            else:
                url = f"{BASE_URL}{path}"
                headers["Content-Type"] = "application/x-www-form-urlencoded"
                resp = self.session.post(url, data=query, headers=headers)
        else:
            url = f"{BASE_URL}{path}"
            resp = self.session.request(method, url, params=params)

        resp.raise_for_status()
        if resp.text:
            return resp.json()
        return {}

    # Helpers
    def server_time(self) -> Any:
        return self._request("GET", "/api/v3/time")

    def ticker_price(self, symbol: str) -> Any:
        return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})

    def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
        return self._request(
            "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
        )

    def test_order(self, **params: Any) -> Any:
        return self._request("POST", "/api/v3/order/test", params, signed=True)

    def place_order(self, **params: Any) -> Any:
        return self._request("POST", "/api/v3/order", params, signed=True)

    def account_info(self) -> Any:
        return self._request("GET", "/api/v3/account", signed=True)

    def book_ticker(self, symbol: str) -> Any:
        return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})


def sma(values: List[float], period: int) -> float:
    if len(values) < period:
        raise ValueError("Not enough data for SMA")
    return sum(values[-period:]) / period


def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
    kl = client.klines(symbol, limit=50)
    closes = [float(k[4]) for k in kl]
    sma9_prev = sma(closes[:-1], 9)
    sma21_prev = sma(closes[:-1], 21)
    sma9_curr = sma(closes, 9)
    sma21_curr = sma(closes, 21)

    cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
    cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr

    log = logging.getLogger("bitget_bot")

    if cross_up:
        book = client.book_ticker(symbol)
        ask = float(book["askPrice"])
        qty = quote_usdt / ask
        params = {
            "symbol": symbol,
            "side": "BUY",
            "type": "LIMIT",
            "timeInForce": "IOC",
            "quantity": f"{qty:.6f}",
            "price": book["askPrice"],
        }
        log.info("BUY signal %s", params)
        resp = client.test_order(**params) if dry_run else client.place_order(**params)
        log.info("response %s", resp)
    elif cross_down:
        account = client.account_info()
        base = symbol.rstrip("USDT")
        bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
        qty = float(bal["free"])
        if qty > 0:
            book = client.book_ticker(symbol)
            params = {
                "symbol": symbol,
                "side": "SELL",
                "type": "LIMIT",
                "timeInForce": "IOC",
                "quantity": f"{qty:.6f}",
                "price": book["bidPrice"],
            }
            log.info("SELL signal %s", params)
            resp = client.test_order(**params) if dry_run else client.place_order(**params)
            log.info("response %s", resp)
        else:
            log.info("No balance to sell")


def interval_seconds(interval: str) -> int:
    unit = interval[-1]
    qty = int(interval[:-1])
    if unit == "m":
        return qty * 60
    if unit == "h":
        return qty * 3600
    if unit == "d":
        return qty * 86400
    return 60


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    parser = ArgumentParser(description="Bitget SMA crossover bot")
    parser.add_argument("--symbol", default="BTCUSDT")
    parser.add_argument("--quote-usdt", type=float, default=10.0)
    parser.add_argument("--interval", default="1m")
    parser.add_argument("--loop", action="store_true")
    parser.add_argument("--dry-run", dest="dry_run", action="store_true")
    parser.add_argument("--live", dest="dry_run", action="store_false")
    parser.set_defaults(dry_run=True)
    args = parser.parse_args()

    client = BitgetClient()
    delay = interval_seconds(args.interval)

    while True:
        try:
            analyze(client, args.symbol, args.quote_usdt, args.dry_run)
        except Exception as exc:
            logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
        if not args.loop:
            break
        time.sleep(delay)


if __name__ == "__main__":
    main()


## pytest.ini
[pytest]
addopts = -q


## quick_order.py
#!/usr/bin/env python3
"""Submit a simple market order on Bitget futures.

This helper reads API credentials and trade parameters from environment
variables (optionally loaded from a `.env` file) and places a one-way
market order.  Only the essential steps from the user's reference script
are kept to minimise latency and redundant code.

Environment variables:
    BITGET_API_KEY / BITGET_ACCESS_KEY
    BITGET_API_SECRET / BITGET_SECRET_KEY
    BITGET_API_PASSPHRASE
    BITGET_BASE_URL (default https://api.bitget.com)
    BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
    BITGET_MARGIN_COIN (default ``USDT``)
    BITGET_SYMBOL (e.g. ``BTCUSDT``)
    BITGET_TEST_NOTIONAL_USDT (default ``5``)

Usage:
    python quick_order.py buy
    python quick_order.py sell
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

from dotenv import load_dotenv

from scalp.bitget_client import BitgetFuturesClient

# Load variables from `.env` if present
load_dotenv(Path(__file__).resolve().parent / ".env")

side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
if side not in {"buy", "sell"}:
    raise SystemExit("Usage: quick_order.py [buy|sell]")

base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))

if not (ak and sk and ph):
    raise SystemExit("‚ùå BITGET_API_KEY/SECRET/PASSPHRASE manquants")

client = BitgetFuturesClient(
    access_key=ak,
    secret_key=sk,
    base_url=base,
    passphrase=ph,
    paper_trade=False,
)

tick = client.get_ticker(symbol)
price = None
try:
    data = tick.get("data")
    if isinstance(data, list) and data:
        price_str = data[0].get("lastPr") or data[0].get("lastPrice")
        if price_str is not None:
            price = float(price_str)
    elif isinstance(data, dict):
        price_str = data.get("lastPr") or data.get("lastPrice")
        if price_str is not None:
            price = float(price_str)
except Exception:
    pass
if price is None or price <= 0:
    raise SystemExit("Prix introuvable pour le ticker")

size = round(notional / price, 6)
client.set_position_mode_one_way(symbol, product_type)
client.set_leverage(symbol, product_type, margin_coin, leverage=2)
resp = client.place_market_order_one_way(
    symbol, side, size, product_type, margin_coin
)
print(resp)


## requirements-dev.txt
pytest


## requirements.txt
requests
python-dotenv


## scalp/VERSION
0.3.0



## scalp/__init__.py
"""Utilities and helpers for Scalp bot.

When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
keys to live in ``notebook/.env``.  On import this module attempts to load the
variables from that file so that API keys can remain outside of the repository
yet still be available at runtime.
"""

from __future__ import annotations

import os
from pathlib import Path
import sys


def _load_parent_env() -> None:
    """Load environment variables from ``../.env`` relative to the entry script.

    The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
    are expected to be stored one directory above (``notebook/.env``).  If that
    file is not found the function falls back to the historical behaviour of
    checking ``../.env`` relative to the package itself.
    """

    script_path = Path(sys.argv[0]).resolve()
    env_file = script_path.parent.parent / ".env"
    if not env_file.exists():
        env_file = Path(__file__).resolve().parents[2] / ".env"
        if not env_file.exists():
            return

    try:
        from dotenv import load_dotenv

        load_dotenv(env_file)
    except Exception:  # pragma: no cover - optional dependency
        for line in env_file.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            os.environ.setdefault(key.strip(), value.strip().strip("'\""))


_load_parent_env()

from .version import get_version, bump_version_from_message  # noqa: E402
from .strategy import (  # noqa: E402
    Signal,
    scan_pairs,
    select_active_pairs,
    generate_signal,
    backtest,
)
from .risk.manager import RiskManager  # noqa: E402

__all__ = [
    "get_version",
    "bump_version_from_message",
    "__version__",
    "Signal",
    "scan_pairs",
    "select_active_pairs",
    "generate_signal",
    "RiskManager",
    "backtest",
]

__version__ = get_version()


## scalp/backtest/__init__.py
"""Simple backtesting helpers."""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from scalp.bot_config import CONFIG
from scalp.metrics import calc_pnl_pct
from .walkforward import walk_forward

__all__ = ["backtest_trades", "walk_forward_windows", "walk_forward"]


def backtest_trades(
    trades: List[Dict[str, Any]],
    *,
    fee_rate: Optional[float] = None,
    logger: Any | None = None,
) -> float:
    """Compute cumulative PnL for a series of trades.

    If ``logger`` is provided it must expose a ``log(dict)`` method and each
    trade will be recorded with the computed PnL.
    """
    fee_rate = fee_rate if fee_rate is not None else CONFIG.get("FEE_RATE", 0.0)

    pnl = 0.0
    for tr in trades:
        symbol = tr.get("symbol")
        entry = tr.get("entry")
        exit_ = tr.get("exit")
        side = tr.get("side", 1)
        if None in (symbol, entry, exit_):
            continue
        pnl_trade = calc_pnl_pct(entry, exit_, side, fee_rate)
        if logger is not None:
            logger.log(
                {
                    "pair": symbol,
                    "tf": tr.get("tf"),
                    "dir": "long" if side > 0 else "short",
                    "entry": entry,
                    "sl": tr.get("sl"),
                    "tp": tr.get("tp"),
                    "score": tr.get("score"),
                    "reasons": tr.get("reasons"),
                    "pnl": pnl_trade,
                }
            )
        pnl += pnl_trade
    return pnl


def walk_forward_windows(series: List[Any], train: int, test: int):
    """Yield sequential ``(train, test)`` windows for walk-forward analysis.

    Parameters
    ----------
    series:
        Ordered data sequence.  The function simply slices the input and does
        not inspect the values.
    train, test:
        Number of elements for the training and testing windows respectively.
    """

    end = len(series) - train - test + 1
    step = test if test > 0 else 1
    for start in range(0, max(0, end), step):
        train_slice = series[start : start + train]
        test_slice = series[start + train : start + train + test]
        if len(test_slice) < test or len(train_slice) < train:
            break
        yield train_slice, test_slice


## scalp/backtest/walkforward.py
from __future__ import annotations

from itertools import product
from statistics import mean, stdev
from typing import Dict, Iterable, Optional

from ..strategy import max_drawdown


def _sharpe(returns: Iterable[float]) -> float:
    vals = list(returns)
    if not vals:
        return 0.0
    mu = mean(vals)
    if len(vals) > 1:
        sd = stdev(vals)
    else:
        sd = 0.0
    return mu / sd if sd > 0 else 0.0


def _stability(equity: Iterable[float]) -> float:
    curve = list(equity)
    n = len(curve)
    if n < 2:
        return 0.0
    x = list(range(n))
    x_mean = sum(x) / n
    y_mean = sum(curve) / n
    ss_tot = sum((y - y_mean) ** 2 for y in curve)
    denom = sum((xi - x_mean) ** 2 for xi in x)
    if denom == 0 or ss_tot == 0:
        return 0.0
    b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    a = y_mean - b * x_mean
    ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    return 1 - ss_res / ss_tot


def walk_forward(
    df,
    splits: int = 5,
    train_ratio: float = 0.7,
    params: Optional[Dict[str, Iterable]] = None,
) -> Dict[str, float]:
    """Perform walk-forward optimisation and evaluation.

    Parameters
    ----------
    df:
        DataFrame containing per-period percentage returns. The first column is
        used when a dedicated ``"returns"`` column is not found.
    splits:
        Number of walk-forward test windows.
    train_ratio:
        Proportion of the data used for training in the initial window.
    params:
        Optional parameter grid. If provided, columns in ``df`` matching each
        parameter combination are evaluated and the best Sharpe ratio on the
        training window is selected. When ``None``, the first column is used.
    """

    if df.empty:
        return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}

    returns_col = "returns" if "returns" in df.columns else df.columns[0]
    data = df.copy()

    n = len(data)
    train_len = max(1, int(n * train_ratio))
    test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)

    sharpe_list = []
    mdd_list = []
    pnl_list = []
    stability_list = []

    from . import walk_forward_windows

    indices = list(range(n))

    for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
        train_df = data.iloc[tr_idx]
        test_df = data.iloc[te_idx]

        # Parameter optimisation based on Sharpe ratio
        if params:
            best_col = None
            best_score = float("-inf")
            keys, values = zip(*params.items()) if params else ([], [])
            for combo in product(*values):
                col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
                if col_name not in data.columns:
                    continue
                score = _sharpe(train_df[col_name])
                if score > best_score:
                    best_score = score
                    best_col = col_name
            series = test_df[best_col] if best_col else test_df[returns_col]
        else:
            series = test_df[returns_col]

        sharpe_list.append(_sharpe(series))
        equity = (1 + series / 100.0).cumprod()
        mdd_list.append(max_drawdown(equity))
        pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
        stability_list.append(_stability(equity))

    count = len(sharpe_list) or 1
    mean_sharpe = sum(sharpe_list) / count
    mean_mdd = sum(mdd_list) / count
    mean_pnl = sum(pnl_list) / count
    mean_stability = sum(stability_list) / count

    return {
        "sharpe": mean_sharpe,
        "mdd": mean_mdd,
        "pnl": mean_pnl,
        "stability": mean_stability,
    }


## scalp/bitget_client.py
import json
import logging
import time
import hmac
import hashlib
import base64
import uuid
from typing import Any, Dict, List, Optional

import requests


# Mapping of deprecated v1 product type identifiers to the new v2 names
_PRODUCT_TYPE_ALIASES = {
    "UMCBL": "USDT-FUTURES",
    "DMCBL": "USDC-FUTURES",
    "CMCBL": "COIN-FUTURES",
}

# Granularity aliases from v1 to v2 nomenclature
_GRANULARITY_ALIASES = {
    "MIN1": "1m",
    "MIN3": "3m",
    "MIN5": "5m",
    "MIN15": "15m",
    "MIN30": "30m",
    "HOUR1": "1H",
    "HOUR4": "4H",
    "HOUR12": "12H",
    "DAY1": "1D",
    "WEEK1": "1W",
}


# Default margin coin for each product type. Some authenticated endpoints
# require ``marginCoin`` in addition to ``productType``; supplying a sensible
# default avoids ``400 Bad Request`` responses when the caller does not provide
# it explicitly.
_DEFAULT_MARGIN_COIN = {
    "USDT-FUTURES": "USDT",
    "USDC-FUTURES": "USDC",
}


class BitgetFuturesClient:
    """Lightweight REST client for Bitget LAPI v2 futures endpoints."""

    def __init__(
        self,
        access_key: str,
        secret_key: str,
        base_url: str,
        *,
        product_type: str = "USDT-FUTURES",
        recv_window: int = 30,
        paper_trade: bool = True,
        requests_module: Any = requests,
        log_event: Optional[Any] = None,
        passphrase: Optional[str] = None,
    ) -> None:
        self.ak = access_key
        self.sk = secret_key
        self.base = base_url.rstrip("/")
        pt = product_type.upper()
        self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
        self.recv_window = recv_window
        self.paper_trade = paper_trade
        self.requests = requests_module
        self.log_event = log_event or (lambda *a, **k: None)
        self.passphrase = passphrase
        if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
            logging.warning(
                "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
            )

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    @staticmethod
    def _ms() -> int:
        return int(time.time() * 1000)

    @staticmethod
    def _urlencode_sorted(params: Dict[str, Any]) -> str:
        if not params:
            return ""
        items = []
        for k in sorted(params.keys()):
            v = "" if params[k] is None else str(params[k])
            items.append(f"{k}={v}")
        return "&".join(items)

    def _sign(self, prehash: str) -> str:
        """Return a base64-encoded HMAC SHA256 signature."""
        digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
        return base64.b64encode(digest).decode()

    def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
        headers = {
            "ACCESS-KEY": self.ak,
            "ACCESS-SIGN": signature,
            "ACCESS-TIMESTAMP": str(timestamp),
            "ACCESS-RECV-WINDOW": str(self.recv_window),
            "Content-Type": "application/json",
        }
        if self.passphrase:
            headers["ACCESS-PASSPHRASE"] = self.passphrase
        return headers

    def _format_symbol(self, symbol: str) -> str:
        """Return ``symbol`` formatted for Bitget API.

        The v2 endpoints expect the trading pair without any product type
        suffix (``BTCUSDT``). Older configurations may provide symbols like
        ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
        separators and any trailing product type string (legacy or v2).
        """

        if not symbol:
            return symbol

        sym = symbol.replace("_", "").upper()
        # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
        if sym.endswith(self.product_type):
            sym = sym[: -len(self.product_type)]
        else:
            for old in _PRODUCT_TYPE_ALIASES.keys():
                if sym.endswith(old):
                    sym = sym[: -len(old)]
                    break
        return sym

    def _product_type(self, pt: Optional[str] = None) -> str:
        """Normalise ``pt`` to a valid v2 product type identifier."""
        key = (pt or self.product_type or "").upper()
        return _PRODUCT_TYPE_ALIASES.get(key, key)

    # ------------------------------------------------------------------
    # Public endpoints
    # ------------------------------------------------------------------
    def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        """Return futures contract information.

        The previous implementation queried ``/contract-detail`` which does not
        exist on Bitget's v2 API and resulted in a 404 error.  The correct
        endpoint is ``/contracts`` with the symbol supplied as a query
        parameter."""

        url = f"{self.base}/api/v2/mix/market/contracts"
        params: Dict[str, Any] = {"productType": self.product_type}
        if symbol:
            params["symbol"] = self._format_symbol(symbol)
        r = self.requests.get(url, params=params, timeout=15)
        if r.status_code == 404:  # pragma: no cover - depends on network
            logging.error("Contract detail introuvable pour %s", symbol)
            return {"success": False, "code": 404, "data": None}
        r.raise_for_status()
        return r.json()

    def get_kline(
        self,
        symbol: str,
        interval: str = "1m",
        start: Optional[int] = None,
        end: Optional[int] = None,
    ) -> Dict[str, Any]:
        # Endpoint expects the trading pair in query parameters rather than
        # encoded in the path. Using ``/candles/{symbol}`` results in a 404
        # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
        url = f"{self.base}/api/v2/mix/market/candles"
        interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
        params: Dict[str, Any] = {
            "symbol": self._format_symbol(symbol),
            "productType": self.product_type,
            "granularity": interval_norm,
        }
        if start is not None:
            params["startTime"] = int(start)
        if end is not None:
            params["endTime"] = int(end)
        r = self.requests.get(url, params=params, timeout=15)
        r.raise_for_status()
        data = r.json()

        rows = data.get("data") if isinstance(data, dict) else None
        if isinstance(rows, list) and rows and isinstance(rows[0], list):
            cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
            for row in rows:
                if len(row) < 7:
                    continue
                try:
                    ts, op, hi, lo, cl, vol, qv = row[:7]
                    cols["ts"].append(int(ts))
                    cols["open"].append(float(op))
                    cols["high"].append(float(hi))
                    cols["low"].append(float(lo))
                    cols["close"].append(float(cl))
                    cols["volume"].append(float(vol))
                    cols["quoteVolume"].append(float(qv))
                except (TypeError, ValueError):
                    continue
            data["data"] = cols
        elif isinstance(rows, list):
            data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
        return data

    def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        if symbol:
            url = f"{self.base}/api/v2/mix/market/ticker"
            params = {
                "symbol": self._format_symbol(symbol),
                "productType": self.product_type,
            }
        else:
            url = f"{self.base}/api/v2/mix/market/tickers"
            params = {"productType": self.product_type}
        r = self.requests.get(url, params=params, timeout=15)
        r.raise_for_status()
        return r.json()

    # ------------------------------------------------------------------
    # Private endpoints
    # ------------------------------------------------------------------
    def _private_request(
        self,
        method: str,
        path: str,
        *,
        params: Optional[Dict[str, Any]] = None,
        body: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        method = method.upper()
        url = f"{self.base}{path}"
        ts = self._ms()

        if method in ("GET", "DELETE"):
            qs = self._urlencode_sorted(params or {})
            req_path = path + (f"?{qs}" if qs else "")
            sig = self._sign(f"{ts}{method}{req_path}")
            headers = self._headers(sig, ts)
            r = self.requests.request(method, url, params=params, headers=headers, timeout=20)
        elif method == "POST":
            qs = self._urlencode_sorted(params or {})
            req_path = path + (f"?{qs}" if qs else "")
            body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
            sig = self._sign(f"{ts}{method}{req_path}{body_str}")
            headers = self._headers(sig, ts)
            r = self.requests.post(
                url,
                params=params,
                data=body_str.encode("utf-8"),
                headers=headers,
                timeout=20,
            )
        else:
            raise ValueError("M\u00e9thode non support\u00e9e")

        try:
            r.raise_for_status()
            data = r.json()
        except Exception as e:  # pragma: no cover - network errors
            # Try to surface the response body to aid troubleshooting
            resp_text = getattr(r, "text", "")
            logging.error(
                "Erreur HTTP/JSON %s %s -> %s %s", method, path, str(e), resp_text
            )
            try:
                data = r.json()
                # Ensure a consistent failure structure
                if isinstance(data, dict):
                    data.setdefault("success", False)
                    data.setdefault("status_code", getattr(r, "status_code", None))
                    data.setdefault("error", resp_text or str(e))
            except Exception:
                data = {
                    "success": False,
                    "error": resp_text or str(e),
                    "status_code": getattr(r, "status_code", None),
                }
        self.log_event(
            "http_private",
            {"method": method, "path": path, "params": params, "body": body, "response": data},
        )
        return data

    # Accounts & positions -------------------------------------------------
    def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {
                "success": True,
                "code": 0,
                "data": [
                    {
                        "currency": "USDT",
                        "equity": 100.0,
                    }
                ],
            }

        params = {"productType": self.product_type}
        if margin_coin is None:
            margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
        if margin_coin:
            params["marginCoin"] = margin_coin
        return self._private_request(
            "GET", "/api/v2/mix/account/accounts", params=params
        )

    def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {"success": True, "code": 0, "data": []}
        data = self._private_request(
            "GET",
            "/api/v2/mix/position/all-position",
            params={"productType": self._product_type(product_type)},
        )
        try:
            positions = data.get("data", [])
            filtered = []
            for pos in positions:
                vol = pos.get("vol")
                try:
                    if vol is not None and float(vol) > 0:
                        filtered.append(pos)
                except (TypeError, ValueError):
                    continue
            data["data"] = filtered
        except Exception:  # pragma: no cover - best effort
            pass
        return data

    def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        if self.paper_trade:
            return {"success": True, "code": 0, "data": []}
        params: Dict[str, Any] = {"productType": self.product_type}
        if symbol:
            params["symbol"] = self._format_symbol(symbol)
        return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)

    # Account configuration -------------------------------------------------
    def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
        body = {
            "productType": self._product_type(product_type),
            "symbol": self._format_symbol(symbol),
            "posMode": "one_way_mode",
        }
        return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)

    def set_leverage(
        self,
        symbol: str,
        product_type: Optional[str] = None,
        margin_coin: str = "USDT",
        leverage: int = 1,
    ) -> Dict[str, Any]:
        body = {
            "symbol": self._format_symbol(symbol),
            "productType": self._product_type(product_type),
            "marginCoin": margin_coin,
            "leverage": int(leverage),
        }
        return self._private_request(
            "POST", "/api/v2/mix/account/set-leverage", body=body
        )

    def place_market_order_one_way(
        self,
        symbol: str,
        side: str,
        size: float,
        product_type: Optional[str] = None,
        margin_coin: str = "USDT",
        *,
        time_in_force: str = "normal",
    ) -> Dict[str, Any]:
        side = side.lower()
        if side not in {"buy", "sell"}:
            raise ValueError("side must be 'buy' or 'sell'")
        body = {
            "symbol": self._format_symbol(symbol),
            "productType": self._product_type(product_type),
            "marginCoin": margin_coin,
            "marginMode": "crossed",
            "posMode": "one_way_mode",
            "orderType": "market",
            "side": side,
            "size": str(size),
            "timeInForceValue": time_in_force,
            "clientOid": str(uuid.uuid4())[:32],
        }
        return self._private_request(
            "POST", "/api/v2/mix/order/place-order", body=body
        )

    # Orders ---------------------------------------------------------------
    def place_order(
        self,
        symbol: str,
        side: int,
        vol: int,
        order_type: int,
        *,
        price: Optional[float] = None,
        open_type: int = 1,
        leverage: Optional[int] = None,
        position_id: Optional[int] = None,
        external_oid: Optional[str] = None,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
        reduce_only: Optional[bool] = None,
        position_mode: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Submit an order."""
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
                side,
                vol,
                order_type,
                price,
            )
            return {
                "success": True,
                "paperTrade": True,
                "simulated": {
                    "symbol": symbol,
                    "side": side,
                    "vol": vol,
                    "type": order_type,
                    "price": price,
                    "openType": open_type,
                    "leverage": leverage,
                    "stopLossPrice": stop_loss,
                    "takeProfitPrice": take_profit,
                },
            }

        body = {
            "symbol": self._format_symbol(symbol),
            "size": vol,
            "side": side,
            "orderType": order_type,
            "openType": open_type,
        }
        if price is not None:
            body["price"] = float(price)
        if leverage is not None:
            body["leverage"] = int(leverage)
        if position_id is not None:
            body["positionId"] = int(position_id)
        if external_oid:
            body["clientOid"] = str(external_oid)[:32]
        if stop_loss is not None:
            body["stopLossPrice"] = float(stop_loss)
        if take_profit is not None:
            body["takeProfitPrice"] = float(take_profit)
        if reduce_only is not None:
            body["reduceOnly"] = bool(reduce_only)
        if position_mode is not None:
            body["positionMode"] = int(position_mode)

        return self._private_request("POST", "/api/v2/mix/order/place", body=body)

    def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> annulation simul√©e: order_ids=%s", order_ids
            )
            return {"success": True, "code": 0}
        return self._private_request(
            "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
        )

    def cancel_all(
        self,
        symbol: Optional[str] = None,
        margin_coin: Optional[str] = None,
    ) -> Dict[str, Any]:
        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> annulation simul√©e de tous les ordres"
            )
            return {"success": True, "code": 0}
        params = {"productType": self.product_type}
        if symbol:
            params["symbol"] = self._format_symbol(symbol)
        if margin_coin is None:
            margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
        if margin_coin:
            params["marginCoin"] = margin_coin
        return self._private_request(
            "POST", "/api/v2/mix/order/cancel-all-orders", params=params
        )

    def close_position(
        self,
        symbol: str,
        size: Optional[int] = None,
        hold_side: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Close an open position for ``symbol``.

        Parameters
        ----------
        symbol:
            Trading symbol to close.
        size:
            Optional number of contracts to close. If omitted the entire
            position is closed.
        hold_side:
            Optional side (``"long"``/``"short"``) to close when ``size`` is
            specified. If not provided the exchange will infer it.
        """

        if self.paper_trade:
            logging.info(
                "PAPER_TRADE=True -> fermeture simul√©e de la position %s", symbol
            )
            return {"success": True, "code": 0}

        body = {"symbol": self._format_symbol(symbol)}
        if size is not None:
            body["size"] = int(size)
        if hold_side:
            body["holdSide"] = hold_side

        body["productType"] = self.product_type
        return self._private_request(
            "POST", "/api/v2/mix/position/close-position", body=body
        )

    def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
        """Close all open positions."""
        results = []
        try:
            for pos in self.get_positions(product_type).get("data", []):
                sym = pos.get("symbol")
                if sym:
                    results.append(self.close_position(sym))
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Erreur fermeture de toutes les positions: %s", exc)
        return {"success": True, "data": results}


## scalp/bot_config.py
import os


DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"

CONFIG = {
    "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
    or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
    "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
    or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
    "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
    "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
    "SYMBOL": DEFAULT_SYMBOL,
    "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
    "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
    "INTERVAL": os.getenv("INTERVAL", "1m"),
    "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
    "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
    "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
    "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
    "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
    "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
    "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
    "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
    "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
    "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
    "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
    "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
    "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
    "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
    "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
    "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
    "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
    "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
    "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
    "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
    "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
    "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
    "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
    "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
    "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
    "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "1")),
}



## scalp/client.py
import logging
from typing import Any, Dict, Optional

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class HTTPError(RuntimeError):
    """Raised when an HTTP request fails"""


class HttpClient:
    """Simple HTTP client with persistent session and retry logic.

    The client exposes a :py:meth:`close` method and implements the context
    manager protocol so it can be used with ``with`` statements to ensure
    that the underlying :class:`requests.Session` is properly closed.
    """

    def __init__(
        self,
        base_url: str,
        *,
        timeout: float = 10.0,
        max_retries: int = 3,
        backoff_factor: float = 0.3,
        status_forcelist: Optional[list[int]] = None,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.session = requests.Session()
        retry = Retry(
            total=max_retries,
            backoff_factor=backoff_factor,
            status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
            allowed_methods=[
                "HEAD",
                "GET",
                "OPTIONS",
                "POST",
                "PUT",
                "DELETE",
                "PATCH",
            ],
        )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

    def close(self) -> None:
        """Close the underlying :class:`requests.Session`."""
        self.session.close()

    # ------------------------------------------------------------------
    # Context manager support
    # ------------------------------------------------------------------
    def __enter__(self) -> "HttpClient":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
        self.close()

    def request(
        self,
        method: str,
        path: str,
        *,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """Perform an HTTP request and return JSON data.

        Errors during the request raise ``HTTPError``. If the response cannot
        be decoded as JSON, a dictionary describing the issue is returned.
        """
        url = f"{self.base_url}{path}"
        try:
            resp = self.session.request(
                method,
                url,
                params=params,
                json=json,
                headers=headers,
                timeout=self.timeout,
            )
            resp.raise_for_status()
        except requests.RequestException as exc:  # network or HTTP errors
            msg = f"HTTP error calling {url}: {exc}"
            logging.error(msg)
            raise HTTPError(msg) from exc

        try:
            return resp.json()
        except ValueError:  # invalid JSON
            msg = "Invalid JSON in response"
            logging.error("%s for %s: %s", msg, url, resp.text)
            return {"success": False, "error": msg, "text": resp.text}


## scalp/logging_utils.py
"""Logging helpers for the Scalp bot."""

from __future__ import annotations

import atexit
import csv
import json
import os
import sqlite3
import time
from typing import Any, Dict


def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    """Return a callable that logs events as JSON lines.

    Parameters
    ----------
    path: str
        Target file path for JSON lines.
    max_bytes: int, optional
        If >0, rotate the file when its size exceeds this value.
    backup_count: int, optional
        Number of rotated files to keep when ``max_bytes`` is set.
    """
    os.makedirs(os.path.dirname(path), exist_ok=True)
    log_file = open(path, "a", encoding="utf-8")

    def _close_file() -> None:
        try:
            log_file.close()
        except Exception:
            pass

    atexit.register(_close_file)

    def _rotate() -> None:
        nonlocal log_file
        log_file.close()
        for i in range(backup_count - 1, 0, -1):
            src = f"{path}.{i}"
            dst = f"{path}.{i + 1}"
            if os.path.exists(src):
                os.replace(src, dst)
        os.replace(path, f"{path}.1")
        log_file = open(path, "a", encoding="utf-8")

    def _log(event: str, payload: Dict[str, Any]) -> None:
        nonlocal log_file
        payload = dict(payload or {})
        payload["event"] = event
        payload["ts"] = int(time.time() * 1000)
        line = json.dumps(payload, ensure_ascii=False)
        if max_bytes and backup_count > 0:
            if log_file.tell() + len(line) + 1 > max_bytes:
                _rotate()
        log_file.write(line + "\n")
        log_file.flush()

    return _log


class TradeLogger:
    """Helper writing trade information to CSV and SQLite files."""

    fields = [
        "pair",
        "tf",
        "dir",
        "entry",
        "sl",
        "tp",
        "score",
        "reasons",
        "pnl",
    ]

    def __init__(self, csv_path: str, sqlite_path: str) -> None:
        os.makedirs(os.path.dirname(csv_path), exist_ok=True)
        self.csv_path = csv_path
        self.sqlite_path = sqlite_path

        # Ensure CSV has header
        if not os.path.exists(csv_path):
            with open(csv_path, "w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=self.fields)
                writer.writeheader()

        # Setup SQLite store
        self.conn = sqlite3.connect(sqlite_path)
        cur = self.conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS trades (
                pair TEXT,
                tf TEXT,
                dir TEXT,
                entry REAL,
                sl REAL,
                tp REAL,
                score REAL,
                reasons TEXT,
                pnl REAL
            )
            """
        )
        self.conn.commit()
        atexit.register(self.conn.close)

    def log(self, data: Dict[str, Any]) -> None:
        row = {k: data.get(k) for k in self.fields}
        with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=self.fields)
            writer.writerow(row)
        cur = self.conn.cursor()
        cur.execute(
            "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                row["pair"],
                row["tf"],
                row["dir"],
                row["entry"],
                row["sl"],
                row["tp"],
                row["score"],
                row["reasons"],
                row["pnl"],
            ),
        )
        self.conn.commit()


## scalp/metrics.py
"""Utility metrics for trading calculations."""

from __future__ import annotations


from typing import Iterable

__all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]


def calc_pnl_pct(
    entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
) -> float:
    """Return percentage PnL between entry and exit prices minus fees.


    Parameters
    ----------
    entry_price: float
        Trade entry price (>0).
    exit_price: float
        Trade exit price (>0).
    side: int
        +1 for long, -1 for short.
    fee_rate: float, optional
        Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
        applied twice (entry + exit).
    """
    if entry_price <= 0 or exit_price <= 0:
        raise ValueError("Prices must be positive")
    if side not in (1, -1):
        raise ValueError("side must be +1 (long) or -1 (short)")

    pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    fee_pct = fee_rate * 2 * 100.0  # entr√©e + sortie
    return pnl - fee_pct


def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    """Compute the Relative Strength Index (RSI) using Wilder's smoothing.


    Parameters
    ----------
    prices:
        Ordered sequence of closing prices.
    period:
        Number of periods to use for the calculation. Must be positive and the
        length of ``prices`` must be at least ``period + 1``.
    """

    prices_list = [float(p) for p in prices]

    if period <= 0:
        raise ValueError("period must be positive")
    if len(prices_list) < period + 1:

        raise ValueError("len(prices) must be >= period + 1")

    gains: list[float] = []
    losses: list[float] = []
    for i in range(1, period + 1):

        diff = prices_list[i] - prices_list[i - 1]

        if diff >= 0:
            gains.append(diff)
            losses.append(0.0)
        else:
            gains.append(0.0)
            losses.append(-diff)

    avg_gain = sum(gains) / period
    avg_loss = sum(losses) / period

    for i in range(period + 1, len(prices_list)):
        diff = prices_list[i] - prices_list[i - 1]

        gain = max(diff, 0.0)
        loss = max(-diff, 0.0)
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period

    if avg_gain == 0 and avg_loss == 0:
        return 50.0
    if avg_loss == 0:
        return 100.0
    if avg_gain == 0:
        return 0.0
    rs = avg_gain / avg_loss
    return 100.0 - (100.0 / (1.0 + rs))


def calc_atr(
    highs: Iterable[float],
    lows: Iterable[float],
    closes: Iterable[float],
    period: int = 14,
) -> float:
    """Compute the Average True Range (ATR) using Wilder's smoothing.


    Parameters
    ----------
    highs, lows, closes:
        Ordered sequences of high, low and close prices. All sequences must
        have the same length and contain at least ``period + 1`` elements.
    period:
        Number of periods to use for the calculation. Must be positive.
    """

    highs_list = [float(h) for h in highs]
    lows_list = [float(low) for low in lows]
    closes_list = [float(c) for c in closes]

    length = len(highs_list)
    if length != len(lows_list) or length != len(closes_list):

        raise ValueError("Input sequences must have the same length")
    if period <= 0:
        raise ValueError("period must be positive")
    if length < period + 1:
        raise ValueError("Input sequences must have at least period + 1 elements")

    trs: list[float] = []
    for i in range(1, len(highs_list)):
        tr = max(
            highs_list[i] - lows_list[i],
            abs(highs_list[i] - closes_list[i - 1]),
            abs(lows_list[i] - closes_list[i - 1]),
        )
        trs.append(tr)

    atr = sum(trs[:period]) / period
    for tr in trs[period:]:
        atr = (atr * (period - 1) + tr) / period
    return atr


def calc_macd(
    prices: Sequence[float],
    fast: int = 12,
    slow: int = 26,
    signal: int = 9,
) -> tuple[float, float, float]:
    """Return MACD, signal line and histogram values.

    The implementation computes exponential moving averages using Wilder's
    smoothing. ``prices`` must contain at least ``slow + signal`` elements.
    """

    prices_list = [float(p) for p in prices]
    if fast <= 0 or slow <= 0 or signal <= 0:
        raise ValueError("periods must be positive")
    min_len = max(fast, slow) + signal
    if len(prices_list) < min_len:
        raise ValueError("len(prices) must be >= slow + signal")

    def _ema_series(series: Sequence[float], window: int) -> list[float]:
        k = 2.0 / (window + 1.0)
        out = [float(series[0])]
        for x in series[1:]:
            out.append(float(x) * k + out[-1] * (1.0 - k))
        return out

    fast_ema = _ema_series(prices_list, fast)
    slow_ema = _ema_series(prices_list, slow)
    macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
    signal_series = _ema_series(macd_series, signal)
    macd_val = macd_series[-1]
    signal_val = signal_series[-1]
    hist = macd_val - signal_val
    return macd_val, signal_val, hist


def backtest_position(
    prices: list[float], entry_idx: int, exit_idx: int, side: int
) -> bool:
    """Run a basic backtest to verify a position's coherence.

    Parameters
    ----------
    prices: list[float]
        Sequential list of prices to evaluate.
    entry_idx: int
        Index in ``prices`` where the position is opened.
    exit_idx: int
        Index in ``prices`` where the position is closed (must be > ``entry_idx``).
    side: int
        +1 for long, -1 for short.

    Returns
    -------
    bool
        ``True`` if the resulting PnL is non-negative, meaning the position is
        coherent with the direction of price movement. ``False`` otherwise.
    """
    if side not in (1, -1):
        raise ValueError("side must be +1 (long) or -1 (short)")
    if not (0 <= entry_idx < exit_idx < len(prices)):
        raise ValueError(
            "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
        )

    entry_price = float(prices[entry_idx])
    exit_price = float(prices[exit_idx])
    pnl = calc_pnl_pct(entry_price, exit_price, side)
    return pnl >= 0.0


## scalp/notifier.py
"""Simple notifier for bot events."""

from __future__ import annotations

import logging
import os
from typing import Any, Dict

try:  # pragma: no cover - guarded import for optional dependency
    import requests as _requests

    # ``requests`` may be provided as a stub during tests. Ensure it exposes a
    # ``post`` attribute so callers can monkeypatch it reliably.
    if not hasattr(_requests, "post"):
        raise ImportError
    requests = _requests
except Exception:  # pragma: no cover - fallback when ``requests`` is missing

    class _Requests:
        """Minimal stand‚Äëin for :mod:`requests` when the real library is absent."""

        def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
            raise RuntimeError("requests.post unavailable")

    requests = _Requests()  # type: ignore[assignment]


def _pair_name(symbol: str) -> str:
    """Return a human friendly pair name without the base ``USDT``."""
    if "_" in symbol:
        base, quote = symbol.split("_", 1)
    elif symbol.endswith("USDT"):
        base, quote = symbol[:-4], "USDT"
    else:
        base, quote = symbol, ""
    if not quote or quote == "USDT":
        return base
    return f"{base}/{quote}"


def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
    """Format a position open/close payload."""
    action = "Ouvre" if event == "position_opened" else "Ferme"
    side = payload.get("side")
    if side:
        side = f"{side} {'üìà' if side == 'long' else 'üìâ'}"
    symbol = payload.get("symbol")
    if symbol:
        symbol = _pair_name(symbol)
    pnl_pct = payload.get("pnl_pct")
    icons = ""
    if event == "position_closed" and pnl_pct is not None:
        icons = "‚úÖüéØ" if pnl_pct > 0 else "‚ùåüõë"
    head = " ".join(p for p in [action, side, symbol, icons] if p)

    lines = [head]
    vol = payload.get("vol")
    if vol is not None:
        lines.append(f"Position: {vol}")
    lev = payload.get("leverage")
    if lev is not None:
        lines.append(f"Levier: x{lev}")
    if event == "position_opened":
        tp_usd = payload.get("tp_usd")
        sl_usd = payload.get("sl_usd")
        if tp_usd is not None and sl_usd is not None:
            lines.append(f"TP: +{tp_usd} USDT")
            lines.append(f"SL: -{sl_usd} USDT")
        else:
            tp = payload.get("tp_pct")
            sl = payload.get("sl_pct")
            if tp is not None and sl is not None:
                lines.append(f"TP: +{tp:.2f}%")
                lines.append(f"SL: -{sl:.2f}%")
        hold = payload.get("hold") or payload.get("expected_duration")
        if hold is not None:
            lines.append(f"Dur√©e pr√©vue: {hold}")
    else:  # position_closed
        pnl_usd = payload.get("pnl_usd")
        if pnl_usd is not None and pnl_pct is not None:
            lines.append(f"PnL: {pnl_usd} USDT ({pnl_pct:.2f}%)")
        elif pnl_pct is not None:
            lines.append(f"PnL: {pnl_pct:.2f}%")
        dur = payload.get("duration")
        if dur is not None:
            lines.append(f"Dur√©e: {dur}")
    return "\n".join(lines)


def _format_pair_list(payload: Dict[str, Any]) -> str:
    """Format the pair list payload."""
    green = payload.get("green")
    orange = payload.get("orange")
    red = payload.get("red")
    if green or orange or red:
        lines = ["Listing :"]
        if green:
            lines.append(f"üü¢ {green}")
        if orange:
            lines.append(f"üü† {orange}")
        if red:
            lines.append(f"üî¥ {red}")
        return "\n".join(lines)
    pairs = payload.get("pairs", "")
    return f"Listing : {pairs}"


def _format_generic(event: str, payload: Dict[str, Any]) -> str:
    text = event
    if payload:
        items = "\n".join(f"{k}={v}" for k, v in payload.items())
        text = f"{text}\n{items}"
    return text


def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
    """Return a human readable text describing the event payload."""
    payload = payload or {}
    if event in {"position_opened", "position_closed"}:
        return _format_position_event(event, payload)
    if event == "pair_list":
        return _format_pair_list(payload)
    if event == "bot_started":
        return "ü§ñ Bot d√©marr√©"
    return _format_generic(event, payload)


def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
    """Send an event payload to configured endpoints.

    Notifications can be delivered via a generic HTTP endpoint defined by
    ``NOTIFY_URL`` and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
    ``TELEGRAM_CHAT_ID`` are provided. Missing configuration for one notifier
    doesn't affect the others. Network errors are logged but otherwise ignored
    so they don't interrupt the bot's execution.
    """

    data = {"event": event}
    if payload:
        data.update(payload)

    # Generic HTTP webhook
    url = os.getenv("NOTIFY_URL")
    if url:
        try:
            requests.post(url, json=data, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort only
            logging.error("Notification error for %s: %s", event, exc)

    # Telegram bot notification
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    if token and chat_id:
        tg_url = f"https://api.telegram.org/bot{token}/sendMessage"
        tg_payload = {"chat_id": chat_id, "text": _format_text(event, payload)}
        try:
            requests.post(tg_url, json=tg_payload, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort only
            logging.error("Telegram notification error for %s: %s", event, exc)


## scalp/pairs.py
"""Utilities to select trading pairs and detect signals."""
from __future__ import annotations

from typing import Any, Dict, List, Optional, Callable

from scalp.bot_config import CONFIG
from scalp.strategy import ema as default_ema, cross as default_cross
from scalp.notifier import notify


def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    """Return all trading pairs using the client's ``get_ticker`` method."""
    tick = client.get_ticker()
    data = tick.get("data") if isinstance(tick, dict) else []
    if not data:
        return []
    return data if isinstance(data, list) else [data]


def filter_trade_pairs(
    client: Any,
    *,
    volume_min: float = 5_000_000,
    max_spread_bps: float = 5.0,
    top_n: int = 20,
) -> List[Dict[str, Any]]:
    """Filter pairs by volume and spread."""
    pairs = get_trade_pairs(client)
    eligible: List[Dict[str, Any]] = []

    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        try:
            vol = float(info.get("volume", 0))
        except (TypeError, ValueError):
            continue
        if vol < volume_min:
            continue
        try:
            bid = float(info.get("bidPrice", 0))
            ask = float(info.get("askPrice", 0))
        except (TypeError, ValueError):
            continue
        if bid <= 0 or ask <= 0:
            continue
        spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
        if spread_bps >= max_spread_bps:
            continue
        eligible.append(info)

    eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    return eligible[:top_n]


def select_top_pairs(client: Any, top_n: int = 10, key: str = "volume") -> List[Dict[str, Any]]:
    """Return ``top_n`` pairs sorted by ``key``."""
    pairs = get_trade_pairs(client)

    def volume(row: Dict[str, Any]) -> float:
        try:
            return float(row.get(key, 0))
        except (TypeError, ValueError):
            return 0.0

    pairs.sort(key=volume, reverse=True)
    return pairs[:top_n]


def find_trade_positions(
    client: Any,
    pairs: List[Dict[str, Any]],
    *,
    interval: str = "1m",
    ema_fast_n: Optional[int] = None,
    ema_slow_n: Optional[int] = None,
    ema_func=default_ema,
    cross_func=default_cross,
) -> List[Dict[str, Any]]:
    """Apply EMA crossover strategy on ``pairs`` and return signals."""
    ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    results: List[Dict[str, Any]] = []

    for info in pairs:
        symbol = info.get("symbol")
        if not symbol:
            continue
        k = client.get_kline(symbol, interval=interval)
        closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
        if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
            continue
        efull = ema_func(closes, ema_fast_n)
        eslow = ema_func(closes, ema_slow_n)
        signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
        if signal == 1:
            price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
            results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
        elif signal == -1:
            price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
            results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
    return results


def send_selected_pairs(
    client: Any,
    top_n: int = 20,
    *,
    select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
    notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
) -> Dict[str, str]:
    """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.

    Returns the payload sent to ``notify_fn``. The mapping contains the
    comma-separated symbols for each color group (``green``, ``orange`` and
    ``red``) or an empty dictionary when no pairs are available.
    """

    def split_symbol(sym: str) -> tuple[str, str]:
        if "_" in sym:
            left, right = sym.split("_", 1)
            # Legacy style: BTC_USDT
            if len(right) <= 4:
                return left, right
            # Bitget futures style: BTCUSDT_UMCBL
            main = left
            if main.endswith("USDT"):
                return main[:-4], "USDT"
            if main.endswith("USDC"):
                return main[:-4], "USDC"
            if main.endswith("USD"):
                return main[:-3], "USD"
            return main, ""
        if sym.endswith("USDT"):
            return sym[:-4], "USDT"
        if sym.endswith("USDC"):
            return sym[:-4], "USDC"
        if sym.endswith("USD"):
            return sym[:-3], "USD"
        return sym, ""

    pairs = select_fn(client, top_n=top_n * 3)
    by_base: Dict[str, Dict[str, Any]] = {}
    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        base, quote = split_symbol(sym)
        existing = by_base.get(base)
        priority = {"USDT": 3, "USDC": 2, "USD": 1}
        if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
            by_base[base] = {"data": info, "quote": quote}

    unique = sorted(
        (v["data"] for v in by_base.values()),
        key=lambda row: float(row.get("volume", 0)),
        reverse=True,
    )
    symbols: list[str] = []
    for row in unique[:top_n]:
        sym = row.get("symbol")
        if not sym:
            continue
        base, _ = split_symbol(sym)
        symbols.append(base)
    if symbols:
        n = len(symbols)
        third = max(n // 3, 1)
        green = symbols[:third]
        orange = symbols[third : 2 * third]
        red = symbols[2 * third :]
        payload: Dict[str, str] = {}
        if green:
            payload["green"] = ", ".join(green)
        if orange:
            payload["orange"] = ", ".join(orange)
        if red:
            payload["red"] = ", ".join(red)
        notify_fn("pair_list", payload)
        return payload
    return {}


def heat_score(volatility: float, volume: float, news: bool = False) -> float:
    """Return a heat score combining volatility, volume and a news flag."""
    mult = 2.0 if news else 1.0
    return volatility * volume * mult


def select_top_heat_pairs(
    pairs: List[Dict[str, Any]], *, top_n: int = 3
) -> List[Dict[str, Any]]:
    """Return ``top_n`` pairs ranked by ``heat_score``."""

    scored: List[Dict[str, Any]] = []
    for info in pairs:
        try:
            vol = float(info.get("volatility", 0))
            volume = float(info.get("volume", 0))
        except (TypeError, ValueError):
            continue
        score = heat_score(vol, volume, bool(info.get("news")))
        row = dict(info)
        row["heat_score"] = score
        scored.append(row)

    scored.sort(key=lambda r: r["heat_score"], reverse=True)
    return scored[:top_n]


def decorrelate_pairs(
    pairs: List[Dict[str, Any]],
    corr: Dict[str, Dict[str, float]],
    *,
    threshold: float = 0.8,
    top_n: int = 3,
) -> List[Dict[str, Any]]:
    """Return top pairs while avoiding highly correlated symbols.

    ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
    pairs are considered too correlated when the absolute value of the
    correlation exceeds ``threshold``.
    """

    selected: List[Dict[str, Any]] = []
    for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
        sym = info.get("symbol")
        if not sym:
            continue
        if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
            selected.append(info)
        if len(selected) >= top_n:
            break
    return selected


## scalp/risk/__init__.py
"""Risk management utilities for position sizing."""

from __future__ import annotations

__all__ = ["calc_risk_amount", "calc_position_size", "adjust_risk_pct", "RiskManager"]


def calc_risk_amount(equity: float, risk_pct: float) -> float:
    """Return the monetary amount to risk on a trade.

    Parameters
    ----------
    equity: float
        Total account equity in quote currency.
    risk_pct: float
        Fraction of equity to risk (e.g. ``0.01`` for 1%). Must be in ``(0, 1]``.
    """
    if equity <= 0:
        raise ValueError("equity must be positive")
    if risk_pct <= 0 or risk_pct > 1:
        raise ValueError("risk_pct must be between 0 and 1")
    return equity * risk_pct


def calc_position_size(equity: float, risk_pct: float, stop_distance: float) -> float:
    """Compute position size given risk and stop distance.

    The size is ``risk_amount / stop_distance`` where ``risk_amount`` equals
    ``equity * risk_pct``.

    Parameters
    ----------
    equity: float
        Total account equity in quote currency.
    risk_pct: float
        Fraction of equity to risk (e.g. ``0.01`` for 1%).
    stop_distance: float
        Distance between entry price and stop-loss in quote currency.
        Must be positive.
    """
    if stop_distance <= 0:
        raise ValueError("stop_distance must be positive")
    risk_amount = calc_risk_amount(equity, risk_pct)
    return risk_amount / stop_distance


def adjust_risk_pct(
    risk_pct: float,
    win_streak: int,
    loss_streak: int,
    *,
    increase: float = 0.12,
    decrease: float = 0.25,
    min_pct: float = 0.001,
    max_pct: float = 0.05,
) -> float:
    """Return ``risk_pct`` adjusted by recent performance.

    After two consecutive winning trades the risk percentage is increased by
    ``increase`` (default 12%).  After two consecutive losses it is reduced by
    ``decrease`` (default 25%).  The result is bounded by ``min_pct`` and
    ``max_pct``.

    Parameters
    ----------
    risk_pct:
        Current risk fraction (e.g. ``0.01`` for 1%).  Must be positive.
    win_streak / loss_streak:
        Number of consecutive wins or losses.
    increase / decrease:
        Fractional adjustments applied when the respective streak is reached.
    min_pct / max_pct:
        Hard limits for the adjusted risk.
    """

    if risk_pct <= 0:
        raise ValueError("risk_pct must be positive")

    if win_streak >= 2:
        risk_pct *= 1.0 + increase
    if loss_streak >= 2:
        risk_pct *= 1.0 - decrease

    if risk_pct < min_pct:
        return min_pct
    if risk_pct > max_pct:
        return max_pct
    return risk_pct


# RiskManager lives in a separate module but is exported here for convenience.
from .manager import RiskManager  # noqa: E402  (import at end to avoid cycle)


## scalp/risk/manager.py
"""Advanced risk management utilities.

This module provides the :class:`RiskManager` class which tracks trading
performance and adjusts risk exposure accordingly.  It also implements helper
methods for dynamic risk calculation and trailing stops.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional

from . import adjust_risk_pct


@dataclass
class RiskManager:
    """Utility class implementing kill switch, loss limits and risk scaling."""

    max_daily_loss_pct: float
    max_positions: int
    risk_pct: float
    aggressive: bool = False
    max_daily_profit_pct: Optional[float] = None
    min_risk_pct: float = 0.001
    max_risk_pct: float = 0.05

    def __post_init__(self) -> None:
        self.base_risk_pct = self.risk_pct
        self.reset_day()

    # ------------------------------------------------------------------
    # State management
    # ------------------------------------------------------------------
    def reset_day(self) -> None:
        """Reset daily counters at the start of a new session."""
        self.daily_pnl_pct = 0.0
        self.consecutive_losses = 0
        self.win_streak = 0
        self.loss_streak = 0
        self.kill_switch = False
        self.risk_pct = self.base_risk_pct

    # ------------------------------------------------------------------
    # Trade handling
    # ------------------------------------------------------------------
    def register_trade(self, pnl_pct: float) -> None:
        """Register the outcome of a closed trade.

        The method updates win/loss streaks, daily profit and loss counters and
        adjusts the internal risk percentage.  When the daily loss or profit
        thresholds are breached the ``kill_switch`` flag is activated.
        """
        if pnl_pct < 0:
            self.consecutive_losses += 1
            self.loss_streak += 1
            self.win_streak = 0
        else:
            self.consecutive_losses = 0
            self.win_streak += 1
            self.loss_streak = 0

        self.daily_pnl_pct += pnl_pct

        if self.daily_pnl_pct <= -self.max_daily_loss_pct:
            self.kill_switch = True
        if (
            self.max_daily_profit_pct is not None
            and self.daily_pnl_pct >= self.max_daily_profit_pct
        ):
            self.kill_switch = True

        # Update risk percentage based purely on streaks for the next trade
        self.risk_pct = adjust_risk_pct(
            self.risk_pct, self.win_streak, self.loss_streak
        )

    # Backwards compatibility with older API
    record_trade = register_trade

    # ------------------------------------------------------------------
    # Dynamic risk and trailing stop utilities
    # ------------------------------------------------------------------
    def dynamic_risk_pct(self, signal_quality: float, score: float) -> float:
        """Return a risk percentage adjusted for streaks and signal quality.

        ``signal_quality`` is expected to be in the ``[0, 1]`` range where higher
        values indicate better confidence.  ``score`` acts as a modifier in the
        ``[-1, 1]`` range and allows callers to further tweak the risk based on
        arbitrary logic.  The result is clamped between ``min_risk_pct`` and
        ``max_risk_pct`` and stored in :attr:`risk_pct` for convenience.
        """
        base = adjust_risk_pct(self.base_risk_pct, self.win_streak, self.loss_streak)
        quality = max(0.0, min(1.0, signal_quality))
        score = max(-1.0, min(1.0, score))
        pct = base * (1.0 + quality * score)
        pct = max(self.min_risk_pct, min(self.max_risk_pct, pct))
        self.risk_pct = pct
        return pct

    def apply_trailing(
        self,
        direction: int,
        price: float,
        sl: float,
        atr: float,
        params: Dict[str, float],
    ) -> float:
        """Return a new stop-loss based on trailing stop parameters.

        Parameters
        ----------
        direction:
            ``1`` for long positions and ``-1`` for short positions.
        price:
            Current market price.
        sl:
            Existing stop-loss level.
        atr:
            Current Average True Range value.
        params:
            Dictionary controlling the behaviour.  Supported keys are:
            ``type`` (``"atr"`` or ``"vwap"``).  For ``atr`` trailing the key
            ``atr_mult`` (or ``mult``) specifies the ATR multiplier.  For VWAP
            trailing provide ``vwap`` and optional ``buffer``.
        """
        method = params.get("type", "atr")
        new_sl = sl
        if method == "atr":
            mult = float(params.get("atr_mult", params.get("mult", 1.0)))
            if atr > 0 and mult > 0:
                distance = atr * mult
                if direction > 0:
                    candidate = price - distance
                    if candidate > sl:
                        new_sl = candidate
                else:
                    candidate = price + distance
                    if candidate < sl:
                        new_sl = candidate
        elif method == "vwap":
            vwap_val = params.get("vwap")
            if vwap_val is not None:
                buffer = float(params.get("buffer", 0.0))
                if direction > 0:
                    candidate = vwap_val - buffer
                    if candidate > sl:
                        new_sl = candidate
                else:
                    candidate = vwap_val + buffer
                    if candidate < sl:
                        new_sl = candidate
        return new_sl

    # ------------------------------------------------------------------
    # Misc helpers
    # ------------------------------------------------------------------
    def pause_duration(self) -> int:
        """Return seconds to pause after consecutive losses."""
        if self.consecutive_losses >= 5:
            return 60 * 60
        if self.consecutive_losses >= 3:
            return 15 * 60
        return 0

    def can_open(self, current_positions: int) -> bool:
        """Return whether a new position can be opened."""
        return (not self.kill_switch) and current_positions < self.max_positions


## scalp/selection/__init__.py
"""Pair selection helpers for the Scalp bot.

This package exposes two utilities used during the preparation phase of the
trading strategy:

``scan_pairs``
    Performs the first level market scan by filtering pairs based on volume,
    spread and hourly volatility.

``select_active_pairs``
    Refines a list of pairs by keeping only those showing an EMA20/EMA50
    crossover and a sufficiently high ATR.
"""

from .scanner import scan_pairs
from .momentum import select_active_pairs

__all__ = ["scan_pairs", "select_active_pairs"]



## scalp/selection/momentum.py
"""Utilities to select pairs exhibiting strong momentum."""

from __future__ import annotations

from typing import Any, Dict, List, Sequence

from ..metrics import calc_atr


def ema(series: Sequence[float], window: int) -> List[float]:
    """Simple exponential moving average implementation."""

    if window <= 1 or not series:
        return list(series)
    k = 2.0 / (window + 1.0)
    out: List[float] = [float(series[0])]
    prev = out[0]
    for x in series[1:]:
        prev = float(x) * k + prev * (1.0 - k)
        out.append(prev)
    return out


def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""

    if prev_fast <= prev_slow and last_fast > last_slow:
        return 1
    if prev_fast >= prev_slow and last_fast < last_slow:
        return -1
    return 0


def _quantile(values: Sequence[float], q: float) -> float:
    """Return the *q* quantile of *values* (0 <= q <= 1)."""

    if not values:
        return 0.0
    q = min(max(q, 0.0), 1.0)
    vals = sorted(values)
    idx = int((len(vals) - 1) * q)
    return vals[idx]


def select_active_pairs(
    client: Any,
    pairs: Sequence[Dict[str, Any]],
    *,
    interval: str = "Min5",
    ema_fast: int = 20,
    ema_slow: int = 50,
    atr_period: int = 14,
    atr_quantile: float = 0.5,
    top_n: int = 5,
) -> List[Dict[str, Any]]:
    """Return pairs with an EMA crossover and high ATR.

    Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    Among those candidates, the Average True Range is computed and only pairs
    whose ATR is above the provided quantile are returned.  The resulting
    dictionaries include an ``atr`` key for convenience.
    """

    candidates: List[Dict[str, Any]] = []
    atrs: List[float] = []

    for info in pairs:
        sym = info.get("symbol")
        if not sym:
            continue
        k = client.get_kline(sym, interval=interval)
        kdata = k.get("data") if isinstance(k, dict) else {}
        closes = kdata.get("close", [])
        highs = kdata.get("high", [])
        lows = kdata.get("low", [])
        if len(closes) < max(ema_slow, atr_period) + 2:
            continue
        efast = ema(closes, ema_fast)
        eslow = ema(closes, ema_slow)
        if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
            continue
        atr_val = calc_atr(highs, lows, closes, atr_period)
        row = dict(info)
        row["atr"] = atr_val
        candidates.append(row)
        atrs.append(atr_val)

    if not candidates:
        return []

    threshold = _quantile(atrs, atr_quantile)
    selected = [row for row in candidates if row["atr"] >= threshold]
    selected.sort(key=lambda r: r["atr"], reverse=True)
    return selected[:top_n]


__all__ = ["select_active_pairs"]



## scalp/selection/scanner.py
"""Utilities for scanning tradable pairs on the exchange."""

from __future__ import annotations

from typing import Any, Dict, List


def scan_pairs(
    client: Any,
    *,
    volume_min: float = 5_000_000,
    max_spread_bps: float = 5.0,
    min_hourly_vol: float = 0.0,
    top_n: int = 20,
) -> List[Dict[str, Any]]:
    """Return pairs satisfying basic liquidity and volatility filters.

    Parameters
    ----------
    client: Any
        Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    volume_min: float, optional
        Minimum 24h volume required to keep a pair.
    max_spread_bps: float, optional
        Maximum allowed bid/ask spread expressed in basis points.
    min_hourly_vol: float, optional
        Minimum volatility over the last hour expressed as ``(high - low) /
        close``.  When set to ``0`` the filter is disabled.
    top_n: int, optional
        Limit the number of returned pairs.
    """

    tick = client.get_ticker()
    data = tick.get("data") if isinstance(tick, dict) else []
    if not isinstance(data, list):
        data = [data]

    eligible: List[Dict[str, Any]] = []

    for row in data:
        sym = row.get("symbol")
        if not sym:
            continue
        try:
            vol = float(row.get("volume", 0))
            bid = float(row.get("bidPrice", 0))
            ask = float(row.get("askPrice", 0))
        except (TypeError, ValueError):
            continue
        if vol < volume_min or bid <= 0 or ask <= 0:
            continue
        spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
        if spread_bps >= max_spread_bps:
            continue

        if min_hourly_vol > 0:
            k = client.get_kline(sym, interval="Min60")
            kdata = k.get("data") if isinstance(k, dict) else {}
            highs = kdata.get("high", [])
            lows = kdata.get("low", [])
            closes = kdata.get("close", [])
            if not highs or not lows or not closes:
                continue
            try:
                h = float(highs[-1])
                l = float(lows[-1])
                c = float(closes[-1])
            except (TypeError, ValueError):
                continue
            hourly_vol = (h - l) / c if c else 0.0
            if hourly_vol < min_hourly_vol:
                continue

        eligible.append(row)

    eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    return eligible[:top_n]


__all__ = ["scan_pairs"]



## scalp/strategy.py
"""Core trading strategy components for scalping EMA/VWAP/RSI/ATR.

This module implements a minimal but functional version of the strategy
outlined in the project specification.  The focus is on pure Python
implementations so the logic can easily be unit tested without requiring
external services or heavy third‚Äëparty dependencies.

The strategy is deliberately stateless; functions operate on passed data and
return simple data structures.  This makes it easy to plug the logic into
real‚Äëtime trading loops or backtest engines.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Sequence, List, Dict, Optional, Tuple, Any

from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
from .risk import calc_position_size

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def ema(series: Sequence[float], window: int) -> List[float]:
    """Return the exponential moving average of *series*.

    The first value is the raw input to remain consistent with most trading
    platforms.  ``window`` must be positive; when it equals ``1`` the input is
    returned unchanged.
    """

    if window <= 1 or not series:
        return list(series)
    k = 2.0 / (window + 1.0)
    out: List[float] = [float(series[0])]
    prev = out[0]
    for x in series[1:]:
        prev = float(x) * k + prev * (1.0 - k)
        out.append(prev)
    return out

def vwap(highs: Sequence[float], lows: Sequence[float],
         closes: Sequence[float], volumes: Sequence[float]) -> float:
    """Compute the volume weighted average price (VWAP).

    Parameters
    ----------
    highs, lows, closes, volumes: Sequence[float]
        Matching sequences for the period considered.
    """

    tp_vol = 0.0
    vol_sum = 0.0
    for h, low, c, v in zip(highs, lows, closes, volumes):
        tp = (h + low + c) / 3.0
        tp_vol += tp * v
        vol_sum += v
    return tp_vol / vol_sum if vol_sum else 0.0

def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    """Return the On Balance Volume (OBV) series."""

    if not closes:
        return []
    out: List[float] = [0.0]
    for i in range(1, len(closes)):
        if closes[i] > closes[i - 1]:
            out.append(out[-1] + volumes[i])
        elif closes[i] < closes[i - 1]:
            out.append(out[-1] - volumes[i])
        else:
            out.append(out[-1])
    return out


def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    """Detect a crossing between two series.

    Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    ``0`` otherwise.
    """

    if prev_fast <= prev_slow and last_fast > last_slow:
        return 1
    if prev_fast >= prev_slow and last_fast < last_slow:
        return -1
    return 0


def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    """Compute order book imbalance.

    The value is normalised between ``-1`` and ``1`` where positive numbers
    indicate bid dominance.  ``0`` is returned when both volumes are zero.
    """

    total = bid_vol + ask_vol
    return (bid_vol - ask_vol) / total if total else 0.0


def swing_levels(
    highs: Sequence[float], lows: Sequence[float], lookback: int
) -> Tuple[float, float]:
    """Return the most recent swing high and swing low.

    ``lookback`` defines how many completed candles are inspected.  The current
    candle is excluded to avoid look‚Äëahead bias.
    """

    if len(highs) < lookback + 1 or len(lows) < lookback + 1:
        return highs[-1], lows[-1]
    high = max(highs[-lookback - 1 : -1])
    low = min(lows[-lookback - 1 : -1])
    return high, low

# ---------------------------------------------------------------------------
# Pair selection
# ---------------------------------------------------------------------------

# The first and second level pair selection helpers now live in
# :mod:`scalp.selection`.  They are re-exported here for backward compatibility
# and to keep the public API unchanged.
from .selection.scanner import scan_pairs  # noqa: E402
from .selection.momentum import select_active_pairs  # noqa: E402

# ---------------------------------------------------------------------------
# Signal generation
# ---------------------------------------------------------------------------

@dataclass
class Signal:
    """Trading signal with risk parameters."""

    symbol: str
    side: str  # "long" or "short"
    price: float
    sl: float
    tp1: float
    tp2: float
    qty: float


def generate_signal(
    symbol: str,
    ohlcv: Dict[str, Sequence[float]],
    *,
    equity: float,
    risk_pct: float,
    ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
    ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
    order_book: Optional[Dict[str, float]] = None,
    tick_ratio_buy: Optional[float] = None,
    atr_disable_pct: float = 0.2,
    atr_reduce_pct: float = 2.0,
    swing_lookback: int = 5,
    macd_fast: int = 12,
    macd_slow: int = 26,
    macd_signal: int = 9,
    trend_ema_period: int = 200,
) -> Optional[Signal]:
    """Return a trading :class:`Signal` if conditions are met.

    ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
    sequences ordered from oldest to newest.  The function checks the following
    rules:

    * price positioned relative to VWAP and EMA20/EMA50 trend
    * RSI(14) crossing key levels (40/60)
    * OBV rising or high short‚Äëterm volume
    * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
    * Micro‚Äëstructure breakout of last swing high/low
    * MACD trend filter
    * Long‚Äëterm trend via configurable EMA filter
    * Order book imbalance and tape filters
    * Dynamic ATR‚Äëbased stop‚Äëloss and take‚Äëprofit
    * Position sizing via ``calc_position_size``
    """

    closes = [float(x) for x in ohlcv.get("close", [])]
    highs = [float(x) for x in ohlcv.get("high", [])]
    lows = [float(x) for x in ohlcv.get("low", [])]
    vols = [float(x) for x in ohlcv.get("volume", [])]
    if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
        return None

    price = closes[-1]
    ema20 = ema(closes, 20)
    ema50 = ema(closes, 50)
    ema_trend = ema(closes, trend_ema_period)
    v = vwap(highs, lows, closes, vols)
    obv_series = obv(closes, vols)
    obv_rising = obv_series[-1] > obv_series[-2]
    vol_last3 = sum(vols[-3:])
    vol_ma20 = sum(vols[-20:]) / 20.0
    vol_rising = vol_last3 > vol_ma20

    macd_val, macd_sig, _ = calc_macd(
        closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
    )

    # Multi timeframe filters -------------------------------------------------
    trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
    if ohlcv_1h:
        h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
        if len(h_closes) >= 52:
            h_ema50 = ema(h_closes, 50)
            if len(h_ema50) >= 2:
                slope = h_ema50[-1] - h_ema50[-2]
                if slope > 0:
                    trend_dir = 1
                elif slope < 0:
                    trend_dir = -1

    rsi_15 = None
    if ohlcv_15m:
        m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
        if len(m_closes) >= 15:
            rsi_15 = calc_rsi(m_closes, 14)

    # RSI crossing logic (5m)
    rsi_curr = calc_rsi(closes[-15:], 14)
    rsi_prev = calc_rsi(closes[-16:-1], 14)

    atr = calc_atr(highs, lows, closes, 14)
    atr_pct = atr / price * 100.0 if price else 0.0
    if atr_pct < atr_disable_pct:
        return None
    size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0

    sl_dist = 0.5 * atr
    tp1_dist = 1.0 * atr
    tp2_dist = 1.5 * atr

    swing_high, swing_low = swing_levels(highs, lows, swing_lookback)

    obi_ok_long = obi_ok_short = True
    if order_book is not None:
        bid = float(order_book.get("bid_vol_aggreg", 0))
        ask = float(order_book.get("ask_vol_aggreg", 0))
        obi = order_book_imbalance(bid, ask)
        obi_ok_long = obi > 0.1
        obi_ok_short = obi < -0.1

    tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
    tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45

    def _size(dist: float) -> float:
        return calc_position_size(equity, risk_pct, dist) * size_mult

    if (
        price > v
        and ema20[-1] > ema50[-1]
        and rsi_prev <= 40 < rsi_curr
        and macd_val > macd_sig
        and (obv_rising or vol_rising)
        and (rsi_15 is None or rsi_15 > 50)
        and price > swing_high
        and price > ema_trend[-1]
        and obi_ok_long
        and tick_ok_long
        and trend_dir >= 0
    ):
        sl = price - sl_dist
        tp1 = price + tp1_dist
        tp2 = price + tp2_dist
        qty = _size(sl_dist)
        return Signal(symbol, "long", price, sl, tp1, tp2, qty)

    if (
        price < v
        and ema20[-1] < ema50[-1]
        and rsi_prev >= 60 > rsi_curr
        and macd_val < macd_sig
        and (obv_series[-1] < obv_series[-2] or vol_rising)
        and (rsi_15 is None or rsi_15 < 50)
        and price < swing_low
        and price < ema_trend[-1]
        and obi_ok_short
        and tick_ok_short
        and trend_dir <= 0
    ):
        sl = price + sl_dist
        tp1 = price - tp1_dist
        tp2 = price - tp2_dist
        qty = _size(sl_dist)
        return Signal(symbol, "short", price, sl, tp1, tp2, qty)

    return None

# ---------------------------------------------------------------------------
# Backtesting utilities
# ---------------------------------------------------------------------------

def max_drawdown(equity_curve: Sequence[float]) -> float:
    peak = equity_curve[0]
    mdd = 0.0
    for x in equity_curve:
        if x > peak:
            peak = x
        dd = (peak - x) / peak * 100.0
        if dd > mdd:
            mdd = dd
    return mdd

def backtest(
    trades: Sequence[Dict[str, Any]],
    *,
    equity_start: float = 1_000.0,
    fee_rate: float = 0.0,
) -> Dict[str, float]:
    """Evaluate a list of trade dictionaries.

    Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
    optionally include ``duration`` in minutes.  Results are aggregated into
    common performance metrics to quickly evaluate the strategy.
    """

    equity = equity_start
    equity_curve = [equity]
    pnl_pct_list: List[float] = []
    wins = losses = 0
    win_sum = loss_sum = 0.0
    total_duration = 0.0

    for t in trades:
        pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
        pnl_pct_list.append(pnl_pct)
        if pnl_pct >= 0:
            wins += 1
            win_sum += pnl_pct
        else:
            losses += 1
            loss_sum += pnl_pct
        equity *= 1 + pnl_pct / 100.0
        equity_curve.append(equity)
        total_duration += float(t.get("duration", 0.0))

    pnl_pct_total = sum(pnl_pct_list)
    pnl_usdt = equity - equity_start
    profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
    winrate = wins / len(trades) * 100.0 if trades else 0.0
    mdd = max_drawdown(equity_curve)
    avg_trade_time = total_duration / len(trades) if trades else 0.0
    exposure = total_duration  # in minutes, callers can normalise if desired
    # Sharpe ratio based on per-trade returns
    if len(pnl_pct_list) > 1:
        mean = sum(pnl_pct_list) / len(pnl_pct_list)
        var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
        sharpe = mean / (var ** 0.5) if var > 0 else 0.0
    else:
        sharpe = 0.0

    return {
        "pnl_usdt": pnl_usdt,
        "pnl_pct": pnl_pct_total,
        "profit_factor": profit_factor,
        "winrate": winrate,
        "max_drawdown": mdd,
        "avg_trade_time": avg_trade_time,
        "exposure": exposure,
        "sharpe": sharpe,
    }


## scalp/telegram_bot.py
from __future__ import annotations

import logging
import os
from typing import Any, Dict, Optional

try:  # pragma: no cover - optional dependency
    import requests as _requests
    requests = _requests
except Exception:  # pragma: no cover
    class _Requests:
        def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
            raise RuntimeError("requests.get unavailable")

        def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
            raise RuntimeError("requests.post unavailable")

    requests = _Requests()  # type: ignore[assignment]


class TelegramBot:
    """Minimal Telegram bot using the HTTP API.


    The bot exposes a simple *menu* based interface with clickable buttons so
    users do not have to remember text commands.  A sub-menu lets the user set
    the risk level.

    """

    def __init__(
        self,
        token: str,
        chat_id: str,
        client: Any,
        config: Dict[str, Any],
        risk_mgr: Any,
        *,
        requests_module: Any = requests,
    ) -> None:
        self.token = token
        self.chat_id = str(chat_id)
        self.client = client
        self.config = config
        self.risk_mgr = risk_mgr
        self.requests = requests_module
        self.last_update_id: Optional[int] = None
        self.stop_requested = False


        self.main_keyboard = [
            [{"text": "Positions ouvertes", "callback_data": "positions"}],
            [{"text": "Update Cryptos", "callback_data": "update"}],
            [{"text": "R√©glages", "callback_data": "settings"}],
        ]
        self.settings_keyboard = [
            [{"text": "Stop trade", "callback_data": "stop"}],
            [{"text": "R√©glage risk", "callback_data": "risk"}],
            [{"text": "Reset risk", "callback_data": "reset_risk"}],
            [{"text": "Arr√™t bot", "callback_data": "shutdown"}],
            [{"text": "Reset total", "callback_data": "reset_all"}],
            [{"text": "Retour", "callback_data": "back"}],
        ]
        self.risk_keyboard = [
            [
                {"text": "üü¢", "callback_data": "risk_green"},
                {"text": "üü†", "callback_data": "risk_orange"},
                {"text": "üî¥", "callback_data": "risk_red"},
            ],
            [{"text": "Retour", "callback_data": "back"}],
        ]

        # Show menu on startup with zero PnL session
        self.send_main_menu(0.0)


    def _base_symbol(self, symbol: str) -> str:
        sym = symbol.replace("_", "")
        return sym[:-4] if sym.endswith("USDT") else sym

    def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
        pos = self.client.get_positions()
        buttons: list[list[Dict[str, str]]] = []
        for p in pos.get("data", []):
            sym = p.get("symbol")
            if not sym:
                continue
            base = self._base_symbol(sym)
            # Use the full symbol in the callback so we can properly
            # identify the position to close.  Only the label shows the
            # base asset to keep the interface concise.
            buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
        buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
        buttons.append([{"text": "Retour", "callback_data": "back"}])
        return buttons


    def _menu_text(self, session_pnl: float) -> str:
        assets = self.client.get_assets()
        equity = 0.0
        for row in assets.get("data", []):
            if row.get("currency") == "USDT":
                try:
                    equity = float(row.get("equity", 0.0))
                except Exception:
                    equity = 0.0
                break
        return (
            f"Solde: {equity} USDT\n"
            f"PnL session: {session_pnl} USDT\n"
            "Choisissez une option:"
        )

    def send_main_menu(self, session_pnl: float) -> None:
        self.send(self._menu_text(session_pnl), self.main_keyboard)

    def update_pairs(self) -> None:
        from bot import update as _update  # lazy import to avoid cycle

        _update(self.client, top_n=20, tg_bot=self)

    # ------------------------------------------------------------------
    def _api_url(self, method: str) -> str:
        return f"https://api.telegram.org/bot{self.token}/{method}"


    def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
        payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
        if keyboard:
            payload["reply_markup"] = {"inline_keyboard": keyboard}

        try:  # pragma: no cover - network
            self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram send error: %s", exc)

    def answer_callback(self, cb_id: str) -> None:
        payload = {"callback_query_id": cb_id}
        try:  # pragma: no cover - network
            self.requests.post(
                self._api_url("answerCallbackQuery"), json=payload, timeout=5
            )
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram answerCallback error: %s", exc)


    # ------------------------------------------------------------------
    def fetch_updates(self) -> list[Dict[str, Any]]:
        params: Dict[str, Any] = {}
        if self.last_update_id is not None:
            params["offset"] = self.last_update_id + 1
        try:  # pragma: no cover - network
            r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
            r.raise_for_status()
            data = r.json()
        except Exception as exc:  # pragma: no cover - best effort
            logging.error("Telegram getUpdates error: %s", exc)
            return []
        updates = data.get("result", [])
        if updates:
            self.last_update_id = updates[-1].get("update_id")
        return updates

    # ------------------------------------------------------------------
    def handle_updates(self, session_pnl: float) -> None:
        for update in self.fetch_updates():

            callback = update.get("callback_query")
            if callback:
                if str(callback.get("from", {}).get("id")) != self.chat_id:
                    continue
                data = callback.get("data", "")
                reply, kb = self.handle_callback(data, session_pnl)
                if reply:
                    self.send(reply, kb)
                cb_id = callback.get("id")
                if cb_id:
                    self.answer_callback(cb_id)
                continue


            msg = update.get("message") or {}
            chat = msg.get("chat") or {}
            if str(chat.get("id")) != self.chat_id:
                continue

            # Any text message triggers the main menu with balance and PnL
            self.send_main_menu(session_pnl)

    # ------------------------------------------------------------------
    def handle_callback(
        self, data: str, session_pnl: float
    ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
        if not data:
            return None, None
        if data == "balance":
            assets = self.client.get_assets()
            equity = 0.0
            for row in assets.get("data", []):
                if row.get("currency") == "USDT":
                    try:
                        equity = float(row.get("equity", 0.0))
                    except Exception:
                        equity = 0.0
                    break

            return f"Solde: {equity} USDT", self.main_keyboard
        if data == "positions":
            pos = self.client.get_positions()
            lines = []
            for p in pos.get("data", []):
                symbol = p.get("symbol", "")
                base = self._base_symbol(symbol)
                side = p.get("side")
                vol = p.get("vol")
                pnl = p.get("pnl_usd")
                if pnl is None:
                    pnl = p.get("pnl")
                pnl_pct = p.get("pnl_pct")
                line = f"{base} {side} {vol}"
                if pnl is not None and pnl_pct is not None:
                    line += f"\nPnL: {pnl} USDT ({pnl_pct}%)"
                lines.append(line)
            if not lines:

                return "Aucune position ouverte", self.main_keyboard
            return "Positions:\n" + "\n".join(lines), self.main_keyboard
        if data == "pnl":
            return f"PnL session: {session_pnl} USDT", self.main_keyboard
        if data == "risk":
            return "Choisissez le niveau de risque:", self.risk_keyboard
        if data == "settings":
            return "R√©glages:", self.settings_keyboard
        if data == "reset_risk":
            try:
                self.risk_mgr.reset_day()
                return "Risque r√©initialis√©", self.settings_keyboard
            except Exception:
                return "Erreur reset risque", self.settings_keyboard
        if data == "update":
            try:
                self.update_pairs()
                return "Liste cryptos mise √† jour", self.main_keyboard
            except Exception:
                return "Erreur mise √† jour", self.main_keyboard
        if data.startswith("risk"):
            mapping = {
                "risk_green": 1,
                "risk_orange": 2,
                "risk_red": 3,
            }
            lvl = mapping.get(data)
            if lvl:
                self.config["RISK_LEVEL"] = lvl
                return f"Niveau de risque r√©gl√© sur {lvl}", self.main_keyboard
            return "Niveau de risque inchang√©", self.main_keyboard

        if data == "reset_all":
            try:
                self.client.close_all_positions()
                self.risk_mgr.reset_day()
                return "Positions et risque r√©initialis√©s", self.settings_keyboard
            except Exception:
                return "Erreur lors du reset total", self.settings_keyboard

        if data == "stop":
            pos = self.client.get_positions()
            if not pos.get("data"):
                return "Aucune crypto s√©lectionn√©e", self.settings_keyboard
            return "Choisissez la position √† fermer:", self._build_stop_keyboard()
        if data == "stop_all":
            try:
                self.client.close_all_positions()
                return "Toutes les positions ferm√©es", self.settings_keyboard
            except Exception:
                return "Erreur arr√™t trade", self.settings_keyboard
        if data.startswith("stop_"):
            sym = data[5:]
            try:
                self.client.close_position(sym)
                return f"Position {sym} ferm√©e", self.settings_keyboard
            except Exception:
                return f"Erreur arr√™t trade {sym}", self.settings_keyboard

        if data == "shutdown":
            self.stop_requested = True
            return "Arr√™t du bot demand√©", self.settings_keyboard

        if data == "back":
            return self._menu_text(session_pnl), self.main_keyboard
        return None, None


def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    if token and chat_id:
        return TelegramBot(token, chat_id, client, config, risk_mgr)
    return None


## scalp/trade_utils.py
"""Utilities for risk analysis and position sizing."""
from __future__ import annotations

import math
from typing import Any, Dict, List, Optional, Tuple

from scalp.bot_config import CONFIG


def compute_position_size(
    contract_detail: Dict[str, Any],
    equity_usdt: float,
    price: float,
    risk_pct: float,
    leverage: int,
    symbol: Optional[str] = None,
) -> int:
    """Return contract volume to trade for the given risk parameters.

    The original implementation assumed ``price`` and contract metadata were
    always valid which could lead to divide-by-zero errors or negative volumes
    when the upstream API returned incomplete data.  To harden the sizing logic
    we now validate these inputs and simply return ``0`` whenever they are
    non‚Äëpositive.  The caller interprets a zero volume as a cue to skip the
    trade, keeping the bot running without raising exceptions.
    """

    symbol = symbol or CONFIG.get("SYMBOL")
    contracts = contract_detail.get("data") or []
    if not isinstance(contracts, list):
        contracts = [contracts]
    contract = next((c for c in contracts if c and c.get("symbol") == symbol), None)
    if contract is None:
        raise ValueError("Contract detail introuvable pour le symbole")

    contract_size = float(contract.get("contractSize", 0.0001))
    vol_unit = int(contract.get("volUnit", 1))
    min_vol = int(contract.get("minVol", 1))

    if price <= 0 or contract_size <= 0 or vol_unit <= 0 or min_vol <= 0:
        return 0

    notional = equity_usdt * float(risk_pct) * float(leverage)
    if notional <= 0.0:
        return 0
    vol = notional / (price * contract_size)
    vol = int(math.floor(vol / vol_unit) * vol_unit)
    return max(min_vol, vol)


def analyse_risque(
    contract_detail: Dict[str, Any],
    open_positions: List[Dict[str, Any]],
    equity_usdt: float,
    price: float,
    risk_pct: float,
    base_leverage: int,
    symbol: Optional[str] = None,
    side: str = "long",
    risk_level: int = 2,
) -> Tuple[int, int]:
    """Analyse le risque avant l'ouverture d'une position."""
    symbol = symbol or CONFIG.get("SYMBOL")
    side = side.lower()

    max_positions_map = {1: 1, 2: 2, 3: 3}
    leverage_map = {1: max(1, base_leverage // 2), 2: base_leverage, 3: base_leverage * 2}

    max_pos = max_positions_map.get(risk_level, max_positions_map[2])
    leverage = leverage_map.get(risk_level, base_leverage)

    current = 0
    for pos in open_positions or []:
        if pos and pos.get("symbol") == symbol:
            if str(pos.get("side", "")).lower() == side:
                current += 1

    if current >= max_pos:
        return 0, leverage

    vol = compute_position_size(
        contract_detail,
        equity_usdt=equity_usdt,
        price=price,
        risk_pct=risk_pct,
        leverage=leverage,
        symbol=symbol,
    )
    return vol, leverage


def trailing_stop(side: str, current_price: float, atr: float, sl: float, *, mult: float = 0.75) -> float:
    """Update a stop loss using a trailing ATR multiple."""

    if side.lower() == "long":
        new_sl = current_price - mult * atr
        return max(sl, new_sl)
    new_sl = current_price + mult * atr
    return min(sl, new_sl)


def break_even_stop(
    side: str,
    entry_price: float,
    current_price: float,
    atr: float,
    sl: float,
    *,
    mult: float = 1.0,
) -> float:
    """Move stop loss to break-even after a favourable move.

    Once price advances ``mult`` times the ``atr`` from ``entry_price`` the
    original stop loss ``sl`` is tightened to the entry.  This helps lock in
    profits while still giving the trade room to develop.
    """

    side = side.lower()
    if side == "long":
        if current_price - entry_price >= mult * atr:
            return max(sl, entry_price)
        return sl
    if side == "short":
        if entry_price - current_price >= mult * atr:
            return min(sl, entry_price)
        return sl
    raise ValueError("side must be 'long' or 'short'")


def should_scale_in(
    entry_price: float,
    current_price: float,
    last_entry: float,
    atr: float,
    side: str,
    *,
    distance_mult: float = 0.5,
) -> bool:
    """Return ``True`` when price moved sufficiently to add to the position."""

    if side.lower() == "long":
        target = last_entry + distance_mult * atr
        return current_price >= target
    target = last_entry - distance_mult * atr
    return current_price <= target


def timeout_exit(
    entry_time: float,
    now: float,
    entry_price: float,
    current_price: float,
    side: str,
    *,
    progress_min: float = 15.0,
    timeout_min: float = 30.0,
) -> bool:
    """Return ``True`` when a position should be closed for lack of progress."""

    elapsed = now - entry_time
    if elapsed >= timeout_min:
        return True
    if elapsed >= progress_min:
        progress = (current_price - entry_price) if side.lower() == "long" else (entry_price - current_price)
        return progress <= 0
    return False


def marketable_limit_price(
    side: str,
    *,
    best_bid: float,
    best_ask: float,
    slippage: float = 0.001,
) -> float:
    """Return price for a marketable limit order with slippage cap.

    Parameters
    ----------
    side:
        ``"buy"`` or ``"sell"``.
    best_bid, best_ask:
        Current best bid and ask prices.
    slippage:
        Maximum relative slippage allowed (e.g. ``0.001`` = 0.1%).
    """

    if slippage < 0:
        raise ValueError("slippage must be non-negative")
    side = side.lower()
    if side == "buy":
        return best_ask * (1.0 + slippage)
    if side == "sell":
        return best_bid * (1.0 - slippage)
    raise ValueError("side must be 'buy' or 'sell'")


## scalp/version.py
"""Utilities for managing the Scalp bot version."""

from __future__ import annotations

from pathlib import Path
import re

import subprocess


# Path to the VERSION file within the package
_VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
_VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")


def get_version() -> str:
    """Return the current version of the bot.

    If the VERSION file does not exist the default version ``0.0.0`` is
    returned.
    """
    if not _VERSION_FILE.exists():
        return "0.0.0"
    return _VERSION_FILE.read_text().strip()


def _parse(version: str) -> tuple[int, int, int]:
    match = _VERSION_RE.match(version)
    if not match:
        raise ValueError(f"Invalid version: {version!r}")
    return tuple(int(x) for x in match.groups())


def bump_version(part: str = "patch") -> str:
    """Bump the version stored in the VERSION file.

    Parameters
    ----------
    part:
        Which component to increment. Accepted values are ``"major"``,
        ``"minor"`` and ``"patch"`` (default).
    """
    major, minor, patch = _parse(get_version())
    if part == "major":
        major += 1
        minor = 0
        patch = 0
    elif part == "minor":
        minor += 1
        patch = 0

    elif part == "patch":
        patch += 1
    else:
        raise ValueError(f"Unknown part: {part}")
    new_version = f"{major}.{minor}.{patch}"
    _VERSION_FILE.write_text(f"{new_version}\n")
    return new_version


def bump_version_from_message(message: str) -> str:
    """Bump the version according to a commit message.

    ``message`` is evaluated using a tiny subset of the Conventional
    Commits spec. Messages starting with ``feat`` bump the *minor*
    version, messages whose header ends with ``!`` or contain
    ``BREAKING CHANGE`` bump the *major* version. All other messages
    bump the *patch* component.
    """

    header = message.strip().splitlines()[0].lower()
    lower = message.lower()
    type_part = header.split(":")[0]
    if "!" in type_part or "breaking change" in lower:
        part = "major"
    elif type_part.startswith("feat"):
        part = "minor"
    else:
        part = "patch"
    return bump_version(part)


def bump_version_from_git() -> str:
    """Read the latest git commit message and bump the version accordingly."""
    try:
        message = subprocess.check_output(
            ["git", "log", "-1", "--pretty=%B"], text=True
        ).strip()
    except Exception:
        message = ""
    return bump_version_from_message(message)


if __name__ == "__main__":
    print(bump_version_from_git())


## scalp/ws.py
"""Minimal websocket manager with heartbeat and auto-resubscribe.

This module provides a light-weight framework to maintain a realtime
connection to an exchange.  The actual network layer is expected to be
supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
manager handles retrying failed connections and periodically invoking the
``subscribe`` callback as a heartbeat.  This keeps the code fully testable
without opening real network sockets.
"""
from __future__ import annotations

import asyncio
import logging
from typing import Awaitable, Callable, Optional


class WebsocketManager:
    """Maintain a websocket connection with heartbeat and retry."""

    def __init__(
        self,
        connect: Callable[[], Awaitable[None]],
        subscribe: Callable[[], Awaitable[None]],
        *,
        heartbeat_interval: float = 30.0,
        max_retries: int = 3,
    ) -> None:
        self._connect = connect
        self._subscribe = subscribe
        self.heartbeat_interval = heartbeat_interval
        self.max_retries = max_retries
        self._heartbeat_task: Optional[asyncio.Task] = None

    async def run(self) -> None:
        """Open the connection retrying on failure."""
        retries = 0
        while True:
            try:
                await self._connect()
                await self._subscribe()
                self._heartbeat_task = asyncio.create_task(self._heartbeat())
                return
            except Exception as exc:  # pragma: no cover - network errors
                logging.error("websocket connect failed: %s", exc)
                retries += 1
                if retries > self.max_retries:
                    raise
                await asyncio.sleep(1)

    async def _heartbeat(self) -> None:
        """Send periodic heartbeats and resubscribe on failure."""
        while True:
            await asyncio.sleep(self.heartbeat_interval)
            try:
                await self._subscribe()
            except Exception as exc:  # pragma: no cover - network errors
                logging.warning("websocket heartbeat failed: %s", exc)
                await self.run()
                break

    async def stop(self) -> None:
        """Cancel the heartbeat task if it is running."""
        task = self._heartbeat_task
        if task and not task.done():
            task.cancel()
            try:
                await task
            except BaseException:  # pragma: no cover - cancellation
                pass
        self._heartbeat_task = None


## short_one_way.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Example script to open a one-way short on Bitget futures.

This standalone script signs and sends a market sell order using the
Bitget REST API. Environment variables required (defined in a `.env`
file alongside this script):

- ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
- ``BITGET_API_KEY``
- ``BITGET_API_SECRET``
- ``BITGET_API_PASSPHRASE``
- ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
- ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
- ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
- ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)

The script retrieves the current contract specification and price,
ensures account settings (one-way mode & leverage) and finally places a
market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.

The intent is purely demonstrational; use at your own risk.
"""

import base64
import hashlib
import hmac
import json
import os
import sys
import time
import uuid
from pathlib import Path

import requests

try:  # lazy dependency import for dotenv
    from dotenv import load_dotenv
except ImportError:  # pragma: no cover - installation fallback
    import subprocess

    subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
    from dotenv import load_dotenv

# load environment variables
load_dotenv(Path(__file__).resolve().parent / ".env")


def T(x):  # small helper used throughout configuration
    return x.strip() if isinstance(x, str) else x


BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
AK = T(os.getenv("BITGET_API_KEY"))
SK = T(os.getenv("BITGET_API_SECRET"))
PH = T(os.getenv("BITGET_API_PASSPHRASE"))
PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))

if not (AK and SK and PH):
    sys.exit("‚ùå .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")

print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional‚âà{NOTIONAL}USDT")


# ---------- signing helpers ----------
def sign_get(ts, path, params):
    qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
    pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
    return base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()


def sign_post(ts, path, body):
    body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
    pre = f"{ts}POST{path}{body_str}"
    sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
    return sig, body_str


def headers(sig, ts):
    return {
        "ACCESS-KEY": AK,
        "ACCESS-SIGN": sig,
        "ACCESS-TIMESTAMP": str(ts),
        "ACCESS-PASSPHRASE": PH,
        "ACCESS-RECV-WINDOW": "60000",
        "Content-Type": "application/json",
    }


def pick_price(d: dict):
    for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
        try:
            v = float(d.get(k))
            if v > 0:
                return v
        except Exception:
            pass
    return None


# ---------- public endpoints ----------
def get_contract_spec():
    r = requests.get(
        f"{BASE}/api/v2/mix/market/contracts",
        params={"productType": PT, "symbol": SYMB},
        timeout=12,
    )
    r.raise_for_status()
    arr = r.json().get("data") or []
    if not arr:
        raise RuntimeError("Contrat introuvable")
    return arr[0]


def get_price():
    # 1) ticker (obj/list) avec productType
    try:
        r = requests.get(
            f"{BASE}/api/v2/mix/market/ticker",
            params={"symbol": SYMB, "productType": PT},
            timeout=10,
        )
        r.raise_for_status()
        data = r.json().get("data")
        if isinstance(data, dict):
            p = pick_price(data)
            if p:
                return p
        if isinstance(data, list) and data:
            p = pick_price(data[0])
            if p:
                return p
    except requests.HTTPError as e:
        print("‚ö†Ô∏è ticker HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("‚ö†Ô∏è ticker err:", e)

    # 2) tickers (liste enti√®re)
    try:
        r = requests.get(
            f"{BASE}/api/v2/mix/market/tickers",
            params={"productType": PT},
            timeout=10,
        )
        r.raise_for_status()
        arr = r.json().get("data") or []
        row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
        p = pick_price(row or {})
        if p:
            return p
    except requests.HTTPError as e:
        print("‚ö†Ô∏è tickers HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("‚ö†Ô∏è tickers err:", e)

    # 3) candles 1m (close)
    try:
        # ``symbol`` must be provided as a query parameter; placing it in the
        # path triggers a 404 response from Bitget.
        r = requests.get(
            f"{BASE}/api/v2/mix/market/candles",
            params={"symbol": SYMB, "granularity": "1m"},
            timeout=10,
        )
        r.raise_for_status()
        arr = r.json().get("data") or []
        if arr:
            return float(arr[0][4])
    except requests.HTTPError as e:
        print("‚ö†Ô∏è candles HTTP:", e.response.status_code, e.response.text[:140])
    except Exception as e:
        print("‚ö†Ô∏è candles err:", e)

    raise RuntimeError("prix indisponible")


# ---------- private endpoints ----------
def check_accounts():
    path = "/api/v2/mix/account/accounts"
    ts = int(time.time() * 1000)
    params = {"productType": PT}
    sig = sign_get(ts, path, params)
    r = requests.get(BASE + path, params=params, headers=headers(sig, ts), timeout=12)
    print("accounts", r.status_code, r.text[:160])
    r.raise_for_status()
    j = r.json()
    if str(j.get("code")) not in ("00000", "0"):
        raise RuntimeError(j)


def set_position_mode_one_way():
    path = "/api/v2/mix/account/set-position-mode"
    ts = int(time.time() * 1000)
    body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
    sig, b = sign_post(ts, path, body)
    r = requests.post(BASE + path, headers=headers(sig, ts), data=b.encode(), timeout=12)
    print("set-position-mode(one-way)", r.status_code, r.text[:160])
    r.raise_for_status()


def set_leverage(lv: int = 2):
    path = "/api/v2/mix/account/set-leverage"
    ts = int(time.time() * 1000)
    body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
    sig, b = sign_post(ts, path, body)
    r = requests.post(BASE + path, headers=headers(sig, ts), data=b.encode(), timeout=12)
    print("set-leverage", r.status_code, r.text[:160])
    r.raise_for_status()


def place_one_way_sell(size_coin: float):
    """Ouvre un SHORT en one_way_mode (market SELL)."""
    path = "/api/v2/mix/order/place-order"
    ts = int(time.time() * 1000)
    body = {
        "symbol": SYMB,
        "productType": PT,
        "marginCoin": MC,
        "marginMode": "crossed",
        "posMode": "one_way_mode",
        "orderType": "market",
        "side": "sell",  # <-- SHORT
        "size": str(size_coin),
        "timeInForceValue": "normal",
        "clientOid": str(uuid.uuid4())[:32],
    }
    sig, b = sign_post(ts, path, body)
    r = requests.post(BASE + path, headers=headers(sig, ts), data=b.encode(), timeout=15)
    print("place-order(one-way SELL)", r.status_code, r.text[:220])
    r.raise_for_status()
    j = r.json()
    if str(j.get("code")) not in ("00000", "0"):
        raise RuntimeError(j)
    return j


# ---------- main ----------
def main():
    spec = get_contract_spec()
    min_usdt = float(spec.get("minTradeUSDT") or 5)
    min_num = float(spec.get("minTradeNum") or 0)
    size_place = int(spec.get("sizePlace") or 6)
    print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")

    px = get_price()
    print(f"Prix OK ‚âà {px}")

    check_accounts()
    set_position_mode_one_way()
    set_leverage(2)

    target = max(NOTIONAL, min_usdt)
    size = max(target / px, min_num)
    size = float(f"{size:.{size_place}f}")
    print(f"Taille={size} (target‚âà{target}USDT)")

    j = place_one_way_sell(size)
    print("‚úÖ SHORT OK")
    print(json.dumps(j, indent=2, ensure_ascii=False))


if __name__ == "__main__":  # pragma: no cover - script entrypoint
    main()


## signals/__init__.py
"""Signal generation utilities."""

from .generator import generate_signal

__all__ = ["generate_signal"]


## signals/generator.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

import pandas as pd

from data.indicators import compute_all

__all__ = ["generate_signal"]


def _quality_from_score(score: float) -> str:
    if score >= 0.8:
        return "A"
    if score >= 0.5:
        return "B"
    return "C"


def generate_signal(
    df: pd.DataFrame,
    *,
    trend_tf: Optional[pd.DataFrame] = None,
    confirm_tf: Optional[pd.DataFrame] = None,
    atr_mult: float = 1.0,
    trailing: bool = False,
    **_: Any,
) -> Optional[Dict[str, Any]]:
    """Generate a trading signal with confluence scoring.

    Parameters
    ----------
    df: pd.DataFrame
        Primary timeframe OHLCV data.
    trend_tf: pd.DataFrame, optional
        Higher timeframe used for trend filtering.
    confirm_tf: pd.DataFrame, optional
        Lower timeframe used for confirmation.
    atr_mult: float, optional
        Multiplier applied to ATR for stop/target calculation.
    trailing: bool, optional
        When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).

    Returns
    -------
    dict | None
        Dictionary describing the signal or ``None`` if no trade setup exists.
    """

    if df is None or len(df) < 2:
        return None

    df = compute_all(df)
    last = df.iloc[-1]

    conditions: List[bool] = []
    reasons: List[str] = []
    direction: Optional[str] = None

    # --- Basic trend via EMAs ----------------------------------------------
    if last["close"] > last["ema20"] > last["ema50"]:
        direction = "long"
        reasons.append("price_above_ema")
        conditions.append(True)
    elif last["close"] < last["ema20"] < last["ema50"]:
        direction = "short"
        reasons.append("price_below_ema")
        conditions.append(True)
    else:
        conditions.append(False)
        return None

    # --- RSI ---------------------------------------------------------------
    if direction == "long":
        cond = last["rsi"] > 55
        if cond:
            reasons.append("rsi_bullish")
        conditions.append(cond)
    else:
        cond = last["rsi"] < 45
        if cond:
            reasons.append("rsi_bearish")
        conditions.append(cond)

    # --- MACD --------------------------------------------------------------
    if direction == "long":
        cond = last["macd"] > last["macd_signal"]
        if cond:
            reasons.append("macd_bullish")
        conditions.append(cond)
    else:
        cond = last["macd"] < last["macd_signal"]
        if cond:
            reasons.append("macd_bearish")
        conditions.append(cond)

    # --- OBV momentum ------------------------------------------------------
    if len(df) >= 2:
        obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
        if obv_up:
            reasons.append("obv_trending")
        conditions.append(obv_up)

    # --- Trend timeframe filter -------------------------------------------
    if trend_tf is not None and len(trend_tf) >= 2:
        tdf = compute_all(trend_tf)
        ema50 = tdf["ema50"]
        slope = ema50.iloc[-1] - ema50.iloc[-2]
        if direction == "long":
            cond = slope > 0
            if cond:
                reasons.append("trend_up")
            conditions.append(cond)
        else:
            cond = slope < 0
            if cond:
                reasons.append("trend_down")
            conditions.append(cond)

    # --- Confirmation timeframe filter ------------------------------------
    if confirm_tf is not None and len(confirm_tf) > 0:
        cdf = compute_all(confirm_tf)
        rsi = cdf["rsi"].iloc[-1]
        if direction == "long":
            cond = rsi > 50
            if cond:
                reasons.append("confirm_rsi_bullish")
            conditions.append(cond)
        else:
            cond = rsi < 50
            if cond:
                reasons.append("confirm_rsi_bearish")
            conditions.append(cond)

    score = (
        sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
    )
    quality = _quality_from_score(score)

    atr = last.get("atr")
    if pd.isna(atr) or atr == 0:
        return None

    entry = float(last["close"])
    if direction == "long":
        sl = entry - atr * atr_mult
        tp = entry + atr * atr_mult * 2
    else:
        sl = entry + atr * atr_mult
        tp = entry - atr * atr_mult * 2

    result: Dict[str, Any] = {
        "direction": direction,
        "entry": entry,
        "sl": sl,
        "tp": tp,
        "score": round(score, 3),
        "reasons": reasons,
        "quality": quality,
    }

    if trailing:
        result["trail"] = atr * atr_mult

    return result


## tests/conftest.py
"""Test configuration and shared fixtures."""

import sys
import types
from pathlib import Path


# Ensure the project root is importable so tests can ``import bot``.
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))


# Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
# the real dependency during test collection. Individual tests patch the
# functions they need (``request``/``post``/``get``).
sys.modules.setdefault(
    "requests",
    types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
)



## tests/test_analyse_risque.py
import os
import sys
import types

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.SimpleNamespace(
    request=lambda *a, **k: None,
    post=lambda *a, **k: None,
    HTTPError=Exception,
)

from bot import analyse_risque  # noqa: E402


def make_contract_detail():
    return {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }


def test_analyse_risque_limits_and_leverage():
    contract_detail = make_contract_detail()
    # Risk level 1: leverage halved, limit 1 position
    open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=1)
    assert lev == 5
    assert vol == 0  # already one long position

    # Risk level 2: base leverage, limit 2 positions
    open_pos = [{"symbol": "BTC_USDT", "side": "long"},
                {"symbol": "BTC_USDT", "side": "long"}]
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=2)
    assert lev == 10
    assert vol == 0

    # Risk level 3: leverage doubled, no existing position
    open_pos = []
    vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
                               symbol="BTC_USDT", side="long", risk_level=3)
    assert lev == 20
    assert vol == 1


## tests/test_backtest.py
import pytest

import bot


def test_backtest_trades():
    trades = [
        {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
        {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
    ]
    pnl = bot.backtest_trades(trades, fee_rate=0.001)
    # Both trades: 10% - 0.2% fee = 9.8% each
    assert pnl == pytest.approx(19.6)


## tests/test_backtest_position.py
import os
import sys
import pytest

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from scalp.metrics import backtest_position


def test_backtest_position_long():
    prices = [100.0, 110.0, 120.0]
    assert backtest_position(prices, 0, 2, 1) is True


def test_backtest_position_short():
    prices = [100.0, 90.0, 80.0]
    assert backtest_position(prices, 0, 2, -1) is True


def test_backtest_position_incoherent():
    prices = [100.0, 110.0, 120.0]
    assert backtest_position(prices, 0, 2, -1) is False


def test_backtest_position_bad_indices():
    prices = [100.0, 110.0]
    with pytest.raises(ValueError):
        backtest_position(prices, 1, 0, 1)


## tests/test_bitget_futures_pairs.py
import json
from pathlib import Path
from typing import Any, Dict

import pytest

import bitget_futures_pairs as bfp


class DummyResponse:
    def __init__(self, status: int, payload: Dict[str, Any]):
        self.status_code = status
        self._payload = payload
        self.text = json.dumps(payload)

    def json(self):
        return self._payload


def test_fetch_contracts_success(monkeypatch):
    payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}

    def fake_get(url, params=None, timeout=0):
        return DummyResponse(200, payload)

    monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    contracts = bfp.fetch_contracts("USDT-FUTURES")
    assert contracts == payload["data"]


def test_fetch_contracts_error(monkeypatch):
    payload = {"code": "10001"}

    def fake_get(url, params=None, timeout=0):
        return DummyResponse(200, payload)

    monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    with pytest.raises(RuntimeError):
        bfp.fetch_contracts("USDT-FUTURES")


def test_normalize_rows():
    contracts = [
        {
            "symbol": "BTCUSDT",
            "baseCoin": "BTC",
            "quoteCoin": "USDT",
            "symbolType": "perpetual",
            "symbolStatus": "normal",
            "maxLever": "50",
            "minLever": "1",
            "minTradeNum": "0.001",
            "sizeMultiplier": "1",
            "pricePlace": "2",
            "volumePlace": "3",
            "launchTime": 0,
            "deliveryTime": 0,
        }
    ]
    rows = bfp.normalize_rows("USDT-FUTURES", contracts)
    assert rows[0]["symbol"] == "BTCUSDT"
    assert rows[0]["productType"] == "USDT-FUTURES"


def test_write_csv(tmp_path: Path):
    path = tmp_path / "pairs.csv"
    bfp.write_csv([], str(path))
    assert path.exists()
    content = path.read_text().splitlines()
    assert content[0].startswith("productType,")


## tests/test_bot_update.py
import logging
import bot


def test_update_displays_pairs(monkeypatch, caplog):
    def fake_send(client, top_n=20, tg_bot=None):
        assert (client, top_n, tg_bot) == ("cli", 5, "tg")
        return {"green": "BTC", "orange": "ETH", "red": "XRP"}

    monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
    with caplog.at_level(logging.INFO):
        payload = bot.update("cli", top_n=5, tg_bot="tg")
    assert payload["green"] == "BTC"
    assert "BTC" in caplog.text and "ETH" in caplog.text and "XRP" in caplog.text



## tests/test_break_even_stop.py
from scalp.trade_utils import break_even_stop


def test_break_even_stop_long() -> None:
    sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
    assert sl == 100
    sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
    assert sl == 95


def test_break_even_stop_short() -> None:
    sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
    assert sl == 100
    sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
    assert sl == 105


## tests/test_calc_pnl_pct.py
import os
import sys
import pytest
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from scalp.metrics import calc_pnl_pct


def test_calc_pnl_pct_long():
    assert calc_pnl_pct(100.0, 110.0, 1) == 10.0

def test_calc_pnl_pct_short():
    assert calc_pnl_pct(100.0, 90.0, -1) == 10.0


def test_calc_pnl_pct_with_fee():
    # 10% move minus 0.1%*2 fees = 9.8%
    assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)


## tests/test_check_config.py
import logging
from bot import check_config


def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
    monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
    monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
    monkeypatch.delenv("NOTIFY_URL", raising=False)
    with caplog.at_level(logging.INFO):
        check_config()
    messages = [r.getMessage() for r in caplog.records]
    assert any("BITGET_ACCESS_KEY" in m for m in messages)
    assert any("BITGET_SECRET_KEY" in m for m in messages)
    assert all("NOTIFY_URL" not in m for m in messages)


## tests/test_cli.py
"""Tests for the command line interface defined in :mod:`cli`."""

from __future__ import annotations

import cli


def test_opt_invokes_parallel_optimization(monkeypatch):
    """The ``opt`` command should call ``run_parallel_optimization``."""

    called = {}

    def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
        called["args"] = (pairs, tf, jobs)

    monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
    cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
    assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)


def test_walkforward_invokes_analysis(monkeypatch):
    """The ``walkforward`` command calls ``run_walkforward_analysis``."""

    called = {}

    def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
        called["args"] = (pair, tf, splits, train_ratio)

    monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
    cli.main(
        [
            "walkforward",
            "--pair",
            "BTCUSDT",
            "--tf",
            "1m",
            "--splits",
            "3",
            "--train-ratio",
            "0.8",
        ]
    )
    assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)


def test_live_invokes_async_pipeline(monkeypatch):
    """The ``live`` command must execute the async pipeline via ``asyncio.run``."""

    called = {}

    async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
        called["args"] = (pairs, list(tfs))

    monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
    cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
    assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])


def test_bump_version_invokes_helper(monkeypatch):
    """The ``bump-version`` command calls ``bump_version_from_git``."""

    called = {}

    def fake_bump():  # pragma: no cover - executed via CLI
        called["called"] = True
        return "0.1.0"

    monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
    cli.main(["bump-version"])
    assert called["called"] is True



## tests/test_client.py
import json
import hmac
import hashlib
import base64
import pytest
import bot
from bot import BitgetFuturesClient


@pytest.fixture(autouse=True)
def no_log_event(monkeypatch):
    monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)


def test_private_request_get_signature(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    called = {}

    def fake_request(method, url, params=None, headers=None, timeout=None):
        called["method"] = method
        called["url"] = url
        called["params"] = params
        called["headers"] = headers

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"success": True}

        return Resp()

    monkeypatch.setattr(bot.requests, "request", fake_request)

    resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
    assert resp["success"] is True
    qs = "a=1&b=2"
    prehash = f"1000GET/api/test?{qs}"
    expected = base64.b64encode(
        hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    ).decode()
    assert called["headers"]["ACCESS-SIGN"] == expected
    assert called["headers"]["ACCESS-KEY"] == "key"
    assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    assert called["params"] == {"b": "2", "a": "1"}


def test_private_request_post_signature(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    called = {}

    def fake_post(url, params=None, data=None, headers=None, timeout=None):
        called["url"] = url
        called["params"] = params
        called["data"] = data
        called["headers"] = headers

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"success": True}

        return Resp()

    monkeypatch.setattr(bot.requests, "post", fake_post)

    resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
    assert resp["success"] is True
    body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
    prehash = f"1000POST/api/test{body}"
    expected = base64.b64encode(
        hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    ).decode()
    assert called["headers"]["ACCESS-SIGN"] == expected
    assert called["headers"]["ACCESS-KEY"] == "key"
    assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    assert called["params"] is None
    assert called["data"].decode("utf-8") == body


def test_private_request_http_error(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")
    monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))

    class Resp:
        status_code = 418

        def raise_for_status(self):
            raise bot.requests.HTTPError("teapot")

        def json(self):
            return {"unused": True}

    monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())

    resp = client._private_request("GET", "/api/test")
    assert resp["success"] is False
    assert resp["status_code"] == 418
    assert "teapot" in resp["error"]


def test_get_assets_paper_trade():
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
    assets = client.get_assets()
    assert assets["success"] is True
    usdt = next((row for row in assets.get("data", []) if row.get("currency") == "USDT"), None)
    assert usdt and usdt["equity"] == 100.0


def test_http_client_context_manager(monkeypatch):
    import sys
    import importlib
    sys.modules.pop('requests', None)
    real_requests = importlib.import_module('requests')
    sys.modules['requests'] = real_requests
    import scalp.client as http_client
    importlib.reload(http_client)

    closed = {"count": 0}

    class DummySession:
        def mount(self, *a, **k):
            pass

        def request(self, *a, **k):
            class Resp:
                def raise_for_status(self):
                    pass

                def json(self):
                    return {}

                text = "{}"

            return Resp()

        def close(self):
            closed["count"] += 1

    monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())

    http = http_client.HttpClient("http://example.com")
    http.close()
    assert closed["count"] == 1

    closed["count"] = 0
    with http_client.HttpClient("http://example.com") as hc:
        hc.request("GET", "/")
    assert closed["count"] == 1


def test_get_kline_query_params(monkeypatch):
    """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
    query parameter. The previous implementation embedded the symbol in the
    path which resulted in a 404 from Bitget."""

    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_get(url, params=None, timeout=None):
        called["url"] = url
        called["params"] = params

        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {"data": []}

        return Resp()

    # Some tests replace ``bot.requests`` with a lightweight namespace that
    # doesn't define ``get``. ``raising=False`` ensures the attribute is added
    # even if missing so we can observe the call.
    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    client.get_kline("BTC_USDT", interval="Min1")

    assert called["url"].endswith("/api/v2/mix/market/candles")
    assert called["params"] == {
        "symbol": "BTCUSDT",
        "productType": "USDT-FUTURES",
        "granularity": "1m",
    }


def test_get_open_orders_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["params"] = params
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.get_open_orders("BTCUSDT_UMCBL")

    assert called["path"] == "/api/v2/mix/order/orders-pending"
    assert called["params"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
    }


def test_product_type_alias():
    client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
    assert client.product_type == "USDT-FUTURES"


def test_get_contract_detail_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    called = {}

    def fake_get(url, params=None, timeout=None):
        called["url"] = url
        called["params"] = params

        class Resp:
            status_code = 200

            def raise_for_status(self):
                pass

            def json(self):
                return {"data": []}

        return Resp()

    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    client.get_contract_detail("BTCUSDT_UMCBL")

    assert called["url"].endswith("/api/v2/mix/market/contracts")
    assert called["params"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
    }


def test_cancel_all_endpoint(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)

    called = {}

    def fake_private(self, method, path, params=None, body=None):
        called["method"] = method
        called["path"] = path
        called["params"] = params
        called["body"] = body
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")

    assert called["method"] == "POST"
    assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
    assert called["params"] == {
        "productType": "USDT-FUTURES",
        "symbol": "BTCUSDT",
        "marginCoin": "USDT",
    }
    assert called["body"] is None


def test_get_open_orders_paper_trade(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)

    called = {"count": 0}

    def fake_private(*a, **k):
        called["count"] += 1
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    resp = client.get_open_orders("BTCUSDT_UMCBL")

    assert resp["success"] is True
    assert resp["data"] == []
    assert called["count"] == 0


def test_cancel_all_paper_trade(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)

    called = {"count": 0}

    def fake_private(*a, **k):
        called["count"] += 1
        return {"success": True}

    monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)

    resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")

    assert resp["success"] is True
    assert called["count"] == 0


def test_get_kline_transforms_data(monkeypatch):
    client = BitgetFuturesClient("key", "secret", "https://test")

    def fake_get(url, params=None, timeout=None):
        class Resp:
            def raise_for_status(self):
                pass

            def json(self):
                return {
                    "data": [
                        ["1", "2", "3", "1", "2", "10", "20"],
                        ["2", "3", "4", "2", "3", "11", "21"],
                    ]
                }

        return Resp()

    monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)

    data = client.get_kline("BTC_USDT", interval="1m")
    kdata = data["data"]
    assert kdata["open"] == [2.0, 3.0]
    assert kdata["high"] == [3.0, 4.0]
    assert kdata["low"] == [1.0, 2.0]
    assert kdata["close"] == [2.0, 3.0]
    assert kdata["volume"] == [10.0, 11.0]
    assert kdata["quoteVolume"] == [20.0, 21.0]


## tests/test_compute_position_size.py
import os
import sys
import types
import pytest

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
sys.modules['requests'] = types.ModuleType('requests')
from bot import compute_position_size  # noqa: E402


def test_compute_position_size_basic():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
                                risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    assert vol == 1


def test_compute_position_size_symbol_not_found():
    contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
    with pytest.raises(ValueError):
        compute_position_size(contract_detail, equity_usdt=1000, price=500,
                                risk_pct=0.01, leverage=10, symbol="BTC_USDT")


def test_compute_position_size_invalid_price():
    contract_detail = {
        "data": [
            {
                "symbol": "BTC_USDT",
                "contractSize": 0.01,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(
        contract_detail,
        equity_usdt=1000,
        price=0,
        risk_pct=0.01,
        leverage=10,
        symbol="BTC_USDT",
    )
    assert vol == 0


## tests/test_dynamic_allocation.py
import math
from scalp.risk import adjust_risk_pct


def test_adjust_risk_pct_increase_decrease():
    base = 0.01
    assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
    assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base


def test_adjust_risk_pct_bounds():
    assert math.isclose(
        adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
    )
    assert math.isclose(
        adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
    )


## tests/test_env_loading.py
"""Tests for loading environment variables from ``notebook/.env``."""

from __future__ import annotations

import importlib
import os
import sys
from pathlib import Path


def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
    """Module should load variables from ``notebook/.env`` if present."""

    notebook = tmp_path / "notebook"
    spot = notebook / "spot"
    spot.mkdir(parents=True)
    bitget_bot = spot / "bitget_bot.py"
    bitget_bot.write_text("")
    env_file = notebook / ".env"
    env_file.write_text("BITGET_ACCESS_KEY=from_env\n")

    old = os.environ.pop("BITGET_ACCESS_KEY", None)
    monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
    import scalp

    importlib.reload(scalp)

    try:
        assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
    finally:
        env_file.unlink(missing_ok=True)
        if old is None:
            os.environ.pop("BITGET_ACCESS_KEY", None)
        else:
            os.environ["BITGET_ACCESS_KEY"] = old


## tests/test_heat_score.py
from scalp.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs


def test_heat_score_value():
    assert heat_score(2.0, 100.0) == 200.0
    assert heat_score(2.0, 100.0, news=True) == 400.0


def test_select_and_decorrelate_pairs():
    pairs = [
        {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
        {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
        {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
        {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
    ]
    top = select_top_heat_pairs(pairs, top_n=3)
    assert len(top) == 3
    corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
    selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
    syms = {p["symbol"] for p in selected}
    assert not ("A" in syms and "B" in syms)


## tests/test_indicators.py


import os
import sys
import pytest
sys.path.append(os.path.dirname(os.path.dirname(__file__)))




from scalp.metrics import calc_rsi, calc_atr, calc_macd


def test_calc_rsi_uptrend():
    prices = list(range(1, 16))  # strictly increasing
    assert calc_rsi(prices, period=14) == pytest.approx(100.0)


def test_calc_rsi_downtrend():
    prices = list(range(15, 0, -1))  # strictly decreasing
    assert calc_rsi(prices, period=14) == pytest.approx(0.0)



def test_calc_rsi_flat():
    prices = [1.0] * 15  # no movement
    assert calc_rsi(prices, period=14) == pytest.approx(50.0)



    highs = [10, 11, 12, 13, 14]
    lows = [9, 10, 11, 12, 13]
    closes = [9.5, 10.5, 11.5, 12.5, 13.5]
    assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)


def test_calc_macd_trend():
    prices = list(range(1, 60))
    macd, signal, hist = calc_macd(prices)
    assert macd > signal
    assert hist > 0


def test_calc_macd_flat():
    prices = [100.0] * 60
    macd, signal, hist = calc_macd(prices)
    assert macd == pytest.approx(0.0)
    assert signal == pytest.approx(0.0)
    assert hist == pytest.approx(0.0)



@pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
def test_calc_rsi_invalid_inputs(prices, period):
    with pytest.raises(ValueError):
        calc_rsi(prices, period=period)


@pytest.mark.parametrize(
    "highs, lows, closes, period",
    [
        ([1, 2, 3], [1, 2], [1, 2, 3], 2),
        ([1, 2], [1, 1], [1, 1], 3),
    ],
)
def test_calc_atr_invalid_inputs(highs, lows, closes, period):
    with pytest.raises(ValueError):
        calc_atr(highs, lows, closes, period=period)



## tests/test_notifier.py
import scalp.notifier as notifier


def test_notify_skips_without_url(monkeypatch):
    called = False

    def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
        nonlocal called
        called = True

    monkeypatch.delenv("NOTIFY_URL", raising=False)
    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    monkeypatch.setattr(notifier.requests, "post", fake_post)
    notifier.notify("test", {"foo": 1})
    assert called is False


def test_notify_posts(monkeypatch):
    payload = {}

    def fake_post(url, json=None, timeout=5):
        payload["url"] = url
        payload["json"] = json
        payload["timeout"] = timeout

    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    monkeypatch.setattr(notifier.requests, "post", fake_post)
    notifier.notify("evt", {"bar": 2})
    assert payload["url"] == "http://example.com"
    assert payload["json"]["event"] == "evt"
    assert payload["json"]["bar"] == 2


def test_notify_posts_telegram(monkeypatch):
    calls = []

    def fake_post(url, json=None, timeout=5):
        calls.append({"url": url, "json": json, "timeout": timeout})

    monkeypatch.delenv("NOTIFY_URL", raising=False)
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    monkeypatch.setattr(notifier.requests, "post", fake_post)

    notifier.notify("evt", {"bar": 2})

    assert len(calls) == 1
    assert calls[0]["url"] == "https://api.telegram.org/botabc/sendMessage"
    assert calls[0]["json"]["chat_id"] == "123"
    assert calls[0]["json"]["text"].startswith("evt")
    assert "bar" in calls[0]["json"]["text"]



def test_notify_posts_both(monkeypatch):
    calls = []

    def fake_post(url, json=None, timeout=5):
        calls.append({"url": url, "json": json, "timeout": timeout})

    monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    monkeypatch.setattr(notifier.requests, "post", fake_post)

    notifier.notify("evt", {"bar": 2})

    assert len(calls) == 2
    assert calls[0]["url"] == "http://example.com"
    assert calls[1]["url"] == "https://api.telegram.org/botabc/sendMessage"


def test_format_text_open_position():
    payload = {
        "side": "long",
        "symbol": "BTCUSDT",
        "vol": 1,
        "leverage": 10,

        "tp_usd": 5,
        "sl_usd": 2,
        "hold": "2h",
    }
    text = notifier._format_text("position_opened", payload)
    lines = text.splitlines()

    assert lines[0] == "Ouvre long üìà BTC"
    assert lines[1] == "Position: 1"
    assert lines[2] == "Levier: x10"
    assert "TP: +5 USDT" in lines
    assert "SL: -2 USDT" in lines
    assert any("Dur√©e pr√©vue: 2h" in line for line in lines)


def test_format_text_closed_position():
    payload = {
        "side": "short",
        "symbol": "ETHUSDT",
        "vol": 2,
        "leverage": 5,
        "pnl_usd": 12,
        "pnl_pct": 3,
        "duration": "1h",
    }
    text = notifier._format_text("position_closed", payload)
    lines = text.splitlines()
    assert lines[0] == "Ferme short üìâ ETH ‚úÖüéØ"
    assert lines[1] == "Position: 2"
    assert lines[2] == "Levier: x5"
    assert any("PnL: 12 USDT (3.00%)" in line for line in lines)
    assert any("Dur√©e: 1h" in line for line in lines)


def test_format_text_pair_list_and_start():
    assert notifier._format_text("bot_started") == "ü§ñ Bot d√©marr√©"
    text = notifier._format_text(
        "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
    )
    assert text == "Listing :\nüü¢ AAA\nüü† BBB\nüî¥ CCC"


def test_format_pair_list_helper():
    payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
    text = notifier._format_pair_list(payload)
    assert text == "Listing :\nüü¢ AAA\nüü† BBB\nüî¥ CCC"


def test_format_position_event_helper():
    payload = {
        "side": "long",
        "symbol": "BTCUSDT",
        "vol": 1,
        "leverage": 10,
        "tp_pct": 5,
        "sl_pct": 2,
    }
    text = notifier._format_position_event("position_opened", payload)
    assert text.splitlines()[0] == "Ouvre long üìà BTC"




## tests/test_pair_selection.py
import bot


def test_get_trade_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {"symbol": "BTC_USDT"},
                    {"symbol": "ETH_USDT"},
                ],
            }

    pairs = bot.get_trade_pairs(Client())
    assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]


def test_select_top_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {"symbol": "A", "volume": "1"},
                    {"symbol": "B", "volume": "3"},
                    {"symbol": "C", "volume": "2"},
                ],
            }

    top = bot.select_top_pairs(Client(), top_n=2)
    assert [p["symbol"] for p in top] == ["B", "C"]


def test_filter_trade_pairs():
    class Client:
        def get_ticker(self, symbol=None):
            return {
                "success": True,
                "data": [
                    {
                        "symbol": "AAA",
                        "volume": "6000000",
                        "bidPrice": "100",
                        "askPrice": "100.03",
                    },  # spread ~3 bps
                    {
                        "symbol": "BBB",
                        "volume": "10000000",
                        "bidPrice": "50",
                        "askPrice": "50.1",
                    },  # spread ~200 bps
                    {
                        "symbol": "CCC",
                        "volume": "7000000",
                        "bidPrice": "10",
                        "askPrice": "10.01",
                    },  # spread ~100 bps
                    {
                        "symbol": "DDD",
                        "volume": "4000000",
                        "bidPrice": "20",
                        "askPrice": "20.01",
                    },  # volume trop faible
                ],
            }

    pairs = bot.filter_trade_pairs(
        Client(),
        volume_min=5_000_000,
        max_spread_bps=5,
    )
    assert [p["symbol"] for p in pairs] == ["AAA"]


def test_find_trade_positions(monkeypatch):
    class Client:
        def __init__(self):
            self.data = {
                "AAA": {"data": {"close": [1, 2, 3]}},
                "BBB": {"data": {"close": [3, 2, 1]}},
            }

        def get_kline(self, symbol, interval="1m"):
            return self.data[symbol]

    pairs = [
        {"symbol": "AAA", "lastPrice": "1"},
        {"symbol": "BBB", "lastPrice": "1"},
    ]

    monkeypatch.setattr(bot, "ema", lambda series, window: series)

    def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
        if last_fast > prev_fast:
            return 1
        if last_fast < prev_fast:
            return -1
        return 0

    monkeypatch.setattr(bot, "cross", fake_cross)

    signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
    assert signals == [
        {"symbol": "AAA", "signal": "long", "price": 1.0},
        {"symbol": "BBB", "signal": "short", "price": 1.0},
    ]


## tests/test_pairs.py
import bot


def test_send_selected_pairs(monkeypatch):
    sent = {}

    def fake_notify(event, payload=None):
        sent["event"] = event
        sent["payload"] = payload

    monkeypatch.setattr(bot, "notify", fake_notify)
    monkeypatch.setattr(
        bot,
        "filter_trade_pairs",
        lambda client, top_n=60: [
            {"symbol": "WIFUSDT", "volume": 10},
            {"symbol": "WIFUSDT", "volume": 9},
            {"symbol": "BTCUSD", "volume": 8},
            {"symbol": "BTCUSDT", "volume": 7},
            {"symbol": "DOGEUSDT", "volume": 6},
            {"symbol": "ETHUSDC", "volume": 5},
            {"symbol": "ETHUSDT", "volume": 4},
        ],
    )

    payload = bot.send_selected_pairs(object(), top_n=4)

    assert sent["event"] == "pair_list"
    assert sent["payload"]["green"] == "WIF"
    assert sent["payload"]["orange"] == "BTC"
    assert sent["payload"]["red"] == "DOGE, ETH"
    assert payload == sent["payload"]


def test_filter_trade_pairs_all_pairs(monkeypatch):
    class DummyClient:
        def get_ticker(self):
            return {
                "data": [
                    {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
                    {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
                ]
            }

    client = DummyClient()
    res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
    assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]



## tests/test_risk_manager.py
from scalp import RiskManager


def test_kill_switch_triggered() -> None:
    rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(-1.0)
    rm.record_trade(-1.5)
    assert rm.kill_switch is True


def test_profit_kill_switch_triggered() -> None:
    rm = RiskManager(
        max_daily_loss_pct=10.0,
        max_daily_profit_pct=3.0,
        max_positions=1,
        risk_pct=0.01,
    )
    rm.record_trade(1.5)
    rm.record_trade(1.6)
    assert rm.kill_switch is True


def test_pause_and_can_open() -> None:
    rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(-0.5)
    rm.record_trade(-0.6)
    rm.record_trade(-0.7)
    assert rm.pause_duration() == 15 * 60
    rm.record_trade(-0.8)
    rm.record_trade(-0.9)
    assert rm.pause_duration() == 60 * 60
    assert rm.can_open(0) is True
    assert rm.can_open(1) is False


def test_risk_pct_scaling() -> None:
    rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    rm.record_trade(1.0)
    rm.record_trade(1.0)
    assert rm.risk_pct > 0.01
    rm.record_trade(-1.0)
    rm.record_trade(-1.0)
    assert rm.risk_pct < 0.01


## tests/test_risk_utils.py
import pytest

from scalp.risk import calc_risk_amount, calc_position_size


def test_calc_risk_amount_basic():
    assert calc_risk_amount(1000, 0.01) == 10.0


def test_calc_position_size_basic():
    # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
    assert calc_position_size(1000, 0.01, 50) == 0.2


@pytest.mark.parametrize("equity,risk_pct", [
    (0, 0.01),
    (-100, 0.01),
    (1000, 0),
    (1000, -0.1),
    (1000, 1.5),
])
def test_calc_risk_amount_invalid(equity, risk_pct):
    with pytest.raises(ValueError):
        calc_risk_amount(equity, risk_pct)


@pytest.mark.parametrize("stop_distance", [0, -1])
def test_calc_position_size_invalid_stop(stop_distance):
    with pytest.raises(ValueError):
        calc_position_size(1000, 0.01, stop_distance)


## tests/test_slippage.py
from scalp.trade_utils import marketable_limit_price


def test_marketable_limit_price_buy_sell():
    price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
    assert price_buy == 10.0 * 1.001
    price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
    assert price_sell == 9.9 * (1 - 0.001)


## tests/test_strategy_v2.py
import pytest

from scalp import strategy
from scalp.trade_utils import trailing_stop, should_scale_in, timeout_exit


def make_ohlcv(n=60, start=100, step=1):
    closes = [start + i * step for i in range(n)]
    highs = [c + 1 for c in closes]
    lows = [c - 1 for c in closes]
    vols = [1 for _ in closes]
    return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}


def test_generate_signal_atr_adaptation(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    # patches for deterministic RSI values
    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    # low ATR -> signal disabled
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig is None

    # high ATR -> size reduced
    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig and sig.side == "long"
    assert sig.qty == 50


def test_generate_signal_short_with_filters(monkeypatch):
    base = make_ohlcv(start=200, step=-2)
    ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
    ohlcv_1h = make_ohlcv(start=200, step=-2)

    rsi_vals = iter([40, 59, 61])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
        tick_ratio_buy=0.4,
    )
    assert sig and sig.side == "short"
    assert sig.qty == 100


def test_trailing_and_timeout():
    # trailing stop
    sl = trailing_stop("long", current_price=110, atr=10, sl=90)
    assert sl == pytest.approx(102.5)
    # scaling
    assert should_scale_in(100, 105, 100, 10, "long") is True
    assert should_scale_in(100, 95, 100, 10, "short") is True
    # timeout
    assert timeout_exit(0, 20, 100, 99, "long", progress_min=15, timeout_min=30)


def test_generate_signal_macd_filter(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
    monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
    )
    assert sig is None



def test_generate_signal_trend_ema_filter(monkeypatch):
    base = make_ohlcv(step=2)
    ohlcv_15 = make_ohlcv(n=15, step=2)
    ohlcv_1h = make_ohlcv(step=2)

    rsi_vals = iter([60, 41, 39])
    monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)

    orig_ema = strategy.ema

    def fake_ema(series, window):
        if window == 200:
            return [x + 1000 for x in orig_ema(series, window)]
        return orig_ema(series, window)

    monkeypatch.setattr(strategy, "ema", fake_ema)

    sig = strategy.generate_signal(
        "AAA",
        base,
        equity=1_000,
        risk_pct=0.01,
        ohlcv_15m=ohlcv_15,
        ohlcv_1h=ohlcv_1h,
        order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
        tick_ratio_buy=0.6,
        trend_ema_period=200,
    )
    assert sig is None
    

## tests/test_telegram_bot.py
from scalp.telegram_bot import TelegramBot


class DummyClient:

    def __init__(self):
        self.closed = []
        self.closed_all = False


    def get_assets(self):
        return {"data": [{"currency": "USDT", "equity": 123.45}]}

    def get_positions(self):
        return {
            "data": [
                {
                    "symbol": "BTC_USDT",
                    "side": "long",
                    "vol": 2,
                    "pnl_usd": 1.0,
                    "pnl_pct": 5.0,
                }
            ]
        }

    def close_position(self, sym):
        self.closed.append(sym)

    def close_all_positions(self):
        self.closed_all = True



class DummyRiskMgr:

    def __init__(self):
        self.reset_called = False

    def reset_day(self):
        self.reset_called = True


class DummyRequests:
    def __init__(self):
        self.posts = []

    def post(self, url, json=None, timeout=5):
        self.posts.append((url, json))

    def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
        return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()


def make_bot(config=None, requests_module=None):
    cfg = {"RISK_LEVEL": 2}
    if config:
        cfg.update(config)
    if requests_module is None:
        requests_module = DummyRequests()
    return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)


def test_handle_balance():
    bot = make_bot()

    resp, kb = bot.handle_callback("balance", 0.0)
    assert "123.45" in resp
    assert kb == bot.main_keyboard



def test_handle_positions():
    bot = make_bot()
    resp, _ = bot.handle_callback("positions", 0.0)
    assert "BTC" in resp
    assert "PnL" in resp


def test_handle_positions_zero_pnl():
    bot = make_bot()

    def zero_positions():
        return {
            "data": [
                {
                    "symbol": "BTC_USDT",
                    "side": "long",
                    "vol": 1,
                    "pnl_usd": 0.0,
                    "pnl_pct": 0.0,
                }
            ]
        }

    bot.client.get_positions = zero_positions
    resp, _ = bot.handle_callback("positions", 0.0)
    assert "PnL: 0.0 USDT" in resp



def test_handle_pnl():
    bot = make_bot()
    resp, _ = bot.handle_callback("pnl", 5.0)

    assert "5.0" in resp


def test_handle_risk_change():
    bot = make_bot()

    resp, kb = bot.handle_callback("risk_red", 0.0)
    assert "3" in resp
    assert bot.config["RISK_LEVEL"] == 3
    assert kb == bot.main_keyboard


def test_risk_menu():
    bot = make_bot()
    resp, kb = bot.handle_callback("risk", 0.0)
    assert "risque" in resp.lower()
    assert kb == bot.risk_keyboard



def test_stop_menu_and_actions():
    bot = make_bot()
    resp, kb = bot.handle_callback("stop", 0.0)
    assert any(
        btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
    )
    assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
    resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
    assert "ferm√©e" in resp.lower()
    assert bot.client.closed == ["BTC_USDT"]
    resp, _ = bot.handle_callback("stop_all", 0.0)
    assert bot.client.closed_all is True


def test_handle_unknown():
    bot = make_bot()
    resp, kb = bot.handle_callback("foobar", 0.0)
    assert resp is None
    assert kb is None


def test_reset_all():
    bot = make_bot()
    resp, kb = bot.handle_callback("reset_all", 0.0)
    assert "r√©initialis√©s" in resp.lower()
    assert bot.risk_mgr.reset_called is True
    assert bot.client.closed_all is True
    assert kb == bot.settings_keyboard


def test_shutdown_bot():
    bot = make_bot()
    resp, kb = bot.handle_callback("shutdown", 0.0)
    assert "arr√™t" in resp.lower()
    assert bot.stop_requested is True
    assert kb == bot.settings_keyboard


def test_start_sends_menu():
    req = DummyRequests()
    make_bot(requests_module=req)
    assert req.posts
    text = req.posts[0][1]["text"]
    assert "Solde" in text and "PnL session" in text


def test_settings_menu_and_reset_risk():
    bot = make_bot()
    resp, kb = bot.handle_callback("settings", 0.0)
    assert "r√©glages" in resp.lower()
    assert kb == bot.settings_keyboard
    resp, kb = bot.handle_callback("reset_risk", 0.0)
    assert "risque" in resp.lower()
    assert bot.risk_mgr.reset_called is True
    assert kb == bot.settings_keyboard


def test_update_button(monkeypatch):
    bot = make_bot()
    called = {}

    def fake_update():
        called["called"] = True

    bot.update_pairs = fake_update
    resp, kb = bot.handle_callback("update", 0.0)
    assert called["called"] is True
    assert "mise √† jour" in resp.lower()
    assert kb == bot.main_keyboard


def test_stop_no_positions():
    bot = make_bot()
    bot.client.get_positions = lambda: {"data": []}
    resp, kb = bot.handle_callback("stop", 0.0)
    assert "aucune crypto" in resp.lower()
    assert kb == bot.settings_keyboard



## tests/test_utils.py
import pytest
from bot import ema, cross, compute_position_size, CONFIG


def test_ema_basic():
    data = [1, 2, 3, 4, 5]
    result = ema(data, 3)
    assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])


def test_cross_up_down_none():
    assert cross(3, 2, 1, 2) == 1  # up cross
    assert cross(0.5, 1, 2, 1) == -1  # down cross
    assert cross(2, 2, 2, 2) == 0  # no cross


def test_compute_position_size():
    detail = {
        "data": [
            {
                "symbol": CONFIG["SYMBOL"],
                "contractSize": 0.001,
                "volUnit": 1,
                "minVol": 1,
            }
        ]
    }
    vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
                                risk_pct=0.01, leverage=5)
    assert vol == 1


def test_compute_position_size_missing_symbol():
    with pytest.raises(ValueError):
        compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)


## tests/test_version.py
import pytest
from scalp import version


def test_get_version(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("1.2.3")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.get_version() == "1.2.3"


def test_bump_version(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"

    vfile.write_text("0.1.2\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.bump_version("minor") == "0.2.0"
    assert vfile.read_text().strip() == "0.2.0"


def test_bump_version_invalid_part(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("0.1.0\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    with pytest.raises(ValueError):
        version.bump_version("foo")


def test_bump_from_message(monkeypatch, tmp_path):
    vfile = tmp_path / "VERSION"
    vfile.write_text("1.0.0\n")
    monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    assert version.bump_version_from_message("feat: add x") == "1.1.0"
    assert version.bump_version_from_message("fix: bug") == "1.1.1"
    assert version.bump_version_from_message("feat!: major change") == "2.0.0"



## tests/test_walk_forward.py
from scalp.backtest import walk_forward_windows


def test_walk_forward_windows():
    data = list(range(10))
    windows = list(walk_forward_windows(data, train=4, test=2))
    assert windows == [
        ([0, 1, 2, 3], [4, 5]),
        ([2, 3, 4, 5], [6, 7]),
        ([4, 5, 6, 7], [8, 9]),
    ]


## tests/test_ws.py
import asyncio

from scalp.ws import WebsocketManager


def test_websocket_manager_stop():
    async def connect():
        return None

    async def subscribe():
        return None

    ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)

    async def run_and_stop():
        await ws.run()
        assert ws._heartbeat_task is not None
        await ws.stop()
        assert ws._heartbeat_task is None

    asyncio.run(run_and_stop())


