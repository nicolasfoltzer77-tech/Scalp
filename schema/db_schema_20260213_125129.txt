=== SQLITE SCHEMA EXPORT ===
Timestamp: 20260213_125129
Root: /opt/scalp

----------------------------------------
DATABASE: a.db
----------------------------------------
CREATE TABLE ohlcv_5m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE ohlcv_15m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE ohlcv_30m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE VIEW v_ohlcv_freshness AS
SELECT
    instId,
    MAX(ts) AS ts,
    (strftime('%s','now') * 1000 - MAX(ts)) AS age_ms
FROM ohlcv_5m
GROUP BY instId
/* v_ohlcv_freshness(instId,ts,age_ms) */;
CREATE INDEX idx_ohlcv5_inst_ts ON ohlcv_5m(instId, ts);
CREATE INDEX idx_ohlcv15_inst_ts ON ohlcv_15m(instId, ts);
CREATE INDEX idx_ohlcv30_inst_ts ON ohlcv_30m(instId, ts);
CREATE TABLE ctx_A (
    instId TEXT PRIMARY KEY,
    ts_updated INTEGER,

    trend_5m   TEXT,
    trend_15m  TEXT,
    trend_30m  TEXT,

    score_5m   REAL,
    score_15m  REAL,
    score_30m  REAL,

    score_final REAL,

    p_buy  REAL,
    p_sell REAL,
    p_hold REAL,

    ctx TEXT
, score_A REAL DEFAULT 0.5);
CREATE VIEW v_ctx_overview AS
SELECT
    instId,
    DATETIME(ts_updated/1000,'unixepoch','localtime') AS ts,
    score_5m,
    score_15m,
    score_30m,
    score_final,
    CASE
        WHEN score_final IS NOT NULL THEN
            ROUND( exp(score_final/0.35)
                / (exp(score_final/0.35) + 1 + exp(-score_final/0.35)), 6 )
    END AS p_buy,
    CASE
        WHEN score_final IS NOT NULL THEN
            ROUND( exp(-score_final/0.35)
                / (exp(score_final/0.35) + 1 + exp(-score_final/0.35)), 6 )
    END AS p_sell,
    CASE
        WHEN score_final IS NOT NULL THEN
            ROUND( 1
                - (exp(score_final/0.35)
                   / (exp(score_final/0.35) + 1 + exp(-score_final/0.35)))
                - (exp(-score_final/0.35)
                   / (exp(score_final/0.35) + 1 + exp(-score_final/0.35))), 6 )
    END AS p_hold,
    ctx
FROM ctx_A
ORDER BY instId
/* v_ctx_overview(instId,ts,score_5m,score_15m,score_30m,score_final,p_buy,p_sell,p_hold,ctx) */;
CREATE TABLE feat_5m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    ema9 REAL,
    ema21 REAL,
    ema50 REAL,
    macd REAL,
    macdsignal REAL,
    macdhist REAL,
    rsi REAL,
    atr REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE feat_15m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    ema9 REAL,
    ema21 REAL,
    ema50 REAL,
    macd REAL,
    macdsignal REAL,
    macdhist REAL,
    rsi REAL,
    atr REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE feat_30m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    ema9 REAL,
    ema21 REAL,
    ema50 REAL,
    macd REAL,
    macdsignal REAL,
    macdhist REAL,
    rsi REAL,
    atr REAL,
    PRIMARY KEY(instId, ts)
);
CREATE VIEW v_ctx_latest AS
SELECT
    o.instId                         AS instId,
    o.ctx                            AS ctx,
    o.score_final                    AS score_C,
    o.ts                             AS ts_updated
FROM v_ctx_overview o
/* v_ctx_latest(instId,ctx,score_C,ts_updated) */;
CREATE VIEW v_ctx_signal_market_ok AS
SELECT
    c.instId,
    c.ctx,
    c.score_C,
    c.side,
    c.ctx_ok,
    c.ts_updated
FROM snap_ctx c
WHERE c.instId IN (
    SELECT instId
    FROM market_latest
    WHERE
        -- flags stricts market
        staleness_ms <= 1000
        AND ticks_5s >= 5
        AND spread_bps <= 5.0
);
CREATE VIEW v_ctx_market_stats AS
SELECT
    COUNT(*)                                AS ctx_tested,
    SUM(ctx_ok)                             AS ctx_ok,

    SUM(ctx = 'bullish')                    AS bull_total,
    SUM(ctx = 'bullish' AND ctx_ok = 1)     AS bull_ok,

    SUM(ctx = 'bearish')                    AS bear_total,
    SUM(ctx = 'bearish' AND ctx_ok = 1)     AS bear_ok,

    SUM(ctx NOT IN ('bullish','bearish'))   AS flat_total,
    SUM(ctx NOT IN ('bullish','bearish') AND ctx_ok = 1) AS flat_ok
FROM v_ctx_signal_market_ok;
CREATE VIEW v_atr_latest_5m AS
SELECT
    f.instId,
    f.atr      AS atr_5m,
    f.ts       AS ts_5m,
    (strftime('%s','now')*1000 - f.ts) AS age_5m_ms
FROM feat_5m f
JOIN (
    SELECT instId, MAX(ts) AS ts
    FROM feat_5m
    GROUP BY instId
) last
ON f.instId = last.instId
AND f.ts = last.ts
/* v_atr_latest_5m(instId,atr_5m,ts_5m,age_5m_ms) */;
CREATE VIEW v_atr_latest_15m AS
SELECT
    f.instId,
    f.atr      AS atr_15m,
    f.ts       AS ts_15m,
    (strftime('%s','now')*1000 - f.ts) AS age_15m_ms
FROM feat_15m f
JOIN (
    SELECT instId, MAX(ts) AS ts
    FROM feat_15m
    GROUP BY instId
) last
ON f.instId = last.instId
AND f.ts = last.ts
/* v_atr_latest_15m(instId,atr_15m,ts_15m,age_15m_ms) */;
CREATE VIEW v_atr_latest_30m AS
SELECT
    f.instId,
    f.atr      AS atr_30m,
    f.ts       AS ts_30m,
    (strftime('%s','now')*1000 - f.ts) AS age_30m_ms
FROM feat_30m f
JOIN (
    SELECT instId, MAX(ts) AS ts
    FROM feat_30m
    GROUP BY instId
) last
ON f.instId = last.instId
AND f.ts = last.ts
/* v_atr_latest_30m(instId,atr_30m,ts_30m,age_30m_ms) */;
CREATE VIEW v_atr_context_test AS
WITH
atr_5m AS (
    SELECT instId, atr, ts
    FROM feat_5m
),
atr_15m AS (
    SELECT instId, atr, ts
    FROM feat_15m
),
atr_30m AS (
    SELECT instId, atr, ts
    FROM feat_30m
),
joined AS (
    SELECT
        a5.instId,
        a5.atr  AS atr_5m,
        a15.atr AS atr_15m,
        a30.atr AS atr_30m,
        a5.ts   AS ts_5m
    FROM atr_5m a5
    LEFT JOIN atr_15m a15
        ON a15.instId = a5.instId
       AND a15.ts = (
            SELECT MAX(ts)
            FROM feat_15m
            WHERE instId = a5.instId
        )
    LEFT JOIN atr_30m a30
        ON a30.instId = a5.instId
       AND a30.ts = (
            SELECT MAX(ts)
            FROM feat_30m
            WHERE instId = a5.instId
        )
)
SELECT
    instId,
    atr_5m,
    atr_15m,
    atr_30m,
    CASE
        WHEN atr_15m > 0 THEN atr_5m / atr_15m
        ELSE NULL
    END AS ratio_5m_15m,
    CASE
        WHEN atr_30m > 0 THEN atr_5m / atr_30m
        ELSE NULL
    END AS ratio_5m_30m,
    (strftime('%s','now') * 1000 - ts_5m) AS age_ms
FROM joined
/* v_atr_context_test(instId,atr_5m,atr_15m,atr_30m,ratio_5m_15m,ratio_5m_30m,age_ms) */;
CREATE VIEW v_atr_context AS
WITH
-- ------------------------------------------------------------
-- DERNIER ATR 5m
-- ------------------------------------------------------------
a5 AS (
    SELECT
        f.instId,
        f.atr       AS atr_5m,
        f.ts        AS ts_5m
    FROM feat_5m f
    JOIN (
        SELECT instId, MAX(ts) AS ts
        FROM feat_5m
        GROUP BY instId
    ) m
      ON f.instId = m.instId
     AND f.ts     = m.ts
),

-- ------------------------------------------------------------
-- DERNIER ATR 15m
-- ------------------------------------------------------------
a15 AS (
    SELECT
        f.instId,
        f.atr       AS atr_15m,
        f.ts        AS ts_15m
    FROM feat_15m f
    JOIN (
        SELECT instId, MAX(ts) AS ts
        FROM feat_15m
        GROUP BY instId
    ) m
      ON f.instId = m.instId
     AND f.ts     = m.ts
),

-- ------------------------------------------------------------
-- DERNIER ATR 30m
-- ------------------------------------------------------------
a30 AS (
    SELECT
        f.instId,
        f.atr       AS atr_30m,
        f.ts        AS ts_30m
    FROM feat_30m f
    JOIN (
        SELECT instId, MAX(ts) AS ts
        FROM feat_30m
        GROUP BY instId
    ) m
      ON f.instId = m.instId
     AND f.ts     = m.ts
)

-- ------------------------------------------------------------
-- CONTEXTE FINAL
-- ------------------------------------------------------------
SELECT
    a5.instId,

    a5.atr_5m,
    a15.atr_15m,
    a30.atr_30m,

    CASE
        WHEN a15.atr_15m > 0 THEN a5.atr_5m / a15.atr_15m
        ELSE NULL
    END AS ratio_5m_15m,

    CASE
        WHEN a30.atr_30m > 0 THEN a5.atr_5m / a30.atr_30m
        ELSE NULL
    END AS ratio_5m_30m,

    (strftime('%s','now')*1000 - a5.ts_5m) AS age_ms

FROM a5
LEFT JOIN a15 ON a5.instId = a15.instId
LEFT JOIN a30 ON a5.instId = a30.instId
/* v_atr_context(instId,atr_5m,atr_15m,atr_30m,ratio_5m_15m,ratio_5m_30m,age_ms) */;
CREATE VIEW v_ctx_signal AS
WITH base AS (
    SELECT
        c.instId,
        c.ctx,                -- bullish / bearish / flat
        c.score_C,
        c.ts_updated,
        a.atr_5m,
        a.atr_15m,
        a.atr_30m,
        a.ratio_5m_15m,
        a.ratio_5m_30m,
        a.age_ms
    FROM v_ctx_latest c
    LEFT JOIN v_atr_context a
        ON a.instId = c.instId
),
vol AS (
    SELECT *,
        CASE
            WHEN ratio_5m_15m IS NULL THEN 'UNKNOWN'
            WHEN ratio_5m_15m < 0.55 THEN 'COMPRESS'
            WHEN ratio_5m_15m > 1.30 THEN 'EXPAND'
            ELSE 'NORMAL'
        END AS vol_regime
    FROM base
)
SELECT
    instId,
    ctx,
    score_C,
    ts_updated,

    CASE
        WHEN ctx='bullish' AND score_C >  0.30 THEN 'buy'
        WHEN ctx='bearish' AND score_C < -0.30 THEN 'sell'
        ELSE NULL
    END AS side,

    CASE
        WHEN ctx IN ('bullish','bearish') AND ABS(score_C) >= 0.30 THEN 1
        ELSE 0
    END AS ctx_ok,

    atr_5m,
    atr_15m,
    atr_30m,
    ratio_5m_15m,
    ratio_5m_30m,
    vol_regime,

    CASE
        WHEN ctx IN ('bullish','bearish')
         AND ABS(score_C) >= 0.30
         AND vol_regime != 'UNKNOWN'
        THEN 1
        ELSE 0
    END AS ctx_ok_final,

    age_ms
FROM vol
/* v_ctx_signal(instId,ctx,score_C,ts_updated,side,ctx_ok,atr_5m,atr_15m,atr_30m,ratio_5m_15m,ratio_5m_30m,vol_regime,ctx_ok_final,age_ms) */;

----------------------------------------
DATABASE: analytics.db
----------------------------------------
CREATE TABLE factor_stats (
    instId TEXT,
    side TEXT,
    reason TEXT,
    scoreA_bucket INTEGER,
    scoreB_bucket INTEGER,
    hour_bucket INTEGER,
    n_trades INTEGER,
    wins INTEGER,
    pnl_net_sum REAL,
    pnl_net_avg REAL,
    wr_local REAL,
    granularity INTEGER,
    PRIMARY KEY(instId, side, reason, scoreA_bucket, scoreB_bucket, hour_bucket)
);
CREATE TABLE exposure_scores (
    instId        TEXT,
    side          TEXT,
    ctx           TEXT,
    scoreB_bucket INTEGER,
    hour_bucket   INTEGER,
    n_trades      INTEGER,
    winrate       REAL,
    pnl_net_avg   REAL,
    score         REAL,
    last_update   INTEGER,
    PRIMARY KEY(instId, side, ctx, scoreB_bucket, hour_bucket)
);
CREATE VIEW v_scores_for_opener AS
SELECT
    instId,
    side,
    ctx,
    scoreB_bucket,
    hour_bucket,
    score
FROM exposure_scores
/* v_scores_for_opener(instId,side,ctx,scoreB_bucket,hour_bucket,score) */;
CREATE VIEW v_signal_timing AS
SELECT
    uid,
    instId,
    side,
    reason,
    ts_signal,
    price_signal,
    peak_ts,
    peak_price,
    delta_t_ms,
    delta_price,
    delta_price_pct,
    score_T,
    ts_updated
FROM signal_timing
ORDER BY ts_updated DESC;
CREATE TABLE historical_scores_v2 (
    instId          TEXT NOT NULL,    -- BTCUSDT
    side            TEXT NOT NULL,    -- buy / sell
    reason          TEXT NOT NULL,    -- BREAKOUT, MOMENTUM, ...

    ctx_dir         TEXT NOT NULL,    -- bullish / bearish / neutral
    ctx_strength    TEXT NOT NULL,    -- strong / medium / weak

    signal_strength TEXT NOT NULL,    -- strong / medium / weak

    day_bucket      TEXT NOT NULL,    -- midweek / friday / weekend / monday
    hour_bucket     INTEGER NOT NULL, -- 0–23

    vol_bucket      TEXT NOT NULL,    -- low / medium / high (NOTE: NOT NULL)
    of_bucket       TEXT NOT NULL,    -- supporting / neutral / contradicting

    total_trades    INTEGER NOT NULL,
    win_rate        REAL NOT NULL,    -- [0,1]
    avg_pnl         REAL NOT NULL,
    median_pnl      REAL NOT NULL,

    score_H         REAL NOT NULL,    -- final score [0,1]

    last_update     INTEGER NOT NULL,

    PRIMARY KEY (
        instId,
        side,
        reason,
        ctx_dir,
        ctx_strength,
        signal_strength,
        day_bucket,
        hour_bucket,
        vol_bucket,
        of_bucket
    )
);
CREATE VIEW v_score_H AS
SELECT
    instId,
    side,
    reason,
    ctx_dir,
    ctx_strength,
    signal_strength,
    day_bucket,
    hour_bucket,
    vol_bucket,
    of_bucket,
    total_trades,
    win_rate,
    avg_pnl,
    median_pnl,
    score_H,
    last_update
FROM historical_scores_v2
ORDER BY last_update DESC
/* v_score_H(instId,side,reason,ctx_dir,ctx_strength,signal_strength,day_bucket,hour_bucket,vol_bucket,of_bucket,total_trades,win_rate,avg_pnl,median_pnl,score_H,last_update) */;
CREATE VIEW v_ctx_bucket AS
SELECT
    instId,
    ctx AS ctx_dir,
    CASE
        WHEN score_A >= 0.70 THEN 'strong'
        WHEN score_A <= 0.30 THEN 'weak'
        ELSE 'mid'
    END AS score_C_bucket
FROM ctx_A;
CREATE VIEW v_signal_bucket AS
SELECT
    uid,
    instId,
    side,
    reason,
    score_B,
    CASE
        WHEN score_B >= 0.70 THEN 'strong'
        WHEN score_B <= 0.30 THEN 'weak'
        ELSE 'mid'
    END AS score_S_bucket
FROM signals_B;
CREATE VIEW v_atr_bucket AS
SELECT
    instId,
    CASE
        WHEN atr_signal <= 0.5 THEN 'low'
        WHEN atr_signal <= 1.5 THEN 'mid'
        ELSE 'high'
    END AS atr_bucket
FROM trades_recorded;
CREATE VIEW v_orderflow_bucket AS
SELECT
    instId,
    CASE
        WHEN imbalance >= 0.20 THEN 'strong_buy'
        WHEN imbalance <= -0.20 THEN 'strong_sell'
        ELSE 'neutral'
    END AS of_bucket
FROM v_orderflow_features;
CREATE TABLE historical_scores (
    instId TEXT NOT NULL,
    side TEXT NOT NULL,
    type_signal TEXT NOT NULL,

    ctx TEXT NOT NULL,
    score_C REAL NOT NULL,
    score_S REAL NOT NULL,
    score_OF REAL,
    atr_bucket TEXT,

    win_rate REAL,
    pnl_avg REAL,
    score_H REAL NOT NULL,

    ts_updated INTEGER NOT NULL,

    PRIMARY KEY (instId, side, type_signal, ctx, score_C, score_S)
);
CREATE VIEW v_historical AS
SELECT
    instId,
    side,
    type_signal,
    ctx,
    score_C,
    score_S,
    score_OF,
    atr_bucket,
    win_rate,
    pnl_avg,
    score_H,
    score_H AS score_H_final,
    ts_updated
FROM historical_scores
ORDER BY ts_updated DESC
/* v_historical(instId,side,type_signal,ctx,score_C,score_S,score_OF,atr_bucket,win_rate,pnl_avg,score_H,score_H_final,ts_updated) */;
CREATE TABLE signal_timing (
    uid TEXT PRIMARY KEY,
    instId TEXT NOT NULL,
    side TEXT NOT NULL,
    type_signal TEXT NOT NULL,

    ts_signal INTEGER NOT NULL,
    price_signal REAL NOT NULL,

    peak_ts INTEGER,
    peak_price REAL,
    delta_t_ms INTEGER,
    delta_price REAL,
    delta_price_pct REAL,

    score_T REAL,
    ts_updated INTEGER NOT NULL
);
CREATE VIEW v_timing AS
SELECT *
FROM signal_timing
ORDER BY ts_signal DESC
/* v_timing(uid,instId,side,type_signal,ts_signal,price_signal,peak_ts,peak_price,delta_t_ms,delta_price,delta_price_pct,score_T,ts_updated) */;
CREATE VIEW v_ctx_latest AS
SELECT
    instId,
    ctx,
    score_A AS score_C,
    ts_updated
FROM ctx_A
WHERE ts_updated = (
    SELECT MAX(ts_updated) FROM ctx_A c2 WHERE c2.instId = ctx_A.instId
);

----------------------------------------
DATABASE: audit_triggers.db
----------------------------------------
CREATE TABLE trigger_audit (
    uid TEXT PRIMARY KEY,
    instId TEXT NOT NULL,
    regime TEXT NOT NULL,            -- scalp | intraday

    ts_fire INTEGER NOT NULL,
    price_fire REAL NOT NULL,
    side TEXT NOT NULL,

    atr REAL NOT NULL,

    mfe REAL,
    mae REAL,

    mfe_atr REAL,
    mae_atr REAL,

    t_mfe_ms INTEGER,
    t_mae_ms INTEGER,

    valid INTEGER,                   -- 1 ou 0

    ts_audit INTEGER NOT NULL
);
CREATE INDEX idx_audit_regime ON trigger_audit(regime);
CREATE INDEX idx_audit_ts     ON trigger_audit(ts_fire);
CREATE INDEX idx_audit_instId ON trigger_audit(instId);
CREATE TABLE audit_triggers (
            uid            TEXT PRIMARY KEY,
            instId         TEXT NOT NULL,
            side           TEXT NOT NULL,
            trigger_status TEXT NOT NULL,
            price_entry    REAL NOT NULL,
            atr            REAL NOT NULL,
            mfe            REAL NOT NULL,
            mae            REAL NOT NULL,
            outcome        TEXT NOT NULL
        , entry_price REAL, mfe_atr REAL, mae_atr REAL, ts_trigger INTEGER, window_ms INTEGER, validated INTEGER, mfe_early REAL, mae_early REAL, ttl_ms INTEGER, life_ms INTEGER, outcome_early TEXT, ctx TEXT, score_ctx REAL);
CREATE INDEX idx_audit_uid ON audit_triggers(uid);
CREATE VIEW v_trigger_perf AS
SELECT
    instId,
    side,
    mfe_atr,
    mae_atr,
    outcome,
    window_ms/1000.0 AS life_s
FROM audit_triggers
/* v_trigger_perf(instId,side,mfe_atr,mae_atr,outcome,life_s) */;
CREATE VIEW v_trigger_audit_full AS
SELECT
    a.uid,
    a.instId,
    a.side,
    a.mfe_atr,
    a.mae_atr,
    a.outcome,
    a.window_ms/1000.0 AS life_s,

    s.reason,
    s.score_B,

    t.score_T,
    t.delta_t_ms,

    h.score_H
FROM audit_triggers a
LEFT JOIN signals_B      s ON s.uid = a.uid
LEFT JOIN signal_timing  t ON t.uid = a.uid
LEFT JOIN historical_scores_v2 h
       ON h.instId = a.instId
      AND h.side   = a.side;

----------------------------------------
DATABASE: b.db
----------------------------------------
CREATE TABLE feat_1m (
    instId TEXT,
    ts INTEGER,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    ema9 REAL, ema12 REAL, ema21 REAL, ema26 REAL, ema50 REAL,
    macd REAL, macdsignal REAL, macdhist REAL,
    rsi REAL, atr REAL,
    bb_mid REAL, bb_std REAL, bb_up REAL, bb_low REAL, bb_width REAL,
    mom REAL, roc REAL, slope REAL,
    ctx TEXT, plus_di REAL, minus_di REAL, adx REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE feat_3m(
  instId TEXT,
  ts INT,
  o REAL,
  h REAL,
  l REAL,
  c REAL,
  v REAL,
  ema9 REAL,
  ema12 REAL,
  ema21 REAL,
  ema26 REAL,
  ema50 REAL,
  macd REAL,
  macdsignal REAL,
  macdhist REAL,
  rsi REAL,
  atr REAL,
  bb_mid REAL,
  bb_std REAL,
  bb_up REAL,
  bb_low REAL,
  bb_width REAL,
  mom REAL,
  roc REAL,
  slope REAL,
  ctx TEXT
, plus_di REAL, minus_di REAL, adx REAL);
CREATE TABLE feat_5m(
  instId TEXT,
  ts INT,
  o REAL,
  h REAL,
  l REAL,
  c REAL,
  v REAL,
  ema9 REAL,
  ema12 REAL,
  ema21 REAL,
  ema26 REAL,
  ema50 REAL,
  macd REAL,
  macdsignal REAL,
  macdhist REAL,
  rsi REAL,
  atr REAL,
  bb_mid REAL,
  bb_std REAL,
  bb_up REAL,
  bb_low REAL,
  bb_width REAL,
  mom REAL,
  roc REAL,
  slope REAL,
  ctx TEXT
, plus_di REAL, minus_di REAL, adx REAL);
CREATE INDEX idx_feat1 ON feat_1m(instId, ts DESC);
CREATE INDEX idx_feat3 ON feat_3m(instId, ts DESC);
CREATE INDEX idx_feat5 ON feat_5m(instId, ts DESC);
CREATE VIEW v_feat_3m AS
SELECT *,
       (strftime('%s','now')*1000 - ts) AS age_ms
FROM feat_3m
/* v_feat_3m(instId,ts,o,h,l,c,v,ema9,ema12,ema21,ema26,ema50,macd,macdsignal,macdhist,rsi,atr,bb_mid,bb_std,bb_up,bb_low,bb_width,mom,roc,slope,ctx,plus_di,minus_di,adx,age_ms) */;
CREATE VIEW v_feat_5m AS
SELECT *,
       (strftime('%s','now')*1000 - ts) AS age_ms
FROM feat_5m
/* v_feat_5m(instId,ts,o,h,l,c,v,ema9,ema12,ema21,ema26,ema50,macd,macdsignal,macdhist,rsi,atr,bb_mid,bb_std,bb_up,bb_low,bb_width,mom,roc,slope,ctx,plus_di,minus_di,adx,age_ms) */;
CREATE VIEW v_feat_1m AS
SELECT
  f.instId,
  f.ts,
  f.o,
  f.h,
  f.l,
  f.c,
  f.v,
  f.ema9,
  f.ema12,
  f.ema21,
  f.ema26,
  f.ema50,
  f.macd,
  f.macdsignal,
  f.macdhist,
  f.rsi,
  f.atr,
  f.bb_mid,
  f.bb_std,
  f.bb_up,
  f.bb_low,
  f.bb_width,
  f.mom,
  f.roc,
  f.slope,
  f.ctx,
  f.plus_di,
  f.minus_di,
  f.adx,
  (strftime('%s','now')*1000 - f.ts) AS age_ms
FROM feat_1m f
JOIN (
  SELECT instId, MAX(ts) AS ts
  FROM feat_1m
  GROUP BY instId
) last
ON f.instId = last.instId
AND f.ts = last.ts
/* v_feat_1m(instId,ts,o,h,l,c,v,ema9,ema12,ema21,ema26,ema50,macd,macdsignal,macdhist,rsi,atr,bb_mid,bb_std,bb_up,bb_low,bb_width,mom,roc,slope,ctx,plus_di,minus_di,adx,age_ms) */;
CREATE VIEW v_range_1m AS
WITH w AS (
  SELECT
    instId,
    ts,
    MAX(h) OVER win AS high_20,
    MIN(l) OVER win AS low_20,
    atr,
    bb_width,
    AVG(bb_width) OVER win AS bb_width_avg,
    ROW_NUMBER() OVER (PARTITION BY instId ORDER BY ts DESC) AS rn
  FROM feat_1m
  WINDOW win AS (
    PARTITION BY instId
    ORDER BY ts
    ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
  )
)
SELECT
  instId,
  ts,
  high_20,
  low_20,
  atr,
  bb_width,
  CASE
    WHEN bb_width_avg IS NOT NULL
     AND bb_width < bb_width_avg * 0.85
    THEN 1
    ELSE 0
  END AS compression_ok
FROM w
WHERE rn = 1
/* v_range_1m(instId,ts,high_20,low_20,atr,bb_width,compression_ok) */;
CREATE VIEW v_atr_context AS
WITH
atr1 AS (
    SELECT instId, atr AS atr_1m, age_ms
    FROM v_feat_1m
),
atr3 AS (
    SELECT instId, atr AS atr_3m
    FROM v_feat_3m
),
atr5 AS (
    SELECT instId, atr AS atr_5m
    FROM v_feat_5m
),
rng AS (
    SELECT instId, compression_ok
    FROM v_range_1m
)
SELECT
    a1.instId,

    -- ATR par horizon
    a1.atr_1m,
    a3.atr_3m,
    a5.atr_5m,

    -- Ratios ATR (guards division)
    CASE
        WHEN a3.atr_3m > 0 THEN a1.atr_1m / a3.atr_3m
        ELSE NULL
    END AS ratio_1m_3m,

    CASE
        WHEN a5.atr_5m > 0 THEN a1.atr_1m / a5.atr_5m
        ELSE NULL
    END AS ratio_1m_5m,

    CASE
        WHEN a5.atr_5m > 0 THEN a3.atr_3m / a5.atr_5m
        ELSE NULL
    END AS ratio_3m_5m,

    -- Compression / contexte
    r.compression_ok,

    -- Fraîcheur
    a1.age_ms

FROM atr1 a1
LEFT JOIN atr3 a3 ON a1.instId = a3.instId
LEFT JOIN atr5 a5 ON a1.instId = a5.instId
LEFT JOIN rng  r  ON a1.instId = r.instId
/* v_atr_context(instId,atr_1m,atr_3m,atr_5m,ratio_1m_3m,ratio_1m_5m,ratio_3m_5m,compression_ok,age_ms) */;

----------------------------------------
DATABASE: budget.db
----------------------------------------
CREATE TABLE sqlite_sequence(name,seq);
CREATE VIEW v_exposure AS
SELECT
    instId,
    ROUND(SUM(CASE WHEN type='margin' THEN amount ELSE 0 END),6) AS margin,
    ROUND(SUM(CASE WHEN type='pnl_real' THEN amount ELSE 0 END),6) AS pnl_real
FROM ledger
GROUP BY instId
ORDER BY ABS(margin) DESC;
CREATE VIEW v_budget_overview AS
SELECT
  ROUND(balance,6) AS balance,
  ROUND(margin,6)  AS margin,
  ROUND(pnl_real,6) AS pnl_real,
  datetime(ts_update,'unixepoch','localtime') AS last_update
FROM budget_state;
CREATE TABLE balance (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    balance_usdt REAL NOT NULL
);
CREATE VIEW v_balance AS
SELECT balance_usdt
FROM balance
WHERE id = 1
/* v_balance(balance_usdt) */;
CREATE TABLE budget_state (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    equity REAL NOT NULL,
    margin_used REAL NOT NULL,
    free_balance REAL NOT NULL,
    exposure REAL NOT NULL,
    ts_ms INTEGER NOT NULL
);
CREATE TABLE budget_exposure (
    uid TEXT PRIMARY KEY,
    notional_engaged REAL NOT NULL,
    ts_update INTEGER NOT NULL
);

----------------------------------------
DATABASE: closer.db
----------------------------------------
CREATE TABLE trades_close (
    uid       TEXT PRIMARY KEY,
    instId    TEXT NOT NULL,
    price_exec REAL NOT NULL,
    ts_exec    INTEGER NOT NULL
);
CREATE TABLE closer (
    uid         TEXT    NOT NULL,
    exec_type   TEXT    NOT NULL,         -- 'partial' | 'close'
    side        TEXT    NOT NULL,
    qty         REAL    NOT NULL,
    price_exec  REAL,                     -- ⬅️ NULL autorisé (IMPORTANT)
    fee         REAL    DEFAULT 0.0,
    step        INTEGER DEFAULT 0,
    reason      TEXT,
    ts_exec     INTEGER NOT NULL,
    status      TEXT    NOT NULL,         -- *_stdby | *_done
    instId      TEXT,
    close_step  INTEGER DEFAULT 0, ratio REAL, qty_raw REAL, qty_norm REAL, reject_reason TEXT,
    PRIMARY KEY (uid, exec_type, step)
);
CREATE VIEW v_closer_for_gest AS
SELECT
    uid,
    ts_exec      AS ts_close,
    price_exec   AS price_close,
    NULL         AS pnl_usdt,
    NULL         AS pnl_pct,
    'closed'     AS status,
    NULL         AS reason_close
FROM trades_close
ORDER BY ts_exec ASC
/* v_closer_for_gest(uid,ts_close,price_close,pnl_usdt,pnl_pct,status,reason_close) */;
CREATE VIEW v_closer AS
SELECT
    uid,
    instId,
    exec_type,
    side,
    qty,
    price_exec,
    fee,
    step,
    close_step,
    status,
    ts_exec
FROM closer
/* v_closer(uid,instId,exec_type,side,qty,price_exec,fee,step,close_step,status,ts_exec) */;

----------------------------------------
DATABASE: contracts.db
----------------------------------------
CREATE TABLE contracts (
    symbol TEXT PRIMARY KEY,
    baseCoin TEXT,
    quoteCoin TEXT,
    minTradeNum REAL,
    minTradeUSDT REAL,
    pricePlace INTEGER,
    volumePlace INTEGER,
    sizeMultiplier REAL,
    minLever INTEGER,
    maxLever INTEGER,
    makerFee REAL,
    takerFee REAL,
    maxOrderQty REAL,
    maxMarketOrderQty REAL,
    symbolStatus TEXT,
    last_update INTEGER
);
CREATE VIEW v_contracts AS
SELECT
    symbol,
    minTradeUSDT,
    minTradeNum,
    minLever,
    maxLever,
    pricePlace,
    volumePlace,
    makerFee    AS makerFee,
    takerFee    AS takerFee,
    sizeMultiplier,
    symbolStatus
FROM contracts
/* v_contracts(symbol,minTradeUSDT,minTradeNum,minLever,maxLever,pricePlace,volumePlace,makerFee,takerFee,sizeMultiplier,symbolStatus) */;

----------------------------------------
DATABASE: ctx.db
----------------------------------------

----------------------------------------
DATABASE: ctx_macro.db
----------------------------------------
CREATE TABLE ctx_macro (
    ts                  INTEGER PRIMARY KEY,

    universe_size       INTEGER NOT NULL,

    -- =========================
    -- BREADTH
    -- =========================
    breadth_value       REAL    NOT NULL,
    breadth_state       TEXT    NOT NULL,     -- STRONG | WEAK | FLAT

    -- =========================
    -- DIRECTION GLOBALE
    -- =========================
    direction_value     REAL,                 -- rendement moyen
    direction_disp      REAL,                 -- dispersion (std dev)
    direction_state     TEXT,                 -- BULL | BEAR | MIXED

    -- =========================
    -- RISK REGIME
    -- =========================
    risk_value          REAL,                 -- perf BTC - perf médiane alts
    risk_state          TEXT,                 -- ON | OFF

    -- =========================
    -- VOLATILITÉ GLOBALE
    -- =========================
    vol_value           REAL,                 -- ATR médian
    vol_ref             REAL,                 -- ATR médian historique
    vol_state           TEXT,                 -- HIGH | NORMAL | LOW

    -- =========================
    -- SYNTHÈSE
    -- =========================
    regime              TEXT                  -- TREND_BULL | TREND_BEAR | CHOP | DEAD
);
CREATE INDEX ix_ctx_macro_ts
ON ctx_macro(ts);
CREATE TABLE ctx_macro_detail (
    ts          INTEGER NOT NULL,
    instId      TEXT    NOT NULL,

    ret_value   REAL,           -- rendement utilisé
    atr_value   REAL,           -- ATR du coin
    active      INTEGER,        -- 1 si compté dans breadth

    PRIMARY KEY (ts, instId)
);
CREATE INDEX ix_ctx_macro_detail_ts
ON ctx_macro_detail(ts);

----------------------------------------
DATABASE: dec.db
----------------------------------------
CREATE TABLE dec_breakout (
    instId TEXT PRIMARY KEY,
    ts     INTEGER,
    side   TEXT,
    price  REAL,
    range_high REAL,
    range_low  REAL,
    atr REAL,
    score_ctx REAL,
    regime TEXT,
    compression_ok INTEGER,
    breakout_now INTEGER
, ctx TEXT, score_C REAL, ts_updated INTEGER, high_20 REAL, low_20 REAL, bb_width REAL);
CREATE VIEW v_dec_breakout_ready AS
SELECT *
FROM dec_breakout
WHERE breakout_now = 1
/* v_dec_breakout_ready(instId,ts,side,price,range_high,range_low,atr,score_ctx,regime,compression_ok,breakout_now,ctx,score_C,ts_updated,high_20,low_20,bb_width) */;
CREATE TABLE snap_ctx (
  instId TEXT PRIMARY KEY,
  ctx TEXT,
  score_C REAL,
  side TEXT,
  ctx_ok INTEGER,
  ts_updated INTEGER
, atr_fast REAL, atr_slow REAL, vol_regime TEXT);
CREATE TABLE snap_range (
  instId TEXT PRIMARY KEY,
  high_20 REAL,
  low_20 REAL,
  atr REAL,
  bb_width REAL,
  compression_ok INTEGER,
  ts INTEGER
);
CREATE VIEW v_dec_bo AS
SELECT *,
  CASE
    WHEN ctx_ok=1
     AND compression_ok=1
     AND (
       (side='buy'  AND lastPr > high_20) OR
       (side='sell' AND lastPr < low_20)
     )
    THEN 1 ELSE 0
  END AS fire_bo
FROM v_dec_candidates
/* v_dec_bo(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,fire_bo) */;
CREATE VIEW v_dec_pb AS
SELECT *,
  CASE
    WHEN ctx_ok=1
     AND compression_ok=0
     AND (
       (side='buy'
         AND lastPr < high_20
         AND lastPr > (high_20 - (high_20-low_20)*0.62)
       )
       OR
       (side='sell'
         AND lastPr > low_20
         AND lastPr < (low_20 + (high_20-low_20)*0.62)
       )
     )
    THEN 1 ELSE 0
  END AS armed_pb
FROM v_dec_candidates
/* v_dec_pb(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,armed_pb) */;
CREATE VIEW v_dec_fbo AS
SELECT *,
  CASE
    WHEN ctx_ok=1
     AND (
       (side='buy'
         AND lastPr < high_20
         AND lastPr > low_20
       )
       OR
       (side='sell'
         AND lastPr > low_20
         AND lastPr < high_20
       )
     )
    THEN 1 ELSE 0
  END AS fire_fbo
FROM v_dec_candidates
WHERE compression_ok=1
/* v_dec_fbo(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,fire_fbo) */;
CREATE VIEW v_dec_cont AS
SELECT *,
  CASE
    WHEN ctx_ok=1
     AND (
       (side='buy'  AND lastPr > high_20 + atr*0.5) OR
       (side='sell' AND lastPr < low_20  - atr*0.5)
     )
    THEN 1 ELSE 0
  END AS fire_cont
FROM v_dec_candidates
/* v_dec_cont(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,fire_cont) */;
CREATE VIEW v_dec_flags AS
WITH latest_ticks AS (
  SELECT
    instId_s,
    lastPr,
    ts
  FROM snap_ticks t1
  WHERE ts = (
    SELECT MAX(ts)
    FROM snap_ticks t2
    WHERE t2.instId_s = t1.instId_s
  )
)
SELECT
  c.instId,
  c.side,
  c.score_C,
  c.ctx_ok,

  t.lastPr,
  t.ts AS tick_ts,

  r.high_20,
  r.low_20,
  r.atr,
  r.bb_width,
  r.compression_ok,

  CASE
    WHEN r.atr IS NOT NULL
     AND r.high_20 IS NOT NULL
     AND r.low_20 IS NOT NULL
     AND (
       (c.side='buy'  AND t.lastPr > r.high_20 + r.atr*0.60) OR
       (c.side='sell' AND t.lastPr < r.low_20  - r.atr*0.60)
     )
    THEN 1 ELSE 0
  END AS cont_ok,

  CASE
    WHEN r.atr IS NOT NULL
     AND r.high_20 IS NOT NULL
     AND r.low_20 IS NOT NULL
     AND (
       (c.side='sell' AND t.lastPr <= r.low_20  + r.atr*0.20) OR
       (c.side='buy'  AND t.lastPr >= r.high_20 - r.atr*0.20)
     )
    THEN 1 ELSE 0
  END AS trend_ok,

  CASE
    WHEN c.ctx_ok = 1
     AND (
       (c.side='sell' AND c.score_C <= -0.30) OR
       (c.side='buy'  AND c.score_C >=  0.30)
     )
    THEN 1 ELSE 0
  END AS drift_ok

FROM snap_ctx c
LEFT JOIN snap_range r
  ON r.instId = c.instId
LEFT JOIN latest_ticks t
  ON t.instId_s = c.instId

WHERE c.ctx_ok = 1
  AND c.side IS NOT NULL
  AND t.lastPr IS NOT NULL;
CREATE VIEW v_dec_pyramide_ok AS
SELECT
    instId,
    cont_ok,
    drift_ok,
    score_C
FROM v_dec_flags
WHERE cont_ok = 1;
CREATE VIEW v_dec_rejected AS
SELECT
  instId,
  ctx,
  score_C,
  atr,
  bb_width,
  compression_ok
FROM snap_ctx
LEFT JOIN snap_range USING(instId)
WHERE ctx_ok = 0
/* v_dec_rejected(instId,ctx,score_C,atr,bb_width,compression_ok) */;
CREATE VIEW v_dec_score_s AS
SELECT
    d.*,

    /* ================= STRUCTURE ================= */
    CASE
        WHEN d.cont_ok  = 1 THEN 1.00
        WHEN d.drift_ok = 1 THEN 0.70
        ELSE 0.0
    END AS s_struct,

    /* ================= TIMING COMBINÉ (ATR + RANGE) ================= */
    MIN(
        1.0,
        MAX(
            0.0,

            /* ATR adouci (K = 3) */
            0.5 * COALESCE(
                EXP(
                    -1.0 * (
                        ABS(
                            d.lastPr -
                            CASE
                                WHEN d.side='buy'  THEN d.high_20
                                WHEN d.side='sell' THEN d.low_20
                                ELSE d.lastPr
                            END
                        ) / NULLIF(d.atr * 3.0, 0)
                    )
                ),
                0.30
            )

            +

            /* Range timing */
            0.5 * COALESCE(
                CASE
                    WHEN d.high_20 IS NULL
                      OR d.low_20  IS NULL
                      OR d.high_20 <= d.low_20
                    THEN 0.30
                    ELSE
                        MAX(
                            0.0,
                            MIN(
                                1.0,
                                1.0 -
                                (
                                    ABS(
                                        d.lastPr -
                                        CASE
                                            WHEN d.side='buy'  THEN d.high_20
                                            WHEN d.side='sell' THEN d.low_20
                                            ELSE d.lastPr
                                        END
                                    ) /
                                    (d.high_20 - d.low_20)
                                )
                            )
                        )
                END,
                0.30
            )
        )
    ) AS s_timing,

    /* ================= QUALITÉ (range ^0.65 * timing) ================= */
    MAX(
        0.25,   -- PLANCHER DE QUALITÉ (CRITIQUE)
        MIN(
            1.0,
            POWER(
                CASE
                    WHEN d.high_20 IS NULL
                      OR d.low_20  IS NULL
                      OR d.high_20 <= d.low_20
                    THEN 0.30

                    WHEN d.side='buy' THEN
                        MAX(
                            0.0,
                            MIN(
                                1.0,
                                (d.high_20 - d.lastPr) /
                                (d.high_20 - d.low_20)
                            )
                        )

                    WHEN d.side='sell' THEN
                        MAX(
                            0.0,
                            MIN(
                                1.0,
                                (d.lastPr - d.low_20) /
                                (d.high_20 - d.low_20)
                            )
                        )

                    ELSE 0.30
                END,
                0.65
            )
            *
            MIN(
                1.0,
                MAX(
                    0.0,

                    0.5 * COALESCE(
                        EXP(
                            -1.0 * (
                                ABS(
                                    d.lastPr -
                                    CASE
                                        WHEN d.side='buy'  THEN d.high_20
                                        WHEN d.side='sell' THEN d.low_20
                                        ELSE d.lastPr
                                    END
                                ) / NULLIF(d.atr * 3.0, 0)
                            )
                        ),
                        0.30
                    )

                    +

                    0.5 * COALESCE(
                        CASE
                            WHEN d.high_20 IS NULL
                              OR d.low_20  IS NULL
                              OR d.high_20 <= d.low_20
                            THEN 0.30
                            ELSE
                                MAX(
                                    0.0,
                                    MIN(
                                        1.0,
                                        1.0 -
                                        (
                                            ABS(
                                                d.lastPr -
                                                CASE
                                                    WHEN d.side='buy'  THEN d.high_20
                                                    WHEN d.side='sell' THEN d.low_20
                                                    ELSE d.lastPr
                                                END
                                            ) /
                                            (d.high_20 - d.low_20)
                                        )
                                    )
                                )
                        END,
                        0.30
                    )
                )
            )
        )
    ) AS s_quality,

    /* ================= VOLATILITÉ ================= */
    CASE
        WHEN d.compression_ok = 1 THEN 1.00
        ELSE 0.70
    END AS s_vol,

    /* ================= CONFIRMATION ================= */
    (CASE WHEN d.cont_ok  = 1 THEN 0.20 ELSE 0.0 END) +
    (CASE WHEN d.drift_ok = 1 THEN 0.10 ELSE 0.0 END)
    AS s_confirm,

    /* ================= SCORE S FINAL ================= */
    MIN(
        1.0,
        MAX(
            0.0,
            0.40 * (
                CASE
                    WHEN d.cont_ok  = 1 THEN 1.00
                    WHEN d.drift_ok = 1 THEN 0.70
                    ELSE 0.0
                END
            )
            +
            0.30 * (
                MAX(
                    0.25,
                    MIN(
                        1.0,
                        POWER(
                            CASE
                                WHEN d.high_20 IS NULL
                                  OR d.low_20  IS NULL
                                  OR d.high_20 <= d.low_20
                                THEN 0.30

                                WHEN d.side='buy' THEN
                                    MAX(
                                        0.0,
                                        MIN(
                                            1.0,
                                            (d.high_20 - d.lastPr) /
                                            (d.high_20 - d.low_20)
                                        )
                                    )

                                WHEN d.side='sell' THEN
                                    MAX(
                                        0.0,
                                        MIN(
                                            1.0,
                                            (d.lastPr - d.low_20) /
                                            (d.high_20 - d.low_20)
                                        )
                                    )

                                ELSE 0.30
                            END,
                            0.65
                        )
                        *
                        MIN(
                            1.0,
                            MAX(
                                0.0,

                                0.5 * COALESCE(
                                    EXP(
                                        -1.0 * (
                                            ABS(
                                                d.lastPr -
                                                CASE
                                                    WHEN d.side='buy'  THEN d.high_20
                                                    WHEN d.side='sell' THEN d.low_20
                                                    ELSE d.lastPr
                                                END
                                            ) / NULLIF(d.atr * 3.0, 0)
                                        )
                                    ),
                                    0.30
                                )

                                +

                                0.5 * COALESCE(
                                    CASE
                                        WHEN d.high_20 IS NULL
                                          OR d.low_20  IS NULL
                                          OR d.high_20 <= d.low_20
                                        THEN 0.30
                                        ELSE
                                            MAX(
                                                0.0,
                                                MIN(
                                                    1.0,
                                                    1.0 -
                                                    (
                                                        ABS(
                                                            d.lastPr -
                                                            CASE
                                                                WHEN d.side='buy'  THEN d.high_20
                                                                WHEN d.side='sell' THEN d.low_20
                                                                ELSE d.lastPr
                                                            END
                                                        ) /
                                                        (d.high_20 - d.low_20)
                                                    )
                                                )
                                            )
                                    END,
                                    0.30
                                )
                            )
                        )
                    )
                )
            )
            +
            0.20 * (
                CASE
                    WHEN d.compression_ok = 1 THEN 1.00
                    ELSE 0.70
                END
            )
            +
            0.10 * (
                (CASE WHEN d.cont_ok  = 1 THEN 0.20 ELSE 0.0 END) +
                (CASE WHEN d.drift_ok = 1 THEN 0.10 ELSE 0.0 END)
            )
        )
    ) AS score_S

FROM v_dec_flags d;
CREATE TABLE dec_fire_log (
    ts          INTEGER NOT NULL,
    instId      TEXT    NOT NULL,

    ctx         TEXT,
    score_dec   REAL,
    regime      TEXT,

    reason      TEXT,

    PRIMARY KEY (ts, instId)
);
CREATE INDEX idx_dec_fire_log_inst
    ON dec_fire_log(instId);
CREATE INDEX idx_dec_fire_log_ts
    ON dec_fire_log(ts);
CREATE VIEW v_dec_market_ok AS
SELECT *
FROM v_dec_candidates
WHERE instId IN (
    SELECT instId
    FROM market_latest
    WHERE market_ok = 1
);
CREATE VIEW v_dec_drift AS
SELECT
  d.*,

  CASE
    WHEN
      d.ctx_ok = 1
      AND d.atr IS NOT NULL
      AND d.high_20 IS NOT NULL
      AND d.low_20  IS NOT NULL
      AND (
        (d.side = 'buy'
          AND d.lastPr >
              d.low_20 + (d.high_20 - d.low_20) * 0.55
        )
        OR
        (d.side = 'sell'
          AND d.lastPr <
              d.high_20 - (d.high_20 - d.low_20) * 0.55
        )
      )
    THEN 1 ELSE 0
  END AS drift_ok

FROM v_dec_candidates d
/* v_dec_drift(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,drift_ok) */;
CREATE VIEW v_snap_ticks_latest AS
WITH latest AS (
  SELECT
    instId_s AS instId,
    lastPr,
    ts,
    ROW_NUMBER() OVER (PARTITION BY instId_s ORDER BY ts DESC) AS rn
  FROM snap_ticks
  WHERE instId_s IS NOT NULL
    AND instId_s <> ''
    AND lastPr IS NOT NULL
)
SELECT instId, lastPr, ts
FROM latest
WHERE rn = 1;
CREATE VIEW v_snap_range_valid AS
SELECT *
FROM snap_range
WHERE high_20 IS NOT NULL
  AND low_20  IS NOT NULL
  AND high_20 > low_20
  AND atr IS NOT NULL
  AND atr > 0
/* v_snap_range_valid(instId,high_20,low_20,atr,bb_width,compression_ok,ts) */;
CREATE VIEW v_dec_drift_simple AS
SELECT
  d.*,
  CASE
    WHEN d.ctx_ok = 1
     AND d.atr IS NOT NULL
     AND d.lastPr IS NOT NULL
     AND d.high_20 IS NOT NULL
     AND d.low_20  IS NOT NULL
     AND d.lastPr >= d.low_20
     AND d.lastPr <= d.high_20
    THEN 1 ELSE 0
  END AS drift_ok
FROM v_dec_candidates d
/* v_dec_drift_simple(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,drift_ok) */;
CREATE TABLE snap_ticks (
    instId  TEXT PRIMARY KEY,
    lastPr  REAL NOT NULL,
    ts      INTEGER NOT NULL
);
CREATE INDEX idx_snap_ticks_ts
ON snap_ticks(ts DESC);
CREATE VIEW v_dec_candidates AS
SELECT
  c.instId,
  c.ctx,
  c.score_C,
  c.side,
  c.ctx_ok,

  r.high_20,
  r.low_20,
  r.atr,
  r.bb_width,
  r.compression_ok,

  t.lastPr
FROM snap_ctx c
LEFT JOIN snap_range r
  ON r.instId = c.instId
LEFT JOIN snap_ticks t
  ON t.instId = c.instId
WHERE c.ctx_ok = 1
  AND c.side IS NOT NULL
  AND t.lastPr IS NOT NULL
/* v_dec_candidates(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr) */;
CREATE VIEW v_dec_prebreak AS
SELECT
  d.*,
  CASE
    WHEN d.compression_ok = 1
     AND d.atr IS NOT NULL
     AND (
       (d.side='buy'  AND d.lastPr >= d.high_20 - d.atr * 0.25) OR
       (d.side='sell' AND d.lastPr <= d.low_20  + d.atr * 0.25)
     )
    THEN 1 ELSE 0
  END AS prebreak_ok
FROM v_dec_candidates d
/* v_dec_prebreak(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,prebreak_ok) */;
CREATE VIEW v_dec_pullback AS
SELECT
  d.*,
  CASE
    WHEN d.atr IS NOT NULL
     AND (
       (d.side='buy'
        AND d.lastPr < d.high_20
        AND d.lastPr > d.high_20 - d.atr * 0.6)
       OR
       (d.side='sell'
        AND d.lastPr > d.low_20
        AND d.lastPr < d.low_20 + d.atr * 0.6)
     )
    THEN 1 ELSE 0
  END AS pullback_ok
FROM v_dec_candidates d
/* v_dec_pullback(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,pullback_ok) */;
CREATE VIEW v_dec_momentum AS
SELECT
  d.*,
  CASE
    WHEN d.atr IS NOT NULL
     AND d.compression_ok = 0
     AND (
       (d.side='buy'
        AND d.lastPr > d.low_20 + (d.high_20-d.low_20)*0.65)
       OR
       (d.side='sell'
        AND d.lastPr < d.high_20 - (d.high_20-d.low_20)*0.65)
     )
    THEN 1 ELSE 0
  END AS momentum_ok
FROM v_dec_candidates d
/* v_dec_momentum(instId,ctx,score_C,side,ctx_ok,high_20,low_20,atr,bb_width,compression_ok,lastPr,momentum_ok) */;
CREATE VIEW v_dec_armed AS
SELECT
  e.*,
  CASE
    WHEN e.dec_mode IN ('PREBREAK','MOMENTUM')
    THEN 1
    ELSE 0
  END AS armed
FROM v_dec_explain e
/* v_dec_armed(instId,side,ctx,score_C,lastPr,high_20,low_20,atr,compression_ok,prebreak_ok,pullback_ok,momentum_ok,dec_mode,armed) */;
CREATE VIEW v_dec_explain AS
SELECT
  c.instId,
  c.side,
  c.ctx,
  c.score_C,

  c.lastPr,
  c.high_20,
  c.low_20,
  c.atr,

  r.compression_ok,
  pb.prebreak_ok,
  pl.pullback_ok,
  mo.momentum_ok,

  CASE
    WHEN pb.prebreak_ok = 1 THEN 'PREBREAK'
    WHEN mo.momentum_ok = 1 THEN 'MOMENTUM'
    WHEN pl.pullback_ok = 1 THEN 'PULLBACK'
    ELSE 'NO_ENTRY'
  END AS dec_mode

FROM v_dec_candidates c
LEFT JOIN snap_range r USING(instId)
LEFT JOIN v_dec_prebreak pb USING(instId)
LEFT JOIN v_dec_pullback pl USING(instId)
LEFT JOIN v_dec_momentum mo USING(instId)
/* v_dec_explain(instId,side,ctx,score_C,lastPr,high_20,low_20,atr,compression_ok,prebreak_ok,pullback_ok,momentum_ok,dec_mode) */;
CREATE VIEW v_triggers_norm AS
SELECT
    instId,
    side,
    ctx,

    -- déclencheur principal
    dec_mode            AS trigger_type,

    -- métriques
    score_C,
    atr,

    -- état
    fire                AS fired,

    -- flags analytiques
    momentum_ok,
    prebreak_ok,
    pullback_ok,
    compression_ok

FROM v_dec_fire
WHERE armed = 1;
CREATE TABLE snap_atr (
    instId TEXT PRIMARY KEY,

    atr_1m  REAL,
    atr_3m  REAL,
    atr_5m  REAL,
    atr_15m REAL,
    atr_30m REAL,

    ratio_1m_5m  REAL,
    ratio_5m_15m REAL,
    ratio_5m_30m REAL,

    vol_regime TEXT,        -- COMPRESS | NORMAL | EXPAND
    ts_updated INTEGER
);
CREATE INDEX idx_snap_atr_ts
ON snap_atr(ts_updated);
CREATE VIEW v_dec_debug_ctx AS
SELECT
    instId,
    ctx,
    side,
    score_C,
    atr_fast,
    atr_slow,
    vol_regime,
    CASE
        WHEN vol_regime = 'COMPRESS' THEN 'COMPRESS'
        WHEN vol_regime = 'EXPAND'  THEN 'EXPAND'
        ELSE 'NORMAL'
    END AS vol_flag,
    (strftime('%s','now')*1000 - ts_updated) AS age_ms
FROM snap_ctx
/* v_dec_debug_ctx(instId,ctx,side,score_C,atr_fast,atr_slow,vol_regime,vol_flag,age_ms) */;
CREATE VIEW v_dec_fire_debug AS
SELECT
  instId,
  side,
  0.0      AS lastPr,
  atr_fast AS atr,
  ctx      AS dec_mode,
  score_C,
  ctx,
  1        AS fire
FROM snap_ctx
WHERE ctx_ok = 1
/* v_dec_fire_debug(instId,side,lastPr,atr,dec_mode,score_C,ctx,fire) */;
CREATE TABLE ticks_live (
    instId   TEXT PRIMARY KEY,
    lastPr   REAL NOT NULL,
    ts_ms    INTEGER NOT NULL
);
CREATE INDEX idx_ticks_live_ts ON ticks_live(ts_ms);
CREATE VIEW v_dec_fire AS
WITH base AS (
    SELECT
        s.instId,
        s.side,
        s.ctx,
        s.score_C,
        s.atr_fast,
        s.atr_slow,
        s.vol_regime,
        t.lastPr,
        s.ts_updated
    FROM snap_ctx s
    JOIN ticks_live t   -- ✅ PRIX MARCHÉ RÉEL LOCAL
      ON t.instId = s.instId
    WHERE s.ctx_ok = 1
),
patterned AS (
    SELECT *,
        CASE
            WHEN ctx='bullish' AND vol_regime='EXPAND'  THEN 'MOMENTUM'
            WHEN ctx='bullish' AND vol_regime='NORMAL'  THEN 'CONT'
            WHEN ctx='bearish' AND vol_regime='NORMAL'  THEN 'DRIFT'
            WHEN ctx='bearish' AND vol_regime='COMPRESS' THEN 'PREBREAK'
            ELSE 'IGNORE'
        END AS dec_mode
    FROM base
),
admission AS (
    SELECT *,
        CASE
            WHEN dec_mode='MOMENTUM' AND ABS(score_C)>=0.45 THEN 1
            WHEN dec_mode='PREBREAK' THEN 1
            WHEN dec_mode='DRIFT' AND ABS(score_C)>=0.30 THEN 1
            WHEN dec_mode='CONT'  AND ABS(score_C)>=0.30 THEN 1
            ELSE 0
        END AS fire
    FROM patterned
)
SELECT
    instId, side, lastPr, atr_fast AS atr,
    dec_mode, score_C, ctx, fire
FROM admission
WHERE fire=1
/* v_dec_fire(instId,side,lastPr,atr,dec_mode,score_C,ctx,fire) */;

----------------------------------------
DATABASE: exec.db
----------------------------------------
CREATE TABLE exec (
    exec_id TEXT PRIMARY KEY,
    uid TEXT NOT NULL,
    step INTEGER NOT NULL,

    exec_type TEXT NOT NULL,   -- open | pyramide | partial | close
    side TEXT NOT NULL,

    qty REAL NOT NULL,
    price_exec REAL NOT NULL,
    fee REAL DEFAULT 0.0,

    status TEXT NOT NULL,      -- *_stdby | *_done
    ts_exec INTEGER NOT NULL
, reason TEXT, regime TEXT, instId TEXT, lev REAL NOT NULL DEFAULT 1.0, pnl_realized_step REAL NOT NULL DEFAULT 0.0, sl_be REAL, sl_trail REAL, tp_dyn REAL, mfe_atr REAL, mae_atr REAL, golden INTEGER, type_signal TEXT, dec_mode TEXT, done_step INTEGER DEFAULT 0);
CREATE INDEX idx_exec_uid ON exec(uid);
CREATE INDEX idx_exec_status ON exec(status);
CREATE INDEX idx_exec_type
    ON exec(exec_type);
CREATE INDEX ix_exec_uid_step
ON exec(uid, step);
CREATE INDEX ix_exec_status
ON exec(status);
CREATE VIEW v_exec_ledger AS
SELECT
  exec_id,
  uid,
  step,
  exec_type,
  side,
  qty,
  price_exec,
  fee,
  status,
  ts_exec
FROM exec
WHERE status='done'
/* v_exec_ledger(exec_id,uid,step,exec_type,side,qty,price_exec,fee,status,ts_exec) */
/* v_exec_ledger(exec_id,uid,step,exec_type,side,qty,price_exec,fee,status,ts_exec) */;
CREATE VIEW v_exec_pnl_uid AS
WITH p AS (
  SELECT
    uid,
    side,
    avg_price_open,
    fee_total
  FROM v_exec_position
),
out_exec AS (
  SELECT
    e.uid,
    e.side,
    e.exec_type,
    e.qty,
    e.price_exec
  FROM v_exec_ledger e
  WHERE e.exec_type IN ('partial','close')
),
pnl_core AS (
  SELECT
    o.uid,
    SUM(
      CASE
        WHEN o.side='buy'  THEN o.qty * (o.price_exec - p.avg_price_open)
        WHEN o.side='sell' THEN o.qty * (p.avg_price_open - o.price_exec)
        ELSE 0.0
      END
    ) AS pnl_gross
  FROM out_exec o
  JOIN p ON p.uid=o.uid
  GROUP BY o.uid
)
SELECT
  p.uid,
  COALESCE(pc.pnl_gross,0.0) - COALESCE(p.fee_total,0.0) AS pnl_realized
FROM p
LEFT JOIN pnl_core pc USING(uid)
/* v_exec_pnl_uid(uid,pnl_realized) */
/* v_exec_pnl_uid(uid,pnl_realized) */;
CREATE VIEW v_gest_monitoring AS
SELECT
    uid,
    instId,
    side,
    entry,
    qty,
    status,
    ts_open
FROM gest
WHERE status IN (
    'open_req',
    'open_done',
    'follow',
    'partial_req',
    'partial_done',
    'pyramide_req',
    'pyramide_done',
    'close_req'
);
CREATE VIEW v_exec_monitoring AS
SELECT
    uid,
    side,
    qty_open,
    avg_price_open,
    last_exec_type,
    last_step,
    last_price_exec,
    last_ts_exec
FROM v_exec_position
/* v_exec_monitoring(uid,side,qty_open,avg_price_open,last_exec_type,last_step,last_price_exec,last_ts_exec) */;
CREATE VIEW v_follower_monitoring AS
SELECT
    uid,
    mfe_price,
    mae_price,
    sl_trail,
    tp_dyn,
    atr_signal
FROM follower
WHERE status = 'follow';
CREATE VIEW v_ticks_monitoring AS
SELECT
    instId,
    lastPr
FROM v_ticks_latest;
CREATE VIEW v_exec_position AS
WITH x AS (
  SELECT
    uid,
    side,
    exec_type,
    step,
    qty,
    price_exec,
    fee,
    ts_exec,
    CASE
      WHEN exec_type IN ('open','pyramide') THEN qty
      WHEN exec_type IN ('partial','close') THEN -qty
      ELSE 0
    END AS signed_qty,
    CASE
      WHEN exec_type IN ('open','pyramide') THEN qty
      ELSE 0
    END AS qty_in,
    CASE
      WHEN exec_type IN ('open','pyramide') THEN qty * price_exec
      ELSE 0
    END AS notional_in
  FROM v_exec_ledger
),
agg AS (
  SELECT
    uid,
    MAX(side) AS side,
    SUM(signed_qty) AS qty_open,
    SUM(qty_in) AS qty_in_total,
    SUM(notional_in) AS notional_in_total,
    SUM(COALESCE(fee,0.0)) AS fee_total,
    MAX(ts_exec) AS last_ts_exec
  FROM x
  GROUP BY uid
),
last_row AS (
  SELECT
    uid,
    exec_type AS last_exec_type,
    step AS last_step,
    price_exec AS last_price_exec,
    ts_exec AS last_ts_exec
  FROM (
    SELECT
      uid, exec_type, step, price_exec, ts_exec,
      ROW_NUMBER() OVER (PARTITION BY uid ORDER BY ts_exec DESC, step DESC) AS rn
    FROM v_exec_ledger
  )
  WHERE rn = 1
)
SELECT
  a.uid,
  a.side,
  a.qty_open,
  CASE
    WHEN a.qty_in_total > 0
    THEN a.notional_in_total / a.qty_in_total
    ELSE 0.0
  END AS avg_price_open,
  a.fee_total,
  l.last_exec_type,
  l.last_step,
  l.last_price_exec,
  l.last_ts_exec
FROM agg a
LEFT JOIN last_row l USING(uid)
/* v_exec_position(uid,side,qty_open,avg_price_open,fee_total,last_exec_type,last_step,last_price_exec,last_ts_exec) */;
CREATE VIEW v_exec_perf_by_step AS
    SELECT
        step,
        COUNT(*)                       AS n,
        AVG(pnl_realized_step)         AS exp,
        SUM(CASE WHEN pnl_realized_step > 0 THEN pnl_realized_step ELSE 0 END)
        / ABS(SUM(CASE WHEN pnl_realized_step < 0 THEN pnl_realized_step ELSE 0 END)) AS pf
    FROM exec
    WHERE exec_type IN ('close','partial')
    GROUP BY step
/* v_exec_perf_by_step(step,n,exp,pf) */;
CREATE VIEW v_exec_perf_by_exit AS
    SELECT
        reason,
        COUNT(*)                       AS n,
        AVG(pnl_realized_step)         AS exp,
        SUM(CASE WHEN pnl_realized_step > 0 THEN pnl_realized_step ELSE 0 END)
        / ABS(SUM(CASE WHEN pnl_realized_step < 0 THEN pnl_realized_step ELSE 0 END)) AS pf
    FROM exec
    WHERE exec_type IN ('close','partial')
    GROUP BY reason
/* v_exec_perf_by_exit(reason,n,exp,pf) */;
CREATE VIEW v_exec_perf_step_exit AS
    SELECT
        step,
        reason,
        COUNT(*)                       AS n,
        AVG(pnl_realized_step)         AS exp
    FROM exec
    WHERE exec_type IN ('close','partial')
    GROUP BY step, reason
/* v_exec_perf_step_exit(step,reason,n,exp) */;
CREATE VIEW v_exec_step_exit_perf AS
SELECT
  step,
  exec_type,
  reason,
  COUNT(*) AS n,
  AVG(pnl_realized_step) AS exp,
  SUM(CASE WHEN pnl_realized_step > 0 THEN pnl_realized_step ELSE 0 END)
   / NULLIF(ABS(SUM(CASE WHEN pnl_realized_step < 0 THEN pnl_realized_step ELSE 0 END)),0) AS pf,
  AVG(mfe_atr) AS mfe_atr,
  AVG(mae_atr) AS mae_atr,
  SUM(golden) AS golden_n
FROM exec
WHERE exec_type IN ('partial','close')
GROUP BY step, exec_type, reason
/* v_exec_step_exit_perf(step,exec_type,reason,n,exp,pf,mfe_atr,mae_atr,golden_n) */;

----------------------------------------
DATABASE: follow.db
----------------------------------------

----------------------------------------
DATABASE: follower.db
----------------------------------------
CREATE TABLE follower(
    uid TEXT PRIMARY KEY,
    ts_follow INTEGER DEFAULT 0,
    sl_be REAL DEFAULT 0,
    sl_trail REAL DEFAULT 0,
    tp_dyn REAL DEFAULT 0,
    atr_signal REAL DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'follow'
, reason_close TEXT, price_to_close REAL, qty_to_close REAL, close_step INTEGER DEFAULT 0, mfe_price REAL, mfe_ts INTEGER, mae_price REAL, mae_ts INTEGER, reason TEXT, ts_decision INTEGER, nb_partial INTEGER DEFAULT 0, nb_pyramide INTEGER DEFAULT 0, nb_pyramide_post_partial INTEGER DEFAULT 0, last_partial_price REAL, last_partial_ts INTEGER, last_pyramide_price REAL, last_pyramide_ts INTEGER, mfe_local REAL, mae_local REAL, vwap_local REAL, cooldown_partial_ts INTEGER, cooldown_pyramide_ts INTEGER, regime TEXT DEFAULT 'scalp', qty_ratio REAL, step INTEGER DEFAULT 0, ensure_step_column INTEGER DEFAULT 0, mfe_atr REAL DEFAULT 0.0, mae_atr REAL DEFAULT 0.0, last_pyramide_mfe_atr REAL DEFAULT 0.0, last_partial_mfe_atr REAL DEFAULT 0.0, last_action_ts INTEGER DEFAULT 0, golden INTEGER NOT NULL DEFAULT 0, golden_ts INTEGER, sl_be_price REAL, sl_be_atr REAL, sl_be_ts INTEGER, sl_trail_active INTEGER DEFAULT 0, sl_trail_start_atr REAL, sl_trail_ts INTEGER, tp_dyn_atr REAL, tp_dyn_ts INTEGER, first_partial_ts INTEGER, first_partial_mfe_atr REAL, first_pyramide_ts INTEGER, last_decision_ts, instId TEXT, side TEXT, ratio_opened REAL DEFAULT 0.0, ratio_to_open REAL, ratio_to_close REAL, ratio_closed REAL DEFAULT 0, ratio_exposed REAL DEFAULT 0, trade_free INTEGER DEFAULT 0, req_step INTEGER DEFAULT 0, done_step INTEGER DEFAULT 0, qty_to_close_ratio REAL DEFAULT 0.0, qty_to_add_ratio REAL DEFAULT 0.0, ts_updated INTEGER, ratio_to_add REAL DEFAULT NULL, qty_open_snapshot REAL DEFAULT 0.0, qty_open REAL DEFAULT 0.0, avg_price_open REAL, last_exec_type TEXT, last_step INTEGER, last_price_exec REAL, last_ts_exec INTEGER);
CREATE INDEX idx_follower_uid
    ON follower(uid);
CREATE INDEX idx_follower_status
    ON follower(status);
CREATE INDEX ix_follower_status
ON follower(status);
CREATE VIEW v_follower AS
SELECT
    uid,
    ts_follow,
    sl_be,
    sl_trail,
    tp_dyn,
    status
FROM follower
/* v_follower(uid,ts_follow,sl_be,sl_trail,tp_dyn,status) */;
CREATE VIEW v_gest_monitoring AS
SELECT
    uid,
    instId,
    side,
    entry,
    qty,
    status,
    ts_open
FROM gest
WHERE status IN (
    'open_req',
    'open_done',
    'follow',
    'partial_req',
    'partial_done',
    'pyramide_req',
    'pyramide_done',
    'close_req'
);
CREATE VIEW v_follower_monitoring AS
SELECT
    uid,
    mfe_price,
    mae_price,
    sl_trail,
    tp_dyn,
    atr_signal
FROM follower
WHERE status = 'follow'
/* v_follower_monitoring(uid,mfe_price,mae_price,sl_trail,tp_dyn,atr_signal) */;
CREATE VIEW v_ticks_monitoring AS
SELECT
    instId,
    lastPr
FROM v_ticks_latest;
CREATE VIEW trades_follow AS
SELECT
    uid,
    instId,
    side,
    status,
    mfe_atr     AS mfe,
    atr_signal  AS atr,
    nb_pyramide,
    last_pyramide_price,
    last_pyramide_ts,
    cooldown_pyramide_ts,
    step        AS pyramide_inflight_step,
    last_action_ts AS ts_update
FROM follower
/* trades_follow(uid,instId,side,status,mfe,atr,nb_pyramide,last_pyramide_price,last_pyramide_ts,cooldown_pyramide_ts,pyramide_inflight_step,ts_update) */;
CREATE VIEW v_follower_state AS
SELECT
    uid,
    instId,
    side,
    status,
    step,

    -- ratios
    qty_ratio,
    qty_to_close_ratio,
    qty_to_add_ratio,

    -- FSM
    req_step,
    done_step,

    -- AGE
    (strftime('%s','now') - ts_follow / 1000) AS age_s,

    -- MFE / MAE
    mfe_atr,
    mae_atr,

    -- COUNTERS
    nb_partial,
    nb_pyramide,

    -- ✅ EXEC MATERIALISÉ
    qty_open,
    avg_price_open,
    last_exec_type,
    last_step,
    last_price_exec,
    last_ts_exec

FROM follower
/* v_follower_state(uid,instId,side,status,step,qty_ratio,qty_to_close_ratio,qty_to_add_ratio,req_step,done_step,age_s,mfe_atr,mae_atr,nb_partial,nb_pyramide,qty_open,avg_price_open,last_exec_type,last_step,last_price_exec,last_ts_exec) */;

----------------------------------------
DATABASE: gest.db
----------------------------------------
CREATE TABLE gest (
    uid TEXT PRIMARY KEY,
    instId TEXT NOT NULL,
    side TEXT NOT NULL,

    ts_signal INTEGER NOT NULL,
    price_signal REAL DEFAULT 0,
    atr_signal REAL DEFAULT 0,

    reason TEXT,
    entry_reason TEXT,
    type_signal TEXT,

    score_C REAL,
    score_S REAL,
    score_H REAL,

    entry REAL,
    qty REAL,
    lev REAL,
    margin REAL,

    ts_open INTEGER,
    sl_init REAL,
    tp_init REAL,

    ts_follow INTEGER,
    sl_be REAL,
    sl_trail REAL,
    tp_dyn REAL,

    price_to_close REAL,
    ts_close INTEGER,
    price_close REAL,
    reason_close TEXT,
    ctx_close TEXT,
    price_exec_close REAL,

    pnl REAL,
    pnl_pct REAL,
    fee REAL,
    fee_total REAL,
    pnl_net REAL,

    wt_delta_t_ms INTEGER,
    wt_delta_price_pct REAL,
    wt_peak_ts INTEGER,
    wt_peak_price REAL,

    status TEXT NOT NULL,
    ts_status_update INTEGER
, instId_raw TEXT, strength REAL, ctx TEXT, atr REAL, of_imbalance REAL, confluence REAL, ts_created INTEGER, ts_updated INTEGER, skipped_reason TEXT, fire INTEGER DEFAULT 0, score_of     REAL, score_mo     REAL, score_br     REAL, score_force  REAL, qty_open REAL, pnl_realized REAL, qty_to_close REAL, close_step INTEGER DEFAULT 0, mfe_price REAL, mfe_ts INTEGER, mae_price REAL, mae_ts INTEGER, qty_in_exec      REAL DEFAULT 0, qty_out_exec     REAL DEFAULT 0, qty_open_exec    REAL DEFAULT 0, avg_entry_price  REAL, avg_exit_price   REAL, fee_total_exec   REAL DEFAULT 0, last_exec_step   INTEGER DEFAULT 0, fsm_state TEXT, qty_in REAL DEFAULT 0, qty_out REAL DEFAULT 0, fee_exec_total REAL DEFAULT 0, ts_first_open INTEGER, ts_last_close INTEGER, step INTEGER NOT NULL DEFAULT 0, nb_partial INTEGER DEFAULT 0, nb_pyramide INTEGER DEFAULT 0, nb_pyramide_post_partial INTEGER DEFAULT 0, last_partial_price REAL, last_partial_ts INTEGER, last_pyramide_price REAL, last_pyramide_ts INTEGER, mfe_local REAL, mae_local REAL, vwap_local REAL, cooldown_partial_ts INTEGER, cooldown_pyramide_ts INTEGER, regime TEXT, score_M REAL, mfe_atr REAL, mae_atr REAL, mfe_atr_partial REAL, mfe_atr_pyramide REAL, golden INTEGER DEFAULT 0, golden_ts INTEGER, first_partial_ts INTEGER, first_partial_mfe_atr REAL, first_pyramide_ts INTEGER, last_pyramide_mfe_atr REAL, last_action_ts INTEGER, last_emit_status, last_emit_ts, trigger_type TEXT, dec_mode TEXT, momentum_ok INTEGER DEFAULT 0, prebreak_ok INTEGER DEFAULT 0, pullback_ok INTEGER DEFAULT 0, compression_ok INTEGER DEFAULT 0, dec_ctx TEXT, dec_score_C REAL, ratio_to_open REAL, ratio_to_add  REAL, ratio_to_close REAL);
CREATE TABLE exec_snapshot (
    uid             TEXT NOT NULL,
    exec_type       TEXT NOT NULL,
    side            TEXT NOT NULL,
    qty             REAL NOT NULL,
    price_exec      REAL NOT NULL,
    ts_exec         INTEGER NOT NULL,
    step            INTEGER NOT NULL,
    PRIMARY KEY (uid, exec_type, step)
);
CREATE INDEX idx_gest_uid
    ON gest(uid);
CREATE INDEX idx_gest_status
    ON gest(status);
CREATE INDEX idx_gest_ts_signal
    ON gest(ts_signal);
CREATE INDEX idx_gest_instId
    ON gest(instId);
CREATE INDEX idx_gest_price_signal
    ON gest(price_signal);
CREATE INDEX ix_gest_uid_step
ON gest(uid, step);
CREATE INDEX ix_gest_status
ON gest(status);
CREATE INDEX idx_exec_snapshot_uid
ON exec_snapshot(uid);
CREATE VIEW v_gest AS
SELECT *
FROM gest
ORDER BY ts_signal DESC
/* v_gest(uid,instId,side,ts_signal,price_signal,atr_signal,reason,entry_reason,type_signal,score_C,score_S,score_H,entry,qty,lev,margin,ts_open,sl_init,tp_init,ts_follow,sl_be,sl_trail,tp_dyn,price_to_close,ts_close,price_close,reason_close,ctx_close,price_exec_close,pnl,pnl_pct,fee,fee_total,pnl_net,wt_delta_t_ms,wt_delta_price_pct,wt_peak_ts,wt_peak_price,status,ts_status_update,instId_raw,strength,ctx,atr,of_imbalance,confluence,ts_created,ts_updated,skipped_reason,fire,score_of,score_mo,score_br,score_force,qty_open,pnl_realized,qty_to_close,close_step,mfe_price,mfe_ts,mae_price,mae_ts,qty_in_exec,qty_out_exec,qty_open_exec,avg_entry_price,avg_exit_price,fee_total_exec,last_exec_step,fsm_state,qty_in,qty_out,fee_exec_total,ts_first_open,ts_last_close,step,nb_partial,nb_pyramide,nb_pyramide_post_partial,last_partial_price,last_partial_ts,last_pyramide_price,last_pyramide_ts,mfe_local,mae_local,vwap_local,cooldown_partial_ts,cooldown_pyramide_ts,regime,score_M,mfe_atr,mae_atr,mfe_atr_partial,mfe_atr_pyramide,golden,golden_ts,first_partial_ts,first_partial_mfe_atr,first_pyramide_ts,last_pyramide_mfe_atr,last_action_ts,last_emit_status,last_emit_ts,trigger_type,dec_mode,momentum_ok,prebreak_ok,pullback_ok,compression_ok,dec_ctx,dec_score_C,ratio_to_open,ratio_to_add,ratio_to_close) */;
CREATE VIEW v_gest_status_count AS
SELECT
    status,
    COUNT(*) AS cnt
FROM gest
GROUP BY status
/* v_gest_status_count(status,cnt) */;
CREATE VIEW v_active_coins AS
SELECT DISTINCT
    instId
FROM gest
WHERE status IN (
    'armed',
    'fire',
    'opened',
    'follow',
    'to_close'
)
AND instId IS NOT NULL
/* v_active_coins(instId) */;
CREATE VIEW v_status AS
SELECT uid, fsm_state AS status
FROM v_gest_fsm;
CREATE VIEW v_gest_fsm AS
SELECT
    g.*,

    p.qty_open,
    p.avg_entry_price,
    p.avg_exit_price,
    p.fee_total,

    CASE
        WHEN g.status IN ('partial_done','pyramid_done') THEN 'follow'
        ELSE g.status
    END AS fsm_state

FROM gest g
LEFT JOIN v_position p ON p.uid = g.uid;
CREATE VIEW v_exec_agg AS
SELECT
    uid,

    SUM(CASE
        WHEN exec_type IN ('open','pyramide')
        THEN qty ELSE 0 END) AS qty_in,

    SUM(CASE
        WHEN exec_type IN ('partial','close')
        THEN qty ELSE 0 END) AS qty_out,

    SUM(CASE
        WHEN exec_type IN ('open','pyramide')
        THEN qty * price_exec ELSE 0 END)
      / NULLIF(
          SUM(CASE
              WHEN exec_type IN ('open','pyramide')
              THEN qty ELSE 0 END),
          0
        ) AS avg_entry_price,

    SUM(CASE
        WHEN exec_type IN ('partial','close')
        THEN qty * price_exec ELSE 0 END)
      / NULLIF(
          SUM(CASE
              WHEN exec_type IN ('partial','close')
              THEN qty ELSE 0 END),
          0
        ) AS avg_exit_price,

    SUM(fee) AS fee_total,

    MIN(ts_exec) AS ts_first_exec,
    MAX(ts_exec) AS ts_last_exec,

    MAX(step) AS last_step

FROM exec
GROUP BY uid;
CREATE VIEW v_position AS
SELECT
    g.uid,
    g.instId,
    g.side,

    e.qty_in,
    e.qty_out,
    (e.qty_in - e.qty_out) AS qty_open,

    e.avg_entry_price,
    e.avg_exit_price,
    e.fee_total,

    e.ts_first_exec AS ts_first_open,
    e.ts_last_exec  AS ts_last_close,

    CASE
        WHEN (e.qty_in - e.qty_out) <= 1e-8
        THEN 'closed'
        ELSE 'open'
    END AS position_state,

    g.status AS fsm_state,
    g.ts_status_update

FROM gest g
LEFT JOIN v_exec_agg e USING(uid);
CREATE VIEW v_gest_open_inst AS
SELECT DISTINCT instId
FROM gest
WHERE status IN (
  'open_req',
  'open_done',
  'follow',
  'partial_done',
  'pyramide_done'
)
/* v_gest_open_inst(instId) */;
CREATE VIEW v_exec_close_agg AS
SELECT
    uid,
    SUM(qty)                          AS qty_out_exec,
    SUM(qty * price_exec)             AS cash_out_exec,
    CASE
        WHEN SUM(qty) > 0
        THEN SUM(qty * price_exec) / SUM(qty)
        ELSE NULL
    END                               AS avg_exit_price,
    MAX(ts_exec)                      AS ts_last_exec,
    MAX(CASE WHEN exec_type='close' THEN 1 ELSE 0 END) AS has_close
FROM exec_snapshot
WHERE exec_type IN ('partial','close')
GROUP BY uid
/* v_exec_close_agg(uid,qty_out_exec,cash_out_exec,avg_exit_price,ts_last_exec,has_close) */;
CREATE VIEW v_gest_monitoring AS
SELECT
    uid,
    instId,
    side,
    entry,
    qty,
    status,
    ts_open
FROM gest
WHERE status IN (
    'open_req',
    'open_done',
    'follow',
    'partial_req',
    'partial_done',
    'pyramide_req',
    'pyramide_done',
    'close_req'
)
/* v_gest_monitoring(uid,instId,side,entry,qty,status,ts_open) */;
CREATE VIEW v_exec_monitoring AS
SELECT
    uid,
    side,
    qty_open,
    avg_price_open,
    last_exec_type,
    last_step,
    last_price_exec,
    last_ts_exec
FROM v_exec_position;
CREATE VIEW v_follower_monitoring AS
SELECT
    uid,
    mfe_price,
    mae_price,
    sl_trail,
    tp_dyn,
    atr_signal
FROM follower
WHERE status = 'follow';
CREATE VIEW v_ticks_monitoring AS
SELECT
    instId,
    lastPr
FROM v_ticks_latest;

----------------------------------------
DATABASE: h.db
----------------------------------------
CREATE TABLE h_stats (
    setup_hash TEXT PRIMARY KEY,

    instId TEXT,
    side TEXT,
    ctx TEXT,
    regime TEXT,
    tf_ref TEXT,
    time_bucket TEXT,
    score_C_bucket TEXT,
    score_S_bucket TEXT,

    n_trades INTEGER,
    win_rate REAL,
    expectancy REAL,
    avg_pnl REAL,
    profit_factor REAL,
    max_dd REAL,

    score_H REAL,

    ts_last_update INTEGER
);
CREATE INDEX idx_h_lookup
ON h_stats (
    instId, side, ctx, regime, tf_ref,
    time_bucket, score_C_bucket, score_S_bucket
);
CREATE VIEW v_score_h AS
SELECT
    instId,
    side,
    ctx,
    regime,
    tf_ref,
    time_bucket,
    score_C_bucket,
    score_S_bucket,
    score_H,
    n_trades,
    expectancy,
    ts_last_update
FROM h_stats
/* v_score_h(instId,side,ctx,regime,tf_ref,time_bucket,score_C_bucket,score_S_bucket,score_H,n_trades,expectancy,ts_last_update) */;

----------------------------------------
DATABASE: market.db
----------------------------------------
CREATE VIEW v_market_flags AS
SELECT
    instId,

    CASE
        WHEN staleness_ms IS NULL OR staleness_ms > 3000 THEN 0
        ELSE 1
    END AS market_fresh,

    CASE
        WHEN ticks_5s >= 5 THEN 1
        ELSE 0
    END AS market_active,

    CASE
        WHEN spread_ok = 1 AND liquidity_ok = 1 THEN 1
        ELSE 0
    END AS market_clean

FROM v_market_latest
/* v_market_flags(instId,market_fresh,market_active,market_clean) */;
CREATE TABLE market_tick_stats (
  instId TEXT NOT NULL,
  ts INTEGER NOT NULL,

  last REAL,
  bid REAL,
  ask REAL,

  spread_abs REAL,
  spread_bps REAL,

  ticks_1s INTEGER,
  ticks_5s INTEGER,

  staleness_ms INTEGER
);
CREATE INDEX idx_mkt_ticks_inst_ts
ON market_tick_stats(instId, ts DESC);
CREATE TABLE market_volatility (
  instId TEXT,
  ts INTEGER,
  range_1s REAL,
  range_5s REAL,
  atr REAL,
  vol_norm REAL
);
CREATE INDEX idx_mkt_vol_inst_ts
ON market_volatility(instId, ts DESC);
CREATE TABLE market_liquidity (
  instId TEXT,
  ts INTEGER,
  volume_24h REAL,
  funding REAL,
  spread_ok INTEGER,
  liquidity_ok INTEGER
);
CREATE INDEX idx_mkt_liq_inst_ts
ON market_liquidity(instId, ts DESC);
CREATE TABLE market_latest (
  instId TEXT PRIMARY KEY,
  ticks_5s INTEGER NOT NULL,
  spread_bps REAL NOT NULL,
  staleness_ms INTEGER NOT NULL,
  ts_update INTEGER NOT NULL
);
CREATE VIEW v_market_latest AS
SELECT
  instId,

  ticks_5s,
  spread_bps,
  staleness_ms,

  -- flags normalisés (ATTENDUS par monitor / dec)
  CASE WHEN spread_bps <= 5.0 THEN 1 ELSE 0 END AS spread_ok,
  CASE WHEN ticks_5s >= 5 THEN 1 ELSE 0 END AS liquidity_ok,
  CASE
    WHEN ticks_5s >= 5
     AND spread_bps <= 5.0
     AND staleness_ms <= 1000
    THEN 1 ELSE 0
  END AS market_ok,

  ts_update
FROM market_latest
/* v_market_latest(instId,ticks_5s,spread_bps,staleness_ms,spread_ok,liquidity_ok,market_ok,ts_update) */;
CREATE VIEW v_market_scored AS
WITH vol_latest AS (
  SELECT
    v.instId,
    v.vol_norm,
    v.ts
  FROM market_volatility v
  WHERE v.ts = (
    SELECT MAX(ts)
    FROM market_volatility v2
    WHERE v2.instId = v.instId
  )
)
SELECT
  m.instId,

  -- timestamp canonique
  m.ts_update AS ts,

  -- ==========================================================
  -- RAW MARKET DATA
  -- ==========================================================
  m.ticks_5s,
  m.spread_bps,
  v.vol_norm,
  m.staleness_ms,
  m.spread_ok,
  m.liquidity_ok,
  m.market_ok,

  -- ==========================================================
  -- SCORES
  -- ==========================================================

  -- Activity (0–40)
  MIN(40, m.ticks_5s * 4) AS ticks_score,

  -- Cost (0–30)
  MAX(0, 30 - m.spread_bps * 6) AS spread_score,

  -- Volatility (0–30)
  CASE
    WHEN v.vol_norm BETWEEN 0.25 AND 0.80 THEN 30
    WHEN v.vol_norm BETWEEN 0.10 AND 0.25 THEN 20
    WHEN v.vol_norm > 0.80              THEN 20
    WHEN v.vol_norm < 0.10              THEN 10
    ELSE 0
  END AS vol_score,

  -- ==========================================================
  -- TOTAL SCORE (0–100)
  -- ==========================================================
  (
    MIN(40, m.ticks_5s * 4)
    + MAX(0, 30 - m.spread_bps * 6)
    + CASE
        WHEN v.vol_norm BETWEEN 0.25 AND 0.80 THEN 30
        WHEN v.vol_norm BETWEEN 0.10 AND 0.25 THEN 20
        WHEN v.vol_norm > 0.80              THEN 20
        WHEN v.vol_norm < 0.10              THEN 10
        ELSE 0
      END
  ) AS market_score,

  -- ==========================================================
  -- RISK FACTOR (0.30 → 1.00)
  -- ==========================================================
  MAX(
    0.30,
    MIN(
      1.00,
      (
        (
          MIN(40, m.ticks_5s * 4)
          + MAX(0, 30 - m.spread_bps * 6)
          + CASE
              WHEN v.vol_norm BETWEEN 0.25 AND 0.80 THEN 30
              WHEN v.vol_norm BETWEEN 0.10 AND 0.25 THEN 20
              WHEN v.vol_norm > 0.80              THEN 20
              WHEN v.vol_norm < 0.10              THEN 10
              ELSE 0
            END
        ) / 100.0
      )
    )
  ) AS market_risk_factor

FROM v_market_latest m
LEFT JOIN vol_latest v
  ON v.instId = m.instId
/* v_market_scored(instId,ts,ticks_5s,spread_bps,vol_norm,staleness_ms,spread_ok,liquidity_ok,market_ok,ticks_score,spread_score,vol_score,market_score,market_risk_factor) */;
CREATE VIEW v_market_score_latest AS
SELECT
  instId,
  market_score,
  market_risk_factor,
  ts
FROM v_market_scored
WHERE ts = (
  SELECT MAX(ts)
  FROM v_market_scored m2
  WHERE m2.instId = v_market_scored.instId
)
/* v_market_score_latest(instId,market_score,market_risk_factor,ts) */;

----------------------------------------
DATABASE: mfe_mae.db
----------------------------------------
CREATE TABLE mfe_mae (
    uid TEXT PRIMARY KEY,

    instId TEXT NOT NULL,
    side TEXT NOT NULL,

    entry_price REAL NOT NULL,
    ts_open INTEGER NOT NULL,

    mfe REAL DEFAULT 0,
    mfe_ts INTEGER,

    mae REAL DEFAULT 0,
    mae_ts INTEGER,

    last_price REAL,
    last_ts INTEGER,

    ts_updated INTEGER NOT NULL
, atr REAL);
CREATE TABLE snap_gest (
    uid         TEXT PRIMARY KEY,
    instId      TEXT,
    side        TEXT,
    entry_price REAL,
    atr         REAL,
    ts_open     INTEGER,
    ts_snap     INTEGER
);
CREATE INDEX idx_snap_gest_instId ON snap_gest(instId);
CREATE INDEX idx_mfe_mae_inst
ON mfe_mae(instId);
CREATE VIEW v_follow_mfe AS
SELECT
    uid,
    instId,
    side,

    entry_price,
    ts_open,

    mfe,
    mfe_ts,
    mae,
    mae_ts,

    atr,

    CASE
        WHEN atr > 0 THEN mfe / atr
        ELSE NULL
    END AS mfe_atr,

    CASE
        WHEN atr > 0 THEN ABS(mae) / atr
        ELSE NULL
    END AS mae_atr,

    last_price,
    last_ts,
    ts_updated
FROM mfe_mae
/* v_follow_mfe(uid,instId,side,entry_price,ts_open,mfe,mfe_ts,mae,mae_ts,atr,mfe_atr,mae_atr,last_price,last_ts,ts_updated) */;
CREATE VIEW v_mfe_mae_atr AS
SELECT
  uid,
  instId,
  side,
  entry_price,
  ts_open,

  mfe,
  mae,
  atr,

  CASE
    WHEN atr > 0 THEN mfe / atr
    ELSE 0
  END AS mfe_atr,

  CASE
    WHEN atr > 0 THEN ABS(mae) / atr
    ELSE 0
  END AS mae_atr,

  mfe_ts,
  mae_ts,
  last_price,
  last_ts,
  ts_updated
FROM mfe_mae
/* v_mfe_mae_atr(uid,instId,side,entry_price,ts_open,mfe,mae,atr,mfe_atr,mae_atr,mfe_ts,mae_ts,last_price,last_ts,ts_updated) */;

----------------------------------------
DATABASE: mfemae.db
----------------------------------------

----------------------------------------
DATABASE: monitor.db
----------------------------------------
CREATE TABLE pipeline_snapshot (
    ts              INTEGER PRIMARY KEY,
    universe_total  INTEGER,
    market_ok       INTEGER,
    ctx_ok          INTEGER,
    dec_tradable    INTEGER,
    armed           INTEGER,
    fired           INTEGER,
    lost_market     INTEGER,
    lost_ctx        INTEGER,
    lost_dec        INTEGER,
    lost_armed      INTEGER
);
CREATE TABLE snap_ctx_market (
  instId TEXT PRIMARY KEY,
  ctx TEXT,
  score_C REAL,
  side TEXT,
  ctx_ok INTEGER,
  market_ok INTEGER,
  ts_updated INTEGER
);
CREATE TABLE snap_dec_explain (
  instId TEXT PRIMARY KEY,
  ctx_ok INTEGER,
  has_range INTEGER,
  has_atr INTEGER,
  compression_ok INTEGER,
  breaking_now INTEGER
);

----------------------------------------
DATABASE: monitor_live.db
----------------------------------------
CREATE TABLE position_snapshot (
            uid TEXT PRIMARY KEY,
            instId TEXT,
            side TEXT,
            entry REAL,
            price REAL,
            qty REAL,
            pnl REAL,
            pnl_pct REAL,
            mfe REAL,
            mae REAL,
            atr REAL,
            age_s REAL,
            status TEXT,
            ts INTEGER
        );

----------------------------------------
DATABASE: oa.db
----------------------------------------
CREATE TABLE sqlite_sequence(name,seq);
CREATE TABLE ohlcv_5m (
    instId TEXT NOT NULL,
    ts INTEGER NOT NULL,
    open REAL,
    high REAL,
    low REAL,
    close REAL,
    volume REAL,
    PRIMARY KEY (instId, ts)
);
CREATE TABLE ohlcv_15m (
    instId TEXT NOT NULL,
    ts INTEGER NOT NULL,
    open REAL,
    high REAL,
    low REAL,
    close REAL,
    volume REAL,
    PRIMARY KEY (instId, ts)
);
CREATE TABLE ohlcv_30m (
    instId TEXT NOT NULL,
    ts INTEGER NOT NULL,
    open REAL,
    high REAL,
    low REAL,
    close REAL,
    volume REAL,
    PRIMARY KEY (instId, ts)
);
CREATE VIEW v_ohlcv_5m_latest AS
SELECT *
FROM ohlcv_5m
WHERE ts IN (
    SELECT ts FROM ohlcv_5m AS o2
    WHERE o2.instId = ohlcv_5m.instId
    ORDER BY ts DESC
    LIMIT 150
)
/* v_ohlcv_5m_latest(instId,ts,open,high,low,close,volume) */;
CREATE VIEW v_ohlcv_15m_latest AS
SELECT *
FROM ohlcv_15m
WHERE ts IN (
    SELECT ts FROM ohlcv_15m AS o2
    WHERE o2.instId = ohlcv_15m.instId
    ORDER BY ts DESC
    LIMIT 150
)
/* v_ohlcv_15m_latest(instId,ts,open,high,low,close,volume) */;
CREATE VIEW v_ohlcv_30m_latest AS
SELECT *
FROM ohlcv_30m
WHERE ts IN (
    SELECT ts FROM ohlcv_30m AS o2
    WHERE o2.instId = ohlcv_30m.instId
    ORDER BY ts DESC
    LIMIT 150
)
/* v_ohlcv_30m_latest(instId,ts,open,high,low,close,volume) */;
CREATE INDEX idx_ohlcv_5m_ts  ON ohlcv_5m(ts);
CREATE INDEX idx_ohlcv_15m_ts ON ohlcv_15m(ts);
CREATE INDEX idx_ohlcv_30m_ts ON ohlcv_30m(ts);

----------------------------------------
DATABASE: ob.db
----------------------------------------
CREATE TABLE ohlcv_1m (
    instId TEXT NOT NULL,
    ts     INTEGER NOT NULL,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE ohlcv_3m (
    instId TEXT NOT NULL,
    ts     INTEGER NOT NULL,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE ohlcv_5m (
    instId TEXT NOT NULL,
    ts     INTEGER NOT NULL,
    o REAL, h REAL, l REAL, c REAL, v REAL,
    PRIMARY KEY(instId, ts)
);
CREATE TABLE feat_1m (
            instId TEXT NOT NULL,
            ts INTEGER NOT NULL,
            open REAL, high REAL, low REAL, close REAL, vol REAL,
            PRIMARY KEY(instId, ts)
        );
CREATE TABLE feat_3m (
            instId TEXT NOT NULL,
            ts INTEGER NOT NULL,
            open REAL, high REAL, low REAL, close REAL, vol REAL,
            PRIMARY KEY(instId, ts)
        );
CREATE TABLE feat_5m (
            instId TEXT NOT NULL,
            ts INTEGER NOT NULL,
            open REAL, high REAL, low REAL, close REAL, vol REAL,
            PRIMARY KEY(instId, ts)
        );

----------------------------------------
DATABASE: opener.db
----------------------------------------
CREATE TABLE IF NOT EXISTS "opener_backup_1768073835" (
    uid TEXT,
    instId TEXT,
    side TEXT,
    qty REAL,
    lev REAL,
    ts_open INTEGER,
    price_exec_open REAL,
    status TEXT,
    exec_type TEXT,
    step INTEGER,
    reason TEXT,
    PRIMARY KEY (uid, exec_type, step)
);
CREATE TABLE IF NOT EXISTS "opener" (
    uid TEXT NOT NULL,
    instId TEXT NOT NULL,
    side TEXT NOT NULL,
    qty REAL NOT NULL,
    lev REAL NOT NULL,
    ts_open INTEGER,
    price_exec_open REAL,
    status TEXT NOT NULL,
    exec_type TEXT NOT NULL,
    step INTEGER NOT NULL, ratio REAL, qty_raw REAL, qty_norm REAL, reject_reason TEXT,
    PRIMARY KEY (uid, exec_type, step)
);
CREATE VIEW v_opener AS SELECT * FROM opener
/* v_opener(uid,instId,side,qty,lev,ts_open,price_exec_open,status,exec_type,step,ratio,qty_raw,qty_norm,reject_reason) */;

----------------------------------------
DATABASE: record.db
----------------------------------------

----------------------------------------
DATABASE: recorder.db
----------------------------------------
