# DUMP 20250825-081800
Repo: /notebooks/scalp

================================================================================
ARBORESCENCE
================================================================================
.gitignore  (last modified: 2025-08-24 16:58:01)
CHANGELOG.md  (last modified: 2025-08-24 16:58:01)
INSTALL.txt  (last modified: 2025-08-24 16:58:01)
Makefile  (last modified: 2025-08-24 16:58:01)
PROMPT.md  (last modified: 2025-08-24 16:58:01)
README.md  (last modified: 2025-08-24 16:58:01)
STRATEGY.md  (last modified: 2025-08-24 16:58:01)
bot.py  (last modified: 2025-08-24 17:01:47)
cli.py  (last modified: 2025-08-24 16:58:01)
dash/
dash/app.py  (last modified: 2025-08-24 16:58:01)
data/
data/BTCUSDT-1m.csv  (last modified: 2025-08-24 16:58:01)
data/__init__.py  (last modified: 2025-08-24 16:58:01)
dump.txt  (last modified: 2025-08-24 16:58:01)
engine/
engine/VERSION  (last modified: 2025-08-24 16:58:01)
engine/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/adapters/
engine/adapters/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/adapters/bitget.py  (last modified: 2025-08-24 16:58:01)
engine/adapters/bitget_fetch.py  (last modified: 2025-08-24 16:58:01)
engine/adapters/market_data.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/
engine/backtest/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/cache.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/cli.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/engine.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/grid_search.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/loader_csv.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/market_data.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/metrics.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/optimize.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/position_sizing.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/run_multi.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/runner.py  (last modified: 2025-08-24 16:58:01)
engine/backtest/walkforward.py  (last modified: 2025-08-24 16:58:01)
engine/bitget_client.py  (last modified: 2025-08-24 16:58:01)
engine/client.py  (last modified: 2025-08-24 16:58:01)
engine/config/
engine/config/config.yaml  (last modified: 2025-08-24 16:58:01)
engine/config/loader.py  (last modified: 2025-08-24 16:58:01)
engine/config/strategies.py  (last modified: 2025-08-24 16:58:01)
engine/config/watchlist.py  (last modified: 2025-08-24 16:58:01)
engine/core/
engine/core/indicators.py  (last modified: 2025-08-24 16:58:01)
engine/core/signal.py  (last modified: 2025-08-24 16:58:01)
engine/core/signals.py  (last modified: 2025-08-24 16:58:01)
engine/exchange/
engine/exchange/bitget_ccxt.py  (last modified: 2025-08-24 16:58:01)
engine/exchange/bitget_rest.py  (last modified: 2025-08-24 16:58:01)
engine/hooks/
engine/hooks/prewarm_cache.py  (last modified: 2025-08-24 16:58:01)
engine/live/
engine/live/commands.py  (last modified: 2025-08-24 16:58:01)
engine/live/notify.py  (last modified: 2025-08-24 16:58:01)
engine/live/orchestrator.py  (last modified: 2025-08-24 16:58:01)
engine/live/trader.py  (last modified: 2025-08-24 16:58:01)
engine/logging_utils.py  (last modified: 2025-08-24 16:58:01)
engine/metrics.py  (last modified: 2025-08-24 16:58:01)
engine/pairs/
engine/pairs/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/pairs/selector.py  (last modified: 2025-08-24 16:58:01)
engine/pairs.py  (last modified: 2025-08-24 16:58:01)
engine/positions/
engine/positions/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/positions/state.py  (last modified: 2025-08-24 16:58:01)
engine/risk/
engine/risk/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/risk/manager.py  (last modified: 2025-08-24 16:58:01)
engine/selection/
engine/selection/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/selection/momentum.py  (last modified: 2025-08-24 16:58:01)
engine/selection/scanner.py  (last modified: 2025-08-24 16:58:01)
engine/selfcheck.py  (last modified: 2025-08-24 16:58:01)
engine/services/
engine/services/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/services/data_cache.py  (last modified: 2025-08-24 16:58:01)
engine/services/order_service.py  (last modified: 2025-08-24 16:58:01)
engine/services/utils.py  (last modified: 2025-08-24 16:58:01)
engine/signals/
engine/signals/__init__.py  (last modified: 2025-08-24 16:58:01)
engine/signals/current.py  (last modified: 2025-08-24 16:58:01)
engine/signals/factory.py  (last modified: 2025-08-24 16:58:01)
engine/signals/generator.py  (last modified: 2025-08-24 16:58:01)
engine/strategy/
engine/strategy/factory.py  (last modified: 2025-08-24 16:58:01)
engine/strategy.py  (last modified: 2025-08-24 16:58:01)
engine/trade_utils.py  (last modified: 2025-08-24 16:58:01)
engine/utils/
engine/utils/bootstrap.py  (last modified: 2025-08-24 16:58:01)
engine/version.py  (last modified: 2025-08-24 16:58:01)
engine/ws.py  (last modified: 2025-08-24 16:58:01)
init.py  (last modified: 2025-08-24 16:58:01)
jobs/
jobs/backfill.py  (last modified: 2025-08-24 16:58:01)
jobs/backtest.py  (last modified: 2025-08-24 16:58:01)
jobs/dash.py  (last modified: 2025-08-24 16:58:01)
jobs/promote.py  (last modified: 2025-08-24 16:58:01)
jobs/refresh_pairs.py  (last modified: 2025-08-24 16:58:01)
jobs/viewer.py  (last modified: 2025-08-24 16:58:01)
pytest.ini  (last modified: 2025-08-24 16:58:01)
requirements-dev.txt  (last modified: 2025-08-24 16:58:01)
requirements.txt  (last modified: 2025-08-24 16:58:01)
resultat.log  (last modified: 2025-08-24 16:58:01)
scalper/
scalper/config/
scalper/config/__init__.py  (last modified: 2025-08-24 16:58:01)
scalper/config/loader.py  (last modified: 2025-08-24 16:58:01)
scalper/config/strategies.yml  (last modified: 2025-08-24 16:58:01)
scalper/exchange/
scalper/exchange/__init__.py  (last modified: 2025-08-24 16:58:01)
scalper/exchange/bitget.py  (last modified: 2025-08-24 16:58:01)
scalper/exchange/bitget_ccxt.py  (last modified: 2025-08-24 16:58:01)
scalper/exchange/fees.py  (last modified: 2025-08-24 16:58:01)
scalper/live/
scalper/live/__init__.py  (last modified: 2025-08-24 16:58:01)
scalper/live/backtest_telegram.py  (last modified: 2025-08-24 16:58:01)
scalper/live/commands.py  (last modified: 2025-08-24 16:58:01)
scalper/live/data_utils.py  (last modified: 2025-08-24 16:58:01)
scalper/live/fetcher.py  (last modified: 2025-08-24 16:58:01)
scalper/live/journal.py  (last modified: 2025-08-24 16:58:01)
scalper/live/logs.py  (last modified: 2025-08-24 16:58:01)
scalper/live/loops/
scalper/live/loops/trade.py  (last modified: 2025-08-24 16:58:01)
scalper/live/notify.py  (last modified: 2025-08-24 16:58:01)
scalper/live/ohlcv_service.py  (last modified: 2025-08-24 16:58:01)
scalper/live/orchestrator.py  (last modified: 2025-08-24 16:58:01)
scalper/live/orders.py  (last modified: 2025-08-24 16:58:01)
scalper/live/position_fsm.py  (last modified: 2025-08-24 16:58:01)
scalper/live/runner.py  (last modified: 2025-08-24 16:58:01)
scalper/live/setup_wizard.py  (last modified: 2025-08-24 16:58:01)
scalper/live/state_store.py  (last modified: 2025-08-24 16:58:01)
scalper/live/telegram_async.py  (last modified: 2025-08-24 16:58:01)
scalper/live/watchlist.py  (last modified: 2025-08-24 16:58:01)
sitecustomize.py  (last modified: 2025-08-24 18:01:27)
tg_diag.py  (last modified: 2025-08-24 16:58:01)
tools/
tools/dump-repo.py  (last modified: 2025-08-24 16:58:01)
tools/migrate-to-engine.py  (last modified: 2025-08-24 16:58:01)
tools/trashify.py  (last modified: 2025-08-24 19:22:16)

================================================================================
FICHIERS COMPLETS
================================================================================

--------------------------------------------------------------------------------
FILE: .gitignore  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: __pycache__/
     2: *.pyc
     3: .pytest_cache/
     4: logs/

--------------------------------------------------------------------------------
FILE: CHANGELOG.md  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Changelog
     2: 
     3: ## Unreleased
     4: 
     5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
     6:   signal levels.
     7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
     8:   user risk level.
     9: - Notional and margin caps with available balance check to avoid Bitget error
    10:   `40762`.
    11: - Risk notifications with green/yellow/red indicators for terminal and
    12:   Telegram.

--------------------------------------------------------------------------------
FILE: INSTALL.txt  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # INSTALLATION — Projet scalp
     2: 
     3: Prérequis système
     4: - Python 3.10+ (recommandé 3.11)
     5: - Accès réseau sortant (Bitget API, Telegram)
     6: - Espace persistant pour DATA_ROOT (ex: /notebooks/scalp_data)
     7: 
     8: 1) Création d’environnement virtuel (recommandé)
     9:    python -m venv .venv
    10:    . .venv/bin/activate
    11:    python -m pip install --upgrade pip
    12: 
    13: 2) Installation des dépendances
    14:    pip install -r requirements.txt
    15: 
    16: 3) Configuration .env (dans /notebooks/.env)
    17:    TELEGRAM_BOT_TOKEN=xxxx
    18:    TELEGRAM_CHAT_ID=123456
    19:    BITGET_ACCESS_KEY=xxxx
    20:    BITGET_SECRET_KEY=xxxx
    21:    BITGET_PASSPHRASE=xxxx
    22:    DATA_ROOT=/notebooks/scalp_data
    23:    LOG_LEVEL=INFO
    24: 
    25: 4) Premier run (collecte market data simple)
    26:    python bot.py
    27:    → écrit /notebooks/scalp_data/data/live/logs/signals.csv
    28: 
    29: 5) Mise à jour pairs + backfill
    30:    python jobs/refresh_pairs.py --timeframe 5m --top 10 --backfill-tfs 1m,5m,15m,1h --limit 2000
    31: 
    32: 6) Backtests + promotion stratégie
    33:    python jobs/backtest.py --from-watchlist --tfs 1m,5m,15m,1h
    34:    python jobs/promote.py --draft /notebooks/scalp_data/reports/strategies.yml.next
    35: 
    36: 7) Lancement live (avec stratégies promues)
    37:    python bot.py
    38:    → écrit /notebooks/scalp_data/data/live/orders.csv (paper mode)
    39: 
    40: 8) Dashboard (optionnel)
    41:    streamlit run dash/app.py --server.port 8501 --server.headless true

--------------------------------------------------------------------------------
FILE: Makefile  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: .PHONY: test
     2: 
     3: test:
     4: 	pytest
     5: 
     6: dash:
     7: 	@. .venv/bin/activate && python jobs/dash.py --headless --port 8501

--------------------------------------------------------------------------------
FILE: PROMPT.md  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Prompt de re-création du bot Scalp (version spot)
     2: 
     3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
     4: 
     5: ## Structure principale
     6: 
     7: ### bot.py
     8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
     9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
    10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
    11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
    12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
    13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
    14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
    15: 
    16: ### cli.py
    17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
    18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
    19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
    20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
    21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
    22: 
    23: ### init.py
    24: - `install_packages(*args)` : installe des paquets via `pip`.
    25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
    26: 
    27: ## Modules `scalp`
    28: 
    29: ### bot_config.py
    30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
    31: 
    32: ### metrics.py
    33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
    34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
    35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
    36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
    37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
    38: 
    39: ### strategy.py
    40: - `ema(series, window)` : moyenne mobile exponentielle.
    41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
    42: - `obv(closes, volumes)` : série On Balance Volume.
    43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
    44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
    45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
    46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
    47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
    48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
    49: 
    50: ### trade_utils.py
    51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
    52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
    53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
    54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
    55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
    56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
    57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
    58: 
    59: ### risk
    60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
    61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
    62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
    63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
    64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
    65: 
    66: ### notifier.py
    67: - `_pair_name(symbol)` : formatte le nom d’une paire.
    68: - `_format_text(event, payload=None)` : construit un message lisible.
    69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
    70: 
    71: ### logging_utils.py
    72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
    73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
    74: 
    75: ### bitget_client.py
    76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
    77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
    78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
    79:   - `get_account()`, `get_open_orders(symbol=None)`.
    80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
    81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
    82: 
    83: ### pairs.py
    84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
    85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
    86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
    87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
    88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
    89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
    90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
    91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
    92: 
    93: ### telegram_bot.py
    94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
    95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
    96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
    97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
    98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
    99: 
   100: ## Utilisation
   101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   102: 2. Exécuter `init.py` pour installer les dépendances.
   103: 3. Lancer `bot.py` pour démarrer le trading.
   104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   105: 
   106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   107: 

--------------------------------------------------------------------------------
FILE: README.md  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Scalp
     2: 
     3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
     4: 
     5: ## Installation
     6: 
     7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
     8: 
     9: ```bash
    10: pip install -r requirements.txt
    11: ```
    12: 
    13: Pour développer ou exécuter les tests :
    14: 
    15: ```bash
    16: pip install -r requirements-dev.txt
    17: pytest  # ou make test
    18: ```
    19: 
    20: ## Configuration
    21: 
    22: Le bot lit sa configuration via des variables d'environnement :
    23: 
    24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
    25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
    26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
    27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
    28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
    29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
    30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
    31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
    32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
    33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
    34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
    35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
    36: 
    37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
    38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
    39: 
    40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
    41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
    42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
    43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
    44: bot.
    45: 
    46: 
    47: Exemple :
    48: 
    49: ```bash
    50: export BITGET_ACCESS_KEY="votre_cle"
    51: export BITGET_SECRET_KEY="votre_secret"
    52: export PAPER_TRADE=true
    53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
    54: export TELEGRAM_CHAT_ID="123456789"
    55: python bot.py
    56: ```
    57: 
    58: ## Lancement
    59: 
    60: Après configuration, lancez simplement :
    61: 
    62: ```bash
    63: python bot.py
    64: ```
    65: 
    66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
    67: 
    68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
    69: 
    70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
    71: 
    72: 
    73: ## Stratégie
    74: 
    75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
    76: rapidement les pertes.
    77: 
    78: Principes généraux :
    79: 
    80: - sélection de paires liquides au fort momentum ;
    81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
    82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
    83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
    84:   calculée selon le risque ;
    85: - limites quotidiennes pour protéger le capital.
    86: 
    87: Les règles détaillées et l’algorithme complet sont décrits dans
    88: `STRATEGY.md`.
    89: 
    90: ## Version
    91: 
    92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
    93: le code via la variable `scalp.__version__` :
    94: 
    95: ```python
    96: from scalp import __version__
    97: print(__version__)
    98: ```
    99: 
   100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   101: 
   102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   103: `scalp.version.bump_version_from_message` permet également de déterminer
   104: automatiquement l'incrément à appliquer à partir d'un message de commit
   105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   106: 
   107: Exemple d'incrément basé sur un message :
   108: 
   109: ```python
   110: from scalp.version import bump_version_from_message
   111: bump_version_from_message("feat: add new strategy")
   112: ```
   113: 
   114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   115: message de commit `git` et met à jour le fichier `VERSION` en
   116: conséquence.
   117: 
   118: La même opération peut être déclenchée depuis la ligne de commande via
   119: `cli.py` :
   120: 
   121: ```bash
   122: python cli.py bump-version
   123: ```
   124: 
   125: 
   126: ## Changelog
   127: 
   128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   129: 
   130: ## Avertissement
   131: 
   132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.

--------------------------------------------------------------------------------
FILE: STRATEGY.md  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Stratégie de trading
     2: 
     3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
     4: 
     5: ## Principes généraux
     6: 
     7: - ne traiter que des actifs liquides à fort momentum ;
     8: - suivre la tendance dominante et éviter les marchés plats ;
     9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
    10: - dimensionner chaque position selon un pourcentage fixe du capital ;
    11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
    12: 
    13: ## Sélection des paires
    14: 
    15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
    16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
    17:    - croisement entre EMA20 et EMA50 ;
    18:    - ATR élevé pour privilégier les actifs volatils.
    19: 
    20: ## Génération du signal
    21: 
    22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
    23: 
    24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
    25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
    26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
    27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
    28: - cassure du dernier **swing high/low** ;
    29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
    30: 
    31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
    32: 
    33: ## Gestion du risque
    34: 
    35: La classe `RiskManager` applique plusieurs garde‑fous :
    36: 
    37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
    38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
    39: - pause forcée en cas de pertes consécutives prolongées ;
    40: - contrôle du nombre maximal de positions ouvertes.
    41: 
    42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.

--------------------------------------------------------------------------------
FILE: bot.py  (last modified: 2025-08-24 17:01:47)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # --- bootstrap forcé (au cas où sitecustomize ne se charge pas automatiquement) ---
     3: from __future__ import annotations
     4: 
     5: import asyncio
     6: import logging
     7: import os
     8: import sys
     9: from typing import Any, Dict, Iterable, Optional, Sequence
    10: from pathlib import Path
    11: 
    12: # s'assurer que la racine du repo est bien sur sys.path
    13: ROOT = Path(__file__).resolve().parent
    14: if str(ROOT) not in sys.path:
    15:     sys.path.insert(0, str(ROOT))
    16: 
    17: # forcer l'import de sitecustomize (verbeux)
    18: try:
    19:     import sitecustomize  # noqa: F401
    20:     print("[bootstrap] sitecustomize importé (OK)")
    21: except Exception as e:
    22:     print(f"[bootstrap] sitecustomize non importé: {e}")
    23:     # dernier filet de sécurité: installation directe des deps
    24:     try:
    25:         from engine.utils.bootstrap import ensure_dependencies
    26:         deps = ensure_dependencies(with_dash=True, with_ccxt=True)
    27:         print("[bootstrap] ensure_dependencies:", deps)
    28:     except Exception as ee:
    29:         print(f"[bootstrap] fallback ensure_dependencies a échoué: {ee}")
    30: # --- fin bootstrap forcé ---
    31: 
    32: 
    33: from engine.config.loader import load_config
    34: from engine.live.orchestrator import RunConfig, run_orchestrator
    35: from engine.live.notify import build_notifier
    36: from engine.live.commands import build_command_stream
    37: 
    38: LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
    39: logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
    40:                     format="%(asctime)s %(levelname)s %(name)s: %(message)s")
    41: log = logging.getLogger("bot")
    42: 
    43: 
    44: def _build_exchange(cfg: Dict[str, Any]):
    45:     try:
    46:         from engine.exchange.bitget_ccxt import BitgetExchange
    47:         ex = BitgetExchange(
    48:             api_key=cfg["secrets"]["bitget"]["access"],
    49:             secret=cfg["secrets"]["bitget"]["secret"],
    50:             password=cfg["secrets"]["bitget"]["passphrase"],
    51:             data_dir=cfg["runtime"]["data_dir"],
    52:         )
    53:         log.info("Exchange CCXT initialisé")
    54:         return ex
    55:     except Exception as exc:
    56:         log.warning("CCXT indisponible (%s) — fallback REST", exc)
    57:         from engine.exchange.bitget_rest import BitgetFuturesClient
    58:         return BitgetFuturesClient(
    59:             access_key=cfg["secrets"]["bitget"]["access"],
    60:             secret_key=cfg["secrets"]["bitget"]["secret"],
    61:             passphrase=cfg["secrets"]["bitget"]["passphrase"],
    62:             base_url=os.getenv("BITGET_BASE_URL", "https://api.bitget.com"),
    63:             paper_trade=cfg["runtime"].get("paper_trade", True),
    64:         )
    65: 
    66: 
    67: async def _run() -> int:
    68:     cfg = load_config()
    69:     runtime, strategy = cfg.get("runtime", {}), cfg.get("strategy", {})
    70:     symbols: Sequence[str] = runtime.get("allowed_symbols") or []
    71:     run_cfg = RunConfig(
    72:         symbols=symbols or ["BTCUSDT", "ETHUSDT", "SOLUSDT"],
    73:         timeframe=strategy.get("live_timeframe", "1m"),
    74:         refresh_secs=int(runtime.get("refresh_secs", 5)),
    75:         cache_dir=str(runtime.get("data_dir")),
    76:     )
    77:     ex = _build_exchange(cfg)
    78:     notifier = build_notifier(cfg)
    79:     cmd_stream = build_command_stream(cfg)
    80:     await run_orchestrator(ex, run_cfg, notifier, cmd_stream)
    81:     return 0
    82: 
    83: 
    84: def main(argv: Optional[Iterable[str]] = None) -> int:
    85:     try:
    86:         return asyncio.run(_run())
    87:     except KeyboardInterrupt:
    88:         log.info("Arrêt demandé (Ctrl+C)")
    89:         return 0
    90: 
    91: 
    92: if __name__ == "__main__":
    93:     raise SystemExit(main(sys.argv[1:]))

--------------------------------------------------------------------------------
FILE: cli.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Command line utilities for the Scalp project.
     2: 
     3: This module exposes a small command line interface used throughout the
     4: project.  The actual trading logic lives in other modules, however the CLI is
     5: responsible for parsing parameters and dispatching the appropriate routines.
     6: 
     7: The implementation intentionally keeps the invoked functions minimal so that
     8: tests can patch them easily.  In a real deployment these functions would
     9: perform optimisation, walk‑forward analysis or run the live pipeline.
    10: """
    11: 
    12: from __future__ import annotations
    13: 
    14: import argparse
    15: import asyncio
    16: from typing import Iterable, List
    17: 
    18: from engine.version import bump_version_from_git
    19: 
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Placeholder implementations
    23: # ---------------------------------------------------------------------------
    24: 
    25: 
    26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    27:     """Run a parallel parameter optimisation.
    28: 
    29:     The real project dispatches a potentially heavy optimisation routine.  The
    30:     function is kept trivial so unit tests can verify that the CLI wiring works
    31:     without actually performing the optimisation.
    32:     """
    33: 
    34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
    35: 
    36: 
    37: def run_walkforward_analysis(
    38:     pair: str, timeframe: str, splits: int, train_ratio: float
    39: ) -> None:
    40:     """Execute a walk-forward analysis."""
    41: 
    42:     print(
    43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    44:     )
    45: 
    46: 
    47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    48:     """Run the live trading pipeline."""
    49: 
    50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
    51: 
    52: 
    53: # ---------------------------------------------------------------------------
    54: # Argument parsing
    55: # ---------------------------------------------------------------------------
    56: 
    57: 
    58: def create_parser() -> argparse.ArgumentParser:
    59:     """Create the top-level argument parser."""
    60: 
    61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
    62:     sub = parser.add_subparsers(dest="command")
    63: 
    64:     # --- ``opt`` command -------------------------------------------------
    65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    67:     opt_p.add_argument("--tf", required=True, help="timeframe")
    68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    69:     opt_p.set_defaults(
    70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    71:     )
    72: 
    73:     # --- ``walkforward`` command ----------------------------------------
    74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    75:     wf_p.add_argument("--pair", required=True, help="trading pair")
    76:     wf_p.add_argument("--tf", required=True, help="timeframe")
    77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    78:     wf_p.add_argument(
    79:         "--train-ratio",
    80:         type=float,
    81:         default=0.7,
    82:         help="portion of data used for training",
    83:     )
    84:     wf_p.set_defaults(
    85:         func=lambda a: run_walkforward_analysis(
    86:             a.pair, a.tf, a.splits, a.train_ratio
    87:         )
    88:     )
    89: 
    90:     # --- ``live`` command -----------------------------------------------
    91:     live_p = sub.add_parser("live", help="run the live async pipeline")
    92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
    95: 
    96:     # --- ``bump-version`` command -------------------------------------
    97:     bv_p = sub.add_parser(
    98:         "bump-version",
    99:         help="update the VERSION file based on the latest git commit",
   100:     )
   101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
   102: 
   103:     return parser
   104: 
   105: 
   106: def main(argv: Iterable[str] | None = None) -> int:
   107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
   108: 
   109:     parser = create_parser()
   110:     args = parser.parse_args(argv)
   111:     if not hasattr(args, "func"):
   112:         parser.print_help()
   113:         return 0
   114:     result = args.func(args)
   115:     return 0 if result is None else int(result)
   116: 
   117: 
   118: if __name__ == "__main__":  # pragma: no cover - manual invocation
   119:     raise SystemExit(main())
   120: 

--------------------------------------------------------------------------------
FILE: dash/app.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # dash/app.py
     2: from __future__ import annotations
     3: 
     4: import json
     5: import os
     6: from pathlib import Path
     7: from typing import Dict, List, Tuple
     8: 
     9: import pandas as pd
    10: import streamlit as st
    11: 
    12: # ---------- config & chemins ----------
    13: def _load_config_paths() -> Dict[str, str]:
    14:     try:
    15:         # on lit la config du moteur si dispo
    16:         from engine.config.loader import load_config
    17:         cfg = load_config()
    18:         r = cfg.get("runtime", {})
    19:         return {
    20:             "DATA_DIR": r.get("data_dir") or "/notebooks/scalp_data/data",
    21:             "REPORTS_DIR": r.get("reports_dir") or "/notebooks/scalp_data/reports",
    22:         }
    23:     except Exception:
    24:         root = os.getenv("DATA_ROOT", "/notebooks/scalp_data")
    25:         return {
    26:             "DATA_DIR": str(Path(root) / "data"),
    27:             "REPORTS_DIR": str(Path(root) / "reports"),
    28:         }
    29: 
    30: PATHS = _load_config_paths()
    31: 
    32: def p_live() -> Path: return Path(PATHS["DATA_DIR"]) / "live"
    33: def p_orders() -> Path: return p_live() / "orders.csv"
    34: def p_signals() -> Path: return p_live() / "logs" / "signals.csv"
    35: def p_watchlist() -> Path: return Path(PATHS["REPORTS_DIR"]) / "watchlist.yml"
    36: def p_strategies() -> Path: return Path(__file__).resolve().parents[1] / "engine" / "config" / "strategies.yml"
    37: def p_summary() -> Path: return Path(PATHS["REPORTS_DIR"]) / "summary.json"
    38: 
    39: # ---------- helpers IO ----------
    40: @st.cache_data(show_spinner=False)
    41: def load_json_file(path: Path) -> Dict:
    42:     if not path.exists(): return {}
    43:     try:
    44:         return json.loads(path.read_text(encoding="utf-8"))
    45:     except Exception:
    46:         return {}
    47: 
    48: @st.cache_data(show_spinner=False)
    49: def load_csv_tail(path: Path, n: int = 1000) -> pd.DataFrame:
    50:     if not path.exists(): return pd.DataFrame()
    51:     try:
    52:         # lecture efficace tail n lignes
    53:         with path.open("rb") as f:
    54:             f.seek(0, os.SEEK_END)
    55:             size = f.tell()
    56:             block = 4096
    57:             data = b""
    58:             while len(data.splitlines()) <= n + 1 and f.tell() > 0:
    59:                 step = min(block, f.tell())
    60:                 f.seek(-step, os.SEEK_CUR)
    61:                 data = f.read(step) + data
    62:                 f.seek(-step, os.SEEK_CUR)
    63:             s = data.decode("utf-8", errors="ignore")
    64:         df = pd.read_csv(pd.compat.StringIO(s))
    65:         return df.tail(n).reset_index(drop=True)
    66:     except Exception:
    67:         try:
    68:             return pd.read_csv(path).tail(n).reset_index(drop=True)
    69:         except Exception:
    70:             return pd.DataFrame()
    71: 
    72: @st.cache_data(show_spinner=False)
    73: def load_signals() -> pd.DataFrame:
    74:     df = load_csv_tail(p_signals(), n=5000)
    75:     if not df.empty:
    76:         # ts en ms → datetime
    77:         df["ts"] = pd.to_datetime(df["ts"], unit="ms")
    78:     return df
    79: 
    80: @st.cache_data(show_spinner=False)
    81: def load_orders() -> pd.DataFrame:
    82:     df = load_csv_tail(p_orders(), n=2000)
    83:     if not df.empty:
    84:         df["ts"] = pd.to_datetime(df["ts"], unit="ms")
    85:     return df
    86: 
    87: # ---------- UI ----------
    88: st.set_page_config(page_title="Scalp Dashboard", layout="wide")
    89: st.title("⚡ Scalp — Dashboard")
    90: 
    91: with st.sidebar:
    92:     st.subheader("Paramètres")
    93:     refresh_sec = st.number_input("Auto-refresh (sec)", min_value=0, max_value=120, value=10, step=1)
    94:     if refresh_sec > 0:
    95:         st.autorefresh = st.experimental_rerun  # alias doux
    96:         st.experimental_set_query_params(_=int(pd.Timestamp.now().timestamp()))
    97:         st.experimental_data_editor  # no-op; évite un warning IDE
    98:         st.experimental_rerun  # pas déclenché ici; déclenché par autorefresh ci-dessous
    99:         st.experimental_memo
   100:         st_autorefresh = st.experimental_rerun
   101:         st.empty()
   102:     page = st.radio("Vue", ["Overview", "Watchlist", "Strategies", "Live: Signals", "Live: Orders"], index=0)
   103: 
   104:     st.caption(f"DATA_DIR: {PATHS['DATA_DIR']}")
   105:     st.caption(f"REPORTS_DIR: {PATHS['REPORTS_DIR']}")
   106: 
   107: # déclencheur auto-refresh léger
   108: if refresh_sec > 0:
   109:     st.experimental_set_query_params(ts=int(pd.Timestamp.now().timestamp()))
   110:     st_autorefresh_id = st.experimental_singleton(lambda: 0)
   111:     st.experimental_rerun
   112: 
   113: # ---------- PAGES ----------
   114: if page == "Overview":
   115:     c1, c2, c3, c4 = st.columns(4)
   116:     wl = load_json_file(p_watchlist())
   117:     strat = load_json_file(p_strategies())
   118:     sig = load_signals()
   119:     ords = load_orders()
   120: 
   121:     c1.metric("Watchlist", len(wl.get("top", [])))
   122:     c2.metric("Strategies", len((strat.get("strategies") or {})))
   123:     c3.metric("Signals (tail)", len(sig))
   124:     c4.metric("Orders (tail)", len(ords))
   125: 
   126:     st.markdown("### Fichiers")
   127:     status = [
   128:         ("watchlist.yml", p_watchlist(), p_watchlist().exists()),
   129:         ("strategies.yml", p_strategies(), p_strategies().exists()),
   130:         ("signals.csv", p_signals(), p_signals().exists()),
   131:         ("orders.csv", p_orders(), p_orders().exists()),
   132:         ("summary.json", p_summary(), p_summary().exists()),
   133:     ]
   134:     st.table(pd.DataFrame([{"file": n, "path": str(p), "exists": ok} for n, p, ok in status]))
   135: 
   136:     st.markdown("### Derniers signaux (aperçu)")
   137:     st.dataframe(sig.tail(30), use_container_width=True)
   138: 
   139: elif page == "Watchlist":
   140:     doc = load_json_file(p_watchlist())
   141:     top = pd.DataFrame(doc.get("top", []))
   142:     if top.empty:
   143:         st.warning(f"Watchlist vide ou introuvable: {p_watchlist()}")
   144:     else:
   145:         top = top.sort_values("score", ascending=False).reset_index(drop=True)
   146:         st.subheader("Top (score volume+volatilité)")
   147:         st.dataframe(top, use_container_width=True)
   148:         c1, c2 = st.columns(2)
   149:         with c1:
   150:             if {"symbol", "vol_usd_24h"}.issubset(top.columns):
   151:                 st.bar_chart(top.set_index("symbol")["vol_usd_24h"])
   152:         with c2:
   153:             if {"symbol", "atr_pct_24h"}.issubset(top.columns):
   154:                 st.bar_chart((top.set_index("symbol")["atr_pct_24h"] * 100).rename("ATR %"))
   155: 
   156: elif page == "Strategies":
   157:     doc = load_json_file(p_strategies())
   158:     strat = pd.DataFrame([
   159:         {"pair_tf": k, **v} for k, v in (doc.get("strategies") or {}).items()
   160:     ])
   161:     if strat.empty:
   162:         st.info("Aucune stratégie promue. Lance les jobs backtest + promote.")
   163:     else:
   164:         st.subheader("Stratégies promues (par pair:TF)")
   165:         st.dataframe(strat.sort_values("pair_tf"), use_container_width=True)
   166: 
   167: elif page == "Live: Signals":
   168:     df = load_signals()
   169:     if df.empty:
   170:         st.warning(f"Aucun signal (fichier introuvable ou vide): {p_signals()}")
   171:     else:
   172:         syms = sorted(df["symbol"].unique().tolist())
   173:         sym = st.selectbox("Symbole", syms, index=0)
   174:         tf = st.selectbox("Timeframe", sorted(df["tf"].unique().tolist()), index=0)
   175:         d = df[(df["symbol"] == sym) & (df["tf"] == tf)].copy()
   176:         d = d.sort_values("ts")
   177:         st.line_chart(d.set_index("ts")["price"], height=300)
   178:         st.dataframe(d.tail(200), use_container_width=True)
   179: 
   180: elif page == "Live: Orders":
   181:     df = load_orders()
   182:     if df.empty:
   183:         st.info(f"Aucun ordre encore. (paper mode ?) Fichier: {p_orders()}")
   184:     else:
   185:         st.subheader("Journal des ordres")
   186:         st.dataframe(df.tail(200), use_container_width=True)
   187:         # stats rapides
   188:         buys = (df["action"] == "BUY").sum()
   189:         sells = (df["action"] == "SELL").sum()
   190:         st.caption(f"BUY: {buys} • SELL: {sells}")
   191: 
   192: # pied de page
   193: st.write("---")
   194: st.caption("Scalp Dashboard • Streamlit • auto-refresh paramétrable • fichiers hors repo")

--------------------------------------------------------------------------------
FILE: data/BTCUSDT-1m.csv  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: ts,open,high,low,close,volume
     2: 1625097600000,34000,34100,33950,34050,123.4
     3: 1625097660000,34050,34200,34000,34150,150.7
     4: 1625097720000,34150,34300,34100,34250,180.3
     5: 1625097780000,34250,34400,34200,34350,200.1
     6: 1625097840000,34350,34500,34300,34450,220.8

--------------------------------------------------------------------------------
FILE: data/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Indicator computation helpers."""
     2: 
     3: from .indicators import compute_all
     4: 
     5: __all__ = ["compute_all"]

--------------------------------------------------------------------------------
FILE: dump.txt  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: Dump created: 2025-08-24 03:12:35
     2: Repository tree:
     3: Scalp/
     4:     CHANGELOG.md
     5:     Makefile
     6:     PROMPT.md
     7:     README.md
     8:     STRATEGY.md
     9:     bot.py
    10:     cli.py
    11:     init.py
    12:     pytest.ini
    13:     requirements-dev.txt
    14:     requirements.txt
    15:     sitecustomize.py
    16:     tg_diag.py
    17:     scalper/
    18:         VERSION
    19:         __init__.py
    20:         bitget_client.py
    21:         client.py
    22:         logging_utils.py
    23:         metrics.py
    24:         pairs.py
    25:         selfcheck.py
    26:         strategy.py
    27:         trade_utils.py
    28:         version.py
    29:         ws.py
    30:         positions/
    31:             __init__.py
    32:             state.py
    33:         risk/
    34:             __init__.py
    35:             manager.py
    36:         hooks/
    37:             prewarm_cache.py
    38:         exchange/
    39:             __init__.py
    40:             bitget_ccxt.py
    41:             fees.py
    42:         selection/
    43:             __init__.py
    44:             momentum.py
    45:             scanner.py
    46:         config/
    47:             __init__.py
    48:             loader.py
    49:         backtest/
    50:             __init__.py
    51:             cache.py
    52:             cli.py
    53:             engine.py
    54:             grid_search.py
    55:             loader_csv.py
    56:             market_data.py
    57:             metrics.py
    58:             optimize.py
    59:             run_multi.py
    60:             runner.py
    61:             walkforward.py
    62:         services/
    63:             __init__.py
    64:             data_cache.py
    65:             order_service.py
    66:             utils.py
    67:         signals/
    68:             __init__.py
    69:             current.py
    70:             factory.py
    71:             generator.py
    72:         adapters/
    73:             __init__.py
    74:             bitget.py
    75:             bitget_fetch.py
    76:             market_data.py
    77:         live/
    78:             __init__.py
    79:             backtest_telegram.py
    80:             commands.py
    81:             journal.py
    82:             logs.py
    83:             notify.py
    84:             ohlcv_service.py
    85:             orchestrator.py
    86:             orders.py
    87:             position_fsm.py
    88:             setup_wizard.py
    89:             state_store.py
    90:             telegram_async.py
    91:             watchlist.py
    92:             loops/
    93:                 trade.py
    94:     TRASH_20250823-124533/
    95:         bitget_futures_pairs.py
    96:         dashboard.py
    97:         dump_repo.py
    98:         quick_order.py
    99:         rr.py
   100:         run_backtest.py
   101:         short_one_way.py
   102:         notebooks/
   103:             spot/
   104:                 bitget_bot.py
   105:         scalper/
   106:             bot_config.py
   107:             legacy_config.py
   108:             notifier.py
   109:             telegram_bot.py
   110:         result/
   111:     data/
   112:         BTCUSDT-1m.csv
   113:         __init__.py
   114:         indicators.py
   115:     tests/
   116:         conftest.py
   117:         test_analyse_risque.py
   118:         test_backtest.py
   119:         test_backtest_multi.py
   120:         test_backtest_position.py
   121:         test_bitget_futures_pairs.py
   122:         test_bot_place_order_caps.py
   123:         test_bot_update.py
   124:         test_break_even_stop.py
   125:         test_calc_pnl_pct.py
   126:         test_check_config.py
   127:         test_cli.py
   128:         test_client.py
   129:         test_compute_position_size.py
   130:         test_compute_position_size_cap.py
   131:         test_dynamic_allocation.py
   132:         test_effective_leverage.py
   133:         test_env_loading.py
   134:         test_grid_search.py
   135:         test_heat_score.py
   136:         test_indicators.py
   137:         test_min_qty_rules.py
   138:         test_notifier.py
   139:         test_notional_and_pnl_units.py
   140:         test_pair_selection.py
   141:         test_pairs.py
   142:         test_risk_manager.py
   143:         test_risk_utils.py
   144:         test_signal_risk.py
   145:         test_slippage.py
   146:         test_strategy_v2.py
   147:         test_telegram_bot.py
   148:         test_utils.py
   149:         test_version.py
   150:         test_walk_forward.py
   151:         test_ws.py
   152: 
   153: ## CHANGELOG.md (last modified: 2025-08-23 20:57:14)
   154:      1: # Changelog
   155:      2: 
   156:      3: ## Unreleased
   157:      4: 
   158:      5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
   159:      6:   signal levels.
   160:      7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
   161:      8:   user risk level.
   162:      9: - Notional and margin caps with available balance check to avoid Bitget error
   163:     10:   `40762`.
   164:     11: - Risk notifications with green/yellow/red indicators for terminal and
   165:     12:   Telegram.
   166: 
   167: 
   168: ## Makefile (last modified: 2025-08-23 20:57:14)
   169:      1: .PHONY: test
   170:      2: 
   171:      3: test:
   172:      4: 	pytest
   173: 
   174: 
   175: ## PROMPT.md (last modified: 2025-08-23 20:57:14)
   176:      1: # Prompt de re-création du bot Scalp (version spot)
   177:      2: 
   178:      3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
   179:      4: 
   180:      5: ## Structure principale
   181:      6: 
   182:      7: ### bot.py
   183:      8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
   184:      9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
   185:     10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
   186:     11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
   187:     12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
   188:     13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
   189:     14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
   190:     15: 
   191:     16: ### cli.py
   192:     17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
   193:     18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
   194:     19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
   195:     20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
   196:     21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
   197:     22: 
   198:     23: ### init.py
   199:     24: - `install_packages(*args)` : installe des paquets via `pip`.
   200:     25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
   201:     26: 
   202:     27: ## Modules `scalp`
   203:     28: 
   204:     29: ### bot_config.py
   205:     30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
   206:     31: 
   207:     32: ### metrics.py
   208:     33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
   209:     34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
   210:     35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
   211:     36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
   212:     37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
   213:     38: 
   214:     39: ### strategy.py
   215:     40: - `ema(series, window)` : moyenne mobile exponentielle.
   216:     41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
   217:     42: - `obv(closes, volumes)` : série On Balance Volume.
   218:     43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
   219:     44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
   220:     45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
   221:     46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
   222:     47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
   223:     48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
   224:     49: 
   225:     50: ### trade_utils.py
   226:     51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
   227:     52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
   228:     53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
   229:     54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
   230:     55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
   231:     56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
   232:     57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
   233:     58: 
   234:     59: ### risk
   235:     60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
   236:     61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
   237:     62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
   238:     63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
   239:     64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
   240:     65: 
   241:     66: ### notifier.py
   242:     67: - `_pair_name(symbol)` : formatte le nom d’une paire.
   243:     68: - `_format_text(event, payload=None)` : construit un message lisible.
   244:     69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
   245:     70: 
   246:     71: ### logging_utils.py
   247:     72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
   248:     73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
   249:     74: 
   250:     75: ### bitget_client.py
   251:     76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
   252:     77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
   253:     78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
   254:     79:   - `get_account()`, `get_open_orders(symbol=None)`.
   255:     80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
   256:     81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
   257:     82: 
   258:     83: ### pairs.py
   259:     84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
   260:     85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
   261:     86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
   262:     87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
   263:     88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
   264:     89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
   265:     90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
   266:     91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
   267:     92: 
   268:     93: ### telegram_bot.py
   269:     94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
   270:     95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
   271:     96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
   272:     97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
   273:     98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
   274:     99: 
   275:    100: ## Utilisation
   276:    101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   277:    102: 2. Exécuter `init.py` pour installer les dépendances.
   278:    103: 3. Lancer `bot.py` pour démarrer le trading.
   279:    104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   280:    105: 
   281:    106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   282:    107: 
   283: 
   284: 
   285: ## README.md (last modified: 2025-08-23 20:57:14)
   286:      1: # Scalp
   287:      2: 
   288:      3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
   289:      4: 
   290:      5: ## Installation
   291:      6: 
   292:      7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
   293:      8: 
   294:      9: ```bash
   295:     10: pip install -r requirements.txt
   296:     11: ```
   297:     12: 
   298:     13: Pour développer ou exécuter les tests :
   299:     14: 
   300:     15: ```bash
   301:     16: pip install -r requirements-dev.txt
   302:     17: pytest  # ou make test
   303:     18: ```
   304:     19: 
   305:     20: ## Configuration
   306:     21: 
   307:     22: Le bot lit sa configuration via des variables d'environnement :
   308:     23: 
   309:     24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
   310:     25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
   311:     26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
   312:     27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
   313:     28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
   314:     29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
   315:     30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
   316:     31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
   317:     32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
   318:     33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
   319:     34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
   320:     35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
   321:     36: 
   322:     37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
   323:     38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
   324:     39: 
   325:     40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
   326:     41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
   327:     42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
   328:     43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
   329:     44: bot.
   330:     45: 
   331:     46: 
   332:     47: Exemple :
   333:     48: 
   334:     49: ```bash
   335:     50: export BITGET_ACCESS_KEY="votre_cle"
   336:     51: export BITGET_SECRET_KEY="votre_secret"
   337:     52: export PAPER_TRADE=true
   338:     53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
   339:     54: export TELEGRAM_CHAT_ID="123456789"
   340:     55: python bot.py
   341:     56: ```
   342:     57: 
   343:     58: ## Lancement
   344:     59: 
   345:     60: Après configuration, lancez simplement :
   346:     61: 
   347:     62: ```bash
   348:     63: python bot.py
   349:     64: ```
   350:     65: 
   351:     66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
   352:     67: 
   353:     68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
   354:     69: 
   355:     70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
   356:     71: 
   357:     72: 
   358:     73: ## Stratégie
   359:     74: 
   360:     75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
   361:     76: rapidement les pertes.
   362:     77: 
   363:     78: Principes généraux :
   364:     79: 
   365:     80: - sélection de paires liquides au fort momentum ;
   366:     81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
   367:     82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
   368:     83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
   369:     84:   calculée selon le risque ;
   370:     85: - limites quotidiennes pour protéger le capital.
   371:     86: 
   372:     87: Les règles détaillées et l’algorithme complet sont décrits dans
   373:     88: `STRATEGY.md`.
   374:     89: 
   375:     90: ## Version
   376:     91: 
   377:     92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
   378:     93: le code via la variable `scalp.__version__` :
   379:     94: 
   380:     95: ```python
   381:     96: from scalp import __version__
   382:     97: print(__version__)
   383:     98: ```
   384:     99: 
   385:    100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   386:    101: 
   387:    102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   388:    103: `scalp.version.bump_version_from_message` permet également de déterminer
   389:    104: automatiquement l'incrément à appliquer à partir d'un message de commit
   390:    105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   391:    106: 
   392:    107: Exemple d'incrément basé sur un message :
   393:    108: 
   394:    109: ```python
   395:    110: from scalp.version import bump_version_from_message
   396:    111: bump_version_from_message("feat: add new strategy")
   397:    112: ```
   398:    113: 
   399:    114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   400:    115: message de commit `git` et met à jour le fichier `VERSION` en
   401:    116: conséquence.
   402:    117: 
   403:    118: La même opération peut être déclenchée depuis la ligne de commande via
   404:    119: `cli.py` :
   405:    120: 
   406:    121: ```bash
   407:    122: python cli.py bump-version
   408:    123: ```
   409:    124: 
   410:    125: 
   411:    126: ## Changelog
   412:    127: 
   413:    128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   414:    129: 
   415:    130: ## Avertissement
   416:    131: 
   417:    132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.
   418: 
   419: 
   420: ## STRATEGY.md (last modified: 2025-08-23 20:57:14)
   421:      1: # Stratégie de trading
   422:      2: 
   423:      3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
   424:      4: 
   425:      5: ## Principes généraux
   426:      6: 
   427:      7: - ne traiter que des actifs liquides à fort momentum ;
   428:      8: - suivre la tendance dominante et éviter les marchés plats ;
   429:      9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
   430:     10: - dimensionner chaque position selon un pourcentage fixe du capital ;
   431:     11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
   432:     12: 
   433:     13: ## Sélection des paires
   434:     14: 
   435:     15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
   436:     16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
   437:     17:    - croisement entre EMA20 et EMA50 ;
   438:     18:    - ATR élevé pour privilégier les actifs volatils.
   439:     19: 
   440:     20: ## Génération du signal
   441:     21: 
   442:     22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
   443:     23: 
   444:     24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
   445:     25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
   446:     26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
   447:     27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
   448:     28: - cassure du dernier **swing high/low** ;
   449:     29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
   450:     30: 
   451:     31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
   452:     32: 
   453:     33: ## Gestion du risque
   454:     34: 
   455:     35: La classe `RiskManager` applique plusieurs garde‑fous :
   456:     36: 
   457:     37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
   458:     38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
   459:     39: - pause forcée en cas de pertes consécutives prolongées ;
   460:     40: - contrôle du nombre maximal de positions ouvertes.
   461:     41: 
   462:     42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.
   463: 
   464: 
   465: ## TRASH_20250823-124533/bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
   466:      1: #!/usr/bin/env python3
   467:      2: """Fetch the list of Bitget futures contracts.
   468:      3: 
   469:      4: This helper script queries the public Bitget REST API to retrieve futures
   470:      5: trading pairs for the specified product types and saves them to CSV and JSON
   471:      6: files. It mirrors the standalone example provided by the user but integrates
   472:      7: with the repository's configuration system.
   473:      8: 
   474:      9: Usage examples::
   475:     10: 
   476:     11:     python bitget_futures_pairs.py
   477:     12:     python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
   478:     13:     python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
   479:     14: """
   480:     15: from __future__ import annotations
   481:     16: 
   482:     17: import argparse
   483:     18: import csv
   484:     19: import json
   485:     20: import sys
   486:     21: import time
   487:     22: from typing import Any, Dict, List
   488:     23: 
   489:     24: from scalper.bot_config import CONFIG
   490:     25: 
   491:     26: try:  # pragma: no cover - import guard
   492:     27:     import requests
   493:     28: except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
   494:     29:     sys.stderr.write(
   495:     30:         "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
   496:     31:     )
   497:     32:     raise
   498:     33: 
   499:     34: BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
   500:     35: CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
   501:     36: DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]
   502:     37: 
   503:     38: 
   504:     39: def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
   505:     40:     """Return contract metadata for ``product_type``."""
   506:     41:     url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
   507:     42:     params = {"productType": product_type}
   508:     43:     resp = requests.get(url, params=params, timeout=timeout)
   509:     44:     try:
   510:     45:         data = resp.json()
   511:     46:     except json.JSONDecodeError as exc:  # pragma: no cover - network failure
   512:     47:         raise RuntimeError(
   513:     48:             f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
   514:     49:         ) from exc
   515:     50:     if resp.status_code != 200 or data.get("code") != "00000":
   516:     51:         raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
   517:     52:     return data.get("data", [])
   518:     53: 
   519:     54: 
   520:     55: def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
   521:     56:     """Select and rename key fields for CSV/JSON output."""
   522:     57:     rows: List[Dict[str, Any]] = []
   523:     58:     for c in contracts:
   524:     59:         row = {
   525:     60:             "productType": product_type,
   526:     61:             "symbol": c.get("symbol"),
   527:     62:             "baseCoin": c.get("baseCoin"),
   528:     63:             "quoteCoin": c.get("quoteCoin"),
   529:     64:             "symbolType": c.get("symbolType"),
   530:     65:             "symbolStatus": c.get("symbolStatus"),
   531:     66:             "maxLever": c.get("maxLever"),
   532:     67:             "minLever": c.get("minLever"),
   533:     68:             "minTradeNum": c.get("minTradeNum"),
   534:     69:             "sizeMultiplier": c.get("sizeMultiplier"),
   535:     70:             "pricePlace": c.get("pricePlace"),
   536:     71:             "volumePlace": c.get("volumePlace"),
   537:     72:             "launchTime": c.get("launchTime"),
   538:     73:             "deliveryTime": c.get("deliveryTime"),
   539:     74:         }
   540:     75:         rows.append(row)
   541:     76:     return rows
   542:     77: 
   543:     78: 
   544:     79: def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
   545:     80:     """Write ``rows`` to ``path`` in CSV format."""
   546:     81:     headers = [
   547:     82:         "productType",
   548:     83:         "symbol",
   549:     84:         "baseCoin",
   550:     85:         "quoteCoin",
   551:     86:         "symbolType",
   552:     87:         "symbolStatus",
   553:     88:         "maxLever",
   554:     89:         "minLever",
   555:     90:         "minTradeNum",
   556:     91:         "sizeMultiplier",
   557:     92:         "pricePlace",
   558:     93:         "volumePlace",
   559:     94:         "launchTime",
   560:     95:         "deliveryTime",
   561:     96:     ]
   562:     97:     with open(path, "w", newline="", encoding="utf-8") as fh:
   563:     98:         writer = csv.DictWriter(fh, fieldnames=headers)
   564:     99:         writer.writeheader()
   565:    100:         if rows:
   566:    101:             writer.writerows(rows)
   567:    102: 
   568:    103: 
   569:    104: def main(argv: List[str] | None = None) -> int:
   570:    105:     parser = argparse.ArgumentParser(
   571:    106:         description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
   572:    107:     )
   573:    108:     parser.add_argument(
   574:    109:         "--types",
   575:    110:         nargs="+",
   576:    111:         default=DEFAULT_PRODUCT_TYPES,
   577:    112:         help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
   578:    113:     )
   579:    114:     parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
   580:    115:     parser.add_argument(
   581:    116:         "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
   582:    117:     )
   583:    118:     parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
   584:    119:     args = parser.parse_args(argv)
   585:    120: 
   586:    121:     all_rows: List[Dict[str, Any]] = []
   587:    122:     merged_json: Dict[str, List[Dict[str, Any]]] = {}
   588:    123: 
   589:    124:     for i, pt in enumerate(args.types):
   590:    125:         try:
   591:    126:             contracts = fetch_contracts(pt)
   592:    127:         except Exception as exc:  # pragma: no cover - network/runtime error
   593:    128:             sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
   594:    129:             continue
   595:    130:         rows = normalize_rows(pt, contracts)
   596:    131:         all_rows.extend(rows)
   597:    132:         merged_json[pt] = contracts
   598:    133:         if i < len(args.types) - 1 and args.sleep > 0:
   599:    134:             time.sleep(args.sleep)
   600:    135: 
   601:    136:     all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))
   602:    137: 
   603:    138:     write_csv(all_rows, args.out)
   604:    139:     with open(args.json_out, "w", encoding="utf-8") as fh:
   605:    140:         json.dump(merged_json, fh, ensure_ascii=False, indent=2)
   606:    141: 
   607:    142:     counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
   608:    143:     total = sum(counts.values())
   609:    144:     print(
   610:    145:         f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
   611:    146:     )
   612:    147:     for pt, n in counts.items():
   613:    148:         print(f"  - {pt}: {n} pairs")
   614:    149:     return 0
   615:    150: 
   616:    151: 
   617:    152: if __name__ == "__main__":  # pragma: no cover - CLI execution
   618:    153:     raise SystemExit(main())
   619: 
   620: 
   621: ## TRASH_20250823-124533/dashboard.py (last modified: 2025-08-23 20:57:14)
   622:      1: # dashboard.py
   623:      2: from __future__ import annotations
   624:      3: 
   625:      4: import os
   626:      5: import time
   627:      6: from pathlib import Path
   628:      7: from typing import Dict, Tuple
   629:      8: 
   630:      9: import pandas as pd
   631:     10: import streamlit as st
   632:     11: 
   633:     12: # ------------------------------------------------------------
   634:     13: # Réglages
   635:     14: # ------------------------------------------------------------
   636:     15: LOG_DIR = Path("scalp/live/logs")  # emplacement des CSV créés par l'orchestrateur
   637:     16: REFRESH_SECS = 5                   # auto-refresh UI
   638:     17: MAX_ROWS_SHOW = 2000               # clamp mémoire
   639:     18: 
   640:     19: 
   641:     20: # ------------------------------------------------------------
   642:     21: # Utilitaires lecture robuste CSV
   643:     22: # ------------------------------------------------------------
   644:     23: def _safe_read_csv(path: Path) -> pd.DataFrame:
   645:     24:     if not path.exists():
   646:     25:         return pd.DataFrame()
   647:     26:     try:
   648:     27:         df = pd.read_csv(path)
   649:     28:         # clamp pour éviter d’exploser en RAM si les logs deviennent énormes
   650:     29:         if len(df) > MAX_ROWS_SHOW:
   651:     30:             df = df.tail(MAX_ROWS_SHOW).reset_index(drop=True)
   652:     31:         return df
   653:     32:     except Exception:
   654:     33:         # fichier en cours d’écriture → on réessaiera au prochain tick
   655:     34:         return pd.DataFrame()
   656:     35: 
   657:     36: 
   658:     37: def load_logs() -> Dict[str, pd.DataFrame]:
   659:     38:     return {
   660:     39:         "signals": _safe_read_csv(LOG_DIR / "signals.csv"),
   661:     40:         "orders": _safe_read_csv(LOG_DIR / "orders.csv"),
   662:     41:         "fills": _safe_read_csv(LOG_DIR / "fills.csv"),
   663:     42:         "positions": _safe_read_csv(LOG_DIR / "positions.csv"),
   664:     43:     }
   665:     44: 
   666:     45: 
   667:     46: def _format_ts_ms_to_str(df: pd.DataFrame, col: str = "ts") -> pd.DataFrame:
   668:     47:     if col in df.columns:
   669:     48:         try:
   670:     49:             df[col] = pd.to_datetime(df[col], unit="ms")
   671:     50:         except Exception:
   672:     51:             try:
   673:     52:                 df[col] = pd.to_datetime(df[col])
   674:     53:             except Exception:
   675:     54:                 pass
   676:     55:     return df
   677:     56: 
   678:     57: 
   679:     58: # ------------------------------------------------------------
   680:     59: # Métriques & agrégats simples
   681:     60: # ------------------------------------------------------------
   682:     61: def compute_activity_metrics(df_orders: pd.DataFrame, df_fills: pd.DataFrame) -> Tuple[float, float, int]:
   683:     62:     """
   684:     63:     Retourne: (volume notionnel approx, fees cumulés, nb fills)
   685:     64:     - notionnel approx = somme(|price * qty|) sur les fills (indépendant du sens)
   686:     65:     - fees = somme(fee) si dispo
   687:     66:     """
   688:     67:     notional = 0.0
   689:     68:     fees = 0.0
   690:     69:     n_fills = 0
   691:     70: 
   692:     71:     if not df_fills.empty:
   693:     72:         # normalisation colonnes
   694:     73:         price_col = next((c for c in ["price", "fillPrice", "fill_px"] if c in df_fills.columns), None)
   695:     74:         qty_col = next((c for c in ["qty", "size", "fillQty", "fill_sz"] if c in df_fills.columns), None)
   696:     75:         fee_col = next((c for c in ["fee", "fillFee"] if c in df_fills.columns), None)
   697:     76: 
   698:     77:         if price_col and qty_col:
   699:     78:             notional = float((df_fills[price_col].abs() * df_fills[qty_col].abs()).sum())
   700:     79:             n_fills = int(len(df_fills))
   701:     80:         if fee_col:
   702:     81:             fees = float(df_fills[fee_col].fillna(0).sum())
   703:     82: 
   704:     83:     return notional, fees, n_fills
   705:     84: 
   706:     85: 
   707:     86: def last_positions_snapshot(df_positions: pd.DataFrame) -> pd.DataFrame:
   708:     87:     """Dernier état par symbole (state/qty/entry)."""
   709:     88:     if df_positions.empty:
   710:     89:         return df_positions
   711:     90:     df = df_positions.copy()
   712:     91:     df = _format_ts_ms_to_str(df, "ts")
   713:     92:     # on prend le dernier enregistrement par symbol
   714:     93:     last = df.sort_values("ts").groupby("symbol", as_index=False).tail(1)
   715:     94:     return last.sort_values("symbol").reset_index(drop=True)
   716:     95: 
   717:     96: 
   718:     97: def recent_signals(df_signals: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   719:     98:     if df_signals.empty:
   720:     99:         return df_signals
   721:    100:     df = df_signals.copy()
   722:    101:     df = _format_ts_ms_to_str(df, "ts")
   723:    102:     df = df.sort_values("ts", ascending=False).head(limit)
   724:    103:     return df.reset_index(drop=True)
   725:    104: 
   726:    105: 
   727:    106: def recent_orders(df_orders: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   728:    107:     if df_orders.empty:
   729:    108:         return df_orders
   730:    109:     df = df_orders.copy()
   731:    110:     df = _format_ts_ms_to_str(df, "ts")
   732:    111:     df = df.sort_values("ts", ascending=False).head(limit)
   733:    112:     # petites colonnes utiles en premier
   734:    113:     cols = [c for c in ["ts", "symbol", "side", "status", "price", "sl", "tp", "risk_pct", "order_id"] if c in df.columns]
   735:    114:     other = [c for c in df.columns if c not in cols]
   736:    115:     return df[cols + other]
   737:    116: 
   738:    117: 
   739:    118: def recent_fills(df_fills: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
   740:    119:     if df_fills.empty:
   741:    120:         return df_fills
   742:    121:     df = df_fills.copy()
   743:    122:     df = _format_ts_ms_to_str(df, "ts")
   744:    123:     df = df.sort_values("ts", ascending=False).head(limit)
   745:    124:     cols = [c for c in ["ts", "symbol", "order_id", "trade_id", "price", "qty", "fee"] if c in df.columns]
   746:    125:     other = [c for c in df.columns if c not in cols]
   747:    126:     return df[cols + other]
   748:    127: 
   749:    128: 
   750:    129: # ------------------------------------------------------------
   751:    130: # UI
   752:    131: # ------------------------------------------------------------
   753:    132: st.set_page_config(page_title="ScalpBot Dashboard", layout="wide")
   754:    133: st.title("📊 ScalpBot — Dashboard Live")
   755:    134: 
   756:    135: # auto-refresh
   757:    136: st.caption("Auto-refresh toutes les {}s".format(REFRESH_SECS))
   758:    137: st_autorefresh = st.experimental_rerun if False else None  # placeholder to keep code readable
   759:    138: # Streamlit v1.32+ propose st.autorefresh :
   760:    139: try:
   761:    140:     st_autorefresh = st.experimental_rerun  # fallback compat
   762:    141:     from streamlit.runtime.scriptrunner import add_script_run_ctx  # noqa: F401
   763:    142:     st_autorefresh = None
   764:    143: except Exception:
   765:    144:     pass
   766:    145: 
   767:    146: try:
   768:    147:     st_autorefresh = st.autorefresh(interval=REFRESH_SECS * 1000, key="autorf")
   769:    148: except Exception:
   770:    149:     pass
   771:    150: 
   772:    151: # Choix du dossier de logs (utile si on lance le dashboard depuis un autre cwd)
   773:    152: default_dir = str(LOG_DIR.resolve())
   774:    153: custom_dir = st.sidebar.text_input("Dossier de logs", value=default_dir)
   775:    154: LOG_DIR = Path(custom_dir) if custom_dir else LOG_DIR
   776:    155: 
   777:    156: if not LOG_DIR.exists():
   778:    157:     st.error(f"Dossier introuvable : {LOG_DIR}")
   779:    158:     st.stop()
   780:    159: 
   781:    160: data = load_logs()
   782:    161: df_sig, df_ord, df_fill, df_pos = data["signals"], data["orders"], data["fills"], data["positions"]
   783:    162: 
   784:    163: # KPIs rapides
   785:    164: notional, fees, n_fills = compute_activity_metrics(df_ord, df_fill)
   786:    165: col_a, col_b, col_c, col_d = st.columns(4)
   787:    166: col_a.metric("Paires actives (Top 10)", "10")
   788:    167: col_b.metric("Fills (total)", f"{n_fills}")
   789:    168: col_c.metric("Notionnel cumulé (approx)", f"{notional:,.0f} USDT")
   790:    169: col_d.metric("Frais cumulés", f"{fees:,.2f} USDT")
   791:    170: 
   792:    171: st.divider()
   793:    172: 
   794:    173: # 1) Positions snapshot
   795:    174: st.subheader("📌 Positions (snapshot courant par symbole)")
   796:    175: pos_snapshot = last_positions_snapshot(df_pos)
   797:    176: if pos_snapshot.empty:
   798:    177:     st.info("Aucune position pour l’instant.")
   799:    178: else:
   800:    179:     # Met un peu d'ordre dans les colonnes
   801:    180:     order_cols = [c for c in ["symbol", "state", "qty", "entry", "ts"] if c in pos_snapshot.columns]
   802:    181:     pos_snapshot = pos_snapshot[order_cols + [c for c in pos_snapshot.columns if c not in order_cols]]
   803:    182:     st.dataframe(pos_snapshot, use_container_width=True, height=260)
   804:    183: 
   805:    184: # 2) Derniers signaux
   806:    185: st.subheader("📣 Derniers signaux")
   807:    186: sig_tbl = recent_signals(df_sig, limit=40)
   808:    187: if sig_tbl.empty:
   809:    188:     st.info("Pas encore de signaux.")
   810:    189: else:
   811:    190:     # comptage LONG/SHORT
   812:    191:     try:
   813:    192:         by_side = sig_tbl.assign(side_norm=sig_tbl["side"].astype(str).str.upper()).groupby("side_norm").size()
   814:    193:         st.bar_chart(by_side)
   815:    194:     except Exception:
   816:    195:         pass
   817:    196:     st.dataframe(sig_tbl, use_container_width=True, height=300)
   818:    197: 
   819:    198: # 3) Ordres récents
   820:    199: st.subheader("🧾 Ordres récents")
   821:    200: ord_tbl = recent_orders(df_ord, limit=40)
   822:    201: if ord_tbl.empty:
   823:    202:     st.info("Pas encore d’ordres.")
   824:    203: else:
   825:    204:     st.dataframe(ord_tbl, use_container_width=True, height=280)
   826:    205: 
   827:    206: # 4) Fills récents
   828:    207: st.subheader("✅ Fills récents")
   829:    208: fills_tbl = recent_fills(df_fill, limit=80)
   830:    209: if fills_tbl.empty:
   831:    210:     st.info("Pas encore d’exécutions (fills).")
   832:    211: else:
   833:    212:     st.dataframe(fills_tbl, use_container_width=True, height=320)
   834:    213: 
   835:    214: st.caption(f"Logs: {LOG_DIR}")
   836: 
   837: ## TRASH_20250823-124533/dump_repo.py (last modified: 2025-08-23 20:57:14)
   838:      1: import os
   839:      2: from datetime import datetime
   840:      3: from pathlib import Path
   841:      4: 
   842:      5: IGNORE_EXTENSIONS = {'.log', '.pyc'}
   843:      6: IGNORE_DIRS = {'__pycache__'}
   844:      7: 
   845:      8: 
   846:      9: def _is_ignored(path: Path) -> bool:
   847:     10:     """Return True if the path should be ignored."""
   848:     11:     if any(part.startswith('.') for part in path.parts):
   849:     12:         return True
   850:     13:     if path.suffix in IGNORE_EXTENSIONS:
   851:     14:         return True
   852:     15:     if any(part in IGNORE_DIRS for part in path.parts):
   853:     16:         return True
   854:     17:     return False
   855:     18: 
   856:     19: 
   857:     20: def _build_tree(root: Path, ignore_path: Path) -> str:
   858:     21:     lines = []
   859:     22:     for dirpath, dirnames, filenames in os.walk(root):
   860:     23:         dirpath = Path(dirpath)
   861:     24:         dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
   862:     25:         depth = len(dirpath.relative_to(root).parts)
   863:     26:         indent = '    ' * depth
   864:     27:         lines.append(f"{indent}{dirpath.name}/")
   865:     28:         for fname in sorted(filenames):
   866:     29:             fpath = dirpath / fname
   867:     30:             if fpath == ignore_path or _is_ignored(fpath):
   868:     31:                 continue
   869:     32:             lines.append(f"{indent}    {fname}")
   870:     33:     return '\n'.join(lines)
   871:     34: 
   872:     35: 
   873:     36: def _iter_files(root: Path):
   874:     37:     for path in sorted(root.rglob('*')):
   875:     38:         if path.is_file() and not _is_ignored(path):
   876:     39:             yield path
   877:     40: 
   878:     41: 
   879:     42: def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
   880:     43:     """Create a text dump of the repository tree and file contents."""
   881:     44:     root_path = Path(root).resolve()
   882:     45:     output_path = root_path / output_path
   883:     46:     now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
   884:     47:     with output_path.open('w', encoding='utf-8') as dump:
   885:     48:         dump.write(f"Dump created: {now}\n")
   886:     49:         dump.write('Repository tree:\n')
   887:     50:         dump.write(_build_tree(root_path, output_path))
   888:     51:         dump.write('\n\n')
   889:     52:         for file_path in _iter_files(root_path):
   890:     53:             rel_path = file_path.relative_to(root_path)
   891:     54:             if file_path == output_path:
   892:     55:                 continue
   893:     56:             mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
   894:     57:             dump.write(f"## {rel_path} (last modified: {mod_time})\n")
   895:     58:             try:
   896:     59:                 with file_path.open('r', encoding='utf-8') as f:
   897:     60:                     for i, line in enumerate(f, 1):
   898:     61:                         dump.write(f"{i:6}: {line}")
   899:     62:             except Exception:
   900:     63:                 dump.write('[unreadable file]\n')
   901:     64:             dump.write('\n\n')
   902:     65: 
   903:     66: 
   904:     67: if __name__ == '__main__':
   905:     68:     create_dump_file()
   906: 
   907: 
   908: ## TRASH_20250823-124533/notebooks/spot/bitget_bot.py (last modified: 2025-08-23 20:57:14)
   909:      1: import os
   910:      2: import time
   911:      3: import hmac
   912:      4: import hashlib
   913:      5: import base64
   914:      6: import logging
   915:      7: from argparse import ArgumentParser
   916:      8: from pathlib import Path
   917:      9: from typing import Any, Dict, List
   918:     10: from urllib.parse import urlencode
   919:     11: 
   920:     12: import requests
   921:     13: from dotenv import load_dotenv
   922:     14: 
   923:     15: BASE_URL = "https://api.bitget.com"
   924:     16: RECV_WINDOW = 5000
   925:     17: 
   926:     18: 
   927:     19: def load_keys() -> Dict[str, str]:
   928:     20:     parent = Path(__file__).resolve().parent.parent
   929:     21:     load_dotenv(parent / ".env")
   930:     22:     api_key = os.getenv("BITGET_API_KEY")
   931:     23:     api_secret = os.getenv("BITGET_API_SECRET")
   932:     24:     if not api_key or not api_secret:
   933:     25:         raise RuntimeError("API keys not found in environment")
   934:     26:     return {"key": api_key, "secret": api_secret}
   935:     27: 
   936:     28: 
   937:     29: class BitgetClient:
   938:     30:     def __init__(self) -> None:
   939:     31:         creds = load_keys()
   940:     32:         self.api_key = creds["key"]
   941:     33:         self.api_secret = creds["secret"]
   942:     34:         self.session = requests.Session()
   943:     35:         self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
   944:     36:         self.time_offset = self._compute_time_offset()
   945:     37: 
   946:     38:     def _compute_time_offset(self) -> int:
   947:     39:         server = self.server_time()
   948:     40:         return int(server["serverTime"]) - int(time.time() * 1000)
   949:     41: 
   950:     42:     def _timestamp(self) -> int:
   951:     43:         return int(time.time() * 1000) + self.time_offset
   952:     44: 
   953:     45:     def _request(
   954:     46:         self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
   955:     47:     ) -> Any:
   956:     48:         params = params or {}
   957:     49:         if signed:
   958:     50:             params["timestamp"] = self._timestamp()
   959:     51:             params["recvWindow"] = RECV_WINDOW
   960:     52:             query = urlencode(params)
   961:     53:             signature = base64.b64encode(
   962:     54:                 hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
   963:     55:             ).decode()
   964:     56:             query += f"&signature={signature}"
   965:     57:             headers = {"X-BITGET-APIKEY": self.api_key}
   966:     58:             if method.upper() == "GET":
   967:     59:                 url = f"{BASE_URL}{path}?{query}"
   968:     60:                 resp = self.session.get(url, headers=headers)
   969:     61:             else:
   970:     62:                 url = f"{BASE_URL}{path}"
   971:     63:                 headers["Content-Type"] = "application/x-www-form-urlencoded"
   972:     64:                 resp = self.session.post(url, data=query, headers=headers)
   973:     65:         else:
   974:     66:             url = f"{BASE_URL}{path}"
   975:     67:             resp = self.session.request(method, url, params=params)
   976:     68: 
   977:     69:         resp.raise_for_status()
   978:     70:         if resp.text:
   979:     71:             return resp.json()
   980:     72:         return {}
   981:     73: 
   982:     74:     # Helpers
   983:     75:     def server_time(self) -> Any:
   984:     76:         return self._request("GET", "/api/v3/time")
   985:     77: 
   986:     78:     def ticker_price(self, symbol: str) -> Any:
   987:     79:         return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})
   988:     80: 
   989:     81:     def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
   990:     82:         return self._request(
   991:     83:             "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
   992:     84:         )
   993:     85: 
   994:     86:     def test_order(self, **params: Any) -> Any:
   995:     87:         return self._request("POST", "/api/v3/order/test", params, signed=True)
   996:     88: 
   997:     89:     def place_order(self, **params: Any) -> Any:
   998:     90:         return self._request("POST", "/api/v3/order", params, signed=True)
   999:     91: 
  1000:     92:     def account_info(self) -> Any:
  1001:     93:         return self._request("GET", "/api/v3/account", signed=True)
  1002:     94: 
  1003:     95:     def book_ticker(self, symbol: str) -> Any:
  1004:     96:         return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})
  1005:     97: 
  1006:     98: 
  1007:     99: def sma(values: List[float], period: int) -> float:
  1008:    100:     if len(values) < period:
  1009:    101:         raise ValueError("Not enough data for SMA")
  1010:    102:     return sum(values[-period:]) / period
  1011:    103: 
  1012:    104: 
  1013:    105: def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
  1014:    106:     kl = client.klines(symbol, limit=50)
  1015:    107:     closes = [float(k[4]) for k in kl]
  1016:    108:     sma9_prev = sma(closes[:-1], 9)
  1017:    109:     sma21_prev = sma(closes[:-1], 21)
  1018:    110:     sma9_curr = sma(closes, 9)
  1019:    111:     sma21_curr = sma(closes, 21)
  1020:    112: 
  1021:    113:     cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
  1022:    114:     cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr
  1023:    115: 
  1024:    116:     log = logging.getLogger("bitget_bot")
  1025:    117: 
  1026:    118:     if cross_up:
  1027:    119:         book = client.book_ticker(symbol)
  1028:    120:         ask = float(book["askPrice"])
  1029:    121:         qty = quote_usdt / ask
  1030:    122:         params = {
  1031:    123:             "symbol": symbol,
  1032:    124:             "side": "BUY",
  1033:    125:             "type": "LIMIT",
  1034:    126:             "timeInForce": "IOC",
  1035:    127:             "quantity": f"{qty:.6f}",
  1036:    128:             "price": book["askPrice"],
  1037:    129:         }
  1038:    130:         log.info("BUY signal %s", params)
  1039:    131:         resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1040:    132:         log.info("response %s", resp)
  1041:    133:     elif cross_down:
  1042:    134:         account = client.account_info()
  1043:    135:         base = symbol.rstrip("USDT")
  1044:    136:         bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
  1045:    137:         qty = float(bal["free"])
  1046:    138:         if qty > 0:
  1047:    139:             book = client.book_ticker(symbol)
  1048:    140:             params = {
  1049:    141:                 "symbol": symbol,
  1050:    142:                 "side": "SELL",
  1051:    143:                 "type": "LIMIT",
  1052:    144:                 "timeInForce": "IOC",
  1053:    145:                 "quantity": f"{qty:.6f}",
  1054:    146:                 "price": book["bidPrice"],
  1055:    147:             }
  1056:    148:             log.info("SELL signal %s", params)
  1057:    149:             resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1058:    150:             log.info("response %s", resp)
  1059:    151:         else:
  1060:    152:             log.info("No balance to sell")
  1061:    153: 
  1062:    154: 
  1063:    155: def interval_seconds(interval: str) -> int:
  1064:    156:     unit = interval[-1]
  1065:    157:     qty = int(interval[:-1])
  1066:    158:     if unit == "m":
  1067:    159:         return qty * 60
  1068:    160:     if unit == "h":
  1069:    161:         return qty * 3600
  1070:    162:     if unit == "d":
  1071:    163:         return qty * 86400
  1072:    164:     return 60
  1073:    165: 
  1074:    166: 
  1075:    167: def main() -> None:
  1076:    168:     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
  1077:    169:     parser = ArgumentParser(description="Bitget SMA crossover bot")
  1078:    170:     parser.add_argument("--symbol", default="BTCUSDT")
  1079:    171:     parser.add_argument("--quote-usdt", type=float, default=10.0)
  1080:    172:     parser.add_argument("--interval", default="1m")
  1081:    173:     parser.add_argument("--loop", action="store_true")
  1082:    174:     parser.add_argument("--dry-run", dest="dry_run", action="store_true")
  1083:    175:     parser.add_argument("--live", dest="dry_run", action="store_false")
  1084:    176:     parser.set_defaults(dry_run=True)
  1085:    177:     args = parser.parse_args()
  1086:    178: 
  1087:    179:     client = BitgetClient()
  1088:    180:     delay = interval_seconds(args.interval)
  1089:    181: 
  1090:    182:     while True:
  1091:    183:         try:
  1092:    184:             analyze(client, args.symbol, args.quote_usdt, args.dry_run)
  1093:    185:         except Exception as exc:
  1094:    186:             logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
  1095:    187:         if not args.loop:
  1096:    188:             break
  1097:    189:         time.sleep(delay)
  1098:    190: 
  1099:    191: 
  1100:    192: if __name__ == "__main__":
  1101:    193:     main()
  1102: 
  1103: 
  1104: ## TRASH_20250823-124533/quick_order.py (last modified: 2025-08-23 20:57:14)
  1105:      1: #!/usr/bin/env python3
  1106:      2: """Submit a simple market order on Bitget futures.
  1107:      3: 
  1108:      4: This helper reads API credentials and trade parameters from environment
  1109:      5: variables (optionally loaded from a `.env` file) and places a one-way
  1110:      6: market order.  Only the essential steps from the user's reference script
  1111:      7: are kept to minimise latency and redundant code.
  1112:      8: 
  1113:      9: Environment variables:
  1114:     10:     BITGET_API_KEY / BITGET_ACCESS_KEY
  1115:     11:     BITGET_API_SECRET / BITGET_SECRET_KEY
  1116:     12:     BITGET_API_PASSPHRASE
  1117:     13:     BITGET_BASE_URL (default https://api.bitget.com)
  1118:     14:     BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
  1119:     15:     BITGET_MARGIN_COIN (default ``USDT``)
  1120:     16:     BITGET_SYMBOL (e.g. ``BTCUSDT``)
  1121:     17:     BITGET_TEST_NOTIONAL_USDT (default ``5``)
  1122:     18: 
  1123:     19: Usage:
  1124:     20:     python quick_order.py buy
  1125:     21:     python quick_order.py sell
  1126:     22: """
  1127:     23: 
  1128:     24: from __future__ import annotations
  1129:     25: 
  1130:     26: import os
  1131:     27: import sys
  1132:     28: from pathlib import Path
  1133:     29: 
  1134:     30: from dotenv import load_dotenv
  1135:     31: 
  1136:     32: from scalper.bitget_client import BitgetFuturesClient
  1137:     33: 
  1138:     34: # Load variables from `.env` if present
  1139:     35: load_dotenv(Path(__file__).resolve().parent / ".env")
  1140:     36: 
  1141:     37: side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
  1142:     38: if side not in {"buy", "sell"}:
  1143:     39:     raise SystemExit("Usage: quick_order.py [buy|sell]")
  1144:     40: 
  1145:     41: base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
  1146:     42: ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
  1147:     43: sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
  1148:     44: ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
  1149:     45: product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
  1150:     46: margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
  1151:     47: symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
  1152:     48: notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))
  1153:     49: 
  1154:     50: if not (ak and sk and ph):
  1155:     51:     raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")
  1156:     52: 
  1157:     53: client = BitgetFuturesClient(
  1158:     54:     access_key=ak,
  1159:     55:     secret_key=sk,
  1160:     56:     base_url=base,
  1161:     57:     passphrase=ph,
  1162:     58:     paper_trade=False,
  1163:     59: )
  1164:     60: 
  1165:     61: tick = client.get_ticker(symbol)
  1166:     62: price = None
  1167:     63: try:
  1168:     64:     data = tick.get("data")
  1169:     65:     if isinstance(data, list) and data:
  1170:     66:         price_str = data[0].get("lastPr") or data[0].get("lastPrice")
  1171:     67:         if price_str is not None:
  1172:     68:             price = float(price_str)
  1173:     69:     elif isinstance(data, dict):
  1174:     70:         price_str = data.get("lastPr") or data.get("lastPrice")
  1175:     71:         if price_str is not None:
  1176:     72:             price = float(price_str)
  1177:     73: except Exception:
  1178:     74:     pass
  1179:     75: if price is None or price <= 0:
  1180:     76:     raise SystemExit("Prix introuvable pour le ticker")
  1181:     77: 
  1182:     78: size = round(notional / price, 6)
  1183:     79: client.set_position_mode_one_way(symbol, product_type)
  1184:     80: client.set_leverage(symbol, product_type, margin_coin, leverage=2)
  1185:     81: resp = client.place_market_order_one_way(
  1186:     82:     symbol, side, size, product_type, margin_coin
  1187:     83: )
  1188:     84: print(resp)
  1189: 
  1190: 
  1191: ## TRASH_20250823-124533/rr.py (last modified: 2025-08-23 20:57:14)
  1192:      1: #!/usr/bin/env python3
  1193:      2: from __future__ import annotations
  1194:      3: import argparse, shutil, re, os, datetime as dt
  1195:      4: from pathlib import Path
  1196:      5: 
  1197:      6: # ---------- helpers ----------
  1198:      7: def info(msg): print(f"[i] {msg}")
  1199:      8: def ok(msg):   print(f"[✓] {msg}")
  1200:      9: def warn(msg): print(f"[!] {msg}")
  1201:     10: 
  1202:     11: def backup_repo(repo: Path) -> Path:
  1203:     12:     ts = dt.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
  1204:     13:     dst = repo.parent / f".backup-refactor-{ts}"
  1205:     14:     shutil.copytree(repo, dst)
  1206:     15:     ok(f"Sauvegarde créée: {dst}")
  1207:     16:     return dst
  1208:     17: 
  1209:     18: def ensure_pkg_init(path: Path):
  1210:     19:     initp = path / "__init__.py"
  1211:     20:     if not initp.exists():
  1212:     21:         initp.write_text("# package\n", encoding="utf-8")
  1213:     22: 
  1214:     23: def move_dir(src: Path, dst: Path):
  1215:     24:     if not src.exists(): return
  1216:     25:     dst.mkdir(parents=True, exist_ok=True)
  1217:     26:     for child in src.iterdir():
  1218:     27:         shutil.move(str(child), str(dst / child.name))
  1219:     28:     # supprime le répertoire source s'il est vide
  1220:     29:     try: src.rmdir()
  1221:     30:     except Exception: pass
  1222:     31: 
  1223:     32: # règles initiales (rangement)
  1224:     33: IMPORT_RULES_STAGE1 = [
  1225:     34:     (re.compile(r"from\s+scalp\.config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1226:     35:     (re.compile(r"from\s+config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1227:     36:     (re.compile(r"from\s+scalp\.config\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1228:     37:     (re.compile(r"from\s+live(\.| import)"), r"from scalper.live\1"),
  1229:     38:     (re.compile(r"import\s+live(\s|$)"), r"import scalper.live\1"),
  1230:     39:     (re.compile(r"from\s+backtest(\.| import)"), r"from scalper.backtest\1"),
  1231:     40:     (re.compile(r"import\s+backtest(\s|$)"), r"import scalper.backtest\1"),
  1232:     41:     (re.compile(r"from\s+signals(\.| import)"), r"from scalper.signals\1"),
  1233:     42:     (re.compile(r"import\s+signals(\s|$)"), r"import scalper.signals\1"),
  1234:     43:     (re.compile(r"from\s+exchange(\.| import)"), r"from scalper.exchange\1"),
  1235:     44:     (re.compile(r"import\s+exchange(\s|$)"), r"import scalper.exchange\1"),
  1236:     45: ]
  1237:     46: 
  1238:     47: def rewrite_imports(root: Path, rules):
  1239:     48:     changed = 0
  1240:     49:     for py in root.rglob("*.py"):
  1241:     50:         if ".backup-" in str(py) or ".backup" in str(py):  # safety
  1242:     51:             continue
  1243:     52:         txt = py.read_text(encoding="utf-8")
  1244:     53:         new = txt
  1245:     54:         for pat, rep in rules:
  1246:     55:             new = pat.sub(rep, new)
  1247:     56:         if new != txt:
  1248:     57:             py.write_text(new, encoding="utf-8")
  1249:     58:             changed += 1
  1250:     59:     return changed
  1251:     60: 
  1252:     61: def ensure_config_package(scalp_pkg: Path):
  1253:     62:     """Transforme scalp/config.py en package scalp/config/loader.py et ajoute __init__.py exportant load_settings."""
  1254:     63:     flat = scalp_pkg / "config.py"
  1255:     64:     pkg = scalp_pkg / "config"
  1256:     65:     loader = pkg / "loader.py"
  1257:     66:     initp = pkg / "__init__.py"
  1258:     67: 
  1259:     68:     # si un config.py existe, le renommer pour archivage
  1260:     69:     if flat.exists():
  1261:     70:         legacy = scalp_pkg / "legacy_config.py"
  1262:     71:         if legacy.exists(): legacy.unlink()
  1263:     72:         shutil.move(str(flat), str(legacy))
  1264:     73:         info(f"renommé {flat} -> {legacy}")
  1265:     74: 
  1266:     75:     pkg.mkdir(parents=True, exist_ok=True)
  1267:     76:     ensure_pkg_init(pkg)
  1268:     77: 
  1269:     78:     # si pas de loader.py, créer un loader minimal (tu pourras le remplacer par ta version complète)
  1270:     79:     if not loader.exists():
  1271:     80:         loader.write_text(
  1272:     81:             'from __future__ import annotations\n'
  1273:     82:             'import os, json\n'
  1274:     83:             'from typing import Any, Dict, Tuple\n'
  1275:     84:             'try:\n'
  1276:     85:             '    import yaml\n'
  1277:     86:             'except Exception:\n'
  1278:     87:             '    yaml = None\n'
  1279:     88:             'try:\n'
  1280:     89:             '    from dotenv import load_dotenv\n'
  1281:     90:             'except Exception:\n'
  1282:     91:             '    load_dotenv = None\n'
  1283:     92:             '\n'
  1284:     93:             'def _read_yaml(path: str):\n'
  1285:     94:             '    if not os.path.exists(path): return {}\n'
  1286:     95:             '    with open(path, "r", encoding="utf-8") as f:\n'
  1287:     96:             '        if yaml: return yaml.safe_load(f) or {}\n'
  1288:     97:             '        return json.load(f)\n'
  1289:     98:             '\n'
  1290:     99:             'def load_settings(config_path: str="config.yml", config_local_path: str="config.local.yml"):\n'
  1291:    100:             '    if load_dotenv: load_dotenv(override=False)\n'
  1292:    101:             '    base = _read_yaml(config_path)\n'
  1293:    102:             '    local = _read_yaml(config_local_path)\n'
  1294:    103:             '    cfg = {**base, **local}\n'
  1295:    104:             '    runtime = {\n'
  1296:    105:             '        "quiet": bool(cfg.get("QUIET", 1)),\n'
  1297:    106:             '        "print_sample": bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)),\n'
  1298:    107:             '        "timeframe": str(cfg.get("TIMEFRAME", "5m")),\n'
  1299:    108:             '        "cash": float(cfg.get("CASH", 10000)),\n'
  1300:    109:             '        "risk_pct": float(cfg.get("RISK_PCT", 0.5)),\n'
  1301:    110:             '        "slippage_bps": float(cfg.get("SLIPPAGE_BPS", 2)),\n'
  1302:    111:             '        "watchlist_mode": str(cfg.get("WATCHLIST_MODE", "local")),\n'
  1303:    112:             '        "watchlist_local_conc": int(cfg.get("WATCHLIST_LOCAL_CONC", 5)),\n'
  1304:    113:             '        "top_symbols": cfg.get("TOP_SYMBOLS", []),\n'
  1305:    114:             '        "top_candidates": cfg.get("TOP_CANDIDATES", []),\n'
  1306:    115:             '        "caps": cfg.get("CAPS", {}),\n'
  1307:    116:             '        "fees_by_symbol": {},\n'
  1308:    117:             '    }\n'
  1309:    118:             '    secrets = {\n'
  1310:    119:             '        "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),\n'
  1311:    120:             '        "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),\n'
  1312:    121:             '        "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),\n'
  1313:    122:             '        "BITGET_USE_TESTNET": os.getenv("BITGET_USE_TESTNET", "1") in ("1","true","True"),\n'
  1314:    123:             '        "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),\n'
  1315:    124:             '        "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),\n'
  1316:    125:             '        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),\n'
  1317:    126:             '    }\n'
  1318:    127:             '    return runtime, secrets\n',
  1319:    128:             encoding="utf-8"
  1320:    129:         )
  1321:    130:     # __init__.py exporte load_settings
  1322:    131:     initp.write_text("from .loader import load_settings\n__all__ = ['load_settings']\n", encoding="utf-8")
  1323:    132: 
  1324:    133: def stage1_restructure(repo: Path):
  1325:    134:     """Range les modules à l’intérieur du package 'scalp/' + fix imports."""
  1326:    135:     scalp_pkg = repo / "scalp"
  1327:    136:     scalp_pkg.mkdir(exist_ok=True)
  1328:    137:     ensure_pkg_init(scalp_pkg)
  1329:    138: 
  1330:    139:     for mod in ("live", "backtest", "signals", "config", "exchange"):
  1331:    140:         src = repo / mod
  1332:    141:         if src.exists() and src.is_dir():
  1333:    142:             dst = scalp_pkg / mod
  1334:    143:             info(f"déplacement {src} -> {dst}")
  1335:    144:             move_dir(src, dst)
  1336:    145:             ensure_pkg_init(dst)
  1337:    146: 
  1338:    147:     # gérer config.py -> package config/loader.py
  1339:    148:     ensure_config_package(scalp_pkg)
  1340:    149: 
  1341:    150:     # réécriture imports vers scalper.*
  1342:    151:     changed = rewrite_imports(repo, IMPORT_RULES_STAGE1)
  1343:    152:     ok(f"imports stage1 réécrits dans {changed} fichier(s)")
  1344:    153: 
  1345:    154: def stage2_rename_package(repo: Path, old="scalp", new="scalper"):
  1346:    155:     """Renomme le package interne old -> new et réécrit tous les imports."""
  1347:    156:     pkg_old = repo / old
  1348:    157:     pkg_new = repo / new
  1349:    158:     if not pkg_old.exists():
  1350:    159:         warn(f"package {pkg_old} introuvable (déjà renommé ?)")
  1351:    160:     else:
  1352:    161:         shutil.move(str(pkg_old), str(pkg_new))
  1353:    162:         ok(f"package renommé {pkg_old.name} -> {pkg_new.name}")
  1354:    163: 
  1355:    164:     # réécriture imports 'old.' -> 'new.'
  1356:    165:     pat = re.compile(rf"\b{old}\.")
  1357:    166:     changed = 0
  1358:    167:     for py in repo.rglob("*.py"):
  1359:    168:         if ".backup" in str(py): continue
  1360:    169:         txt = py.read_text(encoding="utf-8")
  1361:    170:         new_txt = pat.sub(f"{new}.", txt)
  1362:    171:         if new_txt != txt:
  1363:    172:             py.write_text(new_txt, encoding="utf-8")
  1364:    173:             changed += 1
  1365:    174:     ok(f"imports stage2 réécrits dans {changed} fichier(s)")
  1366:    175: 
  1367:    176: def main():
  1368:    177:     ap = argparse.ArgumentParser(description="Restructure + rename Python package (scalp -> scalper).")
  1369:    178:     ap.add_argument("--repo", default="./", help="Chemin du repo (racine qui contient bot.py).")
  1370:    179:     args = ap.parse_args()
  1371:    180:     repo = Path(args.repo).resolve()
  1372:    181:     if not repo.exists(): raise SystemExit(f"Repo introuvable: {repo}")
  1373:    182: 
  1374:    183:     # 1) sauvegarde
  1375:    184:     backup_repo(repo)
  1376:    185: 
  1377:    186:     # 2) ranger les modules sous scalp/ (package) + fixer imports
  1378:    187:     stage1_restructure(repo)
  1379:    188: 
  1380:    189:     # 3) renommer le package interne scalp/ -> scalper/ + fixer imports
  1381:    190:     stage2_rename_package(repo, old="scalp", new="scalper")
  1382:    191: 
  1383:    192:     ok("Refactor complet terminé.")
  1384:    193:     print("\n➡️ Vérifie maintenant:\n"
  1385:    194:           "   python - <<'PY'\n"
  1386:    195:           "import importlib; m = importlib.import_module('scalper.config'); print('OK:', hasattr(m, 'load_settings'))\n"
  1387:    196:           "PY\n"
  1388:    197:           "\nPuis lance:\n"
  1389:    198:           "   python bot.py\n")
  1390:    199: 
  1391:    200: if __name__ == "__main__":
  1392:    201:     main()
  1393: 
  1394: ## TRASH_20250823-124533/run_backtest.py (last modified: 2025-08-23 20:57:14)
  1395:      1: #!/usr/bin/env python3
  1396:      2: import os
  1397:      3: from scalper.backtest.engine import BacktestEngine
  1398:      4: 
  1399:      5: def main():
  1400:      6:     print("[*] Lancement du backtest...")
  1401:      7:     
  1402:      8:     # ⚡ Tu pourras changer ces paramètres
  1403:      9:     pairs = ["BTCUSDT", "ETHUSDT"]  # pour commencer simple
  1404:     10:     start_date = "2024-01-01"
  1405:     11:     end_date = "2024-02-01"
  1406:     12: 
  1407:     13:     # Dossier résultat
  1408:     14:     result_dir = os.path.join(os.path.dirname(__file__), "result")
  1409:     15:     os.makedirs(result_dir, exist_ok=True)
  1410:     16: 
  1411:     17:     # Création du moteur
  1412:     18:     engine = BacktestEngine(
  1413:     19:         pairs=pairs,
  1414:     20:         start_date=start_date,
  1415:     21:         end_date=end_date,
  1416:     22:         result_dir=result_dir
  1417:     23:     )
  1418:     24: 
  1419:     25:     # Lancer le backtest
  1420:     26:     engine.run()
  1421:     27: 
  1422:     28:     print("[✅] Backtest terminé ! Résultats disponibles dans /result/")
  1423:     29: 
  1424:     30: if __name__ == "__main__":
  1425:     31:     main()
  1426: 
  1427: ## TRASH_20250823-124533/scalper/bot_config.py (last modified: 2025-08-23 20:57:14)
  1428:      1: import os
  1429:      2: 
  1430:      3: 
  1431:      4: DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"
  1432:      5: 
  1433:      6: CONFIG = {
  1434:      7:     "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
  1435:      8:     or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
  1436:      9:     "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
  1437:     10:     or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
  1438:     11:     "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
  1439:     12:     "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
  1440:     13:     "SYMBOL": DEFAULT_SYMBOL,
  1441:     14:     "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
  1442:     15:     "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
  1443:     16:     "INTERVAL": os.getenv("INTERVAL", "1m"),
  1444:     17:     "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
  1445:     18:     "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
  1446:     19:     "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
  1447:     20:     "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
  1448:     21:     "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
  1449:     22:     "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
  1450:     23:     "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
  1451:     24:     "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
  1452:     25:     "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
  1453:     26:     "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
  1454:     27:     "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
  1455:     28:     "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
  1456:     29:     "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
  1457:     30:     "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
  1458:     31:     "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
  1459:     32:     "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
  1460:     33:     "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
  1461:     34:     "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
  1462:     35:     "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
  1463:     36:     "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
  1464:     37:     "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
  1465:     38:     # --- Sécurité / Sizing -------------------------------------------------
  1466:     39:     "ALLOWED_SYMBOLS": [
  1467:     40:         s.strip().upper()
  1468:     41:         for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
  1469:     42:         if s.strip()
  1470:     43:     ],
  1471:     44:     "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
  1472:     45:     "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
  1473:     46:     "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
  1474:     47:     "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
  1475:     48:     "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
  1476:     49:     "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
  1477:     50:     "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
  1478:     51:     "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
  1479:     52:     "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
  1480:     53: }
  1481:     54: 
  1482: 
  1483: 
  1484: ## TRASH_20250823-124533/scalper/legacy_config.py (last modified: 2025-08-23 20:57:14)
  1485:      1: # scalp/config.py
  1486:      2: from __future__ import annotations
  1487:      3: import os, sys
  1488:      4: from typing import Optional
  1489:      5: 
  1490:      6: # ---------------------------
  1491:      7: #  Chargement .env (sans dep)
  1492:      8: # ---------------------------
  1493:      9: def _load_dotenv_if_present(path: str = ".env") -> None:
  1494:     10:     try:
  1495:     11:         if not os.path.isfile(path):
  1496:     12:             return
  1497:     13:         with open(path, "r", encoding="utf-8") as f:
  1498:     14:             for line in f:
  1499:     15:                 s = line.strip()
  1500:     16:                 if not s or s.startswith("#") or "=" not in s:
  1501:     17:                     continue
  1502:     18:                 k, v = s.split("=", 1)
  1503:     19:                 k = k.strip()
  1504:     20:                 v = v.strip().strip('"').strip("'")
  1505:     21:                 # ne pas écraser une var déjà définie par l'env
  1506:     22:                 os.environ.setdefault(k, v)
  1507:     23:     except Exception:
  1508:     24:         pass
  1509:     25: 
  1510:     26: _load_dotenv_if_present()
  1511:     27: 
  1512:     28: # ---------------------------
  1513:     29: #  Aliases variables d'env
  1514:     30: # ---------------------------
  1515:     31: def _env_alias(name: str, *aliases: str) -> Optional[str]:
  1516:     32:     """Retourne la première valeur non nulle parmi name et ses alias."""
  1517:     33:     if name in os.environ and os.environ[name]:
  1518:     34:         return os.environ[name]
  1519:     35:     for a in aliases:
  1520:     36:         v = os.environ.get(a)
  1521:     37:         if v:
  1522:     38:             return v
  1523:     39:     return None
  1524:     40: 
  1525:     41: def _env_bool(name: str, default: bool) -> bool:
  1526:     42:     raw = os.environ.get(name)
  1527:     43:     if raw is None:
  1528:     44:         return default
  1529:     45:     return raw.lower() in ("1", "true", "yes", "on")
  1530:     46: 
  1531:     47: # ---------------------------
  1532:     48: #  Pydantic v1 si dispo
  1533:     49: # ---------------------------
  1534:     50: try:
  1535:     51:     from pydantic import BaseModel, Field, ValidationError  # type: ignore
  1536:     52:     _HAVE_PYDANTIC = True
  1537:     53: except Exception:
  1538:     54:     _HAVE_PYDANTIC = False
  1539:     55: 
  1540:     56: if _HAVE_PYDANTIC:
  1541:     57: 
  1542:     58:     class AppConfig(BaseModel):
  1543:     59:         # Clés Bitget
  1544:     60:         BITGET_API_KEY: str = Field(..., min_length=3)
  1545:     61:         BITGET_API_SECRET: str = Field(..., min_length=3)
  1546:     62:         BITGET_PASSPHRASE: str = Field(..., min_length=1)
  1547:     63: 
  1548:     64:         # Trading
  1549:     65:         RISK_PCT: float = Field(0.01, ge=0.0, le=0.2)
  1550:     66:         MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
  1551:     67:         LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
  1552:     68:         PAPER_TRADE: bool = Field(True)
  1553:     69: 
  1554:     70:         # Telegram (facultatif)
  1555:     71:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  1556:     72:         TELEGRAM_CHAT_ID: Optional[str] = None
  1557:     73: 
  1558:     74:     def load_or_exit() -> "AppConfig":
  1559:     75:         try:
  1560:     76:             # supporte aussi ACCESS_KEY/SECRET_KEY (alias)
  1561:     77:             api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  1562:     78:             api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  1563:     79:             api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  1564:     80: 
  1565:     81:             return AppConfig(
  1566:     82:                 BITGET_API_KEY=api_key,
  1567:     83:                 BITGET_API_SECRET=api_sec,
  1568:     84:                 BITGET_PASSPHRASE=api_pass,
  1569:     85:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  1570:     86:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  1571:     87:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  1572:     88:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  1573:     89:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  1574:     90:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  1575:     91:             )
  1576:     92:         except ValidationError as e:
  1577:     93:             print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
  1578:     94:             sys.exit(2)
  1579:     95: 
  1580:     96: else:
  1581:     97:     # ---------------------------
  1582:     98:     #  Fallback dataclass simple
  1583:     99:     # ---------------------------
  1584:    100:     from dataclasses import dataclass
  1585:    101: 
  1586:    102:     @dataclass
  1587:    103:     class AppConfig:
  1588:    104:         BITGET_API_KEY: str
  1589:    105:         BITGET_API_SECRET: str
  1590:    106:         BITGET_PASSPHRASE: str
  1591:    107: 
  1592:    108:         RISK_PCT: float = 0.01
  1593:    109:         MIN_TRADE_USDT: float = 5.0
  1594:    110:         LEVERAGE: float = 1.0
  1595:    111:         PAPER_TRADE: bool = True
  1596:    112: 
  1597:    113:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  1598:    114:         TELEGRAM_CHAT_ID: Optional[str] = None
  1599:    115: 
  1600:    116:     def load_or_exit() -> "AppConfig":
  1601:    117:         api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  1602:    118:         api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  1603:    119:         api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  1604:    120: 
  1605:    121:         if not api_key or not api_sec or not api_pass:
  1606:    122:             print("[CONFIG] Missing Bitget credentials. Expected either:", file=sys.stderr)
  1607:    123:             print("        - BITGET_API_KEY / BITGET_API_SECRET / BITGET_PASSPHRASE", file=sys.stderr)
  1608:    124:             print("          or", file=sys.stderr)
  1609:    125:             print("        - BITGET_ACCESS_KEY / BITGET_SECRET_KEY / BITGET_PASSPHRASE", file=sys.stderr)
  1610:    126:             sys.exit(2)
  1611:    127: 
  1612:    128:         try:
  1613:    129:             return AppConfig(
  1614:    130:                 BITGET_API_KEY=api_key,
  1615:    131:                 BITGET_API_SECRET=api_sec,
  1616:    132:                 BITGET_PASSPHRASE=api_pass,
  1617:    133:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  1618:    134:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  1619:    135:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  1620:    136:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  1621:    137:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  1622:    138:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  1623:    139:             )
  1624:    140:         except Exception as e:
  1625:    141:             print(f"[CONFIG] Invalid configuration values: {e!r}", file=sys.stderr)
  1626:    142:             sys.exit(2)
  1627: 
  1628: ## TRASH_20250823-124533/scalper/notifier.py (last modified: 2025-08-23 20:57:14)
  1629:      1: """Simple notifier for bot events."""
  1630:      2: 
  1631:      3: from __future__ import annotations
  1632:      4: 
  1633:      5: import logging
  1634:      6: import os
  1635:      7: from typing import Any, Dict
  1636:      8: 
  1637:      9: try:  # pragma: no cover - guarded import for optional dependency
  1638:     10:     import requests as _requests
  1639:     11: 
  1640:     12:     # ``requests`` may be provided as a stub during tests. Ensure it exposes a
  1641:     13:     # ``post`` attribute so callers can monkeypatch it reliably.
  1642:     14:     if not hasattr(_requests, "post"):
  1643:     15:         raise ImportError
  1644:     16:     requests = _requests
  1645:     17: except Exception:  # pragma: no cover - fallback when ``requests`` is missing
  1646:     18: 
  1647:     19:     class _Requests:
  1648:     20:         """Minimal stand‑in for :mod:`requests` when the real library is absent."""
  1649:     21: 
  1650:     22:         def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
  1651:     23:             raise RuntimeError("requests.post unavailable")
  1652:     24: 
  1653:     25:     requests = _Requests()  # type: ignore[assignment]
  1654:     26: 
  1655:     27: 
  1656:     28: def _pair_name(symbol: str) -> str:
  1657:     29:     """Return a human friendly pair name without the base ``USDT``."""
  1658:     30:     if "_" in symbol:
  1659:     31:         base, quote = symbol.split("_", 1)
  1660:     32:     elif symbol.endswith("USDT"):
  1661:     33:         base, quote = symbol[:-4], "USDT"
  1662:     34:     else:
  1663:     35:         base, quote = symbol, ""
  1664:     36:     if not quote or quote == "USDT":
  1665:     37:         return base
  1666:     38:     return f"{base}/{quote}"
  1667:     39: 
  1668:     40: 
  1669:     41: def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
  1670:     42:     """Format a position open/close payload."""
  1671:     43: 
  1672:     44:     side = payload.get("side")
  1673:     45:     symbol = payload.get("symbol")
  1674:     46:     if symbol:
  1675:     47:         symbol = _pair_name(symbol)
  1676:     48: 
  1677:     49:     if event == "position_opened":
  1678:     50:         rc = payload.get("risk_color", "")
  1679:     51:         head = f"{rc} Ouvre {side} {symbol}".strip()
  1680:     52:         lines = [head]
  1681:     53:         lines.append(
  1682:     54:             f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
  1683:     55:         )
  1684:     56:         lines.append(
  1685:     57:             "Marge estimée: {} USDT (dispo: {} USDT)".format(
  1686:     58:                 payload.get("required_margin_usdt"), payload.get("available_usdt")
  1687:     59:             )
  1688:     60:         )
  1689:     61:         lines.append(
  1690:     62:             "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
  1691:     63:                 payload.get("signal_level"),
  1692:     64:                 payload.get("risk_level_user"),
  1693:     65:                 float(payload.get("risk_pct_eff", 0.0)) * 100,
  1694:     66:             )
  1695:     67:         )
  1696:     68:         lines.append(
  1697:     69:             "Prix: {}   Vol: {} (cs={})".format(
  1698:     70:                 payload.get("price"),
  1699:     71:                 payload.get("vol"),
  1700:     72:                 payload.get("contract_size"),
  1701:     73:             )
  1702:     74:         )
  1703:     75:         return "\n".join(lines)
  1704:     76: 
  1705:     77:     # position_closed
  1706:     78:     rc = payload.get("risk_color", "")
  1707:     79:     head = f"Ferme {side} {symbol} {rc}".strip()
  1708:     80:     lines = [head]
  1709:     81:     pnl_usdt = payload.get("pnl_usdt")
  1710:     82:     fees = payload.get("fees_usdt")
  1711:     83:     if pnl_usdt is not None and fees is not None:
  1712:     84:         lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
  1713:     85:     pct = payload.get("pnl_pct_on_margin")
  1714:     86:     if pct is not None:
  1715:     87:         lines.append(f"% sur marge: {pct:.2f}%")
  1716:     88:     lines.append(
  1717:     89:         "Entrée: {}  Sortie: {}".format(
  1718:     90:             payload.get("entry_price"), payload.get("exit_price")
  1719:     91:         )
  1720:     92:     )
  1721:     93:     lines.append(
  1722:     94:         "Vol: {}  Notional: in {} → out {} USDT".format(
  1723:     95:             payload.get("vol"),
  1724:     96:             payload.get("notional_entry_usdt"),
  1725:     97:             payload.get("notional_exit_usdt"),
  1726:     98:         )
  1727:     99:     )
  1728:    100:     return "\n".join(lines)
  1729:    101: 
  1730:    102: 
  1731:    103: def _format_pair_list(payload: Dict[str, Any]) -> str:
  1732:    104:     """Format the pair list payload.
  1733:    105: 
  1734:    106:     The detailed pair listing is intentionally hidden from terminal output to
  1735:    107:     reduce noise. Only an acknowledgement message is returned.
  1736:    108:     """
  1737:    109: 
  1738:    110:     return "Listing ok"
  1739:    111: 
  1740:    112: 
  1741:    113: def _format_generic(event: str, payload: Dict[str, Any]) -> str:
  1742:    114:     text = event
  1743:    115:     if payload:
  1744:    116:         items = "\n".join(f"{k}={v}" for k, v in payload.items())
  1745:    117:         text = f"{text}\n{items}"
  1746:    118:     return text
  1747:    119: 
  1748:    120: 
  1749:    121: def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
  1750:    122:     """Return a human readable text describing the event payload."""
  1751:    123:     payload = payload or {}
  1752:    124:     if event in {"position_opened", "position_closed"}:
  1753:    125:         return _format_position_event(event, payload)
  1754:    126:     if event == "pair_list":
  1755:    127:         return _format_pair_list(payload)
  1756:    128:     if event == "bot_started":
  1757:    129:         return "🤖 Bot démarré"
  1758:    130:     return _format_generic(event, payload)
  1759:    131: 
  1760:    132: 
  1761:    133: def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
  1762:    134:     """Send an event payload to configured endpoints.
  1763:    135: 
  1764:    136:     Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
  1765:    137:     and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
  1766:    138:     ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
  1767:    139:     ignored so they do not interrupt the bot's execution.
  1768:    140:     """
  1769:    141: 
  1770:    142:     data = {"event": event}
  1771:    143:     if payload:
  1772:    144:         data.update(payload)
  1773:    145: 
  1774:    146:     # Generic HTTP webhook
  1775:    147:     url = os.getenv("NOTIFY_URL")
  1776:    148:     if url:
  1777:    149:         try:
  1778:    150:             requests.post(url, json=data, timeout=5)
  1779:    151:         except Exception as exc:  # pragma: no cover - best effort only
  1780:    152:             logging.error("Notification error for %s: %s", event, exc)
  1781:    153: 
  1782:    154:     # Telegram notification
  1783:    155:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  1784:    156:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  1785:    157:     # ``pair_list`` notifications are intentionally not forwarded to Telegram
  1786:    158:     if token and chat_id and event != "pair_list":
  1787:    159:         text = _format_text(event, payload or {})
  1788:    160:         t_url = f"https://api.telegram.org/bot{token}/sendMessage"
  1789:    161:         t_payload = {"chat_id": chat_id, "text": text}
  1790:    162:         try:  # pragma: no cover - network
  1791:    163:             requests.post(t_url, json=t_payload, timeout=5)
  1792:    164:         except Exception as exc:  # pragma: no cover - best effort only
  1793:    165:             logging.error("Telegram notification error for %s: %s", event, exc)
  1794: 
  1795: 
  1796: ## TRASH_20250823-124533/scalper/telegram_bot.py (last modified: 2025-08-23 20:57:14)
  1797:      1: from __future__ import annotations
  1798:      2: 
  1799:      3: import logging
  1800:      4: import os
  1801:      5: from typing import Any, Dict, Optional
  1802:      6: 
  1803:      7: try:  # pragma: no cover - optional dependency
  1804:      8:     import requests as _requests
  1805:      9:     requests = _requests
  1806:     10: except Exception:  # pragma: no cover
  1807:     11:     class _Requests:
  1808:     12:         def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  1809:     13:             raise RuntimeError("requests.get unavailable")
  1810:     14: 
  1811:     15:         def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  1812:     16:             raise RuntimeError("requests.post unavailable")
  1813:     17: 
  1814:     18:     requests = _Requests()  # type: ignore[assignment]
  1815:     19: 
  1816:     20: 
  1817:     21: class TelegramBot:
  1818:     22:     """Minimal Telegram bot using the HTTP API.
  1819:     23: 
  1820:     24: 
  1821:     25:     The bot exposes a simple *menu* based interface with clickable buttons so
  1822:     26:     users do not have to remember text commands.  A sub-menu lets the user set
  1823:     27:     the risk level.
  1824:     28: 
  1825:     29:     """
  1826:     30: 
  1827:     31:     def __init__(
  1828:     32:         self,
  1829:     33:         token: str,
  1830:     34:         chat_id: str,
  1831:     35:         client: Any,
  1832:     36:         config: Dict[str, Any],
  1833:     37:         risk_mgr: Any,
  1834:     38:         *,
  1835:     39:         requests_module: Any = requests,
  1836:     40:     ) -> None:
  1837:     41:         self.token = token
  1838:     42:         self.chat_id = str(chat_id)
  1839:     43:         self.client = client
  1840:     44:         self.config = config
  1841:     45:         self.risk_mgr = risk_mgr
  1842:     46:         self.requests = requests_module
  1843:     47:         self.last_update_id: Optional[int] = None
  1844:     48:         self.stop_requested = False
  1845:     49: 
  1846:     50: 
  1847:     51:         self.main_keyboard = [
  1848:     52:             [{"text": "Positions ouvertes", "callback_data": "positions"}],
  1849:     53:             [{"text": "Update Cryptos", "callback_data": "update"}],
  1850:     54:             [{"text": "Réglages", "callback_data": "settings"}],
  1851:     55:             [{"text": "Arrêt bot", "callback_data": "shutdown"}],
  1852:     56:         ]
  1853:     57:         self.settings_keyboard = [
  1854:     58:             [{"text": "Stop trade", "callback_data": "stop"}],
  1855:     59:             [{"text": "Réglage risk", "callback_data": "risk"}],
  1856:     60:             [{"text": "Nb positions", "callback_data": "maxpos"}],
  1857:     61:             [{"text": "Reset risk", "callback_data": "reset_risk"}],
  1858:     62:             [{"text": "Reset total", "callback_data": "reset_all"}],
  1859:     63:             [{"text": "Retour", "callback_data": "back"}],
  1860:     64:         ]
  1861:     65:         self.risk_keyboard = [
  1862:     66:             [
  1863:     67:                 {"text": "🟢", "callback_data": "risk_green"},
  1864:     68:                 {"text": "🟠", "callback_data": "risk_orange"},
  1865:     69:                 {"text": "🔴", "callback_data": "risk_red"},
  1866:     70:             ],
  1867:     71:             [{"text": "Retour", "callback_data": "back"}],
  1868:     72:         ]
  1869:     73:         self.maxpos_keyboard = [
  1870:     74:             [
  1871:     75:                 {"text": "1", "callback_data": "maxpos_1"},
  1872:     76:                 {"text": "2", "callback_data": "maxpos_2"},
  1873:     77:                 {"text": "3", "callback_data": "maxpos_3"},
  1874:     78:             ],
  1875:     79:             [
  1876:     80:                 {"text": "4", "callback_data": "maxpos_4"},
  1877:     81:                 {"text": "5", "callback_data": "maxpos_5"},
  1878:     82:             ],
  1879:     83:             [{"text": "Retour", "callback_data": "back"}],
  1880:     84:         ]
  1881:     85: 
  1882:     86:         # Show menu on startup with zero PnL session
  1883:     87:         self.send_main_menu(0.0)
  1884:     88: 
  1885:     89: 
  1886:     90:     def _base_symbol(self, symbol: str) -> str:
  1887:     91:         sym = symbol.replace("_", "")
  1888:     92:         return sym[:-4] if sym.endswith("USDT") else sym
  1889:     93: 
  1890:     94:     def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
  1891:     95:         pos = self.client.get_positions() or {}
  1892:     96:         buttons: list[list[Dict[str, str]]] = []
  1893:     97:         for p in pos.get("data") or []:
  1894:     98:             sym = p.get("symbol")
  1895:     99:             if not sym:
  1896:    100:                 continue
  1897:    101:             base = self._base_symbol(sym)
  1898:    102:             # Use the full symbol in the callback so we can properly
  1899:    103:             # identify the position to close.  Only the label shows the
  1900:    104:             # base asset to keep the interface concise.
  1901:    105:             buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
  1902:    106:         buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
  1903:    107:         buttons.append([{"text": "Retour", "callback_data": "back"}])
  1904:    108:         return buttons
  1905:    109: 
  1906:    110: 
  1907:    111:     def _menu_text(self, session_pnl: float) -> str:
  1908:    112:         assets = self.client.get_assets() or {}
  1909:    113:         equity = 0.0
  1910:    114:         for row in assets.get("data") or []:
  1911:    115:             if row.get("currency") == "USDT":
  1912:    116:                 try:
  1913:    117:                     equity = float(row.get("equity", 0.0))
  1914:    118:                 except Exception:
  1915:    119:                     equity = 0.0
  1916:    120:                 break
  1917:    121:         return (
  1918:    122:             f"Solde: {equity:.2f} USDT\n"
  1919:    123:             f"PnL session: {session_pnl:.2f} USDT\n"
  1920:    124:             f"Positions max: {self.risk_mgr.max_positions}\n"
  1921:    125:             f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
  1922:    126:             "Choisissez une option:"
  1923:    127:         )
  1924:    128: 
  1925:    129:     def send_main_menu(self, session_pnl: float) -> None:
  1926:    130:         self.send(self._menu_text(session_pnl), self.main_keyboard)
  1927:    131: 
  1928:    132:     def update_pairs(self) -> None:
  1929:    133:         from bot import update as _update  # lazy import to avoid cycle
  1930:    134:         _update(self.client, top_n=40)
  1931:    135: 
  1932:    136:     # ------------------------------------------------------------------
  1933:    137:     def _api_url(self, method: str) -> str:
  1934:    138:         return f"https://api.telegram.org/bot{self.token}/{method}"
  1935:    139: 
  1936:    140: 
  1937:    141:     def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
  1938:    142:         payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
  1939:    143:         if keyboard:
  1940:    144:             payload["reply_markup"] = {"inline_keyboard": keyboard}
  1941:    145: 
  1942:    146:         try:  # pragma: no cover - network
  1943:    147:             self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
  1944:    148:         except Exception as exc:  # pragma: no cover - best effort
  1945:    149:             logging.error("Telegram send error: %s", exc)
  1946:    150: 
  1947:    151:     def answer_callback(self, cb_id: str) -> None:
  1948:    152:         payload = {"callback_query_id": cb_id}
  1949:    153:         try:  # pragma: no cover - network
  1950:    154:             self.requests.post(
  1951:    155:                 self._api_url("answerCallbackQuery"), json=payload, timeout=5
  1952:    156:             )
  1953:    157:         except Exception as exc:  # pragma: no cover - best effort
  1954:    158:             logging.error("Telegram answerCallback error: %s", exc)
  1955:    159: 
  1956:    160: 
  1957:    161:     # ------------------------------------------------------------------
  1958:    162:     def fetch_updates(self) -> list[Dict[str, Any]]:
  1959:    163:         params: Dict[str, Any] = {}
  1960:    164:         if self.last_update_id is not None:
  1961:    165:             params["offset"] = self.last_update_id + 1
  1962:    166:         try:  # pragma: no cover - network
  1963:    167:             r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
  1964:    168:             r.raise_for_status()
  1965:    169:             data = r.json()
  1966:    170:         except Exception as exc:  # pragma: no cover - best effort
  1967:    171:             logging.error("Telegram getUpdates error: %s", exc)
  1968:    172:             return []
  1969:    173:         updates = data.get("result", [])
  1970:    174:         if updates:
  1971:    175:             self.last_update_id = updates[-1].get("update_id")
  1972:    176:         return updates
  1973:    177: 
  1974:    178:     # ------------------------------------------------------------------
  1975:    179:     def handle_updates(self, session_pnl: float) -> None:
  1976:    180:         for update in self.fetch_updates():
  1977:    181: 
  1978:    182:             callback = update.get("callback_query")
  1979:    183:             if callback:
  1980:    184:                 if str(callback.get("from", {}).get("id")) != self.chat_id:
  1981:    185:                     continue
  1982:    186:                 data = callback.get("data", "")
  1983:    187:                 reply, kb = self.handle_callback(data, session_pnl)
  1984:    188:                 if reply:
  1985:    189:                     self.send(reply, kb)
  1986:    190:                 cb_id = callback.get("id")
  1987:    191:                 if cb_id:
  1988:    192:                     self.answer_callback(cb_id)
  1989:    193:                 continue
  1990:    194: 
  1991:    195: 
  1992:    196:             msg = update.get("message") or {}
  1993:    197:             chat = msg.get("chat") or {}
  1994:    198:             if str(chat.get("id")) != self.chat_id:
  1995:    199:                 continue
  1996:    200: 
  1997:    201:             # Any text message triggers the main menu with balance and PnL
  1998:    202:             self.send_main_menu(session_pnl)
  1999:    203: 
  2000:    204:     # ------------------------------------------------------------------
  2001:    205:     def handle_callback(
  2002:    206:         self, data: str, session_pnl: float
  2003:    207:     ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
  2004:    208:         if not data:
  2005:    209:             return None, None
  2006:    210:         if data == "balance":
  2007:    211:             assets = self.client.get_assets() or {}
  2008:    212:             equity = 0.0
  2009:    213:             for row in assets.get("data") or []:
  2010:    214:                 if row.get("currency") == "USDT":
  2011:    215:                     try:
  2012:    216:                         equity = float(row.get("equity", 0.0))
  2013:    217:                     except Exception:
  2014:    218:                         equity = 0.0
  2015:    219:                     break
  2016:    220: 
  2017:    221:             return f"Solde: {equity:.2f} USDT", self.main_keyboard
  2018:    222:         if data == "positions":
  2019:    223:             pos = self.client.get_positions() or {}
  2020:    224:             lines = []
  2021:    225:             for p in pos.get("data") or []:
  2022:    226:                 symbol = p.get("symbol", "")
  2023:    227:                 base = self._base_symbol(symbol)
  2024:    228:                 side = p.get("side")
  2025:    229:                 vol = p.get("vol")
  2026:    230:                 pnl = p.get("pnl_usdt")
  2027:    231:                 if pnl is None:
  2028:    232:                     pnl = p.get("pnl_usd")
  2029:    233:                 if pnl is None:
  2030:    234:                     pnl = p.get("pnl")
  2031:    235:                 pnl_pct = p.get("pnl_pct_on_margin")
  2032:    236:                 if pnl_pct is None:
  2033:    237:                     pnl_pct = p.get("pnl_pct")
  2034:    238:                 line = f"{base} {side} {vol}"
  2035:    239:                 if pnl is not None and pnl_pct is not None:
  2036:    240:                     line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
  2037:    241:                 lines.append(line)
  2038:    242:             if not lines:
  2039:    243: 
  2040:    244:                 return "Aucune position ouverte", self.main_keyboard
  2041:    245:             return "Positions:\n" + "\n".join(lines), self.main_keyboard
  2042:    246:         if data == "pnl":
  2043:    247:             return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
  2044:    248:         if data == "risk":
  2045:    249:             return "Choisissez le niveau de risque:", self.risk_keyboard
  2046:    250:         if data == "settings":
  2047:    251:             return "Réglages:", self.settings_keyboard
  2048:    252:         if data == "maxpos":
  2049:    253:             return "Choisissez le nombre de positions:", self.maxpos_keyboard
  2050:    254:         if data == "reset_risk":
  2051:    255:             try:
  2052:    256:                 self.risk_mgr.reset_day()
  2053:    257:                 return "Risque réinitialisé", self.settings_keyboard
  2054:    258:             except Exception:
  2055:    259:                 return "Erreur reset risque", self.settings_keyboard
  2056:    260:         if data == "update":
  2057:    261:             try:
  2058:    262:                 self.update_pairs()
  2059:    263:                 return "Liste cryptos mise à jour", self.main_keyboard
  2060:    264:             except Exception:
  2061:    265:                 return "Erreur mise à jour", self.main_keyboard
  2062:    266:         if data.startswith("risk"):
  2063:    267:             mapping = {
  2064:    268:                 "risk_green": 1,
  2065:    269:                 "risk_orange": 2,
  2066:    270:                 "risk_red": 3,
  2067:    271:             }
  2068:    272:             lvl = mapping.get(data)
  2069:    273:             if lvl:
  2070:    274:                 self.config["RISK_LEVEL"] = lvl
  2071:    275:                 return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
  2072:    276:             return "Niveau de risque inchangé", self.main_keyboard
  2073:    277: 
  2074:    278:         if data.startswith("maxpos_"):
  2075:    279:             try:
  2076:    280:                 lvl = int(data.split("_", 1)[1])
  2077:    281:             except Exception:
  2078:    282:                 lvl = None
  2079:    283:             if lvl:
  2080:    284:                 self.config["MAX_POSITIONS"] = lvl
  2081:    285:                 self.risk_mgr.max_positions = lvl
  2082:    286:                 return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
  2083:    287:             return "Nombre de positions inchangé", self.main_keyboard
  2084:    288: 
  2085:    289:         if data == "reset_all":
  2086:    290:             try:
  2087:    291:                 self.client.close_all_positions()
  2088:    292:                 self.risk_mgr.reset_day()
  2089:    293:                 return "Positions et risque réinitialisés", self.settings_keyboard
  2090:    294:             except Exception:
  2091:    295:                 return "Erreur lors du reset total", self.settings_keyboard
  2092:    296: 
  2093:    297:         if data == "stop":
  2094:    298:             pos = self.client.get_positions() or {}
  2095:    299:             if not (pos.get("data") or []):
  2096:    300:                 return "Aucune crypto sélectionnée", self.settings_keyboard
  2097:    301:             return "Choisissez la position à fermer:", self._build_stop_keyboard()
  2098:    302:         if data == "stop_all":
  2099:    303:             try:
  2100:    304:                 self.client.close_all_positions()
  2101:    305:                 return "Toutes les positions fermées", self.settings_keyboard
  2102:    306:             except Exception:
  2103:    307:                 return "Erreur arrêt trade", self.settings_keyboard
  2104:    308:         if data.startswith("stop_"):
  2105:    309:             sym = data[5:]
  2106:    310:             try:
  2107:    311:                 self.client.close_position(sym)
  2108:    312:                 return f"Position {sym} fermée", self.settings_keyboard
  2109:    313:             except Exception:
  2110:    314:                 return f"Erreur arrêt trade {sym}", self.settings_keyboard
  2111:    315: 
  2112:    316:         if data == "shutdown":
  2113:    317:             self.stop_requested = True
  2114:    318:             return "Arrêt du bot demandé", self.main_keyboard
  2115:    319: 
  2116:    320:         if data == "back":
  2117:    321:             return self._menu_text(session_pnl), self.main_keyboard
  2118:    322:         return None, None
  2119:    323: 
  2120:    324: 
  2121:    325: def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
  2122:    326:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  2123:    327:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  2124:    328:     if token and chat_id:
  2125:    329:         return TelegramBot(token, chat_id, client, config, risk_mgr)
  2126:    330:     return None
  2127: 
  2128: 
  2129: ## TRASH_20250823-124533/short_one_way.py (last modified: 2025-08-23 20:57:14)
  2130:      1: #!/usr/bin/env python3
  2131:      2: # -*- coding: utf-8 -*-
  2132:      3: """Example script to open a one-way short on Bitget futures.
  2133:      4: 
  2134:      5: This standalone script signs and sends a market sell order using the
  2135:      6: Bitget REST API. Environment variables required (defined in a `.env`
  2136:      7: file alongside this script):
  2137:      8: 
  2138:      9: - ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
  2139:     10: - ``BITGET_API_KEY``
  2140:     11: - ``BITGET_API_SECRET``
  2141:     12: - ``BITGET_API_PASSPHRASE``
  2142:     13: - ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
  2143:     14: - ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
  2144:     15: - ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
  2145:     16: - ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)
  2146:     17: 
  2147:     18: The script retrieves the current contract specification and price,
  2148:     19: ensures account settings (one-way mode & leverage) and finally places a
  2149:     20: market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.
  2150:     21: 
  2151:     22: The intent is purely demonstrational; use at your own risk.
  2152:     23: """
  2153:     24: 
  2154:     25: import base64
  2155:     26: import hashlib
  2156:     27: import hmac
  2157:     28: import json
  2158:     29: import os
  2159:     30: import sys
  2160:     31: import time
  2161:     32: import uuid
  2162:     33: from pathlib import Path
  2163:     34: 
  2164:     35: import requests
  2165:     36: 
  2166:     37: try:  # lazy dependency import for dotenv
  2167:     38:     from dotenv import load_dotenv
  2168:     39: except ImportError:  # pragma: no cover - installation fallback
  2169:     40:     import subprocess
  2170:     41: 
  2171:     42:     subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
  2172:     43:     from dotenv import load_dotenv
  2173:     44: 
  2174:     45: # load environment variables
  2175:     46: load_dotenv(Path(__file__).resolve().parent / ".env")
  2176:     47: 
  2177:     48: 
  2178:     49: def T(x):  # small helper used throughout configuration
  2179:     50:     return x.strip() if isinstance(x, str) else x
  2180:     51: 
  2181:     52: 
  2182:     53: BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
  2183:     54: AK = T(os.getenv("BITGET_API_KEY"))
  2184:     55: SK = T(os.getenv("BITGET_API_SECRET"))
  2185:     56: PH = T(os.getenv("BITGET_API_PASSPHRASE"))
  2186:     57: PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
  2187:     58: MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
  2188:     59: SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
  2189:     60: NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))
  2190:     61: 
  2191:     62: if not (AK and SK and PH):
  2192:     63:     sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")
  2193:     64: 
  2194:     65: print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")
  2195:     66: 
  2196:     67: 
  2197:     68: # ---------- signing helpers ----------
  2198:     69: def sign_get(ts, path, params):
  2199:     70:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  2200:     71:     pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
  2201:     72:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  2202:     73:     return sig, qs
  2203:     74: 
  2204:     75: 
  2205:     76: def sign_post(ts, path, body, params=None):
  2206:     77:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  2207:     78:     body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
  2208:     79:     pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
  2209:     80:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  2210:     81:     return sig, body_str, qs
  2211:     82: 
  2212:     83: 
  2213:     84: def headers(sig, ts):
  2214:     85:     return {
  2215:     86:         "ACCESS-KEY": AK,
  2216:     87:         "ACCESS-SIGN": sig,
  2217:     88:         "ACCESS-TIMESTAMP": str(ts),
  2218:     89:         "ACCESS-PASSPHRASE": PH,
  2219:     90:         "ACCESS-RECV-WINDOW": "60000",
  2220:     91:         "Content-Type": "application/json",
  2221:     92:     }
  2222:     93: 
  2223:     94: 
  2224:     95: def pick_price(d: dict):
  2225:     96:     for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
  2226:     97:         try:
  2227:     98:             v = float(d.get(k))
  2228:     99:             if v > 0:
  2229:    100:                 return v
  2230:    101:         except Exception:
  2231:    102:             pass
  2232:    103:     return None
  2233:    104: 
  2234:    105: 
  2235:    106: # ---------- public endpoints ----------
  2236:    107: def get_contract_spec():
  2237:    108:     r = requests.get(
  2238:    109:         f"{BASE}/api/v2/mix/market/contracts",
  2239:    110:         params={"productType": PT, "symbol": SYMB},
  2240:    111:         timeout=12,
  2241:    112:     )
  2242:    113:     r.raise_for_status()
  2243:    114:     arr = r.json().get("data") or []
  2244:    115:     if not arr:
  2245:    116:         raise RuntimeError("Contrat introuvable")
  2246:    117:     return arr[0]
  2247:    118: 
  2248:    119: 
  2249:    120: def get_price():
  2250:    121:     # 1) ticker (obj/list) avec productType
  2251:    122:     try:
  2252:    123:         r = requests.get(
  2253:    124:             f"{BASE}/api/v2/mix/market/ticker",
  2254:    125:             params={"symbol": SYMB, "productType": PT},
  2255:    126:             timeout=10,
  2256:    127:         )
  2257:    128:         r.raise_for_status()
  2258:    129:         data = r.json().get("data")
  2259:    130:         if isinstance(data, dict):
  2260:    131:             p = pick_price(data)
  2261:    132:             if p:
  2262:    133:                 return p
  2263:    134:         if isinstance(data, list) and data:
  2264:    135:             p = pick_price(data[0])
  2265:    136:             if p:
  2266:    137:                 return p
  2267:    138:     except requests.HTTPError as e:
  2268:    139:         print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
  2269:    140:     except Exception as e:
  2270:    141:         print("⚠️ ticker err:", e)
  2271:    142: 
  2272:    143:     # 2) tickers (liste entière)
  2273:    144:     try:
  2274:    145:         r = requests.get(
  2275:    146:             f"{BASE}/api/v2/mix/market/tickers",
  2276:    147:             params={"productType": PT},
  2277:    148:             timeout=10,
  2278:    149:         )
  2279:    150:         r.raise_for_status()
  2280:    151:         arr = r.json().get("data") or []
  2281:    152:         row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
  2282:    153:         p = pick_price(row or {})
  2283:    154:         if p:
  2284:    155:             return p
  2285:    156:     except requests.HTTPError as e:
  2286:    157:         print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
  2287:    158:     except Exception as e:
  2288:    159:         print("⚠️ tickers err:", e)
  2289:    160: 
  2290:    161:     # 3) candles 1m (close)
  2291:    162:     try:
  2292:    163:         # ``symbol`` must be provided as a query parameter; placing it in the
  2293:    164:         # path triggers a 404 response from Bitget.
  2294:    165:         r = requests.get(
  2295:    166:             f"{BASE}/api/v2/mix/market/candles",
  2296:    167:             params={"symbol": SYMB, "granularity": "1m"},
  2297:    168:             timeout=10,
  2298:    169:         )
  2299:    170:         r.raise_for_status()
  2300:    171:         arr = r.json().get("data") or []
  2301:    172:         if arr:
  2302:    173:             return float(arr[0][4])
  2303:    174:     except requests.HTTPError as e:
  2304:    175:         print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
  2305:    176:     except Exception as e:
  2306:    177:         print("⚠️ candles err:", e)
  2307:    178: 
  2308:    179:     raise RuntimeError("prix indisponible")
  2309:    180: 
  2310:    181: 
  2311:    182: # ---------- private endpoints ----------
  2312:    183: def check_accounts():
  2313:    184:     path = "/api/v2/mix/account/accounts"
  2314:    185:     ts = int(time.time() * 1000)
  2315:    186:     params = {"productType": PT}
  2316:    187:     sig, qs = sign_get(ts, path, params)
  2317:    188:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2318:    189:     r = requests.get(url, headers=headers(sig, ts), timeout=12)
  2319:    190:     print("accounts", r.status_code, r.text[:160])
  2320:    191:     r.raise_for_status()
  2321:    192:     j = r.json()
  2322:    193:     if str(j.get("code")) not in ("00000", "0"):
  2323:    194:         raise RuntimeError(j)
  2324:    195: 
  2325:    196: 
  2326:    197: def set_position_mode_one_way():
  2327:    198:     path = "/api/v2/mix/account/set-position-mode"
  2328:    199:     ts = int(time.time() * 1000)
  2329:    200:     body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
  2330:    201:     sig, b, qs = sign_post(ts, path, body)
  2331:    202:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2332:    203:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  2333:    204:     print("set-position-mode(one-way)", r.status_code, r.text[:160])
  2334:    205:     r.raise_for_status()
  2335:    206: 
  2336:    207: 
  2337:    208: def set_leverage(lv: int = 2):
  2338:    209:     path = "/api/v2/mix/account/set-leverage"
  2339:    210:     ts = int(time.time() * 1000)
  2340:    211:     body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
  2341:    212:     sig, b, qs = sign_post(ts, path, body)
  2342:    213:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2343:    214:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  2344:    215:     print("set-leverage", r.status_code, r.text[:160])
  2345:    216:     r.raise_for_status()
  2346:    217: 
  2347:    218: 
  2348:    219: def place_one_way_sell(size_coin: float):
  2349:    220:     """Ouvre un SHORT en one_way_mode (market SELL)."""
  2350:    221:     path = "/api/v2/mix/order/place-order"
  2351:    222:     ts = int(time.time() * 1000)
  2352:    223:     body = {
  2353:    224:         "symbol": SYMB,
  2354:    225:         "productType": PT,
  2355:    226:         "marginCoin": MC,
  2356:    227:         "marginMode": "crossed",
  2357:    228:         "posMode": "one_way_mode",
  2358:    229:         "orderType": "market",
  2359:    230:         "side": "sell",  # <-- SHORT
  2360:    231:         "size": str(size_coin),
  2361:    232:         "timeInForceValue": "normal",
  2362:    233:         "clientOid": str(uuid.uuid4())[:32],
  2363:    234:     }
  2364:    235:     sig, b, qs = sign_post(ts, path, body)
  2365:    236:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2366:    237:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
  2367:    238:     print("place-order(one-way SELL)", r.status_code, r.text[:220])
  2368:    239:     r.raise_for_status()
  2369:    240:     j = r.json()
  2370:    241:     if str(j.get("code")) not in ("00000", "0"):
  2371:    242:         raise RuntimeError(j)
  2372:    243:     return j
  2373:    244: 
  2374:    245: 
  2375:    246: # ---------- main ----------
  2376:    247: def main():
  2377:    248:     spec = get_contract_spec()
  2378:    249:     min_usdt = float(spec.get("minTradeUSDT") or 5)
  2379:    250:     min_num = float(spec.get("minTradeNum") or 0)
  2380:    251:     size_place = int(spec.get("sizePlace") or 6)
  2381:    252:     print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")
  2382:    253: 
  2383:    254:     px = get_price()
  2384:    255:     print(f"Prix OK ≈ {px}")
  2385:    256: 
  2386:    257:     check_accounts()
  2387:    258:     set_position_mode_one_way()
  2388:    259:     set_leverage(2)
  2389:    260: 
  2390:    261:     target = max(NOTIONAL, min_usdt)
  2391:    262:     size = max(target / px, min_num)
  2392:    263:     size = float(f"{size:.{size_place}f}")
  2393:    264:     print(f"Taille={size} (target≈{target}USDT)")
  2394:    265: 
  2395:    266:     j = place_one_way_sell(size)
  2396:    267:     print("✅ SHORT OK")
  2397:    268:     print(json.dumps(j, indent=2, ensure_ascii=False))
  2398:    269: 
  2399:    270: 
  2400:    271: if __name__ == "__main__":  # pragma: no cover - script entrypoint
  2401:    272:     main()
  2402: 
  2403: 
  2404: ## bot.py (last modified: 2025-08-24 03:12:00)
  2405:      1: # bot.py
  2406:      2: from __future__ import annotations
  2407:      3: 
  2408:      4: import asyncio
  2409:      5: import os
  2410:      6: import sys
  2411:      7: import json
  2412:      8: from dataclasses import dataclass
  2413:      9: from pathlib import Path
  2414:     10: from typing import Sequence, Optional
  2415:     11: 
  2416:     12: # --- utils ---
  2417:     13: 
  2418:     14: def ensure_ccxt() -> None:
  2419:     15:     try:
  2420:     16:         import ccxt  # noqa: F401
  2421:     17:     except ImportError:
  2422:     18:         import subprocess
  2423:     19:         print("[setup] ccxt manquant, installation…")
  2424:     20:         subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "ccxt"])
  2425:     21:         import ccxt  # noqa: F401
  2426:     22: 
  2427:     23: def getenv(name: str, default: str = "") -> str:
  2428:     24:     """Lit d’abord les variables d’environnement, sinon .env local s’il existe."""
  2429:     25:     val = os.environ.get(name)
  2430:     26:     if val is not None:
  2431:     27:         return val
  2432:     28:     dot = Path(".env")
  2433:     29:     if dot.exists():
  2434:     30:         for line in dot.read_text().splitlines():
  2435:     31:             line = line.strip()
  2436:     32:             if not line or line.startswith("#") or "=" not in line:
  2437:     33:                 continue
  2438:     34:             k, v = line.split("=", 1)
  2439:     35:             if k == name:
  2440:     36:                 return v
  2441:     37:     return default
  2442:     38: 
  2443:     39: # --- config ---
  2444:     40: 
  2445:     41: @dataclass
  2446:     42: class RunConfig:
  2447:     43:     symbols: Sequence[str]
  2448:     44:     live_tf: str
  2449:     45:     data_dir: Path
  2450:     46:     csv_min_rows: int = 200           # seuil minimal d’un CSV “ok”
  2451:     47:     ready_flag: Path = Path("scalp/.ready.json")
  2452:     48: 
  2453:     49: # --- notifier (Telegram ou Null) ---
  2454:     50: 
  2455:     51: class NullNotifier:
  2456:     52:     async def send(self, msg: str) -> None:
  2457:     53:         print(f"[notify:null] {msg}")
  2458:     54: 
  2459:     55: async def build_notifier_and_commands() -> tuple[object, object]:
  2460:     56:     """Retourne (notifier, command_stream). Ici soit Telegram, soit Null."""
  2461:     57:     bot_token = getenv("TELEGRAM_BOT_TOKEN")
  2462:     58:     chat_id   = getenv("TELEGRAM_CHAT_ID")
  2463:     59:     if bot_token and chat_id:
  2464:     60:         # Implémentation simple via httpx/aiohttp → pour garder le fichier autonome, on renvoie un proxy minimal.
  2465:     61:         class TelegramNotifier:
  2466:     62:             def __init__(self, token: str, chat: str):
  2467:     63:                 self.token = token
  2468:     64:                 self.chat  = chat
  2469:     65:             async def send(self, msg: str) -> None:
  2470:     66:                 # en mode simple: on n’échoue pas si Telegram refuse le markdown
  2471:     67:                 import aiohttp
  2472:     68:                 url = f"https://api.telegram.org/bot{self.token}/sendMessage"
  2473:     69:                 payload = {"chat_id": self.chat, "text": msg, "disable_web_page_preview": True, "parse_mode": "Markdown"}
  2474:     70:                 try:
  2475:     71:                     async with aiohttp.ClientSession() as sess:
  2476:     72:                         async with sess.post(url, json=payload, timeout=15) as r:
  2477:     73:                             if r.status >= 400:
  2478:     74:                                 txt = await r.text()
  2479:     75:                                 print(f"[notify:telegram] send fail {r.status}: {txt[:180]}")
  2480:     76:                 except Exception as e:
  2481:     77:                     print(f"[notify:telegram] send error: {e}")
  2482:     78: 
  2483:     79:         notifier = TelegramNotifier(bot_token, chat_id)
  2484:     80:         # Pas de commandes interactives dans cette version : on renvoie un stream “nul”
  2485:     81:         return notifier, None
  2486:     82:     else:
  2487:     83:         print("[notify] TELEGRAM non configuré → Null notifier.")
  2488:     84:         return NullNotifier(), None
  2489:     85: 
  2490:     86: # --- préchauffage cache CSV ---
  2491:     87: 
  2492:     88: def csv_ok(p: Path, min_rows: int) -> bool:
  2493:     89:     if not p.exists():
  2494:     90:         return False
  2495:     91:     try:
  2496:     92:         # compte rapide des lignes
  2497:     93:         n = sum(1 for _ in p.open("r", encoding="utf-8", errors="ignore"))
  2498:     94:         return n >= min_rows
  2499:     95:     except Exception:
  2500:     96:         return False
  2501:     97: 
  2502:     98: async def prewarm_cache(cfg: RunConfig) -> None:
  2503:     99:     cfg.data_dir.mkdir(parents=True, exist_ok=True)
  2504:    100:     ok = True
  2505:    101:     for sym in cfg.symbols:
  2506:    102:         csv = cfg.data_dir / f"{sym}-{cfg.live_tf}.csv"
  2507:    103:         if csv_ok(csv, cfg.csv_min_rows):
  2508:    104:             print(f"[cache] ready -> {csv.relative_to(Path.cwd())}")
  2509:    105:         else:
  2510:    106:             ok = False
  2511:    107:             print(f"[cache] MISSING for {sym} -> {csv.relative_to(Path.cwd())}")
  2512:    108:     # ici on ne fetch pas pour rester autonome ; tu as déjà so.py si besoin
  2513:    109: 
  2514:    110: # --- orchestrateur glue ---
  2515:    111: 
  2516:    112: # ⛔️ ADAPTE CE CHEMIN SI TON WRAPPER N’EST PAS ICI
  2517:    113: # ex: from scalper.services.market import BitgetExchange
  2518:    114: from scalper.exchanges.bitget import BitgetExchange  # <-- ajuste ce chemin si besoin
  2519:    115: 
  2520:    116: async def run_orchestrator(exchange, cfg: RunConfig, notifier, command_stream=None):
  2521:    117:     """
  2522:    118:     Adapte-toi à la signature de ton vrai orchestrateur si tu en utilises un.
  2523:    119:     Ici on illustre une boucle “heartbeat + ticks_total” minimale.
  2524:    120:     """
  2525:    121:     ticks_total = 0
  2526:    122:     await notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  2527:    123:     try:
  2528:    124:         while True:
  2529:    125:             await asyncio.sleep(30)
  2530:    126:             await notifier.send(f"[stats] ticks_total={ticks_total} (+0 /30s) | pairs={','.join(cfg.symbols)}")
  2531:    127:     except asyncio.CancelledError:
  2532:    128:         await notifier.send("🛑 Arrêt orchestrateur.")
  2533:    129:         raise
  2534:    130: 
  2535:    131: # --- setup + ready flag ---
  2536:    132: 
  2537:    133: def write_ready_flag(cfg: RunConfig, reason: str = "ok") -> None:
  2538:    134:     cfg.ready_flag.parent.mkdir(parents=True, exist_ok=True)
  2539:    135:     cfg.ready_flag.write_text(json.dumps({"status": "ok", "reason": reason}, ensure_ascii=False, indent=2))
  2540:    136: 
  2541:    137: def is_ready(cfg: RunConfig) -> bool:
  2542:    138:     return cfg.ready_flag.exists()
  2543:    139: 
  2544:    140: async def setup_once(cfg: RunConfig, notifier) -> None:
  2545:    141:     await prewarm_cache(cfg)
  2546:    142:     await notifier.send("Setup wizard terminé (cache vérifié).")
  2547:    143:     write_ready_flag(cfg, "cache verified")
  2548:    144: 
  2549:    145: # --- lance l’orchestrateur avec shim .symbols/.timeframe ---
  2550:    146: 
  2551:    147: async def launch_orchestrator(cfg: RunConfig):
  2552:    148:     notifier, command_stream = await build_notifier_and_commands()
  2553:    149: 
  2554:    150:     # Setup si nécessaire
  2555:    151:     if not is_ready(cfg):
  2556:    152:         await notifier.send("Setup requis → exécution…")
  2557:    153:         await setup_once(cfg, notifier)
  2558:    154:         await notifier.send(f"[setup] flag écrit -> {cfg.ready_flag}")
  2559:    155: 
  2560:    156:     # Crée l’exchange
  2561:    157:     ex = BitgetExchange(
  2562:    158:         api_key=getenv("BITGET_ACCESS"),
  2563:    159:         secret=getenv("BITGET_SECRET"),
  2564:    160:         password=getenv("BITGET_PASSPHRASE"),
  2565:    161:         data_dir=str(cfg.data_dir),
  2566:    162:         use_cache=True,
  2567:    163:         spot=True,
  2568:    164:     )
  2569:    165: 
  2570:    166:     # --- SHIM IMPORTANT : certains orchestrateurs lisent exchange.symbols / exchange.timeframe
  2571:    167:     if not hasattr(ex, "symbols"):
  2572:    168:         setattr(ex, "symbols", tuple(cfg.symbols))
  2573:    169:     if not hasattr(ex, "timeframe"):
  2574:    170:         setattr(ex, "timeframe", cfg.live_tf)
  2575:    171: 
  2576:    172:     # Démarre l’orchestrateur (remplace par ton vrai import/runner si tu en as un)
  2577:    173:     await run_orchestrator(ex, cfg, notifier, command_stream)
  2578:    174: 
  2579:    175: # --- main ---
  2580:    176: 
  2581:    177: async def main():
  2582:    178:     ensure_ccxt()
  2583:    179:     symbols = (
  2584:    180:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  2585:    181:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  2586:    182:     )
  2587:    183:     cfg = RunConfig(
  2588:    184:         symbols=symbols,
  2589:    185:         live_tf="5m",
  2590:    186:         data_dir=Path("scalp/data"),
  2591:    187:     )
  2592:    188:     await launch_orchestrator(cfg)
  2593:    189: 
  2594:    190: if __name__ == "__main__":
  2595:    191:     try:
  2596:    192:         asyncio.run(main())
  2597:    193:     except KeyboardInterrupt:
  2598:    194:         pass
  2599: 
  2600: ## cli.py (last modified: 2025-08-23 20:57:14)
  2601:      1: """Command line utilities for the Scalp project.
  2602:      2: 
  2603:      3: This module exposes a small command line interface used throughout the
  2604:      4: project.  The actual trading logic lives in other modules, however the CLI is
  2605:      5: responsible for parsing parameters and dispatching the appropriate routines.
  2606:      6: 
  2607:      7: The implementation intentionally keeps the invoked functions minimal so that
  2608:      8: tests can patch them easily.  In a real deployment these functions would
  2609:      9: perform optimisation, walk‑forward analysis or run the live pipeline.
  2610:     10: """
  2611:     11: 
  2612:     12: from __future__ import annotations
  2613:     13: 
  2614:     14: import argparse
  2615:     15: import asyncio
  2616:     16: from typing import Iterable, List
  2617:     17: 
  2618:     18: from scalper.version import bump_version_from_git
  2619:     19: 
  2620:     20: 
  2621:     21: # ---------------------------------------------------------------------------
  2622:     22: # Placeholder implementations
  2623:     23: # ---------------------------------------------------------------------------
  2624:     24: 
  2625:     25: 
  2626:     26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
  2627:     27:     """Run a parallel parameter optimisation.
  2628:     28: 
  2629:     29:     The real project dispatches a potentially heavy optimisation routine.  The
  2630:     30:     function is kept trivial so unit tests can verify that the CLI wiring works
  2631:     31:     without actually performing the optimisation.
  2632:     32:     """
  2633:     33: 
  2634:     34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
  2635:     35: 
  2636:     36: 
  2637:     37: def run_walkforward_analysis(
  2638:     38:     pair: str, timeframe: str, splits: int, train_ratio: float
  2639:     39: ) -> None:
  2640:     40:     """Execute a walk-forward analysis."""
  2641:     41: 
  2642:     42:     print(
  2643:     43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
  2644:     44:     )
  2645:     45: 
  2646:     46: 
  2647:     47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
  2648:     48:     """Run the live trading pipeline."""
  2649:     49: 
  2650:     50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
  2651:     51: 
  2652:     52: 
  2653:     53: # ---------------------------------------------------------------------------
  2654:     54: # Argument parsing
  2655:     55: # ---------------------------------------------------------------------------
  2656:     56: 
  2657:     57: 
  2658:     58: def create_parser() -> argparse.ArgumentParser:
  2659:     59:     """Create the top-level argument parser."""
  2660:     60: 
  2661:     61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
  2662:     62:     sub = parser.add_subparsers(dest="command")
  2663:     63: 
  2664:     64:     # --- ``opt`` command -------------------------------------------------
  2665:     65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
  2666:     66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  2667:     67:     opt_p.add_argument("--tf", required=True, help="timeframe")
  2668:     68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
  2669:     69:     opt_p.set_defaults(
  2670:     70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
  2671:     71:     )
  2672:     72: 
  2673:     73:     # --- ``walkforward`` command ----------------------------------------
  2674:     74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
  2675:     75:     wf_p.add_argument("--pair", required=True, help="trading pair")
  2676:     76:     wf_p.add_argument("--tf", required=True, help="timeframe")
  2677:     77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
  2678:     78:     wf_p.add_argument(
  2679:     79:         "--train-ratio",
  2680:     80:         type=float,
  2681:     81:         default=0.7,
  2682:     82:         help="portion of data used for training",
  2683:     83:     )
  2684:     84:     wf_p.set_defaults(
  2685:     85:         func=lambda a: run_walkforward_analysis(
  2686:     86:             a.pair, a.tf, a.splits, a.train_ratio
  2687:     87:         )
  2688:     88:     )
  2689:     89: 
  2690:     90:     # --- ``live`` command -----------------------------------------------
  2691:     91:     live_p = sub.add_parser("live", help="run the live async pipeline")
  2692:     92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  2693:     93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
  2694:     94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
  2695:     95: 
  2696:     96:     # --- ``bump-version`` command -------------------------------------
  2697:     97:     bv_p = sub.add_parser(
  2698:     98:         "bump-version",
  2699:     99:         help="update the VERSION file based on the latest git commit",
  2700:    100:     )
  2701:    101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
  2702:    102: 
  2703:    103:     return parser
  2704:    104: 
  2705:    105: 
  2706:    106: def main(argv: Iterable[str] | None = None) -> int:
  2707:    107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
  2708:    108: 
  2709:    109:     parser = create_parser()
  2710:    110:     args = parser.parse_args(argv)
  2711:    111:     if not hasattr(args, "func"):
  2712:    112:         parser.print_help()
  2713:    113:         return 0
  2714:    114:     result = args.func(args)
  2715:    115:     return 0 if result is None else int(result)
  2716:    116: 
  2717:    117: 
  2718:    118: if __name__ == "__main__":  # pragma: no cover - manual invocation
  2719:    119:     raise SystemExit(main())
  2720:    120: 
  2721: 
  2722: 
  2723: ## data/BTCUSDT-1m.csv (last modified: 2025-08-23 20:57:14)
  2724:      1: ts,open,high,low,close,volume
  2725:      2: 1625097600000,34000,34100,33950,34050,123.4
  2726:      3: 1625097660000,34050,34200,34000,34150,150.7
  2727:      4: 1625097720000,34150,34300,34100,34250,180.3
  2728:      5: 1625097780000,34250,34400,34200,34350,200.1
  2729:      6: 1625097840000,34350,34500,34300,34450,220.8
  2730: 
  2731: ## data/__init__.py (last modified: 2025-08-23 20:57:14)
  2732:      1: """Indicator computation helpers."""
  2733:      2: 
  2734:      3: from .indicators import compute_all
  2735:      4: 
  2736:      5: __all__ = ["compute_all"]
  2737: 
  2738: 
  2739: ## data/indicators.py (last modified: 2025-08-23 20:57:14)
  2740:      1: import pandas as pd
  2741:      2: 
  2742:      3: __all__ = ["compute_all"]
  2743:      4: 
  2744:      5: def compute_all(
  2745:      6:     df: pd.DataFrame,
  2746:      7:     *,
  2747:      8:     ema_fast: int = 20,
  2748:      9:     ema_slow: int = 50,
  2749:     10:     rsi_period: int = 14,
  2750:     11:     macd_fast: int = 12,
  2751:     12:     macd_slow: int = 26,
  2752:     13:     macd_signal: int = 9,
  2753:     14:     atr_period: int = 14,
  2754:     15:     swing_lookback: int = 5,
  2755:     16: ) -> pd.DataFrame:
  2756:     17:     """Compute common indicators and return enriched DataFrame.
  2757:     18: 
  2758:     19:     Parameters
  2759:     20:     ----------
  2760:     21:     df : pd.DataFrame
  2761:     22:         DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
  2762:     23:         ``volume`` columns ordered chronologically.
  2763:     24: 
  2764:     25:     Returns
  2765:     26:     -------
  2766:     27:     pd.DataFrame
  2767:     28:         New DataFrame with additional indicator columns.
  2768:     29:     """
  2769:     30: 
  2770:     31:     if df.empty:
  2771:     32:         return df.copy()
  2772:     33: 
  2773:     34:     df = df.copy()
  2774:     35: 
  2775:     36:     # --- VWAP ---------------------------------------------------------------
  2776:     37:     typical = (df["high"] + df["low"] + df["close"]) / 3.0
  2777:     38:     vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
  2778:     39:     df["vwap"] = vwap
  2779:     40: 
  2780:     41:     # --- EMAs ---------------------------------------------------------------
  2781:     42:     df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
  2782:     43:     df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()
  2783:     44: 
  2784:     45:     # --- RSI ----------------------------------------------------------------
  2785:     46:     delta = df["close"].diff()
  2786:     47:     gain = delta.where(delta > 0, 0.0)
  2787:     48:     loss = -delta.where(delta < 0, 0.0)
  2788:     49:     avg_gain = gain.rolling(rsi_period).mean()
  2789:     50:     avg_loss = loss.rolling(rsi_period).mean()
  2790:     51:     rs = avg_gain / avg_loss
  2791:     52:     rsi = 100 - (100 / (1 + rs))
  2792:     53:     df["rsi"] = rsi.fillna(50.0)
  2793:     54: 
  2794:     55:     # --- MACD ---------------------------------------------------------------
  2795:     56:     ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
  2796:     57:     ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
  2797:     58:     macd = ema_fast_series - ema_slow_series
  2798:     59:     signal = macd.ewm(span=macd_signal, adjust=False).mean()
  2799:     60:     df["macd"] = macd
  2800:     61:     df["macd_signal"] = signal
  2801:     62:     df["macd_hist"] = macd - signal
  2802:     63: 
  2803:     64:     # --- OBV ----------------------------------------------------------------
  2804:     65:     obv = [0.0]
  2805:     66:     closes = df["close"].tolist()
  2806:     67:     vols = df["volume"].tolist()
  2807:     68:     for i in range(1, len(df)):
  2808:     69:         if closes[i] > closes[i - 1]:
  2809:     70:             obv.append(obv[-1] + vols[i])
  2810:     71:         elif closes[i] < closes[i - 1]:
  2811:     72:             obv.append(obv[-1] - vols[i])
  2812:     73:         else:
  2813:     74:             obv.append(obv[-1])
  2814:     75:     df["obv"] = obv
  2815:     76: 
  2816:     77:     # --- ATR ----------------------------------------------------------------
  2817:     78:     high_low = df["high"] - df["low"]
  2818:     79:     high_close = (df["high"] - df["close"].shift()).abs()
  2819:     80:     low_close = (df["low"] - df["close"].shift()).abs()
  2820:     81:     tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
  2821:     82:     df["atr"] = tr.rolling(atr_period).mean()
  2822:     83: 
  2823:     84:     # --- Swing highs/lows ---------------------------------------------------
  2824:     85:     df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
  2825:     86:     df["swing_low"] = df["low"].rolling(window=swing_lookback).min()
  2826:     87: 
  2827:     88:     return df
  2828: 
  2829: 
  2830: ## init.py (last modified: 2025-08-23 20:57:14)
  2831:      1: #!/usr/bin/env python3
  2832:      2: """Install all project dependencies.
  2833:      3: 
  2834:      4: Run this script once to install every ``requirements*.txt`` file found in the
  2835:      5: repository as well as the packages needed for the test suite.  All subsequent
  2836:      6: invocations of the bot or its submodules will then share the same Python
  2837:      7: environment with the required dependencies available.
  2838:      8: """
  2839:      9: 
  2840:     10: from __future__ import annotations
  2841:     11: 
  2842:     12: import subprocess
  2843:     13: import sys
  2844:     14: from pathlib import Path
  2845:     15: 
  2846:     16: 
  2847:     17: def install_packages(*args: str) -> None:
  2848:     18:     """Install packages using pip for the current Python interpreter."""
  2849:     19:     cmd = [sys.executable, "-m", "pip", "install", *args]
  2850:     20:     subprocess.check_call(cmd)
  2851:     21: 
  2852:     22: 
  2853:     23: def main() -> None:
  2854:     24:     repo_root = Path(__file__).resolve().parent
  2855:     25: 
  2856:     26:     # Install from any requirements*.txt file across the repository so that
  2857:     27:     # sub-packages with their own dependency lists are also covered.
  2858:     28:     for req in sorted(repo_root.rglob("requirements*.txt")):
  2859:     29:         install_packages("-r", str(req))
  2860:     30: 
  2861:     31:     # Ensure test dependencies are available
  2862:     32:     install_packages("pytest")
  2863:     33: 
  2864:     34: 
  2865:     35: if __name__ == "__main__":
  2866:     36:     main()
  2867: 
  2868: 
  2869: ## pytest.ini (last modified: 2025-08-23 20:57:14)
  2870:      1: [pytest]
  2871:      2: addopts = -q
  2872: 
  2873: 
  2874: ## requirements-dev.txt (last modified: 2025-08-23 20:57:14)
  2875:      1: pytest
  2876: 
  2877: 
  2878: ## requirements.txt (last modified: 2025-08-23 20:57:14)
  2879:      1: requests
  2880:      2: python-dotenv
  2881:      3: pydantic==1.10.15 ; python_version < "3.11"
  2882:      4: 
  2883:      5: # pydantic v1 déjà pin si environnement ancien
  2884:      6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)
  2885: 
  2886: 
  2887: ## scalper/VERSION (last modified: 2025-08-23 20:57:14)
  2888:      1: 0.3.0
  2889:      2: 
  2890: 
  2891: 
  2892: ## scalper/__init__.py (last modified: 2025-08-23 20:57:14)
  2893:      1: """Utilities and helpers for Scalp bot.
  2894:      2: 
  2895:      3: When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
  2896:      4: keys to live in ``notebook/.env``.  On import this module attempts to load the
  2897:      5: variables from that file so that API keys can remain outside of the repository
  2898:      6: yet still be available at runtime.
  2899:      7: """
  2900:      8: 
  2901:      9: from __future__ import annotations
  2902:     10: 
  2903:     11: import os
  2904:     12: from pathlib import Path
  2905:     13: import sys
  2906:     14: 
  2907:     15: 
  2908:     16: def _load_parent_env() -> None:
  2909:     17:     """Load environment variables from ``../.env`` relative to the entry script.
  2910:     18: 
  2911:     19:     The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
  2912:     20:     are expected to be stored one directory above (``notebook/.env``).  If that
  2913:     21:     file is not found the function falls back to the historical behaviour of
  2914:     22:     checking ``../.env`` relative to the package itself.
  2915:     23:     """
  2916:     24: 
  2917:     25:     script_path = Path(sys.argv[0]).resolve()
  2918:     26:     env_file = script_path.parent.parent / ".env"
  2919:     27:     if not env_file.exists():
  2920:     28:         env_file = Path(__file__).resolve().parents[2] / ".env"
  2921:     29:         if not env_file.exists():
  2922:     30:             return
  2923:     31: 
  2924:     32:     try:
  2925:     33:         from dotenv import load_dotenv
  2926:     34: 
  2927:     35:         load_dotenv(env_file)
  2928:     36:     except Exception:  # pragma: no cover - optional dependency
  2929:     37:         for line in env_file.read_text().splitlines():
  2930:     38:             line = line.strip()
  2931:     39:             if not line or line.startswith("#") or "=" not in line:
  2932:     40:                 continue
  2933:     41:             key, value = line.split("=", 1)
  2934:     42:             os.environ.setdefault(key.strip(), value.strip().strip("'\""))
  2935:     43: 
  2936:     44: 
  2937:     45: _load_parent_env()
  2938:     46: 
  2939:     47: from .version import get_version, bump_version_from_message  # noqa: E402
  2940:     48: from .strategy import (  # noqa: E402
  2941:     49:     Signal,
  2942:     50:     scan_pairs,
  2943:     51:     select_active_pairs,
  2944:     52:     generate_signal,
  2945:     53:     backtest,
  2946:     54: )
  2947:     55: from .risk.manager import RiskManager  # noqa: E402
  2948:     56: 
  2949:     57: __all__ = [
  2950:     58:     "get_version",
  2951:     59:     "bump_version_from_message",
  2952:     60:     "__version__",
  2953:     61:     "Signal",
  2954:     62:     "scan_pairs",
  2955:     63:     "select_active_pairs",
  2956:     64:     "generate_signal",
  2957:     65:     "RiskManager",
  2958:     66:     "backtest",
  2959:     67: ]
  2960:     68: 
  2961:     69: __version__ = get_version()
  2962: 
  2963: 
  2964: ## scalper/adapters/__init__.py (last modified: 2025-08-23 20:57:14)
  2965: 
  2966: 
  2967: ## scalper/adapters/bitget.py (last modified: 2025-08-23 20:57:14)
  2968:      1: # scalp/adapters/bitget.py
  2969:      2: from __future__ import annotations
  2970:      3: from typing import Any, Dict, List, Optional
  2971:      4: import inspect, os
  2972:      5: import requests
  2973:      6: 
  2974:      7: # Client bas-niveau fourni par le repo
  2975:      8: from scalper.bitget_client import BitgetFuturesClient as _Base
  2976:      9: 
  2977:     10: 
  2978:     11: def _to_float(x, default: float = 0.0) -> float:
  2979:     12:     try:
  2980:     13:         return float(x)
  2981:     14:     except Exception:
  2982:     15:         return default
  2983:     16: 
  2984:     17: 
  2985:     18: def _select_base_url() -> str:
  2986:     19:     env = os.environ.get("BITGET_BASE_URL")
  2987:     20:     if env:
  2988:     21:         return env
  2989:     22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
  2990:     23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
  2991:     24: 
  2992:     25: 
  2993:     26: class BitgetFuturesClient(_Base):
  2994:     27:     """
  2995:     28:     Adaptateur Bitget:
  2996:     29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
  2997:     30:       - Normalisations robustes: assets, ticker(s), positions, fills
  2998:     31:     """
  2999:     32: 
  3000:     33:     # --------------------- INIT dynamique ---------------------
  3001:     34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
  3002:     35:         """
  3003:     36:         Accepte indifféremment:
  3004:     37:           api_key/apiKey/access_key/accessKey/key
  3005:     38:           api_secret/apiSecret/secret/secret_key/secretKey
  3006:     39:           passphrase/password/api_passphrase/apiPassphrase
  3007:     40:           base_url/baseUrl/host/endpoint (ou auto)
  3008:     41:         On n'envoie au client de base que les noms présents dans sa signature.
  3009:     42:         """
  3010:     43:         user_kwargs = dict(kwargs)
  3011:     44: 
  3012:     45:         # Collecte des valeurs possibles (tous alias)
  3013:     46:         incoming_key = (
  3014:     47:             user_kwargs.pop("api_key", None)
  3015:     48:             or user_kwargs.pop("apiKey", None)
  3016:     49:             or user_kwargs.pop("access_key", None)
  3017:     50:             or user_kwargs.pop("accessKey", None)
  3018:     51:             or user_kwargs.pop("key", None)
  3019:     52:             or user_kwargs.pop("API_KEY", None)
  3020:     53:         )
  3021:     54:         incoming_secret = (
  3022:     55:             user_kwargs.pop("api_secret", None)
  3023:     56:             or user_kwargs.pop("apiSecret", None)
  3024:     57:             or user_kwargs.pop("secret_key", None)
  3025:     58:             or user_kwargs.pop("secretKey", None)
  3026:     59:             or user_kwargs.pop("secret", None)
  3027:     60:             or user_kwargs.pop("API_SECRET", None)
  3028:     61:         )
  3029:     62:         incoming_pass = (
  3030:     63:             user_kwargs.pop("passphrase", None)
  3031:     64:             or user_kwargs.pop("password", None)
  3032:     65:             or user_kwargs.pop("api_passphrase", None)
  3033:     66:             or user_kwargs.pop("apiPassphrase", None)
  3034:     67:         )
  3035:     68:         incoming_base = (
  3036:     69:             user_kwargs.pop("base_url", None)
  3037:     70:             or user_kwargs.pop("baseUrl", None)
  3038:     71:             or user_kwargs.pop("host", None)
  3039:     72:             or user_kwargs.pop("endpoint", None)
  3040:     73:             or _select_base_url()
  3041:     74:         )
  3042:     75: 
  3043:     76:         # Signature réelle du client bas-niveau
  3044:     77:         sig = inspect.signature(_Base.__init__)
  3045:     78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
  3046:     79: 
  3047:     80:         def pick_name(cands: List[str]) -> Optional[str]:
  3048:     81:             for c in cands:
  3049:     82:                 if c in param_names:
  3050:     83:                     return c
  3051:     84:             return None
  3052:     85: 
  3053:     86:         # Noms réellement supportés
  3054:     87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
  3055:     88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
  3056:     89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
  3057:     90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
  3058:     91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
  3059:     92: 
  3060:     93:         # Construire kwargs à transmettre (une seule fois par nom)
  3061:     94:         base_kwargs: Dict[str, Any] = {}
  3062:     95:         if key_name and incoming_key is not None:
  3063:     96:             base_kwargs[key_name] = incoming_key
  3064:     97:         if sec_name and incoming_secret is not None:
  3065:     98:             base_kwargs[sec_name] = incoming_secret
  3066:     99:         if pas_name and incoming_pass is not None:
  3067:    100:             base_kwargs[pas_name] = incoming_pass
  3068:    101:         if base_name:
  3069:    102:             base_kwargs[base_name] = incoming_base
  3070:    103:         if req_mod_name:
  3071:    104:             base_kwargs[req_mod_name] = requests
  3072:    105: 
  3073:    106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
  3074:    107:         # qui n'a pas été défini ci-dessus, on le relaie.
  3075:    108:         for k, v in list(user_kwargs.items()):
  3076:    109:             if k in param_names and k not in base_kwargs:
  3077:    110:                 base_kwargs[k] = v
  3078:    111: 
  3079:    112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
  3080:    113:         super().__init__(**base_kwargs)
  3081:    114: 
  3082:    115:     # --------------------- COMPTES / ASSETS ---------------------
  3083:    116:     def get_assets(self) -> Dict[str, Any]:
  3084:    117:         raw = super().get_assets()
  3085:    118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
  3086:    119:         norm: List[Dict[str, Any]] = []
  3087:    120:         for a in data:
  3088:    121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
  3089:    122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
  3090:    123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
  3091:    124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
  3092:    125:         return {"success": True, "data": norm}
  3093:    126: 
  3094:    127:     # ------------------------ TICKER(S) -------------------------
  3095:    128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  3096:    129:         """
  3097:    130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
  3098:    131:         Tolère top-level dict/list et items dict/list.
  3099:    132:         """
  3100:    133:         try:
  3101:    134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
  3102:    135:         except Exception as e:
  3103:    136:             return {"success": False, "error": repr(e), "data": []}
  3104:    137: 
  3105:    138:         items: List[Any] = []
  3106:    139:         if isinstance(raw, dict):
  3107:    140:             d = raw.get("data")
  3108:    141:             if symbol and isinstance(d, dict):
  3109:    142:                 items = [d]
  3110:    143:             else:
  3111:    144:                 items = d or raw.get("result") or raw.get("tickers") or []
  3112:    145:         elif isinstance(raw, (list, tuple)):
  3113:    146:             items = list(raw)
  3114:    147: 
  3115:    148:         norm: List[Dict[str, Any]] = []
  3116:    149:         for t in items:
  3117:    150:             if isinstance(t, dict):
  3118:    151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
  3119:    152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
  3120:    153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
  3121:    154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
  3122:    155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
  3123:    156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
  3124:    157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
  3125:    158:                 norm.append({
  3126:    159:                     "symbol": s,
  3127:    160:                     "lastPrice": _to_float(last_),
  3128:    161:                     "bidPrice": _to_float(bid_),
  3129:    162:                     "askPrice": _to_float(ask_),
  3130:    163:                     "volume": volume
  3131:    164:                 })
  3132:    165:             else:
  3133:    166:                 seq = list(t)
  3134:    167:                 if len(seq) >= 5:
  3135:    168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
  3136:    169:                     if first_ts:
  3137:    170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
  3138:    171:                     else:
  3139:    172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
  3140:    173:                 else:
  3141:    174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
  3142:    175:                 s = (symbol or "").replace("_", "")
  3143:    176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
  3144:    177: 
  3145:    178:         return {"success": True, "data": norm}
  3146:    179: 
  3147:    180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
  3148:    181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  3149:    182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
  3150:    183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
  3151:    184:         out: List[Dict[str, Any]] = []
  3152:    185:         for p in items:
  3153:    186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
  3154:    187:             if symbol and s != symbol:
  3155:    188:                 continue
  3156:    189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
  3157:    190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
  3158:    191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
  3159:    192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
  3160:    193:         return {"success": True, "data": out}
  3161:    194: 
  3162:    195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
  3163:    196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
  3164:    197:         items = raw.get("data") or raw.get("result") or []
  3165:    198:         out: List[Dict[str, Any]] = []
  3166:    199:         for f in items[:limit]:
  3167:    200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
  3168:    201:             if s != symbol:
  3169:    202:                 continue
  3170:    203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
  3171:    204:                 continue
  3172:    205:             out.append({
  3173:    206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
  3174:    207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
  3175:    208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
  3176:    209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
  3177:    210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
  3178:    211:                 "ts": int(f.get("ts", f.get("time", 0))),
  3179:    212:             })
  3180:    213:         return {"success": True, "data": out}
  3181:    214: 
  3182:    215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
  3183:    216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
  3184:    217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
  3185:    218:         return {"success": ok, "data": {"orderId": order_id}}
  3186: 
  3187: ## scalper/adapters/bitget_fetch.py (last modified: 2025-08-23 20:57:14)
  3188:      1: # scalper/adapters/bitget_fetch.py
  3189:      2: from __future__ import annotations
  3190:      3: 
  3191:      4: import asyncio
  3192:      5: import inspect
  3193:      6: import os
  3194:      7: from typing import Any, Optional
  3195:      8: 
  3196:      9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  3197:     10: 
  3198:     11: def _log(msg: str) -> None:
  3199:     12:     if BT_DEBUG:
  3200:     13:         print(f"[bt.debug] {msg}", flush=True)
  3201:     14: 
  3202:     15: _TF_TO_SECS = {
  3203:     16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  3204:     17:     "1h": 3600, "4h": 14400, "1d": 86400,
  3205:     18: }
  3206:     19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
  3207:     20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  3208:     21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
  3209:     22: }
  3210:     23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
  3211:     24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  3212:     25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
  3213:     26: }
  3214:     27: 
  3215:     28: def _await_if_needed(val: Any) -> Any:
  3216:     29:     if inspect.isawaitable(val):
  3217:     30:         try:
  3218:     31:             asyncio.get_running_loop()
  3219:     32:         except RuntimeError:
  3220:     33:             return asyncio.run(val)
  3221:     34:         else:
  3222:     35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
  3223:     36:             return fut.result()
  3224:     37:     return val
  3225:     38: 
  3226:     39: class BitgetFetchAdapter:
  3227:     40:     """
  3228:     41:     Adaptateur qui fournit une méthode CCXT-like:
  3229:     42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
  3230:     43:     au-dessus d'un client Bitget existant (sync ou async).
  3231:     44:     """
  3232:     45:     def __init__(self, client: Any, *, market_hint: str | None = None):
  3233:     46:         self.client = client
  3234:     47:         self.market_hint = (market_hint or "").lower() or None
  3235:     48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
  3236:     49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
  3237:     50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
  3238:     51: 
  3239:     52:     @staticmethod
  3240:     53:     def _possible_methods(client: Any) -> list[str]:
  3241:     54:         names = dir(client)
  3242:     55:         base = [
  3243:     56:             "fetch_ohlcv",
  3244:     57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
  3245:     58:             "klines", "get_klines", "kline",
  3246:     59:             "mix_get_candles", "mix_candles",
  3247:     60:             "spot_get_candles", "spot_candles",
  3248:     61:             "market_candles", "public_candles",
  3249:     62:         ]
  3250:     63:         # + heuristique: tout ce qui contient candle/kline
  3251:     64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
  3252:     65:         out = []
  3253:     66:         for n in base + extra:
  3254:     67:             if n in names and callable(getattr(client, n)) and n not in out:
  3255:     68:                 out.append(n)
  3256:     69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
  3257:     70:         return out
  3258:     71: 
  3259:     72:     @staticmethod
  3260:     73:     def _sym_variants(sym: str) -> list[str]:
  3261:     74:         s = sym.upper()
  3262:     75:         out = [s]
  3263:     76:         if not s.endswith("_UMCBL"):
  3264:     77:             out.append(f"{s}_UMCBL")
  3265:     78:         if not s.endswith("_SPBL"):
  3266:     79:             out.append(f"{s}_SPBL")
  3267:     80:         _log(f"Variantes symbole testées: {out}")
  3268:     81:         return out
  3269:     82: 
  3270:     83:     @staticmethod
  3271:     84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
  3272:     85:         secs = _TF_TO_SECS.get(timeframe, 300)
  3273:     86:         mix = _TF_TO_MIX.get(timeframe, "5min")
  3274:     87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
  3275:     88:         variants = []
  3276:     89:         if market_hint == "mix":
  3277:     90:             variants.append({"granularity": mix})
  3278:     91:         if market_hint == "spot":
  3279:     92:             variants.append({"period": spot})
  3280:     93:         variants += [
  3281:     94:             {"timeframe": timeframe},
  3282:     95:             {"interval": timeframe},
  3283:     96:             {"k": secs},
  3284:     97:             {"granularity": mix},
  3285:     98:             {"period": spot},
  3286:     99:         ]
  3287:    100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
  3288:    101:         return variants
  3289:    102: 
  3290:    103:     @staticmethod
  3291:    104:     def _normalize_rows(raw: Any) -> list[list[float]]:
  3292:    105:         import pandas as pd  # local import
  3293:    106:         if raw is None:
  3294:    107:             raise ValueError("OHLCV vide")
  3295:    108:         if isinstance(raw, dict) and "data" in raw:
  3296:    109:             raw = raw["data"]
  3297:    110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
  3298:    111:             out = []
  3299:    112:             for r in raw:
  3300:    113:                 ts = int(str(r[0]))
  3301:    114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
  3302:    115:                 out.append([ts, o, h, l, c, v])
  3303:    116:             return out
  3304:    117:         if "pandas" in str(type(raw)):
  3305:    118:             df = raw
  3306:    119:             if "timestamp" in df.columns:
  3307:    120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  3308:    121:                 df = df.set_index("timestamp").sort_index()
  3309:    122:             df = df[["open", "high", "low", "close", "volume"]]
  3310:    123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
  3311:    124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
  3312:    125: 
  3313:    126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
  3314:    127:         methods = self._possible_methods(self.client)
  3315:    128:         if not methods:
  3316:    129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
  3317:    130: 
  3318:    131:         last_err: Exception | None = None
  3319:    132:         for mname in methods:
  3320:    133:             fn = getattr(self.client, mname)
  3321:    134:             for sym in self._sym_variants(symbol):
  3322:    135:                 for par in self._param_variants(timeframe, self.market_hint):
  3323:    136:                     kwargs = dict(par)
  3324:    137:                     kwargs.setdefault("symbol", sym)
  3325:    138:                     kwargs.setdefault("limit", limit)
  3326:    139:                     if since is not None:
  3327:    140:                         kwargs.setdefault("since", since)
  3328:    141:                     try:
  3329:    142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
  3330:    143:                         res = _await_if_needed(fn(**kwargs))
  3331:    144:                         rows = self._normalize_rows(res)
  3332:    145:                         if rows:
  3333:    146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
  3334:    147:                             first = rows[0][0]; last = rows[-1][0]
  3335:    148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
  3336:    149:                                  f"t0={first} {unit}, t1={last} {unit}")
  3337:    150:                             return rows
  3338:    151:                     except TypeError as e:
  3339:    152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
  3340:    153:                         last_err = e
  3341:    154:                     except Exception as e:
  3342:    155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
  3343:    156:                         last_err = e
  3344:    157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
  3345:    158: 
  3346:    159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
  3347:    160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
  3348:    161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
  3349:    162:         _log("exchange.fetch_ohlcv() déjà présent.")
  3350:    163:         return exchange
  3351:    164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
  3352:    165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)
  3353: 
  3354: ## scalper/adapters/market_data.py (last modified: 2025-08-23 20:57:14)
  3355:      1: # scalper/backtest/market_data.py
  3356:      2: from __future__ import annotations
  3357:      3: 
  3358:      4: import os
  3359:      5: from pathlib import Path
  3360:      6: from typing import Any
  3361:      7: 
  3362:      8: import pandas as pd
  3363:      9: 
  3364:     10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  3365:     11: 
  3366:     12: def _log(msg: str) -> None:
  3367:     13:     if BT_DEBUG:
  3368:     14:         print(f"[bt.debug] {msg}", flush=True)
  3369:     15: 
  3370:     16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
  3371:     17:     root = Path(data_dir)
  3372:     18:     root.mkdir(parents=True, exist_ok=True)
  3373:     19:     tf = timeframe.replace(":", "")
  3374:     20:     return root / f"{symbol}-{tf}.csv"
  3375:     21: 
  3376:     22: def _read_csv(path: Path) -> pd.DataFrame:
  3377:     23:     _log(f"lecture CSV: {path}")
  3378:     24:     df = pd.read_csv(path)
  3379:     25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
  3380:     26:     if ts_col is None:
  3381:     27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
  3382:     28:     df = df.rename(columns={ts_col: "timestamp"})
  3383:     29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  3384:     30:     df = df.set_index("timestamp").sort_index()
  3385:     31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  3386:     32:     return df
  3387:     33: 
  3388:     34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  3389:     35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
  3390:     36:     if "timestamp" not in tmp.columns:
  3391:     37:         tmp = tmp.rename(columns={"index": "timestamp"})
  3392:     38:     tmp.to_csv(path, index=False)
  3393:     39:     _log(f"écrit CSV: {path} (n={len(df)})")
  3394:     40: 
  3395:     41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  3396:     42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
  3397:     43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
  3398:     44:     # Normalisation minimaliste (liste de listes)
  3399:     45:     rows = []
  3400:     46:     for r in raw:
  3401:     47:         ts = int(r[0])
  3402:     48:         unit = "ms" if ts > 10_000_000_000 else "s"
  3403:     49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
  3404:     50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
  3405:     51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
  3406:     52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  3407:     53:     return df
  3408:     54: 
  3409:     55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
  3410:     56:     """
  3411:     57:     Loader hybride:
  3412:     58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
  3413:     59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
  3414:     60:     """
  3415:     61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  3416:     62:         path = _csv_path(data_dir, symbol, timeframe)
  3417:     63:         if path.exists():
  3418:     64:             df = _read_csv(path)
  3419:     65:             src = "csv"
  3420:     66:         else:
  3421:     67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
  3422:     68:             _write_csv(path, df)
  3423:     69:             src = "exchange"
  3424:     70:         if start:
  3425:     71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  3426:     72:         if end:
  3427:     73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  3428:     74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
  3429:     75:              f"range=[{df.index.min()} .. {df.index.max()}]")
  3430:     76:         return df
  3431:     77:     return load
  3432: 
  3433: ## scalper/backtest/__init__.py (last modified: 2025-08-23 20:57:14)
  3434:      1: # scalper/backtest/__init__.py
  3435:      2: from .runner import (
  3436:      3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
  3437:      4:     run_multi, run_single,  # mêmes signatures async
  3438:      5:     save_results,           # no-op compat
  3439:      6: )
  3440:      7: from .cache import (
  3441:      8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
  3442:      9:     tf_to_seconds,
  3443:     10: )
  3444: 
  3445: ## scalper/backtest/cache.py (last modified: 2025-08-23 20:57:14)
  3446:      1: # scalper/backtest/cache.py
  3447:      2: from __future__ import annotations
  3448:      3: 
  3449:      4: import csv
  3450:      5: import json
  3451:      6: import os
  3452:      7: import time
  3453:      8: from dataclasses import dataclass
  3454:      9: from pathlib import Path
  3455:     10: from typing import Dict, List, Tuple, Iterable, Optional
  3456:     11: 
  3457:     12: # ---------------- Timeframe utils ----------------
  3458:     13: 
  3459:     14: _TF_SECONDS = {
  3460:     15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  3461:     16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
  3462:     17:     "1d": 86400, "3d": 259200, "1w": 604800,
  3463:     18: }
  3464:     19: 
  3465:     20: def tf_to_seconds(tf: str) -> int:
  3466:     21:     tf = tf.strip().lower()
  3467:     22:     if tf not in _TF_SECONDS:
  3468:     23:         raise ValueError(f"Timeframe inconnu: {tf}")
  3469:     24:     return _TF_SECONDS[tf]
  3470:     25: 
  3471:     26: # ---------------- Fraîcheur cible par TF ----------------
  3472:     27: 
  3473:     28: _DEFAULT_MAX_AGE = {
  3474:     29:     # règle empirique (peut être surchargée par ENV)
  3475:     30:     "1m": 2 * 3600,        # 2h
  3476:     31:     "3m": 4 * 3600,        # 4h
  3477:     32:     "5m": 12 * 3600,       # 12h
  3478:     33:     "15m": 24 * 3600,      # 24h
  3479:     34:     "30m": 36 * 3600,      # 36h
  3480:     35:     "1h": 3 * 86400,       # 3 jours
  3481:     36:     "2h": 5 * 86400,       # 5 jours
  3482:     37:     "4h": 10 * 86400,      # 10 jours
  3483:     38:     "6h": 15 * 86400,      # 15 jours
  3484:     39:     "12h": 20 * 86400,     # 20 jours
  3485:     40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
  3486:     41:     "3d": 10 * 86400,
  3487:     42:     "1w": 30 * 86400,
  3488:     43: }
  3489:     44: 
  3490:     45: def max_age_for_tf(tf: str) -> int:
  3491:     46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
  3492:     47:     tf = tf.lower()
  3493:     48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
  3494:     49:     if env_key in os.environ:
  3495:     50:         try:
  3496:     51:             return int(os.environ[env_key])
  3497:     52:         except Exception:
  3498:     53:             pass
  3499:     54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
  3500:     55: 
  3501:     56: # ---------------- CSV I/O ----------------
  3502:     57: 
  3503:     58: def data_dir() -> Path:
  3504:     59:     d = Path(os.getenv("DATA_DIR", "data"))
  3505:     60:     d.mkdir(parents=True, exist_ok=True)
  3506:     61:     return d
  3507:     62: 
  3508:     63: def csv_path(symbol: str, tf: str) -> Path:
  3509:     64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
  3510:     65: 
  3511:     66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
  3512:     67:     out: List[List[float]] = []
  3513:     68:     if not path.exists():
  3514:     69:         return out
  3515:     70:     with path.open("r", newline="") as f:
  3516:     71:         r = csv.reader(f)
  3517:     72:         header = next(r, None)
  3518:     73:         for row in r:
  3519:     74:             # columns: timestamp,open,high,low,close,volume
  3520:     75:             try:
  3521:     76:                 ts, o, h, l, c, v = row[:6]
  3522:     77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
  3523:     78:             except Exception:
  3524:     79:                 continue
  3525:     80:     return out
  3526:     81: 
  3527:     82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
  3528:     83:     new_file = not path.exists()
  3529:     84:     with path.open("w", newline="") as f:
  3530:     85:         w = csv.writer(f)
  3531:     86:         w.writerow(["timestamp","open","high","low","close","volume"])
  3532:     87:         for r in rows:
  3533:     88:             w.writerow(r)
  3534:     89: 
  3535:     90: # ---------------- Validation / Chargement / Fetch ----------------
  3536:     91: 
  3537:     92: @dataclass
  3538:     93: class CacheInfo:
  3539:     94:     symbol: str
  3540:     95:     tf: str
  3541:     96:     path: Path
  3542:     97:     exists: bool
  3543:     98:     fresh: bool
  3544:     99:     last_ts: Optional[int] = None
  3545:    100:     rows: int = 0
  3546:    101: 
  3547:    102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
  3548:    103:     if not last_ts:
  3549:    104:         return False
  3550:    105:     age = int(time.time()) - int(last_ts / 1000)
  3551:    106:     return age <= max_age_for_tf(tf)
  3552:    107: 
  3553:    108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
  3554:    109:     p = csv_path(symbol, tf)
  3555:    110:     if not p.exists():
  3556:    111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
  3557:    112:     rows = read_csv_ohlcv(p)
  3558:    113:     last_ts = rows[-1][0] if rows else None
  3559:    114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
  3560:    115: 
  3561:    116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
  3562:    117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
  3563:    118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
  3564:    119: 
  3565:    120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
  3566:    121:     info = inspect_csv(symbol, tf)
  3567:    122:     if info.exists and info.fresh:
  3568:    123:         data = read_csv_ohlcv(info.path)
  3569:    124:         return info, data
  3570:    125: 
  3571:    126:     # fetch & persist
  3572:    127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
  3573:    128:     if data:
  3574:    129:         write_csv_ohlcv(info.path, data)
  3575:    130:         info = inspect_csv(symbol, tf)  # refresh stats
  3576:    131:     return info, data
  3577:    132: 
  3578:    133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
  3579:    134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
  3580:    135:     out: Dict[str, List[List[float]]] = {}
  3581:    136:     for s in symbols:
  3582:    137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
  3583:    138:         out[s] = rows
  3584:    139:     return out
  3585:    140: 
  3586:    141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
  3587:    142:     report = []
  3588:    143:     for s in symbols:
  3589:    144:         info = inspect_csv(s, tf)
  3590:    145:         report.append({
  3591:    146:             "symbol": s,
  3592:    147:             "tf": tf,
  3593:    148:             "path": str(info.path),
  3594:    149:             "exists": info.exists,
  3595:    150:             "fresh": info.fresh,
  3596:    151:             "last_ts": info.last_ts,
  3597:    152:             "rows": info.rows,
  3598:    153:             "max_age": max_age_for_tf(tf),
  3599:    154:         })
  3600:    155:     out_path.parent.mkdir(parents=True, exist_ok=True)
  3601:    156:     out_path.write_text(json.dumps(report, indent=2))
  3602: 
  3603: ## scalper/backtest/cli.py (last modified: 2025-08-23 20:57:14)
  3604:      1: from __future__ import annotations
  3605:      2: 
  3606:      3: import argparse
  3607:      4: from scalper.backtest.runner import run_multi, csv_loader_factory
  3608:      5: 
  3609:      6: def create_parser() -> argparse.ArgumentParser:
  3610:      7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
  3611:      8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
  3612:      9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
  3613:     10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
  3614:     11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
  3615:     12:     p.add_argument("--cash", type=float, default=10_000.0)
  3616:     13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
  3617:     14:     p.add_argument("--slippage-bps", type=float, default=1.5)
  3618:     15:     return p
  3619:     16: 
  3620:     17: def main(argv: list[str] | None = None) -> int:
  3621:     18:     p = create_parser()
  3622:     19:     a = p.parse_args(argv)
  3623:     20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
  3624:     21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
  3625:     22:     loader = csv_loader_factory(a.data_dir)
  3626:     23:     run_multi(
  3627:     24:         symbols=symbols,
  3628:     25:         timeframes=tfs,
  3629:     26:         loader=loader,
  3630:     27:         out_dir=a.out_dir,
  3631:     28:         initial_cash=a.cash,
  3632:     29:         risk_pct=a.risk,
  3633:     30:         slippage_bps=a.slippage_bps,
  3634:     31:     )
  3635:     32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
  3636:     33:     return 0
  3637:     34: 
  3638:     35: if __name__ == "__main__":
  3639:     36:     raise SystemExit(main())
  3640: 
  3641: ## scalper/backtest/engine.py (last modified: 2025-08-23 20:57:14)
  3642:      1: # scalper/backtest/engine.py
  3643:      2: from __future__ import annotations
  3644:      3: 
  3645:      4: import math
  3646:      5: from dataclasses import dataclass, asdict
  3647:      6: from typing import Callable, Dict, List, Optional, Tuple
  3648:      7: 
  3649:      8: import pandas as pd
  3650:      9: 
  3651:     10: from scalper.strategy import generate_signal
  3652:     11: from scalper.trade_utils import compute_position_size
  3653:     12: from scalper.exchange.fees import get_fee
  3654:     13: 
  3655:     14: OHLCVLoader = Callable[[str, str, Optional[str], Optional[str]], pd.DataFrame]
  3656:     15: 
  3657:     16: 
  3658:     17: @dataclass
  3659:     18: class Fill:
  3660:     19:     ts: pd.Timestamp
  3661:     20:     symbol: str
  3662:     21:     side: str       # "long" | "short" | "flat"
  3663:     22:     price: float
  3664:     23:     qty: float
  3665:     24:     fee: float
  3666:     25:     reason: str     # "entry"|"tp"|"sl"|"exit"|"reverse"|"final_exit"
  3667:     26: 
  3668:     27: 
  3669:     28: @dataclass
  3670:     29: class Trade:
  3671:     30:     symbol: str
  3672:     31:     side: str
  3673:     32:     entry_ts: pd.Timestamp
  3674:     33:     entry_px: float
  3675:     34:     qty: float
  3676:     35:     exit_ts: pd.Timestamp
  3677:     36:     exit_px: float
  3678:     37:     fee_entry: float
  3679:     38:     fee_exit: float
  3680:     39:     pnl: float
  3681:     40:     pnl_pct: float
  3682:     41: 
  3683:     42: 
  3684:     43: @dataclass
  3685:     44: class EquityPoint:
  3686:     45:     ts: pd.Timestamp
  3687:     46:     equity: float
  3688:     47: 
  3689:     48: 
  3690:     49: def _apply_slippage(price: float, side: str, slippage_bps: float) -> float:
  3691:     50:     if slippage_bps <= 0:
  3692:     51:         return price
  3693:     52:     mult = 1.0 + (slippage_bps / 10_000.0)
  3694:     53:     return price * (mult if side in ("buy", "long") else 1.0 / mult)
  3695:     54: 
  3696:     55: 
  3697:     56: def _hit_tp_sl(row: pd.Series, side: str, tp: float, sl: float) -> Tuple[bool, str, float]:
  3698:     57:     high, low, close = float(row.high), float(row.low), float(row.close)
  3699:     58:     if side == "long":
  3700:     59:         if low <= sl <= high:
  3701:     60:             return True, "sl", sl
  3702:     61:         if low <= tp <= high:
  3703:     62:             return True, "tp", tp
  3704:     63:         return False, "", close
  3705:     64:     else:
  3706:     65:         if low <= tp <= high:
  3707:     66:             return True, "tp", tp
  3708:     67:         if low <= sl <= high:
  3709:     68:             return True, "sl", sl
  3710:     69:         return False, "", close
  3711:     70: 
  3712:     71: 
  3713:     72: def run_single(
  3714:     73:     *,
  3715:     74:     symbol: str,
  3716:     75:     timeframe: str,
  3717:     76:     loader: OHLCVLoader,
  3718:     77:     start: str | None = None,
  3719:     78:     end: str | None = None,
  3720:     79:     initial_cash: float = 10_000.0,
  3721:     80:     risk_pct: float = 0.005,
  3722:     81:     slippage_bps: float = 1.5,
  3723:     82:     taker: bool = True,
  3724:     83:     quiet: bool = True,
  3725:     84: ) -> Dict[str, object]:
  3726:     85:     df = loader(symbol, timeframe, start, end).copy()
  3727:     86:     if df.empty:
  3728:     87:         raise ValueError(f"Pas de données pour {symbol} {timeframe}")
  3729:     88:     df.columns = [c.lower() for c in df.columns]
  3730:     89:     for c in ("open", "high", "low", "close", "volume"):
  3731:     90:         if c not in df.columns:
  3732:     91:             raise ValueError(f"OHLCV invalide: colonne {c} manquante")
  3733:     92: 
  3734:     93:     fee_rate = get_fee(symbol, "taker" if taker else "maker")
  3735:     94: 
  3736:     95:     equity = float(initial_cash)
  3737:     96:     pos_side: str = "flat"
  3738:     97:     pos_qty: float = 0.0
  3739:     98:     entry_px: float = 0.0
  3740:     99:     fee_entry: float = 0.0
  3741:    100:     sl: float = math.nan
  3742:    101:     tp: float = math.nan
  3743:    102: 
  3744:    103:     eq: List[EquityPoint] = []
  3745:    104:     fills: List[Fill] = []
  3746:    105:     closed: List[Trade] = []
  3747:    106: 
  3748:    107:     for ts, row in df.iterrows():
  3749:    108:         ts = pd.Timestamp(ts)
  3750:    109: 
  3751:    110:         # gérer SL/TP quand en position
  3752:    111:         if pos_side in ("long", "short"):
  3753:    112:             hit, reason, exec_px = _hit_tp_sl(row, pos_side, tp, sl)
  3754:    113:             if hit:
  3755:    114:                 px = _apply_slippage(exec_px, "sell" if pos_side == "long" else "buy", slippage_bps)
  3756:    115:                 fee = abs(px * pos_qty) * fee_rate
  3757:    116:                 pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  3758:    117:                 equity += pnl - fee
  3759:    118:                 fills.append(Fill(ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, reason))
  3760:    119:                 closed.append(
  3761:    120:                     Trade(
  3762:    121:                         symbol=symbol, side=pos_side, entry_ts=ts, entry_px=entry_px, qty=pos_qty,
  3763:    122:                         exit_ts=ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  3764:    123:                         pnl=pnl - fee_entry - fee,
  3765:    124:                         pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  3766:    125:                     )
  3767:    126:                 )
  3768:    127:                 pos_side, pos_qty, entry_px, sl, tp, fee_entry = "flat", 0.0, 0.0, math.nan, math.nan, 0.0
  3769:    128: 
  3770:    129:         # signal de la stratégie live
  3771:    130:         sig = generate_signal(
  3772:    131:             symbol=symbol,
  3773:    132:             ohlcv=df.loc[:ts].tail(300),
  3774:    133:             equity=equity,
  3775:    134:             risk_pct=risk_pct,
  3776:    135:         )
  3777:    136:         if sig and getattr(sig, "side", None) and pos_side == "flat":
  3778:    137:             side = sig.side  # "long"|"short"
  3779:    138:             px = _apply_slippage(float(sig.price), "buy" if side == "long" else "sell", slippage_bps)
  3780:    139:             qty = float(getattr(sig, "qty", 0.0)) or compute_position_size(equity, px, risk_pct, symbol=symbol)
  3781:    140:             if qty > 0:
  3782:    141:                 fee = abs(px * qty) * fee_rate
  3783:    142:                 pos_side, pos_qty, entry_px = side, qty, px
  3784:    143:                 sl = float(getattr(sig, "sl", px * (0.995 if side == "long" else 1.005)))
  3785:    144:                 tp = float(getattr(sig, "tp", getattr(sig, "tp1", px * (1.005 if side == "long" else 0.995))))
  3786:    145:                 fee_entry = fee
  3787:    146:                 equity -= fee
  3788:    147:                 fills.append(Fill(ts, symbol, side, px, qty if side == "long" else -qty, fee, "entry"))
  3789:    148: 
  3790:    149:         eq.append(EquityPoint(ts, equity))
  3791:    150: 
  3792:    151:     # sortie forcée fin de série
  3793:    152:     if pos_side in ("long", "short"):
  3794:    153:         last_ts = pd.Timestamp(df.index[-1])
  3795:    154:         px = _apply_slippage(float(df["close"].iloc[-1]), "sell" if pos_side == "long" else "buy", slippage_bps)
  3796:    155:         fee = abs(px * pos_qty) * fee_rate
  3797:    156:         pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  3798:    157:         equity += pnl - fee
  3799:    158:         fills.append(Fill(last_ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, "final_exit"))
  3800:    159:         closed.append(
  3801:    160:             Trade(
  3802:    161:                 symbol=symbol, side=pos_side, entry_ts=last_ts, entry_px=entry_px, qty=pos_qty,
  3803:    162:                 exit_ts=last_ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  3804:    163:                 pnl=pnl - fee_entry - fee, pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  3805:    164:             )
  3806:    165:         )
  3807:    166: 
  3808:    167:     eq_df = pd.DataFrame([asdict(e) for e in eq])
  3809:    168:     tr_df = pd.DataFrame([asdict(t) for t in closed])
  3810:    169:     fills_df = pd.DataFrame([asdict(f) for f in fills])
  3811:    170: 
  3812:    171:     metrics = {
  3813:    172:         "symbol": symbol,
  3814:    173:         "timeframe": timeframe,
  3815:    174:         "initial_cash": initial_cash,
  3816:    175:         "final_equity": float(eq_df["equity"].iloc[-1] if not eq_df.empty else initial_cash),
  3817:    176:         "return_pct": float(((eq_df["equity"].iloc[-1] / initial_cash) - 1.0) * 100.0 if initial_cash and not eq_df.empty else 0.0),
  3818:    177:         "n_trades": int(len(tr_df)),
  3819:    178:         "win_rate_pct": float((tr_df["pnl"] > 0).mean() * 100.0) if not tr_df.empty else 0.0,
  3820:    179:         "avg_trade_pnl": float(tr_df["pnl"].mean()) if not tr_df.empty else 0.0,
  3821:    180:         "max_dd_pct": float(((eq_df["equity"].cummax() - eq_df["equity"]) / eq_df["equity"].cummax()).max() * 100.0) if not eq_df.empty else 0.0,
  3822:    181:     }
  3823:    182: 
  3824:    183:     return {"equity_curve": eq_df, "trades": tr_df, "fills": fills_df, "metrics": metrics}
  3825: 
  3826: ## scalper/backtest/grid_search.py (last modified: 2025-08-23 20:57:14)
  3827:      1: """Grid-search express module to evaluate hyperparameter combinations.
  3828:      2: 
  3829:      3: This module builds combinations of strategy and engine parameters, runs the
  3830:      4: existing multi symbol backtester for each combination, collects key metrics and
  3831:      5: selects the best configuration according to:
  3832:      6: 
  3833:      7: 1. Profit factor (descending)
  3834:      8: 2. Maximum drawdown percentage (ascending)
  3835:      9: 3. Net PnL in USDT (descending)
  3836:     10: 4. Number of trades (ascending)
  3837:     11: 
  3838:     12: Results are written under ``result/grid`` by default and a short summary is
  3839:     13: printed to the console.
  3840:     14: """
  3841:     15: from __future__ import annotations
  3842:     16: 
  3843:     17: from dataclasses import dataclass
  3844:     18: import csv
  3845:     19: import json
  3846:     20: import os
  3847:     21: import random
  3848:     22: from itertools import product
  3849:     23: from typing import Any, Callable, Dict, Iterable, List, Sequence
  3850:     24: 
  3851:     25: # ---------------------------------------------------------------------------
  3852:     26: # Utilities
  3853:     27: # ---------------------------------------------------------------------------
  3854:     28: 
  3855:     29: 
  3856:     30: def parse_hours(hours: str) -> List[int]:
  3857:     31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
  3858:     32: 
  3859:     33:     Each comma separated element can either be a single hour (``"8"``) or a
  3860:     34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
  3861:     35:     """
  3862:     36: 
  3863:     37:     if not hours:
  3864:     38:         return []
  3865:     39:     result: List[int] = []
  3866:     40:     for part in hours.split(","):
  3867:     41:         part = part.strip()
  3868:     42:         if not part:
  3869:     43:             continue
  3870:     44:         if "-" in part:
  3871:     45:             start_s, end_s = part.split("-", 1)
  3872:     46:             start, end = int(start_s), int(end_s)
  3873:     47:             result.extend(range(start, end + 1))
  3874:     48:         else:
  3875:     49:             result.append(int(part))
  3876:     50:     return sorted(set(result))
  3877:     51: 
  3878:     52: 
  3879:     53: # Order of parameters used throughout the module and in CSV output
  3880:     54: PARAM_KEYS = [
  3881:     55:     "timeframe",
  3882:     56:     "score_min",
  3883:     57:     "atr_min_ratio",
  3884:     58:     "rr_min",
  3885:     59:     "risk_pct",
  3886:     60:     "slippage_bps",
  3887:     61:     "fee_rate",
  3888:     62:     "cooldown_secs",
  3889:     63:     "hours",
  3890:     64: ]
  3891:     65: 
  3892:     66: # Default values used if a parameter is not provided in the grid
  3893:     67: DEFAULTS = {
  3894:     68:     "score_min": 55,
  3895:     69:     "atr_min_ratio": 0.002,
  3896:     70:     "rr_min": 1.2,
  3897:     71:     "risk_pct": 0.01,
  3898:     72:     "slippage_bps": 2,
  3899:     73:     "fee_rate": 0.001,
  3900:     74:     "cooldown_secs": 300,
  3901:     75:     "hours": "7-11,13-17",
  3902:     76: }
  3903:     77: 
  3904:     78: 
  3905:     79: @dataclass
  3906:     80: class GridResult:
  3907:     81:     params: Dict[str, Any]
  3908:     82:     metrics: Dict[str, float]
  3909:     83: 
  3910:     84: 
  3911:     85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
  3912:     86:     if isinstance(val, (list, tuple, set)):
  3913:     87:         return list(val)
  3914:     88:     return [val]
  3915:     89: 
  3916:     90: 
  3917:     91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
  3918:     92:     """Return a list of parameter combinations.
  3919:     93: 
  3920:     94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
  3921:     95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
  3922:     96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
  3923:     97:     variety of timeframes and ``atr_min_ratio`` values.
  3924:     98:     """
  3925:     99: 
  3926:    100:     lists: Dict[str, List[Any]] = {}
  3927:    101:     for key in PARAM_KEYS:
  3928:    102:         if key == "timeframe":
  3929:    103:             # timeframe must be explicitly provided; default empty -> "1m"
  3930:    104:             vals = param_lists.get(key) or ["1m"]
  3931:    105:         else:
  3932:    106:             vals = param_lists.get(key)
  3933:    107:             if not vals:
  3934:    108:                 default = DEFAULTS[key]
  3935:    109:                 vals = [default]
  3936:    110:         lists[key] = _ensure_list(vals)
  3937:    111: 
  3938:    112:     combos: List[Dict[str, Any]] = [
  3939:    113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
  3940:    114:     ]
  3941:    115: 
  3942:    116:     # Uniform sampling if exceeding grid_max
  3943:    117:     if len(combos) > grid_max:
  3944:    118:         step = len(combos) / float(grid_max)
  3945:    119:         sampled = []
  3946:    120:         for i in range(grid_max):
  3947:    121:             idx = int(round(i * step))
  3948:    122:             if idx >= len(combos):
  3949:    123:                 idx = len(combos) - 1
  3950:    124:             sampled.append(combos[idx])
  3951:    125:         # ensure each timeframe appears at least once
  3952:    126:         wanted_tfs = set(lists["timeframe"])
  3953:    127:         present_tfs = {c["timeframe"] for c in sampled}
  3954:    128:         missing = list(wanted_tfs - present_tfs)
  3955:    129:         if missing:
  3956:    130:             for tf in missing:
  3957:    131:                 for c in combos:
  3958:    132:                     if c["timeframe"] == tf and c not in sampled:
  3959:    133:                         sampled.append(c)
  3960:    134:                         break
  3961:    135:             sampled = sampled[:grid_max]
  3962:    136:         combos = sampled
  3963:    137:     return combos
  3964:    138: 
  3965:    139: 
  3966:    140: # ---------------------------------------------------------------------------
  3967:    141: # Core runner
  3968:    142: # ---------------------------------------------------------------------------
  3969:    143: 
  3970:    144: 
  3971:    145: def run_grid_search(
  3972:    146:     *,
  3973:    147:     symbols: Sequence[str],
  3974:    148:     exchange: str,
  3975:    149:     base_params: Dict[str, Any],
  3976:    150:     param_lists: Dict[str, Sequence[Any]],
  3977:    151:     grid_max: int = 12,
  3978:    152:     csv_dir: str | None = None,
  3979:    153:     initial_equity: float = 1000.0,
  3980:    154:     leverage: float = 1.0,
  3981:    155:     paper_constraints: bool = True,
  3982:    156:     seed: int | None = None,
  3983:    157:     out_dir: str = "./result/grid",
  3984:    158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
  3985:    159:     run_func: Callable[..., Any] | None = None,
  3986:    160: ) -> List[GridResult]:
  3987:    161:     """Execute grid search across parameter combinations.
  3988:    162: 
  3989:    163:     ``base_params`` provides default single values for parameters. ``param_lists``
  3990:    164:     contains the grid specifications from CLI (already parsed into sequences).
  3991:    165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
  3992:    166:     """
  3993:    167: 
  3994:    168:     if seed is not None:
  3995:    169:         random.seed(seed)
  3996:    170: 
  3997:    171:     if run_func is None:  # avoid circular import at module load
  3998:    172:         from .run_multi import run_backtest_multi  # late import
  3999:    173: 
  4000:    174:         run_func = run_backtest_multi
  4001:    175: 
  4002:    176:     # merge lists with defaults
  4003:    177:     full_lists: Dict[str, Sequence[Any]] = {}
  4004:    178:     for k in PARAM_KEYS:
  4005:    179:         if k == "timeframe":
  4006:    180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
  4007:    181:         else:
  4008:    182:             if param_lists.get(k) is not None:
  4009:    183:                 full_lists[k] = param_lists[k]
  4010:    184:             else:
  4011:    185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
  4012:    186: 
  4013:    187:     combos = build_param_grid(full_lists, grid_max)
  4014:    188: 
  4015:    189:     results: List[GridResult] = []
  4016:    190:     os.makedirs(out_dir, exist_ok=True)
  4017:    191: 
  4018:    192:     for combo in combos:
  4019:    193:         # Build parameters for backtester
  4020:    194:         tf = combo["timeframe"]
  4021:    195:         fee = float(combo["fee_rate"])
  4022:    196:         slip = float(combo["slippage_bps"])
  4023:    197:         risk = float(combo["risk_pct"])
  4024:    198: 
  4025:    199:         summary, _trades = run_func(
  4026:    200:             symbols=list(symbols),
  4027:    201:             exchange=exchange,
  4028:    202:             timeframe=tf,
  4029:    203:             csv_dir=csv_dir,
  4030:    204:             fee_rate=fee,
  4031:    205:             slippage_bps=slip,
  4032:    206:             risk_pct=risk,
  4033:    207:             initial_equity=initial_equity,
  4034:    208:             leverage=leverage,
  4035:    209:             paper_constraints=paper_constraints,
  4036:    210:             seed=seed,
  4037:    211:             out_dir=os.path.join(out_dir, "tmp"),
  4038:    212:             plot=False,
  4039:    213:             dry_run=True,
  4040:    214:         )
  4041:    215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
  4042:    216:         metrics = {
  4043:    217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
  4044:    218:             "profit_factor": float(total.get("profit_factor", 0.0)),
  4045:    219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
  4046:    220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
  4047:    221:             "trades": float(total.get("trades", 0.0)),
  4048:    222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
  4049:    223:         }
  4050:    224:         results.append(GridResult(params=combo, metrics=metrics))
  4051:    225: 
  4052:    226:     # sort results
  4053:    227:     results.sort(
  4054:    228:         key=lambda r: (
  4055:    229:             -r.metrics["profit_factor"],
  4056:    230:             r.metrics["max_dd_pct"],
  4057:    231:             -r.metrics["pnl_usdt"],
  4058:    232:             r.metrics["trades"],
  4059:    233:         )
  4060:    234:     )
  4061:    235: 
  4062:    236:     # console output -------------------------------------------------------
  4063:    237:     print(
  4064:    238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
  4065:    239:     )
  4066:    240:     header = (
  4067:    241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
  4068:    242:     )
  4069:    243:     print(header)
  4070:    244:     for r in results[:10]:
  4071:    245:         m = r.metrics
  4072:    246:         print(
  4073:    247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
  4074:    248:         )
  4075:    249: 
  4076:    250:     # write csv ------------------------------------------------------------
  4077:    251:     csv_cols = PARAM_KEYS + [
  4078:    252:         "pnl_usdt",
  4079:    253:         "profit_factor",
  4080:    254:         "max_dd_pct",
  4081:    255:         "winrate_pct",
  4082:    256:         "trades",
  4083:    257:         "final_equity",
  4084:    258:     ]
  4085:    259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
  4086:    260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
  4087:    261:         writer.writeheader()
  4088:    262:         for r in results:
  4089:    263:             row = {**r.params, **r.metrics}
  4090:    264:             writer.writerow(row)
  4091:    265: 
  4092:    266:     best = results[0]
  4093:    267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
  4094:    268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
  4095:    269: 
  4096:    270:     # markdown summary -----------------------------------------------------
  4097:    271:     md_path = os.path.join(out_dir, "grid_summary.md")
  4098:    272:     with open(md_path, "w", encoding="utf8") as fh:
  4099:    273:         fh.write(
  4100:    274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
  4101:    275:         )
  4102:    276:         for r in results[:10]:
  4103:    277:             m = r.metrics
  4104:    278:             fh.write(
  4105:    279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
  4106:    280:             )
  4107:    281: 
  4108:    282:     # optional scatter plot ------------------------------------------------
  4109:    283:     try:  # pragma: no cover - optional dependency
  4110:    284:         import matplotlib.pyplot as plt
  4111:    285: 
  4112:    286:         pf = [r.metrics["profit_factor"] for r in results]
  4113:    287:         dd = [r.metrics["max_dd_pct"] for r in results]
  4114:    288:         trades = [r.metrics["trades"] for r in results]
  4115:    289:         tfs = [r.params["timeframe"] for r in results]
  4116:    290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
  4117:    291:         c = [colors[tf] for tf in tfs]
  4118:    292:         plt.figure(figsize=(6, 4))
  4119:    293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
  4120:    294:         plt.xlabel("MaxDD%")
  4121:    295:         plt.ylabel("Profit Factor")
  4122:    296:         plt.title("PF vs MaxDD")
  4123:    297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
  4124:    298:         plt.close()
  4125:    299:     except Exception:  # pragma: no cover
  4126:    300:         pass
  4127:    301: 
  4128:    302:     return results
  4129:    303: 
  4130:    304: 
  4131:    305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]
  4132: 
  4133: 
  4134: ## scalper/backtest/loader_csv.py (last modified: 2025-08-23 20:57:14)
  4135:      1: # scalper/backtest/loader_csv.py
  4136:      2: from __future__ import annotations
  4137:      3: 
  4138:      4: import csv
  4139:      5: from typing import Dict, List
  4140:      6: 
  4141:      7: from scalper.services.data_cache import csv_path
  4142:      8: 
  4143:      9: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
  4144:     10: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
  4145:     11:     path = csv_path(symbol, timeframe)
  4146:     12:     rows: List[List[float]] = []
  4147:     13:     with open(path, "r") as f:
  4148:     14:         r = csv.DictReader(f)
  4149:     15:         for row in r:
  4150:     16:             rows.append([
  4151:     17:                 int(row["timestamp"]),
  4152:     18:                 float(row["open"]),
  4153:     19:                 float(row["high"]),
  4154:     20:                 float(row["low"]),
  4155:     21:                 float(row["close"]),
  4156:     22:                 float(row["volume"]),
  4157:     23:             ])
  4158:     24:     rows.sort(key=lambda x: x[0])
  4159:     25:     return rows
  4160:     26: 
  4161:     27: 
  4162:     28: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
  4163:     29:     out: Dict[str, List[List[float]]] = {}
  4164:     30:     for s in symbols:
  4165:     31:         out[s] = load_ohlcv_csv(s, timeframe)
  4166:     32:     return out
  4167: 
  4168: ## scalper/backtest/market_data.py (last modified: 2025-08-23 20:57:14)
  4169:      1: from __future__ import annotations
  4170:      2: 
  4171:      3: import json
  4172:      4: import os
  4173:      5: import time
  4174:      6: from pathlib import Path
  4175:      7: from typing import Any, Iterable, Optional, Sequence, Tuple
  4176:      8: from urllib.request import Request, urlopen
  4177:      9: from urllib.error import URLError, HTTPError
  4178:     10: 
  4179:     11: import pandas as pd
  4180:     12: 
  4181:     13: # ============================================================================
  4182:     14: # Logs & utilitaires
  4183:     15: # ============================================================================
  4184:     16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  4185:     17: def _log(msg: str) -> None:
  4186:     18:     if BT_DEBUG:
  4187:     19:         print(f"[bt.debug] {msg}", flush=True)
  4188:     20: 
  4189:     21: def _now_ms() -> int:
  4190:     22:     return int(time.time() * 1000)
  4191:     23: 
  4192:     24: def _tf_to_seconds(tf: str) -> int:
  4193:     25:     tf = tf.lower().strip()
  4194:     26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
  4195:     27:     if tf not in table:
  4196:     28:         raise ValueError(f"Timeframe non supporté: {tf}")
  4197:     29:     return table[tf]
  4198:     30: 
  4199:     31: def _parse_duration(s: str) -> int:
  4200:     32:     """
  4201:     33:     '90s','15m','2h','3d' -> secondes
  4202:     34:     """
  4203:     35:     s = s.strip().lower()
  4204:     36:     if s.endswith("s"): return int(float(s[:-1]))
  4205:     37:     if s.endswith("m"): return int(float(s[:-1])*60)
  4206:     38:     if s.endswith("h"): return int(float(s[:-1])*3600)
  4207:     39:     if s.endswith("d"): return int(float(s[:-1])*86400)
  4208:     40:     return int(float(s))  # secondes
  4209:     41: 
  4210:     42: # ============================================================================
  4211:     43: # Politique de fraîcheur (par défaut + overrides via ENV)
  4212:     44: # ============================================================================
  4213:     45: def _default_max_age_seconds(tf: str) -> int:
  4214:     46:     """
  4215:     47:     Règles par défaut (conservatrices) :
  4216:     48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
  4217:     49:       - 30m     : 1h
  4218:     50:       - 1h      : 6h
  4219:     51:       - 4h      : 24h
  4220:     52:       - 1d      : 3d
  4221:     53:     """
  4222:     54:     tf = tf.lower()
  4223:     55:     if tf in ("1m","3m","5m","15m"):
  4224:     56:         return 2 * _tf_to_seconds(tf)
  4225:     57:     if tf == "30m":
  4226:     58:         return 3600
  4227:     59:     if tf == "1h":
  4228:     60:         return 6*3600
  4229:     61:     if tf == "4h":
  4230:     62:         return 24*3600
  4231:     63:     if tf == "1d":
  4232:     64:         return 3*86400
  4233:     65:     raise ValueError(tf)
  4234:     66: 
  4235:     67: def _max_age_seconds(tf: str) -> int:
  4236:     68:     """
  4237:     69:     Overrides possibles (au choix) :
  4238:     70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
  4239:     71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
  4240:     72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
  4241:     73:     """
  4242:     74:     tfk = tf.lower().replace(":", "")
  4243:     75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
  4244:     76:     if env_spec:
  4245:     77:         return _parse_duration(env_spec)
  4246:     78:     mult = os.getenv("CSV_MAX_AGE_MULT")
  4247:     79:     if mult:
  4248:     80:         return int(float(mult) * _tf_to_seconds(tf))
  4249:     81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
  4250:     82:     if g:
  4251:     83:         return _parse_duration(g)
  4252:     84:     return _default_max_age_seconds(tf)
  4253:     85: 
  4254:     86: # ============================================================================
  4255:     87: # CSV helpers + validation
  4256:     88: # ============================================================================
  4257:     89: def _data_dir(default: str = "data") -> Path:
  4258:     90:     root = Path(os.getenv("DATA_DIR", default))
  4259:     91:     root.mkdir(parents=True, exist_ok=True)
  4260:     92:     return root
  4261:     93: 
  4262:     94: def _csv_path(symbol: str, timeframe: str) -> Path:
  4263:     95:     tf = timeframe.replace(":", "")
  4264:     96:     return _data_dir() / f"{symbol}-{tf}.csv"
  4265:     97: 
  4266:     98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
  4267:     99:     rows = list(rows)
  4268:    100:     if not rows:
  4269:    101:         raise ValueError("OHLCV vide")
  4270:    102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
  4271:    103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
  4272:    104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
  4273:    105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
  4274:    106: 
  4275:    107: def _read_csv(path: Path) -> pd.DataFrame:
  4276:    108:     df = pd.read_csv(path)
  4277:    109:     # tolère quelques variations de colonnes
  4278:    110:     cols = {c.lower(): c for c in df.columns}
  4279:    111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
  4280:    112:     if not ts_col:
  4281:    113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
  4282:    114:     rename = {ts_col: "timestamp"}
  4283:    115:     for c in ("open","high","low","close","volume"):
  4284:    116:         if c not in cols:
  4285:    117:             raise ValueError(f"Colonne manquante: {c}")
  4286:    118:         rename[cols[c]] = c
  4287:    119:     df = df.rename(columns=rename)
  4288:    120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  4289:    121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
  4290:    122:     df = df.drop_duplicates("timestamp")
  4291:    123:     df = df.set_index("timestamp")
  4292:    124:     return df
  4293:    125: 
  4294:    126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  4295:    127:     out = df.reset_index().rename(columns={"index": "timestamp"})
  4296:    128:     out.to_csv(path, index=False)
  4297:    129: 
  4298:    130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
  4299:    131:     """
  4300:    132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
  4301:    133:       - schéma valide
  4302:    134:       - assez de lignes
  4303:    135:       - fraîcheur < seuil selon TF
  4304:    136:     """
  4305:    137:     if not path.exists():
  4306:    138:         return False, "absent"
  4307:    139:     try:
  4308:    140:         df = _read_csv(path)
  4309:    141:     except Exception as e:
  4310:    142:         return False, f"invalid({e})"
  4311:    143:     if len(df) < min_rows:
  4312:    144:         return False, f"too_few_rows({len(df)}<{min_rows})"
  4313:    145:     # Fraîcheur
  4314:    146:     last_ts = int(df.index.max().timestamp())
  4315:    147:     age_s = int(time.time()) - last_ts
  4316:    148:     max_age = _max_age_seconds(timeframe)
  4317:    149:     if age_s > max_age:
  4318:    150:         return False, f"stale({age_s}s>{max_age}s)"
  4319:    151:     # Monotonicité (échantillon)
  4320:    152:     if not df.index.is_monotonic_increasing:
  4321:    153:         return False, "not_monotonic"
  4322:    154:     return True, "ok"
  4323:    155: 
  4324:    156: # ============================================================================
  4325:    157: # Fallback réseau (CCXT d'abord, HTTP sinon)
  4326:    158: # ============================================================================
  4327:    159: def _ensure_ccxt() -> Any | None:
  4328:    160:     try:
  4329:    161:         import ccxt  # type: ignore
  4330:    162:         return ccxt
  4331:    163:     except Exception:
  4332:    164:         return None
  4333:    165: 
  4334:    166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  4335:    167:     ccxt = _ensure_ccxt()
  4336:    168:     if not ccxt:
  4337:    169:         _log("ccxt indisponible")
  4338:    170:         return None
  4339:    171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
  4340:    172:     ex.load_markets()
  4341:    173:     base = symbol.upper()
  4342:    174:     if not base.endswith("USDT"):
  4343:    175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
  4344:    176:     coin = base[:-4]
  4345:    177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
  4346:    178:     for ccxt_sym in candidates:
  4347:    179:         try:
  4348:    180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
  4349:    181:             if rows:
  4350:    182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
  4351:    183:         except Exception as e:
  4352:    184:             _log(f"ccxt fail {ccxt_sym}: {e}")
  4353:    185:             continue
  4354:    186:     return None
  4355:    187: 
  4356:    188: # === (facultatif) HTTP Bitget v1 minimal ===
  4357:    189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
  4358:    190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
  4359:    191: 
  4360:    192: def _http_get(url: str, timeout: int = 20) -> dict | list:
  4361:    193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
  4362:    194:     with urlopen(req, timeout=timeout) as resp:
  4363:    195:         return json.loads(resp.read().decode("utf-8"))
  4364:    196: 
  4365:    197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
  4366:    198:     rows = payload.get("data") if isinstance(payload, dict) else payload
  4367:    199:     if not isinstance(rows, list):
  4368:    200:         raise ValueError(f"Réponse inattendue: {payload}")
  4369:    201:     out = []
  4370:    202:     for r in rows:
  4371:    203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
  4372:    204:         out.append([ts,o,h,l,c,v])
  4373:    205:     out.sort(key=lambda x:x[0])
  4374:    206:     return out
  4375:    207: 
  4376:    208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  4377:    209:     tf = timeframe.lower()
  4378:    210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
  4379:    211:     if not (g and p):
  4380:    212:         return None
  4381:    213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
  4382:    214:     trials = [
  4383:    215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
  4384:    216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
  4385:    217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
  4386:    218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
  4387:    219:     ]
  4388:    220:     for url in trials:
  4389:    221:         try:
  4390:    222:             payload = _http_get(url)
  4391:    223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
  4392:    224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
  4393:    225:             rows = _normalize_http_rows(payload)
  4394:    226:             if rows:
  4395:    227:                 return _rows_to_df(rows)
  4396:    228:         except Exception as e:
  4397:    229:             _log(f"HTTP fail: {url} -> {e}")
  4398:    230:             continue
  4399:    231:     return None
  4400:    232: 
  4401:    233: # ============================================================================
  4402:    234: # API publique utilisée par l’orchestrateur/backtest
  4403:    235: # ============================================================================
  4404:    236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  4405:    237:     """
  4406:    238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
  4407:    239:     """
  4408:    240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
  4409:    241:     if df is not None:
  4410:    242:         _log(f"source=ccxt  n={len(df)}")
  4411:    243:         return df
  4412:    244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
  4413:    245:     if df is not None:
  4414:    246:         _log(f"source=http  n={len(df)}")
  4415:    247:         return df
  4416:    248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
  4417:    249: 
  4418:    250: def hybrid_loader(
  4419:    251:     data_dir: str = "data",
  4420:    252:     *,
  4421:    253:     use_cache_first: bool = True,
  4422:    254:     min_rows: int = 100,
  4423:    255:     refill_if_stale: bool = True,
  4424:    256:     network_limit: int = 1000,
  4425:    257: ):
  4426:    258:     """
  4427:    259:     Loader smart :
  4428:    260:       1) si CSV présent ET frais/valide → le renvoie
  4429:    261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
  4430:    262:       3) sinon → lève
  4431:    263:     """
  4432:    264:     os.environ.setdefault("DATA_DIR", data_dir)
  4433:    265: 
  4434:    266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  4435:    267:         path = _csv_path(symbol, timeframe)
  4436:    268: 
  4437:    269:         if use_cache_first:
  4438:    270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
  4439:    271:             if ok:
  4440:    272:                 _log(f"CSV OK: {path}")
  4441:    273:                 df = _read_csv(path)
  4442:    274:             else:
  4443:    275:                 _log(f"CSV non utilisable ({why}): {path}")
  4444:    276:                 if not refill_if_stale:
  4445:    277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
  4446:    278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  4447:    279:                 _write_csv(path, df)
  4448:    280:         else:
  4449:    281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  4450:    282:             _write_csv(path, df)
  4451:    283: 
  4452:    284:         # Fenêtrage temporel si demandé (timestamps UTC)
  4453:    285:         if start:
  4454:    286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  4455:    287:         if end:
  4456:    288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  4457:    289:         return df
  4458:    290: 
  4459:    291:     return load
  4460: 
  4461: ## scalper/backtest/metrics.py (last modified: 2025-08-23 20:57:14)
  4462:      1: from __future__ import annotations
  4463:      2: import math
  4464:      3: from dataclasses import dataclass
  4465:      4: from typing import List, Dict
  4466:      5: 
  4467:      6: @dataclass
  4468:      7: class Trade:
  4469:      8:     ts: int
  4470:      9:     side: str
  4471:     10:     entry: float
  4472:     11:     exit: float
  4473:     12:     pnl_abs: float
  4474:     13:     pnl_pct: float
  4475:     14:     dur_min: float
  4476:     15: 
  4477:     16: def equity_to_drawdown(equity: List[float]) -> float:
  4478:     17:     peak = -1e18; maxdd = 0.0
  4479:     18:     for v in equity:
  4480:     19:         if v > peak: peak = v
  4481:     20:         dd = 0.0 if peak == 0 else (peak - v) / peak
  4482:     21:         if dd > maxdd: maxdd = dd
  4483:     22:     return maxdd
  4484:     23: 
  4485:     24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
  4486:     25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
  4487:     26:     if not returns: return 0.0
  4488:     27:     mean = sum(returns)/len(returns)
  4489:     28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
  4490:     29:     std = math.sqrt(var) if var>0 else 0.0
  4491:     30:     if std == 0: return 0.0
  4492:     31:     return (mean - rf) / std * math.sqrt(period_per_year)
  4493:     32: 
  4494:     33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
  4495:     34:     wins = [t for t in trades if t.pnl_abs > 0]
  4496:     35:     losses = [t for t in trades if t.pnl_abs < 0]
  4497:     36:     wr = len(wins)/len(trades) if trades else 0.0
  4498:     37:     gross_win = sum(t.pnl_abs for t in wins)
  4499:     38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
  4500:     39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
  4501:     40:     mdd = equity_to_drawdown(equity)
  4502:     41:     shp = sharpe(bar_returns)
  4503:     42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
  4504:     43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
  4505:     44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
  4506:     45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
  4507:     46:     return {
  4508:     47:         "trades": len(trades),
  4509:     48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
  4510:     49:         "expectancy": expectancy, "cagr": cagr, "score": score,
  4511:     50:         "equity_start": equity[0] if equity else None,
  4512:     51:         "equity_end": equity[-1] if equity else None,
  4513:     52:     }
  4514: 
  4515: ## scalper/backtest/optimize.py (last modified: 2025-08-23 20:57:14)
  4516:      1: from __future__ import annotations
  4517:      2: 
  4518:      3: """Parameter sweep utilities for strategy optimisation.
  4519:      4: 
  4520:      5: This module performs a grid search over a parameter space in parallel.  It
  4521:      6: tries to use :mod:`ray` for distributed execution when available and falls
  4522:      7: back to :mod:`multiprocessing` otherwise.
  4523:      8: """
  4524:      9: 
  4525:     10: import itertools
  4526:     11: import json
  4527:     12: import multiprocessing as mp
  4528:     13: import os
  4529:     14: from typing import Any, Dict, Iterable, List, Sequence
  4530:     15: 
  4531:     16: try:  # Optional dependency
  4532:     17:     import ray  # type: ignore
  4533:     18: except Exception:  # pragma: no cover - ray is optional
  4534:     19:     ray = None
  4535:     20: 
  4536:     21: from scalper.backtest import backtest_trades
  4537:     22: 
  4538:     23: 
  4539:     24: # ---------------------------------------------------------------------------
  4540:     25: # Parameter space
  4541:     26: # ---------------------------------------------------------------------------
  4542:     27: 
  4543:     28: def param_space_default() -> Dict[str, Sequence[Any]]:
  4544:     29:     """Return the default parameter search space.
  4545:     30: 
  4546:     31:     The keys correspond to strategy parameters while the values are iterables
  4547:     32:     of possible settings.  The defaults represent a small but representative
  4548:     33:     grid and can be overridden by callers.
  4549:     34:     """
  4550:     35: 
  4551:     36:     return {
  4552:     37:         "ema_fast": [10, 20, 30],
  4553:     38:         "ema_slow": [50, 100, 200],
  4554:     39:         "rsi_period": [14, 21],
  4555:     40:         "atr_period": [14, 21],
  4556:     41:     }
  4557:     42: 
  4558:     43: 
  4559:     44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
  4560:     45:     """Expand *space* into a list of parameter combinations."""
  4561:     46: 
  4562:     47:     keys = list(space)
  4563:     48:     values = [space[k] for k in keys]
  4564:     49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
  4565:     50: 
  4566:     51: 
  4567:     52: # ---------------------------------------------------------------------------
  4568:     53: # Evaluation
  4569:     54: # ---------------------------------------------------------------------------
  4570:     55: 
  4571:     56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
  4572:     57:     """Run a backtest for a single parameter combination.
  4573:     58: 
  4574:     59:     ``grid_item`` contains the parameter values along with optional ``trades``
  4575:     60:     to evaluate.  The function returns a copy of the parameters augmented with
  4576:     61:     the computed PnL under the key ``pnl``.
  4577:     62:     """
  4578:     63: 
  4579:     64:     params = dict(grid_item)
  4580:     65:     trades = params.pop("trades", [])
  4581:     66:     fee_rate = params.pop("fee_rate", None)
  4582:     67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
  4583:     68:     params["pnl"] = pnl
  4584:     69:     return params
  4585:     70: 
  4586:     71: 
  4587:     72: # ---------------------------------------------------------------------------
  4588:     73: # Orchestration
  4589:     74: # ---------------------------------------------------------------------------
  4590:     75: 
  4591:     76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
  4592:     77:     """Evaluate the full parameter grid in parallel and return results."""
  4593:     78: 
  4594:     79:     space = space or param_space_default()
  4595:     80:     grid = _param_grid(space)
  4596:     81: 
  4597:     82:     # Determine execution backend
  4598:     83:     use_ray = False
  4599:     84:     if ray is not None:
  4600:     85:         try:  # pragma: no cover - depends on ray
  4601:     86:             ray.init(ignore_reinit_error=True)
  4602:     87:             use_ray = True
  4603:     88:         except Exception:
  4604:     89:             use_ray = False
  4605:     90: 
  4606:     91:     if use_ray:
  4607:     92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
  4608:     93:         futures = [remote_eval.remote(g) for g in grid]
  4609:     94:         results = ray.get(futures)
  4610:     95:     else:
  4611:     96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
  4612:     97:         with mp.Pool(processes=jobs) as pool:
  4613:     98:             results = pool.map(eval_params_one, grid)
  4614:     99: 
  4615:    100:     return results
  4616:    101: 
  4617:    102: 
  4618:    103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
  4619:    104:     """High level helper executing the sweep and saving aggregated results."""
  4620:    105: 
  4621:    106:     results = run_param_sweep(space, jobs=jobs)
  4622:    107:     with open(outfile, "w", encoding="utf8") as fh:
  4623:    108:         json.dump(results, fh, indent=2, sort_keys=True)
  4624:    109:     return results
  4625:    110: 
  4626:    111: 
  4627:    112: def main() -> None:  # pragma: no cover - convenience CLI
  4628:    113:     optimize()
  4629:    114: 
  4630:    115: 
  4631:    116: if __name__ == "__main__":  # pragma: no cover
  4632:    117:     main()
  4633: 
  4634: 
  4635: ## scalper/backtest/run_multi.py (last modified: 2025-08-23 20:57:14)
  4636:      1: # annulé
  4637: 
  4638: ## scalper/backtest/runner.py (last modified: 2025-08-23 20:57:14)
  4639:      1: # scalper/backtest/runner.py
  4640:      2: from __future__ import annotations
  4641:      3: 
  4642:      4: import json
  4643:      5: import math
  4644:      6: import os
  4645:      7: import time
  4646:      8: from dataclasses import dataclass, replace
  4647:      9: from pathlib import Path
  4648:     10: from typing import Dict, List, Tuple, Callable
  4649:     11: 
  4650:     12: from .cache import ensure_csv_cache, read_csv_ohlcv, csv_path, tf_to_seconds, dump_validation_report
  4651:     13: 
  4652:     14: # --------- Chargement de la stratégie ---------
  4653:     15: def load_signal_fn() -> Callable[[str, List[List[float]], float, float], Tuple[str, float]]:
  4654:     16:     try:
  4655:     17:         from scalper.signals.factory import load_signal  # type: ignore
  4656:     18:         name = os.getenv("STRATEGY", "current")
  4657:     19:         return load_signal(name)
  4658:     20:     except Exception:
  4659:     21:         def _fallback(symbol: str, ohlcv: List[List[float]], cash: float, risk_pct: float) -> Tuple[str, float]:
  4660:     22:             closes = [r[4] for r in (ohlcv[-10:] if len(ohlcv) >= 10 else ohlcv)]
  4661:     23:             if not closes:
  4662:     24:                 return "HOLD", 0.0
  4663:     25:             avg = sum(closes) / len(closes)
  4664:     26:             last = closes[-1]
  4665:     27:             if last > avg * 1.002:
  4666:     28:                 return "BUY", 1.0
  4667:     29:             if last < avg * 0.998:
  4668:     30:                 return "SELL", 1.0
  4669:     31:             return "HOLD", 0.0
  4670:     32:         return _fallback
  4671:     33: 
  4672:     34: # --------- Config ---------
  4673:     35: @dataclass
  4674:     36: class BTCfg:
  4675:     37:     symbols: List[str]
  4676:     38:     timeframe: str = "5m"
  4677:     39:     limit: int = 1500
  4678:     40:     cash: float = 10_000.0
  4679:     41:     risk_pct: float = 0.05
  4680:     42:     slippage_bps: float = 0.0
  4681:     43:     fee_bps: float = 6.0
  4682:     44:     data_dir: str = "data"
  4683:     45:     strategy: str = os.getenv("STRATEGY", "current")
  4684:     46: 
  4685:     47: # --------- Petit moteur PnL ---------
  4686:     48: def _bps(x: float) -> float: return x / 10_000.0
  4687:     49: 
  4688:     50: def simulate_symbol(ohlcv: List[List[float]], cfg: BTCfg, signal_fn: Callable) -> Tuple[List[Tuple[int,float]], Dict]:
  4689:     51:     equity = cfg.cash
  4690:     52:     position = 0.0
  4691:     53:     entry_price = 0.0
  4692:     54:     equity_curve: List[Tuple[int, float]] = []
  4693:     55:     trades = 0
  4694:     56: 
  4695:     57:     fee = _bps(cfg.fee_bps)
  4696:     58:     slip = _bps(cfg.slippage_bps)
  4697:     59: 
  4698:     60:     for i in range(1, len(ohlcv)):
  4699:     61:         window = ohlcv[: i+1]
  4700:     62:         ts, _, _, _, price, _ = ohlcv[i]
  4701:     63:         signal, strength = signal_fn("SYMBOL", window, equity, cfg.risk_pct)
  4702:     64: 
  4703:     65:         if position != 0:
  4704:     66:             equity += position * (price - ohlcv[i-1][4])
  4705:     67: 
  4706:     68:         target_pos = 0.0
  4707:     69:         if signal == "BUY":
  4708:     70:             notional = equity * cfg.risk_pct * strength
  4709:     71:             target_pos = max(0.0, notional / price)
  4710:     72:         elif signal == "SELL":
  4711:     73:             notional = equity * cfg.risk_pct * strength
  4712:     74:             target_pos = - max(0.0, notional / price)
  4713:     75: 
  4714:     76:         if target_pos != position:
  4715:     77:             delta = target_pos - position
  4716:     78:             if delta != 0:
  4717:     79:                 trades += 1
  4718:     80:                 trade_price = price * (1 + slip * (1 if delta > 0 else -1))
  4719:     81:                 equity -= abs(delta) * trade_price * fee
  4720:     82:                 position = target_pos
  4721:     83:                 entry_price = trade_price if position != 0 else 0.0
  4722:     84: 
  4723:     85:         equity_curve.append((ts, equity))
  4724:     86: 
  4725:     87:     if position != 0 and ohlcv:
  4726:     88:         last_price = ohlcv[-1][4]
  4727:     89:         equity += position * (last_price - entry_price)
  4728:     90:         equity -= abs(position) * last_price * fee
  4729:     91:         position = 0
  4730:     92: 
  4731:     93:     eq = [e for _, e in equity_curve]
  4732:     94:     ret_tot = (eq[-1] / eq[0] - 1.0) if len(eq) >= 2 else 0.0
  4733:     95:     max_dd = 0.0
  4734:     96:     peak = -1.0
  4735:     97:     for v in eq:
  4736:     98:         if v > peak: peak = v
  4737:     99:         dd = (peak - v) / peak if peak > 0 else 0.0
  4738:    100:         max_dd = max(max_dd, dd)
  4739:    101: 
  4740:    102:     tf_sec = tf_to_seconds(cfg.timeframe)
  4741:    103:     bpy = int((365.0 * 86400.0) / tf_sec)
  4742:    104:     rets = []
  4743:    105:     for i in range(1, len(eq)):
  4744:    106:         r = (eq[i] / eq[i-1]) - 1.0
  4745:    107:         rets.append(r)
  4746:    108:     if len(rets) > 1:
  4747:    109:         mu = sum(rets) / len(rets)
  4748:    110:         var = sum((x - mu) ** 2 for x in rets) / (len(rets) - 1)
  4749:    111:         std = math.sqrt(var) if var > 0 else 0.0
  4750:    112:         sharpe = (mu * bpy) / (std * math.sqrt(bpy)) if std > 0 else 0.0
  4751:    113:     else:
  4752:    114:         sharpe = 0.0
  4753:    115: 
  4754:    116:     metrics = {
  4755:    117:         "final_equity": round(eq[-1], 4) if eq else cfg.cash,
  4756:    118:         "total_return_pct": round(ret_tot * 100, 4),
  4757:    119:         "max_drawdown_pct": round(max_dd * 100, 4),
  4758:    120:         "sharpe_like": round(sharpe, 4),
  4759:    121:         "trades": trades,
  4760:    122:     }
  4761:    123:     return equity_curve, metrics
  4762:    124: 
  4763:    125: # --------- Runner principal ---------
  4764:    126: async def run_multi(cfg: BTCfg, exchange) -> Dict:
  4765:    127:     data = await ensure_csv_cache(exchange, cfg.symbols, cfg.timeframe, cfg.limit)
  4766:    128: 
  4767:    129:     signal_fn = load_signal_fn()
  4768:    130:     per_symbol: Dict[str, Dict] = {}
  4769:    131:     aligned_ts: List[int] = []
  4770:    132: 
  4771:    133:     sets_ts = []
  4772:    134:     for s in cfg.symbols:
  4773:    135:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  4774:    136:         sets_ts.append({r[0] for r in rows})
  4775:    137:     if sets_ts:
  4776:    138:         aligned_ts = sorted(list(set.intersection(*sets_ts)))
  4777:    139: 
  4778:    140:     results_curves: Dict[str, List[Tuple[int, float]]] = {}
  4779:    141:     for s in cfg.symbols:
  4780:    142:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  4781:    143:         rows = [r for r in rows if r[0] in set(aligned_ts)]
  4782:    144:         curve, metr = simulate_symbol(rows, cfg, signal_fn)
  4783:    145:         results_curves[s] = curve
  4784:    146:         per_symbol[s] = metr
  4785:    147: 
  4786:    148:     fused: List[Tuple[int, float]] = []
  4787:    149:     for i in range(len(aligned_ts)):
  4788:    150:         ts = aligned_ts[i]
  4789:    151:         vals = []
  4790:    152:         for s in cfg.symbols:
  4791:    153:             cv = results_curves[s]
  4792:    154:             if i < len(cv) and cv[i][0] == ts:
  4793:    155:                 vals.append(cv[i][1])
  4794:    156:         if vals:
  4795:    157:             fused.append((ts, sum(vals) / len(vals)))
  4796:    158: 
  4797:    159:     glob_metrics = {}
  4798:    160:     if fused:
  4799:    161:         eq = [e for _, e in fused]
  4800:    162:         ret_tot = (eq[-1]/eq[0]-1.0) if len(eq)>=2 else 0.0
  4801:    163:         peak = -1.0; max_dd = 0.0
  4802:    164:         for v in eq:
  4803:    165:             if v > peak: peak = v
  4804:    166:             dd = (peak - v) / peak if peak > 0 else 0.0
  4805:    167:             max_dd = max(max_dd, dd)
  4806:    168:         tf_sec = tf_to_seconds(cfg.timeframe)
  4807:    169:         bpy = int((365.0*86400.0)/tf_sec)
  4808:    170:         rets = []
  4809:    171:         for i in range(1, len(eq)):
  4810:    172:             rets.append((eq[i]/eq[i-1]) - 1.0)
  4811:    173:         if len(rets) > 1:
  4812:    174:             mu = sum(rets)/len(rets)
  4813:    175:             var = sum((x-mu)**2 for x in rets)/(len(rets)-1)
  4814:    176:             std = math.sqrt(var) if var>0 else 0.0
  4815:    177:             sharpe = (mu*bpy)/(std*math.sqrt(bpy)) if std>0 else 0.0
  4816:    178:         else:
  4817:    179:             sharpe = 0.0
  4818:    180:         glob_metrics = {
  4819:    181:             "final_equity": round(eq[-1], 4),
  4820:    182:             "total_return_pct": round(ret_tot*100, 4),
  4821:    183:             "max_drawdown_pct": round(max_dd*100, 4),
  4822:    184:             "sharpe_like": round(sharpe, 4),
  4823:    185:         }
  4824:    186: 
  4825:    187:     stamp = time.strftime("%Y%m%d-%H%M%S")
  4826:    188:     out_dir = Path(os.getenv("BACKTEST_OUT", f"result/backtest-{stamp}"))
  4827:    189:     out_dir.mkdir(parents=True, exist_ok=True)
  4828:    190: 
  4829:    191:     (out_dir / "equity_curve.csv").write_text(
  4830:    192:         "timestamp,equity\n" + "\n".join(f"{ts},{eq:.6f}" for ts, eq in fused)
  4831:    193:     )
  4832:    194:     all_metrics = {"global": glob_metrics, "per_symbol": per_symbol}
  4833:    195:     (out_dir / "metrics.json").write_text(json.dumps(all_metrics, indent=2))
  4834:    196:     dump_validation_report(cfg.symbols, cfg.timeframe, out_dir / "csv_validation.json")
  4835:    197: 
  4836:    198:     return {
  4837:    199:         "out_dir": str(out_dir),
  4838:    200:         "equity_curve": str(out_dir / "equity_curve.csv"),
  4839:    201:         "metrics": str(out_dir / "metrics.json"),
  4840:    202:         "csv_validation": str(out_dir / "csv_validation.json"),
  4841:    203:     }
  4842:    204: 
  4843:    205: # --------- Alias rétro-compatibilité ---------
  4844:    206: # Certains fichiers live importaient: BTConfig, run_single, save_results
  4845:    207: BTConfig = BTCfg  # alias
  4846:    208: 
  4847:    209: async def run_single(cfg: BTCfg, exchange, symbol: str | None = None) -> Dict:
  4848:    210:     """Compat : lance un backtest mono-symbole en réutilisant run_multi."""
  4849:    211:     if symbol:
  4850:    212:         cfg = replace(cfg, symbols=[symbol])
  4851:    213:     return await run_multi(cfg, exchange)
  4852:    214: 
  4853:    215: def save_results(res: Dict) -> Dict:
  4854:    216:     """Compat no-op : les fichiers sont déjà écrits par run_multi."""
  4855:    217:     return res
  4856:    218: 
  4857:    219: # --------- CLI ---------
  4858:    220: if __name__ == "__main__":
  4859:    221:     import asyncio
  4860:    222:     try:
  4861:    223:         import ccxt.async_support as ccxt  # type: ignore
  4862:    224:     except Exception:
  4863:    225:         raise SystemExit("Installe ccxt: pip install ccxt")
  4864:    226: 
  4865:    227:     symbols = os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",")
  4866:    228:     cfg = BTCfg(
  4867:    229:         symbols=[s.strip().upper() for s in symbols if s.strip()],
  4868:    230:         timeframe=os.getenv("TF", "5m"),
  4869:    231:         limit=int(os.getenv("LIMIT", "1500")),
  4870:    232:         cash=float(os.getenv("CASH", "10000")),
  4871:    233:         risk_pct=float(os.getenv("RISK_PCT", "0.05")),
  4872:    234:         slippage_bps=float(os.getenv("SLIPPAGE_BPS", "0.0")),
  4873:    235:         fee_bps=float(os.getenv("FEE_BPS", "6.0")),
  4874:    236:     )
  4875:    237:     exchange = ccxt.bitget()
  4876:    238:     res = asyncio.run(run_multi(cfg, exchange))
  4877:    239:     print("Résultats écrits dans:", res["out_dir"])
  4878: 
  4879: ## scalper/backtest/walkforward.py (last modified: 2025-08-23 20:57:14)
  4880:      1: from __future__ import annotations
  4881:      2: 
  4882:      3: from itertools import product
  4883:      4: from statistics import mean, stdev
  4884:      5: from typing import Dict, Iterable, Optional
  4885:      6: 
  4886:      7: from ..strategy import max_drawdown
  4887:      8: 
  4888:      9: 
  4889:     10: def _sharpe(returns: Iterable[float]) -> float:
  4890:     11:     vals = list(returns)
  4891:     12:     if not vals:
  4892:     13:         return 0.0
  4893:     14:     mu = mean(vals)
  4894:     15:     if len(vals) > 1:
  4895:     16:         sd = stdev(vals)
  4896:     17:     else:
  4897:     18:         sd = 0.0
  4898:     19:     return mu / sd if sd > 0 else 0.0
  4899:     20: 
  4900:     21: 
  4901:     22: def _stability(equity: Iterable[float]) -> float:
  4902:     23:     curve = list(equity)
  4903:     24:     n = len(curve)
  4904:     25:     if n < 2:
  4905:     26:         return 0.0
  4906:     27:     x = list(range(n))
  4907:     28:     x_mean = sum(x) / n
  4908:     29:     y_mean = sum(curve) / n
  4909:     30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
  4910:     31:     denom = sum((xi - x_mean) ** 2 for xi in x)
  4911:     32:     if denom == 0 or ss_tot == 0:
  4912:     33:         return 0.0
  4913:     34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
  4914:     35:     a = y_mean - b * x_mean
  4915:     36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
  4916:     37:     return 1 - ss_res / ss_tot
  4917:     38: 
  4918:     39: 
  4919:     40: def walk_forward(
  4920:     41:     df,
  4921:     42:     splits: int = 5,
  4922:     43:     train_ratio: float = 0.7,
  4923:     44:     params: Optional[Dict[str, Iterable]] = None,
  4924:     45: ) -> Dict[str, float]:
  4925:     46:     """Perform walk-forward optimisation and evaluation.
  4926:     47: 
  4927:     48:     Parameters
  4928:     49:     ----------
  4929:     50:     df:
  4930:     51:         DataFrame containing per-period percentage returns. The first column is
  4931:     52:         used when a dedicated ``"returns"`` column is not found.
  4932:     53:     splits:
  4933:     54:         Number of walk-forward test windows.
  4934:     55:     train_ratio:
  4935:     56:         Proportion of the data used for training in the initial window.
  4936:     57:     params:
  4937:     58:         Optional parameter grid. If provided, columns in ``df`` matching each
  4938:     59:         parameter combination are evaluated and the best Sharpe ratio on the
  4939:     60:         training window is selected. When ``None``, the first column is used.
  4940:     61:     """
  4941:     62: 
  4942:     63:     if df.empty:
  4943:     64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
  4944:     65: 
  4945:     66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
  4946:     67:     data = df.copy()
  4947:     68: 
  4948:     69:     n = len(data)
  4949:     70:     train_len = max(1, int(n * train_ratio))
  4950:     71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
  4951:     72: 
  4952:     73:     sharpe_list = []
  4953:     74:     mdd_list = []
  4954:     75:     pnl_list = []
  4955:     76:     stability_list = []
  4956:     77: 
  4957:     78:     from . import walk_forward_windows
  4958:     79: 
  4959:     80:     indices = list(range(n))
  4960:     81: 
  4961:     82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
  4962:     83:         train_df = data.iloc[tr_idx]
  4963:     84:         test_df = data.iloc[te_idx]
  4964:     85: 
  4965:     86:         # Parameter optimisation based on Sharpe ratio
  4966:     87:         if params:
  4967:     88:             best_col = None
  4968:     89:             best_score = float("-inf")
  4969:     90:             keys, values = zip(*params.items()) if params else ([], [])
  4970:     91:             for combo in product(*values):
  4971:     92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
  4972:     93:                 if col_name not in data.columns:
  4973:     94:                     continue
  4974:     95:                 score = _sharpe(train_df[col_name])
  4975:     96:                 if score > best_score:
  4976:     97:                     best_score = score
  4977:     98:                     best_col = col_name
  4978:     99:             series = test_df[best_col] if best_col else test_df[returns_col]
  4979:    100:         else:
  4980:    101:             series = test_df[returns_col]
  4981:    102: 
  4982:    103:         sharpe_list.append(_sharpe(series))
  4983:    104:         equity = (1 + series / 100.0).cumprod()
  4984:    105:         mdd_list.append(max_drawdown(equity))
  4985:    106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
  4986:    107:         stability_list.append(_stability(equity))
  4987:    108: 
  4988:    109:     count = len(sharpe_list) or 1
  4989:    110:     mean_sharpe = sum(sharpe_list) / count
  4990:    111:     mean_mdd = sum(mdd_list) / count
  4991:    112:     mean_pnl = sum(pnl_list) / count
  4992:    113:     mean_stability = sum(stability_list) / count
  4993:    114: 
  4994:    115:     return {
  4995:    116:         "sharpe": mean_sharpe,
  4996:    117:         "mdd": mean_mdd,
  4997:    118:         "pnl": mean_pnl,
  4998:    119:         "stability": mean_stability,
  4999:    120:     }
  5000: 
  5001: 
  5002: ## scalper/bitget_client.py (last modified: 2025-08-23 20:57:14)
  5003:      1: import json
  5004:      2: import logging
  5005:      3: import time
  5006:      4: import hmac
  5007:      5: import hashlib
  5008:      6: import base64
  5009:      7: import uuid
  5010:      8: from typing import Any, Dict, List, Optional
  5011:      9: 
  5012:     10: import requests
  5013:     11: 
  5014:     12: 
  5015:     13: # Mapping of deprecated v1 product type identifiers to the new v2 names
  5016:     14: _PRODUCT_TYPE_ALIASES = {
  5017:     15:     "UMCBL": "USDT-FUTURES",
  5018:     16:     "DMCBL": "USDC-FUTURES",
  5019:     17:     "CMCBL": "COIN-FUTURES",
  5020:     18: }
  5021:     19: 
  5022:     20: # Granularity aliases from v1 to v2 nomenclature
  5023:     21: _GRANULARITY_ALIASES = {
  5024:     22:     "MIN1": "1m",
  5025:     23:     "MIN3": "3m",
  5026:     24:     "MIN5": "5m",
  5027:     25:     "MIN15": "15m",
  5028:     26:     "MIN30": "30m",
  5029:     27:     "HOUR1": "1H",
  5030:     28:     "HOUR4": "4H",
  5031:     29:     "HOUR12": "12H",
  5032:     30:     "DAY1": "1D",
  5033:     31:     "WEEK1": "1W",
  5034:     32: }
  5035:     33: 
  5036:     34: 
  5037:     35: # Default margin coin for each product type. Some authenticated endpoints
  5038:     36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
  5039:     37: # default avoids ``400 Bad Request`` responses when the caller does not provide
  5040:     38: # it explicitly.
  5041:     39: _DEFAULT_MARGIN_COIN = {
  5042:     40:     "USDT-FUTURES": "USDT",
  5043:     41:     "USDC-FUTURES": "USDC",
  5044:     42: }
  5045:     43: 
  5046:     44: 
  5047:     45: class BitgetFuturesClient:
  5048:     46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
  5049:     47: 
  5050:     48:     def __init__(
  5051:     49:         self,
  5052:     50:         access_key: str,
  5053:     51:         secret_key: str,
  5054:     52:         base_url: str,
  5055:     53:         *,
  5056:     54:         product_type: str = "USDT-FUTURES",
  5057:     55:         recv_window: int = 30,
  5058:     56:         paper_trade: bool = True,
  5059:     57:         requests_module: Any = requests,
  5060:     58:         log_event: Optional[Any] = None,
  5061:     59:         passphrase: Optional[str] = None,
  5062:     60:     ) -> None:
  5063:     61:         self.ak = access_key
  5064:     62:         self.sk = secret_key
  5065:     63:         self.base = base_url.rstrip("/")
  5066:     64:         pt = product_type.upper()
  5067:     65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
  5068:     66:         self.recv_window = recv_window
  5069:     67:         self.paper_trade = paper_trade
  5070:     68:         self.requests = requests_module
  5071:     69:         self.log_event = log_event or (lambda *a, **k: None)
  5072:     70:         self.passphrase = passphrase
  5073:     71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
  5074:     72:             logging.warning(
  5075:     73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
  5076:     74:             )
  5077:     75:         # Cache for contract precision details to avoid repeated network calls
  5078:     76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
  5079:     77: 
  5080:     78:     # ------------------------------------------------------------------
  5081:     79:     # Helpers
  5082:     80:     # ------------------------------------------------------------------
  5083:     81:     @staticmethod
  5084:     82:     def _ms() -> int:
  5085:     83:         return int(time.time() * 1000)
  5086:     84: 
  5087:     85:     @staticmethod
  5088:     86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
  5089:     87:         if not params:
  5090:     88:             return ""
  5091:     89:         items = []
  5092:     90:         for k in sorted(params.keys()):
  5093:     91:             v = "" if params[k] is None else str(params[k])
  5094:     92:             items.append(f"{k}={v}")
  5095:     93:         return "&".join(items)
  5096:     94: 
  5097:     95:     def _sign(self, prehash: str) -> str:
  5098:     96:         """Return a base64-encoded HMAC SHA256 signature."""
  5099:     97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
  5100:     98:         return base64.b64encode(digest).decode()
  5101:     99: 
  5102:    100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
  5103:    101:         headers = {
  5104:    102:             "ACCESS-KEY": self.ak,
  5105:    103:             "ACCESS-SIGN": signature,
  5106:    104:             "ACCESS-TIMESTAMP": str(timestamp),
  5107:    105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
  5108:    106:             "Content-Type": "application/json",
  5109:    107:         }
  5110:    108:         if self.passphrase:
  5111:    109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
  5112:    110:         return headers
  5113:    111: 
  5114:    112:     def _format_symbol(self, symbol: str) -> str:
  5115:    113:         """Return ``symbol`` formatted for Bitget API.
  5116:    114: 
  5117:    115:         The v2 endpoints expect the trading pair without any product type
  5118:    116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
  5119:    117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
  5120:    118:         separators and any trailing product type string (legacy or v2).
  5121:    119:         """
  5122:    120: 
  5123:    121:         if not symbol:
  5124:    122:             return symbol
  5125:    123: 
  5126:    124:         sym = symbol.replace("_", "").upper()
  5127:    125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
  5128:    126:         if sym.endswith(self.product_type):
  5129:    127:             sym = sym[: -len(self.product_type)]
  5130:    128:         else:
  5131:    129:             for old in _PRODUCT_TYPE_ALIASES.keys():
  5132:    130:                 if sym.endswith(old):
  5133:    131:                     sym = sym[: -len(old)]
  5134:    132:                     break
  5135:    133:         return sym
  5136:    134: 
  5137:    135:     def _product_type(self, pt: Optional[str] = None) -> str:
  5138:    136:         """Normalise ``pt`` to a valid v2 product type identifier."""
  5139:    137:         key = (pt or self.product_type or "").upper()
  5140:    138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
  5141:    139: 
  5142:    140:     # ------------------------------------------------------------------
  5143:    141:     # Public endpoints
  5144:    142:     # ------------------------------------------------------------------
  5145:    143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5146:    144:         """Return futures contract information.
  5147:    145: 
  5148:    146:         The previous implementation queried ``/contract-detail`` which does not
  5149:    147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
  5150:    148:         endpoint is ``/contracts`` with the symbol supplied as a query
  5151:    149:         parameter."""
  5152:    150: 
  5153:    151:         url = f"{self.base}/api/v2/mix/market/contracts"
  5154:    152:         params: Dict[str, Any] = {"productType": self.product_type}
  5155:    153:         if symbol:
  5156:    154:             params["symbol"] = self._format_symbol(symbol)
  5157:    155:         r = self.requests.get(url, params=params, timeout=15)
  5158:    156:         if r.status_code == 404:  # pragma: no cover - depends on network
  5159:    157:             logging.error("Contract detail introuvable pour %s", symbol)
  5160:    158:             return {"success": False, "code": 404, "data": None}
  5161:    159:         r.raise_for_status()
  5162:    160:         return r.json()
  5163:    161: 
  5164:    162:     # ------------------------------------------------------------------
  5165:    163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
  5166:    164:         """Return price and volume precision for ``symbol``.
  5167:    165: 
  5168:    166:         Results are cached to minimise HTTP requests. If the contract
  5169:    167:         information cannot be retrieved, ``(0, 0)`` is returned.
  5170:    168:         """
  5171:    169:         sym = self._format_symbol(symbol)
  5172:    170:         info = self._contract_cache.get(sym)
  5173:    171:         if info is None:
  5174:    172:             detail = self.get_contract_detail(sym)
  5175:    173:             try:
  5176:    174:                 data = detail.get("data", [])
  5177:    175:                 if isinstance(data, list) and data:
  5178:    176:                     info = data[0]
  5179:    177:                 else:
  5180:    178:                     info = {}
  5181:    179:             except Exception:
  5182:    180:                 info = {}
  5183:    181:             self._contract_cache[sym] = info
  5184:    182:         price_place = int(info.get("pricePlace") or 0)
  5185:    183:         volume_place = int(info.get("volumePlace") or 0)
  5186:    184:         return price_place, volume_place
  5187:    185: 
  5188:    186:     def get_kline(
  5189:    187:         self,
  5190:    188:         symbol: str,
  5191:    189:         interval: str = "1m",
  5192:    190:         start: Optional[int] = None,
  5193:    191:         end: Optional[int] = None,
  5194:    192:     ) -> Dict[str, Any]:
  5195:    193:         # Endpoint expects the trading pair in query parameters rather than
  5196:    194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
  5197:    195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
  5198:    196:         url = f"{self.base}/api/v2/mix/market/candles"
  5199:    197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
  5200:    198:         params: Dict[str, Any] = {
  5201:    199:             "symbol": self._format_symbol(symbol),
  5202:    200:             "productType": self.product_type,
  5203:    201:             "granularity": interval_norm,
  5204:    202:         }
  5205:    203:         if start is not None:
  5206:    204:             params["startTime"] = int(start)
  5207:    205:         if end is not None:
  5208:    206:             params["endTime"] = int(end)
  5209:    207:         r = self.requests.get(url, params=params, timeout=15)
  5210:    208:         r.raise_for_status()
  5211:    209:         data = r.json()
  5212:    210: 
  5213:    211:         rows = data.get("data") if isinstance(data, dict) else None
  5214:    212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
  5215:    213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  5216:    214:             for row in rows:
  5217:    215:                 if len(row) < 7:
  5218:    216:                     continue
  5219:    217:                 try:
  5220:    218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
  5221:    219:                     cols["ts"].append(int(ts))
  5222:    220:                     cols["open"].append(float(op))
  5223:    221:                     cols["high"].append(float(hi))
  5224:    222:                     cols["low"].append(float(lo))
  5225:    223:                     cols["close"].append(float(cl))
  5226:    224:                     cols["volume"].append(float(vol))
  5227:    225:                     cols["quoteVolume"].append(float(qv))
  5228:    226:                 except (TypeError, ValueError):
  5229:    227:                     continue
  5230:    228:             data["data"] = cols
  5231:    229:         elif isinstance(rows, list):
  5232:    230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  5233:    231:         return data
  5234:    232: 
  5235:    233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5236:    234:         if symbol:
  5237:    235:             url = f"{self.base}/api/v2/mix/market/ticker"
  5238:    236:             params = {
  5239:    237:                 "symbol": self._format_symbol(symbol),
  5240:    238:                 "productType": self.product_type,
  5241:    239:             }
  5242:    240:         else:
  5243:    241:             url = f"{self.base}/api/v2/mix/market/tickers"
  5244:    242:             params = {"productType": self.product_type}
  5245:    243:         r = self.requests.get(url, params=params, timeout=15)
  5246:    244:         r.raise_for_status()
  5247:    245:         return r.json()
  5248:    246: 
  5249:    247:     # ------------------------------------------------------------------
  5250:    248:     # Private endpoints
  5251:    249:     # ------------------------------------------------------------------
  5252:    250:     def _private_request(
  5253:    251:         self,
  5254:    252:         method: str,
  5255:    253:         path: str,
  5256:    254:         *,
  5257:    255:         params: Optional[Dict[str, Any]] = None,
  5258:    256:         body: Optional[Dict[str, Any]] = None,
  5259:    257:     ) -> Dict[str, Any]:
  5260:    258:         method = method.upper()
  5261:    259:         ts = self._ms()
  5262:    260: 
  5263:    261:         if method in ("GET", "DELETE"):
  5264:    262:             qs = self._urlencode_sorted(params or {})
  5265:    263:             req_path = path + (f"?{qs}" if qs else "")
  5266:    264:             sig = self._sign(f"{ts}{method}{req_path}")
  5267:    265:             headers = self._headers(sig, ts)
  5268:    266:             url = f"{self.base}{req_path}"
  5269:    267:             r = self.requests.request(method, url, headers=headers, timeout=20)
  5270:    268:         elif method == "POST":
  5271:    269:             qs = self._urlencode_sorted(params or {})
  5272:    270:             req_path = path + (f"?{qs}" if qs else "")
  5273:    271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
  5274:    272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
  5275:    273:             headers = self._headers(sig, ts)
  5276:    274:             url = f"{self.base}{req_path}"
  5277:    275:             r = self.requests.post(
  5278:    276:                 url,
  5279:    277:                 data=body_str.encode("utf-8"),
  5280:    278:                 headers=headers,
  5281:    279:                 timeout=20,
  5282:    280:             )
  5283:    281:         else:
  5284:    282:             raise ValueError("M\u00e9thode non support\u00e9e")
  5285:    283: 
  5286:    284:         resp_text = getattr(r, "text", "")
  5287:    285:         try:
  5288:    286:             data = r.json()
  5289:    287:         except Exception:
  5290:    288:             data = {
  5291:    289:                 "success": False,
  5292:    290:                 "error": resp_text,
  5293:    291:                 "status_code": getattr(r, "status_code", None),
  5294:    292:             }
  5295:    293: 
  5296:    294:         status = getattr(r, "status_code", 0)
  5297:    295:         if status >= 400:
  5298:    296:             code = str(data.get("code")) if isinstance(data, dict) else ""
  5299:    297:             if code == "22001":
  5300:    298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
  5301:    299:             else:
  5302:    300:                 try:
  5303:    301:                     r.raise_for_status()
  5304:    302:                 except Exception as e:
  5305:    303:                     if not resp_text:
  5306:    304:                         resp_text = getattr(r, "text", "") or str(e)
  5307:    305:                 logging.error(
  5308:    306:                     "Erreur HTTP/JSON %s %s -> %s %s",
  5309:    307:                     method,
  5310:    308:                     path,
  5311:    309:                     status,
  5312:    310:                     resp_text,
  5313:    311:                 )
  5314:    312:                 if isinstance(data, dict):
  5315:    313:                     data.setdefault("success", False)
  5316:    314:                     data.setdefault("status_code", status)
  5317:    315:                     data.setdefault("error", resp_text)
  5318:    316: 
  5319:    317:         self.log_event(
  5320:    318:             "http_private",
  5321:    319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
  5322:    320:         )
  5323:    321:         return data
  5324:    322: 
  5325:    323:     # Accounts & positions -------------------------------------------------
  5326:    324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
  5327:    325:         if self.paper_trade:
  5328:    326:             return {
  5329:    327:                 "success": True,
  5330:    328:                 "code": 0,
  5331:    329:                 "data": [
  5332:    330:                     {
  5333:    331:                         "currency": "USDT",
  5334:    332:                         "equity": 100.0,
  5335:    333:                     }
  5336:    334:                 ],
  5337:    335:             }
  5338:    336: 
  5339:    337:         params = {"productType": self.product_type}
  5340:    338:         if margin_coin is None:
  5341:    339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5342:    340:         if margin_coin:
  5343:    341:             params["marginCoin"] = margin_coin
  5344:    342:         data = self._private_request(
  5345:    343:             "GET", "/api/v2/mix/account/accounts", params=params
  5346:    344:         )
  5347:    345:         if isinstance(data, dict):
  5348:    346:             data.setdefault("success", str(data.get("code")) == "00000")
  5349:    347:         try:
  5350:    348:             for row in data.get("data", []):
  5351:    349:                 if "currency" not in row and row.get("marginCoin"):
  5352:    350:                     row["currency"] = str(row["marginCoin"]).upper()
  5353:    351:                 chosen = None
  5354:    352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
  5355:    353:                     val = row.get(key)
  5356:    354:                     if val is not None:
  5357:    355:                         chosen = val
  5358:    356:                         break
  5359:    357:                 if chosen is not None:
  5360:    358:                     row["equity"] = chosen
  5361:    359:                 try:
  5362:    360:                     row["equity"] = float(row["equity"])
  5363:    361:                 except Exception:
  5364:    362:                     pass
  5365:    363:         except Exception:  # pragma: no cover - best effort
  5366:    364:             pass
  5367:    365:         return data
  5368:    366: 
  5369:    367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  5370:    368:         if self.paper_trade:
  5371:    369:             return {"success": True, "code": 0, "data": []}
  5372:    370:         data = self._private_request(
  5373:    371:             "GET",
  5374:    372:             "/api/v2/mix/position/all-position",
  5375:    373:             params={"productType": self._product_type(product_type)},
  5376:    374:         )
  5377:    375:         try:
  5378:    376:             positions = data.get("data", [])
  5379:    377:             filtered = []
  5380:    378:             for pos in positions:
  5381:    379:                 vol = pos.get("vol")
  5382:    380:                 try:
  5383:    381:                     if vol is not None and float(vol) > 0:
  5384:    382:                         filtered.append(pos)
  5385:    383:                 except (TypeError, ValueError):
  5386:    384:                     continue
  5387:    385:             data["data"] = filtered
  5388:    386:         except Exception:  # pragma: no cover - best effort
  5389:    387:             pass
  5390:    388:         return data
  5391:    389: 
  5392:    390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5393:    391:         if self.paper_trade:
  5394:    392:             return {"success": True, "code": 0, "data": []}
  5395:    393:         params: Dict[str, Any] = {"productType": self.product_type}
  5396:    394:         if symbol:
  5397:    395:             params["symbol"] = self._format_symbol(symbol)
  5398:    396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
  5399:    397: 
  5400:    398:     # Account configuration -------------------------------------------------
  5401:    399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
  5402:    400:         body = {
  5403:    401:             "productType": self._product_type(product_type),
  5404:    402:             "symbol": self._format_symbol(symbol),
  5405:    403:             "posMode": "one_way_mode",
  5406:    404:         }
  5407:    405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
  5408:    406: 
  5409:    407:     def set_leverage(
  5410:    408:         self,
  5411:    409:         symbol: str,
  5412:    410:         product_type: Optional[str] = None,
  5413:    411:         margin_coin: str = "USDT",
  5414:    412:         leverage: int = 1,
  5415:    413:     ) -> Dict[str, Any]:
  5416:    414:         body = {
  5417:    415:             "symbol": self._format_symbol(symbol),
  5418:    416:             "productType": self._product_type(product_type),
  5419:    417:             "marginCoin": margin_coin,
  5420:    418:             "leverage": int(leverage),
  5421:    419:         }
  5422:    420:         return self._private_request(
  5423:    421:             "POST", "/api/v2/mix/account/set-leverage", body=body
  5424:    422:         )
  5425:    423: 
  5426:    424:     def place_market_order_one_way(
  5427:    425:         self,
  5428:    426:         symbol: str,
  5429:    427:         side: str,
  5430:    428:         size: float,
  5431:    429:         product_type: Optional[str] = None,
  5432:    430:         margin_coin: str = "USDT",
  5433:    431:         *,
  5434:    432:         time_in_force: str = "normal",
  5435:    433:     ) -> Dict[str, Any]:
  5436:    434:         side = side.lower()
  5437:    435:         if side not in {"buy", "sell"}:
  5438:    436:             raise ValueError("side must be 'buy' or 'sell'")
  5439:    437:         body = {
  5440:    438:             "symbol": self._format_symbol(symbol),
  5441:    439:             "productType": self._product_type(product_type),
  5442:    440:             "marginCoin": margin_coin,
  5443:    441:             "marginMode": "crossed",
  5444:    442:             "posMode": "one_way_mode",
  5445:    443:             "orderType": "market",
  5446:    444:             "side": side,
  5447:    445:             "size": str(size),
  5448:    446:             "timeInForceValue": time_in_force,
  5449:    447:             "clientOid": str(uuid.uuid4())[:32],
  5450:    448:         }
  5451:    449:         return self._private_request(
  5452:    450:             "POST", "/api/v2/mix/order/place-order", body=body
  5453:    451:         )
  5454:    452: 
  5455:    453:     # Orders ---------------------------------------------------------------
  5456:    454:     def place_order(
  5457:    455:         self,
  5458:    456:         symbol: str,
  5459:    457:         side: int,
  5460:    458:         vol: int,
  5461:    459:         order_type: int,
  5462:    460:         *,
  5463:    461:         price: Optional[float] = None,
  5464:    462:         open_type: int = 1,
  5465:    463:         leverage: Optional[int] = None,
  5466:    464:         position_id: Optional[int] = None,
  5467:    465:         external_oid: Optional[str] = None,
  5468:    466:         stop_loss: Optional[float] = None,
  5469:    467:         take_profit: Optional[float] = None,
  5470:    468:         position_mode: Optional[int] = None,
  5471:    469:         margin_coin: Optional[str] = None,
  5472:    470:         time_in_force: str = "normal",
  5473:    471:     ) -> Dict[str, Any]:
  5474:    472:         """Submit an order.
  5475:    473: 
  5476:    474:         This helper keeps backward compatibility with the older numeric
  5477:    475:         parameters used by the bot while translating them to the string based
  5478:    476:         fields required by Bitget's v2 API.
  5479:    477:         """
  5480:    478:         if self.paper_trade:
  5481:    479:             logging.info(
  5482:    480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
  5483:    481:                 side,
  5484:    482:                 vol,
  5485:    483:                 order_type,
  5486:    484:                 price,
  5487:    485:             )
  5488:    486:             return {
  5489:    487:                 "success": True,
  5490:    488:                 "paperTrade": True,
  5491:    489:                 "simulated": {
  5492:    490:                     "symbol": symbol,
  5493:    491:                     "side": side,
  5494:    492:                     "vol": vol,
  5495:    493:                     "type": order_type,
  5496:    494:                     "price": price,
  5497:    495:                     "openType": open_type,
  5498:    496:                     "leverage": leverage,
  5499:    497:                     "stopLossPrice": stop_loss,
  5500:    498:                     "takeProfitPrice": take_profit,
  5501:    499:                 },
  5502:    500:             }
  5503:    501: 
  5504:    502:         # ------------------------------------------------------------------
  5505:    503:         # Parameter mapping
  5506:    504:         # ------------------------------------------------------------------
  5507:    505:         side_map = {
  5508:    506:             1: ("buy", "long"),
  5509:    507:             2: ("buy", "short"),
  5510:    508:             3: ("sell", "short"),
  5511:    509:             4: ("sell", "long"),
  5512:    510:         }
  5513:    511:         if isinstance(side, int):
  5514:    512:             mapped = side_map.get(side)
  5515:    513:             if not mapped:
  5516:    514:                 raise ValueError(f"Invalid side value: {side}")
  5517:    515:             side_str, pos_side = mapped
  5518:    516:         else:
  5519:    517:             side_str = str(side)
  5520:    518:             pos_side = None
  5521:    519: 
  5522:    520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
  5523:    521:         if isinstance(order_type, int):
  5524:    522:             order_str = order_map.get(order_type)
  5525:    523:             if order_str is None:
  5526:    524:                 order_str = "limit" if price is not None else "market"
  5527:    525:         else:
  5528:    526:             order_str = str(order_type)
  5529:    527: 
  5530:    528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
  5531:    529: 
  5532:    530:         if margin_coin is None:
  5533:    531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5534:    532: 
  5535:    533:         # ------------------------------------------------------------------
  5536:    534:         # Precision handling
  5537:    535:         # ------------------------------------------------------------------
  5538:    536:         try:
  5539:    537:             price_place, volume_place = self._get_contract_precision(symbol)
  5540:    538:         except Exception:  # pragma: no cover - best effort
  5541:    539:             price_place = volume_place = 0
  5542:    540:         if price is not None:
  5543:    541:             price = round(float(price), price_place)
  5544:    542:         if vol is not None:
  5545:    543:             vol = round(float(vol), volume_place)
  5546:    544: 
  5547:    545:         body = {
  5548:    546:             "symbol": self._format_symbol(symbol),
  5549:    547:             "productType": self.product_type,
  5550:    548:             "marginMode": margin_mode,
  5551:    549:             "orderType": order_str,
  5552:    550:             "side": side_str,
  5553:    551:             "size": vol,
  5554:    552:             "timeInForceValue": time_in_force,
  5555:    553:         }
  5556:    554:         if pos_side is not None:
  5557:    555:             body["posSide"] = pos_side
  5558:    556:         if margin_coin:
  5559:    557:             body["marginCoin"] = margin_coin
  5560:    558:         if price is not None:
  5561:    559:             body["price"] = float(price)
  5562:    560:         if leverage is not None:
  5563:    561:             body["leverage"] = int(leverage)
  5564:    562:         if position_id is not None:
  5565:    563:             body["positionId"] = int(position_id)
  5566:    564:         if external_oid:
  5567:    565:             body["clientOid"] = str(external_oid)[:32]
  5568:    566:         else:
  5569:    567:             body["clientOid"] = str(uuid.uuid4())[:32]
  5570:    568:         if stop_loss is not None:
  5571:    569:             body["stopLossPrice"] = float(stop_loss)
  5572:    570:         if take_profit is not None:
  5573:    571:             body["takeProfitPrice"] = float(take_profit)
  5574:    572:         if position_mode is not None:
  5575:    573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
  5576:    574:         elif pos_side is not None:
  5577:    575:             body["posMode"] = "hedge_mode"
  5578:    576: 
  5579:    577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
  5580:    578: 
  5581:    579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
  5582:    580:         if self.paper_trade:
  5583:    581:             logging.info(
  5584:    582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
  5585:    583:             )
  5586:    584:             return {"success": True, "code": 0}
  5587:    585:         return self._private_request(
  5588:    586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
  5589:    587:         )
  5590:    588: 
  5591:    589:     def cancel_all(
  5592:    590:         self,
  5593:    591:         symbol: Optional[str] = None,
  5594:    592:         margin_coin: Optional[str] = None,
  5595:    593:     ) -> Dict[str, Any]:
  5596:    594:         if self.paper_trade:
  5597:    595:             logging.info(
  5598:    596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
  5599:    597:             )
  5600:    598:             return {"success": True, "code": 0}
  5601:    599:         body = {"productType": self.product_type}
  5602:    600:         if symbol:
  5603:    601:             body["symbol"] = self._format_symbol(symbol)
  5604:    602:         if margin_coin is None:
  5605:    603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5606:    604:         if margin_coin:
  5607:    605:             body["marginCoin"] = margin_coin
  5608:    606:         return self._private_request(
  5609:    607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
  5610:    608:         )
  5611:    609: 
  5612:    610:     def close_position(
  5613:    611:         self,
  5614:    612:         symbol: str,
  5615:    613:         size: Optional[int] = None,
  5616:    614:         hold_side: Optional[str] = None,
  5617:    615:     ) -> Dict[str, Any]:
  5618:    616:         """Close an open position for ``symbol``.
  5619:    617: 
  5620:    618:         Parameters
  5621:    619:         ----------
  5622:    620:         symbol:
  5623:    621:             Trading symbol to close.
  5624:    622:         size:
  5625:    623:             Optional number of contracts to close. If omitted the entire
  5626:    624:             position is closed.
  5627:    625:         hold_side:
  5628:    626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
  5629:    627:             specified. If not provided the exchange will infer it.
  5630:    628:         """
  5631:    629: 
  5632:    630:         if self.paper_trade:
  5633:    631:             logging.info(
  5634:    632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
  5635:    633:             )
  5636:    634:             return {"success": True, "code": 0}
  5637:    635: 
  5638:    636:         body = {"symbol": self._format_symbol(symbol)}
  5639:    637:         if size is not None:
  5640:    638:             body["size"] = int(size)
  5641:    639:         if hold_side:
  5642:    640:             body["holdSide"] = hold_side
  5643:    641: 
  5644:    642:         body["productType"] = self.product_type
  5645:    643:         return self._private_request(
  5646:    644:             "POST", "/api/v2/mix/position/close-position", body=body
  5647:    645:         )
  5648:    646: 
  5649:    647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  5650:    648:         """Close all open positions."""
  5651:    649:         results = []
  5652:    650:         try:
  5653:    651:             for pos in self.get_positions(product_type).get("data", []):
  5654:    652:                 sym = pos.get("symbol")
  5655:    653:                 if sym:
  5656:    654:                     results.append(self.close_position(sym))
  5657:    655:         except Exception as exc:  # pragma: no cover - best effort
  5658:    656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
  5659:    657:         return {"success": True, "data": results}
  5660: 
  5661: 
  5662: ## scalper/client.py (last modified: 2025-08-23 20:57:14)
  5663:      1: import logging
  5664:      2: from typing import Any, Dict, Optional
  5665:      3: 
  5666:      4: import requests
  5667:      5: from requests.adapters import HTTPAdapter
  5668:      6: from urllib3.util.retry import Retry
  5669:      7: 
  5670:      8: 
  5671:      9: class HTTPError(RuntimeError):
  5672:     10:     """Raised when an HTTP request fails"""
  5673:     11: 
  5674:     12: 
  5675:     13: class HttpClient:
  5676:     14:     """Simple HTTP client with persistent session and retry logic.
  5677:     15: 
  5678:     16:     The client exposes a :py:meth:`close` method and implements the context
  5679:     17:     manager protocol so it can be used with ``with`` statements to ensure
  5680:     18:     that the underlying :class:`requests.Session` is properly closed.
  5681:     19:     """
  5682:     20: 
  5683:     21:     def __init__(
  5684:     22:         self,
  5685:     23:         base_url: str,
  5686:     24:         *,
  5687:     25:         timeout: float = 10.0,
  5688:     26:         max_retries: int = 3,
  5689:     27:         backoff_factor: float = 0.3,
  5690:     28:         status_forcelist: Optional[list[int]] = None,
  5691:     29:     ) -> None:
  5692:     30:         self.base_url = base_url.rstrip("/")
  5693:     31:         self.timeout = timeout
  5694:     32:         self.session = requests.Session()
  5695:     33:         retry = Retry(
  5696:     34:             total=max_retries,
  5697:     35:             backoff_factor=backoff_factor,
  5698:     36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
  5699:     37:             allowed_methods=[
  5700:     38:                 "HEAD",
  5701:     39:                 "GET",
  5702:     40:                 "OPTIONS",
  5703:     41:                 "POST",
  5704:     42:                 "PUT",
  5705:     43:                 "DELETE",
  5706:     44:                 "PATCH",
  5707:     45:             ],
  5708:     46:         )
  5709:     47:         adapter = HTTPAdapter(max_retries=retry)
  5710:     48:         self.session.mount("http://", adapter)
  5711:     49:         self.session.mount("https://", adapter)
  5712:     50: 
  5713:     51:     def close(self) -> None:
  5714:     52:         """Close the underlying :class:`requests.Session`."""
  5715:     53:         self.session.close()
  5716:     54: 
  5717:     55:     # ------------------------------------------------------------------
  5718:     56:     # Context manager support
  5719:     57:     # ------------------------------------------------------------------
  5720:     58:     def __enter__(self) -> "HttpClient":
  5721:     59:         return self
  5722:     60: 
  5723:     61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
  5724:     62:         self.close()
  5725:     63: 
  5726:     64:     def request(
  5727:     65:         self,
  5728:     66:         method: str,
  5729:     67:         path: str,
  5730:     68:         *,
  5731:     69:         params: Optional[Dict[str, Any]] = None,
  5732:     70:         json: Optional[Dict[str, Any]] = None,
  5733:     71:         headers: Optional[Dict[str, str]] = None,
  5734:     72:     ) -> Dict[str, Any]:
  5735:     73:         """Perform an HTTP request and return JSON data.
  5736:     74: 
  5737:     75:         Errors during the request raise ``HTTPError``. If the response cannot
  5738:     76:         be decoded as JSON, a dictionary describing the issue is returned.
  5739:     77:         """
  5740:     78:         url = f"{self.base_url}{path}"
  5741:     79:         try:
  5742:     80:             resp = self.session.request(
  5743:     81:                 method,
  5744:     82:                 url,
  5745:     83:                 params=params,
  5746:     84:                 json=json,
  5747:     85:                 headers=headers,
  5748:     86:                 timeout=self.timeout,
  5749:     87:             )
  5750:     88:             resp.raise_for_status()
  5751:     89:         except requests.RequestException as exc:  # network or HTTP errors
  5752:     90:             msg = f"HTTP error calling {url}: {exc}"
  5753:     91:             logging.error(msg)
  5754:     92:             raise HTTPError(msg) from exc
  5755:     93: 
  5756:     94:         try:
  5757:     95:             return resp.json()
  5758:     96:         except ValueError:  # invalid JSON
  5759:     97:             msg = "Invalid JSON in response"
  5760:     98:             logging.error("%s for %s: %s", msg, url, resp.text)
  5761:     99:             return {"success": False, "error": msg, "text": resp.text}
  5762: 
  5763: 
  5764: ## scalper/config/__init__.py (last modified: 2025-08-23 20:57:14)
  5765:      1: from .loader import load_settings
  5766:      2: __all__ = ['load_settings']
  5767: 
  5768: 
  5769: ## scalper/config/loader.py (last modified: 2025-08-23 20:57:14)
  5770:      1: # scalp/config/loader.py
  5771:      2: from __future__ import annotations
  5772:      3: import os, json
  5773:      4: from typing import Any, Dict, Tuple
  5774:      5: 
  5775:      6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
  5776:      7: try:
  5777:      8:     import yaml  # type: ignore
  5778:      9: except Exception:
  5779:     10:     yaml = None  # fallback JSON si besoin
  5780:     11: 
  5781:     12: # dotenv (facultatif) pour charger un .env automatiquement
  5782:     13: try:
  5783:     14:     from dotenv import load_dotenv  # type: ignore
  5784:     15: except Exception:
  5785:     16:     load_dotenv = None
  5786:     17: 
  5787:     18: # ---------------- Utils ----------------
  5788:     19: 
  5789:     20: def _parse_bool(x: Any, default: bool = False) -> bool:
  5790:     21:     if isinstance(x, bool): return x
  5791:     22:     s = str(x).strip().lower()
  5792:     23:     if s in ("1","true","yes","y","on"): return True
  5793:     24:     if s in ("0","false","no","n","off",""): return False
  5794:     25:     return default
  5795:     26: 
  5796:     27: def _parse_float(x: Any, default: float | None = None) -> float | None:
  5797:     28:     try: return float(x)
  5798:     29:     except Exception: return default
  5799:     30: 
  5800:     31: def _parse_int(x: Any, default: int | None = None) -> int | None:
  5801:     32:     try: return int(str(x).strip())
  5802:     33:     except Exception: return default
  5803:     34: 
  5804:     35: def _parse_csv(x: Any) -> list[str]:
  5805:     36:     if x is None: return []
  5806:     37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
  5807:     38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
  5808:     39: 
  5809:     40: def _read_yaml(path: str) -> Dict[str, Any]:
  5810:     41:     if not os.path.exists(path): return {}
  5811:     42:     with open(path, "r", encoding="utf-8") as f:
  5812:     43:         if yaml:
  5813:     44:             return yaml.safe_load(f) or {}
  5814:     45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
  5815:     46:         try:
  5816:     47:             return json.load(f)
  5817:     48:         except Exception:
  5818:     49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
  5819:     50: 
  5820:     51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
  5821:     52:     # shallow merge suffisant ici (structure plate)
  5822:     53:     out = dict(a)
  5823:     54:     out.update({k: v for k, v in b.items() if v is not None})
  5824:     55:     return out
  5825:     56: 
  5826:     57: # ---------------- Public API ----------------
  5827:     58: 
  5828:     59: def load_settings(
  5829:     60:     config_path: str = "config.yml",
  5830:     61:     config_local_path: str = "config.local.yml",
  5831:     62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
  5832:     63:     """
  5833:     64:     Retourne (config_runtime, secrets) :
  5834:     65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
  5835:     66:       - secrets        : clés API & tokens (NE PAS versionner)
  5836:     67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
  5837:     68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
  5838:     69:     """
  5839:     70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
  5840:     71:     if load_dotenv is not None:
  5841:     72:         load_dotenv(override=False)
  5842:     73: 
  5843:     74:     # 2) Charge YAML (config.yml + override local)
  5844:     75:     base = _read_yaml(config_path)
  5845:     76:     local = _read_yaml(config_local_path)
  5846:     77:     cfg = _merge_dict(base, local)
  5847:     78: 
  5848:     79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
  5849:     80:     env_overlay: Dict[str, Any] = {}
  5850:     81:     # Verbosité
  5851:     82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
  5852:     83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
  5853:     84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
  5854:     85:     # Runtime / Stratégie
  5855:     86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
  5856:     87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
  5857:     88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
  5858:     89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
  5859:     90:     # Watchlist
  5860:     91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
  5861:     92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
  5862:     93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
  5863:     94:     )
  5864:     95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
  5865:     96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
  5866:     97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
  5867:     98:     caps_env = os.getenv("CAPS_JSON")
  5868:     99:     if caps_env:
  5869:    100:         try:
  5870:    101:             env_overlay["CAPS"] = json.loads(caps_env)
  5871:    102:         except Exception:
  5872:    103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
  5873:    104:     else:
  5874:    105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
  5875:    106: 
  5876:    107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
  5877:    108:     secrets = {
  5878:    109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
  5879:    110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
  5880:    111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
  5881:    112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
  5882:    113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
  5883:    114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
  5884:    115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
  5885:    116:     }
  5886:    117: 
  5887:    118:     # 5) Runtime normalisé pour l’orchestrateur
  5888:    119:     runtime = {
  5889:    120:         "quiet": bool(env_overlay["QUIET"]),
  5890:    121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
  5891:    122:         "timeframe": str(env_overlay["TIMEFRAME"]),
  5892:    123:         "cash": float(env_overlay["CASH"]),
  5893:    124:         "risk_pct": float(env_overlay["RISK_PCT"]),
  5894:    125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
  5895:    126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
  5896:    127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
  5897:    128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
  5898:    129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
  5899:    130:         "caps": env_overlay["CAPS"],                        # dict
  5900:    131:         # rempli au boot par les frais Bitget
  5901:    132:         "fees_by_symbol": {}, 
  5902:    133:     }
  5903:    134: 
  5904:    135:     return runtime, secrets
  5905:    136:     
  5906: 
  5907: ## scalper/exchange/__init__.py (last modified: 2025-08-23 20:57:14)
  5908:      1: # package
  5909: 
  5910: 
  5911: ## scalper/exchange/bitget_ccxt.py (last modified: 2025-08-23 20:57:14)
  5912:      1: # scalper/exchange/bitget_ccxt.py
  5913:      2: from __future__ import annotations
  5914:      3: 
  5915:      4: import asyncio
  5916:      5: import csv
  5917:      6: import os
  5918:      7: import time
  5919:      8: from typing import Any, List, Optional
  5920:      9: 
  5921:     10: # CCXT async
  5922:     11: try:
  5923:     12:     import ccxt.async_support as ccxt
  5924:     13: except Exception as e:  # noqa: BLE001
  5925:     14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
  5926:     15: 
  5927:     16: 
  5928:     17: def _now_ms() -> int:
  5929:     18:     return int(time.time() * 1000)
  5930:     19: 
  5931:     20: 
  5932:     21: class BitgetExchange:
  5933:     22:     """
  5934:     23:     Échange Bitget via CCXT (async) avec cache CSV local.
  5935:     24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
  5936:     25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
  5937:     26:         [[ts, open, high, low, close, volume], ...]
  5938:     27:     """
  5939:     28: 
  5940:     29:     def __init__(
  5941:     30:         self,
  5942:     31:         *,
  5943:     32:         api_key: Optional[str] = None,
  5944:     33:         secret: Optional[str] = None,
  5945:     34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
  5946:     35:         data_dir: str = "/notebooks/data",
  5947:     36:         use_cache: bool = True,
  5948:     37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
  5949:     38:         spot: bool = True,           # True = SPOT (recommandé ici)
  5950:     39:     ) -> None:
  5951:     40:         self.data_dir = data_dir
  5952:     41:         self.use_cache = use_cache
  5953:     42:         self.min_fresh = int(min_fresh_seconds)
  5954:     43:         self.spot = spot
  5955:     44: 
  5956:     45:         os.makedirs(self.data_dir, exist_ok=True)
  5957:     46: 
  5958:     47:         # Instance CCXT (async)
  5959:     48:         self.ex = ccxt.bitget({
  5960:     49:             "apiKey": api_key or "",
  5961:     50:             "secret": secret or "",
  5962:     51:             "password": password or "",
  5963:     52:             "enableRateLimit": True,
  5964:     53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
  5965:     54:         })
  5966:     55: 
  5967:     56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
  5968:     57:         self._markets_task: Optional[asyncio.Task[Any]] = None
  5969:     58: 
  5970:     59:     async def _ensure_markets(self) -> None:
  5971:     60:         if self._markets_task is None:
  5972:     61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
  5973:     62:         await self._markets_task
  5974:     63: 
  5975:     64:     # ---------- CSV cache ----------
  5976:     65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
  5977:     66:         safe = symbol.replace("/", "").replace(":", "")
  5978:     67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
  5979:     68: 
  5980:     69:     def _read_cache(self, path: str) -> List[List[float]]:
  5981:     70:         if not os.path.exists(path):
  5982:     71:             return []
  5983:     72:         rows: List[List[float]] = []
  5984:     73:         try:
  5985:     74:             with open(path, "r", newline="") as f:
  5986:     75:                 rd = csv.reader(f)
  5987:     76:                 for r in rd:
  5988:     77:                     if not r:
  5989:     78:                         continue
  5990:     79:                     # ts, o, h, l, c, v
  5991:     80:                     try:
  5992:     81:                         rows.append([
  5993:     82:                             int(r[0]),
  5994:     83:                             float(r[1]),
  5995:     84:                             float(r[2]),
  5996:     85:                             float(r[3]),
  5997:     86:                             float(r[4]),
  5998:     87:                             float(r[5]),
  5999:     88:                         ])
  6000:     89:                     except Exception:
  6001:     90:                         # on ignore les lignes corrompues
  6002:     91:                         continue
  6003:     92:         except Exception:
  6004:     93:             return []
  6005:     94:         return rows
  6006:     95: 
  6007:     96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
  6008:     97:         # On ré‑écrit intégralement (simple et sûr)
  6009:     98:         tmp = path + ".tmp"
  6010:     99:         with open(tmp, "w", newline="") as f:
  6011:    100:             wr = csv.writer(f)
  6012:    101:             wr.writerows(data)
  6013:    102:         os.replace(tmp, path)
  6014:    103: 
  6015:    104:     # ---------- API publique pour orchestrateur ----------
  6016:    105:     async def fetch_ohlcv(
  6017:    106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
  6018:    107:     ) -> List[List[float]]:
  6019:    108:         """
  6020:    109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
  6021:    110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
  6022:    111:         """
  6023:    112:         await self._ensure_markets()
  6024:    113: 
  6025:    114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
  6026:    115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
  6027:    116:         cache_path = self._csv_path(symbol, timeframe)
  6028:    117: 
  6029:    118:         # 1) Cache
  6030:    119:         if self.use_cache:
  6031:    120:             cached = self._read_cache(cache_path)
  6032:    121:             if cached:
  6033:    122:                 # fraicheur = diff entre maintenant et ts dernière bougie
  6034:    123:                 last_ts = int(cached[-1][0])
  6035:    124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
  6036:    125:                     # suffisant => on retourne la fin
  6037:    126:                     if len(cached) >= limit:
  6038:    127:                         return cached[-limit:]
  6039:    128:                     # pas assez, on essaiera de compléter via CCXT plus bas
  6040:    129:                 # sinon: on tentera de rafraîchir plus loin
  6041:    130: 
  6042:    131:         # 2) Remote via CCXT
  6043:    132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
  6044:    133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
  6045:    134:         params: dict[str, Any] = {}
  6046:    135:         if self.spot is True:
  6047:    136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
  6048:    137: 
  6049:    138:         try:
  6050:    139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
  6051:    140:         except Exception as e:  # noqa: BLE001
  6052:    141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
  6053:    142:             cached = self._read_cache(cache_path) if self.use_cache else []
  6054:    143:             if cached:
  6055:    144:                 return cached[-limit:]
  6056:    145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
  6057:    146: 
  6058:    147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
  6059:    148:         if self.use_cache:
  6060:    149:             base = self._read_cache(cache_path)
  6061:    150:             merged = _merge_ohlcv(base, ohlcv)
  6062:    151:             self._write_cache(cache_path, merged)
  6063:    152:             # retourne la fin
  6064:    153:             return merged[-limit:]
  6065:    154: 
  6066:    155:         return ohlcv[-limit:]
  6067:    156: 
  6068:    157:     async def close(self) -> None:
  6069:    158:         try:
  6070:    159:             await self.ex.close()
  6071:    160:         except Exception:
  6072:    161:             pass
  6073:    162: 
  6074:    163: 
  6075:    164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
  6076:    165:     """
  6077:    166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
  6078:    167:     """
  6079:    168:     if not a:
  6080:    169:         return list(b)
  6081:    170:     if not b:
  6082:    171:         return list(a)
  6083:    172: 
  6084:    173:     # index rapide par ts
  6085:    174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
  6086:    175:     for row in b:
  6087:    176:         by_ts[int(row[0])] = row
  6088:    177:     return [by_ts[k] for k in sorted(by_ts)]
  6089: 
  6090: ## scalper/exchange/fees.py (last modified: 2025-08-23 20:57:14)
  6091:      1: # scalper/exchange/fees.py
  6092:      2: from __future__ import annotations
  6093:      3: 
  6094:      4: from typing import Dict, Iterable
  6095:      5: 
  6096:      6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
  6097:      7: DEFAULT_TAKER_BPS = 6    # 0.06%
  6098:      8: DEFAULT_MAKER_BPS = 2    # 0.02%
  6099:      9: 
  6100:     10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
  6101:     11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
  6102:     12: 
  6103:     13: 
  6104:     14: def get_fee(symbol: str, kind: str = "taker") -> float:
  6105:     15:     """
  6106:     16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
  6107:     17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
  6108:     18:     """
  6109:     19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
  6110:     20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
  6111:     21:     return float(bps) / 10_000.0
  6112:     22: 
  6113:     23: 
  6114:     24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
  6115:     25:     """
  6116:     26:     Tente de charger les frais auprès de l'exchange (type ccxt):
  6117:     27:       - fetch_trading_fees(symbols) si dispo
  6118:     28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
  6119:     29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
  6120:     30:     """
  6121:     31:     symbols = list(symbols)
  6122:     32:     fees: Dict[str, Dict[str, float]] = {}
  6123:     33: 
  6124:     34:     try:
  6125:     35:         if hasattr(exchange, "fetch_trading_fees"):
  6126:     36:             data = await exchange.fetch_trading_fees(symbols)
  6127:     37:             for s in symbols:
  6128:     38:                 d = (data or {}).get(s, {}) or {}
  6129:     39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  6130:     40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  6131:     41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  6132:     42:         else:
  6133:     43:             for s in symbols:
  6134:     44:                 try:
  6135:     45:                     d = await exchange.fetch_trading_fee(s)
  6136:     46:                 except Exception:
  6137:     47:                     d = {}
  6138:     48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  6139:     49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  6140:     50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  6141:     51:     except Exception:
  6142:     52:         # fallback: défauts
  6143:     53:         for s in symbols:
  6144:     54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
  6145:     55: 
  6146:     56:     # maj du cache
  6147:     57:     _FEES_BY_SYMBOL.update(fees)
  6148:     58:     return fees
  6149: 
  6150: ## scalper/hooks/prewarm_cache.py (last modified: 2025-08-24 03:12:00)
  6151:      1: # -*- coding: utf-8 -*-
  6152:      2: """
  6153:      3: Pré-chauffe léger du cache OHLCV.
  6154:      4: 
  6155:      5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
  6156:      6: pour chaque symbole, et on s'assure que le dossier data existe.
  6157:      7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
  6158:      8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
  6159:      9: signature.
  6160:     10: """
  6161:     11: from __future__ import annotations
  6162:     12: from pathlib import Path
  6163:     13: from typing import Iterable
  6164:     14: 
  6165:     15: 
  6166:     16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
  6167:     17:     out = Path(out_dir)
  6168:     18:     out.mkdir(parents=True, exist_ok=True)
  6169:     19:     for sym in symbols:
  6170:     20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
  6171:     21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
  6172:     22:         print(f"[cache] warmup OK for {sym}")
  6173: 
  6174: ## scalper/live/__init__.py (last modified: 2025-08-24 03:12:00)
  6175:      1: from .orchestrator import RunConfig, Orchestrator, run_orchestrator  # re‑exports
  6176:      2: from .notify import build_notifier_and_commands  # utile pour bot.py
  6177: 
  6178: ## scalper/live/backtest_telegram.py (last modified: 2025-08-23 20:57:14)
  6179:      1: # scalper/live/backtest_telegram.py
  6180:      2: from __future__ import annotations
  6181:      3: 
  6182:      4: import asyncio
  6183:      5: import os
  6184:      6: from typing import List
  6185:      7: 
  6186:      8: from scalper.backtest import BTCfg, run_multi
  6187:      9: from scalper.services.utils import safe_call
  6188:     10: 
  6189:     11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
  6190:     12: async def _get_exchange():
  6191:     13:     try:
  6192:     14:         import ccxt.async_support as ccxt  # type: ignore
  6193:     15:     except Exception:
  6194:     16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
  6195:     17:     return ccxt.bitget()
  6196:     18: 
  6197:     19: def _parse_symbols(defaults: List[str]) -> List[str]:
  6198:     20:     env = os.getenv("BACKTEST_SYMBOLS", "")
  6199:     21:     if env.strip():
  6200:     22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
  6201:     23:     return defaults
  6202:     24: 
  6203:     25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
  6204:     26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
  6205:     27:     symbols = _parse_symbols(defaults)
  6206:     28:     cash = float(os.getenv("BT_CASH", "10000"))
  6207:     29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
  6208:     30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
  6209:     31:     limit = int(os.getenv("BT_LIMIT", "1500"))
  6210:     32: 
  6211:     33:     await notifier.send(
  6212:     34:         "🧪 Backtest en cours...\n"
  6213:     35:         f"• Symbols: {', '.join(symbols)}\n"
  6214:     36:         f"• TF: {timeframe}\n"
  6215:     37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
  6216:     38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
  6217:     39:     )
  6218:     40: 
  6219:     41:     async def _run():
  6220:     42:         exchange = await _get_exchange()
  6221:     43:         try:
  6222:     44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
  6223:     45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
  6224:     46:             res = await run_multi(cfg, exchange)
  6225:     47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
  6226:     48:         finally:
  6227:     49:             try:
  6228:     50:                 await exchange.close()
  6229:     51:             except Exception:
  6230:     52:                 pass
  6231:     53: 
  6232:     54:     try:
  6233:     55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
  6234:     56:     except Exception as e:
  6235:     57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")
  6236: 
  6237: ## scalper/live/commands.py (last modified: 2025-08-23 20:57:14)
  6238:      1: # scalper/live/commands.py
  6239:      2: from __future__ import annotations
  6240:      3: 
  6241:      4: import asyncio
  6242:      5: from typing import Awaitable, Callable
  6243:      6: 
  6244:      7: 
  6245:      8: class CommandHandler:
  6246:      9:     """
  6247:     10:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
  6248:     11:     Chaque commande est routée vers un callback approprié.
  6249:     12:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
  6250:     13:     """
  6251:     14: 
  6252:     15:     def __init__(self, notifier, command_stream, status_getter, status_sender):
  6253:     16:         self.notifier = notifier
  6254:     17:         self.stream = command_stream
  6255:     18:         self.status_getter = status_getter
  6256:     19:         self.status_sender = status_sender
  6257:     20: 
  6258:     21:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
  6259:     22:         try:
  6260:     23:             await coro
  6261:     24:         except Exception as e:
  6262:     25:             try:
  6263:     26:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
  6264:     27:             except Exception:
  6265:     28:                 pass  # on ne propage jamais
  6266:     29: 
  6267:     30:     async def run(
  6268:     31:         self,
  6269:     32:         on_pause: Callable[[], None],
  6270:     33:         on_resume: Callable[[], None],
  6271:     34:         on_stop: Callable[[], Awaitable[None]] | None,
  6272:     35:         on_setup_apply: Callable[[dict], None],
  6273:     36:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
  6274:     37:     ):
  6275:     38:         """
  6276:     39:         Boucle asynchrone qui lit les lignes du CommandStream
  6277:     40:         et exécute le callback approprié.
  6278:     41:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
  6279:     42:         """
  6280:     43:         async for line in self.stream:
  6281:     44:             txt = (line or "").strip()
  6282:     45:             if not txt:
  6283:     46:                 continue
  6284:     47: 
  6285:     48:             try:
  6286:     49:                 if txt.startswith("/pause"):
  6287:     50:                     on_pause()
  6288:     51:                     await self.notifier.send("⏸️ Pause.")
  6289:     52: 
  6290:     53:                 elif txt.startswith("/resume"):
  6291:     54:                     on_resume()
  6292:     55:                     await self.notifier.send("▶️ Resume.")
  6293:     56: 
  6294:     57:                 elif txt.startswith("/stop"):
  6295:     58:                     if on_stop:
  6296:     59:                         await self._safe_call(on_stop(), "Arrêt échoué")
  6297:     60: 
  6298:     61:                 elif txt.startswith("/status"):
  6299:     62:                     snap = self.status_getter()
  6300:     63:                     await self.notifier.send(f"ℹ️ {snap}")
  6301:     64: 
  6302:     65:                 elif txt.startswith("/setup"):
  6303:     66:                     await self.notifier.send("🧩 Setup wizard à compléter.")
  6304:     67: 
  6305:     68:                 elif txt.startswith("/backtest"):
  6306:     69:                     if on_backtest:
  6307:     70:                         tail = txt[len("/backtest"):].strip()
  6308:     71:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
  6309:     72:                         asyncio.create_task(self._safe_call(
  6310:     73:                             on_backtest(tail), "Backtest échoué"
  6311:     74:                         ))
  6312:     75:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
  6313:     76:                     else:
  6314:     77:                         await self.notifier.send("⚠️ Backtest non disponible.")
  6315:     78: 
  6316:     79:                 else:
  6317:     80:                     await self.notifier.send(
  6318:     81:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
  6319:     82:                     )
  6320:     83: 
  6321:     84:             except Exception as e:
  6322:     85:                 # On protège la boucle quoi qu'il arrive
  6323:     86:                 try:
  6324:     87:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
  6325:     88:                 except Exception:
  6326:     89:                     pass
  6327: 
  6328: ## scalper/live/journal.py (last modified: 2025-08-23 20:57:14)
  6329:      1: from __future__ import annotations
  6330:      2: import os, csv
  6331:      3: from typing import Any, Dict, List
  6332:      4: 
  6333:      5: class LogWriter:
  6334:      6:     """Gestion simple des CSV (création à la volée + append)."""
  6335:      7:     def __init__(self, dirpath: str) -> None:
  6336:      8:         self.dir = dirpath
  6337:      9:         os.makedirs(self.dir, exist_ok=True)
  6338:     10: 
  6339:     11:     def init(self, fname: str, headers: List[str]) -> None:
  6340:     12:         p = os.path.join(self.dir, fname)
  6341:     13:         if not os.path.exists(p):
  6342:     14:             with open(p, "w", newline="", encoding="utf-8") as f:
  6343:     15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
  6344:     16: 
  6345:     17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
  6346:     18:         p = os.path.join(self.dir, fname)
  6347:     19:         with open(p, "a", newline="", encoding="utf-8") as f:
  6348:     20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)
  6349: 
  6350: ## scalper/live/logs.py (last modified: 2025-08-23 20:57:14)
  6351:      1: # scalp/live/logs.py
  6352:      2: from __future__ import annotations
  6353:      3: import os, csv
  6354:      4: from typing import Any, List, Dict
  6355:      5: 
  6356:      6: class CsvLog:
  6357:      7:     def __init__(self, path: str, headers: List[str]):
  6358:      8:         self.path = path
  6359:      9:         self.headers = headers
  6360:     10:         self._ensure_header()
  6361:     11: 
  6362:     12:     def _ensure_header(self):
  6363:     13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
  6364:     14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
  6365:     15:         if must_write:
  6366:     16:             with open(self.path, "w", newline="") as f:
  6367:     17:                 csv.writer(f).writerow(self.headers)
  6368:     18: 
  6369:     19:     def write_row(self, row: Dict[str, Any]):
  6370:     20:         with open(self.path, "a", newline="") as f:
  6371:     21:             w = csv.DictWriter(f, fieldnames=self.headers)
  6372:     22:             w.writerow({k: row.get(k, "") for k in self.headers})
  6373: 
  6374: ## scalper/live/loops/trade.py (last modified: 2025-08-23 20:57:14)
  6375:      1: # scalp/live/loops/trade.py
  6376:      2: from __future__ import annotations
  6377:      3: import asyncio, os
  6378:      4: from dataclasses import dataclass, field
  6379:      5: from typing import Any, Dict, List, Callable
  6380:      6: 
  6381:      7: from ...services.utils import safe_call
  6382:      8: from ...risk.manager import compute_size
  6383:      9: 
  6384:     10: QUIET = int(os.getenv("QUIET", "0") or "0")
  6385:     11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
  6386:     12: 
  6387:     13: class PositionFSM:
  6388:     14:     def __init__(self):
  6389:     15:         self.state = "FLAT"
  6390:     16:         self.side = "flat"
  6391:     17:         self.entry = 0.0
  6392:     18:         self.qty = 0.0
  6393:     19:     def can_open(self): return self.state == "FLAT"
  6394:     20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
  6395:     21:     def can_close(self): return self.state == "OPEN"
  6396:     22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
  6397:     23: 
  6398:     24: @dataclass
  6399:     25: class SymbolContext:
  6400:     26:     symbol: str
  6401:     27:     timeframe: str
  6402:     28:     ohlcv: List[List[float]] = field(default_factory=list)
  6403:     29:     ticks: int = 0
  6404:     30:     fsm: PositionFSM = field(default_factory=PositionFSM)
  6405:     31: 
  6406:     32: class TradeLoop:
  6407:     33:     """
  6408:     34:     Boucle par symbole, indépendante de l'orchestrateur.
  6409:     35:     """
  6410:     36:     def __init__(
  6411:     37:         self,
  6412:     38:         symbol: str,
  6413:     39:         timeframe: str,
  6414:     40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
  6415:     41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
  6416:     42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
  6417:     43:         config: Dict[str, Any],
  6418:     44:         mode_getter: Callable[[], str],
  6419:     45:         log_signals, log_orders, log_fills,
  6420:     46:         tick_counter_add: Callable[[int], None],
  6421:     47:     ):
  6422:     48:         self.symbol = symbol
  6423:     49:         self.timeframe = timeframe
  6424:     50:         self.fetch = ohlcv_fetch
  6425:     51:         self.order_market = order_market
  6426:     52:         self.generate_signal = generate_signal
  6427:     53:         self.config = config
  6428:     54:         self.get_mode = mode_getter
  6429:     55:         self.log_signals = log_signals
  6430:     56:         self.log_orders = log_orders
  6431:     57:         self.log_fills = log_fills
  6432:     58:         self.ctx = SymbolContext(symbol, timeframe)
  6433:     59:         self._tick_add = tick_counter_add
  6434:     60: 
  6435:     61:         # Risk/frais
  6436:     62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
  6437:     63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
  6438:     64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
  6439:     65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
  6440:     66: 
  6441:     67:     def _bps_for(self, order_type: str = "market") -> float:
  6442:     68:         # market -> taker; limit post-only -> maker
  6443:     69:         per = self.fees_map.get(self.symbol, {})
  6444:     70:         if order_type == "limit":
  6445:     71:             return float(per.get("maker_bps", 0.0))
  6446:     72:         return float(per.get("taker_bps", 0.0))
  6447:     73: 
  6448:     74:     async def run(self, running: Callable[[], bool]):
  6449:     75:         lookback = 200
  6450:     76:         while running():
  6451:     77:             if self.get_mode() != "RUNNING":
  6452:     78:                 await asyncio.sleep(0.5); continue
  6453:     79: 
  6454:     80:             async def _fetch():
  6455:     81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
  6456:     82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
  6457:     83:             if not ohlcv or len(ohlcv) < lookback+1:
  6458:     84:                 await asyncio.sleep(1.0); continue
  6459:     85: 
  6460:     86:             self.ctx.ohlcv = ohlcv
  6461:     87:             self.ctx.ticks += 1
  6462:     88:             self._tick_add(1)
  6463:     89: 
  6464:     90:             window = ohlcv[-(lookback+1):]
  6465:     91:             ts, _o, _h, _l, c, _v = window[-1]
  6466:     92: 
  6467:     93:             try:
  6468:     94:                 sig = self.generate_signal(window, self.config) or {}
  6469:     95:             except Exception as e:
  6470:     96:                 if not QUIET:
  6471:     97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
  6472:     98:                 await asyncio.sleep(0.5); continue
  6473:     99: 
  6474:    100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
  6475:    101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
  6476:    102: 
  6477:    103:             # --- Entrée (market -> taker)
  6478:    104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
  6479:    105:                 balance = float(self.config.get("cash", 10_000.0))
  6480:    106:                 qty = compute_size(
  6481:    107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
  6482:    108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  6483:    109:                 )
  6484:    110:                 if qty > 0:
  6485:    111:                     async def _place():
  6486:    112:                         return await self.order_market(self.symbol, side, qty)
  6487:    113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
  6488:    114:                     self.ctx.fsm.on_open(side, entry or c, qty)
  6489:    115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
  6490:    116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
  6491:    117: 
  6492:    118:             # --- Sortie (market -> taker)
  6493:    119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
  6494:    120:                 qty = self.ctx.fsm.qty
  6495:    121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
  6496:    122:                 async def _close():
  6497:    123:                     return await self.order_market(self.symbol, exit_side, qty)
  6498:    124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
  6499:    125: 
  6500:    126:                 # fill avec slippage + frais (taker)
  6501:    127:                 price_fill = float(c)
  6502:    128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
  6503:    129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
  6504:    130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
  6505:    131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
  6506:    132:                                           "order_id": (order or {}).get("id","")})
  6507:    133:                 self.ctx.fsm.on_close()
  6508:    134: 
  6509:    135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
  6510:    136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
  6511:    137: 
  6512:    138:             await asyncio.sleep(0.1 if QUIET else 0.01)
  6513: 
  6514: ## scalper/live/notify.py (last modified: 2025-08-24 03:12:00)
  6515:      1: # -*- coding: utf-8 -*-
  6516:      2: from __future__ import annotations
  6517:      3: import os
  6518:      4: import asyncio
  6519:      5: from dataclasses import dataclass
  6520:      6: from typing import AsyncIterator, Optional
  6521:      7: 
  6522:      8: 
  6523:      9: @dataclass
  6524:     10: class BaseNotifier:
  6525:     11:     async def send(self, text: str) -> None:  # pragma: no cover
  6526:     12:         print(text)
  6527:     13: 
  6528:     14: 
  6529:     15: class NullNotifier(BaseNotifier):
  6530:     16:     pass
  6531:     17: 
  6532:     18: 
  6533:     19: class TelegramNotifier(BaseNotifier):
  6534:     20:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
  6535:     21:         import aiohttp  # lazy
  6536:     22:         self._token = token
  6537:     23:         self._chat = chat_id
  6538:     24:         self._session: aiohttp.ClientSession | None = None
  6539:     25: 
  6540:     26:     async def _ensure(self):
  6541:     27:         import aiohttp
  6542:     28:         if self._session is None or self._session.closed:
  6543:     29:             self._session = aiohttp.ClientSession()
  6544:     30: 
  6545:     31:     async def send(self, text: str) -> None:
  6546:     32:         import aiohttp
  6547:     33:         await self._ensure()
  6548:     34:         # pas de markdown pour éviter les erreurs 400 de parsing
  6549:     35:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
  6550:     36:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
  6551:     37:         try:
  6552:     38:             async with self._session.post(url, json=payload, timeout=20) as r:
  6553:     39:                 await r.text()  # on ignore la réponse pour rester simple
  6554:     40:         except Exception:
  6555:     41:             # on fait un fallback silencieux pour ne pas casser le bot
  6556:     42:             print("[notify:telegram] send fail (ignored)")
  6557:     43: 
  6558:     44:     async def close(self):
  6559:     45:         if self._session and not self._session.closed:
  6560:     46:             await self._session.close()
  6561:     47: 
  6562:     48: 
  6563:     49: class _NullCommands:
  6564:     50:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
  6565:     51:     def __aiter__(self) -> AsyncIterator[str]:
  6566:     52:         return self
  6567:     53:     async def __anext__(self) -> str:
  6568:     54:         await asyncio.sleep(3600)  # jamais
  6569:     55:         raise StopAsyncIteration
  6570:     56: 
  6571:     57: 
  6572:     58: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
  6573:     59:     """
  6574:     60:     Retourne (notifier, command_stream).
  6575:     61: 
  6576:     62:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
  6577:     63:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
  6578:     64:       commandes interactives plus tard.
  6579:     65:     - Sinon: NullNotifier + flux vide.
  6580:     66:     """
  6581:     67:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  6582:     68:     chat = os.getenv("TELEGRAM_CHAT_ID")
  6583:     69:     if token and chat:
  6584:     70:         print("[notify] TELEGRAM configured.")
  6585:     71:         return TelegramNotifier(token, chat), _NullCommands()
  6586:     72:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
  6587:     73:     return NullNotifier(), _NullCommands()
  6588: 
  6589: ## scalper/live/ohlcv_service.py (last modified: 2025-08-23 20:57:14)
  6590:      1: from __future__ import annotations
  6591:      2: import time
  6592:      3: from typing import Any, Dict, List, Optional
  6593:      4: 
  6594:      5: try:
  6595:      6:     from scalper.adapters.market_data import MarketData
  6596:      7: except Exception:
  6597:      8:     MarketData = None  # type: ignore
  6598:      9: 
  6599:     10: class OhlcvService:
  6600:     11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
  6601:     12:     def __init__(self, exchange) -> None:
  6602:     13:         self.exchange = exchange
  6603:     14:         self.md = MarketData(exchange) if MarketData is not None else None
  6604:     15: 
  6605:     16:     @staticmethod
  6606:     17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
  6607:     18:         out: List[Dict[str, float]] = []
  6608:     19:         if not rows: return out
  6609:     20:         for r in rows:
  6610:     21:             if isinstance(r, dict):
  6611:     22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
  6612:     23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
  6613:     24:                 v = float(r.get("volume", r.get("vol", 0.0)))
  6614:     25:             else:
  6615:     26:                 rr = list(r)
  6616:     27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
  6617:     28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
  6618:     29:                 else:
  6619:     30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
  6620:     31:                     h = float(rr[1]) if len(rr) > 1 else o
  6621:     32:                     l = float(rr[2]) if len(rr) > 2 else o
  6622:     33:                     c = float(rr[3]) if len(rr) > 3 else o
  6623:     34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
  6624:     35:                     ts = int(rr[5]) if len(rr) > 5 else 0
  6625:     36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
  6626:     37:         return out
  6627:     38: 
  6628:     39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
  6629:     40:         # 1) MarketData (si dispo)
  6630:     41:         if self.md is not None:
  6631:     42:             try:
  6632:     43:                 d = self.md.get_ohlcv(symbol, interval, limit)
  6633:     44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
  6634:     45:                     return self.normalize_rows(d["data"])
  6635:     46:             except Exception:
  6636:     47:                 pass
  6637:     48: 
  6638:     49:         # 2) Exchange natif
  6639:     50:         rows: List[Any] = []
  6640:     51:         try:
  6641:     52:             data = self.exchange.get_kline(symbol, interval=interval)
  6642:     53:         except Exception:
  6643:     54:             data = None
  6644:     55: 
  6645:     56:         if isinstance(data, dict):
  6646:     57:             rows = (
  6647:     58:                 data.get("data") or data.get("result") or data.get("records") or
  6648:     59:                 data.get("list") or data.get("items") or data.get("candles") or []
  6649:     60:             )
  6650:     61:             guard = 0
  6651:     62:             while isinstance(rows, dict) and guard < 3:
  6652:     63:                 rows = (
  6653:     64:                     rows.get("data") or rows.get("result") or rows.get("records") or
  6654:     65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
  6655:     66:                 )
  6656:     67:                 guard += 1
  6657:     68:         elif isinstance(data, (list, tuple)):
  6658:     69:             rows = list(data)
  6659:     70: 
  6660:     71:         out = self.normalize_rows(rows)[-limit:]
  6661:     72:         if out: return out
  6662:     73: 
  6663:     74:         # 3) Fallback strict via ticker -> bougie synthétique
  6664:     75:         try:
  6665:     76:             tkr = self.exchange.get_ticker(symbol)
  6666:     77:             items = []
  6667:     78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
  6668:     79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
  6669:     80:             if items:
  6670:     81:                 last = items[0]
  6671:     82:                 if isinstance(last, dict):
  6672:     83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
  6673:     84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
  6674:     85:                 else:
  6675:     86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
  6676:     87:                 ts = int(time.time()*1000)
  6677:     88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
  6678:     89:         except Exception:
  6679:     90:             pass
  6680:     91:         return []
  6681: 
  6682: ## scalper/live/orchestrator.py (last modified: 2025-08-24 03:12:00)
  6683:      1: # -*- coding: utf-8 -*-
  6684:      2: from __future__ import annotations
  6685:      3: import asyncio
  6686:      4: from dataclasses import dataclass, field
  6687:      5: from typing import Callable, Iterable, List, Optional, AsyncIterator
  6688:      6: 
  6689:      7: from scalper.hooks.prewarm_cache import prewarm_cache
  6690:      8: 
  6691:      9: 
  6692:     10: @dataclass
  6693:     11: class RunConfig:
  6694:     12:     symbols: List[str] = field(default_factory=lambda: [
  6695:     13:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  6696:     14:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  6697:     15:     ])
  6698:     16:     timeframe: str = "5m"
  6699:     17:     refresh_secs: float = 30.0
  6700:     18:     cache_dir: str = "/notebooks/data"
  6701:     19:     # Tu peux ajouter d'autres paramètres ici (risques, stratégie, etc.)
  6702:     20: 
  6703:     21: 
  6704:     22: class Orchestrator:
  6705:     23:     def __init__(self, cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None):
  6706:     24:         self.cfg = cfg
  6707:     25:         self.notifier = notifier
  6708:     26:         self._cache_dir_factory = cache_dir_factory
  6709:     27:         self._bg_tasks: list[asyncio.Task] = []
  6710:     28:         self._ticks_total: int = 0
  6711:     29:         self._running: bool = False
  6712:     30: 
  6713:     31:     # --- getters exposés aux tâches de log/heartbeat
  6714:     32:     def ticks_total(self) -> int:
  6715:     33:         return self._ticks_total
  6716:     34: 
  6717:     35:     def symbols(self) -> List[str]:
  6718:     36:         return list(self.cfg.symbols)
  6719:     37: 
  6720:     38:     async def _heartbeat_task(self) -> None:
  6721:     39:         while self._running:
  6722:     40:             try:
  6723:     41:                 await self.notifier.send("heartbeat alive")
  6724:     42:             finally:
  6725:     43:                 await asyncio.sleep(30)
  6726:     44: 
  6727:     45:     async def _log_stats_task(self) -> None:
  6728:     46:         # log toutes les 30s
  6729:     47:         while self._running:
  6730:     48:             try:
  6731:     49:                 msg = f"[stats] ticks_total={self._ticks_total} (+0 /30s) | pairs={','.join(self.cfg.symbols) if self.cfg.symbols else ''}"
  6732:     50:                 await self.notifier.send(msg)
  6733:     51:             finally:
  6734:     52:                 await asyncio.sleep(30)
  6735:     53: 
  6736:     54:     async def _main_loop(self) -> None:
  6737:     55:         """Boucle principale ultra‑simple qui incrémente un compteur."""
  6738:     56:         refresh = max(2.0, float(self.cfg.refresh_secs))
  6739:     57:         while self._running:
  6740:     58:             # Ici tu brancheras fetch_ohlcv / signaux / stratégies
  6741:     59:             self._ticks_total += len(self.cfg.symbols)
  6742:     60:             await asyncio.sleep(refresh)
  6743:     61: 
  6744:     62:     async def start(self) -> None:
  6745:     63:         # Pré‑chauffe cache (non bloquant et robuste)
  6746:     64:         prewarm_cache(
  6747:     65:             cfg={},  # placeholder
  6748:     66:             symbols=self.cfg.symbols,
  6749:     67:             timeframe=self.cfg.timeframe,
  6750:     68:             out_dir=(self._cache_dir_factory() if self._cache_dir_factory else self.cfg.cache_dir),
  6751:     69:         )
  6752:     70:         await self.notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  6753:     71: 
  6754:     72:         self._running = True
  6755:     73:         self._bg_tasks.append(asyncio.create_task(self._heartbeat_task()))
  6756:     74:         self._bg_tasks.append(asyncio.create_task(self._log_stats_task()))
  6757:     75:         try:
  6758:     76:             await self._main_loop()
  6759:     77:         finally:
  6760:     78:             # arrêt propre
  6761:     79:             self._running = False
  6762:     80:             for t in self._bg_tasks:
  6763:     81:                 t.cancel()
  6764:     82:             self._bg_tasks.clear()
  6765:     83: 
  6766:     84:     async def run(self) -> None:
  6767:     85:         await self.start()
  6768:     86: 
  6769:     87: 
  6770:     88: async def run_orchestrator(cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None) -> None:
  6771:     89:     """Entrée unique utilisée par bot.py"""
  6772:     90:     orch = Orchestrator(cfg, notifier, cache_dir_factory)
  6773:     91:     await orch.run()
  6774: 
  6775: ## scalper/live/orders.py (last modified: 2025-08-23 20:57:14)
  6776:      1: # live/orders.py
  6777:      2: from __future__ import annotations
  6778:      3: from dataclasses import dataclass
  6779:      4: from typing import Any, Optional
  6780:      5: 
  6781:      6: from scalper.services.order_service import OrderService, OrderRequest
  6782:      7: 
  6783:      8: @dataclass
  6784:      9: class OrderResult:
  6785:     10:     accepted: bool
  6786:     11:     order_id: str | None = None
  6787:     12:     status: str | None = None
  6788:     13:     reason: str | None = None
  6789:     14: 
  6790:     15: class OrderExecutor:
  6791:     16:     """
  6792:     17:     Fine couche autour d'OrderService + exchange :
  6793:     18:       - calcule l'équité USDT
  6794:     19:       - place une entrée (risk_pct)
  6795:     20:       - récupère les fills (normalisés)
  6796:     21:     L'orchestrateur n’appelle plus OrderService directement.
  6797:     22:     """
  6798:     23: 
  6799:     24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
  6800:     25:         self.order_service = order_service
  6801:     26:         self.exchange = exchange
  6802:     27:         self.config = config
  6803:     28: 
  6804:     29:     # ---------- Equity ----------
  6805:     30:     def get_equity_usdt(self) -> float:
  6806:     31:         equity = 0.0
  6807:     32:         try:
  6808:     33:             assets = self.exchange.get_assets()
  6809:     34:             if isinstance(assets, dict):
  6810:     35:                 for a in (assets.get("data") or []):
  6811:     36:                     if str(a.get("currency")).upper() == "USDT":
  6812:     37:                         equity = float(a.get("equity", 0.0))
  6813:     38:                         break
  6814:     39:         except Exception:
  6815:     40:             pass
  6816:     41:         return equity
  6817:     42: 
  6818:     43:     # ---------- Entrée ----------
  6819:     44:     def place_entry(self, *, symbol: str, side: str, price: float,
  6820:     45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
  6821:     46:         """
  6822:     47:         side: 'long' | 'short'
  6823:     48:         Retourne OrderResult(accepted, order_id, status, reason)
  6824:     49:         """
  6825:     50:         equity = self.get_equity_usdt()
  6826:     51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
  6827:     52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
  6828:     53:                            risk_pct=float(risk_pct))
  6829:     54:         try:
  6830:     55:             res = self.order_service.prepare_and_place(equity, req)
  6831:     56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
  6832:     57:                                order_id=getattr(res, "order_id", None),
  6833:     58:                                status=getattr(res, "status", None),
  6834:     59:                                reason=getattr(res, "reason", None))
  6835:     60:         except Exception as e:
  6836:     61:             return OrderResult(accepted=False, reason=str(e))
  6837:     62: 
  6838:     63:     # ---------- Fills ----------
  6839:     64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
  6840:     65:         """
  6841:     66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
  6842:     67:         """
  6843:     68:         try:
  6844:     69:             raw = self.exchange.get_fills(symbol, order_id, limit)
  6845:     70:         except Exception:
  6846:     71:             return []
  6847:     72: 
  6848:     73:         items: list = []
  6849:     74:         if isinstance(raw, dict):
  6850:     75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
  6851:     76:         elif isinstance(raw, (list, tuple)):
  6852:     77:             items = list(raw)
  6853:     78: 
  6854:     79:         out: list[dict] = []
  6855:     80:         for f in items:
  6856:     81:             if isinstance(f, dict):
  6857:     82:                 out.append({
  6858:     83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
  6859:     84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
  6860:     85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
  6861:     86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
  6862:     87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
  6863:     88:                 })
  6864:     89:             else:
  6865:     90:                 try:
  6866:     91:                     seq = list(f)
  6867:     92:                     out.append({
  6868:     93:                         "orderId": str(seq[0]) if seq else "",
  6869:     94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
  6870:     95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
  6871:     96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
  6872:     97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
  6873:     98:                     })
  6874:     99:                 except Exception:
  6875:    100:                     continue
  6876:    101:         return out
  6877: 
  6878: ## scalper/live/position_fsm.py (last modified: 2025-08-23 20:57:14)
  6879:      1: # live/position_fsm.py
  6880:      2: from __future__ import annotations
  6881:      3: from dataclasses import dataclass
  6882:      4: from typing import Optional, Dict, Any, List
  6883:      5: 
  6884:      6: 
  6885:      7: STATE_FLAT = "FLAT"
  6886:      8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
  6887:      9: STATE_OPEN = "OPEN"
  6888:     10: STATE_PENDING_EXIT = "PENDING_EXIT"
  6889:     11: 
  6890:     12: 
  6891:     13: @dataclass
  6892:     14: class PositionState:
  6893:     15:     symbol: str
  6894:     16:     state: str = STATE_FLAT
  6895:     17:     order_id: Optional[str] = None
  6896:     18:     side: Optional[str] = None   # "long" | "short"
  6897:     19:     qty: float = 0.0
  6898:     20:     entry: float = 0.0
  6899:     21: 
  6900:     22: 
  6901:     23: class PositionFSM:
  6902:     24:     """
  6903:     25:     FSM ultra-simple par symbole.
  6904:     26:     - set_pending_entry(order_id, side)
  6905:     27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
  6906:     28:     """
  6907:     29: 
  6908:     30:     def __init__(self, symbols: List[str]) -> None:
  6909:     31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
  6910:     32: 
  6911:     33:     # -------- API utilisateur --------
  6912:     34:     def ensure_symbol(self, symbol: str) -> None:
  6913:     35:         if symbol not in self._by_symbol:
  6914:     36:             self._by_symbol[symbol] = PositionState(symbol)
  6915:     37: 
  6916:     38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
  6917:     39:         self.ensure_symbol(symbol)
  6918:     40:         st = self._by_symbol[symbol]
  6919:     41:         st.state = STATE_PENDING_ENTRY
  6920:     42:         st.order_id = order_id
  6921:     43:         st.side = side
  6922:     44: 
  6923:     45:     def mark_pending_exit(self, symbol: str) -> None:
  6924:     46:         self.ensure_symbol(symbol)
  6925:     47:         st = self._by_symbol[symbol]
  6926:     48:         st.state = STATE_PENDING_EXIT
  6927:     49: 
  6928:     50:     def force_flat(self, symbol: str) -> None:
  6929:     51:         self._by_symbol[symbol] = PositionState(symbol)
  6930:     52: 
  6931:     53:     # -------- Lecture --------
  6932:     54:     def get(self, symbol: str) -> PositionState:
  6933:     55:         self.ensure_symbol(symbol)
  6934:     56:         return self._by_symbol[symbol]
  6935:     57: 
  6936:     58:     def all(self) -> Dict[str, PositionState]:
  6937:     59:         return self._by_symbol
  6938:     60: 
  6939:     61:     # -------- Réconciliation --------
  6940:     62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
  6941:     63:         """
  6942:     64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
  6943:     65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
  6944:     66:         """
  6945:     67:         # indexer positions ouvertes
  6946:     68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
  6947:     69: 
  6948:     70:         for sym, st in self._by_symbol.items():
  6949:     71:             p = idx_open.get(sym)
  6950:     72: 
  6951:     73:             if st.state == STATE_PENDING_ENTRY:
  6952:     74:                 # si on voit des fills de l'ordre en attente -> OPEN
  6953:     75:                 f_list = fills.get(sym) or []
  6954:     76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
  6955:     77:                 if qty_filled > 0.0 or p:
  6956:     78:                     st.state = STATE_OPEN
  6957:     79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
  6958:     80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
  6959:     81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
  6960:     82:             elif st.state == STATE_OPEN:
  6961:     83:                 # si plus de position ouverte -> FLAT
  6962:     84:                 if not p:
  6963:     85:                     st.state = STATE_FLAT
  6964:     86:                     st.order_id = None
  6965:     87:                     st.side = None
  6966:     88:                     st.qty = 0.0
  6967:     89:                     st.entry = 0.0
  6968:     90:                 else:
  6969:     91:                     st.qty = float(p.get("qty", st.qty))
  6970:     92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
  6971:     93:             elif st.state == STATE_PENDING_EXIT:
  6972:     94:                 # si plus de position -> FLAT ; sinon reste OPEN
  6973:     95:                 if not p:
  6974:     96:                     st.state = STATE_FLAT
  6975:     97:                     st.order_id = None
  6976:     98:                     st.side = None
  6977:     99:                     st.qty = 0.0
  6978:    100:                     st.entry = 0.0
  6979:    101:                 else:
  6980:    102:                     st.state = STATE_OPEN  # pas encore clos
  6981:    103:             else:
  6982:    104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
  6983:    105:                 if p:
  6984:    106:                     st.state = STATE_OPEN
  6985:    107:                     st.qty = float(p.get("qty", 0.0))
  6986:    108:                     st.entry = float(p.get("avgEntryPrice", 0.0))
  6987: 
  6988: ## scalper/live/setup_wizard.py (last modified: 2025-08-23 20:57:14)
  6989:      1: from __future__ import annotations
  6990:      2: import asyncio, os
  6991:      3: from dataclasses import dataclass
  6992:      4: from typing import List, Dict, Optional, Callable
  6993:      5: from ..signals.factory import load_signal
  6994:      6: from ..backtest.runner import BacktestRunner
  6995:      7: from .notify import Notifier, CommandStream
  6996:      8: 
  6997:      9: @dataclass
  6998:     10: class SetupResult:
  6999:     11:     strategy: str
  7000:     12:     symbols: List[str]
  7001:     13:     timeframes: List[str]
  7002:     14:     risk_pct: float
  7003:     15:     accepted: bool
  7004:     16:     summary_path: str
  7005:     17: 
  7006:     18: class SetupWizard:
  7007:     19:     """
  7008:     20:     Wizard interactif Telegram avant lancement des trades.
  7009:     21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
  7010:     22:     """
  7011:     23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
  7012:     24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
  7013:     25:                  admin_chat_id: Optional[int]=None):
  7014:     26:         self.notifier = notifier
  7015:     27:         self.cmd_stream = cmd_stream
  7016:     28:         self.loader = ohlcv_loader_sync
  7017:     29:         self.out_dir = out_dir
  7018:     30:         self.admin_chat_id = admin_chat_id
  7019:     31: 
  7020:     32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
  7021:     33:         await self.notifier.send_menu(prompt, choices)
  7022:     34:         async for msg in self.cmd_stream:
  7023:     35:             txt = msg.strip()
  7024:     36:             if allow_multi and ("," in txt or " " in txt):
  7025:     37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
  7026:     38:                 return sel
  7027:     39:             if txt.isdigit():
  7028:     40:                 i = int(txt)-1
  7029:     41:                 if 0 <= i < len(choices):
  7030:     42:                     return [choices[i]]
  7031:     43:             if txt in choices:
  7032:     44:                 return [txt]
  7033:     45:             await self.notifier.send("Entrée invalide. Réessaie.")
  7034:     46: 
  7035:     47:     async def _ask_value(self, prompt: str, cast: Callable, default):
  7036:     48:         await self.notifier.send(f"{prompt} (défaut: {default})")
  7037:     49:         async for msg in self.cmd_stream:
  7038:     50:             txt = msg.strip()
  7039:     51:             if txt == "" or txt.lower() in ("d","defaut","default"):
  7040:     52:                 return default
  7041:     53:             try:
  7042:     54:                 return cast(txt)
  7043:     55:             except Exception:
  7044:     56:                 await self.notifier.send("Entrée invalide. Réessaie.")
  7045:     57: 
  7046:     58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
  7047:     59:                   default_strategy: str="current") -> SetupResult:
  7048:     60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
  7049:     61:         # 1) stratégie
  7050:     62:         strategies = ["current","ema_cross","vwap_break"]
  7051:     63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
  7052:     64: 
  7053:     65:         # 2) symboles
  7054:     66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
  7055:     67: 
  7056:     68:         # 3) timeframes
  7057:     69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
  7058:     70: 
  7059:     71:         # 4) risk %
  7060:     72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
  7061:     73: 
  7062:     74:         # 5) période backtest
  7063:     75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
  7064:     76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
  7065:     77: 
  7066:     78:         # 6) run backtest
  7067:     79:         from ..backtest.cli import parse_ts
  7068:     80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
  7069:     81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
  7070:     82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
  7071:     83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
  7072:     84: 
  7073:     85:         # 7) résumé
  7074:     86:         sum_path = os.path.join(self.out_dir, "metrics.json")
  7075:     87:         prop = res["proposal"]
  7076:     88:         lines = ["**Proposition** :"]
  7077:     89:         for sym, best in prop["per_symbol_best"].items():
  7078:     90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
  7079:     91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
  7080:     92: 
  7081:     93:         # 8) décision
  7082:     94:         async for msg in self.cmd_stream:
  7083:     95:             t = msg.strip().lower()
  7084:     96:             if t in ("accepter","accept","ok","go","start"):
  7085:     97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
  7086:     98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
  7087:     99:             if t in ("modifier","again","repeat"):
  7088:    100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
  7089:    101:             if t in ("annuler","cancel","stop"):
  7090:    102:                 await self.notifier.send("❌ Annulé.")
  7091:    103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)
  7092: 
  7093: ## scalper/live/state_store.py (last modified: 2025-08-23 20:57:14)
  7094:      1: # live/state_store.py
  7095:      2: from __future__ import annotations
  7096:      3: import json, os, time, asyncio
  7097:      4: from typing import Callable, Dict, Any
  7098:      5: 
  7099:      6: class StateStore:
  7100:      7:     """
  7101:      8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
  7102:      9:     - save_state(snapshot: dict) -> écrit sur disque
  7103:     10:     - load_state() -> dict
  7104:     11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
  7105:     12:     """
  7106:     13: 
  7107:     14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
  7108:     15:         self.filepath = filepath
  7109:     16:         self.period_s = period_s
  7110:     17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
  7111:     18:         self._running = False
  7112:     19: 
  7113:     20:     # -------- I/O --------
  7114:     21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
  7115:     22:         tmp = self.filepath + ".tmp"
  7116:     23:         with open(tmp, "w", encoding="utf-8") as f:
  7117:     24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
  7118:     25:         os.replace(tmp, self.filepath)
  7119:     26: 
  7120:     27:     def load_state(self) -> Dict[str, Any]:
  7121:     28:         if not os.path.exists(self.filepath):
  7122:     29:             return {}
  7123:     30:         try:
  7124:     31:             with open(self.filepath, "r", encoding="utf-8") as f:
  7125:     32:                 return json.load(f)
  7126:     33:         except Exception:
  7127:     34:             return {}
  7128:     35: 
  7129:     36:     # -------- Autosave --------
  7130:     37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
  7131:     38:         self._running = True
  7132:     39:         while self._running:
  7133:     40:             try:
  7134:     41:                 snap = get_snapshot()
  7135:     42:                 snap["saved_at"] = int(time.time() * 1000)
  7136:     43:                 self.save_state(snap)
  7137:     44:             except Exception:
  7138:     45:                 pass
  7139:     46:             await asyncio.sleep(self.period_s)
  7140:     47: 
  7141:     48:     def stop(self): self._running = False
  7142: 
  7143: ## scalper/live/telegram_async.py (last modified: 2025-08-23 20:57:14)
  7144:      1: from __future__ import annotations
  7145:      2: import time
  7146:      3: import requests
  7147:      4: import asyncio
  7148:      5: from typing import Optional, Dict, Any, List
  7149:      6: 
  7150:      7: 
  7151:      8: class TelegramAsync:
  7152:      9:     """
  7153:     10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
  7154:     11:     Sans nouvelle dépendance.
  7155:     12:     """
  7156:     13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
  7157:     14:         self.token = token
  7158:     15:         self.chat_id = chat_id
  7159:     16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
  7160:     17:         self._offset = 0
  7161:     18:         self._enabled = bool(token and chat_id)
  7162:     19: 
  7163:     20:     def enabled(self) -> bool:
  7164:     21:         return self._enabled
  7165:     22: 
  7166:     23:     # ---------- sync I/O (appelées via to_thread) ----------
  7167:     24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
  7168:     25:         if not self._enabled:
  7169:     26:             return {"ok": False, "reason": "disabled"}
  7170:     27:         url = f"{self.base}/sendMessage"
  7171:     28:         payload = {"chat_id": self.chat_id, "text": text}
  7172:     29:         try:
  7173:     30:             r = requests.post(url, json=payload, timeout=10)
  7174:     31:             return r.json()
  7175:     32:         except Exception as e:
  7176:     33:             return {"ok": False, "error": repr(e)}
  7177:     34: 
  7178:     35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
  7179:     36:         if not self._enabled:
  7180:     37:             return {"ok": True, "result": []}
  7181:     38:         url = f"{self.base}/getUpdates"
  7182:     39:         params = {"timeout": timeout_s, "offset": self._offset}
  7183:     40:         try:
  7184:     41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
  7185:     42:             return r.json()
  7186:     43:         except Exception as e:
  7187:     44:             return {"ok": False, "error": repr(e), "result": []}
  7188:     45: 
  7189:     46:     # ---------- async wrappers ----------
  7190:     47:     async def send_message(self, text: str) -> None:
  7191:     48:         await asyncio.to_thread(self._send_message_sync, text)
  7192:     49: 
  7193:     50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
  7194:     51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
  7195:     52:         if not data.get("ok"):
  7196:     53:             return []
  7197:     54:         out = []
  7198:     55:         for upd in data.get("result", []):
  7199:     56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
  7200:     57:             msg = upd.get("message") or {}
  7201:     58:             text = (msg.get("text") or "").strip()
  7202:     59:             if not text:
  7203:     60:                 continue
  7204:     61:             out.append({
  7205:     62:                 "date": msg.get("date"),
  7206:     63:                 "chat": str((msg.get("chat") or {}).get("id")),
  7207:     64:                 "text": text,
  7208:     65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
  7209:     66:             })
  7210:     67:         return out
  7211: 
  7212: 
  7213: ## scalper/live/watchlist.py (last modified: 2025-08-24 03:12:00)
  7214:      1: # -*- coding: utf-8 -*-
  7215:      2: from __future__ import annotations
  7216:      3: from dataclasses import dataclass
  7217:      4: from typing import List
  7218:      5: 
  7219:      6: 
  7220:      7: @dataclass
  7221:      8: class WatchlistManager:
  7222:      9:     symbols: List[str]
  7223:     10: 
  7224:     11:     @classmethod
  7225:     12:     def from_env_or_default(cls) -> "WatchlistManager":
  7226:     13:         # Tu peux lire une variable d'env ici si tu veux surcharger
  7227:     14:         default = [
  7228:     15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  7229:     16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  7230:     17:         ]
  7231:     18:         return cls(default)
  7232: 
  7233: ## scalper/logging_utils.py (last modified: 2025-08-23 20:57:14)
  7234:      1: """Logging helpers for the Scalp bot."""
  7235:      2: 
  7236:      3: from __future__ import annotations
  7237:      4: 
  7238:      5: import atexit
  7239:      6: import csv
  7240:      7: import json
  7241:      8: import os
  7242:      9: import sqlite3
  7243:     10: import time
  7244:     11: from pathlib import Path
  7245:     12: from typing import Any, Dict, List
  7246:     13: 
  7247:     14: 
  7248:     15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
  7249:     16:     """Return a callable that logs events as JSON lines.
  7250:     17: 
  7251:     18:     Parameters
  7252:     19:     ----------
  7253:     20:     path: str
  7254:     21:         Target file path for JSON lines.
  7255:     22:     max_bytes: int, optional
  7256:     23:         If >0, rotate the file when its size exceeds this value.
  7257:     24:     backup_count: int, optional
  7258:     25:         Number of rotated files to keep when ``max_bytes`` is set.
  7259:     26:     """
  7260:     27:     os.makedirs(os.path.dirname(path), exist_ok=True)
  7261:     28:     log_file = open(path, "a", encoding="utf-8")
  7262:     29: 
  7263:     30:     def _close_file() -> None:
  7264:     31:         try:
  7265:     32:             log_file.close()
  7266:     33:         except Exception:
  7267:     34:             pass
  7268:     35: 
  7269:     36:     atexit.register(_close_file)
  7270:     37: 
  7271:     38:     def _rotate() -> None:
  7272:     39:         nonlocal log_file
  7273:     40:         log_file.close()
  7274:     41:         for i in range(backup_count - 1, 0, -1):
  7275:     42:             src = f"{path}.{i}"
  7276:     43:             dst = f"{path}.{i + 1}"
  7277:     44:             if os.path.exists(src):
  7278:     45:                 os.replace(src, dst)
  7279:     46:         os.replace(path, f"{path}.1")
  7280:     47:         log_file = open(path, "a", encoding="utf-8")
  7281:     48: 
  7282:     49:     def _log(event: str, payload: Dict[str, Any]) -> None:
  7283:     50:         nonlocal log_file
  7284:     51:         payload = dict(payload or {})
  7285:     52:         payload["event"] = event
  7286:     53:         payload["ts"] = int(time.time() * 1000)
  7287:     54:         line = json.dumps(payload, ensure_ascii=False)
  7288:     55:         if max_bytes and backup_count > 0:
  7289:     56:             if log_file.tell() + len(line) + 1 > max_bytes:
  7290:     57:                 _rotate()
  7291:     58:         log_file.write(line + "\n")
  7292:     59:         log_file.flush()
  7293:     60: 
  7294:     61:     return _log
  7295:     62: 
  7296:     63: 
  7297:     64: class TradeLogger:
  7298:     65:     """Helper writing trade information to CSV and SQLite files."""
  7299:     66: 
  7300:     67:     fields = [
  7301:     68:         "pair",
  7302:     69:         "tf",
  7303:     70:         "dir",
  7304:     71:         "entry",
  7305:     72:         "sl",
  7306:     73:         "tp",
  7307:     74:         "score",
  7308:     75:         "reasons",
  7309:     76:         "pnl",
  7310:     77:     ]
  7311:     78: 
  7312:     79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
  7313:     80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
  7314:     81:         self.csv_path = csv_path
  7315:     82:         self.sqlite_path = sqlite_path
  7316:     83: 
  7317:     84:         # Ensure CSV has header
  7318:     85:         if not os.path.exists(csv_path):
  7319:     86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
  7320:     87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
  7321:     88:                 writer.writeheader()
  7322:     89: 
  7323:     90:         # Setup SQLite store
  7324:     91:         self.conn = sqlite3.connect(sqlite_path)
  7325:     92:         cur = self.conn.cursor()
  7326:     93:         cur.execute(
  7327:     94:             """
  7328:     95:             CREATE TABLE IF NOT EXISTS trades (
  7329:     96:                 pair TEXT,
  7330:     97:                 tf TEXT,
  7331:     98:                 dir TEXT,
  7332:     99:                 entry REAL,
  7333:    100:                 sl REAL,
  7334:    101:                 tp REAL,
  7335:    102:                 score REAL,
  7336:    103:                 reasons TEXT,
  7337:    104:                 pnl REAL
  7338:    105:             )
  7339:    106:             """
  7340:    107:         )
  7341:    108:         self.conn.commit()
  7342:    109:         atexit.register(self.conn.close)
  7343:    110: 
  7344:    111:     def log(self, data: Dict[str, Any]) -> None:
  7345:    112:         row = {k: data.get(k) for k in self.fields}
  7346:    113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
  7347:    114:             writer = csv.DictWriter(f, fieldnames=self.fields)
  7348:    115:             writer.writerow(row)
  7349:    116:         cur = self.conn.cursor()
  7350:    117:         cur.execute(
  7351:    118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
  7352:    119:             (
  7353:    120:                 row["pair"],
  7354:    121:                 row["tf"],
  7355:    122:                 row["dir"],
  7356:    123:                 row["entry"],
  7357:    124:                 row["sl"],
  7358:    125:                 row["tp"],
  7359:    126:                 row["score"],
  7360:    127:                 row["reasons"],
  7361:    128:                 row["pnl"],
  7362:    129:             ),
  7363:    130:         )
  7364:    131:         self.conn.commit()
  7365:    132: 
  7366:    133: 
  7367:    134: BASE_DIR = Path(__file__).resolve().parents[2]
  7368:    135: 
  7369:    136: 
  7370:    137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
  7371:    138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
  7372:    139:     path.parent.mkdir(parents=True, exist_ok=True)
  7373:    140:     file_exists = path.exists()
  7374:    141:     with path.open("a", newline="", encoding="utf-8") as f:
  7375:    142:         writer = csv.DictWriter(f, fieldnames=fields)
  7376:    143:         if not file_exists:
  7377:    144:             writer.writeheader()
  7378:    145:         writer.writerow({k: row.get(k) for k in fields})
  7379:    146: 
  7380:    147: 
  7381:    148: def log_position(data: Dict[str, Any]) -> None:
  7382:    149:     """Log a closed position to ``../positions.csv``."""
  7383:    150:     fields = [
  7384:    151:         "timestamp",
  7385:    152:         "pair",
  7386:    153:         "direction",
  7387:    154:         "entry",
  7388:    155:         "exit",
  7389:    156:         "pnl_pct",
  7390:    157:         "fee_rate",
  7391:    158:         "notes",
  7392:    159:     ]
  7393:    160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
  7394:    161: 
  7395:    162: 
  7396:    163: def log_operation_memo(data: Dict[str, Any]) -> None:
  7397:    164:     """Log operation details to ``../operations_memo.csv``."""
  7398:    165:     fields = ["timestamp", "pair", "details"]
  7399:    166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)
  7400: 
  7401: 
  7402: ## scalper/metrics.py (last modified: 2025-08-23 20:57:14)
  7403:      1: """Utility metrics for trading calculations."""
  7404:      2: 
  7405:      3: from __future__ import annotations
  7406:      4: 
  7407:      5: 
  7408:      6: from typing import Iterable
  7409:      7: 
  7410:      8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
  7411:      9: 
  7412:     10: 
  7413:     11: def calc_pnl_pct(
  7414:     12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
  7415:     13: ) -> float:
  7416:     14:     """Return percentage PnL between entry and exit prices minus fees.
  7417:     15: 
  7418:     16: 
  7419:     17:     Parameters
  7420:     18:     ----------
  7421:     19:     entry_price: float
  7422:     20:         Trade entry price (>0).
  7423:     21:     exit_price: float
  7424:     22:         Trade exit price (>0).
  7425:     23:     side: int
  7426:     24:         +1 for long, -1 for short.
  7427:     25:     fee_rate: float, optional
  7428:     26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
  7429:     27:         applied twice (entry + exit).
  7430:     28:     """
  7431:     29:     if entry_price <= 0 or exit_price <= 0:
  7432:     30:         raise ValueError("Prices must be positive")
  7433:     31:     if side not in (1, -1):
  7434:     32:         raise ValueError("side must be +1 (long) or -1 (short)")
  7435:     33: 
  7436:     34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
  7437:     35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
  7438:     36:     return pnl - fee_pct
  7439:     37: 
  7440:     38: 
  7441:     39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
  7442:     40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
  7443:     41: 
  7444:     42: 
  7445:     43:     Parameters
  7446:     44:     ----------
  7447:     45:     prices:
  7448:     46:         Ordered sequence of closing prices.
  7449:     47:     period:
  7450:     48:         Number of periods to use for the calculation. Must be positive and the
  7451:     49:         length of ``prices`` must be at least ``period + 1``.
  7452:     50:     """
  7453:     51: 
  7454:     52:     prices_list = [float(p) for p in prices]
  7455:     53: 
  7456:     54:     if period <= 0:
  7457:     55:         raise ValueError("period must be positive")
  7458:     56:     if len(prices_list) < period + 1:
  7459:     57: 
  7460:     58:         raise ValueError("len(prices) must be >= period + 1")
  7461:     59: 
  7462:     60:     gains: list[float] = []
  7463:     61:     losses: list[float] = []
  7464:     62:     for i in range(1, period + 1):
  7465:     63: 
  7466:     64:         diff = prices_list[i] - prices_list[i - 1]
  7467:     65: 
  7468:     66:         if diff >= 0:
  7469:     67:             gains.append(diff)
  7470:     68:             losses.append(0.0)
  7471:     69:         else:
  7472:     70:             gains.append(0.0)
  7473:     71:             losses.append(-diff)
  7474:     72: 
  7475:     73:     avg_gain = sum(gains) / period
  7476:     74:     avg_loss = sum(losses) / period
  7477:     75: 
  7478:     76:     for i in range(period + 1, len(prices_list)):
  7479:     77:         diff = prices_list[i] - prices_list[i - 1]
  7480:     78: 
  7481:     79:         gain = max(diff, 0.0)
  7482:     80:         loss = max(-diff, 0.0)
  7483:     81:         avg_gain = (avg_gain * (period - 1) + gain) / period
  7484:     82:         avg_loss = (avg_loss * (period - 1) + loss) / period
  7485:     83: 
  7486:     84:     if avg_gain == 0 and avg_loss == 0:
  7487:     85:         return 50.0
  7488:     86:     if avg_loss == 0:
  7489:     87:         return 100.0
  7490:     88:     if avg_gain == 0:
  7491:     89:         return 0.0
  7492:     90:     rs = avg_gain / avg_loss
  7493:     91:     return 100.0 - (100.0 / (1.0 + rs))
  7494:     92: 
  7495:     93: 
  7496:     94: def calc_atr(
  7497:     95:     highs: Iterable[float],
  7498:     96:     lows: Iterable[float],
  7499:     97:     closes: Iterable[float],
  7500:     98:     period: int = 14,
  7501:     99: ) -> float:
  7502:    100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
  7503:    101: 
  7504:    102: 
  7505:    103:     Parameters
  7506:    104:     ----------
  7507:    105:     highs, lows, closes:
  7508:    106:         Ordered sequences of high, low and close prices. All sequences must
  7509:    107:         have the same length and contain at least ``period + 1`` elements.
  7510:    108:     period:
  7511:    109:         Number of periods to use for the calculation. Must be positive.
  7512:    110:     """
  7513:    111: 
  7514:    112:     highs_list = [float(h) for h in highs]
  7515:    113:     lows_list = [float(low) for low in lows]
  7516:    114:     closes_list = [float(c) for c in closes]
  7517:    115: 
  7518:    116:     length = len(highs_list)
  7519:    117:     if length != len(lows_list) or length != len(closes_list):
  7520:    118: 
  7521:    119:         raise ValueError("Input sequences must have the same length")
  7522:    120:     if period <= 0:
  7523:    121:         raise ValueError("period must be positive")
  7524:    122:     if length < period + 1:
  7525:    123:         raise ValueError("Input sequences must have at least period + 1 elements")
  7526:    124: 
  7527:    125:     trs: list[float] = []
  7528:    126:     for i in range(1, len(highs_list)):
  7529:    127:         tr = max(
  7530:    128:             highs_list[i] - lows_list[i],
  7531:    129:             abs(highs_list[i] - closes_list[i - 1]),
  7532:    130:             abs(lows_list[i] - closes_list[i - 1]),
  7533:    131:         )
  7534:    132:         trs.append(tr)
  7535:    133: 
  7536:    134:     atr = sum(trs[:period]) / period
  7537:    135:     for tr in trs[period:]:
  7538:    136:         atr = (atr * (period - 1) + tr) / period
  7539:    137:     return atr
  7540:    138: 
  7541:    139: 
  7542:    140: def calc_macd(
  7543:    141:     prices: Sequence[float],
  7544:    142:     fast: int = 12,
  7545:    143:     slow: int = 26,
  7546:    144:     signal: int = 9,
  7547:    145: ) -> tuple[float, float, float]:
  7548:    146:     """Return MACD, signal line and histogram values.
  7549:    147: 
  7550:    148:     The implementation computes exponential moving averages using Wilder's
  7551:    149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
  7552:    150:     """
  7553:    151: 
  7554:    152:     prices_list = [float(p) for p in prices]
  7555:    153:     if fast <= 0 or slow <= 0 or signal <= 0:
  7556:    154:         raise ValueError("periods must be positive")
  7557:    155:     min_len = max(fast, slow) + signal
  7558:    156:     if len(prices_list) < min_len:
  7559:    157:         raise ValueError("len(prices) must be >= slow + signal")
  7560:    158: 
  7561:    159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
  7562:    160:         k = 2.0 / (window + 1.0)
  7563:    161:         out = [float(series[0])]
  7564:    162:         for x in series[1:]:
  7565:    163:             out.append(float(x) * k + out[-1] * (1.0 - k))
  7566:    164:         return out
  7567:    165: 
  7568:    166:     fast_ema = _ema_series(prices_list, fast)
  7569:    167:     slow_ema = _ema_series(prices_list, slow)
  7570:    168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
  7571:    169:     signal_series = _ema_series(macd_series, signal)
  7572:    170:     macd_val = macd_series[-1]
  7573:    171:     signal_val = signal_series[-1]
  7574:    172:     hist = macd_val - signal_val
  7575:    173:     return macd_val, signal_val, hist
  7576:    174: 
  7577:    175: 
  7578:    176: def backtest_position(
  7579:    177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
  7580:    178: ) -> bool:
  7581:    179:     """Run a basic backtest to verify a position's coherence.
  7582:    180: 
  7583:    181:     Parameters
  7584:    182:     ----------
  7585:    183:     prices: list[float]
  7586:    184:         Sequential list of prices to evaluate.
  7587:    185:     entry_idx: int
  7588:    186:         Index in ``prices`` where the position is opened.
  7589:    187:     exit_idx: int
  7590:    188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
  7591:    189:     side: int
  7592:    190:         +1 for long, -1 for short.
  7593:    191: 
  7594:    192:     Returns
  7595:    193:     -------
  7596:    194:     bool
  7597:    195:         ``True`` if the resulting PnL is non-negative, meaning the position is
  7598:    196:         coherent with the direction of price movement. ``False`` otherwise.
  7599:    197:     """
  7600:    198:     if side not in (1, -1):
  7601:    199:         raise ValueError("side must be +1 (long) or -1 (short)")
  7602:    200:     if not (0 <= entry_idx < exit_idx < len(prices)):
  7603:    201:         raise ValueError(
  7604:    202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
  7605:    203:         )
  7606:    204: 
  7607:    205:     entry_price = float(prices[entry_idx])
  7608:    206:     exit_price = float(prices[exit_idx])
  7609:    207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
  7610:    208:     return pnl >= 0.0
  7611: 
  7612: 
  7613: ## scalper/pairs.py (last modified: 2025-08-23 20:57:14)
  7614:      1: """Utilities to select trading pairs and detect signals."""
  7615:      2: from __future__ import annotations
  7616:      3: from typing import Any, Dict, List, Optional, Callable
  7617:      4: from scalper.strategy import Signal
  7618:      5: 
  7619:      6: from scalper.bot_config import CONFIG
  7620:      7: from scalper.strategy import ema as default_ema, cross as default_cross
  7621:      8: from scalper.notifier import notify
  7622:      9: 
  7623:     10: 
  7624:     11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
  7625:     12:     """Return all trading pairs using the client's ``get_ticker`` method."""
  7626:     13:     tick = client.get_ticker()
  7627:     14:     data = tick.get("data") if isinstance(tick, dict) else []
  7628:     15:     if not data:
  7629:     16:         return []
  7630:     17:     return data if isinstance(data, list) else [data]
  7631:     18: 
  7632:     19: 
  7633:     20: def filter_trade_pairs(
  7634:     21:     client: Any,
  7635:     22:     *,
  7636:     23:     volume_min: float = 5_000_000,
  7637:     24:     max_spread_bps: float = 5.0,
  7638:     25:     top_n: int = 40,
  7639:     26: ) -> List[Dict[str, Any]]:
  7640:     27:     """Filter pairs by volume and spread."""
  7641:     28:     pairs = get_trade_pairs(client)
  7642:     29:     eligible: List[Dict[str, Any]] = []
  7643:     30: 
  7644:     31:     for info in pairs:
  7645:     32:         sym = info.get("symbol")
  7646:     33:         if not sym:
  7647:     34:             continue
  7648:     35:         try:
  7649:     36:             vol = float(info.get("volume", 0))
  7650:     37:         except (TypeError, ValueError):
  7651:     38:             continue
  7652:     39:         if vol < volume_min:
  7653:     40:             continue
  7654:     41:         try:
  7655:     42:             bid = float(info.get("bidPrice", 0))
  7656:     43:             ask = float(info.get("askPrice", 0))
  7657:     44:         except (TypeError, ValueError):
  7658:     45:             continue
  7659:     46:         if bid <= 0 or ask <= 0:
  7660:     47:             continue
  7661:     48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
  7662:     49:         if spread_bps >= max_spread_bps:
  7663:     50:             continue
  7664:     51:         eligible.append(info)
  7665:     52: 
  7666:     53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
  7667:     54:     return eligible[:top_n]
  7668:     55: 
  7669:     56: 
  7670:     57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
  7671:     58:     """Return ``top_n`` pairs sorted by ``key``."""
  7672:     59:     pairs = get_trade_pairs(client)
  7673:     60: 
  7674:     61:     def volume(row: Dict[str, Any]) -> float:
  7675:     62:         try:
  7676:     63:             return float(row.get(key, 0))
  7677:     64:         except (TypeError, ValueError):
  7678:     65:             return 0.0
  7679:     66: 
  7680:     67:     pairs.sort(key=volume, reverse=True)
  7681:     68:     return pairs[:top_n]
  7682:     69: 
  7683:     70: 
  7684:     71: def _ancienne_impl(
  7685:     72:     client: Any,
  7686:     73:     pairs: List[Dict[str, Any]],
  7687:     74:     *,
  7688:     75:     interval: str = "1m",
  7689:     76:     ema_fast_n: Optional[int] = None,
  7690:     77:     ema_slow_n: Optional[int] = None,
  7691:     78:     ema_func=default_ema,
  7692:     79:     cross_func=default_cross,
  7693:     80: ) -> List[Dict[str, Any]]:
  7694:     81:     """Original implementation returning dicts."""
  7695:     82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
  7696:     83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
  7697:     84:     results: List[Dict[str, Any]] = []
  7698:     85: 
  7699:     86:     for info in pairs:
  7700:     87:         symbol = info.get("symbol")
  7701:     88:         if not symbol:
  7702:     89:             continue
  7703:     90:         k = client.get_kline(symbol, interval=interval)
  7704:     91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
  7705:     92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
  7706:     93:             continue
  7707:     94:         efull = ema_func(closes, ema_fast_n)
  7708:     95:         eslow = ema_func(closes, ema_slow_n)
  7709:     96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
  7710:     97:         if signal == 1:
  7711:     98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  7712:     99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
  7713:    100:         elif signal == -1:
  7714:    101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  7715:    102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
  7716:    103:     return results
  7717:    104: 
  7718:    105: 
  7719:    106: def _to_signal(d: dict) -> Signal:
  7720:    107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
  7721:    108:     return Signal(
  7722:    109:         symbol=d.get("symbol"),
  7723:    110:         side=side,
  7724:    111:         entry=float(d.get("price", d.get("entry", 0))),
  7725:    112:         sl=float(d.get("sl", 0)),
  7726:    113:         tp1=float(d.get("tp1", 0)) or None,
  7727:    114:         tp2=float(d.get("tp2", 0)) or None,
  7728:    115:         score=d.get("score"),
  7729:    116:         quality=d.get("quality"),
  7730:    117:         reasons=d.get("reasons", []),
  7731:    118:     )
  7732:    119: 
  7733:    120: 
  7734:    121: def find_trade_positions(
  7735:    122:     client: Any,
  7736:    123:     pairs: List[Dict[str, Any]],
  7737:    124:     *,
  7738:    125:     interval: str = "1m",
  7739:    126:     ema_fast_n: Optional[int] = None,
  7740:    127:     ema_slow_n: Optional[int] = None,
  7741:    128:     ema_func=default_ema,
  7742:    129:     cross_func=default_cross,
  7743:    130: ) -> List[Signal]:
  7744:    131:     raw = _ancienne_impl(
  7745:    132:         client,
  7746:    133:         pairs,
  7747:    134:         interval=interval,
  7748:    135:         ema_fast_n=ema_fast_n,
  7749:    136:         ema_slow_n=ema_slow_n,
  7750:    137:         ema_func=ema_func,
  7751:    138:         cross_func=cross_func,
  7752:    139:     )
  7753:    140:     return [_to_signal(x) for x in raw]
  7754:    141: 
  7755:    142: 
  7756:    143: def send_selected_pairs(
  7757:    144:     client: Any,
  7758:    145:     top_n: int = 40,
  7759:    146:     *,
  7760:    147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
  7761:    148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
  7762:    149: ) -> Dict[str, str]:
  7763:    150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
  7764:    151: 
  7765:    152:     Returns the payload sent to ``notify_fn``. The mapping contains the
  7766:    153:     comma-separated symbols for each color group (``green``, ``orange`` and
  7767:    154:     ``red``) or an empty dictionary when no pairs are available.
  7768:    155:     """
  7769:    156: 
  7770:    157:     def split_symbol(sym: str) -> tuple[str, str]:
  7771:    158:         if "_" in sym:
  7772:    159:             left, right = sym.split("_", 1)
  7773:    160:             # Legacy style: BTC_USDT
  7774:    161:             if len(right) <= 4:
  7775:    162:                 return left, right
  7776:    163:             # Bitget futures style: BTCUSDT_UMCBL
  7777:    164:             main = left
  7778:    165:             if main.endswith("USDT"):
  7779:    166:                 return main[:-4], "USDT"
  7780:    167:             if main.endswith("USDC"):
  7781:    168:                 return main[:-4], "USDC"
  7782:    169:             if main.endswith("USD"):
  7783:    170:                 return main[:-3], "USD"
  7784:    171:             return main, ""
  7785:    172:         if sym.endswith("USDT"):
  7786:    173:             return sym[:-4], "USDT"
  7787:    174:         if sym.endswith("USDC"):
  7788:    175:             return sym[:-4], "USDC"
  7789:    176:         if sym.endswith("USD"):
  7790:    177:             return sym[:-3], "USD"
  7791:    178:         return sym, ""
  7792:    179: 
  7793:    180:     pairs = select_fn(client, top_n=top_n * 3)
  7794:    181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
  7795:    182:     by_base: Dict[str, Dict[str, Any]] = {}
  7796:    183:     for info in pairs:
  7797:    184:         sym = info.get("symbol")
  7798:    185:         if not sym:
  7799:    186:             continue
  7800:    187:         norm_sym = sym.split("_")[0].upper()
  7801:    188:         if allowed and norm_sym not in allowed:
  7802:    189:             continue
  7803:    190:         base, quote = split_symbol(sym)
  7804:    191:         existing = by_base.get(base)
  7805:    192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
  7806:    193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
  7807:    194:             by_base[base] = {"data": info, "quote": quote}
  7808:    195: 
  7809:    196:     unique = sorted(
  7810:    197:         (v["data"] for v in by_base.values()),
  7811:    198:         key=lambda row: float(row.get("volume", 0)),
  7812:    199:         reverse=True,
  7813:    200:     )
  7814:    201:     symbols: list[str] = []
  7815:    202:     for row in unique[:top_n]:
  7816:    203:         sym = row.get("symbol")
  7817:    204:         if not sym:
  7818:    205:             continue
  7819:    206:         base, _ = split_symbol(sym)
  7820:    207:         symbols.append(base)
  7821:    208:     if symbols:
  7822:    209:         n = len(symbols)
  7823:    210:         third = max(n // 3, 1)
  7824:    211:         green = symbols[:third]
  7825:    212:         orange = symbols[third : 2 * third]
  7826:    213:         red = symbols[2 * third :]
  7827:    214:         payload: Dict[str, str] = {}
  7828:    215:         if green:
  7829:    216:             payload["green"] = ", ".join(green)
  7830:    217:         if orange:
  7831:    218:             payload["orange"] = ", ".join(orange)
  7832:    219:         if red:
  7833:    220:             payload["red"] = ", ".join(red)
  7834:    221:         notify_fn("pair_list", payload)
  7835:    222:         return payload
  7836:    223:     return {}
  7837:    224: 
  7838:    225: 
  7839:    226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
  7840:    227:     """Return a heat score combining volatility, volume and a news flag."""
  7841:    228:     mult = 2.0 if news else 1.0
  7842:    229:     return volatility * volume * mult
  7843:    230: 
  7844:    231: 
  7845:    232: def select_top_heat_pairs(
  7846:    233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
  7847:    234: ) -> List[Dict[str, Any]]:
  7848:    235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
  7849:    236: 
  7850:    237:     scored: List[Dict[str, Any]] = []
  7851:    238:     for info in pairs:
  7852:    239:         try:
  7853:    240:             vol = float(info.get("volatility", 0))
  7854:    241:             volume = float(info.get("volume", 0))
  7855:    242:         except (TypeError, ValueError):
  7856:    243:             continue
  7857:    244:         score = heat_score(vol, volume, bool(info.get("news")))
  7858:    245:         row = dict(info)
  7859:    246:         row["heat_score"] = score
  7860:    247:         scored.append(row)
  7861:    248: 
  7862:    249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
  7863:    250:     return scored[:top_n]
  7864:    251: 
  7865:    252: 
  7866:    253: def decorrelate_pairs(
  7867:    254:     pairs: List[Dict[str, Any]],
  7868:    255:     corr: Dict[str, Dict[str, float]],
  7869:    256:     *,
  7870:    257:     threshold: float = 0.8,
  7871:    258:     top_n: int = 3,
  7872:    259: ) -> List[Dict[str, Any]]:
  7873:    260:     """Return top pairs while avoiding highly correlated symbols.
  7874:    261: 
  7875:    262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
  7876:    263:     pairs are considered too correlated when the absolute value of the
  7877:    264:     correlation exceeds ``threshold``.
  7878:    265:     """
  7879:    266: 
  7880:    267:     selected: List[Dict[str, Any]] = []
  7881:    268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
  7882:    269:         sym = info.get("symbol")
  7883:    270:         if not sym:
  7884:    271:             continue
  7885:    272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
  7886:    273:             selected.append(info)
  7887:    274:         if len(selected) >= top_n:
  7888:    275:             break
  7889:    276:     return selected
  7890: 
  7891: 
  7892: ## scalper/positions/__init__.py (last modified: 2025-08-23 20:57:14)
  7893: 
  7894: 
  7895: ## scalper/positions/state.py (last modified: 2025-08-23 20:57:14)
  7896:      1: from __future__ import annotations
  7897:      2: from dataclasses import dataclass, field
  7898:      3: from enum import Enum, auto
  7899:      4: from typing import List, Optional
  7900:      5: import time
  7901:      6: 
  7902:      7: class PositionStatus(Enum):
  7903:      8:     IDLE = auto()
  7904:      9:     PENDING_ENTRY = auto()
  7905:     10:     OPEN = auto()
  7906:     11:     PENDING_EXIT = auto()
  7907:     12:     CLOSED = auto()
  7908:     13: 
  7909:     14: class PositionSide(Enum):
  7910:     15:     LONG = 1
  7911:     16:     SHORT = -1
  7912:     17: 
  7913:     18: @dataclass
  7914:     19: class Fill:
  7915:     20:     order_id: str
  7916:     21:     trade_id: str
  7917:     22:     price: float
  7918:     23:     qty: float
  7919:     24:     fee: float
  7920:     25:     ts: int
  7921:     26: 
  7922:     27: @dataclass
  7923:     28: class PositionState:
  7924:     29:     symbol: str
  7925:     30:     side: PositionSide
  7926:     31:     status: PositionStatus = PositionStatus.IDLE
  7927:     32:     entry_order_id: Optional[str] = None
  7928:     33:     exit_order_id: Optional[str] = None
  7929:     34:     req_qty: float = 0.0
  7930:     35:     filled_qty: float = 0.0
  7931:     36:     avg_entry_price: float = 0.0
  7932:     37:     avg_exit_price: float = 0.0
  7933:     38:     sl: Optional[float] = None
  7934:     39:     tp: Optional[float] = None
  7935:     40:     realized_pnl: float = 0.0
  7936:     41:     fees: float = 0.0
  7937:     42:     opened_ts: Optional[int] = None
  7938:     43:     closed_ts: Optional[int] = None
  7939:     44:     fills: List[Fill] = field(default_factory=list)
  7940:     45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
  7941:     46: 
  7942:     47:     def apply_fill_entry(self, f: Fill) -> None:
  7943:     48:         self.fills.append(f)
  7944:     49:         self.filled_qty += f.qty
  7945:     50:         # moyenne pondérée
  7946:     51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
  7947:     52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
  7948:     53:         self.fees += abs(f.fee)
  7949:     54:         if self.opened_ts is None:
  7950:     55:             self.opened_ts = f.ts
  7951:     56:         if self.filled_qty > 1e-12:
  7952:     57:             self.status = PositionStatus.OPEN
  7953:     58: 
  7954:     59:     def apply_fill_exit(self, f: Fill) -> None:
  7955:     60:         self.fills.append(f)
  7956:     61:         qty = min(self.filled_qty, f.qty)
  7957:     62:         # realized pnl sur la quantité fermée
  7958:     63:         if self.side == PositionSide.LONG:
  7959:     64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
  7960:     65:         else:
  7961:     66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
  7962:     67:         self.fees += abs(f.fee)
  7963:     68:         self.filled_qty = max(0.0, self.filled_qty - qty)
  7964:     69:         # moyenne de sortie indicative
  7965:     70:         closed_q = (self.req_qty - self.filled_qty)
  7966:     71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
  7967:     72:         if self.filled_qty <= 1e-12:
  7968:     73:             self.status = PositionStatus.CLOSED
  7969:     74:             self.closed_ts = f.ts
  7970:     75: 
  7971: 
  7972: 
  7973: ## scalper/risk/__init__.py (last modified: 2025-08-23 20:57:14)
  7974:      1: # scalp/risk/__init__.py
  7975:      2: from .manager import (
  7976:      3:     Caps,
  7977:      4:     compute_size,
  7978:      5:     calc_position_size,  # alias legacy
  7979:      6:     RiskManager,         # shim legacy
  7980:      7: )
  7981:      8: 
  7982:      9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]
  7983: 
  7984: ## scalper/risk/manager.py (last modified: 2025-08-23 20:57:14)
  7985:      1: # scalp/risk/manager.py
  7986:      2: from __future__ import annotations
  7987:      3: from dataclasses import dataclass
  7988:      4: from typing import Optional, Dict, Any
  7989:      5: 
  7990:      6: @dataclass
  7991:      7: class Caps:
  7992:      8:     min_qty: float = 0.0
  7993:      9:     min_notional: float = 0.0
  7994:     10:     max_leverage: float = 20.0
  7995:     11: 
  7996:     12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
  7997:     13:     if not caps_by_symbol:
  7998:     14:         return Caps()
  7999:     15:     c = caps_by_symbol.get(symbol, {})
  8000:     16:     return Caps(
  8001:     17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
  8002:     18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
  8003:     19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
  8004:     20:     )
  8005:     21: 
  8006:     22: def compute_size(
  8007:     23:     *,
  8008:     24:     symbol: str,
  8009:     25:     price: float,
  8010:     26:     balance_cash: float,
  8011:     27:     risk_pct: float = 0.5,
  8012:     28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
  8013:     29: ) -> float:
  8014:     30:     """Sizing robuste avec gardes min_notional / min_qty."""
  8015:     31:     price = max(1e-9, float(price))
  8016:     32:     balance_cash = max(0.0, float(balance_cash))
  8017:     33:     risk_pct = max(0.0, float(risk_pct))
  8018:     34: 
  8019:     35:     notionnel = balance_cash * risk_pct
  8020:     36:     qty = notionnel / price
  8021:     37: 
  8022:     38:     caps = _get_caps(caps_by_symbol, symbol)
  8023:     39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
  8024:     40:         qty = caps.min_notional / price
  8025:     41:     if caps.min_qty > 0 and qty < caps.min_qty:
  8026:     42:         qty = caps.min_qty
  8027:     43:     return max(0.0, qty)
  8028:     44: 
  8029:     45: # --- Shims pour compatibilité ancienne API -----------------------------------
  8030:     46: 
  8031:     47: def calc_position_size(symbol: str, price: float, balance_cash: float,
  8032:     48:                        risk_pct: float = 0.5,
  8033:     49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
  8034:     50:     """Alias legacy → compute_size."""
  8035:     51:     return compute_size(
  8036:     52:         symbol=symbol, price=price, balance_cash=balance_cash,
  8037:     53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
  8038:     54:     )
  8039:     55: 
  8040:     56: class RiskManager:
  8041:     57:     """
  8042:     58:     Shim minimal compatible avec l'ancien code:
  8043:     59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
  8044:     60:       qty = rm.size(symbol, price, balance_cash)
  8045:     61:     """
  8046:     62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
  8047:     63:         self.risk_pct = float(risk_pct)
  8048:     64:         self.caps_by_symbol = caps_by_symbol or {}
  8049:     65: 
  8050:     66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
  8051:     67:         return compute_size(
  8052:     68:             symbol=symbol, price=price, balance_cash=balance_cash,
  8053:     69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  8054:     70:         )
  8055: 
  8056: ## scalper/selection/__init__.py (last modified: 2025-08-23 20:57:14)
  8057:      1: """Pair selection helpers for the Scalp bot.
  8058:      2: 
  8059:      3: This package exposes two utilities used during the preparation phase of the
  8060:      4: trading strategy:
  8061:      5: 
  8062:      6: ``scan_pairs``
  8063:      7:     Performs the first level market scan by filtering pairs based on volume,
  8064:      8:     spread and hourly volatility.
  8065:      9: 
  8066:     10: ``select_active_pairs``
  8067:     11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
  8068:     12:     crossover and a sufficiently high ATR.
  8069:     13: """
  8070:     14: 
  8071:     15: from .scanner import scan_pairs
  8072:     16: from .momentum import select_active_pairs
  8073:     17: 
  8074:     18: __all__ = ["scan_pairs", "select_active_pairs"]
  8075:     19: 
  8076: 
  8077: 
  8078: ## scalper/selection/momentum.py (last modified: 2025-08-23 20:57:14)
  8079:      1: """Utilities to select pairs exhibiting strong momentum."""
  8080:      2: 
  8081:      3: from __future__ import annotations
  8082:      4: 
  8083:      5: from typing import Any, Dict, List, Sequence
  8084:      6: 
  8085:      7: from ..metrics import calc_atr
  8086:      8: 
  8087:      9: 
  8088:     10: def ema(series: Sequence[float], window: int) -> List[float]:
  8089:     11:     """Simple exponential moving average implementation."""
  8090:     12: 
  8091:     13:     if window <= 1 or not series:
  8092:     14:         return list(series)
  8093:     15:     k = 2.0 / (window + 1.0)
  8094:     16:     out: List[float] = [float(series[0])]
  8095:     17:     prev = out[0]
  8096:     18:     for x in series[1:]:
  8097:     19:         prev = float(x) * k + prev * (1.0 - k)
  8098:     20:         out.append(prev)
  8099:     21:     return out
  8100:     22: 
  8101:     23: 
  8102:     24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  8103:     25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
  8104:     26: 
  8105:     27:     if prev_fast <= prev_slow and last_fast > last_slow:
  8106:     28:         return 1
  8107:     29:     if prev_fast >= prev_slow and last_fast < last_slow:
  8108:     30:         return -1
  8109:     31:     return 0
  8110:     32: 
  8111:     33: 
  8112:     34: def _quantile(values: Sequence[float], q: float) -> float:
  8113:     35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
  8114:     36: 
  8115:     37:     if not values:
  8116:     38:         return 0.0
  8117:     39:     q = min(max(q, 0.0), 1.0)
  8118:     40:     vals = sorted(values)
  8119:     41:     idx = int((len(vals) - 1) * q)
  8120:     42:     return vals[idx]
  8121:     43: 
  8122:     44: 
  8123:     45: def select_active_pairs(
  8124:     46:     client: Any,
  8125:     47:     pairs: Sequence[Dict[str, Any]],
  8126:     48:     *,
  8127:     49:     interval: str = "Min5",
  8128:     50:     ema_fast: int = 20,
  8129:     51:     ema_slow: int = 50,
  8130:     52:     atr_period: int = 14,
  8131:     53:     atr_quantile: float = 0.5,
  8132:     54:     top_n: int = 5,
  8133:     55: ) -> List[Dict[str, Any]]:
  8134:     56:     """Return pairs with an EMA crossover and high ATR.
  8135:     57: 
  8136:     58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
  8137:     59:     Among those candidates, the Average True Range is computed and only pairs
  8138:     60:     whose ATR is above the provided quantile are returned.  The resulting
  8139:     61:     dictionaries include an ``atr`` key for convenience.
  8140:     62:     """
  8141:     63: 
  8142:     64:     candidates: List[Dict[str, Any]] = []
  8143:     65:     atrs: List[float] = []
  8144:     66: 
  8145:     67:     for info in pairs:
  8146:     68:         sym = info.get("symbol")
  8147:     69:         if not sym:
  8148:     70:             continue
  8149:     71:         k = client.get_kline(sym, interval=interval)
  8150:     72:         kdata = k.get("data") if isinstance(k, dict) else {}
  8151:     73:         closes = kdata.get("close", [])
  8152:     74:         highs = kdata.get("high", [])
  8153:     75:         lows = kdata.get("low", [])
  8154:     76:         if len(closes) < max(ema_slow, atr_period) + 2:
  8155:     77:             continue
  8156:     78:         efast = ema(closes, ema_fast)
  8157:     79:         eslow = ema(closes, ema_slow)
  8158:     80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
  8159:     81:             continue
  8160:     82:         atr_val = calc_atr(highs, lows, closes, atr_period)
  8161:     83:         row = dict(info)
  8162:     84:         row["atr"] = atr_val
  8163:     85:         candidates.append(row)
  8164:     86:         atrs.append(atr_val)
  8165:     87: 
  8166:     88:     if not candidates:
  8167:     89:         return []
  8168:     90: 
  8169:     91:     threshold = _quantile(atrs, atr_quantile)
  8170:     92:     selected = [row for row in candidates if row["atr"] >= threshold]
  8171:     93:     selected.sort(key=lambda r: r["atr"], reverse=True)
  8172:     94:     return selected[:top_n]
  8173:     95: 
  8174:     96: 
  8175:     97: __all__ = ["select_active_pairs"]
  8176:     98: 
  8177: 
  8178: 
  8179: ## scalper/selection/scanner.py (last modified: 2025-08-23 20:57:14)
  8180:      1: """Utilities for scanning tradable pairs on the exchange."""
  8181:      2: 
  8182:      3: from __future__ import annotations
  8183:      4: 
  8184:      5: from typing import Any, Dict, List
  8185:      6: 
  8186:      7: 
  8187:      8: def scan_pairs(
  8188:      9:     client: Any,
  8189:     10:     *,
  8190:     11:     volume_min: float = 5_000_000,
  8191:     12:     max_spread_bps: float = 5.0,
  8192:     13:     min_hourly_vol: float = 0.0,
  8193:     14:     top_n: int = 40,
  8194:     15: ) -> List[Dict[str, Any]]:
  8195:     16:     """Return pairs satisfying basic liquidity and volatility filters.
  8196:     17: 
  8197:     18:     Parameters
  8198:     19:     ----------
  8199:     20:     client: Any
  8200:     21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
  8201:     22:     volume_min: float, optional
  8202:     23:         Minimum 24h volume required to keep a pair.
  8203:     24:     max_spread_bps: float, optional
  8204:     25:         Maximum allowed bid/ask spread expressed in basis points.
  8205:     26:     min_hourly_vol: float, optional
  8206:     27:         Minimum volatility over the last hour expressed as ``(high - low) /
  8207:     28:         close``.  When set to ``0`` the filter is disabled.
  8208:     29:     top_n: int, optional
  8209:     30:         Limit the number of returned pairs.
  8210:     31:     """
  8211:     32: 
  8212:     33:     tick = client.get_ticker()
  8213:     34:     data = tick.get("data") if isinstance(tick, dict) else []
  8214:     35:     if not isinstance(data, list):
  8215:     36:         data = [data]
  8216:     37: 
  8217:     38:     eligible: List[Dict[str, Any]] = []
  8218:     39: 
  8219:     40:     for row in data:
  8220:     41:         sym = row.get("symbol")
  8221:     42:         if not sym:
  8222:     43:             continue
  8223:     44:         try:
  8224:     45:             vol = float(row.get("volume", 0))
  8225:     46:             bid = float(row.get("bidPrice", 0))
  8226:     47:             ask = float(row.get("askPrice", 0))
  8227:     48:         except (TypeError, ValueError):
  8228:     49:             continue
  8229:     50:         if vol < volume_min or bid <= 0 or ask <= 0:
  8230:     51:             continue
  8231:     52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
  8232:     53:         if spread_bps >= max_spread_bps:
  8233:     54:             continue
  8234:     55: 
  8235:     56:         if min_hourly_vol > 0:
  8236:     57:             k = client.get_kline(sym, interval="Min60")
  8237:     58:             kdata = k.get("data") if isinstance(k, dict) else {}
  8238:     59:             highs = kdata.get("high", [])
  8239:     60:             lows = kdata.get("low", [])
  8240:     61:             closes = kdata.get("close", [])
  8241:     62:             if not highs or not lows or not closes:
  8242:     63:                 continue
  8243:     64:             try:
  8244:     65:                 h = float(highs[-1])
  8245:     66:                 l = float(lows[-1])
  8246:     67:                 c = float(closes[-1])
  8247:     68:             except (TypeError, ValueError):
  8248:     69:                 continue
  8249:     70:             hourly_vol = (h - l) / c if c else 0.0
  8250:     71:             if hourly_vol < min_hourly_vol:
  8251:     72:                 continue
  8252:     73: 
  8253:     74:         eligible.append(row)
  8254:     75: 
  8255:     76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
  8256:     77:     return eligible[:top_n]
  8257:     78: 
  8258:     79: 
  8259:     80: __all__ = ["scan_pairs"]
  8260:     81: 
  8261: 
  8262: 
  8263: ## scalper/selfcheck.py (last modified: 2025-08-23 20:57:14)
  8264:      1: # scalper/selfcheck.py
  8265:      2: from __future__ import annotations
  8266:      3: import os, sys, importlib, traceback
  8267:      4: from pathlib import Path
  8268:      5: 
  8269:      6: NOTEBOOKS = Path("/notebooks")
  8270:      7: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
  8271:      8: 
  8272:      9: def _mask(val: str) -> str:
  8273:     10:     if not val: return ""
  8274:     11:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
  8275:     12: 
  8276:     13: def _try_import(modname: str):
  8277:     14:     try:
  8278:     15:         m = importlib.import_module(modname)
  8279:     16:         return True, m
  8280:     17:     except Exception:
  8281:     18:         return False, traceback.format_exc()
  8282:     19: 
  8283:     20: def preflight(verbose: bool = False) -> list[str]:
  8284:     21:     """
  8285:     22:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
  8286:     23:     Ne lève pas d'exception. N'écrit que de l'info lisible.
  8287:     24:     """
  8288:     25:     issues: list[str] = []
  8289:     26:     # s'assurer que le repo est bien dans sys.path
  8290:     27:     if str(REPO) not in sys.path:
  8291:     28:         sys.path.insert(0, str(REPO))
  8292:     29: 
  8293:     30:     print("=== SCALPER PREFLIGHT ===")
  8294:     31:     print(f"[i] Repo: {REPO}")
  8295:     32:     print(f"[i] Python: {sys.version.split()[0]}")
  8296:     33: 
  8297:     34:     # backtest API
  8298:     35:     ok, mod = _try_import("scalper.backtest")
  8299:     36:     if not ok:
  8300:     37:         print("[✗] Import scalper.backtest KO")
  8301:     38:         if verbose: print(mod)  # ici 'mod' contient la trace
  8302:     39:         issues.append("backtest import")
  8303:     40:     else:
  8304:     41:         has_single = hasattr(mod, "run_single")
  8305:     42:         has_multi  = hasattr(mod, "run_multi")
  8306:     43:         print(f"[✓] scalper.backtest: run_single={has_single} run_multi={has_multi}")
  8307:     44:         if not (has_single and has_multi):
  8308:     45:             issues.append("backtest API incomplète")
  8309:     46: 
  8310:     47:     # trade_utils
  8311:     48:     ok, mod = _try_import("scalper.trade_utils")
  8312:     49:     if not ok:
  8313:     50:         print("[✗] Import scalper.trade_utils KO")
  8314:     51:         if verbose: print(mod)
  8315:     52:         issues.append("trade_utils import")
  8316:     53:     else:
  8317:     54:         print(f"[✓] scalper.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
  8318:     55: 
  8319:     56:     # fees
  8320:     57:     ok, mod = _try_import("scalper.exchange.fees")
  8321:     58:     if not ok:
  8322:     59:         print("[✗] Import scalper.exchange.fees KO")
  8323:     60:         if verbose: print(mod)
  8324:     61:         issues.append("fees import")
  8325:     62:     else:
  8326:     63:         need = {"get_fee", "load_bitget_fees"}
  8327:     64:         miss = [n for n in need if not hasattr(mod, n)]
  8328:     65:         if miss: issues.append("fees API manquante: " + ",".join(miss))
  8329:     66:         print("[✓] scalper.exchange.fees OK")
  8330:     67: 
  8331:     68:     # notify/commands/backtest_telegram/orchestrator
  8332:     69:     for name, required in [
  8333:     70:         ("scalper.live.notify", ("build_notifier_and_stream",)),
  8334:     71:         ("scalper.live.commands", ("CommandHandler",)),
  8335:     72:         ("scalper.live.backtest_telegram", ("handle_backtest_command",)),
  8336:     73:         ("scalper.live.orchestrator", ("run_orchestrator", "Orchestrator")),
  8337:     74:     ]:
  8338:     75:         ok, mod = _try_import(name)
  8339:     76:         if not ok:
  8340:     77:             print(f"[✗] Import {name} KO")
  8341:     78:             if verbose: print(mod)
  8342:     79:             issues.append(f"{name} import")
  8343:     80:         else:
  8344:     81:             miss = [a for a in required if not hasattr(mod, a)]
  8345:     82:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
  8346:     83:             print(f"[✓] {name} OK")
  8347:     84: 
  8348:     85:     # ENV (masqué)
  8349:     86:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
  8350:     87:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
  8351:     88:     gu   = os.getenv("GIT_USER", "")
  8352:     89:     gt   = os.getenv("GIT_TOKEN", "")
  8353:     90:     print("\n-- ENV --")
  8354:     91:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
  8355:     92:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
  8356:     93:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
  8357:     94:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
  8358:     95: 
  8359:     96:     # Data
  8360:     97:     data_dir = (REPO / "data")
  8361:     98:     print("\n-- DATA --")
  8362:     99:     if data_dir.exists():
  8363:    100:         csvs = list(data_dir.glob("*.csv"))
  8364:    101:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
  8365:    102:     else:
  8366:    103:         print("  data/ absent (OK si loader API)")
  8367:    104: 
  8368:    105:     return issues
  8369:    106: 
  8370:    107: def preflight_or_die(verbose: bool = False) -> None:
  8371:    108:     issues = preflight(verbose=verbose)
  8372:    109:     if issues:
  8373:    110:         print("\n[✗] Préflight a détecté des problèmes :")
  8374:    111:         for it in issues: print("   -", it)
  8375:    112:         print("\nConseils :")
  8376:    113:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
  8377:    114:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
  8378:    115:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
  8379:    116:         raise SystemExit(1)
  8380:    117:     print("\n[✓] Préflight OK — démarrage du bot.")
  8381: 
  8382: ## scalper/services/__init__.py (last modified: 2025-08-23 20:57:14)
  8383: 
  8384: 
  8385: ## scalper/services/data_cache.py (last modified: 2025-08-23 20:57:14)
  8386:      1: # scalper/services/data_cache.py
  8387:      2: from __future__ import annotations
  8388:      3: 
  8389:      4: import asyncio
  8390:      5: import csv
  8391:      6: import os
  8392:      7: import time
  8393:      8: from typing import Iterable, List, Optional, Tuple, Dict
  8394:      9: 
  8395:     10: # ---------------------------------------------------------------------
  8396:     11: # Réglages via env (valeurs sûres par défaut)
  8397:     12: # ---------------------------------------------------------------------
  8398:     13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
  8399:     14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
  8400:     15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
  8401:     16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
  8402:     17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
  8403:     18: 
  8404:     19: os.makedirs(DATA_DIR, exist_ok=True)
  8405:     20: 
  8406:     21: 
  8407:     22: # ---------------------------------------------------------------------
  8408:     23: # Helpers
  8409:     24: # ---------------------------------------------------------------------
  8410:     25: def parse_timeframe_to_seconds(tf: str) -> int:
  8411:     26:     tf = tf.strip().lower()
  8412:     27:     unit = tf[-1]
  8413:     28:     try:
  8414:     29:         n = int(tf[:-1])
  8415:     30:     except Exception as e:
  8416:     31:         raise ValueError(f"timeframe invalide: {tf}") from e
  8417:     32:     if unit == "m":
  8418:     33:         return n * 60
  8419:     34:     if unit == "h":
  8420:     35:         return n * 3600
  8421:     36:     if unit == "d":
  8422:     37:         return n * 86400
  8423:     38:     raise ValueError(f"timeframe invalide: {tf}")
  8424:     39: 
  8425:     40: 
  8426:     41: def csv_path(symbol: str, timeframe: str) -> str:
  8427:     42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
  8428:     43: 
  8429:     44: 
  8430:     45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
  8431:     46:     rows: List[Tuple[int, float, float, float, float, float]] = []
  8432:     47:     if not os.path.exists(path):
  8433:     48:         return rows
  8434:     49:     with open(path, "r", newline="") as f:
  8435:     50:         r = csv.reader(f)
  8436:     51:         header = next(r, None)  # accepte avec ou sans header
  8437:     52:         for line in r:
  8438:     53:             if not line:
  8439:     54:                 continue
  8440:     55:             ts, o, h, l, c, v = line[:6]
  8441:     56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  8442:     57:     return rows
  8443:     58: 
  8444:     59: 
  8445:     60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
  8446:     61:     first = not os.path.exists(path)
  8447:     62:     os.makedirs(os.path.dirname(path), exist_ok=True)
  8448:     63:     with open(path, "a", newline="") as f:
  8449:     64:         w = csv.writer(f)
  8450:     65:         if first:
  8451:     66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
  8452:     67:         for row in data:
  8453:     68:             w.writerow(row)
  8454:     69: 
  8455:     70: 
  8456:     71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
  8457:     72:     return rows[-1][0] if rows else None
  8458:     73: 
  8459:     74: 
  8460:     75: # ---------------------------------------------------------------------
  8461:     76: # Fetch CCXT paginé
  8462:     77: # ---------------------------------------------------------------------
  8463:     78: async def ccxt_fetch_ohlcv_all(
  8464:     79:     exchange,
  8465:     80:     symbol: str,
  8466:     81:     timeframe: str,
  8467:     82:     since_ms: Optional[int],
  8468:     83:     limit: int = 1000,
  8469:     84: ) -> List[Tuple[int, float, float, float, float, float]]:
  8470:     85:     """
  8471:     86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
  8472:     87:     Retourne une liste triée/dédupliquée.
  8473:     88:     """
  8474:     89:     out: List[Tuple[int, float, float, float, float, float]] = []
  8475:     90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
  8476:     91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
  8477:     92: 
  8478:     93:     cursor = since_ms or (now_ms - 200 * tf_ms)
  8479:     94:     while True:
  8480:     95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
  8481:     96:         if not batch:
  8482:     97:             break
  8483:     98:         for ts, o, h, l, c, v in batch:
  8484:     99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  8485:    100:         next_cursor = batch[-1][0] + tf_ms
  8486:    101:         if next_cursor <= cursor:
  8487:    102:             break
  8488:    103:         cursor = next_cursor
  8489:    104:         if cursor >= now_ms + (2 * tf_ms):
  8490:    105:             break
  8491:    106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
  8492:    107: 
  8493:    108:     out.sort(key=lambda x: x[0])
  8494:    109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
  8495:    110:     seen = set()
  8496:    111:     for row in out:
  8497:    112:         if row[0] in seen:
  8498:    113:             continue
  8499:    114:         seen.add(row[0])
  8500:    115:         dedup.append(row)
  8501:    116:     return dedup
  8502:    117: 
  8503:    118: 
  8504:    119: # ---------------------------------------------------------------------
  8505:    120: # Cache manager
  8506:    121: # ---------------------------------------------------------------------
  8507:    122: async def ensure_symbol_csv_cache(
  8508:    123:     exchange,
  8509:    124:     symbol: str,
  8510:    125:     timeframe: str,
  8511:    126:     min_rows: int = CSV_MIN_ROWS,
  8512:    127: ) -> str:
  8513:    128:     """
  8514:    129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
  8515:    130:     Crée/append si nécessaire. Retourne le chemin.
  8516:    131:     """
  8517:    132:     path = csv_path(symbol, timeframe)
  8518:    133:     rows = read_csv_ohlcv(path)
  8519:    134:     tf_sec = parse_timeframe_to_seconds(timeframe)
  8520:    135:     tf_ms = tf_sec * 1000
  8521:    136:     now_ms = int(time.time() * 1000)
  8522:    137: 
  8523:    138:     # âge max
  8524:    139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
  8525:    140: 
  8526:    141:     need_full = False
  8527:    142:     need_append = False
  8528:    143: 
  8529:    144:     if not rows:
  8530:    145:         need_full = True
  8531:    146:     else:
  8532:    147:         last = last_ts(rows) or 0
  8533:    148:         age_sec = max(0, (now_ms - last) // 1000)
  8534:    149:         if age_sec > max_age or len(rows) < min_rows:
  8535:    150:             need_append = True
  8536:    151: 
  8537:    152:     if need_full:
  8538:    153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
  8539:    154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8540:    155:         if len(fresh) < min_rows:
  8541:    156:             since = now_ms - (tf_ms * 5000)
  8542:    157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8543:    158:         if os.path.exists(path):
  8544:    159:             os.remove(path)
  8545:    160:         write_csv_ohlcv(path, fresh)
  8546:    161:         return path
  8547:    162: 
  8548:    163:     if need_append:
  8549:    164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
  8550:    165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8551:    166:         if fresh:
  8552:    167:             write_csv_ohlcv(path, fresh)
  8553:    168: 
  8554:    169:     return path
  8555:    170: 
  8556:    171: 
  8557:    172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
  8558:    173:     """
  8559:    174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
  8560:    175:     Retourne {symbol: path}.
  8561:    176:     """
  8562:    177:     sem = asyncio.Semaphore(PREFETCH_CONC)
  8563:    178:     result: Dict[str, str] = {}
  8564:    179: 
  8565:    180:     async def _one(sym: str):
  8566:    181:         async with sem:
  8567:    182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
  8568:    183:             result[sym] = p
  8569:    184: 
  8570:    185:     await asyncio.gather(*[_one(s) for s in symbols])
  8571:    186:     return result
  8572: 
  8573: ## scalper/services/order_service.py (last modified: 2025-08-23 20:57:14)
  8574:      1: from __future__ import annotations
  8575:      2: from dataclasses import dataclass
  8576:      3: from typing import Any, Dict, Optional, Protocol
  8577:      4: from scalper.trade_utils import extract_available_balance
  8578:      5: 
  8579:      6: 
  8580:      7: @dataclass
  8581:      8: class OrderCaps:
  8582:      9:     min_trade_usdt: float = 5.0
  8583:     10:     leverage: float = 1.0
  8584:     11: 
  8585:     12: 
  8586:     13: @dataclass
  8587:     14: class OrderRequest:
  8588:     15:     symbol: str
  8589:     16:     side: str
  8590:     17:     price: float
  8591:     18:     sl: float
  8592:     19:     tp: Optional[float]
  8593:     20:     risk_pct: float
  8594:     21: 
  8595:     22: 
  8596:     23: @dataclass
  8597:     24: class OrderResult:
  8598:     25:     accepted: bool
  8599:     26:     reason: str = ""
  8600:     27:     payload: Dict[str, Any] = None
  8601:     28:     order_id: Optional[str] = None
  8602:     29:     status: Optional[str] = None
  8603:     30:     avg_price: Optional[float] = None
  8604:     31:     filled_qty: Optional[float] = None
  8605:     32: 
  8606:     33: 
  8607:     34: class Exchange(Protocol):
  8608:     35:     def get_assets(self) -> Dict[str, Any]: ...
  8609:     36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
  8610:     37:     def place_order(
  8611:     38:         self,
  8612:     39:         symbol: str,
  8613:     40:         side: str,
  8614:     41:         quantity: float,
  8615:     42:         order_type: str,
  8616:     43:         price: Optional[float] = None,
  8617:     44:         stop_loss: Optional[float] = None,
  8618:     45:         take_profit: Optional[float] = None,
  8619:     46:     ) -> Dict[str, Any]: ...
  8620:     47: 
  8621:     48: 
  8622:     49: class OrderService:
  8623:     50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
  8624:     51:         self.exchange = exchange
  8625:     52:         self.caps = caps
  8626:     53: 
  8627:     54:     @staticmethod
  8628:     55:     def _abs(x: float) -> float:
  8629:     56:         return -x if x < 0 else x
  8630:     57: 
  8631:     58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
  8632:     59:         dist = self._abs(price - sl)
  8633:     60:         if dist <= 0:
  8634:     61:             return 0.0
  8635:     62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
  8636:     63:         return 0.0 if price <= 0 else (risk_usdt / dist)
  8637:     64: 
  8638:     65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
  8639:     66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
  8640:     67:         if qty <= 0:
  8641:     68:             return OrderResult(False, "invalid_size")
  8642:     69:         notional = qty * req.price
  8643:     70:         if notional < self.caps.min_trade_usdt:
  8644:     71:             return OrderResult(False, "under_min_notional")
  8645:     72:         assets = self.exchange.get_assets()
  8646:     73:         available = extract_available_balance(assets)
  8647:     74:         required_margin = notional / max(1.0, self.caps.leverage)
  8648:     75:         if available < required_margin:
  8649:     76:             return OrderResult(False, "insufficient_margin")
  8650:     77:         side = "BUY" if req.side == "long" else "SELL"
  8651:     78:         out = self.exchange.place_order(
  8652:     79:             symbol=req.symbol, side=side, quantity=qty,
  8653:     80:             order_type="limit", price=req.price,
  8654:     81:             stop_loss=req.sl, take_profit=req.tp
  8655:     82:         )
  8656:     83:         # extraire infos utiles
  8657:     84:         oid = None; status = None; avg = None; filled = None
  8658:     85:         try:
  8659:     86:             data = out.get("data") if isinstance(out, dict) else out
  8660:     87:             if isinstance(data, dict):
  8661:     88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
  8662:     89:                 status = (data.get("status") or data.get("state") or "new").lower()
  8663:     90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
  8664:     91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
  8665:     92:         except Exception:
  8666:     93:             pass
  8667:     94:         return OrderResult(True, "", out, oid, status, avg, filled)
  8668: 
  8669: 
  8670: ## scalper/services/utils.py (last modified: 2025-08-23 20:57:14)
  8671:      1: # scalper/services/utils.py
  8672:      2: from __future__ import annotations
  8673:      3: import asyncio
  8674:      4: from typing import Callable, Any
  8675:      5: 
  8676:      6: 
  8677:      7: class NullNotifier:
  8678:      8:     async def send(self, _msg: str) -> None:
  8679:      9:         return
  8680:     10: 
  8681:     11: 
  8682:     12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
  8683:     13:     if notifier is None:
  8684:     14:         notifier = NullNotifier()
  8685:     15:     try:
  8686:     16:         while running_getter():
  8687:     17:             await notifier.send("heartbeat alive")
  8688:     18:             await asyncio.sleep(period)
  8689:     19:     except asyncio.CancelledError:
  8690:     20:         pass
  8691:     21: 
  8692:     22: 
  8693:     23: async def log_stats_task(
  8694:     24:     notifier: Any,
  8695:     25:     ticks_getter: Callable[[], int],
  8696:     26:     symbols_getter: Callable[[], list[str]],
  8697:     27:     period: float = 30.0,
  8698:     28: ) -> None:
  8699:     29:     if notifier is None:
  8700:     30:         notifier = NullNotifier()
  8701:     31:     last = 0
  8702:     32:     try:
  8703:     33:         while True:
  8704:     34:             total = int(ticks_getter() or 0)
  8705:     35:             delta = total - last
  8706:     36:             last = total
  8707:     37:             syms = symbols_getter() or []
  8708:     38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
  8709:     39:             print(msg)
  8710:     40:             await notifier.send(msg)
  8711:     41:             await asyncio.sleep(period)
  8712:     42:     except asyncio.CancelledError:
  8713:     43:         pass
  8714: 
  8715: ## scalper/signals/__init__.py (last modified: 2025-08-23 20:57:14)
  8716:      1: # scalper/signals/__init__.py
  8717:      2: from .factory import load_signal, available_strategies
  8718:      3: 
  8719:      4: __all__ = ["load_signal", "available_strategies"]
  8720: 
  8721: ## scalper/signals/current.py (last modified: 2025-08-23 20:57:14)
  8722:      1: # scalper/signals/current.py
  8723:      2: from __future__ import annotations
  8724:      3: 
  8725:      4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
  8726:      5: from scalper.strategy import generate_signal as _generate_signal
  8727:      6: 
  8728:      7: def generate_signal(**kwargs):
  8729:      8:     """
  8730:      9:     Expose la même signature que scalper.strategy.generate_signal.
  8731:     10:     Sert d’adaptateur pour la factory.
  8732:     11:     """
  8733:     12:     return _generate_signal(**kwargs)
  8734: 
  8735: ## scalper/signals/factory.py (last modified: 2025-08-23 20:57:14)
  8736:      1: # scalper/signals/factory.py
  8737:      2: from __future__ import annotations
  8738:      3: 
  8739:      4: import importlib
  8740:      5: import importlib.util
  8741:      6: from typing import Callable, Dict, Optional
  8742:      7: 
  8743:      8: SignalFn = Callable[..., object]
  8744:      9: 
  8745:     10: # Mapping symbolique -> module (tu peux en ajouter librement)
  8746:     11: _REGISTRY: Dict[str, str] = {
  8747:     12:     # Stratégie "actuelle" (renvoie scalper.strategy.generate_signal)
  8748:     13:     "current": "scalper.signals.current",
  8749:     14: 
  8750:     15:     # Exemples de plugins (crée les fichiers si tu veux les utiliser)
  8751:     16:     "ema_cross": "scalper.signals.ema_cross",
  8752:     17:     "vwap_break": "scalper.signals.vwap_break",
  8753:     18: }
  8754:     19: 
  8755:     20: def _module_exists(modname: str) -> bool:
  8756:     21:     return importlib.util.find_spec(modname) is not None
  8757:     22: 
  8758:     23: def load_signal(name: str, *, default: str = "current") -> SignalFn:
  8759:     24:     """
  8760:     25:     Charge et retourne une fonction `generate_signal` pour la stratégie `name`.
  8761:     26:     Si le module n'existe pas, on retombe sur `default` (courant: 'current').
  8762:     27:     """
  8763:     28:     target = _REGISTRY.get(name, _REGISTRY.get(default, "scalper.signals.current"))
  8764:     29:     if not _module_exists(target):
  8765:     30:         # fallback direct sur 'current'
  8766:     31:         target = _REGISTRY.get(default, "scalper.signals.current")
  8767:     32: 
  8768:     33:     mod = importlib.import_module(target)
  8769:     34:     fn = getattr(mod, "generate_signal", None)
  8770:     35:     if not callable(fn):
  8771:     36:         # dernier filet de sécurité : stratégie live directe
  8772:     37:         from scalper.strategy import generate_signal as live_generate
  8773:     38:         return live_generate
  8774:     39:     return fn
  8775:     40: 
  8776:     41: def available_strategies() -> Dict[str, str]:
  8777:     42:     """
  8778:     43:     Retourne {nom: 'ok'/'missing'} pour afficher ce qui est disponible.
  8779:     44:     """
  8780:     45:     out: Dict[str, str] = {}
  8781:     46:     for name, mod in _REGISTRY.items():
  8782:     47:         out[name] = "ok" if _module_exists(mod) else "missing"
  8783:     48:     return out
  8784: 
  8785: ## scalper/signals/generator.py (last modified: 2025-08-23 20:57:14)
  8786:      1: from __future__ import annotations
  8787:      2: 
  8788:      3: from typing import Any, Dict, List, Optional
  8789:      4: 
  8790:      5: import pandas as pd
  8791:      6: 
  8792:      7: from data.indicators import compute_all
  8793:      8: 
  8794:      9: __all__ = ["generate_signal"]
  8795:     10: 
  8796:     11: 
  8797:     12: def _quality_from_score(score: float) -> str:
  8798:     13:     if score >= 0.8:
  8799:     14:         return "A"
  8800:     15:     if score >= 0.5:
  8801:     16:         return "B"
  8802:     17:     return "C"
  8803:     18: 
  8804:     19: 
  8805:     20: def generate_signal(
  8806:     21:     df: pd.DataFrame,
  8807:     22:     *,
  8808:     23:     trend_tf: Optional[pd.DataFrame] = None,
  8809:     24:     confirm_tf: Optional[pd.DataFrame] = None,
  8810:     25:     atr_mult: float = 1.0,
  8811:     26:     trailing: bool = False,
  8812:     27:     **_: Any,
  8813:     28: ) -> Optional[Dict[str, Any]]:
  8814:     29:     """Generate a trading signal with confluence scoring.
  8815:     30: 
  8816:     31:     Parameters
  8817:     32:     ----------
  8818:     33:     df: pd.DataFrame
  8819:     34:         Primary timeframe OHLCV data.
  8820:     35:     trend_tf: pd.DataFrame, optional
  8821:     36:         Higher timeframe used for trend filtering.
  8822:     37:     confirm_tf: pd.DataFrame, optional
  8823:     38:         Lower timeframe used for confirmation.
  8824:     39:     atr_mult: float, optional
  8825:     40:         Multiplier applied to ATR for stop/target calculation.
  8826:     41:     trailing: bool, optional
  8827:     42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
  8828:     43: 
  8829:     44:     Returns
  8830:     45:     -------
  8831:     46:     dict | None
  8832:     47:         Dictionary describing the signal or ``None`` if no trade setup exists.
  8833:     48:     """
  8834:     49: 
  8835:     50:     if df is None or len(df) < 2:
  8836:     51:         return None
  8837:     52: 
  8838:     53:     df = compute_all(df)
  8839:     54:     last = df.iloc[-1]
  8840:     55: 
  8841:     56:     conditions: List[bool] = []
  8842:     57:     reasons: List[str] = []
  8843:     58:     direction: Optional[str] = None
  8844:     59: 
  8845:     60:     # --- Basic trend via EMAs ----------------------------------------------
  8846:     61:     if last["close"] > last["ema20"] > last["ema50"]:
  8847:     62:         direction = "long"
  8848:     63:         reasons.append("price_above_ema")
  8849:     64:         conditions.append(True)
  8850:     65:     elif last["close"] < last["ema20"] < last["ema50"]:
  8851:     66:         direction = "short"
  8852:     67:         reasons.append("price_below_ema")
  8853:     68:         conditions.append(True)
  8854:     69:     else:
  8855:     70:         conditions.append(False)
  8856:     71:         return None
  8857:     72: 
  8858:     73:     # --- RSI ---------------------------------------------------------------
  8859:     74:     if direction == "long":
  8860:     75:         cond = last["rsi"] > 55
  8861:     76:         if cond:
  8862:     77:             reasons.append("rsi_bullish")
  8863:     78:         conditions.append(cond)
  8864:     79:     else:
  8865:     80:         cond = last["rsi"] < 45
  8866:     81:         if cond:
  8867:     82:             reasons.append("rsi_bearish")
  8868:     83:         conditions.append(cond)
  8869:     84: 
  8870:     85:     # --- MACD --------------------------------------------------------------
  8871:     86:     if direction == "long":
  8872:     87:         cond = last["macd"] > last["macd_signal"]
  8873:     88:         if cond:
  8874:     89:             reasons.append("macd_bullish")
  8875:     90:         conditions.append(cond)
  8876:     91:     else:
  8877:     92:         cond = last["macd"] < last["macd_signal"]
  8878:     93:         if cond:
  8879:     94:             reasons.append("macd_bearish")
  8880:     95:         conditions.append(cond)
  8881:     96: 
  8882:     97:     # --- OBV momentum ------------------------------------------------------
  8883:     98:     if len(df) >= 2:
  8884:     99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
  8885:    100:         if obv_up:
  8886:    101:             reasons.append("obv_trending")
  8887:    102:         conditions.append(obv_up)
  8888:    103: 
  8889:    104:     # --- Trend timeframe filter -------------------------------------------
  8890:    105:     if trend_tf is not None and len(trend_tf) >= 2:
  8891:    106:         tdf = compute_all(trend_tf)
  8892:    107:         ema50 = tdf["ema50"]
  8893:    108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
  8894:    109:         if direction == "long":
  8895:    110:             cond = slope > 0
  8896:    111:             if cond:
  8897:    112:                 reasons.append("trend_up")
  8898:    113:             conditions.append(cond)
  8899:    114:         else:
  8900:    115:             cond = slope < 0
  8901:    116:             if cond:
  8902:    117:                 reasons.append("trend_down")
  8903:    118:             conditions.append(cond)
  8904:    119: 
  8905:    120:     # --- Confirmation timeframe filter ------------------------------------
  8906:    121:     if confirm_tf is not None and len(confirm_tf) > 0:
  8907:    122:         cdf = compute_all(confirm_tf)
  8908:    123:         rsi = cdf["rsi"].iloc[-1]
  8909:    124:         if direction == "long":
  8910:    125:             cond = rsi > 50
  8911:    126:             if cond:
  8912:    127:                 reasons.append("confirm_rsi_bullish")
  8913:    128:             conditions.append(cond)
  8914:    129:         else:
  8915:    130:             cond = rsi < 50
  8916:    131:             if cond:
  8917:    132:                 reasons.append("confirm_rsi_bearish")
  8918:    133:             conditions.append(cond)
  8919:    134: 
  8920:    135:     score = (
  8921:    136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
  8922:    137:     )
  8923:    138:     quality = _quality_from_score(score)
  8924:    139: 
  8925:    140:     atr = last.get("atr")
  8926:    141:     if pd.isna(atr) or atr == 0:
  8927:    142:         return None
  8928:    143: 
  8929:    144:     entry = float(last["close"])
  8930:    145:     if direction == "long":
  8931:    146:         sl = entry - atr * atr_mult
  8932:    147:         tp = entry + atr * atr_mult * 2
  8933:    148:     else:
  8934:    149:         sl = entry + atr * atr_mult
  8935:    150:         tp = entry - atr * atr_mult * 2
  8936:    151: 
  8937:    152:     result: Dict[str, Any] = {
  8938:    153:         "direction": direction,
  8939:    154:         "entry": entry,
  8940:    155:         "sl": sl,
  8941:    156:         "tp": tp,
  8942:    157:         "score": round(score, 3),
  8943:    158:         "reasons": reasons,
  8944:    159:         "quality": quality,
  8945:    160:     }
  8946:    161: 
  8947:    162:     if trailing:
  8948:    163:         result["trail"] = atr * atr_mult
  8949:    164: 
  8950:    165:     return result
  8951: 
  8952: 
  8953: ## scalper/strategy.py (last modified: 2025-08-23 20:57:14)
  8954:      1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
  8955:      2: 
  8956:      3: This module implements a minimal but functional version of the strategy
  8957:      4: outlined in the project specification.  The focus is on pure Python
  8958:      5: implementations so the logic can easily be unit tested without requiring
  8959:      6: external services or heavy third‑party dependencies.
  8960:      7: 
  8961:      8: The strategy is deliberately stateless; functions operate on passed data and
  8962:      9: return simple data structures.  This makes it easy to plug the logic into
  8963:     10: real‑time trading loops or backtest engines.
  8964:     11: """
  8965:     12: 
  8966:     13: from __future__ import annotations
  8967:     14: 
  8968:     15: from dataclasses import dataclass
  8969:     16: from typing import Sequence, List, Dict, Optional, Tuple, Any
  8970:     17: 
  8971:     18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
  8972:     19: from .risk import calc_position_size
  8973:     20: 
  8974:     21: # ---------------------------------------------------------------------------
  8975:     22: # Helpers
  8976:     23: # ---------------------------------------------------------------------------
  8977:     24: 
  8978:     25: def ema(series: Sequence[float], window: int) -> List[float]:
  8979:     26:     """Return the exponential moving average of *series*.
  8980:     27: 
  8981:     28:     The first value is the raw input to remain consistent with most trading
  8982:     29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
  8983:     30:     returned unchanged.
  8984:     31:     """
  8985:     32: 
  8986:     33:     if window <= 1 or not series:
  8987:     34:         return list(series)
  8988:     35:     k = 2.0 / (window + 1.0)
  8989:     36:     out: List[float] = [float(series[0])]
  8990:     37:     prev = out[0]
  8991:     38:     for x in series[1:]:
  8992:     39:         prev = float(x) * k + prev * (1.0 - k)
  8993:     40:         out.append(prev)
  8994:     41:     return out
  8995:     42: 
  8996:     43: def vwap(highs: Sequence[float], lows: Sequence[float],
  8997:     44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
  8998:     45:     """Compute the volume weighted average price (VWAP).
  8999:     46: 
  9000:     47:     Parameters
  9001:     48:     ----------
  9002:     49:     highs, lows, closes, volumes: Sequence[float]
  9003:     50:         Matching sequences for the period considered.
  9004:     51:     """
  9005:     52: 
  9006:     53:     tp_vol = 0.0
  9007:     54:     vol_sum = 0.0
  9008:     55:     for h, low, c, v in zip(highs, lows, closes, volumes):
  9009:     56:         tp = (h + low + c) / 3.0
  9010:     57:         tp_vol += tp * v
  9011:     58:         vol_sum += v
  9012:     59:     return tp_vol / vol_sum if vol_sum else 0.0
  9013:     60: 
  9014:     61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
  9015:     62:     """Return the On Balance Volume (OBV) series."""
  9016:     63: 
  9017:     64:     if not closes:
  9018:     65:         return []
  9019:     66:     out: List[float] = [0.0]
  9020:     67:     for i in range(1, len(closes)):
  9021:     68:         if closes[i] > closes[i - 1]:
  9022:     69:             out.append(out[-1] + volumes[i])
  9023:     70:         elif closes[i] < closes[i - 1]:
  9024:     71:             out.append(out[-1] - volumes[i])
  9025:     72:         else:
  9026:     73:             out.append(out[-1])
  9027:     74:     return out
  9028:     75: 
  9029:     76: 
  9030:     77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  9031:     78:     """Detect a crossing between two series.
  9032:     79: 
  9033:     80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
  9034:     81:     ``0`` otherwise.
  9035:     82:     """
  9036:     83: 
  9037:     84:     if prev_fast <= prev_slow and last_fast > last_slow:
  9038:     85:         return 1
  9039:     86:     if prev_fast >= prev_slow and last_fast < last_slow:
  9040:     87:         return -1
  9041:     88:     return 0
  9042:     89: 
  9043:     90: 
  9044:     91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
  9045:     92:     """Compute order book imbalance.
  9046:     93: 
  9047:     94:     The value is normalised between ``-1`` and ``1`` where positive numbers
  9048:     95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
  9049:     96:     """
  9050:     97: 
  9051:     98:     total = bid_vol + ask_vol
  9052:     99:     return (bid_vol - ask_vol) / total if total else 0.0
  9053:    100: 
  9054:    101: 
  9055:    102: def swing_levels(
  9056:    103:     highs: Sequence[float], lows: Sequence[float], lookback: int
  9057:    104: ) -> Tuple[float, float]:
  9058:    105:     """Return the most recent swing high and swing low.
  9059:    106: 
  9060:    107:     ``lookback`` defines how many completed candles are inspected.  The current
  9061:    108:     candle is excluded to avoid look‑ahead bias.
  9062:    109:     """
  9063:    110: 
  9064:    111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
  9065:    112:         return highs[-1], lows[-1]
  9066:    113:     high = max(highs[-lookback - 1 : -1])
  9067:    114:     low = min(lows[-lookback - 1 : -1])
  9068:    115:     return high, low
  9069:    116: 
  9070:    117: # ---------------------------------------------------------------------------
  9071:    118: # Pair selection
  9072:    119: # ---------------------------------------------------------------------------
  9073:    120: 
  9074:    121: # The first and second level pair selection helpers now live in
  9075:    122: # :mod:`scalper.selection`.  They are re-exported here for backward compatibility
  9076:    123: # and to keep the public API unchanged.
  9077:    124: from .selection.scanner import scan_pairs  # noqa: E402
  9078:    125: from .selection.momentum import select_active_pairs  # noqa: E402
  9079:    126: 
  9080:    127: # ---------------------------------------------------------------------------
  9081:    128: # Signal generation
  9082:    129: # ---------------------------------------------------------------------------
  9083:    130: 
  9084:    131: @dataclass
  9085:    132: class Signal:
  9086:    133:     """Trading signal with risk parameters."""
  9087:    134: 
  9088:    135:     symbol: str
  9089:    136:     side: int  # 1 for long, -1 for short
  9090:    137:     entry: float
  9091:    138:     sl: float
  9092:    139:     tp1: float
  9093:    140:     tp2: float
  9094:    141:     qty: float = 0.0
  9095:    142:     score: Optional[float] = None
  9096:    143:     quality: Optional[float] = None
  9097:    144:     reasons: Optional[List[str]] = None
  9098:    145: 
  9099:    146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
  9100:    147:         if isinstance(self.side, str):
  9101:    148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
  9102:    149: 
  9103:    150:     @property
  9104:    151:     def price(self) -> float:
  9105:    152:         return self.entry
  9106:    153: 
  9107:    154: 
  9108:    155: def _generate_signal(
  9109:    156:     symbol: str,
  9110:    157:     ohlcv: Dict[str, Sequence[float]],
  9111:    158:     *,
  9112:    159:     equity: float,
  9113:    160:     risk_pct: float,
  9114:    161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
  9115:    162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
  9116:    163:     order_book: Optional[Dict[str, float]] = None,
  9117:    164:     tick_ratio_buy: Optional[float] = None,
  9118:    165:     atr_disable_pct: float = 0.2,
  9119:    166:     atr_reduce_pct: float = 2.0,
  9120:    167:     swing_lookback: int = 5,
  9121:    168:     macd_fast: int = 12,
  9122:    169:     macd_slow: int = 26,
  9123:    170:     macd_signal: int = 9,
  9124:    171:     trend_ema_period: int = 200,
  9125:    172: ) -> Optional[Signal]:
  9126:    173:     """Return a trading :class:`Signal` if conditions are met.
  9127:    174: 
  9128:    175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
  9129:    176:     sequences ordered from oldest to newest.  The function checks the following
  9130:    177:     rules:
  9131:    178: 
  9132:    179:     * price positioned relative to VWAP and EMA20/EMA50 trend
  9133:    180:     * RSI(14) crossing key levels (40/60)
  9134:    181:     * OBV rising or high short‑term volume
  9135:    182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
  9136:    183:     * Micro‑structure breakout of last swing high/low
  9137:    184:     * MACD trend filter
  9138:    185:     * Long‑term trend via configurable EMA filter
  9139:    186:     * Order book imbalance and tape filters
  9140:    187:     * Dynamic ATR‑based stop‑loss and take‑profit
  9141:    188:     * Position sizing via ``calc_position_size``
  9142:    189:     """
  9143:    190: 
  9144:    191:     closes = [float(x) for x in ohlcv.get("close", [])]
  9145:    192:     highs = [float(x) for x in ohlcv.get("high", [])]
  9146:    193:     lows = [float(x) for x in ohlcv.get("low", [])]
  9147:    194:     vols = [float(x) for x in ohlcv.get("volume", [])]
  9148:    195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
  9149:    196:         return None
  9150:    197: 
  9151:    198:     price = closes[-1]
  9152:    199:     ema20 = ema(closes, 20)
  9153:    200:     ema50 = ema(closes, 50)
  9154:    201:     ema_trend = ema(closes, trend_ema_period)
  9155:    202:     v = vwap(highs, lows, closes, vols)
  9156:    203:     obv_series = obv(closes, vols)
  9157:    204:     obv_rising = obv_series[-1] > obv_series[-2]
  9158:    205:     vol_last3 = sum(vols[-3:])
  9159:    206:     vol_ma20 = sum(vols[-20:]) / 20.0
  9160:    207:     vol_rising = vol_last3 > vol_ma20
  9161:    208: 
  9162:    209:     macd_val, macd_sig, _ = calc_macd(
  9163:    210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
  9164:    211:     )
  9165:    212: 
  9166:    213:     # Multi timeframe filters -------------------------------------------------
  9167:    214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
  9168:    215:     if ohlcv_1h:
  9169:    216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
  9170:    217:         if len(h_closes) >= 52:
  9171:    218:             h_ema50 = ema(h_closes, 50)
  9172:    219:             if len(h_ema50) >= 2:
  9173:    220:                 slope = h_ema50[-1] - h_ema50[-2]
  9174:    221:                 if slope > 0:
  9175:    222:                     trend_dir = 1
  9176:    223:                 elif slope < 0:
  9177:    224:                     trend_dir = -1
  9178:    225: 
  9179:    226:     rsi_15 = None
  9180:    227:     if ohlcv_15m:
  9181:    228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
  9182:    229:         if len(m_closes) >= 15:
  9183:    230:             rsi_15 = calc_rsi(m_closes, 14)
  9184:    231: 
  9185:    232:     # RSI crossing logic (5m)
  9186:    233:     rsi_curr = calc_rsi(closes[-15:], 14)
  9187:    234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
  9188:    235: 
  9189:    236:     atr = calc_atr(highs, lows, closes, 14)
  9190:    237:     atr_pct = atr / price * 100.0 if price else 0.0
  9191:    238:     if atr_pct < atr_disable_pct:
  9192:    239:         return None
  9193:    240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
  9194:    241: 
  9195:    242:     sl_dist = 0.5 * atr
  9196:    243:     tp1_dist = 1.0 * atr
  9197:    244:     tp2_dist = 1.5 * atr
  9198:    245: 
  9199:    246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
  9200:    247: 
  9201:    248:     obi_ok_long = obi_ok_short = True
  9202:    249:     if order_book is not None:
  9203:    250:         bid = float(order_book.get("bid_vol_aggreg", 0))
  9204:    251:         ask = float(order_book.get("ask_vol_aggreg", 0))
  9205:    252:         obi = order_book_imbalance(bid, ask)
  9206:    253:         obi_ok_long = obi > 0.1
  9207:    254:         obi_ok_short = obi < -0.1
  9208:    255: 
  9209:    256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
  9210:    257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
  9211:    258: 
  9212:    259:     def _size(dist: float) -> float:
  9213:    260:         return calc_position_size(equity, risk_pct, dist) * size_mult
  9214:    261:     weights = {
  9215:    262:         "ema": 15.0,
  9216:    263:         "macd": 15.0,
  9217:    264:         "vwap": 15.0,
  9218:    265:         "rsi": 15.0,
  9219:    266:         "obv": 10.0,
  9220:    267:         "swing": 10.0,
  9221:    268:         "atr": 20.0,
  9222:    269:     }
  9223:    270: 
  9224:    271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
  9225:    272: 
  9226:    273:     long_score = atr_score
  9227:    274:     long_reasons: List[str] = []
  9228:    275:     if price > v:
  9229:    276:         long_score += weights["vwap"]
  9230:    277:         long_reasons.append("vwap")
  9231:    278:     if ema20[-1] > ema50[-1]:
  9232:    279:         long_score += weights["ema"]
  9233:    280:         long_reasons.append("ema")
  9234:    281:     if rsi_prev <= 40 < rsi_curr:
  9235:    282:         long_score += weights["rsi"]
  9236:    283:         long_reasons.append("rsi")
  9237:    284:     if macd_val > macd_sig:
  9238:    285:         long_score += weights["macd"]
  9239:    286:         long_reasons.append("macd")
  9240:    287:     if obv_rising or vol_rising:
  9241:    288:         long_score += weights["obv"]
  9242:    289:         long_reasons.append("obv")
  9243:    290:     if price > swing_high:
  9244:    291:         long_score += weights["swing"]
  9245:    292:         long_reasons.append("swing")
  9246:    293: 
  9247:    294:     short_score = atr_score
  9248:    295:     short_reasons: List[str] = []
  9249:    296:     if price < v:
  9250:    297:         short_score += weights["vwap"]
  9251:    298:         short_reasons.append("vwap")
  9252:    299:     if ema20[-1] < ema50[-1]:
  9253:    300:         short_score += weights["ema"]
  9254:    301:         short_reasons.append("ema")
  9255:    302:     if rsi_prev >= 60 > rsi_curr:
  9256:    303:         short_score += weights["rsi"]
  9257:    304:         short_reasons.append("rsi")
  9258:    305:     if macd_val < macd_sig:
  9259:    306:         short_score += weights["macd"]
  9260:    307:         short_reasons.append("macd")
  9261:    308:     if obv_series[-1] < obv_series[-2] or vol_rising:
  9262:    309:         short_score += weights["obv"]
  9263:    310:         short_reasons.append("obv")
  9264:    311:     if price < swing_low:
  9265:    312:         short_score += weights["swing"]
  9266:    313:         short_reasons.append("swing")
  9267:    314: 
  9268:    315:     side: Optional[str] = None
  9269:    316:     score: float = 0.0
  9270:    317:     reasons: List[str] = []
  9271:    318:     if (
  9272:    319:         long_score >= short_score
  9273:    320:         and long_score > 0
  9274:    321:         and macd_val > macd_sig
  9275:    322:         and obi_ok_long
  9276:    323:         and tick_ok_long
  9277:    324:         and trend_dir >= 0
  9278:    325:         and price > ema_trend[-1]
  9279:    326:     ):
  9280:    327:         side = "long"
  9281:    328:         score = long_score
  9282:    329:         reasons = long_reasons
  9283:    330:         sl = price - sl_dist
  9284:    331:         tp1 = price + tp1_dist
  9285:    332:         tp2 = price + tp2_dist
  9286:    333:     elif (
  9287:    334:         short_score > long_score
  9288:    335:         and short_score > 0
  9289:    336:         and macd_val < macd_sig
  9290:    337:         and obi_ok_short
  9291:    338:         and tick_ok_short
  9292:    339:         and trend_dir <= 0
  9293:    340:         and price < ema_trend[-1]
  9294:    341:     ):
  9295:    342:         side = "short"
  9296:    343:         score = short_score
  9297:    344:         reasons = short_reasons
  9298:    345:         sl = price + sl_dist
  9299:    346:         tp1 = price - tp1_dist
  9300:    347:         tp2 = price - tp2_dist
  9301:    348:     else:
  9302:    349:         return None
  9303:    350: 
  9304:    351:     qty = _size(sl_dist)
  9305:    352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
  9306:    353: 
  9307:    354: 
  9308:    355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
  9309:    356:     if "config" in kwargs:
  9310:    357:         config = kwargs.pop("config")
  9311:    358:         symbol = kwargs.pop("symbol", None)
  9312:    359:         ohlcv = kwargs.pop("ohlcv", None)
  9313:    360:         if ohlcv is None:
  9314:    361:             raise TypeError("ohlcv argument required")
  9315:    362:         return _generate_signal(
  9316:    363:             symbol or ohlcv.get("symbol", ""),
  9317:    364:             ohlcv,
  9318:    365:             equity=kwargs.pop("equity", 0.0),
  9319:    366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
  9320:    367:             **kwargs,
  9321:    368:         )
  9322:    369:     return _generate_signal(*args, **kwargs)
  9323:    370: 
  9324:    371: # ---------------------------------------------------------------------------
  9325:    372: # Backtesting utilities
  9326:    373: # ---------------------------------------------------------------------------
  9327:    374: 
  9328:    375: def max_drawdown(equity_curve: Sequence[float]) -> float:
  9329:    376:     peak = equity_curve[0]
  9330:    377:     mdd = 0.0
  9331:    378:     for x in equity_curve:
  9332:    379:         if x > peak:
  9333:    380:             peak = x
  9334:    381:         dd = (peak - x) / peak * 100.0
  9335:    382:         if dd > mdd:
  9336:    383:             mdd = dd
  9337:    384:     return mdd
  9338:    385: 
  9339:    386: def backtest(
  9340:    387:     trades: Sequence[Dict[str, Any]],
  9341:    388:     *,
  9342:    389:     equity_start: float = 1_000.0,
  9343:    390:     fee_rate: float = 0.0,
  9344:    391: ) -> Dict[str, float]:
  9345:    392:     """Evaluate a list of trade dictionaries.
  9346:    393: 
  9347:    394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
  9348:    395:     optionally include ``duration`` in minutes.  Results are aggregated into
  9349:    396:     common performance metrics to quickly evaluate the strategy.
  9350:    397:     """
  9351:    398: 
  9352:    399:     equity = equity_start
  9353:    400:     equity_curve = [equity]
  9354:    401:     pnl_pct_list: List[float] = []
  9355:    402:     wins = losses = 0
  9356:    403:     win_sum = loss_sum = 0.0
  9357:    404:     total_duration = 0.0
  9358:    405: 
  9359:    406:     for t in trades:
  9360:    407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
  9361:    408:         pnl_pct_list.append(pnl_pct)
  9362:    409:         if pnl_pct >= 0:
  9363:    410:             wins += 1
  9364:    411:             win_sum += pnl_pct
  9365:    412:         else:
  9366:    413:             losses += 1
  9367:    414:             loss_sum += pnl_pct
  9368:    415:         equity *= 1 + pnl_pct / 100.0
  9369:    416:         equity_curve.append(equity)
  9370:    417:         total_duration += float(t.get("duration", 0.0))
  9371:    418: 
  9372:    419:     pnl_pct_total = sum(pnl_pct_list)
  9373:    420:     pnl_usdt = equity - equity_start
  9374:    421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
  9375:    422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
  9376:    423:     mdd = max_drawdown(equity_curve)
  9377:    424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
  9378:    425:     exposure = total_duration  # in minutes, callers can normalise if desired
  9379:    426:     # Sharpe ratio based on per-trade returns
  9380:    427:     if len(pnl_pct_list) > 1:
  9381:    428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
  9382:    429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
  9383:    430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
  9384:    431:     else:
  9385:    432:         sharpe = 0.0
  9386:    433: 
  9387:    434:     return {
  9388:    435:         "pnl_usdt": pnl_usdt,
  9389:    436:         "pnl_pct": pnl_pct_total,
  9390:    437:         "profit_factor": profit_factor,
  9391:    438:         "winrate": winrate,
  9392:    439:         "max_drawdown": mdd,
  9393:    440:         "avg_trade_time": avg_trade_time,
  9394:    441:         "exposure": exposure,
  9395:    442:         "sharpe": sharpe,
  9396:    443:     }
  9397: 
  9398: 
  9399: ## scalper/trade_utils.py (last modified: 2025-08-23 20:57:14)
  9400:      1: # scalper/trade_utils.py
  9401:      2: from __future__ import annotations
  9402:      3: 
  9403:      4: from typing import Optional
  9404:      5: 
  9405:      6: 
  9406:      7: def compute_position_size(
  9407:      8:     equity: float,
  9408:      9:     price: float,
  9409:     10:     risk_pct: float,
  9410:     11:     *,
  9411:     12:     symbol: Optional[str] = None,
  9412:     13:     min_qty: float = 0.0,
  9413:     14:     max_leverage: float = 1.0,
  9414:     15: ) -> float:
  9415:     16:     """
  9416:     17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
  9417:     18:     qty = notionnel / price
  9418:     19:     - min_qty : borne basse éventuelle (0 pour ignorer)
  9419:     20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
  9420:     21:     """
  9421:     22:     equity = float(max(0.0, equity))
  9422:     23:     price = float(max(1e-12, price))
  9423:     24:     risk_pct = float(max(0.0, risk_pct))
  9424:     25:     notionnel = equity * risk_pct * max_leverage
  9425:     26:     qty = notionnel / price
  9426:     27:     if min_qty > 0 and qty < min_qty:
  9427:     28:         return 0.0
  9428:     29:     return float(qty)
  9429: 
  9430: ## scalper/version.py (last modified: 2025-08-23 20:57:14)
  9431:      1: """Utilities for managing the Scalp bot version."""
  9432:      2: 
  9433:      3: from __future__ import annotations
  9434:      4: 
  9435:      5: from pathlib import Path
  9436:      6: import re
  9437:      7: 
  9438:      8: import subprocess
  9439:      9: 
  9440:     10: 
  9441:     11: # Path to the VERSION file within the package
  9442:     12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
  9443:     13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
  9444:     14: 
  9445:     15: 
  9446:     16: def get_version() -> str:
  9447:     17:     """Return the current version of the bot.
  9448:     18: 
  9449:     19:     If the VERSION file does not exist the default version ``0.0.0`` is
  9450:     20:     returned.
  9451:     21:     """
  9452:     22:     if not _VERSION_FILE.exists():
  9453:     23:         return "0.0.0"
  9454:     24:     return _VERSION_FILE.read_text().strip()
  9455:     25: 
  9456:     26: 
  9457:     27: def _parse(version: str) -> tuple[int, int, int]:
  9458:     28:     match = _VERSION_RE.match(version)
  9459:     29:     if not match:
  9460:     30:         raise ValueError(f"Invalid version: {version!r}")
  9461:     31:     return tuple(int(x) for x in match.groups())
  9462:     32: 
  9463:     33: 
  9464:     34: def bump_version(part: str = "patch") -> str:
  9465:     35:     """Bump the version stored in the VERSION file.
  9466:     36: 
  9467:     37:     Parameters
  9468:     38:     ----------
  9469:     39:     part:
  9470:     40:         Which component to increment. Accepted values are ``"major"``,
  9471:     41:         ``"minor"`` and ``"patch"`` (default).
  9472:     42:     """
  9473:     43:     major, minor, patch = _parse(get_version())
  9474:     44:     if part == "major":
  9475:     45:         major += 1
  9476:     46:         minor = 0
  9477:     47:         patch = 0
  9478:     48:     elif part == "minor":
  9479:     49:         minor += 1
  9480:     50:         patch = 0
  9481:     51: 
  9482:     52:     elif part == "patch":
  9483:     53:         patch += 1
  9484:     54:     else:
  9485:     55:         raise ValueError(f"Unknown part: {part}")
  9486:     56:     new_version = f"{major}.{minor}.{patch}"
  9487:     57:     _VERSION_FILE.write_text(f"{new_version}\n")
  9488:     58:     return new_version
  9489:     59: 
  9490:     60: 
  9491:     61: def bump_version_from_message(message: str) -> str:
  9492:     62:     """Bump the version according to a commit message.
  9493:     63: 
  9494:     64:     ``message`` is evaluated using a tiny subset of the Conventional
  9495:     65:     Commits spec. Messages starting with ``feat`` bump the *minor*
  9496:     66:     version, messages whose header ends with ``!`` or contain
  9497:     67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
  9498:     68:     bump the *patch* component.
  9499:     69:     """
  9500:     70: 
  9501:     71:     header = message.strip().splitlines()[0].lower()
  9502:     72:     lower = message.lower()
  9503:     73:     type_part = header.split(":")[0]
  9504:     74:     if "!" in type_part or "breaking change" in lower:
  9505:     75:         part = "major"
  9506:     76:     elif type_part.startswith("feat"):
  9507:     77:         part = "minor"
  9508:     78:     else:
  9509:     79:         part = "patch"
  9510:     80:     return bump_version(part)
  9511:     81: 
  9512:     82: 
  9513:     83: def bump_version_from_git() -> str:
  9514:     84:     """Read the latest git commit message and bump the version accordingly."""
  9515:     85:     try:
  9516:     86:         message = subprocess.check_output(
  9517:     87:             ["git", "log", "-1", "--pretty=%B"], text=True
  9518:     88:         ).strip()
  9519:     89:     except Exception:
  9520:     90:         message = ""
  9521:     91:     return bump_version_from_message(message)
  9522:     92: 
  9523:     93: 
  9524:     94: if __name__ == "__main__":
  9525:     95:     print(bump_version_from_git())
  9526: 
  9527: 
  9528: ## scalper/ws.py (last modified: 2025-08-23 20:57:14)
  9529:      1: """Minimal websocket manager with heartbeat and auto-resubscribe.
  9530:      2: 
  9531:      3: This module provides a light-weight framework to maintain a realtime
  9532:      4: connection to an exchange.  The actual network layer is expected to be
  9533:      5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
  9534:      6: manager handles retrying failed connections and periodically invoking the
  9535:      7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
  9536:      8: without opening real network sockets.
  9537:      9: """
  9538:     10: from __future__ import annotations
  9539:     11: 
  9540:     12: import asyncio
  9541:     13: import logging
  9542:     14: from typing import Awaitable, Callable, Optional
  9543:     15: 
  9544:     16: 
  9545:     17: class WebsocketManager:
  9546:     18:     """Maintain a websocket connection with heartbeat and retry."""
  9547:     19: 
  9548:     20:     def __init__(
  9549:     21:         self,
  9550:     22:         connect: Callable[[], Awaitable[None]],
  9551:     23:         subscribe: Callable[[], Awaitable[None]],
  9552:     24:         *,
  9553:     25:         heartbeat_interval: float = 30.0,
  9554:     26:         max_retries: int = 3,
  9555:     27:     ) -> None:
  9556:     28:         self._connect = connect
  9557:     29:         self._subscribe = subscribe
  9558:     30:         self.heartbeat_interval = heartbeat_interval
  9559:     31:         self.max_retries = max_retries
  9560:     32:         self._heartbeat_task: Optional[asyncio.Task] = None
  9561:     33: 
  9562:     34:     async def run(self) -> None:
  9563:     35:         """Open the connection retrying on failure."""
  9564:     36:         retries = 0
  9565:     37:         while True:
  9566:     38:             try:
  9567:     39:                 await self._connect()
  9568:     40:                 await self._subscribe()
  9569:     41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
  9570:     42:                 return
  9571:     43:             except Exception as exc:  # pragma: no cover - network errors
  9572:     44:                 logging.error("websocket connect failed: %s", exc)
  9573:     45:                 retries += 1
  9574:     46:                 if retries > self.max_retries:
  9575:     47:                     raise
  9576:     48:                 await asyncio.sleep(1)
  9577:     49: 
  9578:     50:     async def _heartbeat(self) -> None:
  9579:     51:         """Send periodic heartbeats and resubscribe on failure."""
  9580:     52:         while True:
  9581:     53:             await asyncio.sleep(self.heartbeat_interval)
  9582:     54:             try:
  9583:     55:                 await self._subscribe()
  9584:     56:             except Exception as exc:  # pragma: no cover - network errors
  9585:     57:                 logging.warning("websocket heartbeat failed: %s", exc)
  9586:     58:                 await self.run()
  9587:     59:                 break
  9588:     60: 
  9589:     61:     async def stop(self) -> None:
  9590:     62:         """Cancel the heartbeat task if it is running."""
  9591:     63:         task = self._heartbeat_task
  9592:     64:         if task and not task.done():
  9593:     65:             task.cancel()
  9594:     66:             try:
  9595:     67:                 await task
  9596:     68:             except BaseException:  # pragma: no cover - cancellation
  9597:     69:                 pass
  9598:     70:         self._heartbeat_task = None
  9599: 
  9600: 
  9601: ## sitecustomize.py (last modified: 2025-08-23 20:57:14)
  9602:      1: # sitecustomize.py
  9603:      2: """
  9604:      3: Ce fichier est importé automatiquement par Python au démarrage, si présent sur sys.path.
  9605:      4: On l'utilise pour lancer un préflight de 'scalper' avant l'exécution du bot,
  9606:      5: sans modifier bot.py. Désactivable via SKIP_PREFLIGHT=1.
  9607:      6: """
  9608:      7: 
  9609:      8: import os
  9610:      9: 
  9611:     10: if os.getenv("SKIP_PREFLIGHT", "0") not in ("1", "true", "yes"):
  9612:     11:     try:
  9613:     12:         # Optionnel: charger /notebooks/.env si présent
  9614:     13:         try:
  9615:     14:             from dotenv import load_dotenv  # pip install python-dotenv si besoin
  9616:     15:             load_dotenv("/notebooks/.env")
  9617:     16:         except Exception:
  9618:     17:             pass
  9619:     18: 
  9620:     19:     except Exception:
  9621:     20:         pass
  9622:     21: 
  9623:     22:     try:
  9624:     23:         from scalper.selfcheck import preflight_or_die
  9625:     24:         preflight_or_die(verbose=False)
  9626:     25:     except SystemExit:
  9627:     26:         # le préflight a signalé un problème -> on laisse l'arrêt se propager
  9628:     27:         raise
  9629:     28:     except Exception as e:
  9630:     29:         # On ne bloque pas le démarrage si le selfcheck lui-même plante,
  9631:     30:         # mais on affiche une alerte claire.
  9632:     31:         print(f"[sitecustomize] Avertissement: selfcheck non exécuté ({e})")
  9633: 
  9634: ## tests/conftest.py (last modified: 2025-08-23 20:57:14)
  9635:      1: """Test configuration and shared fixtures."""
  9636:      2: 
  9637:      3: import sys
  9638:      4: import types
  9639:      5: from pathlib import Path
  9640:      6: 
  9641:      7: 
  9642:      8: # Ensure the project root is importable so tests can ``import bot``.
  9643:      9: ROOT = Path(__file__).resolve().parents[1]
  9644:     10: sys.path.insert(0, str(ROOT))
  9645:     11: 
  9646:     12: 
  9647:     13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
  9648:     14: # the real dependency during test collection. Individual tests patch the
  9649:     15: # functions they need (``request``/``post``/``get``).
  9650:     16: sys.modules.setdefault(
  9651:     17:     "requests",
  9652:     18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
  9653:     19: )
  9654:     20: 
  9655: 
  9656: 
  9657: ## tests/test_analyse_risque.py (last modified: 2025-08-23 20:57:14)
  9658:      1: import os
  9659:      2: import sys
  9660:      3: import types
  9661:      4: 
  9662:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
  9663:      6: sys.modules['requests'] = types.SimpleNamespace(
  9664:      7:     request=lambda *a, **k: None,
  9665:      8:     post=lambda *a, **k: None,
  9666:      9:     HTTPError=Exception,
  9667:     10: )
  9668:     11: 
  9669:     12: from bot import analyse_risque  # noqa: E402
  9670:     13: 
  9671:     14: 
  9672:     15: def make_contract_detail():
  9673:     16:     return {
  9674:     17:         "data": [
  9675:     18:             {
  9676:     19:                 "symbol": "BTC_USDT",
  9677:     20:                 "contractSize": 0.01,
  9678:     21:                 "volUnit": 1,
  9679:     22:                 "minVol": 1,
  9680:     23:             }
  9681:     24:         ]
  9682:     25:     }
  9683:     26: 
  9684:     27: 
  9685:     28: def test_analyse_risque_limits_and_leverage():
  9686:     29:     contract_detail = make_contract_detail()
  9687:     30:     # Risk level 1: leverage halved, limit 1 position
  9688:     31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
  9689:     32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9690:     33:                                symbol="BTC_USDT", side="long", risk_level=1)
  9691:     34:     assert lev == 5
  9692:     35:     assert vol == 0  # already one long position
  9693:     36: 
  9694:     37:     # Risk level 2: base leverage, limit 3 positions
  9695:     38:     open_pos = [
  9696:     39:         {"symbol": "BTC_USDT", "side": "long"},
  9697:     40:         {"symbol": "BTC_USDT", "side": "long"},
  9698:     41:         {"symbol": "BTC_USDT", "side": "long"},
  9699:     42:     ]
  9700:     43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9701:     44:                                symbol="BTC_USDT", side="long", risk_level=2)
  9702:     45:     assert lev == 10
  9703:     46:     assert vol == 0
  9704:     47: 
  9705:     48:     # Risk level 3: leverage doubled, no existing position
  9706:     49:     open_pos = []
  9707:     50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9708:     51:                                symbol="BTC_USDT", side="long", risk_level=3)
  9709:     52:     assert lev == 20
  9710:     53:     assert vol == 1
  9711: 
  9712: 
  9713: ## tests/test_backtest.py (last modified: 2025-08-23 20:57:14)
  9714:      1: import pytest
  9715:      2: 
  9716:      3: import bot
  9717:      4: 
  9718:      5: 
  9719:      6: def test_backtest_trades():
  9720:      7:     trades = [
  9721:      8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
  9722:      9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
  9723:     10:     ]
  9724:     11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
  9725:     12:     # Both trades: 10% - 0.2% fee = 9.8% each
  9726:     13:     assert pnl == pytest.approx(19.6)
  9727: 
  9728: 
  9729: ## tests/test_backtest_multi.py (last modified: 2025-08-23 20:57:14)
  9730:      1: import csv
  9731:      2: import random
  9732:      3: from datetime import datetime, timedelta, timezone
  9733:      4: from pathlib import Path
  9734:      5: 
  9735:      6: import pytest
  9736:      7: 
  9737:      8: from scalper.backtest.run_multi import run_backtest_multi
  9738:      9: from scalper.strategy import Signal
  9739:     10: 
  9740:     11: 
  9741:     12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
  9742:     13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
  9743:     14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
  9744:     15:     with open(filename, "w", newline="") as fh:
  9745:     16:         writer = csv.writer(fh)
  9746:     17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
  9747:     18:         for i in range(200):
  9748:     19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
  9749:     20:             price = 100 + i
  9750:     21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
  9751:     22: 
  9752:     23: 
  9753:     24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9754:     25:     closes = ohlcv["close"]
  9755:     26:     if len(closes) < 10:
  9756:     27:         return None
  9757:     28:     price = closes[-1]
  9758:     29:     sl = price * 0.99
  9759:     30:     tp = price * 1.01
  9760:     31:     qty = equity * risk_pct / (price - sl)
  9761:     32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
  9762:     33: 
  9763:     34: 
  9764:     35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9765:     36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
  9766:     37:         return None
  9767:     38:     price = ohlcv["close"][-1]
  9768:     39:     sl = price * 0.99
  9769:     40:     tp = price * 1.01
  9770:     41:     qty = equity * risk_pct / (price - sl)
  9771:     42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
  9772:     43: 
  9773:     44: 
  9774:     45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9775:     46:     closes = ohlcv["close"]
  9776:     47:     if len(closes) < 10:
  9777:     48:         return None
  9778:     49:     price = closes[-1]
  9779:     50:     sl = price * 0.99
  9780:     51:     tp = price * 1.01
  9781:     52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
  9782:     53: 
  9783:     54: 
  9784:     55: def find_row(summary, symbol):
  9785:     56:     for row in summary:
  9786:     57:         if row["symbol"] == symbol:
  9787:     58:             return row
  9788:     59:     raise KeyError(symbol)
  9789:     60: 
  9790:     61: 
  9791:     62: def test_csv_multi_pairs(tmp_path, monkeypatch):
  9792:     63:     for sym in ["BTC/USDT", "ETH/USDT"]:
  9793:     64:         make_csv(tmp_path, sym)
  9794:     65:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
  9795:     66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
  9796:     67:     out = tmp_path / "out"
  9797:     68:     summary, trades = run_backtest_multi(
  9798:     69:         symbols=["BTC/USDT", "ETH/USDT"],
  9799:     70:         exchange="csv",
  9800:     71:         timeframe="1m",
  9801:     72:         csv_dir=str(tmp_path),
  9802:     73:         fee_rate=0.0,
  9803:     74:         slippage_bps=0.0,
  9804:     75:         risk_pct=0.01,
  9805:     76:         initial_equity=1000,
  9806:     77:         leverage=1.0,
  9807:     78:         paper_constraints=True,
  9808:     79:         seed=42,
  9809:     80:         out_dir=str(out),
  9810:     81:         plot=False,
  9811:     82:     )
  9812:     83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
  9813:     84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
  9814:     85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
  9815:     86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
  9816:     87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
  9817:     88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
  9818:     89:     # files
  9819:     90:     assert (out / "report_summary.csv").exists()
  9820:     91:     assert (out / "report_trades.csv").exists()
  9821:     92:     assert (out / "equity_curve_total.csv").exists()
  9822:     93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
  9823:     94:     # columns in trades
  9824:     95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
  9825:     96:         assert col in trades[0]
  9826:     97: 
  9827:     98: 
  9828:     99: def test_fee_slippage(tmp_path, monkeypatch):
  9829:    100:     make_csv(tmp_path, "BTC/USDT")
  9830:    101:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
  9831:    102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
  9832:    103:     summary1, _ = run_backtest_multi(
  9833:    104:         symbols=["BTC/USDT"],
  9834:    105:         exchange="csv",
  9835:    106:         timeframe="1m",
  9836:    107:         csv_dir=str(tmp_path),
  9837:    108:         fee_rate=0.0,
  9838:    109:         slippage_bps=0.0,
  9839:    110:         out_dir=str(tmp_path / "o1"),
  9840:    111:     )
  9841:    112:     summary2, _ = run_backtest_multi(
  9842:    113:         symbols=["BTC/USDT"],
  9843:    114:         exchange="csv",
  9844:    115:         timeframe="1m",
  9845:    116:         csv_dir=str(tmp_path),
  9846:    117:         fee_rate=0.01,
  9847:    118:         slippage_bps=100,
  9848:    119:         out_dir=str(tmp_path / "o2"),
  9849:    120:     )
  9850:    121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
  9851:    122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
  9852:    123:     assert pnl2 < pnl1
  9853:    124: 
  9854:    125: 
  9855:    126: def test_paper_constraints(tmp_path, monkeypatch):
  9856:    127:     make_csv(tmp_path, "BTC/USDT")
  9857:    128:     monkeypatch.setattr("scalper.strategy.generate_signal", tiny_qty_signal)
  9858:    129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
  9859:    130:     summary, trades = run_backtest_multi(
  9860:    131:         symbols=["BTC/USDT"],
  9861:    132:         exchange="csv",
  9862:    133:         timeframe="1m",
  9863:    134:         csv_dir=str(tmp_path),
  9864:    135:         paper_constraints=True,
  9865:    136:         out_dir=str(tmp_path / "o"),
  9866:    137:     )
  9867:    138:     assert all(t["qty"] >= 0.001 for t in trades)
  9868:    139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
  9869:    140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
  9870:    141: 
  9871:    142: 
  9872:    143: def test_seed_reproducible(tmp_path, monkeypatch):
  9873:    144:     make_csv(tmp_path, "BTC/USDT")
  9874:    145:     monkeypatch.setattr("scalper.strategy.generate_signal", random_signal)
  9875:    146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
  9876:    147:     s1, t1 = run_backtest_multi(
  9877:    148:         symbols=["BTC/USDT"],
  9878:    149:         exchange="csv",
  9879:    150:         timeframe="1m",
  9880:    151:         csv_dir=str(tmp_path),
  9881:    152:         seed=7,
  9882:    153:         out_dir=str(tmp_path / "o1"),
  9883:    154:     )
  9884:    155:     s2, t2 = run_backtest_multi(
  9885:    156:         symbols=["BTC/USDT"],
  9886:    157:         exchange="csv",
  9887:    158:         timeframe="1m",
  9888:    159:         csv_dir=str(tmp_path),
  9889:    160:         seed=7,
  9890:    161:         out_dir=str(tmp_path / "o2"),
  9891:    162:     )
  9892:    163:     assert t1 == t2
  9893:    164:     assert s1 == s2
  9894: 
  9895: 
  9896: ## tests/test_backtest_position.py (last modified: 2025-08-23 20:57:14)
  9897:      1: import os
  9898:      2: import sys
  9899:      3: import pytest
  9900:      4: 
  9901:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
  9902:      6: 
  9903:      7: from scalper.metrics import backtest_position
  9904:      8: 
  9905:      9: 
  9906:     10: def test_backtest_position_long():
  9907:     11:     prices = [100.0, 110.0, 120.0]
  9908:     12:     assert backtest_position(prices, 0, 2, 1) is True
  9909:     13: 
  9910:     14: 
  9911:     15: def test_backtest_position_short():
  9912:     16:     prices = [100.0, 90.0, 80.0]
  9913:     17:     assert backtest_position(prices, 0, 2, -1) is True
  9914:     18: 
  9915:     19: 
  9916:     20: def test_backtest_position_incoherent():
  9917:     21:     prices = [100.0, 110.0, 120.0]
  9918:     22:     assert backtest_position(prices, 0, 2, -1) is False
  9919:     23: 
  9920:     24: 
  9921:     25: def test_backtest_position_bad_indices():
  9922:     26:     prices = [100.0, 110.0]
  9923:     27:     with pytest.raises(ValueError):
  9924:     28:         backtest_position(prices, 1, 0, 1)
  9925: 
  9926: 
  9927: ## tests/test_bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
  9928:      1: import json
  9929:      2: from pathlib import Path
  9930:      3: from typing import Any, Dict
  9931:      4: 
  9932:      5: import pytest
  9933:      6: 
  9934:      7: import bitget_futures_pairs as bfp
  9935:      8: 
  9936:      9: 
  9937:     10: class DummyResponse:
  9938:     11:     def __init__(self, status: int, payload: Dict[str, Any]):
  9939:     12:         self.status_code = status
  9940:     13:         self._payload = payload
  9941:     14:         self.text = json.dumps(payload)
  9942:     15: 
  9943:     16:     def json(self):
  9944:     17:         return self._payload
  9945:     18: 
  9946:     19: 
  9947:     20: def test_fetch_contracts_success(monkeypatch):
  9948:     21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
  9949:     22: 
  9950:     23:     def fake_get(url, params=None, timeout=0):
  9951:     24:         return DummyResponse(200, payload)
  9952:     25: 
  9953:     26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
  9954:     27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
  9955:     28:     assert contracts == payload["data"]
  9956:     29: 
  9957:     30: 
  9958:     31: def test_fetch_contracts_error(monkeypatch):
  9959:     32:     payload = {"code": "10001"}
  9960:     33: 
  9961:     34:     def fake_get(url, params=None, timeout=0):
  9962:     35:         return DummyResponse(200, payload)
  9963:     36: 
  9964:     37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
  9965:     38:     with pytest.raises(RuntimeError):
  9966:     39:         bfp.fetch_contracts("USDT-FUTURES")
  9967:     40: 
  9968:     41: 
  9969:     42: def test_normalize_rows():
  9970:     43:     contracts = [
  9971:     44:         {
  9972:     45:             "symbol": "BTCUSDT",
  9973:     46:             "baseCoin": "BTC",
  9974:     47:             "quoteCoin": "USDT",
  9975:     48:             "symbolType": "perpetual",
  9976:     49:             "symbolStatus": "normal",
  9977:     50:             "maxLever": "50",
  9978:     51:             "minLever": "1",
  9979:     52:             "minTradeNum": "0.001",
  9980:     53:             "sizeMultiplier": "1",
  9981:     54:             "pricePlace": "2",
  9982:     55:             "volumePlace": "3",
  9983:     56:             "launchTime": 0,
  9984:     57:             "deliveryTime": 0,
  9985:     58:         }
  9986:     59:     ]
  9987:     60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
  9988:     61:     assert rows[0]["symbol"] == "BTCUSDT"
  9989:     62:     assert rows[0]["productType"] == "USDT-FUTURES"
  9990:     63: 
  9991:     64: 
  9992:     65: def test_write_csv(tmp_path: Path):
  9993:     66:     path = tmp_path / "pairs.csv"
  9994:     67:     bfp.write_csv([], str(path))
  9995:     68:     assert path.exists()
  9996:     69:     content = path.read_text().splitlines()
  9997:     70:     assert content[0].startswith("productType,")
  9998: 
  9999: 
 10000: ## tests/test_bot_place_order_caps.py (last modified: 2025-08-23 20:57:14)
 10001:      1: import os
 10002:      2: import sys
 10003:      3: import types
 10004:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10005:      5: sys.modules['requests'] = types.ModuleType('requests')
 10006:      6: 
 10007:      7: from bot import attempt_entry, Signal
 10008:      8: 
 10009:      9: 
 10010:     10: class DummyClient:
 10011:     11:     def __init__(self):
 10012:     12:         self.last_order = None
 10013:     13: 
 10014:     14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
 10015:     15:         self.last_order = (args, kwargs)
 10016:     16:         return {"code": "00000"}
 10017:     17: 
 10018:     18: 
 10019:     19: class DummyRisk:
 10020:     20:     def __init__(self, pct):
 10021:     21:         self.risk_pct = pct
 10022:     22: 
 10023:     23: 
 10024:     24: def _detail():
 10025:     25:     return {
 10026:     26:         "data": [
 10027:     27:             {
 10028:     28:                 "symbol": "BTC_USDT",
 10029:     29:                 "contractSize": 0.001,
 10030:     30:                 "volUnit": 1,
 10031:     31:                 "minVol": 1,
 10032:     32:                 "minTradeUSDT": 5,
 10033:     33:             }
 10034:     34:         ]
 10035:     35:     }
 10036:     36: 
 10037:     37: 
 10038:     38: def test_attempt_entry_respects_caps(monkeypatch):
 10039:     39:     captured = {}
 10040:     40: 
 10041:     41:     def fake_notify(event, payload):
 10042:     42:         captured[event] = payload
 10043:     43: 
 10044:     44:     monkeypatch.setattr("bot.notify", fake_notify)
 10045:     45:     client = DummyClient()
 10046:     46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10047:     47:     rm = DummyRisk(0.02)
 10048:     48:     equity = 100
 10049:     49:     available = 2.2  # just enough for 1 contract with buffer
 10050:     50:     params = attempt_entry(
 10051:     51:         client,
 10052:     52:         _detail(),
 10053:     53:         sig,
 10054:     54:         equity_usdt=equity,
 10055:     55:         available_usdt=available,
 10056:     56:         cfg={"LEVERAGE": 10},
 10057:     57:         risk_mgr=rm,
 10058:     58:         user_risk_level=1,
 10059:     59:     )
 10060:     60:     assert client.last_order is not None
 10061:     61:     assert params["vol"] >= 1
 10062:     62:     opened = captured["position_opened"]
 10063:     63:     assert opened["notional_usdt"] >= 5
 10064:     64:     assert opened["vol"] >= 1
 10065:     65: 
 10066:     66: 
 10067:     67: def test_attempt_entry_insufficient_margin(monkeypatch):
 10068:     68:     captured = {}
 10069:     69: 
 10070:     70:     def fake_notify(event, payload):
 10071:     71:         captured[event] = payload
 10072:     72: 
 10073:     73:     monkeypatch.setattr("bot.notify", fake_notify)
 10074:     74:     client = DummyClient()
 10075:     75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10076:     76:     rm = DummyRisk(0.02)
 10077:     77:     equity = 100
 10078:     78:     available = 1.0  # below required margin
 10079:     79:     params = attempt_entry(
 10080:     80:         client,
 10081:     81:         _detail(),
 10082:     82:         sig,
 10083:     83:         equity_usdt=equity,
 10084:     84:         available_usdt=available,
 10085:     85:         cfg={"LEVERAGE": 10},
 10086:     86:         risk_mgr=rm,
 10087:     87:         user_risk_level=1,
 10088:     88:     )
 10089:     89:     assert client.last_order is None
 10090:     90:     assert params["vol"] == 0
 10091:     91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 10092:     92: 
 10093:     93: 
 10094:     94: def test_attempt_entry_under_min_trade(monkeypatch):
 10095:     95:     captured = {}
 10096:     96: 
 10097:     97:     def fake_notify(event, payload):
 10098:     98:         captured[event] = payload
 10099:     99: 
 10100:    100:     monkeypatch.setattr("bot.notify", fake_notify)
 10101:    101:     client = DummyClient()
 10102:    102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10103:    103:     rm = DummyRisk(0.02)
 10104:    104:     detail = {
 10105:    105:         "data": [
 10106:    106:             {
 10107:    107:                 "symbol": "BTC_USDT",
 10108:    108:                 "contractSize": 0.001,
 10109:    109:                 "volUnit": 1,
 10110:    110:                 "minVol": 1,
 10111:    111:                 "minTradeUSDT": 50,
 10112:    112:             }
 10113:    113:         ]
 10114:    114:     }
 10115:    115:     equity = 100
 10116:    116:     available = 100
 10117:    117:     params = attempt_entry(
 10118:    118:         client,
 10119:    119:         detail,
 10120:    120:         sig,
 10121:    121:         equity_usdt=equity,
 10122:    122:         available_usdt=available,
 10123:    123:         cfg={"LEVERAGE": 10},
 10124:    124:         risk_mgr=rm,
 10125:    125:         user_risk_level=1,
 10126:    126:     )
 10127:    127:     assert client.last_order is None
 10128:    128:     assert params["vol"] == 0
 10129:    129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 10130: 
 10131: 
 10132: ## tests/test_bot_update.py (last modified: 2025-08-23 20:57:14)
 10133:      1: import logging
 10134:      2: import bot
 10135:      3: 
 10136:      4: 
 10137:      5: def test_update_displays_pairs(monkeypatch, caplog):
 10138:      6:     def fake_send(client, top_n=40):
 10139:      7:         assert (client, top_n) == ("cli", 5)
 10140:      8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
 10141:      9: 
 10142:     10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
 10143:     11:     with caplog.at_level(logging.INFO):
 10144:     12:         payload = bot.update("cli", top_n=5)
 10145:     13:     assert payload["green"] == "BTC"
 10146:     14:     assert "Listing ok" in caplog.text
 10147:     15: 
 10148:     16: 
 10149:     17: def test_update_survives_errors(monkeypatch, caplog):
 10150:     18:     """``update`` should never raise even if pair selection fails."""
 10151:     19: 
 10152:     20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
 10153:     21:         raise RuntimeError("network down")
 10154:     22: 
 10155:     23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
 10156:     24:     with caplog.at_level(logging.INFO):
 10157:     25:         payload = bot.update("cli", top_n=5)
 10158:     26: 
 10159:     27:     # The function returns an empty payload and logs the error, but still logs
 10160:     28:     # the "Listing ok" acknowledgement so callers can proceed.
 10161:     29:     assert payload == {}
 10162:     30:     assert "network down" in caplog.text
 10163:     31:     assert "Listing ok" in caplog.text
 10164:     32: 
 10165: 
 10166: 
 10167: ## tests/test_break_even_stop.py (last modified: 2025-08-23 20:57:14)
 10168:      1: from scalper.trade_utils import break_even_stop
 10169:      2: 
 10170:      3: 
 10171:      4: def test_break_even_stop_long() -> None:
 10172:      5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
 10173:      6:     assert sl == 100
 10174:      7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
 10175:      8:     assert sl == 95
 10176:      9: 
 10177:     10: 
 10178:     11: def test_break_even_stop_short() -> None:
 10179:     12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
 10180:     13:     assert sl == 100
 10181:     14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
 10182:     15:     assert sl == 105
 10183: 
 10184: 
 10185: ## tests/test_calc_pnl_pct.py (last modified: 2025-08-23 20:57:14)
 10186:      1: import os
 10187:      2: import sys
 10188:      3: import pytest
 10189:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10190:      5: 
 10191:      6: from scalper.metrics import calc_pnl_pct
 10192:      7: 
 10193:      8: 
 10194:      9: def test_calc_pnl_pct_long():
 10195:     10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
 10196:     11: 
 10197:     12: def test_calc_pnl_pct_short():
 10198:     13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
 10199:     14: 
 10200:     15: 
 10201:     16: def test_calc_pnl_pct_with_fee():
 10202:     17:     # 10% move minus 0.1%*2 fees = 9.8%
 10203:     18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)
 10204: 
 10205: 
 10206: ## tests/test_check_config.py (last modified: 2025-08-23 20:57:14)
 10207:      1: import logging
 10208:      2: from bot import check_config
 10209:      3: 
 10210:      4: 
 10211:      5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
 10212:      6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
 10213:      7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
 10214:      8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 10215:      9:     with caplog.at_level(logging.INFO):
 10216:     10:         check_config()
 10217:     11:     messages = [r.getMessage() for r in caplog.records]
 10218:     12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
 10219:     13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
 10220:     14:     assert all("NOTIFY_URL" not in m for m in messages)
 10221:     15: 
 10222:     16: 
 10223:     17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
 10224:     18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
 10225:     19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
 10226:     20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
 10227:     21:     with caplog.at_level(logging.INFO):
 10228:     22:         check_config()
 10229:     23:     assert caplog.records == []
 10230: 
 10231: 
 10232: ## tests/test_cli.py (last modified: 2025-08-23 20:57:14)
 10233:      1: """Tests for the command line interface defined in :mod:`cli`."""
 10234:      2: 
 10235:      3: from __future__ import annotations
 10236:      4: 
 10237:      5: import cli
 10238:      6: 
 10239:      7: 
 10240:      8: def test_opt_invokes_parallel_optimization(monkeypatch):
 10241:      9:     """The ``opt`` command should call ``run_parallel_optimization``."""
 10242:     10: 
 10243:     11:     called = {}
 10244:     12: 
 10245:     13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
 10246:     14:         called["args"] = (pairs, tf, jobs)
 10247:     15: 
 10248:     16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
 10249:     17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
 10250:     18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
 10251:     19: 
 10252:     20: 
 10253:     21: def test_walkforward_invokes_analysis(monkeypatch):
 10254:     22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
 10255:     23: 
 10256:     24:     called = {}
 10257:     25: 
 10258:     26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
 10259:     27:         called["args"] = (pair, tf, splits, train_ratio)
 10260:     28: 
 10261:     29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
 10262:     30:     cli.main(
 10263:     31:         [
 10264:     32:             "walkforward",
 10265:     33:             "--pair",
 10266:     34:             "BTCUSDT",
 10267:     35:             "--tf",
 10268:     36:             "1m",
 10269:     37:             "--splits",
 10270:     38:             "3",
 10271:     39:             "--train-ratio",
 10272:     40:             "0.8",
 10273:     41:         ]
 10274:     42:     )
 10275:     43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
 10276:     44: 
 10277:     45: 
 10278:     46: def test_live_invokes_async_pipeline(monkeypatch):
 10279:     47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
 10280:     48: 
 10281:     49:     called = {}
 10282:     50: 
 10283:     51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
 10284:     52:         called["args"] = (pairs, list(tfs))
 10285:     53: 
 10286:     54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
 10287:     55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
 10288:     56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
 10289:     57: 
 10290:     58: 
 10291:     59: def test_bump_version_invokes_helper(monkeypatch):
 10292:     60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
 10293:     61: 
 10294:     62:     called = {}
 10295:     63: 
 10296:     64:     def fake_bump():  # pragma: no cover - executed via CLI
 10297:     65:         called["called"] = True
 10298:     66:         return "0.1.0"
 10299:     67: 
 10300:     68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
 10301:     69:     cli.main(["bump-version"])
 10302:     70:     assert called["called"] is True
 10303:     71: 
 10304: 
 10305: 
 10306: ## tests/test_client.py (last modified: 2025-08-23 20:57:14)
 10307:      1: import json
 10308:      2: import hmac
 10309:      3: import hashlib
 10310:      4: import base64
 10311:      5: import pytest
 10312:      6: import bot
 10313:      7: from bot import BitgetFuturesClient
 10314:      8: 
 10315:      9: 
 10316:     10: @pytest.fixture(autouse=True)
 10317:     11: def no_log_event(monkeypatch):
 10318:     12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
 10319:     13: 
 10320:     14: 
 10321:     15: def test_private_request_get_signature(monkeypatch):
 10322:     16:     client = BitgetFuturesClient("key", "secret", "https://test")
 10323:     17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10324:     18: 
 10325:     19:     called = {}
 10326:     20: 
 10327:     21:     def fake_request(method, url, headers=None, timeout=None):
 10328:     22:         called["method"] = method
 10329:     23:         called["url"] = url
 10330:     24:         called["headers"] = headers
 10331:     25: 
 10332:     26:         class Resp:
 10333:     27:             def raise_for_status(self):
 10334:     28:                 pass
 10335:     29: 
 10336:     30:             def json(self):
 10337:     31:                 return {"success": True}
 10338:     32: 
 10339:     33:         return Resp()
 10340:     34: 
 10341:     35:     monkeypatch.setattr(bot.requests, "request", fake_request)
 10342:     36: 
 10343:     37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
 10344:     38:     assert resp["success"] is True
 10345:     39:     qs = "a=1&b=2"
 10346:     40:     prehash = f"1000GET/api/test?{qs}"
 10347:     41:     expected = base64.b64encode(
 10348:     42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 10349:     43:     ).decode()
 10350:     44:     assert called["headers"]["ACCESS-SIGN"] == expected
 10351:     45:     assert called["headers"]["ACCESS-KEY"] == "key"
 10352:     46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 10353:     47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 10354:     48:     assert called["url"] == "https://test/api/test?a=1&b=2"
 10355:     49: 
 10356:     50: 
 10357:     51: def test_private_request_post_signature(monkeypatch):
 10358:     52:     client = BitgetFuturesClient("key", "secret", "https://test")
 10359:     53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10360:     54: 
 10361:     55:     called = {}
 10362:     56: 
 10363:     57:     def fake_post(url, data=None, headers=None, timeout=None):
 10364:     58:         called["url"] = url
 10365:     59:         called["data"] = data
 10366:     60:         called["headers"] = headers
 10367:     61: 
 10368:     62:         class Resp:
 10369:     63:             def raise_for_status(self):
 10370:     64:                 pass
 10371:     65: 
 10372:     66:             def json(self):
 10373:     67:                 return {"success": True}
 10374:     68: 
 10375:     69:         return Resp()
 10376:     70: 
 10377:     71:     monkeypatch.setattr(bot.requests, "post", fake_post)
 10378:     72: 
 10379:     73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
 10380:     74:     assert resp["success"] is True
 10381:     75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
 10382:     76:     prehash = f"1000POST/api/test{body}"
 10383:     77:     expected = base64.b64encode(
 10384:     78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 10385:     79:     ).decode()
 10386:     80:     assert called["headers"]["ACCESS-SIGN"] == expected
 10387:     81:     assert called["headers"]["ACCESS-KEY"] == "key"
 10388:     82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 10389:     83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 10390:     84:     assert called["data"].decode("utf-8") == body
 10391:     85:     assert called["url"] == "https://test/api/test"
 10392:     86: 
 10393:     87: 
 10394:     88: def test_private_request_http_error(monkeypatch):
 10395:     89:     client = BitgetFuturesClient("key", "secret", "https://test")
 10396:     90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10397:     91: 
 10398:     92:     class Resp:
 10399:     93:         status_code = 418
 10400:     94: 
 10401:     95:         def raise_for_status(self):
 10402:     96:             raise bot.requests.HTTPError("teapot")
 10403:     97: 
 10404:     98:         def json(self):
 10405:     99:             return {"unused": True}
 10406:    100: 
 10407:    101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
 10408:    102: 
 10409:    103:     resp = client._private_request("GET", "/api/test")
 10410:    104:     assert resp["success"] is False
 10411:    105:     assert resp["status_code"] == 418
 10412:    106:     assert "teapot" in resp["error"]
 10413:    107: 
 10414:    108: 
 10415:    109: def test_get_assets_normalization(monkeypatch):
 10416:    110:     client = BitgetFuturesClient("key", "secret", "https://test")
 10417:    111: 
 10418:    112:     called = {}
 10419:    113: 
 10420:    114:     def fake_private(self, method, path, params=None, body=None):
 10421:    115:         called["method"] = method
 10422:    116:         called["path"] = path
 10423:    117:         called["params"] = params
 10424:    118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
 10425:    119: 
 10426:    120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10427:    121: 
 10428:    122:     assets = client.get_assets()
 10429:    123: 
 10430:    124:     assert assets["success"] is True
 10431:    125:     usdt = assets.get("data", [])[0]
 10432:    126:     assert usdt["currency"].upper() == "USDT"
 10433:    127:     assert usdt["equity"] == 1.0
 10434:    128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
 10435:    129: 
 10436:    130: 
 10437:    131: def test_get_assets_equity_fallback(monkeypatch):
 10438:    132:     client = BitgetFuturesClient("key", "secret", "https://test")
 10439:    133: 
 10440:    134:     def fake_private(self, method, path, params=None, body=None):
 10441:    135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
 10442:    136: 
 10443:    137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10444:    138: 
 10445:    139:     assets = client.get_assets()
 10446:    140:     usdt = assets.get("data", [])[0]
 10447:    141:     assert usdt["currency"] == "USDT"
 10448:    142:     assert usdt["equity"] == 2.0
 10449:    143: 
 10450:    144: 
 10451:    145: def test_get_assets_prefers_available(monkeypatch):
 10452:    146:     """When both equity and available are returned, available should win."""
 10453:    147:     client = BitgetFuturesClient("key", "secret", "https://test")
 10454:    148: 
 10455:    149:     def fake_private(self, method, path, params=None, body=None):
 10456:    150:         return {
 10457:    151:             "code": "00000",
 10458:    152:             "data": [
 10459:    153:                 {
 10460:    154:                     "marginCoin": "USDT",
 10461:    155:                     "equity": "5",
 10462:    156:                     "available": "1",
 10463:    157:                 }
 10464:    158:             ],
 10465:    159:         }
 10466:    160: 
 10467:    161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10468:    162: 
 10469:    163:     assets = client.get_assets()
 10470:    164:     usdt = assets.get("data", [])[0]
 10471:    165:     assert usdt["equity"] == 1.0
 10472:    166: 
 10473:    167: 
 10474:    168: 
 10475:    169: def test_get_assets_zero_available(monkeypatch):
 10476:    170:     """Zero available balance should propagate as zero equity."""
 10477:    171:     client = BitgetFuturesClient("key", "secret", "https://test")
 10478:    172: 
 10479:    173:     def fake_private(self, method, path, params=None, body=None):
 10480:    174:         return {
 10481:    175:             "code": "00000",
 10482:    176:             "data": [
 10483:    177:                 {
 10484:    178:                     "marginCoin": "USDT",
 10485:    179:                     "available": "0",
 10486:    180:                     "equity": "5",
 10487:    181:                 }
 10488:    182:             ],
 10489:    183:         }
 10490:    184: 
 10491:    185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10492:    186: 
 10493:    187:     assets = client.get_assets()
 10494:    188:     usdt = assets.get("data", [])[0]
 10495:    189:     assert usdt["equity"] == 0.0
 10496:    190: 
 10497:    191: 
 10498:    192: def test_get_assets_available_balance(monkeypatch):
 10499:    193:     """Support alternative ``availableBalance`` field name."""
 10500:    194:     client = BitgetFuturesClient("key", "secret", "https://test")
 10501:    195: 
 10502:    196:     def fake_private(self, method, path, params=None, body=None):
 10503:    197:         return {
 10504:    198:             "code": "00000",
 10505:    199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
 10506:    200:         }
 10507:    201: 
 10508:    202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10509:    203: 
 10510:    204:     assets = client.get_assets()
 10511:    205:     usdt = assets.get("data", [])[0]
 10512:    206:     assert usdt["equity"] == 3.5
 10513:    207: 
 10514:    208: 
 10515:    209: def test_get_ticker_normalization(monkeypatch):
 10516:    210:     client = BitgetFuturesClient("key", "secret", "https://test")
 10517:    211: 
 10518:    212:     called = {}
 10519:    213: 
 10520:    214:     def fake_get(url, params=None, timeout=None):
 10521:    215:         called["url"] = url
 10522:    216:         called["params"] = params
 10523:    217: 
 10524:    218:         class Resp:
 10525:    219:             def raise_for_status(self):
 10526:    220:                 pass
 10527:    221: 
 10528:    222:             def json(self):
 10529:    223:                 return {
 10530:    224:                     "data": {
 10531:    225:                         "instId": "BTCUSDT",
 10532:    226:                         "lastPr": "1",
 10533:    227:                         "bestBidPrice": "0.9",
 10534:    228:                         "bestAskPrice": "1.1",
 10535:    229:                         "usdtVolume": "100",
 10536:    230:                     }
 10537:    231:                 }
 10538:    232: 
 10539:    233:         return Resp()
 10540:    234: 
 10541:    235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10542:    236: 
 10543:    237:     ticker = client.get_ticker("BTC_USDT")
 10544:    238: 
 10545:    239:     assert ticker["success"] is True
 10546:    240:     data = ticker["data"][0]
 10547:    241:     assert data["symbol"] == "BTCUSDT"
 10548:    242:     assert data["lastPrice"] == "1"
 10549:    243:     assert data["bidPrice"] == "0.9"
 10550:    244:     assert data["askPrice"] == "1.1"
 10551:    245:     assert data["volume"] == 100.0
 10552:    246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
 10553:    247: 
 10554:    248: 
 10555:    249: def test_http_client_context_manager(monkeypatch):
 10556:    250:     import sys
 10557:    251:     import importlib
 10558:    252:     sys.modules.pop('requests', None)
 10559:    253:     real_requests = importlib.import_module('requests')
 10560:    254:     sys.modules['requests'] = real_requests
 10561:    255:     import scalper.client as http_client
 10562:    256:     importlib.reload(http_client)
 10563:    257: 
 10564:    258:     closed = {"count": 0}
 10565:    259: 
 10566:    260:     class DummySession:
 10567:    261:         def mount(self, *a, **k):
 10568:    262:             pass
 10569:    263: 
 10570:    264:         def request(self, *a, **k):
 10571:    265:             class Resp:
 10572:    266:                 def raise_for_status(self):
 10573:    267:                     pass
 10574:    268: 
 10575:    269:                 def json(self):
 10576:    270:                     return {}
 10577:    271: 
 10578:    272:                 text = "{}"
 10579:    273: 
 10580:    274:             return Resp()
 10581:    275: 
 10582:    276:         def close(self):
 10583:    277:             closed["count"] += 1
 10584:    278: 
 10585:    279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
 10586:    280: 
 10587:    281:     http = http_client.HttpClient("http://example.com")
 10588:    282:     http.close()
 10589:    283:     assert closed["count"] == 1
 10590:    284: 
 10591:    285:     closed["count"] = 0
 10592:    286:     with http_client.HttpClient("http://example.com") as hc:
 10593:    287:         hc.request("GET", "/")
 10594:    288:     assert closed["count"] == 1
 10595:    289: 
 10596:    290: 
 10597:    291: def test_get_kline_query_params(monkeypatch):
 10598:    292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
 10599:    293:     query parameter. The previous implementation embedded the symbol in the
 10600:    294:     path which resulted in a 404 from Bitget."""
 10601:    295: 
 10602:    296:     client = BitgetFuturesClient("key", "secret", "https://test")
 10603:    297: 
 10604:    298:     called = {}
 10605:    299: 
 10606:    300:     def fake_get(url, params=None, timeout=None):
 10607:    301:         called["url"] = url
 10608:    302:         called["params"] = params
 10609:    303: 
 10610:    304:         class Resp:
 10611:    305:             def raise_for_status(self):
 10612:    306:                 pass
 10613:    307: 
 10614:    308:             def json(self):
 10615:    309:                 return {"data": []}
 10616:    310: 
 10617:    311:         return Resp()
 10618:    312: 
 10619:    313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
 10620:    314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
 10621:    315:     # even if missing so we can observe the call.
 10622:    316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10623:    317: 
 10624:    318:     client.get_kline("BTC_USDT", interval="Min1")
 10625:    319: 
 10626:    320:     assert called["url"].endswith("/api/v2/mix/market/candles")
 10627:    321:     assert called["params"] == {
 10628:    322:         "symbol": "BTCUSDT",
 10629:    323:         "productType": "USDT-FUTURES",
 10630:    324:         "granularity": "1m",
 10631:    325:     }
 10632:    326: 
 10633:    327: 
 10634:    328: def test_get_open_orders_endpoint(monkeypatch):
 10635:    329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10636:    330: 
 10637:    331:     called = {}
 10638:    332: 
 10639:    333:     def fake_private(self, method, path, params=None, body=None):
 10640:    334:         called["method"] = method
 10641:    335:         called["path"] = path
 10642:    336:         called["params"] = params
 10643:    337:         return {"success": True}
 10644:    338: 
 10645:    339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10646:    340: 
 10647:    341:     client.get_open_orders("BTCUSDT_UMCBL")
 10648:    342: 
 10649:    343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
 10650:    344:     assert called["params"] == {
 10651:    345:         "productType": "USDT-FUTURES",
 10652:    346:         "symbol": "BTCUSDT",
 10653:    347:     }
 10654:    348: 
 10655:    349: 
 10656:    350: def test_product_type_alias():
 10657:    351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
 10658:    352:     assert client.product_type == "USDT-FUTURES"
 10659:    353: 
 10660:    354: 
 10661:    355: def test_get_contract_detail_endpoint(monkeypatch):
 10662:    356:     client = BitgetFuturesClient("key", "secret", "https://test")
 10663:    357: 
 10664:    358:     called = {}
 10665:    359: 
 10666:    360:     def fake_get(url, params=None, timeout=None):
 10667:    361:         called["url"] = url
 10668:    362:         called["params"] = params
 10669:    363: 
 10670:    364:         class Resp:
 10671:    365:             status_code = 200
 10672:    366: 
 10673:    367:             def raise_for_status(self):
 10674:    368:                 pass
 10675:    369: 
 10676:    370:             def json(self):
 10677:    371:                 return {"data": []}
 10678:    372: 
 10679:    373:         return Resp()
 10680:    374: 
 10681:    375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10682:    376: 
 10683:    377:     client.get_contract_detail("BTCUSDT_UMCBL")
 10684:    378: 
 10685:    379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
 10686:    380:     assert called["params"] == {
 10687:    381:         "productType": "USDT-FUTURES",
 10688:    382:         "symbol": "BTCUSDT",
 10689:    383:     }
 10690:    384: 
 10691:    385: 
 10692:    386: def test_cancel_all_endpoint(monkeypatch):
 10693:    387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10694:    388: 
 10695:    389:     called = {}
 10696:    390: 
 10697:    391:     def fake_private(self, method, path, params=None, body=None):
 10698:    392:         called["method"] = method
 10699:    393:         called["path"] = path
 10700:    394:         called["params"] = params
 10701:    395:         called["body"] = body
 10702:    396:         return {"success": True}
 10703:    397: 
 10704:    398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10705:    399: 
 10706:    400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 10707:    401: 
 10708:    402:     assert called["method"] == "POST"
 10709:    403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
 10710:    404:     assert called["params"] is None
 10711:    405:     assert called["body"] == {
 10712:    406:         "productType": "USDT-FUTURES",
 10713:    407:         "symbol": "BTCUSDT",
 10714:    408:         "marginCoin": "USDT",
 10715:    409:     }
 10716:    410: 
 10717:    411: 
 10718:    412: def test_place_order_endpoint(monkeypatch):
 10719:    413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10720:    414: 
 10721:    415:     called = {}
 10722:    416: 
 10723:    417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 10724:    418: 
 10725:    419:     def fake_private(self, method, path, params=None, body=None):
 10726:    420:         called["method"] = method
 10727:    421:         called["path"] = path
 10728:    422:         called["body"] = body
 10729:    423:         return {"success": True}
 10730:    424: 
 10731:    425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10732:    426: 
 10733:    427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
 10734:    428: 
 10735:    429:     assert resp["success"] is True
 10736:    430:     assert called["method"] == "POST"
 10737:    431:     assert called["path"] == "/api/v2/mix/order/place-order"
 10738:    432:     body = called["body"]
 10739:    433:     assert body["symbol"] == "BTCUSDT"
 10740:    434:     assert body["marginCoin"] == "USDT"
 10741:    435:     assert body["marginMode"] == "crossed"
 10742:    436:     assert body["side"] == "buy"
 10743:    437:     assert body["posSide"] == "long"
 10744:    438:     assert "reduceOnly" not in body
 10745:    439:     assert body["posMode"] == "hedge_mode"
 10746:    440: 
 10747:    441: 
 10748:    442: @pytest.mark.parametrize(
 10749:    443:     "code, side_str, pos_side",
 10750:    444:     [
 10751:    445:         (4, "sell", "long"),
 10752:    446:         (2, "buy", "short"),
 10753:    447:     ],
 10754:    448: )
 10755:    449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
 10756:    450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10757:    451: 
 10758:    452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 10759:    453: 
 10760:    454:     called = {}
 10761:    455: 
 10762:    456:     def fake_private(self, method, path, params=None, body=None):
 10763:    457:         called["body"] = body
 10764:    458:         return {"success": True}
 10765:    459: 
 10766:    460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10767:    461: 
 10768:    462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
 10769:    463: 
 10770:    464:     body = called["body"]
 10771:    465:     assert body["side"] == side_str
 10772:    466:     assert body["posSide"] == pos_side
 10773:    467:     assert "reduceOnly" not in body
 10774:    468: 
 10775:    469: 
 10776:    470: def test_place_order_precision(monkeypatch):
 10777:    471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10778:    472: 
 10779:    473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
 10780:    474: 
 10781:    475:     called = {}
 10782:    476: 
 10783:    477:     def fake_private(self, method, path, params=None, body=None):
 10784:    478:         called["body"] = body
 10785:    479:         return {"success": True}
 10786:    480: 
 10787:    481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10788:    482: 
 10789:    483:     client.place_order(
 10790:    484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
 10791:    485:     )
 10792:    486: 
 10793:    487:     assert called["body"]["price"] == 1234.57
 10794:    488:     assert called["body"]["size"] == 1.235
 10795:    489: 
 10796:    490: 
 10797:    491: def test_margin_cap_skips_order(monkeypatch):
 10798:    492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10799:    493:     called = {}
 10800:    494: 
 10801:    495:     def fake_private(method, path, **kwargs):
 10802:    496:         called["path"] = path
 10803:    497:         return {"code": "00000"}
 10804:    498: 
 10805:    499:     monkeypatch.setattr(client, "_private_request", fake_private)
 10806:    500:     contract_detail = {
 10807:    501:         "data": {
 10808:    502:             "symbol": "BTCUSDT_UMCBL",
 10809:    503:             "contractSize": 1,
 10810:    504:             "volUnit": 1,
 10811:    505:             "minVol": 1,
 10812:    506:             "minTradeUSDT": 5,
 10813:    507:         }
 10814:    508:     }
 10815:    509:     price = 100.0
 10816:    510:     available = 0.5
 10817:    511:     vol = bot.compute_position_size(
 10818:    512:         contract_detail,
 10819:    513:         equity_usdt=available,
 10820:    514:         price=price,
 10821:    515:         risk_pct=1.0,
 10822:    516:         leverage=10,
 10823:    517:         symbol="BTCUSDT_UMCBL",
 10824:    518:         available_usdt=available,
 10825:    519:     )
 10826:    520:     if vol > 0:
 10827:    521:         client.place_order(
 10828:    522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
 10829:    523:         )
 10830:    524:     assert called == {}
 10831:    525: 
 10832:    526: 
 10833:    527: def test_margin_cap_reduces_volume(monkeypatch):
 10834:    528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10835:    529:     called = {}
 10836:    530: 
 10837:    531:     def fake_private(method, path, **kwargs):
 10838:    532:         called["body"] = kwargs.get("body")
 10839:    533:         return {"code": "00000"}
 10840:    534: 
 10841:    535:     monkeypatch.setattr(client, "_private_request", fake_private)
 10842:    536:     contract_detail = {
 10843:    537:         "data": {
 10844:    538:             "symbol": "BTCUSDT_UMCBL",
 10845:    539:             "contractSize": 1,
 10846:    540:             "volUnit": 1,
 10847:    541:             "minVol": 1,
 10848:    542:             "minTradeUSDT": 5,
 10849:    543:         }
 10850:    544:     }
 10851:    545:     price = 10.0
 10852:    546:     vol_theoretical = bot.compute_position_size(
 10853:    547:         contract_detail,
 10854:    548:         equity_usdt=100,
 10855:    549:         price=price,
 10856:    550:         risk_pct=1.0,
 10857:    551:         leverage=10,
 10858:    552:         symbol="BTCUSDT_UMCBL",
 10859:    553:     )
 10860:    554:     available = 20.0
 10861:    555:     vol_final = bot.compute_position_size(
 10862:    556:         contract_detail,
 10863:    557:         equity_usdt=available,
 10864:    558:         price=price,
 10865:    559:         risk_pct=1.0,
 10866:    560:         leverage=10,
 10867:    561:         symbol="BTCUSDT_UMCBL",
 10868:    562:         available_usdt=available,
 10869:    563:     )
 10870:    564:     assert vol_final < vol_theoretical
 10871:    565:     client.place_order(
 10872:    566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
 10873:    567:     )
 10874:    568:     assert called["body"]["size"] == vol_final
 10875:    569: 
 10876:    570: def test_get_open_orders_paper_trade(monkeypatch):
 10877:    571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 10878:    572: 
 10879:    573:     called = {"count": 0}
 10880:    574: 
 10881:    575:     def fake_private(*a, **k):
 10882:    576:         called["count"] += 1
 10883:    577:         return {"success": True}
 10884:    578: 
 10885:    579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10886:    580: 
 10887:    581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
 10888:    582: 
 10889:    583:     assert resp["success"] is True
 10890:    584:     assert resp["data"] == []
 10891:    585:     assert called["count"] == 0
 10892:    586: 
 10893:    587: 
 10894:    588: def test_cancel_all_paper_trade(monkeypatch):
 10895:    589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 10896:    590: 
 10897:    591:     called = {"count": 0}
 10898:    592: 
 10899:    593:     def fake_private(*a, **k):
 10900:    594:         called["count"] += 1
 10901:    595:         return {"success": True}
 10902:    596: 
 10903:    597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10904:    598: 
 10905:    599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 10906:    600: 
 10907:    601:     assert resp["success"] is True
 10908:    602:     assert called["count"] == 0
 10909:    603: 
 10910:    604: 
 10911:    605: def test_get_kline_transforms_data(monkeypatch):
 10912:    606:     client = BitgetFuturesClient("key", "secret", "https://test")
 10913:    607: 
 10914:    608:     def fake_get(url, params=None, timeout=None):
 10915:    609:         class Resp:
 10916:    610:             def raise_for_status(self):
 10917:    611:                 pass
 10918:    612: 
 10919:    613:             def json(self):
 10920:    614:                 return {
 10921:    615:                     "data": [
 10922:    616:                         ["1", "2", "3", "1", "2", "10", "20"],
 10923:    617:                         ["2", "3", "4", "2", "3", "11", "21"],
 10924:    618:                     ]
 10925:    619:                 }
 10926:    620: 
 10927:    621:         return Resp()
 10928:    622: 
 10929:    623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10930:    624: 
 10931:    625:     data = client.get_kline("BTC_USDT", interval="1m")
 10932:    626:     kdata = data["data"]
 10933:    627:     assert kdata["open"] == [2.0, 3.0]
 10934:    628:     assert kdata["high"] == [3.0, 4.0]
 10935:    629:     assert kdata["low"] == [1.0, 2.0]
 10936:    630:     assert kdata["close"] == [2.0, 3.0]
 10937:    631:     assert kdata["volume"] == [10.0, 11.0]
 10938:    632:     assert kdata["quoteVolume"] == [20.0, 21.0]
 10939: 
 10940: 
 10941: ## tests/test_compute_position_size.py (last modified: 2025-08-23 20:57:14)
 10942:      1: import os
 10943:      2: import sys
 10944:      3: import types
 10945:      4: import pytest
 10946:      5: 
 10947:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10948:      7: sys.modules["requests"] = types.ModuleType("requests")
 10949:      8: import bot  # noqa: E402
 10950:      9: from bot import compute_position_size  # noqa: E402
 10951:     10: 
 10952:     11: 
 10953:     12: def test_compute_position_size_basic():
 10954:     13:     contract_detail = {
 10955:     14:         "data": [
 10956:     15:             {
 10957:     16:                 "symbol": "BTC_USDT",
 10958:     17:                 "contractSize": 0.01,
 10959:     18:                 "volUnit": 1,
 10960:     19:                 "minVol": 1,
 10961:     20:             }
 10962:     21:         ]
 10963:     22:     }
 10964:     23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
 10965:     24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 10966:     25:     assert vol == 1
 10967:     26: 
 10968:     27: 
 10969:     28: def test_compute_position_size_symbol_not_found():
 10970:     29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
 10971:     30:     with pytest.raises(ValueError):
 10972:     31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
 10973:     32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 10974:     33: 
 10975:     34: 
 10976:     35: def test_compute_position_size_invalid_price():
 10977:     36:     contract_detail = {
 10978:     37:         "data": [
 10979:     38:             {
 10980:     39:                 "symbol": "BTC_USDT",
 10981:     40:                 "contractSize": 0.01,
 10982:     41:                 "volUnit": 1,
 10983:     42:                 "minVol": 1,
 10984:     43:             }
 10985:     44:         ]
 10986:     45:     }
 10987:     46:     vol = compute_position_size(
 10988:     47:         contract_detail,
 10989:     48:         equity_usdt=1000,
 10990:     49:         price=0,
 10991:     50:         risk_pct=0.01,
 10992:     51:         leverage=10,
 10993:     52:         symbol="BTC_USDT",
 10994:     53:     )
 10995:     54:     assert vol == 0
 10996:     55: 
 10997:     56: 
 10998:     57: def test_compute_position_size_respects_equity():
 10999:     58:     contract_detail = {
 11000:     59:         "data": [
 11001:     60:             {
 11002:     61:                 "symbol": "BTC_USDT",
 11003:     62:                 "contractSize": 1,
 11004:     63:                 "volUnit": 1,
 11005:     64:                 "minVol": 1,
 11006:     65:             }
 11007:     66:         ]
 11008:     67:     }
 11009:     68:     vol = compute_position_size(
 11010:     69:         contract_detail,
 11011:     70:         equity_usdt=5,
 11012:     71:         price=100,
 11013:     72:         risk_pct=0.01,
 11014:     73:         leverage=10,
 11015:     74:         symbol="BTC_USDT",
 11016:     75:     )
 11017:     76:     assert vol == 0
 11018:     77: 
 11019:     78: 
 11020:     79: def test_compute_position_size_leaves_fee_buffer():
 11021:     80:     contract_detail = {
 11022:     81:         "data": [
 11023:     82:             {
 11024:     83:                 "symbol": "BTC_USDT",
 11025:     84:                 "contractSize": 1,
 11026:     85:                 "volUnit": 1,
 11027:     86:                 "minVol": 1,
 11028:     87:             }
 11029:     88:         ]
 11030:     89:     }
 11031:     90:     vol = compute_position_size(
 11032:     91:         contract_detail,
 11033:     92:         equity_usdt=100,
 11034:     93:         price=100,
 11035:     94:         risk_pct=1.0,
 11036:     95:         leverage=1,
 11037:     96:         symbol="BTC_USDT",
 11038:     97:     )
 11039:     98:     assert vol == 0
 11040:     99: 
 11041:    100: 
 11042:    101: def test_compute_position_size_under_min_notional_returns_zero():
 11043:    102:     contract_detail = {
 11044:    103:         "data": [
 11045:    104:             {
 11046:    105:                 "symbol": "PI_USDT",
 11047:    106:                 "contractSize": 1,
 11048:    107:                 "volUnit": 1,
 11049:    108:                 "minVol": 1,
 11050:    109:                 "minTradeUSDT": 5,
 11051:    110:             }
 11052:    111:         ]
 11053:    112:     }
 11054:    113:     vol = compute_position_size(
 11055:    114:         contract_detail,
 11056:    115:         equity_usdt=100,
 11057:    116:         price=0.5,
 11058:    117:         risk_pct=0.0001,
 11059:    118:         leverage=20,
 11060:    119:         symbol="PI_USDT",
 11061:    120:     )
 11062:    121:     assert vol == 0
 11063:    122: 
 11064:    123: 
 11065:    124: def test_compute_position_size_cap_by_available():
 11066:    125:     contract_detail = {
 11067:    126:         "data": [
 11068:    127:             {
 11069:    128:                 "symbol": "BTC_USDT",
 11070:    129:                 "contractSize": 1,
 11071:    130:                 "volUnit": 2,
 11072:    131:                 "minVol": 2,
 11073:    132:                 "minTradeUSDT": 5,
 11074:    133:             }
 11075:    134:         ]
 11076:    135:     }
 11077:    136:     vol = compute_position_size(
 11078:    137:         contract_detail,
 11079:    138:         equity_usdt=100,
 11080:    139:         price=10,
 11081:    140:         risk_pct=0.5,
 11082:    141:         leverage=10,
 11083:    142:         symbol="BTC_USDT",
 11084:    143:         available_usdt=0.5,
 11085:    144:     )
 11086:    145:     assert vol == 0
 11087:    146:     vol = compute_position_size(
 11088:    147:         contract_detail,
 11089:    148:         equity_usdt=100,
 11090:    149:         price=10,
 11091:    150:         risk_pct=0.5,
 11092:    151:         leverage=10,
 11093:    152:         symbol="BTC_USDT",
 11094:    153:         available_usdt=10,
 11095:    154:     )
 11096:    155:     assert vol == 8
 11097:    156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
 11098:    157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
 11099:    158:     assert required <= 10
 11100: 
 11101: 
 11102: ## tests/test_compute_position_size_cap.py (last modified: 2025-08-23 20:57:14)
 11103:      1: import os
 11104:      2: import sys
 11105:      3: import types
 11106:      4: import pytest
 11107:      5: 
 11108:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11109:      7: sys.modules['requests'] = types.ModuleType('requests')
 11110:      8: 
 11111:      9: from bot import compute_position_size, CONFIG
 11112:     10: 
 11113:     11: 
 11114:     12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
 11115:     13:     return {
 11116:     14:         "data": [
 11117:     15:             {
 11118:     16:                 "symbol": "BTC_USDT",
 11119:     17:                 "contractSize": 0.001,
 11120:     18:                 "volUnit": vol_unit,
 11121:     19:                 "minVol": min_vol,
 11122:     20:                 "minTradeUSDT": min_trade,
 11123:     21:             }
 11124:     22:         ]
 11125:     23:     }
 11126:     24: 
 11127:     25: 
 11128:     26: def test_volume_zero_when_available_low():
 11129:     27:     detail = _detail()
 11130:     28:     vol = compute_position_size(
 11131:     29:         detail,
 11132:     30:         equity_usdt=1000,
 11133:     31:         price=10000,
 11134:     32:         risk_pct=0.01,
 11135:     33:         leverage=10,
 11136:     34:         symbol="BTC_USDT",
 11137:     35:         available_usdt=0.5,
 11138:     36:     )
 11139:     37:     assert vol == 0
 11140:     38: 
 11141:     39: 
 11142:     40: def test_margin_close_to_available():
 11143:     41:     detail = _detail()
 11144:     42:     CONFIG["FEE_RATE"] = 0.001
 11145:     43:     available = 1.05
 11146:     44:     vol = compute_position_size(
 11147:     45:         detail,
 11148:     46:         equity_usdt=1000,
 11149:     47:         price=10000,
 11150:     48:         risk_pct=1,
 11151:     49:         leverage=10,
 11152:     50:         symbol="BTC_USDT",
 11153:     51:         available_usdt=available,
 11154:     52:     )
 11155:     53:     assert vol == 1
 11156:     54:     notional = 10000 * 0.001 * vol
 11157:     55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
 11158:     56:     required = (notional / 10 + fee) * 1.03
 11159:     57:     assert required == pytest.approx(available, rel=0.05)
 11160:     58: 
 11161:     59: 
 11162:     60: def test_respects_units_and_minimums():
 11163:     61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
 11164:     62:     vol = compute_position_size(
 11165:     63:         detail,
 11166:     64:         equity_usdt=1000,
 11167:     65:         price=1000,
 11168:     66:         risk_pct=1,
 11169:     67:         leverage=5,
 11170:     68:         symbol="BTC_USDT",
 11171:     69:         available_usdt=1000,
 11172:     70:     )
 11173:     71:     assert vol % 2 == 0 and vol >= 2
 11174: 
 11175: 
 11176: ## tests/test_dynamic_allocation.py (last modified: 2025-08-23 20:57:14)
 11177:      1: import math
 11178:      2: from scalper.risk import adjust_risk_pct
 11179:      3: 
 11180:      4: 
 11181:      5: def test_adjust_risk_pct_increase_decrease():
 11182:      6:     base = 0.01
 11183:      7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
 11184:      8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
 11185:      9: 
 11186:     10: 
 11187:     11: def test_adjust_risk_pct_bounds():
 11188:     12:     assert math.isclose(
 11189:     13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
 11190:     14:     )
 11191:     15:     assert math.isclose(
 11192:     16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
 11193:     17:     )
 11194: 
 11195: 
 11196: ## tests/test_effective_leverage.py (last modified: 2025-08-23 20:57:14)
 11197:      1: import pytest
 11198:      2: from scalper.trade_utils import effective_leverage
 11199:      3: 
 11200:      4: 
 11201:      5: def test_effective_leverage_basic():
 11202:      6:     lev = effective_leverage(
 11203:      7:         entry_price=100.0,
 11204:      8:         liquidation_price=90.0,
 11205:      9:         position_margin=10.0,
 11206:     10:         position_size=1.0,
 11207:     11:     )
 11208:     12:     assert lev == pytest.approx(10.0)
 11209:     13: 
 11210:     14: 
 11211:     15: def test_effective_leverage_estimated_margin():
 11212:     16:     lev = effective_leverage(
 11213:     17:         entry_price=200.0,
 11214:     18:         liquidation_price=180.0,
 11215:     19:         position_margin=0.0,
 11216:     20:         position_size=2.0,
 11217:     21:     )
 11218:     22:     # price diff 20 * size 2 -> margin 40; notional 400
 11219:     23:     assert lev == pytest.approx(10.0)
 11220:     24: 
 11221:     25: 
 11222:     26: def test_effective_leverage_short_position():
 11223:     27:     lev = effective_leverage(
 11224:     28:         entry_price=100.0,
 11225:     29:         liquidation_price=110.0,
 11226:     30:         position_margin=10.0,
 11227:     31:         position_size=-1.5,
 11228:     32:     )
 11229:     33:     assert lev == pytest.approx(15.0)
 11230:     34: 
 11231:     35: 
 11232:     36: def test_effective_leverage_invalid():
 11233:     37:     assert effective_leverage(0, 0, 0, 0) == 0.0
 11234: 
 11235: 
 11236: ## tests/test_env_loading.py (last modified: 2025-08-23 20:57:14)
 11237:      1: """Tests for loading environment variables from ``notebook/.env``."""
 11238:      2: 
 11239:      3: from __future__ import annotations
 11240:      4: 
 11241:      5: import importlib
 11242:      6: import os
 11243:      7: import sys
 11244:      8: from pathlib import Path
 11245:      9: 
 11246:     10: 
 11247:     11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
 11248:     12:     """Module should load variables from ``notebook/.env`` if present."""
 11249:     13: 
 11250:     14:     notebook = tmp_path / "notebook"
 11251:     15:     spot = notebook / "spot"
 11252:     16:     spot.mkdir(parents=True)
 11253:     17:     bitget_bot = spot / "bitget_bot.py"
 11254:     18:     bitget_bot.write_text("")
 11255:     19:     env_file = notebook / ".env"
 11256:     20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
 11257:     21: 
 11258:     22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
 11259:     23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
 11260:     24:     import scalp
 11261:     25: 
 11262:     26:     importlib.reload(scalp)
 11263:     27: 
 11264:     28:     try:
 11265:     29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
 11266:     30:     finally:
 11267:     31:         env_file.unlink(missing_ok=True)
 11268:     32:         if old is None:
 11269:     33:             os.environ.pop("BITGET_ACCESS_KEY", None)
 11270:     34:         else:
 11271:     35:             os.environ["BITGET_ACCESS_KEY"] = old
 11272: 
 11273: 
 11274: ## tests/test_grid_search.py (last modified: 2025-08-23 20:57:14)
 11275:      1: import json
 11276:      2: import random
 11277:      3: 
 11278:      4: import pytest
 11279:      5: 
 11280:      6: from scalper.backtest import grid_search
 11281:      7: 
 11282:      8: 
 11283:      9: def test_build_grid_sampling():
 11284:     10:     param_lists = {
 11285:     11:         "timeframe": ["1m", "5m", "15m"],
 11286:     12:         "score_min": [50, 55, 60],
 11287:     13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
 11288:     14:     }
 11289:     15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
 11290:     16:     assert len(combos) == 6
 11291:     17:     tfs = {c["timeframe"] for c in combos}
 11292:     18:     assert {"1m", "5m", "15m"}.issubset(tfs)
 11293:     19: 
 11294:     20: 
 11295:     21: def test_run_grid_search_with_mock(tmp_path):
 11296:     22:     calls = []
 11297:     23: 
 11298:     24:     def fake_run_backtest_multi(**kwargs):
 11299:     25:         tf = kwargs.get("timeframe")
 11300:     26:         risk = kwargs.get("risk_pct")
 11301:     27:         # fabricate metrics based on params
 11302:     28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
 11303:     29:         pf += risk  # tiny variation
 11304:     30:         metrics = {
 11305:     31:             "symbol": "TOTAL",
 11306:     32:             "pnl_usdt": 100 * risk,
 11307:     33:             "profit_factor": pf,
 11308:     34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
 11309:     35:             "winrate_pct": 50.0,
 11310:     36:             "trades": 40 if tf == "1m" else 30,
 11311:     37:         }
 11312:     38:         calls.append((tf, risk))
 11313:     39:         return [metrics], []
 11314:     40: 
 11315:     41:     param_lists = {
 11316:     42:         "timeframe": ["1m", "5m"],
 11317:     43:         "risk_pct": [0.005, 0.01],
 11318:     44:     }
 11319:     45:     base_params = {
 11320:     46:         "timeframe": "1m",
 11321:     47:         "risk_pct": 0.005,
 11322:     48:     }
 11323:     49:     out_dir = tmp_path / "grid"
 11324:     50:     grid_search.run_grid_search(
 11325:     51:         symbols=["BTC/USDT"],
 11326:     52:         exchange="csv",
 11327:     53:         base_params=base_params,
 11328:     54:         param_lists=param_lists,
 11329:     55:         grid_max=4,
 11330:     56:         csv_dir="/dev/null",
 11331:     57:         out_dir=str(out_dir),
 11332:     58:         run_func=fake_run_backtest_multi,
 11333:     59:     )
 11334:     60:     best = json.loads((out_dir / "best_config.json").read_text())
 11335:     61:     # best PF should be timeframe 5m risk 0.01
 11336:     62:     assert best["params"]["timeframe"] == "5m"
 11337:     63:     assert best["params"]["risk_pct"] == 0.01
 11338:     64:     assert len(calls) == 4
 11339:     65: 
 11340:     66: 
 11341:     67: def test_parse_hours():
 11342:     68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
 11343:     69: 
 11344:     70: 
 11345:     71: def test_deterministic_results(tmp_path):
 11346:     72:     def fake_run_backtest_multi(**kwargs):
 11347:     73:         # metrics vary with global random state
 11348:     74:         pf = random.uniform(1.0, 3.0)
 11349:     75:         metrics = {
 11350:     76:             "symbol": "TOTAL",
 11351:     77:             "pnl_usdt": random.uniform(-10, 10),
 11352:     78:             "profit_factor": pf,
 11353:     79:             "max_drawdown_pct": random.uniform(1, 5),
 11354:     80:             "winrate_pct": 50.0,
 11355:     81:             "trades": random.randint(10, 50),
 11356:     82:         }
 11357:     83:         return [metrics], []
 11358:     84: 
 11359:     85:     param_lists = {"timeframe": ["1m", "5m"]}
 11360:     86:     base_params = {"timeframe": "1m"}
 11361:     87:     out_dir = tmp_path / "grid"
 11362:     88:     res1 = grid_search.run_grid_search(
 11363:     89:         symbols=["BTC/USDT"],
 11364:     90:         exchange="csv",
 11365:     91:         base_params=base_params,
 11366:     92:         param_lists=param_lists,
 11367:     93:         grid_max=2,
 11368:     94:         csv_dir="/dev/null",
 11369:     95:         out_dir=str(out_dir),
 11370:     96:         seed=42,
 11371:     97:         run_func=fake_run_backtest_multi,
 11372:     98:     )
 11373:     99:     best1 = json.loads((out_dir / "best_config.json").read_text())
 11374:    100:     # run again
 11375:    101:     out_dir2 = tmp_path / "grid2"
 11376:    102:     res2 = grid_search.run_grid_search(
 11377:    103:         symbols=["BTC/USDT"],
 11378:    104:         exchange="csv",
 11379:    105:         base_params=base_params,
 11380:    106:         param_lists=param_lists,
 11381:    107:         grid_max=2,
 11382:    108:         csv_dir="/dev/null",
 11383:    109:         out_dir=str(out_dir2),
 11384:    110:         seed=42,
 11385:    111:         run_func=fake_run_backtest_multi,
 11386:    112:     )
 11387:    113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
 11388:    114:     assert best1 == best2
 11389:    115:     # also ensure results object same best params
 11390:    116:     assert res1[0].params == res2[0].params
 11391: 
 11392: 
 11393: ## tests/test_heat_score.py (last modified: 2025-08-23 20:57:14)
 11394:      1: from scalper.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
 11395:      2: 
 11396:      3: 
 11397:      4: def test_heat_score_value():
 11398:      5:     assert heat_score(2.0, 100.0) == 200.0
 11399:      6:     assert heat_score(2.0, 100.0, news=True) == 400.0
 11400:      7: 
 11401:      8: 
 11402:      9: def test_select_and_decorrelate_pairs():
 11403:     10:     pairs = [
 11404:     11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
 11405:     12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
 11406:     13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
 11407:     14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
 11408:     15:     ]
 11409:     16:     top = select_top_heat_pairs(pairs, top_n=3)
 11410:     17:     assert len(top) == 3
 11411:     18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
 11412:     19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
 11413:     20:     syms = {p["symbol"] for p in selected}
 11414:     21:     assert not ("A" in syms and "B" in syms)
 11415: 
 11416: 
 11417: ## tests/test_indicators.py (last modified: 2025-08-23 20:57:14)
 11418:      1: 
 11419:      2: 
 11420:      3: import os
 11421:      4: import sys
 11422:      5: import pytest
 11423:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11424:      7: 
 11425:      8: 
 11426:      9: 
 11427:     10: 
 11428:     11: from scalper.metrics import calc_rsi, calc_atr, calc_macd
 11429:     12: 
 11430:     13: 
 11431:     14: def test_calc_rsi_uptrend():
 11432:     15:     prices = list(range(1, 16))  # strictly increasing
 11433:     16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
 11434:     17: 
 11435:     18: 
 11436:     19: def test_calc_rsi_downtrend():
 11437:     20:     prices = list(range(15, 0, -1))  # strictly decreasing
 11438:     21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
 11439:     22: 
 11440:     23: 
 11441:     24: 
 11442:     25: def test_calc_rsi_flat():
 11443:     26:     prices = [1.0] * 15  # no movement
 11444:     27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
 11445:     28: 
 11446:     29: 
 11447:     30: 
 11448:     31:     highs = [10, 11, 12, 13, 14]
 11449:     32:     lows = [9, 10, 11, 12, 13]
 11450:     33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
 11451:     34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
 11452:     35: 
 11453:     36: 
 11454:     37: def test_calc_macd_trend():
 11455:     38:     prices = list(range(1, 60))
 11456:     39:     macd, signal, hist = calc_macd(prices)
 11457:     40:     assert macd > signal
 11458:     41:     assert hist > 0
 11459:     42: 
 11460:     43: 
 11461:     44: def test_calc_macd_flat():
 11462:     45:     prices = [100.0] * 60
 11463:     46:     macd, signal, hist = calc_macd(prices)
 11464:     47:     assert macd == pytest.approx(0.0)
 11465:     48:     assert signal == pytest.approx(0.0)
 11466:     49:     assert hist == pytest.approx(0.0)
 11467:     50: 
 11468:     51: 
 11469:     52: 
 11470:     53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
 11471:     54: def test_calc_rsi_invalid_inputs(prices, period):
 11472:     55:     with pytest.raises(ValueError):
 11473:     56:         calc_rsi(prices, period=period)
 11474:     57: 
 11475:     58: 
 11476:     59: @pytest.mark.parametrize(
 11477:     60:     "highs, lows, closes, period",
 11478:     61:     [
 11479:     62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
 11480:     63:         ([1, 2], [1, 1], [1, 1], 3),
 11481:     64:     ],
 11482:     65: )
 11483:     66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
 11484:     67:     with pytest.raises(ValueError):
 11485:     68:         calc_atr(highs, lows, closes, period=period)
 11486:     69: 
 11487: 
 11488: 
 11489: ## tests/test_min_qty_rules.py (last modified: 2025-08-23 20:57:14)
 11490:      1: import os
 11491:      2: import sys
 11492:      3: import types
 11493:      4: 
 11494:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11495:      6: sys.modules['requests'] = types.ModuleType('requests')
 11496:      7: 
 11497:      8: from bot import _apply_contract_checks
 11498:      9: 
 11499:     10: 
 11500:     11: def _detail():
 11501:     12:     return {
 11502:     13:         "data": [
 11503:     14:             {
 11504:     15:                 "symbol": "BTC_USDT",
 11505:     16:                 "contractSize": 1,
 11506:     17:                 "volUnit": 5,
 11507:     18:                 "minVol": 10,
 11508:     19:                 "minTradeUSDT": 5,
 11509:     20:             }
 11510:     21:         ]
 11511:     22:     }
 11512:     23: 
 11513:     24: 
 11514:     25: def test_min_qty_floor_and_validation():
 11515:     26:     detail = _detail()
 11516:     27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
 11517:     28:     assert vol == 10
 11518:     29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
 11519:     30:     assert vol2 == 0
 11520: 
 11521: 
 11522: ## tests/test_notifier.py (last modified: 2025-08-23 20:57:14)
 11523:      1: import scalper.notifier as notifier
 11524:      2: 
 11525:      3: 
 11526:      4: def test_notify_skips_without_targets(monkeypatch):
 11527:      5:     called = False
 11528:      6: 
 11529:      7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
 11530:      8:         nonlocal called
 11531:      9:         called = True
 11532:     10: 
 11533:     11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 11534:     12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 11535:     13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 11536:     14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11537:     15:     notifier.notify("test", {"foo": 1})
 11538:     16:     assert called is False
 11539:     17: 
 11540:     18: 
 11541:     19: def test_notify_posts_http(monkeypatch):
 11542:     20:     payload = {}
 11543:     21: 
 11544:     22:     def fake_post(url, json=None, timeout=5):
 11545:     23:         payload["url"] = url
 11546:     24:         payload["json"] = json
 11547:     25:         payload["timeout"] = timeout
 11548:     26: 
 11549:     27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 11550:     28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 11551:     29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11552:     30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11553:     31:     notifier.notify("evt", {"bar": 2})
 11554:     32:     assert payload["url"] == "http://example.com"
 11555:     33:     assert payload["json"]["event"] == "evt"
 11556:     34:     assert payload["json"]["bar"] == 2
 11557:     35: 
 11558:     36: 
 11559:     37: def test_notify_posts_telegram(monkeypatch):
 11560:     38:     payload = {}
 11561:     39: 
 11562:     40:     def fake_post(url, json=None, timeout=5):
 11563:     41:         payload["url"] = url
 11564:     42:         payload["json"] = json
 11565:     43:         payload["timeout"] = timeout
 11566:     44: 
 11567:     45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 11568:     46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11569:     47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11570:     48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11571:     49: 
 11572:     50:     notifier.notify("evt", {"bar": 2})
 11573:     51: 
 11574:     52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
 11575:     53:     assert payload["json"]["chat_id"] == "123"
 11576:     54:     assert "evt" in payload["json"]["text"]
 11577:     55: 
 11578:     56: 
 11579:     57: def test_notify_posts_both(monkeypatch):
 11580:     58:     calls = []
 11581:     59: 
 11582:     60:     def fake_post(url, json=None, timeout=5):
 11583:     61:         calls.append({"url": url, "json": json, "timeout": timeout})
 11584:     62: 
 11585:     63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11586:     64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11587:     65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11588:     66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11589:     67: 
 11590:     68:     notifier.notify("evt", {"bar": 2})
 11591:     69: 
 11592:     70:     assert len(calls) == 2
 11593:     71:     urls = {c["url"] for c in calls}
 11594:     72:     assert "http://example.com" in urls
 11595:     73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
 11596:     74: 
 11597:     75: 
 11598:     76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
 11599:     77:     calls = []
 11600:     78: 
 11601:     79:     def fake_post(url, json=None, timeout=5):
 11602:     80:         calls.append(url)
 11603:     81: 
 11604:     82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11605:     83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11606:     84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11607:     85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11608:     86: 
 11609:     87:     notifier.notify("pair_list", {"pairs": "BTC"})
 11610:     88: 
 11611:     89:     # Only the generic webhook should be called, not Telegram
 11612:     90:     assert calls == ["http://example.com"]
 11613:     91: 
 11614:     92: 
 11615:     93: def test_format_text_open_position():
 11616:     94:     payload = {
 11617:     95:         "symbol": "BTCUSDT",
 11618:     96:         "side": "short",
 11619:     97:         "price": 18350,
 11620:     98:         "vol": 37,
 11621:     99:         "contract_size": 1,
 11622:    100:         "notional_usdt": 120.5,
 11623:    101:         "leverage": 5,
 11624:    102:         "required_margin_usdt": 25.3,
 11625:    103:         "available_usdt": 134,
 11626:    104:         "risk_level_user": 3,
 11627:    105:         "signal_level": 2,
 11628:    106:         "risk_color": "🟡",
 11629:    107:         "risk_pct_eff": 0.01,
 11630:    108:         "fee_rate": 0.001,
 11631:    109:     }
 11632:    110:     text = notifier._format_text("position_opened", payload)
 11633:    111:     lines = text.splitlines()
 11634:    112: 
 11635:    113:     assert lines[0] == "🟡 Ouvre short BTC"
 11636:    114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
 11637:    115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
 11638:    116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
 11639:    117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
 11640:    118: 
 11641:    119: 
 11642:    120: def test_format_text_closed_position():
 11643:    121:     payload = {
 11644:    122:         "symbol": "BTCUSDT",
 11645:    123:         "side": "short",
 11646:    124:         "entry_price": 18350,
 11647:    125:         "exit_price": 18328,
 11648:    126:         "vol": 37,
 11649:    127:         "contract_size": 1,
 11650:    128:         "notional_entry_usdt": 120.5,
 11651:    129:         "notional_exit_usdt": 120.3,
 11652:    130:         "fees_usdt": 0.03,
 11653:    131:         "pnl_usdt": 0.84,
 11654:    132:         "pnl_pct_on_margin": 3.25,
 11655:    133:         "leverage": 5,
 11656:    134:         "risk_color": "🟡",
 11657:    135:         "fee_rate": 0.001,
 11658:    136:     }
 11659:    137:     text = notifier._format_text("position_closed", payload)
 11660:    138:     lines = text.splitlines()
 11661:    139:     assert lines[0] == "Ferme short BTC 🟡"
 11662:    140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
 11663:    141:     assert lines[2] == "% sur marge: 3.25%"
 11664:    142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
 11665:    143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
 11666:    144: 
 11667:    145: 
 11668:    146: def test_format_text_pair_list_and_start():
 11669:    147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
 11670:    148:     text = notifier._format_text(
 11671:    149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
 11672:    150:     )
 11673:    151:     assert text == "Listing ok"
 11674:    152: 
 11675:    153: 
 11676:    154: def test_format_pair_list_helper():
 11677:    155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
 11678:    156:     text = notifier._format_pair_list(payload)
 11679:    157:     assert text == "Listing ok"
 11680:    158: 
 11681:    159: 
 11682:    160: def test_format_position_event_helper():
 11683:    161:     payload = {
 11684:    162:         "symbol": "BTCUSDT",
 11685:    163:         "side": "short",
 11686:    164:         "price": 18350,
 11687:    165:         "vol": 37,
 11688:    166:         "contract_size": 1,
 11689:    167:         "notional_usdt": 120.5,
 11690:    168:         "leverage": 5,
 11691:    169:         "required_margin_usdt": 25.3,
 11692:    170:         "available_usdt": 134,
 11693:    171:         "risk_level_user": 3,
 11694:    172:         "signal_level": 2,
 11695:    173:         "risk_color": "🟡",
 11696:    174:         "risk_pct_eff": 0.01,
 11697:    175:         "fee_rate": 0.001,
 11698:    176:     }
 11699:    177:     text = notifier._format_position_event("position_opened", payload)
 11700:    178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
 11701:    179: 
 11702:    180: 
 11703: 
 11704: 
 11705: ## tests/test_notional_and_pnl_units.py (last modified: 2025-08-23 20:57:14)
 11706:      1: import os, sys, types, pytest
 11707:      2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11708:      3: sys.modules['requests'] = types.ModuleType('requests')
 11709:      4: 
 11710:      5: from scalper.trade_utils import (
 11711:      6:     get_contract_size,
 11712:      7:     notional as calc_notional,
 11713:      8:     required_margin as calc_required_margin,
 11714:      9:     compute_pnl_usdt,
 11715:     10:     compute_pnl_with_fees,
 11716:     11: )
 11717:     12: 
 11718:     13: 
 11719:     14: def _detail():
 11720:     15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
 11721:     16: 
 11722:     17: 
 11723:     18: def test_notional_and_pnl_units():
 11724:     19:     detail = _detail()
 11725:     20:     cs = get_contract_size(detail, "BTC_USDT")
 11726:     21:     N = calc_notional(10000, 2, cs)
 11727:     22:     assert N == pytest.approx(10000 * 0.001 * 2)
 11728:     23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
 11729:     24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
 11730:     25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
 11731:     26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
 11732:     27:     pnl_net, pct = compute_pnl_with_fees(
 11733:     28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
 11734:     29:     )
 11735:     30:     gross = (10100 - 10000) * cs * 2
 11736:     31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
 11737:     32:     expected = gross - fees
 11738:     33:     expected_pct = expected / (N / 10) * 100
 11739:     34:     assert pnl_net == pytest.approx(expected)
 11740:     35:     assert pct == pytest.approx(expected_pct)
 11741: 
 11742: 
 11743: ## tests/test_pair_selection.py (last modified: 2025-08-23 20:57:14)
 11744:      1: import bot
 11745:      2: 
 11746:      3: 
 11747:      4: def test_get_trade_pairs():
 11748:      5:     class Client:
 11749:      6:         def get_ticker(self, symbol=None):
 11750:      7:             return {
 11751:      8:                 "success": True,
 11752:      9:                 "data": [
 11753:     10:                     {"symbol": "BTC_USDT"},
 11754:     11:                     {"symbol": "ETH_USDT"},
 11755:     12:                 ],
 11756:     13:             }
 11757:     14: 
 11758:     15:     pairs = bot.get_trade_pairs(Client())
 11759:     16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
 11760:     17: 
 11761:     18: 
 11762:     19: def test_select_top_pairs():
 11763:     20:     class Client:
 11764:     21:         def get_ticker(self, symbol=None):
 11765:     22:             return {
 11766:     23:                 "success": True,
 11767:     24:                 "data": [
 11768:     25:                     {"symbol": "A", "volume": "1"},
 11769:     26:                     {"symbol": "B", "volume": "3"},
 11770:     27:                     {"symbol": "C", "volume": "2"},
 11771:     28:                 ],
 11772:     29:             }
 11773:     30: 
 11774:     31:     top = bot.select_top_pairs(Client(), top_n=2)
 11775:     32:     assert [p["symbol"] for p in top] == ["B", "C"]
 11776:     33: 
 11777:     34: 
 11778:     35: def test_select_top_pairs_default_count():
 11779:     36:     class Client:
 11780:     37:         def get_ticker(self, symbol=None):
 11781:     38:             data = []
 11782:     39:             for i in range(100):
 11783:     40:                 data.append({"symbol": str(i), "volume": str(i)})
 11784:     41:             return {"success": True, "data": data}
 11785:     42: 
 11786:     43:     top = bot.select_top_pairs(Client())
 11787:     44:     assert len(top) == 40
 11788:     45: 
 11789:     46: 
 11790:     47: def test_filter_trade_pairs():
 11791:     48:     class Client:
 11792:     49:         def get_ticker(self, symbol=None):
 11793:     50:             return {
 11794:     51:                 "success": True,
 11795:     52:                 "data": [
 11796:     53:                     {
 11797:     54:                         "symbol": "AAA",
 11798:     55:                         "volume": "6000000",
 11799:     56:                         "bidPrice": "100",
 11800:     57:                         "askPrice": "100.03",
 11801:     58:                     },  # spread ~3 bps
 11802:     59:                     {
 11803:     60:                         "symbol": "BBB",
 11804:     61:                         "volume": "10000000",
 11805:     62:                         "bidPrice": "50",
 11806:     63:                         "askPrice": "50.1",
 11807:     64:                     },  # spread ~200 bps
 11808:     65:                     {
 11809:     66:                         "symbol": "CCC",
 11810:     67:                         "volume": "7000000",
 11811:     68:                         "bidPrice": "10",
 11812:     69:                         "askPrice": "10.01",
 11813:     70:                     },  # spread ~100 bps
 11814:     71:                     {
 11815:     72:                         "symbol": "DDD",
 11816:     73:                         "volume": "4000000",
 11817:     74:                         "bidPrice": "20",
 11818:     75:                         "askPrice": "20.01",
 11819:     76:                     },  # volume trop faible
 11820:     77:                 ],
 11821:     78:             }
 11822:     79: 
 11823:     80:     pairs = bot.filter_trade_pairs(
 11824:     81:         Client(),
 11825:     82:         volume_min=5_000_000,
 11826:     83:         max_spread_bps=5,
 11827:     84:     )
 11828:     85:     assert [p["symbol"] for p in pairs] == ["AAA"]
 11829:     86: 
 11830:     87: 
 11831:     88: def test_find_trade_positions(monkeypatch):
 11832:     89:     class Client:
 11833:     90:         def __init__(self):
 11834:     91:             self.data = {
 11835:     92:                 "AAA": {"data": {"close": [1, 2, 3]}},
 11836:     93:                 "BBB": {"data": {"close": [3, 2, 1]}},
 11837:     94:             }
 11838:     95: 
 11839:     96:         def get_kline(self, symbol, interval="1m"):
 11840:     97:             return self.data[symbol]
 11841:     98: 
 11842:     99:     pairs = [
 11843:    100:         {"symbol": "AAA", "lastPrice": "1"},
 11844:    101:         {"symbol": "BBB", "lastPrice": "1"},
 11845:    102:     ]
 11846:    103: 
 11847:    104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
 11848:    105: 
 11849:    106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
 11850:    107:         if last_fast > prev_fast:
 11851:    108:             return 1
 11852:    109:         if last_fast < prev_fast:
 11853:    110:             return -1
 11854:    111:         return 0
 11855:    112: 
 11856:    113:     monkeypatch.setattr(bot, "cross", fake_cross)
 11857:    114: 
 11858:    115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
 11859:    116:     assert signals == [
 11860:    117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
 11861:    118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
 11862:    119:     ]
 11863: 
 11864: 
 11865: ## tests/test_pairs.py (last modified: 2025-08-23 20:57:14)
 11866:      1: import bot
 11867:      2: 
 11868:      3: 
 11869:      4: def test_send_selected_pairs(monkeypatch):
 11870:      5:     sent = {}
 11871:      6: 
 11872:      7:     def fake_notify(event, payload=None):
 11873:      8:         sent["event"] = event
 11874:      9:         sent["payload"] = payload
 11875:     10: 
 11876:     11:     monkeypatch.setattr(bot, "notify", fake_notify)
 11877:     12:     monkeypatch.setattr(
 11878:     13:         bot,
 11879:     14:         "filter_trade_pairs",
 11880:     15:         lambda client, top_n=120: [
 11881:     16:             {"symbol": "WIFUSDT", "volume": 10},
 11882:     17:             {"symbol": "WIFUSDT", "volume": 9},
 11883:     18:             {"symbol": "BTCUSD", "volume": 8},
 11884:     19:             {"symbol": "BTCUSDT", "volume": 7},
 11885:     20:             {"symbol": "DOGEUSDT", "volume": 6},
 11886:     21:             {"symbol": "ETHUSDC", "volume": 5},
 11887:     22:             {"symbol": "ETHUSDT", "volume": 4},
 11888:     23:         ],
 11889:     24:     )
 11890:     25: 
 11891:     26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
 11892:     27: 
 11893:     28:     payload = bot.send_selected_pairs(object(), top_n=4)
 11894:     29: 
 11895:     30:     assert sent["event"] == "pair_list"
 11896:     31:     assert sent["payload"]["green"] == "BTC"
 11897:     32:     assert sent["payload"]["orange"] == "ETH"
 11898:     33:     assert "red" not in sent["payload"]
 11899:     34:     assert payload == sent["payload"]
 11900:     35: 
 11901:     36: 
 11902:     37: def test_send_selected_pairs_no_whitelist(monkeypatch):
 11903:     38:     sent = {}
 11904:     39: 
 11905:     40:     def fake_notify(event, payload=None):
 11906:     41:         sent["payload"] = payload
 11907:     42: 
 11908:     43:     monkeypatch.setattr(bot, "notify", fake_notify)
 11909:     44:     monkeypatch.setattr(
 11910:     45:         bot,
 11911:     46:         "filter_trade_pairs",
 11912:     47:         lambda client, top_n=120: [
 11913:     48:             {"symbol": "AAAUSDT", "volume": 10},
 11914:     49:             {"symbol": "BBBUSD", "volume": 9},
 11915:     50:             {"symbol": "CCCUSDC", "volume": 8},
 11916:     51:             {"symbol": "DDDUSDT", "volume": 7},
 11917:     52:         ],
 11918:     53:     )
 11919:     54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
 11920:     55: 
 11921:     56:     payload = bot.send_selected_pairs(object(), top_n=4)
 11922:     57: 
 11923:     58:     assert payload == sent["payload"]
 11924:     59:     assert payload["green"] == "AAA"
 11925:     60:     assert payload["orange"] == "BBB"
 11926:     61:     assert payload["red"] == "CCC, DDD"
 11927:     62: 
 11928:     63: 
 11929:     64: def test_filter_trade_pairs_all_pairs(monkeypatch):
 11930:     65:     class DummyClient:
 11931:     66:         def get_ticker(self):
 11932:     67:             return {
 11933:     68:                 "data": [
 11934:     69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
 11935:     70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
 11936:     71:                 ]
 11937:     72:             }
 11938:     73: 
 11939:     74:     client = DummyClient()
 11940:     75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
 11941:     76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
 11942:     77: 
 11943: 
 11944: 
 11945: ## tests/test_risk_manager.py (last modified: 2025-08-23 20:57:14)
 11946:      1: from scalp import RiskManager
 11947:      2: 
 11948:      3: 
 11949:      4: def test_kill_switch_triggered() -> None:
 11950:      5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
 11951:      6:     rm.record_trade(-1.0)
 11952:      7:     rm.record_trade(-1.5)
 11953:      8:     assert rm.kill_switch is True
 11954:      9: 
 11955:     10: 
 11956:     11: def test_profit_kill_switch_triggered() -> None:
 11957:     12:     rm = RiskManager(
 11958:     13:         max_daily_loss_pct=10.0,
 11959:     14:         max_daily_profit_pct=3.0,
 11960:     15:         max_positions=1,
 11961:     16:         risk_pct=0.01,
 11962:     17:     )
 11963:     18:     rm.record_trade(1.5)
 11964:     19:     rm.record_trade(1.6)
 11965:     20:     assert rm.kill_switch is True
 11966:     21: 
 11967:     22: 
 11968:     23: def test_pause_and_can_open() -> None:
 11969:     24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 11970:     25:     rm.record_trade(-0.5)
 11971:     26:     rm.record_trade(-0.6)
 11972:     27:     rm.record_trade(-0.7)
 11973:     28:     assert rm.pause_duration() == 15 * 60
 11974:     29:     rm.record_trade(-0.8)
 11975:     30:     rm.record_trade(-0.9)
 11976:     31:     assert rm.pause_duration() == 60 * 60
 11977:     32:     assert rm.can_open(0) is True
 11978:     33:     assert rm.can_open(1) is False
 11979:     34: 
 11980:     35: 
 11981:     36: def test_risk_pct_scaling() -> None:
 11982:     37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 11983:     38:     rm.record_trade(1.0)
 11984:     39:     rm.record_trade(1.0)
 11985:     40:     assert rm.risk_pct > 0.01
 11986:     41:     rm.record_trade(-1.0)
 11987:     42:     rm.record_trade(-1.0)
 11988:     43:     assert rm.risk_pct < 0.01
 11989: 
 11990: 
 11991: ## tests/test_risk_utils.py (last modified: 2025-08-23 20:57:14)
 11992:      1: import pytest
 11993:      2: 
 11994:      3: from scalper.risk import calc_risk_amount, calc_position_size
 11995:      4: 
 11996:      5: 
 11997:      6: def test_calc_risk_amount_basic():
 11998:      7:     assert calc_risk_amount(1000, 0.01) == 10.0
 11999:      8: 
 12000:      9: 
 12001:     10: def test_calc_position_size_basic():
 12002:     11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
 12003:     12:     assert calc_position_size(1000, 0.01, 50) == 0.2
 12004:     13: 
 12005:     14: 
 12006:     15: @pytest.mark.parametrize("equity,risk_pct", [
 12007:     16:     (0, 0.01),
 12008:     17:     (-100, 0.01),
 12009:     18:     (1000, 0),
 12010:     19:     (1000, -0.1),
 12011:     20:     (1000, 1.5),
 12012:     21: ])
 12013:     22: def test_calc_risk_amount_invalid(equity, risk_pct):
 12014:     23:     with pytest.raises(ValueError):
 12015:     24:         calc_risk_amount(equity, risk_pct)
 12016:     25: 
 12017:     26: 
 12018:     27: @pytest.mark.parametrize("stop_distance", [0, -1])
 12019:     28: def test_calc_position_size_invalid_stop(stop_distance):
 12020:     29:     with pytest.raises(ValueError):
 12021:     30:         calc_position_size(1000, 0.01, stop_distance)
 12022: 
 12023: 
 12024: ## tests/test_signal_risk.py (last modified: 2025-08-23 20:57:14)
 12025:      1: import types
 12026:      2: import os
 12027:      3: import sys
 12028:      4: 
 12029:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12030:      6: sys.modules['requests'] = types.ModuleType('requests')
 12031:      7: 
 12032:      8: from bot import (
 12033:      9:     map_score_to_sig_level,
 12034:     10:     compute_risk_params,
 12035:     11:     prepare_order,
 12036:     12:     Signal,
 12037:     13:     CONFIG,
 12038:     14: )
 12039:     15: 
 12040:     16: 
 12041:     17: class DummyRisk:
 12042:     18:     def __init__(self, pct: float) -> None:
 12043:     19:         self.risk_pct = pct
 12044:     20: 
 12045:     21: 
 12046:     22: def _contract_detail():
 12047:     23:     return {
 12048:     24:         "data": [
 12049:     25:             {
 12050:     26:                 "symbol": "BTC_USDT",
 12051:     27:                 "contractSize": 0.001,
 12052:     28:                 "volUnit": 1,
 12053:     29:                 "minVol": 1,
 12054:     30:                 "minTradeUSDT": 5,
 12055:     31:             }
 12056:     32:         ]
 12057:     33:     }
 12058:     34: 
 12059:     35: 
 12060:     36: def test_score_to_level_mapping():
 12061:     37:     assert map_score_to_sig_level(10) == 1
 12062:     38:     assert map_score_to_sig_level(35) == 2
 12063:     39:     assert map_score_to_sig_level(69.9) == 2
 12064:     40:     assert map_score_to_sig_level(70) == 3
 12065:     41: 
 12066:     42: 
 12067:     43: def test_risk_tables():
 12068:     44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
 12069:     45:     assert rp == 0.01 * 1.25
 12070:     46:     assert lev == int(20 * 0.75)
 12071:     47:     assert cap == 0.55
 12072:     48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
 12073:     49:     assert rp2 == 0.01 * 1.0
 12074:     50:     assert lev2 == int(20 * 0.5)
 12075:     51:     assert cap2 == 0.35
 12076:     52: 
 12077:     53: 
 12078:     54: def test_notional_cap():
 12079:     55:     rm = DummyRisk(0.05)
 12080:     56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 12081:     57:     available = 1000
 12082:     58:     params = prepare_order(
 12083:     59:         sig,
 12084:     60:         _contract_detail(),
 12085:     61:         equity_usdt=available,
 12086:     62:         available_usdt=available,
 12087:     63:         base_leverage=10,
 12088:     64:         risk_mgr=rm,
 12089:     65:         user_risk_level=2,
 12090:     66:     )
 12091:     67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6
 12092: 
 12093: 
 12094: ## tests/test_slippage.py (last modified: 2025-08-23 20:57:14)
 12095:      1: from scalper.trade_utils import marketable_limit_price
 12096:      2: 
 12097:      3: 
 12098:      4: def test_marketable_limit_price_buy_sell():
 12099:      5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
 12100:      6:     assert price_buy == 10.0 * 1.001
 12101:      7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
 12102:      8:     assert price_sell == 9.9 * (1 - 0.001)
 12103: 
 12104: 
 12105: ## tests/test_strategy_v2.py (last modified: 2025-08-23 20:57:14)
 12106:      1: import pytest
 12107:      2: 
 12108:      3: from scalp import strategy
 12109:      4: from scalper.trade_utils import trailing_stop, should_scale_in, timeout_exit
 12110:      5: 
 12111:      6: 
 12112:      7: def make_ohlcv(n=60, start=100, step=1):
 12113:      8:     closes = [start + i * step for i in range(n)]
 12114:      9:     highs = [c + 1 for c in closes]
 12115:     10:     lows = [c - 1 for c in closes]
 12116:     11:     vols = [1 for _ in closes]
 12117:     12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
 12118:     13: 
 12119:     14: 
 12120:     15: def test_generate_signal_atr_adaptation(monkeypatch):
 12121:     16:     base = make_ohlcv(step=2)
 12122:     17:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12123:     18:     ohlcv_1h = make_ohlcv(step=2)
 12124:     19: 
 12125:     20:     # patches for deterministic RSI values
 12126:     21:     rsi_vals = iter([60, 41, 39])
 12127:     22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12128:     23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12129:     24:     # low ATR -> signal disabled
 12130:     25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
 12131:     26:     sig = strategy.generate_signal(
 12132:     27:         "AAA",
 12133:     28:         base,
 12134:     29:         equity=1_000,
 12135:     30:         risk_pct=0.01,
 12136:     31:         ohlcv_15m=ohlcv_15,
 12137:     32:         ohlcv_1h=ohlcv_1h,
 12138:     33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12139:     34:         tick_ratio_buy=0.6,
 12140:     35:     )
 12141:     36:     assert sig is None
 12142:     37: 
 12143:     38:     # high ATR -> size reduced
 12144:     39:     rsi_vals = iter([60, 41, 39])
 12145:     40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12146:     41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
 12147:     42:     sig = strategy.generate_signal(
 12148:     43:         "AAA",
 12149:     44:         base,
 12150:     45:         equity=1_000,
 12151:     46:         risk_pct=0.01,
 12152:     47:         ohlcv_15m=ohlcv_15,
 12153:     48:         ohlcv_1h=ohlcv_1h,
 12154:     49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12155:     50:         tick_ratio_buy=0.6,
 12156:     51:     )
 12157:     52:     assert sig and sig.side == "long"
 12158:     53:     assert sig.qty == 50
 12159:     54: 
 12160:     55: 
 12161:     56: def test_generate_signal_short_with_filters(monkeypatch):
 12162:     57:     base = make_ohlcv(start=200, step=-2)
 12163:     58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
 12164:     59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
 12165:     60: 
 12166:     61:     rsi_vals = iter([40, 59, 61])
 12167:     62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12168:     63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12169:     64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12170:     65: 
 12171:     66:     sig = strategy.generate_signal(
 12172:     67:         "AAA",
 12173:     68:         base,
 12174:     69:         equity=1_000,
 12175:     70:         risk_pct=0.01,
 12176:     71:         ohlcv_15m=ohlcv_15,
 12177:     72:         ohlcv_1h=ohlcv_1h,
 12178:     73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
 12179:     74:         tick_ratio_buy=0.4,
 12180:     75:     )
 12181:     76:     assert sig and sig.side == "short"
 12182:     77:     assert sig.qty == 100
 12183:     78: 
 12184:     79: 
 12185:     80: def test_trailing_and_timeout():
 12186:     81:     # trailing stop
 12187:     82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
 12188:     83:     assert sl == pytest.approx(102.5)
 12189:     84:     # scaling
 12190:     85:     assert should_scale_in(100, 105, 100, 10, "long") is True
 12191:     86:     assert should_scale_in(100, 95, 100, 10, "short") is True
 12192:     87:     # timeout
 12193:     88:     # before the progress window no exit should be triggered
 12194:     89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 12195:     90:     # after ``progress_min`` minutes without favourable movement we close
 12196:     91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 12197:     92: 
 12198:     93: 
 12199:     94: def test_generate_signal_macd_filter(monkeypatch):
 12200:     95:     base = make_ohlcv(step=2)
 12201:     96:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12202:     97:     ohlcv_1h = make_ohlcv(step=2)
 12203:     98: 
 12204:     99:     rsi_vals = iter([60, 41, 39])
 12205:    100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12206:    101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12207:    102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12208:    103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
 12209:    104: 
 12210:    105:     sig = strategy.generate_signal(
 12211:    106:         "AAA",
 12212:    107:         base,
 12213:    108:         equity=1_000,
 12214:    109:         risk_pct=0.01,
 12215:    110:         ohlcv_15m=ohlcv_15,
 12216:    111:         ohlcv_1h=ohlcv_1h,
 12217:    112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12218:    113:         tick_ratio_buy=0.6,
 12219:    114:     )
 12220:    115:     assert sig is None
 12221:    116: 
 12222:    117: 
 12223:    118: 
 12224:    119: def test_generate_signal_trend_ema_filter(monkeypatch):
 12225:    120:     base = make_ohlcv(step=2)
 12226:    121:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12227:    122:     ohlcv_1h = make_ohlcv(step=2)
 12228:    123: 
 12229:    124:     rsi_vals = iter([60, 41, 39])
 12230:    125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12231:    126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12232:    127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12233:    128: 
 12234:    129:     orig_ema = strategy.ema
 12235:    130: 
 12236:    131:     def fake_ema(series, window):
 12237:    132:         if window == 200:
 12238:    133:             return [x + 1000 for x in orig_ema(series, window)]
 12239:    134:         return orig_ema(series, window)
 12240:    135: 
 12241:    136:     monkeypatch.setattr(strategy, "ema", fake_ema)
 12242:    137: 
 12243:    138:     sig = strategy.generate_signal(
 12244:    139:         "AAA",
 12245:    140:         base,
 12246:    141:         equity=1_000,
 12247:    142:         risk_pct=0.01,
 12248:    143:         ohlcv_15m=ohlcv_15,
 12249:    144:         ohlcv_1h=ohlcv_1h,
 12250:    145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12251:    146:         tick_ratio_buy=0.6,
 12252:    147:         trend_ema_period=200,
 12253:    148:     )
 12254:    149:     assert sig is None
 12255:    150:     
 12256: 
 12257: ## tests/test_telegram_bot.py (last modified: 2025-08-23 20:57:14)
 12258:      1: from scalper.telegram_bot import TelegramBot
 12259:      2: 
 12260:      3: 
 12261:      4: class DummyClient:
 12262:      5: 
 12263:      6:     def __init__(self):
 12264:      7:         self.closed = []
 12265:      8:         self.closed_all = False
 12266:      9: 
 12267:     10: 
 12268:     11:     def get_assets(self):
 12269:     12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
 12270:     13: 
 12271:     14:     def get_positions(self):
 12272:     15:         return {
 12273:     16:             "data": [
 12274:     17:                 {
 12275:     18:                     "symbol": "BTC_USDT",
 12276:     19:                     "side": "long",
 12277:     20:                     "vol": 2,
 12278:     21:                     "pnl_usd": 1.0,
 12279:     22:                     "pnl_pct": 5.0,
 12280:     23:                 }
 12281:     24:             ]
 12282:     25:         }
 12283:     26: 
 12284:     27:     def close_position(self, sym):
 12285:     28:         self.closed.append(sym)
 12286:     29: 
 12287:     30:     def close_all_positions(self):
 12288:     31:         self.closed_all = True
 12289:     32: 
 12290:     33: 
 12291:     34: 
 12292:     35: class DummyRiskMgr:
 12293:     36: 
 12294:     37:     def __init__(self):
 12295:     38:         self.reset_called = False
 12296:     39:         self.max_positions = 1
 12297:     40:         self.risk_pct = 0.01
 12298:     41: 
 12299:     42:     def reset_day(self):
 12300:     43:         self.reset_called = True
 12301:     44: 
 12302:     45: 
 12303:     46: class DummyRequests:
 12304:     47:     def __init__(self):
 12305:     48:         self.posts = []
 12306:     49: 
 12307:     50:     def post(self, url, json=None, timeout=5):
 12308:     51:         self.posts.append((url, json))
 12309:     52: 
 12310:     53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
 12311:     54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
 12312:     55: 
 12313:     56: 
 12314:     57: def make_bot(config=None, requests_module=None):
 12315:     58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
 12316:     59:     if config:
 12317:     60:         cfg.update(config)
 12318:     61:     if requests_module is None:
 12319:     62:         requests_module = DummyRequests()
 12320:     63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
 12321:     64: 
 12322:     65: 
 12323:     66: def test_handle_balance():
 12324:     67:     bot = make_bot()
 12325:     68: 
 12326:     69:     resp, kb = bot.handle_callback("balance", 0.0)
 12327:     70:     assert "123.45" in resp
 12328:     71:     assert kb == bot.main_keyboard
 12329:     72: 
 12330:     73: 
 12331:     74: 
 12332:     75: def test_handle_positions():
 12333:     76:     bot = make_bot()
 12334:     77:     resp, _ = bot.handle_callback("positions", 0.0)
 12335:     78:     assert "BTC" in resp
 12336:     79:     assert "PnL" in resp
 12337:     80: 
 12338:     81: 
 12339:     82: def test_handle_positions_zero_pnl():
 12340:     83:     bot = make_bot()
 12341:     84: 
 12342:     85:     def zero_positions():
 12343:     86:         return {
 12344:     87:             "data": [
 12345:     88:                 {
 12346:     89:                     "symbol": "BTC_USDT",
 12347:     90:                     "side": "long",
 12348:     91:                     "vol": 1,
 12349:     92:                     "pnl_usd": 0.0,
 12350:     93:                     "pnl_pct": 0.0,
 12351:     94:                 }
 12352:     95:             ]
 12353:     96:         }
 12354:     97: 
 12355:     98:     bot.client.get_positions = zero_positions
 12356:     99:     resp, _ = bot.handle_callback("positions", 0.0)
 12357:    100:     assert "PnL: 0.00 USDT" in resp
 12358:    101: 
 12359:    102: 
 12360:    103: 
 12361:    104: def test_handle_pnl():
 12362:    105:     bot = make_bot()
 12363:    106:     resp, _ = bot.handle_callback("pnl", 5.0)
 12364:    107: 
 12365:    108:     assert "5.00" in resp
 12366:    109: 
 12367:    110: 
 12368:    111: def test_handle_risk_change():
 12369:    112:     bot = make_bot()
 12370:    113: 
 12371:    114:     resp, kb = bot.handle_callback("risk_red", 0.0)
 12372:    115:     assert "3" in resp
 12373:    116:     assert bot.config["RISK_LEVEL"] == 3
 12374:    117:     assert kb == bot.main_keyboard
 12375:    118: 
 12376:    119: 
 12377:    120: def test_risk_menu():
 12378:    121:     bot = make_bot()
 12379:    122:     resp, kb = bot.handle_callback("risk", 0.0)
 12380:    123:     assert "risque" in resp.lower()
 12381:    124:     assert kb == bot.risk_keyboard
 12382:    125: 
 12383:    126: 
 12384:    127: 
 12385:    128: def test_stop_menu_and_actions():
 12386:    129:     bot = make_bot()
 12387:    130:     resp, kb = bot.handle_callback("stop", 0.0)
 12388:    131:     assert any(
 12389:    132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
 12390:    133:     )
 12391:    134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
 12392:    135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
 12393:    136:     assert "fermée" in resp.lower()
 12394:    137:     assert bot.client.closed == ["BTC_USDT"]
 12395:    138:     resp, _ = bot.handle_callback("stop_all", 0.0)
 12396:    139:     assert bot.client.closed_all is True
 12397:    140: 
 12398:    141: 
 12399:    142: def test_handle_unknown():
 12400:    143:     bot = make_bot()
 12401:    144:     resp, kb = bot.handle_callback("foobar", 0.0)
 12402:    145:     assert resp is None
 12403:    146:     assert kb is None
 12404:    147: 
 12405:    148: 
 12406:    149: def test_reset_all():
 12407:    150:     bot = make_bot()
 12408:    151:     resp, kb = bot.handle_callback("reset_all", 0.0)
 12409:    152:     assert "réinitialisés" in resp.lower()
 12410:    153:     assert bot.risk_mgr.reset_called is True
 12411:    154:     assert bot.client.closed_all is True
 12412:    155:     assert kb == bot.settings_keyboard
 12413:    156: 
 12414:    157: 
 12415:    158: def test_shutdown_bot():
 12416:    159:     bot = make_bot()
 12417:    160:     resp, kb = bot.handle_callback("shutdown", 0.0)
 12418:    161:     assert "arrêt" in resp.lower()
 12419:    162:     assert bot.stop_requested is True
 12420:    163:     assert kb == bot.main_keyboard
 12421:    164: 
 12422:    165: 
 12423:    166: def test_start_sends_menu():
 12424:    167:     req = DummyRequests()
 12425:    168:     make_bot(requests_module=req)
 12426:    169:     assert req.posts
 12427:    170:     text = req.posts[0][1]["text"]
 12428:    171:     assert "Solde" in text and "PnL session" in text
 12429:    172:     assert "Positions max" in text
 12430:    173:     assert "Risque actuel" in text
 12431:    174: 
 12432:    175: 
 12433:    176: def test_settings_menu_and_reset_risk():
 12434:    177:     bot = make_bot()
 12435:    178:     resp, kb = bot.handle_callback("settings", 0.0)
 12436:    179:     assert "réglages" in resp.lower()
 12437:    180:     assert kb == bot.settings_keyboard
 12438:    181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
 12439:    182:     assert "risque" in resp.lower()
 12440:    183:     assert bot.risk_mgr.reset_called is True
 12441:    184:     assert kb == bot.settings_keyboard
 12442:    185: 
 12443:    186: 
 12444:    187: def test_update_button(monkeypatch):
 12445:    188:     bot = make_bot()
 12446:    189:     called = {}
 12447:    190: 
 12448:    191:     def fake_update():
 12449:    192:         called["called"] = True
 12450:    193: 
 12451:    194:     bot.update_pairs = fake_update
 12452:    195:     resp, kb = bot.handle_callback("update", 0.0)
 12453:    196:     assert called["called"] is True
 12454:    197:     assert "mise à jour" in resp.lower()
 12455:    198:     assert kb == bot.main_keyboard
 12456:    199: 
 12457:    200: 
 12458:    201: def test_maxpos_menu_and_change():
 12459:    202:     bot = make_bot()
 12460:    203:     resp, kb = bot.handle_callback("maxpos", 0.0)
 12461:    204:     assert "nombre" in resp.lower()
 12462:    205:     assert kb == bot.maxpos_keyboard
 12463:    206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
 12464:    207:     assert "3" in resp
 12465:    208:     assert bot.config["MAX_POSITIONS"] == 3
 12466:    209:     assert bot.risk_mgr.max_positions == 3
 12467:    210:     assert kb == bot.main_keyboard
 12468:    211: 
 12469:    212: 
 12470:    213: def test_stop_no_positions():
 12471:    214:     bot = make_bot()
 12472:    215:     bot.client.get_positions = lambda: {"data": []}
 12473:    216:     resp, kb = bot.handle_callback("stop", 0.0)
 12474:    217:     assert "aucune crypto" in resp.lower()
 12475:    218:     assert kb == bot.settings_keyboard
 12476:    219: 
 12477: 
 12478: 
 12479: ## tests/test_utils.py (last modified: 2025-08-23 20:57:14)
 12480:      1: import pytest
 12481:      2: from bot import ema, cross, compute_position_size, CONFIG
 12482:      3: from scalper.trade_utils import extract_available_balance
 12483:      4: 
 12484:      5: 
 12485:      6: def test_ema_basic():
 12486:      7:     data = [1, 2, 3, 4, 5]
 12487:      8:     result = ema(data, 3)
 12488:      9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
 12489:     10: 
 12490:     11: 
 12491:     12: def test_cross_up_down_none():
 12492:     13:     assert cross(3, 2, 1, 2) == 1  # up cross
 12493:     14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
 12494:     15:     assert cross(2, 2, 2, 2) == 0  # no cross
 12495:     16: 
 12496:     17: 
 12497:     18: def test_compute_position_size():
 12498:     19:     detail = {
 12499:     20:         "data": [
 12500:     21:             {
 12501:     22:                 "symbol": CONFIG["SYMBOL"],
 12502:     23:                 "contractSize": 0.001,
 12503:     24:                 "volUnit": 1,
 12504:     25:                 "minVol": 1,
 12505:     26:             }
 12506:     27:         ]
 12507:     28:     }
 12508:     29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
 12509:     30:                                 risk_pct=0.01, leverage=5)
 12510:     31:     assert vol == 1
 12511:     32: 
 12512:     33: 
 12513:     34: def test_compute_position_size_missing_symbol():
 12514:     35:     with pytest.raises(ValueError):
 12515:     36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
 12516:     37: 
 12517:     38: 
 12518:     39: def test_extract_available_balance_fallback():
 12519:     40:     assets = {
 12520:     41:         "data": [
 12521:     42:             {
 12522:     43:                 "currency": "USDT",
 12523:     44:                 "available": 0,
 12524:     45:                 "cashBalance": "150.5",
 12525:     46:                 "equity": "200",
 12526:     47:             }
 12527:     48:         ]
 12528:     49:     }
 12529:     50:     assert extract_available_balance(assets) == 150.5
 12530:     51: 
 12531:     52: 
 12532:     53: def test_extract_available_balance_equity_only():
 12533:     54:     assets = {
 12534:     55:         "data": [
 12535:     56:             {
 12536:     57:                 "currency": "USDT",
 12537:     58:                 "equity": "42",
 12538:     59:             }
 12539:     60:         ]
 12540:     61:     }
 12541:     62:     assert extract_available_balance(assets) == 42.0
 12542:     63: 
 12543:     64: 
 12544:     65: def test_extract_available_balance_zero_available_returns_zero():
 12545:     66:     assets = {
 12546:     67:         "data": [
 12547:     68:             {
 12548:     69:                 "currency": "USDT",
 12549:     70:                 "available": 0,
 12550:     71:                 "availableBalance": 0,
 12551:     72:                 "equity": "42",
 12552:     73:             }
 12553:     74:         ]
 12554:     75:     }
 12555:     76:     assert extract_available_balance(assets) == 0.0
 12556: 
 12557: 
 12558: ## tests/test_version.py (last modified: 2025-08-23 20:57:14)
 12559:      1: import pytest
 12560:      2: from scalp import version
 12561:      3: 
 12562:      4: 
 12563:      5: def test_get_version(monkeypatch, tmp_path):
 12564:      6:     vfile = tmp_path / "VERSION"
 12565:      7:     vfile.write_text("1.2.3")
 12566:      8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12567:      9:     assert version.get_version() == "1.2.3"
 12568:     10: 
 12569:     11: 
 12570:     12: def test_bump_version(monkeypatch, tmp_path):
 12571:     13:     vfile = tmp_path / "VERSION"
 12572:     14: 
 12573:     15:     vfile.write_text("0.1.2\n")
 12574:     16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12575:     17:     assert version.bump_version("minor") == "0.2.0"
 12576:     18:     assert vfile.read_text().strip() == "0.2.0"
 12577:     19: 
 12578:     20: 
 12579:     21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
 12580:     22:     vfile = tmp_path / "VERSION"
 12581:     23:     vfile.write_text("0.1.0\n")
 12582:     24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12583:     25:     with pytest.raises(ValueError):
 12584:     26:         version.bump_version("foo")
 12585:     27: 
 12586:     28: 
 12587:     29: def test_bump_from_message(monkeypatch, tmp_path):
 12588:     30:     vfile = tmp_path / "VERSION"
 12589:     31:     vfile.write_text("1.0.0\n")
 12590:     32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12591:     33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
 12592:     34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
 12593:     35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
 12594:     36: 
 12595: 
 12596: 
 12597: ## tests/test_walk_forward.py (last modified: 2025-08-23 20:57:14)
 12598:      1: from scalper.backtest import walk_forward_windows
 12599:      2: 
 12600:      3: 
 12601:      4: def test_walk_forward_windows():
 12602:      5:     data = list(range(10))
 12603:      6:     windows = list(walk_forward_windows(data, train=4, test=2))
 12604:      7:     assert windows == [
 12605:      8:         ([0, 1, 2, 3], [4, 5]),
 12606:      9:         ([2, 3, 4, 5], [6, 7]),
 12607:     10:         ([4, 5, 6, 7], [8, 9]),
 12608:     11:     ]
 12609: 
 12610: 
 12611: ## tests/test_ws.py (last modified: 2025-08-23 20:57:14)
 12612:      1: import asyncio
 12613:      2: 
 12614:      3: from scalper.ws import WebsocketManager
 12615:      4: 
 12616:      5: 
 12617:      6: def test_websocket_manager_stop():
 12618:      7:     async def connect():
 12619:      8:         return None
 12620:      9: 
 12621:     10:     async def subscribe():
 12622:     11:         return None
 12623:     12: 
 12624:     13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
 12625:     14: 
 12626:     15:     async def run_and_stop():
 12627:     16:         await ws.run()
 12628:     17:         assert ws._heartbeat_task is not None
 12629:     18:         await ws.stop()
 12630:     19:         assert ws._heartbeat_task is None
 12631:     20: 
 12632:     21:     asyncio.run(run_and_stop())
 12633: 
 12634: 
 12635: ## tg_diag.py (last modified: 2025-08-23 20:57:14)
 12636:      1: # tg_diag.py
 12637:      2: import asyncio, os, aiohttp
 12638:      3: 
 12639:      4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
 12640:      5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
 12641:      6: 
 12642:      7: async def main():
 12643:      8:     if not TOKEN or not CHAT:
 12644:      9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
 12645:     10:         return
 12646:     11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
 12647:     12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
 12648:     13:     try:
 12649:     14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
 12650:     15:             async with s.post(url, json=payload) as r:
 12651:     16:                 body = await r.text()
 12652:     17:                 print("HTTP:", r.status)
 12653:     18:                 print("Body:", body[:500])
 12654:     19:     except Exception as e:
 12655:     20:         print("❌ Exception:", repr(e))
 12656:     21: 
 12657:     22: if __name__ == "__main__":
 12658:     23:     asyncio.run(main())
 12659: 

--------------------------------------------------------------------------------
FILE: engine/VERSION  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: 0.3.0
     2: 

--------------------------------------------------------------------------------
FILE: engine/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Rend le dossier 'scalper' importable comme package.
     2: __all__ = ["live", "signals", "core"]

--------------------------------------------------------------------------------
FILE: engine/adapters/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/adapters/bitget.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/adapters/bitget.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional
     4: import inspect, os
     5: import requests
     6: 
     7: # Client bas-niveau fourni par le repo
     8: from engine.bitget_client import BitgetFuturesClient as _Base
     9: 
    10: 
    11: def _to_float(x, default: float = 0.0) -> float:
    12:     try:
    13:         return float(x)
    14:     except Exception:
    15:         return default
    16: 
    17: 
    18: def _select_base_url() -> str:
    19:     env = os.environ.get("BITGET_BASE_URL")
    20:     if env:
    21:         return env
    22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
    23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
    24: 
    25: 
    26: class BitgetFuturesClient(_Base):
    27:     """
    28:     Adaptateur Bitget:
    29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
    30:       - Normalisations robustes: assets, ticker(s), positions, fills
    31:     """
    32: 
    33:     # --------------------- INIT dynamique ---------------------
    34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
    35:         """
    36:         Accepte indifféremment:
    37:           api_key/apiKey/access_key/accessKey/key
    38:           api_secret/apiSecret/secret/secret_key/secretKey
    39:           passphrase/password/api_passphrase/apiPassphrase
    40:           base_url/baseUrl/host/endpoint (ou auto)
    41:         On n'envoie au client de base que les noms présents dans sa signature.
    42:         """
    43:         user_kwargs = dict(kwargs)
    44: 
    45:         # Collecte des valeurs possibles (tous alias)
    46:         incoming_key = (
    47:             user_kwargs.pop("api_key", None)
    48:             or user_kwargs.pop("apiKey", None)
    49:             or user_kwargs.pop("access_key", None)
    50:             or user_kwargs.pop("accessKey", None)
    51:             or user_kwargs.pop("key", None)
    52:             or user_kwargs.pop("API_KEY", None)
    53:         )
    54:         incoming_secret = (
    55:             user_kwargs.pop("api_secret", None)
    56:             or user_kwargs.pop("apiSecret", None)
    57:             or user_kwargs.pop("secret_key", None)
    58:             or user_kwargs.pop("secretKey", None)
    59:             or user_kwargs.pop("secret", None)
    60:             or user_kwargs.pop("API_SECRET", None)
    61:         )
    62:         incoming_pass = (
    63:             user_kwargs.pop("passphrase", None)
    64:             or user_kwargs.pop("password", None)
    65:             or user_kwargs.pop("api_passphrase", None)
    66:             or user_kwargs.pop("apiPassphrase", None)
    67:         )
    68:         incoming_base = (
    69:             user_kwargs.pop("base_url", None)
    70:             or user_kwargs.pop("baseUrl", None)
    71:             or user_kwargs.pop("host", None)
    72:             or user_kwargs.pop("endpoint", None)
    73:             or _select_base_url()
    74:         )
    75: 
    76:         # Signature réelle du client bas-niveau
    77:         sig = inspect.signature(_Base.__init__)
    78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
    79: 
    80:         def pick_name(cands: List[str]) -> Optional[str]:
    81:             for c in cands:
    82:                 if c in param_names:
    83:                     return c
    84:             return None
    85: 
    86:         # Noms réellement supportés
    87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
    88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
    89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
    90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
    91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
    92: 
    93:         # Construire kwargs à transmettre (une seule fois par nom)
    94:         base_kwargs: Dict[str, Any] = {}
    95:         if key_name and incoming_key is not None:
    96:             base_kwargs[key_name] = incoming_key
    97:         if sec_name and incoming_secret is not None:
    98:             base_kwargs[sec_name] = incoming_secret
    99:         if pas_name and incoming_pass is not None:
   100:             base_kwargs[pas_name] = incoming_pass
   101:         if base_name:
   102:             base_kwargs[base_name] = incoming_base
   103:         if req_mod_name:
   104:             base_kwargs[req_mod_name] = requests
   105: 
   106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
   107:         # qui n'a pas été défini ci-dessus, on le relaie.
   108:         for k, v in list(user_kwargs.items()):
   109:             if k in param_names and k not in base_kwargs:
   110:                 base_kwargs[k] = v
   111: 
   112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
   113:         super().__init__(**base_kwargs)
   114: 
   115:     # --------------------- COMPTES / ASSETS ---------------------
   116:     def get_assets(self) -> Dict[str, Any]:
   117:         raw = super().get_assets()
   118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
   119:         norm: List[Dict[str, Any]] = []
   120:         for a in data:
   121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
   122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
   123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
   124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
   125:         return {"success": True, "data": norm}
   126: 
   127:     # ------------------------ TICKER(S) -------------------------
   128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   129:         """
   130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
   131:         Tolère top-level dict/list et items dict/list.
   132:         """
   133:         try:
   134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
   135:         except Exception as e:
   136:             return {"success": False, "error": repr(e), "data": []}
   137: 
   138:         items: List[Any] = []
   139:         if isinstance(raw, dict):
   140:             d = raw.get("data")
   141:             if symbol and isinstance(d, dict):
   142:                 items = [d]
   143:             else:
   144:                 items = d or raw.get("result") or raw.get("tickers") or []
   145:         elif isinstance(raw, (list, tuple)):
   146:             items = list(raw)
   147: 
   148:         norm: List[Dict[str, Any]] = []
   149:         for t in items:
   150:             if isinstance(t, dict):
   151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
   152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
   153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
   154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
   155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
   156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
   157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
   158:                 norm.append({
   159:                     "symbol": s,
   160:                     "lastPrice": _to_float(last_),
   161:                     "bidPrice": _to_float(bid_),
   162:                     "askPrice": _to_float(ask_),
   163:                     "volume": volume
   164:                 })
   165:             else:
   166:                 seq = list(t)
   167:                 if len(seq) >= 5:
   168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
   169:                     if first_ts:
   170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
   171:                     else:
   172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
   173:                 else:
   174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
   175:                 s = (symbol or "").replace("_", "")
   176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
   177: 
   178:         return {"success": True, "data": norm}
   179: 
   180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
   181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
   183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
   184:         out: List[Dict[str, Any]] = []
   185:         for p in items:
   186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
   187:             if symbol and s != symbol:
   188:                 continue
   189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
   190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
   191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
   192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
   193:         return {"success": True, "data": out}
   194: 
   195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
   196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
   197:         items = raw.get("data") or raw.get("result") or []
   198:         out: List[Dict[str, Any]] = []
   199:         for f in items[:limit]:
   200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
   201:             if s != symbol:
   202:                 continue
   203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
   204:                 continue
   205:             out.append({
   206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
   207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
   208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
   209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
   210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
   211:                 "ts": int(f.get("ts", f.get("time", 0))),
   212:             })
   213:         return {"success": True, "data": out}
   214: 
   215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
   217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
   218:         return {"success": ok, "data": {"orderId": order_id}}

--------------------------------------------------------------------------------
FILE: engine/adapters/bitget_fetch.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/adapters/bitget_fetch.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import inspect
     6: import os
     7: from typing import Any, Optional
     8: 
     9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    10: 
    11: def _log(msg: str) -> None:
    12:     if BT_DEBUG:
    13:         print(f"[bt.debug] {msg}", flush=True)
    14: 
    15: _TF_TO_SECS = {
    16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    17:     "1h": 3600, "4h": 14400, "1d": 86400,
    18: }
    19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
    20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
    22: }
    23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
    24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
    26: }
    27: 
    28: def _await_if_needed(val: Any) -> Any:
    29:     if inspect.isawaitable(val):
    30:         try:
    31:             asyncio.get_running_loop()
    32:         except RuntimeError:
    33:             return asyncio.run(val)
    34:         else:
    35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
    36:             return fut.result()
    37:     return val
    38: 
    39: class BitgetFetchAdapter:
    40:     """
    41:     Adaptateur qui fournit une méthode CCXT-like:
    42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
    43:     au-dessus d'un client Bitget existant (sync ou async).
    44:     """
    45:     def __init__(self, client: Any, *, market_hint: str | None = None):
    46:         self.client = client
    47:         self.market_hint = (market_hint or "").lower() or None
    48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
    49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
    50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
    51: 
    52:     @staticmethod
    53:     def _possible_methods(client: Any) -> list[str]:
    54:         names = dir(client)
    55:         base = [
    56:             "fetch_ohlcv",
    57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
    58:             "klines", "get_klines", "kline",
    59:             "mix_get_candles", "mix_candles",
    60:             "spot_get_candles", "spot_candles",
    61:             "market_candles", "public_candles",
    62:         ]
    63:         # + heuristique: tout ce qui contient candle/kline
    64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
    65:         out = []
    66:         for n in base + extra:
    67:             if n in names and callable(getattr(client, n)) and n not in out:
    68:                 out.append(n)
    69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
    70:         return out
    71: 
    72:     @staticmethod
    73:     def _sym_variants(sym: str) -> list[str]:
    74:         s = sym.upper()
    75:         out = [s]
    76:         if not s.endswith("_UMCBL"):
    77:             out.append(f"{s}_UMCBL")
    78:         if not s.endswith("_SPBL"):
    79:             out.append(f"{s}_SPBL")
    80:         _log(f"Variantes symbole testées: {out}")
    81:         return out
    82: 
    83:     @staticmethod
    84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
    85:         secs = _TF_TO_SECS.get(timeframe, 300)
    86:         mix = _TF_TO_MIX.get(timeframe, "5min")
    87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
    88:         variants = []
    89:         if market_hint == "mix":
    90:             variants.append({"granularity": mix})
    91:         if market_hint == "spot":
    92:             variants.append({"period": spot})
    93:         variants += [
    94:             {"timeframe": timeframe},
    95:             {"interval": timeframe},
    96:             {"k": secs},
    97:             {"granularity": mix},
    98:             {"period": spot},
    99:         ]
   100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
   101:         return variants
   102: 
   103:     @staticmethod
   104:     def _normalize_rows(raw: Any) -> list[list[float]]:
   105:         import pandas as pd  # local import
   106:         if raw is None:
   107:             raise ValueError("OHLCV vide")
   108:         if isinstance(raw, dict) and "data" in raw:
   109:             raw = raw["data"]
   110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
   111:             out = []
   112:             for r in raw:
   113:                 ts = int(str(r[0]))
   114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
   115:                 out.append([ts, o, h, l, c, v])
   116:             return out
   117:         if "pandas" in str(type(raw)):
   118:             df = raw
   119:             if "timestamp" in df.columns:
   120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:                 df = df.set_index("timestamp").sort_index()
   122:             df = df[["open", "high", "low", "close", "volume"]]
   123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
   124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
   125: 
   126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
   127:         methods = self._possible_methods(self.client)
   128:         if not methods:
   129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
   130: 
   131:         last_err: Exception | None = None
   132:         for mname in methods:
   133:             fn = getattr(self.client, mname)
   134:             for sym in self._sym_variants(symbol):
   135:                 for par in self._param_variants(timeframe, self.market_hint):
   136:                     kwargs = dict(par)
   137:                     kwargs.setdefault("symbol", sym)
   138:                     kwargs.setdefault("limit", limit)
   139:                     if since is not None:
   140:                         kwargs.setdefault("since", since)
   141:                     try:
   142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
   143:                         res = _await_if_needed(fn(**kwargs))
   144:                         rows = self._normalize_rows(res)
   145:                         if rows:
   146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
   147:                             first = rows[0][0]; last = rows[-1][0]
   148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
   149:                                  f"t0={first} {unit}, t1={last} {unit}")
   150:                             return rows
   151:                     except TypeError as e:
   152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
   153:                         last_err = e
   154:                     except Exception as e:
   155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
   156:                         last_err = e
   157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
   158: 
   159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
   160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
   161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
   162:         _log("exchange.fetch_ohlcv() déjà présent.")
   163:         return exchange
   164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
   165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)

--------------------------------------------------------------------------------
FILE: engine/adapters/market_data.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/backtest/market_data.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: from pathlib import Path
     6: from typing import Any
     7: 
     8: import pandas as pd
     9: 
    10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    11: 
    12: def _log(msg: str) -> None:
    13:     if BT_DEBUG:
    14:         print(f"[bt.debug] {msg}", flush=True)
    15: 
    16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
    17:     root = Path(data_dir)
    18:     root.mkdir(parents=True, exist_ok=True)
    19:     tf = timeframe.replace(":", "")
    20:     return root / f"{symbol}-{tf}.csv"
    21: 
    22: def _read_csv(path: Path) -> pd.DataFrame:
    23:     _log(f"lecture CSV: {path}")
    24:     df = pd.read_csv(path)
    25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
    26:     if ts_col is None:
    27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
    28:     df = df.rename(columns={ts_col: "timestamp"})
    29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
    30:     df = df.set_index("timestamp").sort_index()
    31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    32:     return df
    33: 
    34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
    35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
    36:     if "timestamp" not in tmp.columns:
    37:         tmp = tmp.rename(columns={"index": "timestamp"})
    38:     tmp.to_csv(path, index=False)
    39:     _log(f"écrit CSV: {path} (n={len(df)})")
    40: 
    41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
    42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
    43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
    44:     # Normalisation minimaliste (liste de listes)
    45:     rows = []
    46:     for r in raw:
    47:         ts = int(r[0])
    48:         unit = "ms" if ts > 10_000_000_000 else "s"
    49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
    50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
    51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
    52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    53:     return df
    54: 
    55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
    56:     """
    57:     Loader hybride:
    58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
    59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
    60:     """
    61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
    62:         path = _csv_path(data_dir, symbol, timeframe)
    63:         if path.exists():
    64:             df = _read_csv(path)
    65:             src = "csv"
    66:         else:
    67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
    68:             _write_csv(path, df)
    69:             src = "exchange"
    70:         if start:
    71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
    72:         if end:
    73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
    74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
    75:              f"range=[{df.index.min()} .. {df.index.max()}]")
    76:         return df
    77:     return load

--------------------------------------------------------------------------------
FILE: engine/backtest/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/backtest/__init__.py
     2: from .runner import (
     3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
     4:     run_multi, run_single,  # mêmes signatures async
     5:     save_results,           # no-op compat
     6: )
     7: from .cache import (
     8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
     9:     tf_to_seconds,
    10: )

--------------------------------------------------------------------------------
FILE: engine/backtest/cache.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/backtest/cache.py
     2: from __future__ import annotations
     3: 
     4: import csv
     5: import json
     6: import os
     7: import time
     8: from dataclasses import dataclass
     9: from pathlib import Path
    10: from typing import Dict, List, Tuple, Iterable, Optional
    11: 
    12: # ---------------- Timeframe utils ----------------
    13: 
    14: _TF_SECONDS = {
    15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
    17:     "1d": 86400, "3d": 259200, "1w": 604800,
    18: }
    19: 
    20: def tf_to_seconds(tf: str) -> int:
    21:     tf = tf.strip().lower()
    22:     if tf not in _TF_SECONDS:
    23:         raise ValueError(f"Timeframe inconnu: {tf}")
    24:     return _TF_SECONDS[tf]
    25: 
    26: # ---------------- Fraîcheur cible par TF ----------------
    27: 
    28: _DEFAULT_MAX_AGE = {
    29:     # règle empirique (peut être surchargée par ENV)
    30:     "1m": 2 * 3600,        # 2h
    31:     "3m": 4 * 3600,        # 4h
    32:     "5m": 12 * 3600,       # 12h
    33:     "15m": 24 * 3600,      # 24h
    34:     "30m": 36 * 3600,      # 36h
    35:     "1h": 3 * 86400,       # 3 jours
    36:     "2h": 5 * 86400,       # 5 jours
    37:     "4h": 10 * 86400,      # 10 jours
    38:     "6h": 15 * 86400,      # 15 jours
    39:     "12h": 20 * 86400,     # 20 jours
    40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
    41:     "3d": 10 * 86400,
    42:     "1w": 30 * 86400,
    43: }
    44: 
    45: def max_age_for_tf(tf: str) -> int:
    46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
    47:     tf = tf.lower()
    48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
    49:     if env_key in os.environ:
    50:         try:
    51:             return int(os.environ[env_key])
    52:         except Exception:
    53:             pass
    54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
    55: 
    56: # ---------------- CSV I/O ----------------
    57: 
    58: def data_dir() -> Path:
    59:     d = Path(os.getenv("DATA_DIR", "data"))
    60:     d.mkdir(parents=True, exist_ok=True)
    61:     return d
    62: 
    63: def csv_path(symbol: str, tf: str) -> Path:
    64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
    65: 
    66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
    67:     out: List[List[float]] = []
    68:     if not path.exists():
    69:         return out
    70:     with path.open("r", newline="") as f:
    71:         r = csv.reader(f)
    72:         header = next(r, None)
    73:         for row in r:
    74:             # columns: timestamp,open,high,low,close,volume
    75:             try:
    76:                 ts, o, h, l, c, v = row[:6]
    77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
    78:             except Exception:
    79:                 continue
    80:     return out
    81: 
    82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
    83:     new_file = not path.exists()
    84:     with path.open("w", newline="") as f:
    85:         w = csv.writer(f)
    86:         w.writerow(["timestamp","open","high","low","close","volume"])
    87:         for r in rows:
    88:             w.writerow(r)
    89: 
    90: # ---------------- Validation / Chargement / Fetch ----------------
    91: 
    92: @dataclass
    93: class CacheInfo:
    94:     symbol: str
    95:     tf: str
    96:     path: Path
    97:     exists: bool
    98:     fresh: bool
    99:     last_ts: Optional[int] = None
   100:     rows: int = 0
   101: 
   102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
   103:     if not last_ts:
   104:         return False
   105:     age = int(time.time()) - int(last_ts / 1000)
   106:     return age <= max_age_for_tf(tf)
   107: 
   108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
   109:     p = csv_path(symbol, tf)
   110:     if not p.exists():
   111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
   112:     rows = read_csv_ohlcv(p)
   113:     last_ts = rows[-1][0] if rows else None
   114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
   115: 
   116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
   117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
   118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
   119: 
   120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
   121:     info = inspect_csv(symbol, tf)
   122:     if info.exists and info.fresh:
   123:         data = read_csv_ohlcv(info.path)
   124:         return info, data
   125: 
   126:     # fetch & persist
   127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
   128:     if data:
   129:         write_csv_ohlcv(info.path, data)
   130:         info = inspect_csv(symbol, tf)  # refresh stats
   131:     return info, data
   132: 
   133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
   134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
   135:     out: Dict[str, List[List[float]]] = {}
   136:     for s in symbols:
   137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
   138:         out[s] = rows
   139:     return out
   140: 
   141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
   142:     report = []
   143:     for s in symbols:
   144:         info = inspect_csv(s, tf)
   145:         report.append({
   146:             "symbol": s,
   147:             "tf": tf,
   148:             "path": str(info.path),
   149:             "exists": info.exists,
   150:             "fresh": info.fresh,
   151:             "last_ts": info.last_ts,
   152:             "rows": info.rows,
   153:             "max_age": max_age_for_tf(tf),
   154:         })
   155:     out_path.parent.mkdir(parents=True, exist_ok=True)
   156:     out_path.write_text(json.dumps(report, indent=2))

--------------------------------------------------------------------------------
FILE: engine/backtest/cli.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import argparse
     4: from engine.backtest.runner import run_multi, csv_loader_factory
     5: 
     6: def create_parser() -> argparse.ArgumentParser:
     7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
     8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
     9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
    10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
    11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
    12:     p.add_argument("--cash", type=float, default=10_000.0)
    13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
    14:     p.add_argument("--slippage-bps", type=float, default=1.5)
    15:     return p
    16: 
    17: def main(argv: list[str] | None = None) -> int:
    18:     p = create_parser()
    19:     a = p.parse_args(argv)
    20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
    21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
    22:     loader = csv_loader_factory(a.data_dir)
    23:     run_multi(
    24:         symbols=symbols,
    25:         timeframes=tfs,
    26:         loader=loader,
    27:         out_dir=a.out_dir,
    28:         initial_cash=a.cash,
    29:         risk_pct=a.risk,
    30:         slippage_bps=a.slippage_bps,
    31:     )
    32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
    33:     return 0
    34: 
    35: if __name__ == "__main__":
    36:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: engine/backtest/engine.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import math, statistics as stats
     3: from dataclasses import dataclass
     4: from typing import Any, Dict, List, Tuple
     5: import pandas as pd
     6: from engine.core.signals import compute_signals
     7: 
     8: @dataclass
     9: class BTParams:
    10:     ema_fast: int = 20
    11:     ema_slow: int = 50
    12:     atr_period: int = 14
    13:     trail_atr_mult: float = 2.0
    14:     risk_pct_equity: float = 0.02
    15:     cash: float = 10_000.0
    16:     slippage_bps: int = 5
    17: 
    18: def grid_params() -> List[Dict[str, Any]]:
    19:     grid: List[Dict[str, Any]] = []
    20:     for fast in (9, 12, 20):
    21:         for slow in (26, 50, 100):
    22:             if slow <= fast: continue
    23:             for atr_mult in (1.5, 2.0, 2.5):
    24:                 grid.append({"ema_fast": fast, "ema_slow": slow, "trail_atr_mult": atr_mult})
    25:     return grid
    26: 
    27: def run_backtest_once(symbol: str, tf: str, ohlcv: pd.DataFrame, base_cfg_path: str | None = None, params: Dict[str, Any] | None = None):
    28:     p = BTParams(**(params or {}))
    29:     df = compute_signals(ohlcv, {
    30:         "ema_fast": p.ema_fast, "ema_slow": p.ema_slow, "atr_period": p.atr_period
    31:     })
    32:     df = df.dropna().reset_index(drop=True)
    33:     equity = p.cash
    34:     pos_size = 0.0
    35:     entry = 0.0
    36:     trail = None
    37:     trades: List[Dict[str, Any]] = []
    38:     equity_curve: List[float] = [equity]
    39: 
    40:     for i in range(1, len(df)):
    41:         row_prev = df.iloc[i-1]
    42:         row = df.iloc[i]
    43:         price = float(row["close"])
    44:         atr = float(row["atr"])
    45:         slip = price * (p.slippage_bps / 10_000.0)
    46: 
    47:         # entrée / sortie par signaux EMA
    48:         sig = int(row_prev["signal"])  # on agit à la bougie suivante
    49:         if pos_size == 0 and sig == 1:
    50:             # calcule une taille simple basée sur le risque % et ATR
    51:             risk_per_unit = max(atr, price * 0.002)  # garde-fou min
    52:             risk_cash = equity * p.risk_pct_equity
    53:             units = max(1.0, risk_cash / risk_per_unit)
    54:             pos_size = units
    55:             entry = price + slip
    56:             trail = entry - p.trail_atr_mult * atr
    57:         elif pos_size > 0:
    58:             # mise à jour du trailing stop
    59:             new_trail = price - p.trail_atr_mult * atr
    60:             if trail is None or new_trail > trail:
    61:                 trail = new_trail
    62:             # sortie par signal inverse ou cassure du trail
    63:             exit_signal = (sig == -1) or (price < (trail or 0.0))
    64:             if exit_signal:
    65:                 exit_price = price - slip
    66:                 pnl = (exit_price - entry) * pos_size
    67:                 equity += pnl
    68:                 trades.append({"entry": entry, "exit": exit_price, "pnl": pnl})
    69:                 pos_size = 0.0
    70:                 entry = 0.0
    71:                 trail = None
    72: 
    73:         equity_curve.append(equity if equity > 0 else 0.0)
    74: 
    75:     metrics = compute_metrics(equity_curve, trades)
    76:     return {"equity_curve": equity_curve, "trades": trades, "metrics": metrics}
    77: 
    78: def compute_metrics(equity_curve: List[float], trades: List[Dict[str, Any]]) -> Dict[str, float]:
    79:     if not equity_curve:
    80:         return {"net_pnl_pct":0.0,"win_rate":0.0,"max_dd_pct":0.0,"sharpe":0.0,"trades":0,"score":0.0}
    81:     start, end = equity_curve[0], equity_curve[-1]
    82:     net_pnl_pct = (end - start) / start if start else 0.0
    83:     # drawdown
    84:     peak = -1e30; max_dd = 0.0
    85:     for v in equity_curve:
    86:         peak = max(peak, v)
    87:         dd = (peak - v) / peak if peak > 0 else 0.0
    88:         max_dd = max(max_dd, dd)
    89:     # sharpe approx (rendements par pas)
    90:     if len(equity_curve) > 1:
    91:         rets = []
    92:         for i in range(1, len(equity_curve)):
    93:             prev, cur = equity_curve[i-1], equity_curve[i]
    94:             r = (cur - prev) / prev if prev else 0.0
    95:             rets.append(r)
    96:         if rets and (stats.pstdev(rets) or 0) > 0:
    97:             sharpe = (stats.mean(rets) / stats.pstdev(rets)) * math.sqrt(252)
    98:         else:
    99:             sharpe = 0.0
   100:     else:
   101:         sharpe = 0.0
   102:     wins = sum(1 for t in trades if t.get("pnl",0.0) > 0)
   103:     wr = (wins / len(trades)) if trades else 0.0
   104:     score = (sharpe * 2.0) + (net_pnl_pct * 1.0) - (max_dd * 0.5)
   105:     return {"net_pnl_pct": float(net_pnl_pct), "win_rate": float(wr), "max_dd_pct": float(max_dd),
   106:             "sharpe": float(sharpe), "trades": float(len(trades)), "score": float(score)}

--------------------------------------------------------------------------------
FILE: engine/backtest/grid_search.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Grid-search express module to evaluate hyperparameter combinations.
     2: 
     3: This module builds combinations of strategy and engine parameters, runs the
     4: existing multi symbol backtester for each combination, collects key metrics and
     5: selects the best configuration according to:
     6: 
     7: 1. Profit factor (descending)
     8: 2. Maximum drawdown percentage (ascending)
     9: 3. Net PnL in USDT (descending)
    10: 4. Number of trades (ascending)
    11: 
    12: Results are written under ``result/grid`` by default and a short summary is
    13: printed to the console.
    14: """
    15: from __future__ import annotations
    16: 
    17: from dataclasses import dataclass
    18: import csv
    19: import json
    20: import os
    21: import random
    22: from itertools import product
    23: from typing import Any, Callable, Dict, Iterable, List, Sequence
    24: 
    25: # ---------------------------------------------------------------------------
    26: # Utilities
    27: # ---------------------------------------------------------------------------
    28: 
    29: 
    30: def parse_hours(hours: str) -> List[int]:
    31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
    32: 
    33:     Each comma separated element can either be a single hour (``"8"``) or a
    34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
    35:     """
    36: 
    37:     if not hours:
    38:         return []
    39:     result: List[int] = []
    40:     for part in hours.split(","):
    41:         part = part.strip()
    42:         if not part:
    43:             continue
    44:         if "-" in part:
    45:             start_s, end_s = part.split("-", 1)
    46:             start, end = int(start_s), int(end_s)
    47:             result.extend(range(start, end + 1))
    48:         else:
    49:             result.append(int(part))
    50:     return sorted(set(result))
    51: 
    52: 
    53: # Order of parameters used throughout the module and in CSV output
    54: PARAM_KEYS = [
    55:     "timeframe",
    56:     "score_min",
    57:     "atr_min_ratio",
    58:     "rr_min",
    59:     "risk_pct",
    60:     "slippage_bps",
    61:     "fee_rate",
    62:     "cooldown_secs",
    63:     "hours",
    64: ]
    65: 
    66: # Default values used if a parameter is not provided in the grid
    67: DEFAULTS = {
    68:     "score_min": 55,
    69:     "atr_min_ratio": 0.002,
    70:     "rr_min": 1.2,
    71:     "risk_pct": 0.01,
    72:     "slippage_bps": 2,
    73:     "fee_rate": 0.001,
    74:     "cooldown_secs": 300,
    75:     "hours": "7-11,13-17",
    76: }
    77: 
    78: 
    79: @dataclass
    80: class GridResult:
    81:     params: Dict[str, Any]
    82:     metrics: Dict[str, float]
    83: 
    84: 
    85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
    86:     if isinstance(val, (list, tuple, set)):
    87:         return list(val)
    88:     return [val]
    89: 
    90: 
    91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
    92:     """Return a list of parameter combinations.
    93: 
    94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
    95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
    96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
    97:     variety of timeframes and ``atr_min_ratio`` values.
    98:     """
    99: 
   100:     lists: Dict[str, List[Any]] = {}
   101:     for key in PARAM_KEYS:
   102:         if key == "timeframe":
   103:             # timeframe must be explicitly provided; default empty -> "1m"
   104:             vals = param_lists.get(key) or ["1m"]
   105:         else:
   106:             vals = param_lists.get(key)
   107:             if not vals:
   108:                 default = DEFAULTS[key]
   109:                 vals = [default]
   110:         lists[key] = _ensure_list(vals)
   111: 
   112:     combos: List[Dict[str, Any]] = [
   113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
   114:     ]
   115: 
   116:     # Uniform sampling if exceeding grid_max
   117:     if len(combos) > grid_max:
   118:         step = len(combos) / float(grid_max)
   119:         sampled = []
   120:         for i in range(grid_max):
   121:             idx = int(round(i * step))
   122:             if idx >= len(combos):
   123:                 idx = len(combos) - 1
   124:             sampled.append(combos[idx])
   125:         # ensure each timeframe appears at least once
   126:         wanted_tfs = set(lists["timeframe"])
   127:         present_tfs = {c["timeframe"] for c in sampled}
   128:         missing = list(wanted_tfs - present_tfs)
   129:         if missing:
   130:             for tf in missing:
   131:                 for c in combos:
   132:                     if c["timeframe"] == tf and c not in sampled:
   133:                         sampled.append(c)
   134:                         break
   135:             sampled = sampled[:grid_max]
   136:         combos = sampled
   137:     return combos
   138: 
   139: 
   140: # ---------------------------------------------------------------------------
   141: # Core runner
   142: # ---------------------------------------------------------------------------
   143: 
   144: 
   145: def run_grid_search(
   146:     *,
   147:     symbols: Sequence[str],
   148:     exchange: str,
   149:     base_params: Dict[str, Any],
   150:     param_lists: Dict[str, Sequence[Any]],
   151:     grid_max: int = 12,
   152:     csv_dir: str | None = None,
   153:     initial_equity: float = 1000.0,
   154:     leverage: float = 1.0,
   155:     paper_constraints: bool = True,
   156:     seed: int | None = None,
   157:     out_dir: str = "./result/grid",
   158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
   159:     run_func: Callable[..., Any] | None = None,
   160: ) -> List[GridResult]:
   161:     """Execute grid search across parameter combinations.
   162: 
   163:     ``base_params`` provides default single values for parameters. ``param_lists``
   164:     contains the grid specifications from CLI (already parsed into sequences).
   165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
   166:     """
   167: 
   168:     if seed is not None:
   169:         random.seed(seed)
   170: 
   171:     if run_func is None:  # avoid circular import at module load
   172:         from .run_multi import run_backtest_multi  # late import
   173: 
   174:         run_func = run_backtest_multi
   175: 
   176:     # merge lists with defaults
   177:     full_lists: Dict[str, Sequence[Any]] = {}
   178:     for k in PARAM_KEYS:
   179:         if k == "timeframe":
   180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
   181:         else:
   182:             if param_lists.get(k) is not None:
   183:                 full_lists[k] = param_lists[k]
   184:             else:
   185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
   186: 
   187:     combos = build_param_grid(full_lists, grid_max)
   188: 
   189:     results: List[GridResult] = []
   190:     os.makedirs(out_dir, exist_ok=True)
   191: 
   192:     for combo in combos:
   193:         # Build parameters for backtester
   194:         tf = combo["timeframe"]
   195:         fee = float(combo["fee_rate"])
   196:         slip = float(combo["slippage_bps"])
   197:         risk = float(combo["risk_pct"])
   198: 
   199:         summary, _trades = run_func(
   200:             symbols=list(symbols),
   201:             exchange=exchange,
   202:             timeframe=tf,
   203:             csv_dir=csv_dir,
   204:             fee_rate=fee,
   205:             slippage_bps=slip,
   206:             risk_pct=risk,
   207:             initial_equity=initial_equity,
   208:             leverage=leverage,
   209:             paper_constraints=paper_constraints,
   210:             seed=seed,
   211:             out_dir=os.path.join(out_dir, "tmp"),
   212:             plot=False,
   213:             dry_run=True,
   214:         )
   215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
   216:         metrics = {
   217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
   218:             "profit_factor": float(total.get("profit_factor", 0.0)),
   219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
   220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
   221:             "trades": float(total.get("trades", 0.0)),
   222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
   223:         }
   224:         results.append(GridResult(params=combo, metrics=metrics))
   225: 
   226:     # sort results
   227:     results.sort(
   228:         key=lambda r: (
   229:             -r.metrics["profit_factor"],
   230:             r.metrics["max_dd_pct"],
   231:             -r.metrics["pnl_usdt"],
   232:             r.metrics["trades"],
   233:         )
   234:     )
   235: 
   236:     # console output -------------------------------------------------------
   237:     print(
   238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
   239:     )
   240:     header = (
   241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
   242:     )
   243:     print(header)
   244:     for r in results[:10]:
   245:         m = r.metrics
   246:         print(
   247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
   248:         )
   249: 
   250:     # write csv ------------------------------------------------------------
   251:     csv_cols = PARAM_KEYS + [
   252:         "pnl_usdt",
   253:         "profit_factor",
   254:         "max_dd_pct",
   255:         "winrate_pct",
   256:         "trades",
   257:         "final_equity",
   258:     ]
   259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
   260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
   261:         writer.writeheader()
   262:         for r in results:
   263:             row = {**r.params, **r.metrics}
   264:             writer.writerow(row)
   265: 
   266:     best = results[0]
   267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
   268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
   269: 
   270:     # markdown summary -----------------------------------------------------
   271:     md_path = os.path.join(out_dir, "grid_summary.md")
   272:     with open(md_path, "w", encoding="utf8") as fh:
   273:         fh.write(
   274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
   275:         )
   276:         for r in results[:10]:
   277:             m = r.metrics
   278:             fh.write(
   279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
   280:             )
   281: 
   282:     # optional scatter plot ------------------------------------------------
   283:     try:  # pragma: no cover - optional dependency
   284:         import matplotlib.pyplot as plt
   285: 
   286:         pf = [r.metrics["profit_factor"] for r in results]
   287:         dd = [r.metrics["max_dd_pct"] for r in results]
   288:         trades = [r.metrics["trades"] for r in results]
   289:         tfs = [r.params["timeframe"] for r in results]
   290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
   291:         c = [colors[tf] for tf in tfs]
   292:         plt.figure(figsize=(6, 4))
   293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
   294:         plt.xlabel("MaxDD%")
   295:         plt.ylabel("Profit Factor")
   296:         plt.title("PF vs MaxDD")
   297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
   298:         plt.close()
   299:     except Exception:  # pragma: no cover
   300:         pass
   301: 
   302:     return results
   303: 
   304: 
   305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]

--------------------------------------------------------------------------------
FILE: engine/backtest/loader_csv.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import pandas as pd
     3: from pathlib import Path
     4: from typing import List
     5: 
     6: def load_csv_ohlcv(path: Path) -> pd.DataFrame:
     7:     df = pd.read_csv(path)
     8:     # attendu: ts,open,high,low,close,volume
     9:     return df.sort_values("ts").reset_index(drop=True)
    10: 
    11: def write_csv_ohlcv(out_dir: Path, symbol: str, tf: str, rows: List[List[float]]) -> None:
    12:     out_dir.mkdir(parents=True, exist_ok=True)
    13:     safe = symbol.replace("/","").replace("_","")
    14:     p = out_dir / f"{safe}-{tf}.csv"
    15:     with p.open("w", encoding="utf-8") as f:
    16:         f.write("ts,open,high,low,close,volume\n")
    17:         for r in rows:
    18:             if len(r) < 6: continue
    19:             f.write(f"{int(r[0])},{r[1]},{r[2]},{r[3]},{r[4]},{r[5]}\n")

--------------------------------------------------------------------------------
FILE: engine/backtest/market_data.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import time
     6: from pathlib import Path
     7: from typing import Any, Iterable, Optional, Sequence, Tuple
     8: from urllib.request import Request, urlopen
     9: from urllib.error import URLError, HTTPError
    10: 
    11: import pandas as pd
    12: 
    13: # ============================================================================
    14: # Logs & utilitaires
    15: # ============================================================================
    16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    17: def _log(msg: str) -> None:
    18:     if BT_DEBUG:
    19:         print(f"[bt.debug] {msg}", flush=True)
    20: 
    21: def _now_ms() -> int:
    22:     return int(time.time() * 1000)
    23: 
    24: def _tf_to_seconds(tf: str) -> int:
    25:     tf = tf.lower().strip()
    26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
    27:     if tf not in table:
    28:         raise ValueError(f"Timeframe non supporté: {tf}")
    29:     return table[tf]
    30: 
    31: def _parse_duration(s: str) -> int:
    32:     """
    33:     '90s','15m','2h','3d' -> secondes
    34:     """
    35:     s = s.strip().lower()
    36:     if s.endswith("s"): return int(float(s[:-1]))
    37:     if s.endswith("m"): return int(float(s[:-1])*60)
    38:     if s.endswith("h"): return int(float(s[:-1])*3600)
    39:     if s.endswith("d"): return int(float(s[:-1])*86400)
    40:     return int(float(s))  # secondes
    41: 
    42: # ============================================================================
    43: # Politique de fraîcheur (par défaut + overrides via ENV)
    44: # ============================================================================
    45: def _default_max_age_seconds(tf: str) -> int:
    46:     """
    47:     Règles par défaut (conservatrices) :
    48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
    49:       - 30m     : 1h
    50:       - 1h      : 6h
    51:       - 4h      : 24h
    52:       - 1d      : 3d
    53:     """
    54:     tf = tf.lower()
    55:     if tf in ("1m","3m","5m","15m"):
    56:         return 2 * _tf_to_seconds(tf)
    57:     if tf == "30m":
    58:         return 3600
    59:     if tf == "1h":
    60:         return 6*3600
    61:     if tf == "4h":
    62:         return 24*3600
    63:     if tf == "1d":
    64:         return 3*86400
    65:     raise ValueError(tf)
    66: 
    67: def _max_age_seconds(tf: str) -> int:
    68:     """
    69:     Overrides possibles (au choix) :
    70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
    71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
    72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
    73:     """
    74:     tfk = tf.lower().replace(":", "")
    75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
    76:     if env_spec:
    77:         return _parse_duration(env_spec)
    78:     mult = os.getenv("CSV_MAX_AGE_MULT")
    79:     if mult:
    80:         return int(float(mult) * _tf_to_seconds(tf))
    81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
    82:     if g:
    83:         return _parse_duration(g)
    84:     return _default_max_age_seconds(tf)
    85: 
    86: # ============================================================================
    87: # CSV helpers + validation
    88: # ============================================================================
    89: def _data_dir(default: str = "data") -> Path:
    90:     root = Path(os.getenv("DATA_DIR", default))
    91:     root.mkdir(parents=True, exist_ok=True)
    92:     return root
    93: 
    94: def _csv_path(symbol: str, timeframe: str) -> Path:
    95:     tf = timeframe.replace(":", "")
    96:     return _data_dir() / f"{symbol}-{tf}.csv"
    97: 
    98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
    99:     rows = list(rows)
   100:     if not rows:
   101:         raise ValueError("OHLCV vide")
   102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
   103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
   104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
   105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
   106: 
   107: def _read_csv(path: Path) -> pd.DataFrame:
   108:     df = pd.read_csv(path)
   109:     # tolère quelques variations de colonnes
   110:     cols = {c.lower(): c for c in df.columns}
   111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
   112:     if not ts_col:
   113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
   114:     rename = {ts_col: "timestamp"}
   115:     for c in ("open","high","low","close","volume"):
   116:         if c not in cols:
   117:             raise ValueError(f"Colonne manquante: {c}")
   118:         rename[cols[c]] = c
   119:     df = df.rename(columns=rename)
   120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
   122:     df = df.drop_duplicates("timestamp")
   123:     df = df.set_index("timestamp")
   124:     return df
   125: 
   126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
   127:     out = df.reset_index().rename(columns={"index": "timestamp"})
   128:     out.to_csv(path, index=False)
   129: 
   130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
   131:     """
   132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
   133:       - schéma valide
   134:       - assez de lignes
   135:       - fraîcheur < seuil selon TF
   136:     """
   137:     if not path.exists():
   138:         return False, "absent"
   139:     try:
   140:         df = _read_csv(path)
   141:     except Exception as e:
   142:         return False, f"invalid({e})"
   143:     if len(df) < min_rows:
   144:         return False, f"too_few_rows({len(df)}<{min_rows})"
   145:     # Fraîcheur
   146:     last_ts = int(df.index.max().timestamp())
   147:     age_s = int(time.time()) - last_ts
   148:     max_age = _max_age_seconds(timeframe)
   149:     if age_s > max_age:
   150:         return False, f"stale({age_s}s>{max_age}s)"
   151:     # Monotonicité (échantillon)
   152:     if not df.index.is_monotonic_increasing:
   153:         return False, "not_monotonic"
   154:     return True, "ok"
   155: 
   156: # ============================================================================
   157: # Fallback réseau (CCXT d'abord, HTTP sinon)
   158: # ============================================================================
   159: def _ensure_ccxt() -> Any | None:
   160:     try:
   161:         import ccxt  # type: ignore
   162:         return ccxt
   163:     except Exception:
   164:         return None
   165: 
   166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   167:     ccxt = _ensure_ccxt()
   168:     if not ccxt:
   169:         _log("ccxt indisponible")
   170:         return None
   171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
   172:     ex.load_markets()
   173:     base = symbol.upper()
   174:     if not base.endswith("USDT"):
   175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
   176:     coin = base[:-4]
   177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
   178:     for ccxt_sym in candidates:
   179:         try:
   180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
   181:             if rows:
   182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
   183:         except Exception as e:
   184:             _log(f"ccxt fail {ccxt_sym}: {e}")
   185:             continue
   186:     return None
   187: 
   188: # === (facultatif) HTTP Bitget v1 minimal ===
   189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
   190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
   191: 
   192: def _http_get(url: str, timeout: int = 20) -> dict | list:
   193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
   194:     with urlopen(req, timeout=timeout) as resp:
   195:         return json.loads(resp.read().decode("utf-8"))
   196: 
   197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
   198:     rows = payload.get("data") if isinstance(payload, dict) else payload
   199:     if not isinstance(rows, list):
   200:         raise ValueError(f"Réponse inattendue: {payload}")
   201:     out = []
   202:     for r in rows:
   203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
   204:         out.append([ts,o,h,l,c,v])
   205:     out.sort(key=lambda x:x[0])
   206:     return out
   207: 
   208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   209:     tf = timeframe.lower()
   210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
   211:     if not (g and p):
   212:         return None
   213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
   214:     trials = [
   215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
   216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
   217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
   218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
   219:     ]
   220:     for url in trials:
   221:         try:
   222:             payload = _http_get(url)
   223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
   224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
   225:             rows = _normalize_http_rows(payload)
   226:             if rows:
   227:                 return _rows_to_df(rows)
   228:         except Exception as e:
   229:             _log(f"HTTP fail: {url} -> {e}")
   230:             continue
   231:     return None
   232: 
   233: # ============================================================================
   234: # API publique utilisée par l’orchestrateur/backtest
   235: # ============================================================================
   236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
   237:     """
   238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
   239:     """
   240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
   241:     if df is not None:
   242:         _log(f"source=ccxt  n={len(df)}")
   243:         return df
   244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
   245:     if df is not None:
   246:         _log(f"source=http  n={len(df)}")
   247:         return df
   248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
   249: 
   250: def hybrid_loader(
   251:     data_dir: str = "data",
   252:     *,
   253:     use_cache_first: bool = True,
   254:     min_rows: int = 100,
   255:     refill_if_stale: bool = True,
   256:     network_limit: int = 1000,
   257: ):
   258:     """
   259:     Loader smart :
   260:       1) si CSV présent ET frais/valide → le renvoie
   261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
   262:       3) sinon → lève
   263:     """
   264:     os.environ.setdefault("DATA_DIR", data_dir)
   265: 
   266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
   267:         path = _csv_path(symbol, timeframe)
   268: 
   269:         if use_cache_first:
   270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
   271:             if ok:
   272:                 _log(f"CSV OK: {path}")
   273:                 df = _read_csv(path)
   274:             else:
   275:                 _log(f"CSV non utilisable ({why}): {path}")
   276:                 if not refill_if_stale:
   277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
   278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   279:                 _write_csv(path, df)
   280:         else:
   281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   282:             _write_csv(path, df)
   283: 
   284:         # Fenêtrage temporel si demandé (timestamps UTC)
   285:         if start:
   286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
   287:         if end:
   288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
   289:         return df
   290: 
   291:     return load

--------------------------------------------------------------------------------
FILE: engine/backtest/metrics.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import math
     3: from dataclasses import dataclass
     4: from typing import List, Dict
     5: 
     6: @dataclass
     7: class Trade:
     8:     ts: int
     9:     side: str
    10:     entry: float
    11:     exit: float
    12:     pnl_abs: float
    13:     pnl_pct: float
    14:     dur_min: float
    15: 
    16: def equity_to_drawdown(equity: List[float]) -> float:
    17:     peak = -1e18; maxdd = 0.0
    18:     for v in equity:
    19:         if v > peak: peak = v
    20:         dd = 0.0 if peak == 0 else (peak - v) / peak
    21:         if dd > maxdd: maxdd = dd
    22:     return maxdd
    23: 
    24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
    25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
    26:     if not returns: return 0.0
    27:     mean = sum(returns)/len(returns)
    28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
    29:     std = math.sqrt(var) if var>0 else 0.0
    30:     if std == 0: return 0.0
    31:     return (mean - rf) / std * math.sqrt(period_per_year)
    32: 
    33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
    34:     wins = [t for t in trades if t.pnl_abs > 0]
    35:     losses = [t for t in trades if t.pnl_abs < 0]
    36:     wr = len(wins)/len(trades) if trades else 0.0
    37:     gross_win = sum(t.pnl_abs for t in wins)
    38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
    39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
    40:     mdd = equity_to_drawdown(equity)
    41:     shp = sharpe(bar_returns)
    42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
    43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
    44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
    45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
    46:     return {
    47:         "trades": len(trades),
    48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
    49:         "expectancy": expectancy, "cagr": cagr, "score": score,
    50:         "equity_start": equity[0] if equity else None,
    51:         "equity_end": equity[-1] if equity else None,
    52:     }

--------------------------------------------------------------------------------
FILE: engine/backtest/optimize.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: """Parameter sweep utilities for strategy optimisation.
     4: 
     5: This module performs a grid search over a parameter space in parallel.  It
     6: tries to use :mod:`ray` for distributed execution when available and falls
     7: back to :mod:`multiprocessing` otherwise.
     8: """
     9: 
    10: import itertools
    11: import json
    12: import multiprocessing as mp
    13: import os
    14: from typing import Any, Dict, Iterable, List, Sequence
    15: 
    16: try:  # Optional dependency
    17:     import ray  # type: ignore
    18: except Exception:  # pragma: no cover - ray is optional
    19:     ray = None
    20: 
    21: from engine.backtest import backtest_trades
    22: 
    23: 
    24: # ---------------------------------------------------------------------------
    25: # Parameter space
    26: # ---------------------------------------------------------------------------
    27: 
    28: def param_space_default() -> Dict[str, Sequence[Any]]:
    29:     """Return the default parameter search space.
    30: 
    31:     The keys correspond to strategy parameters while the values are iterables
    32:     of possible settings.  The defaults represent a small but representative
    33:     grid and can be overridden by callers.
    34:     """
    35: 
    36:     return {
    37:         "ema_fast": [10, 20, 30],
    38:         "ema_slow": [50, 100, 200],
    39:         "rsi_period": [14, 21],
    40:         "atr_period": [14, 21],
    41:     }
    42: 
    43: 
    44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    45:     """Expand *space* into a list of parameter combinations."""
    46: 
    47:     keys = list(space)
    48:     values = [space[k] for k in keys]
    49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
    50: 
    51: 
    52: # ---------------------------------------------------------------------------
    53: # Evaluation
    54: # ---------------------------------------------------------------------------
    55: 
    56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    57:     """Run a backtest for a single parameter combination.
    58: 
    59:     ``grid_item`` contains the parameter values along with optional ``trades``
    60:     to evaluate.  The function returns a copy of the parameters augmented with
    61:     the computed PnL under the key ``pnl``.
    62:     """
    63: 
    64:     params = dict(grid_item)
    65:     trades = params.pop("trades", [])
    66:     fee_rate = params.pop("fee_rate", None)
    67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
    68:     params["pnl"] = pnl
    69:     return params
    70: 
    71: 
    72: # ---------------------------------------------------------------------------
    73: # Orchestration
    74: # ---------------------------------------------------------------------------
    75: 
    76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    77:     """Evaluate the full parameter grid in parallel and return results."""
    78: 
    79:     space = space or param_space_default()
    80:     grid = _param_grid(space)
    81: 
    82:     # Determine execution backend
    83:     use_ray = False
    84:     if ray is not None:
    85:         try:  # pragma: no cover - depends on ray
    86:             ray.init(ignore_reinit_error=True)
    87:             use_ray = True
    88:         except Exception:
    89:             use_ray = False
    90: 
    91:     if use_ray:
    92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
    93:         futures = [remote_eval.remote(g) for g in grid]
    94:         results = ray.get(futures)
    95:     else:
    96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
    97:         with mp.Pool(processes=jobs) as pool:
    98:             results = pool.map(eval_params_one, grid)
    99: 
   100:     return results
   101: 
   102: 
   103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
   104:     """High level helper executing the sweep and saving aggregated results."""
   105: 
   106:     results = run_param_sweep(space, jobs=jobs)
   107:     with open(outfile, "w", encoding="utf8") as fh:
   108:         json.dump(results, fh, indent=2, sort_keys=True)
   109:     return results
   110: 
   111: 
   112: def main() -> None:  # pragma: no cover - convenience CLI
   113:     optimize()
   114: 
   115: 
   116: if __name__ == "__main__":  # pragma: no cover
   117:     main()

--------------------------------------------------------------------------------
FILE: engine/backtest/position_sizing.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/backtest/position_sizing.py
     2: from __future__ import annotations
     3: from engine.core.signal import Signal
     4: 
     5: def position_size_from_signal(equity: float, sig: Signal, risk_pct: float) -> float:
     6:     """
     7:     Taille = (equity * risk_pct) / |entry - sl|
     8:     Retourne la QUANTITÉ (unités de la crypto).
     9:     """
    10:     risk = max(1e-12, abs(sig.entry - sig.sl))
    11:     cash_at_risk = max(0.0, equity) * max(0.0, risk_pct)
    12:     return max(0.0, cash_at_risk / risk)
    13: 
    14: def fees_cost(notional: float, bps: float) -> float:
    15:     return abs(notional) * (bps / 10000.0)

--------------------------------------------------------------------------------
FILE: engine/backtest/run_multi.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # annulé

--------------------------------------------------------------------------------
FILE: engine/backtest/runner.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/backtest/runner.py
     2: from __future__ import annotations
     3: import argparse
     4: import os
     5: from typing import Dict, List
     6: from engine.strategy.factory import load_strategies_cfg
     7: from engine.backtest.engine import BacktestEngine
     8: 
     9: def run_once(
    10:     symbol: str,
    11:     timeframe: str,
    12:     csv_path: str,
    13:     strategies_cfg_path: str = "scalper/config/strategies.yml",
    14:     csv_1h_path: str = "",
    15:     equity: float = 1000.0,
    16:     risk: float = 0.01,
    17:     fees_bps: float = 6.0,
    18: ) -> Dict[str, float]:
    19:     cfg = load_strategies_cfg(strategies_cfg_path)
    20:     data = BacktestEngine.load_csv(csv_path)
    21:     data_1h = BacktestEngine.load_csv(csv_1h_path) if csv_1h_path and os.path.isfile(csv_1h_path) else None
    22: 
    23:     eng = BacktestEngine(
    24:         symbol=symbol, timeframe=timeframe, data=data, data_1h=data_1h,
    25:         equity_start=equity, risk_pct=risk, fees_bps=fees_bps, strategies_cfg=cfg,
    26:     )
    27:     eng.run()
    28:     eng.save_results()
    29:     return eng.summary()
    30: 
    31: def main():
    32:     ap = argparse.ArgumentParser(description="Runner Backtest (point d'entrée unique)")
    33:     ap.add_argument("--symbol", required=True, help="ex: BTCUSDT")
    34:     ap.add_argument("--tf", required=True, help="ex: 5m, 1h")
    35:     ap.add_argument("--csv", required=True, help="CSV OHLCV principal (timestamp,open,high,low,close,volume)")
    36:     ap.add_argument("--csv_1h", default="", help="CSV 1h (optionnel) pour filtre MTF")
    37:     ap.add_argument("--cfg", default="scalper/config/strategies.yml", help="config stratégies (YAML/JSON)")
    38:     ap.add_argument("--equity", type=float, default=1000.0)
    39:     ap.add_argument("--risk", type=float, default=0.01)
    40:     ap.add_argument("--fees_bps", type=float, default=6.0)
    41:     args = ap.parse_args()
    42: 
    43:     summary = run_once(
    44:         symbol=args.symbol, timeframe=args.tf, csv_path=args.csv,
    45:         strategies_cfg_path=args.cfg, csv_1h_path=args.csv_1h,
    46:         equity=args.equity, risk=args.risk, fees_bps=args.fees_bps,
    47:     )
    48:     print("== Résumé ==")
    49:     print(summary)
    50: 
    51: if __name__ == "__main__":
    52:     main()

--------------------------------------------------------------------------------
FILE: engine/backtest/walkforward.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from itertools import product
     4: from statistics import mean, stdev
     5: from typing import Dict, Iterable, Optional
     6: 
     7: from ..strategy import max_drawdown
     8: 
     9: 
    10: def _sharpe(returns: Iterable[float]) -> float:
    11:     vals = list(returns)
    12:     if not vals:
    13:         return 0.0
    14:     mu = mean(vals)
    15:     if len(vals) > 1:
    16:         sd = stdev(vals)
    17:     else:
    18:         sd = 0.0
    19:     return mu / sd if sd > 0 else 0.0
    20: 
    21: 
    22: def _stability(equity: Iterable[float]) -> float:
    23:     curve = list(equity)
    24:     n = len(curve)
    25:     if n < 2:
    26:         return 0.0
    27:     x = list(range(n))
    28:     x_mean = sum(x) / n
    29:     y_mean = sum(curve) / n
    30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
    31:     denom = sum((xi - x_mean) ** 2 for xi in x)
    32:     if denom == 0 or ss_tot == 0:
    33:         return 0.0
    34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    35:     a = y_mean - b * x_mean
    36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    37:     return 1 - ss_res / ss_tot
    38: 
    39: 
    40: def walk_forward(
    41:     df,
    42:     splits: int = 5,
    43:     train_ratio: float = 0.7,
    44:     params: Optional[Dict[str, Iterable]] = None,
    45: ) -> Dict[str, float]:
    46:     """Perform walk-forward optimisation and evaluation.
    47: 
    48:     Parameters
    49:     ----------
    50:     df:
    51:         DataFrame containing per-period percentage returns. The first column is
    52:         used when a dedicated ``"returns"`` column is not found.
    53:     splits:
    54:         Number of walk-forward test windows.
    55:     train_ratio:
    56:         Proportion of the data used for training in the initial window.
    57:     params:
    58:         Optional parameter grid. If provided, columns in ``df`` matching each
    59:         parameter combination are evaluated and the best Sharpe ratio on the
    60:         training window is selected. When ``None``, the first column is used.
    61:     """
    62: 
    63:     if df.empty:
    64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
    65: 
    66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
    67:     data = df.copy()
    68: 
    69:     n = len(data)
    70:     train_len = max(1, int(n * train_ratio))
    71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
    72: 
    73:     sharpe_list = []
    74:     mdd_list = []
    75:     pnl_list = []
    76:     stability_list = []
    77: 
    78:     from . import walk_forward_windows
    79: 
    80:     indices = list(range(n))
    81: 
    82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
    83:         train_df = data.iloc[tr_idx]
    84:         test_df = data.iloc[te_idx]
    85: 
    86:         # Parameter optimisation based on Sharpe ratio
    87:         if params:
    88:             best_col = None
    89:             best_score = float("-inf")
    90:             keys, values = zip(*params.items()) if params else ([], [])
    91:             for combo in product(*values):
    92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
    93:                 if col_name not in data.columns:
    94:                     continue
    95:                 score = _sharpe(train_df[col_name])
    96:                 if score > best_score:
    97:                     best_score = score
    98:                     best_col = col_name
    99:             series = test_df[best_col] if best_col else test_df[returns_col]
   100:         else:
   101:             series = test_df[returns_col]
   102: 
   103:         sharpe_list.append(_sharpe(series))
   104:         equity = (1 + series / 100.0).cumprod()
   105:         mdd_list.append(max_drawdown(equity))
   106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
   107:         stability_list.append(_stability(equity))
   108: 
   109:     count = len(sharpe_list) or 1
   110:     mean_sharpe = sum(sharpe_list) / count
   111:     mean_mdd = sum(mdd_list) / count
   112:     mean_pnl = sum(pnl_list) / count
   113:     mean_stability = sum(stability_list) / count
   114: 
   115:     return {
   116:         "sharpe": mean_sharpe,
   117:         "mdd": mean_mdd,
   118:         "pnl": mean_pnl,
   119:         "stability": mean_stability,
   120:     }

--------------------------------------------------------------------------------
FILE: engine/bitget_client.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: import json
     2: import logging
     3: import time
     4: import hmac
     5: import hashlib
     6: import base64
     7: import uuid
     8: from typing import Any, Dict, List, Optional
     9: 
    10: import requests
    11: 
    12: 
    13: # Mapping of deprecated v1 product type identifiers to the new v2 names
    14: _PRODUCT_TYPE_ALIASES = {
    15:     "UMCBL": "USDT-FUTURES",
    16:     "DMCBL": "USDC-FUTURES",
    17:     "CMCBL": "COIN-FUTURES",
    18: }
    19: 
    20: # Granularity aliases from v1 to v2 nomenclature
    21: _GRANULARITY_ALIASES = {
    22:     "MIN1": "1m",
    23:     "MIN3": "3m",
    24:     "MIN5": "5m",
    25:     "MIN15": "15m",
    26:     "MIN30": "30m",
    27:     "HOUR1": "1H",
    28:     "HOUR4": "4H",
    29:     "HOUR12": "12H",
    30:     "DAY1": "1D",
    31:     "WEEK1": "1W",
    32: }
    33: 
    34: 
    35: # Default margin coin for each product type. Some authenticated endpoints
    36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
    37: # default avoids ``400 Bad Request`` responses when the caller does not provide
    38: # it explicitly.
    39: _DEFAULT_MARGIN_COIN = {
    40:     "USDT-FUTURES": "USDT",
    41:     "USDC-FUTURES": "USDC",
    42: }
    43: 
    44: 
    45: class BitgetFuturesClient:
    46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
    47: 
    48:     def __init__(
    49:         self,
    50:         access_key: str,
    51:         secret_key: str,
    52:         base_url: str,
    53:         *,
    54:         product_type: str = "USDT-FUTURES",
    55:         recv_window: int = 30,
    56:         paper_trade: bool = True,
    57:         requests_module: Any = requests,
    58:         log_event: Optional[Any] = None,
    59:         passphrase: Optional[str] = None,
    60:     ) -> None:
    61:         self.ak = access_key
    62:         self.sk = secret_key
    63:         self.base = base_url.rstrip("/")
    64:         pt = product_type.upper()
    65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
    66:         self.recv_window = recv_window
    67:         self.paper_trade = paper_trade
    68:         self.requests = requests_module
    69:         self.log_event = log_event or (lambda *a, **k: None)
    70:         self.passphrase = passphrase
    71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
    72:             logging.warning(
    73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
    74:             )
    75:         # Cache for contract precision details to avoid repeated network calls
    76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
    77: 
    78:     # ------------------------------------------------------------------
    79:     # Helpers
    80:     # ------------------------------------------------------------------
    81:     @staticmethod
    82:     def _ms() -> int:
    83:         return int(time.time() * 1000)
    84: 
    85:     @staticmethod
    86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
    87:         if not params:
    88:             return ""
    89:         items = []
    90:         for k in sorted(params.keys()):
    91:             v = "" if params[k] is None else str(params[k])
    92:             items.append(f"{k}={v}")
    93:         return "&".join(items)
    94: 
    95:     def _sign(self, prehash: str) -> str:
    96:         """Return a base64-encoded HMAC SHA256 signature."""
    97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
    98:         return base64.b64encode(digest).decode()
    99: 
   100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
   101:         headers = {
   102:             "ACCESS-KEY": self.ak,
   103:             "ACCESS-SIGN": signature,
   104:             "ACCESS-TIMESTAMP": str(timestamp),
   105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
   106:             "Content-Type": "application/json",
   107:         }
   108:         if self.passphrase:
   109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
   110:         return headers
   111: 
   112:     def _format_symbol(self, symbol: str) -> str:
   113:         """Return ``symbol`` formatted for Bitget API.
   114: 
   115:         The v2 endpoints expect the trading pair without any product type
   116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
   117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
   118:         separators and any trailing product type string (legacy or v2).
   119:         """
   120: 
   121:         if not symbol:
   122:             return symbol
   123: 
   124:         sym = symbol.replace("_", "").upper()
   125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
   126:         if sym.endswith(self.product_type):
   127:             sym = sym[: -len(self.product_type)]
   128:         else:
   129:             for old in _PRODUCT_TYPE_ALIASES.keys():
   130:                 if sym.endswith(old):
   131:                     sym = sym[: -len(old)]
   132:                     break
   133:         return sym
   134: 
   135:     def _product_type(self, pt: Optional[str] = None) -> str:
   136:         """Normalise ``pt`` to a valid v2 product type identifier."""
   137:         key = (pt or self.product_type or "").upper()
   138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
   139: 
   140:     # ------------------------------------------------------------------
   141:     # Public endpoints
   142:     # ------------------------------------------------------------------
   143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   144:         """Return futures contract information.
   145: 
   146:         The previous implementation queried ``/contract-detail`` which does not
   147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
   148:         endpoint is ``/contracts`` with the symbol supplied as a query
   149:         parameter."""
   150: 
   151:         url = f"{self.base}/api/v2/mix/market/contracts"
   152:         params: Dict[str, Any] = {"productType": self.product_type}
   153:         if symbol:
   154:             params["symbol"] = self._format_symbol(symbol)
   155:         r = self.requests.get(url, params=params, timeout=15)
   156:         if r.status_code == 404:  # pragma: no cover - depends on network
   157:             logging.error("Contract detail introuvable pour %s", symbol)
   158:             return {"success": False, "code": 404, "data": None}
   159:         r.raise_for_status()
   160:         return r.json()
   161: 
   162:     # ------------------------------------------------------------------
   163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
   164:         """Return price and volume precision for ``symbol``.
   165: 
   166:         Results are cached to minimise HTTP requests. If the contract
   167:         information cannot be retrieved, ``(0, 0)`` is returned.
   168:         """
   169:         sym = self._format_symbol(symbol)
   170:         info = self._contract_cache.get(sym)
   171:         if info is None:
   172:             detail = self.get_contract_detail(sym)
   173:             try:
   174:                 data = detail.get("data", [])
   175:                 if isinstance(data, list) and data:
   176:                     info = data[0]
   177:                 else:
   178:                     info = {}
   179:             except Exception:
   180:                 info = {}
   181:             self._contract_cache[sym] = info
   182:         price_place = int(info.get("pricePlace") or 0)
   183:         volume_place = int(info.get("volumePlace") or 0)
   184:         return price_place, volume_place
   185: 
   186:     def get_kline(
   187:         self,
   188:         symbol: str,
   189:         interval: str = "1m",
   190:         start: Optional[int] = None,
   191:         end: Optional[int] = None,
   192:     ) -> Dict[str, Any]:
   193:         # Endpoint expects the trading pair in query parameters rather than
   194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
   195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
   196:         url = f"{self.base}/api/v2/mix/market/candles"
   197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
   198:         params: Dict[str, Any] = {
   199:             "symbol": self._format_symbol(symbol),
   200:             "productType": self.product_type,
   201:             "granularity": interval_norm,
   202:         }
   203:         if start is not None:
   204:             params["startTime"] = int(start)
   205:         if end is not None:
   206:             params["endTime"] = int(end)
   207:         r = self.requests.get(url, params=params, timeout=15)
   208:         r.raise_for_status()
   209:         data = r.json()
   210: 
   211:         rows = data.get("data") if isinstance(data, dict) else None
   212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
   213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   214:             for row in rows:
   215:                 if len(row) < 7:
   216:                     continue
   217:                 try:
   218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
   219:                     cols["ts"].append(int(ts))
   220:                     cols["open"].append(float(op))
   221:                     cols["high"].append(float(hi))
   222:                     cols["low"].append(float(lo))
   223:                     cols["close"].append(float(cl))
   224:                     cols["volume"].append(float(vol))
   225:                     cols["quoteVolume"].append(float(qv))
   226:                 except (TypeError, ValueError):
   227:                     continue
   228:             data["data"] = cols
   229:         elif isinstance(rows, list):
   230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   231:         return data
   232: 
   233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   234:         if symbol:
   235:             url = f"{self.base}/api/v2/mix/market/ticker"
   236:             params = {
   237:                 "symbol": self._format_symbol(symbol),
   238:                 "productType": self.product_type,
   239:             }
   240:         else:
   241:             url = f"{self.base}/api/v2/mix/market/tickers"
   242:             params = {"productType": self.product_type}
   243:         r = self.requests.get(url, params=params, timeout=15)
   244:         r.raise_for_status()
   245:         return r.json()
   246: 
   247:     # ------------------------------------------------------------------
   248:     # Private endpoints
   249:     # ------------------------------------------------------------------
   250:     def _private_request(
   251:         self,
   252:         method: str,
   253:         path: str,
   254:         *,
   255:         params: Optional[Dict[str, Any]] = None,
   256:         body: Optional[Dict[str, Any]] = None,
   257:     ) -> Dict[str, Any]:
   258:         method = method.upper()
   259:         ts = self._ms()
   260: 
   261:         if method in ("GET", "DELETE"):
   262:             qs = self._urlencode_sorted(params or {})
   263:             req_path = path + (f"?{qs}" if qs else "")
   264:             sig = self._sign(f"{ts}{method}{req_path}")
   265:             headers = self._headers(sig, ts)
   266:             url = f"{self.base}{req_path}"
   267:             r = self.requests.request(method, url, headers=headers, timeout=20)
   268:         elif method == "POST":
   269:             qs = self._urlencode_sorted(params or {})
   270:             req_path = path + (f"?{qs}" if qs else "")
   271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
   272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
   273:             headers = self._headers(sig, ts)
   274:             url = f"{self.base}{req_path}"
   275:             r = self.requests.post(
   276:                 url,
   277:                 data=body_str.encode("utf-8"),
   278:                 headers=headers,
   279:                 timeout=20,
   280:             )
   281:         else:
   282:             raise ValueError("M\u00e9thode non support\u00e9e")
   283: 
   284:         resp_text = getattr(r, "text", "")
   285:         try:
   286:             data = r.json()
   287:         except Exception:
   288:             data = {
   289:                 "success": False,
   290:                 "error": resp_text,
   291:                 "status_code": getattr(r, "status_code", None),
   292:             }
   293: 
   294:         status = getattr(r, "status_code", 0)
   295:         if status >= 400:
   296:             code = str(data.get("code")) if isinstance(data, dict) else ""
   297:             if code == "22001":
   298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
   299:             else:
   300:                 try:
   301:                     r.raise_for_status()
   302:                 except Exception as e:
   303:                     if not resp_text:
   304:                         resp_text = getattr(r, "text", "") or str(e)
   305:                 logging.error(
   306:                     "Erreur HTTP/JSON %s %s -> %s %s",
   307:                     method,
   308:                     path,
   309:                     status,
   310:                     resp_text,
   311:                 )
   312:                 if isinstance(data, dict):
   313:                     data.setdefault("success", False)
   314:                     data.setdefault("status_code", status)
   315:                     data.setdefault("error", resp_text)
   316: 
   317:         self.log_event(
   318:             "http_private",
   319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
   320:         )
   321:         return data
   322: 
   323:     # Accounts & positions -------------------------------------------------
   324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
   325:         if self.paper_trade:
   326:             return {
   327:                 "success": True,
   328:                 "code": 0,
   329:                 "data": [
   330:                     {
   331:                         "currency": "USDT",
   332:                         "equity": 100.0,
   333:                     }
   334:                 ],
   335:             }
   336: 
   337:         params = {"productType": self.product_type}
   338:         if margin_coin is None:
   339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   340:         if margin_coin:
   341:             params["marginCoin"] = margin_coin
   342:         data = self._private_request(
   343:             "GET", "/api/v2/mix/account/accounts", params=params
   344:         )
   345:         if isinstance(data, dict):
   346:             data.setdefault("success", str(data.get("code")) == "00000")
   347:         try:
   348:             for row in data.get("data", []):
   349:                 if "currency" not in row and row.get("marginCoin"):
   350:                     row["currency"] = str(row["marginCoin"]).upper()
   351:                 chosen = None
   352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
   353:                     val = row.get(key)
   354:                     if val is not None:
   355:                         chosen = val
   356:                         break
   357:                 if chosen is not None:
   358:                     row["equity"] = chosen
   359:                 try:
   360:                     row["equity"] = float(row["equity"])
   361:                 except Exception:
   362:                     pass
   363:         except Exception:  # pragma: no cover - best effort
   364:             pass
   365:         return data
   366: 
   367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   368:         if self.paper_trade:
   369:             return {"success": True, "code": 0, "data": []}
   370:         data = self._private_request(
   371:             "GET",
   372:             "/api/v2/mix/position/all-position",
   373:             params={"productType": self._product_type(product_type)},
   374:         )
   375:         try:
   376:             positions = data.get("data", [])
   377:             filtered = []
   378:             for pos in positions:
   379:                 vol = pos.get("vol")
   380:                 try:
   381:                     if vol is not None and float(vol) > 0:
   382:                         filtered.append(pos)
   383:                 except (TypeError, ValueError):
   384:                     continue
   385:             data["data"] = filtered
   386:         except Exception:  # pragma: no cover - best effort
   387:             pass
   388:         return data
   389: 
   390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   391:         if self.paper_trade:
   392:             return {"success": True, "code": 0, "data": []}
   393:         params: Dict[str, Any] = {"productType": self.product_type}
   394:         if symbol:
   395:             params["symbol"] = self._format_symbol(symbol)
   396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
   397: 
   398:     # Account configuration -------------------------------------------------
   399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
   400:         body = {
   401:             "productType": self._product_type(product_type),
   402:             "symbol": self._format_symbol(symbol),
   403:             "posMode": "one_way_mode",
   404:         }
   405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
   406: 
   407:     def set_leverage(
   408:         self,
   409:         symbol: str,
   410:         product_type: Optional[str] = None,
   411:         margin_coin: str = "USDT",
   412:         leverage: int = 1,
   413:     ) -> Dict[str, Any]:
   414:         body = {
   415:             "symbol": self._format_symbol(symbol),
   416:             "productType": self._product_type(product_type),
   417:             "marginCoin": margin_coin,
   418:             "leverage": int(leverage),
   419:         }
   420:         return self._private_request(
   421:             "POST", "/api/v2/mix/account/set-leverage", body=body
   422:         )
   423: 
   424:     def place_market_order_one_way(
   425:         self,
   426:         symbol: str,
   427:         side: str,
   428:         size: float,
   429:         product_type: Optional[str] = None,
   430:         margin_coin: str = "USDT",
   431:         *,
   432:         time_in_force: str = "normal",
   433:     ) -> Dict[str, Any]:
   434:         side = side.lower()
   435:         if side not in {"buy", "sell"}:
   436:             raise ValueError("side must be 'buy' or 'sell'")
   437:         body = {
   438:             "symbol": self._format_symbol(symbol),
   439:             "productType": self._product_type(product_type),
   440:             "marginCoin": margin_coin,
   441:             "marginMode": "crossed",
   442:             "posMode": "one_way_mode",
   443:             "orderType": "market",
   444:             "side": side,
   445:             "size": str(size),
   446:             "timeInForceValue": time_in_force,
   447:             "clientOid": str(uuid.uuid4())[:32],
   448:         }
   449:         return self._private_request(
   450:             "POST", "/api/v2/mix/order/place-order", body=body
   451:         )
   452: 
   453:     # Orders ---------------------------------------------------------------
   454:     def place_order(
   455:         self,
   456:         symbol: str,
   457:         side: int,
   458:         vol: int,
   459:         order_type: int,
   460:         *,
   461:         price: Optional[float] = None,
   462:         open_type: int = 1,
   463:         leverage: Optional[int] = None,
   464:         position_id: Optional[int] = None,
   465:         external_oid: Optional[str] = None,
   466:         stop_loss: Optional[float] = None,
   467:         take_profit: Optional[float] = None,
   468:         position_mode: Optional[int] = None,
   469:         margin_coin: Optional[str] = None,
   470:         time_in_force: str = "normal",
   471:     ) -> Dict[str, Any]:
   472:         """Submit an order.
   473: 
   474:         This helper keeps backward compatibility with the older numeric
   475:         parameters used by the bot while translating them to the string based
   476:         fields required by Bitget's v2 API.
   477:         """
   478:         if self.paper_trade:
   479:             logging.info(
   480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
   481:                 side,
   482:                 vol,
   483:                 order_type,
   484:                 price,
   485:             )
   486:             return {
   487:                 "success": True,
   488:                 "paperTrade": True,
   489:                 "simulated": {
   490:                     "symbol": symbol,
   491:                     "side": side,
   492:                     "vol": vol,
   493:                     "type": order_type,
   494:                     "price": price,
   495:                     "openType": open_type,
   496:                     "leverage": leverage,
   497:                     "stopLossPrice": stop_loss,
   498:                     "takeProfitPrice": take_profit,
   499:                 },
   500:             }
   501: 
   502:         # ------------------------------------------------------------------
   503:         # Parameter mapping
   504:         # ------------------------------------------------------------------
   505:         side_map = {
   506:             1: ("buy", "long"),
   507:             2: ("buy", "short"),
   508:             3: ("sell", "short"),
   509:             4: ("sell", "long"),
   510:         }
   511:         if isinstance(side, int):
   512:             mapped = side_map.get(side)
   513:             if not mapped:
   514:                 raise ValueError(f"Invalid side value: {side}")
   515:             side_str, pos_side = mapped
   516:         else:
   517:             side_str = str(side)
   518:             pos_side = None
   519: 
   520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
   521:         if isinstance(order_type, int):
   522:             order_str = order_map.get(order_type)
   523:             if order_str is None:
   524:                 order_str = "limit" if price is not None else "market"
   525:         else:
   526:             order_str = str(order_type)
   527: 
   528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
   529: 
   530:         if margin_coin is None:
   531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   532: 
   533:         # ------------------------------------------------------------------
   534:         # Precision handling
   535:         # ------------------------------------------------------------------
   536:         try:
   537:             price_place, volume_place = self._get_contract_precision(symbol)
   538:         except Exception:  # pragma: no cover - best effort
   539:             price_place = volume_place = 0
   540:         if price is not None:
   541:             price = round(float(price), price_place)
   542:         if vol is not None:
   543:             vol = round(float(vol), volume_place)
   544: 
   545:         body = {
   546:             "symbol": self._format_symbol(symbol),
   547:             "productType": self.product_type,
   548:             "marginMode": margin_mode,
   549:             "orderType": order_str,
   550:             "side": side_str,
   551:             "size": vol,
   552:             "timeInForceValue": time_in_force,
   553:         }
   554:         if pos_side is not None:
   555:             body["posSide"] = pos_side
   556:         if margin_coin:
   557:             body["marginCoin"] = margin_coin
   558:         if price is not None:
   559:             body["price"] = float(price)
   560:         if leverage is not None:
   561:             body["leverage"] = int(leverage)
   562:         if position_id is not None:
   563:             body["positionId"] = int(position_id)
   564:         if external_oid:
   565:             body["clientOid"] = str(external_oid)[:32]
   566:         else:
   567:             body["clientOid"] = str(uuid.uuid4())[:32]
   568:         if stop_loss is not None:
   569:             body["stopLossPrice"] = float(stop_loss)
   570:         if take_profit is not None:
   571:             body["takeProfitPrice"] = float(take_profit)
   572:         if position_mode is not None:
   573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
   574:         elif pos_side is not None:
   575:             body["posMode"] = "hedge_mode"
   576: 
   577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
   578: 
   579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
   580:         if self.paper_trade:
   581:             logging.info(
   582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
   583:             )
   584:             return {"success": True, "code": 0}
   585:         return self._private_request(
   586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
   587:         )
   588: 
   589:     def cancel_all(
   590:         self,
   591:         symbol: Optional[str] = None,
   592:         margin_coin: Optional[str] = None,
   593:     ) -> Dict[str, Any]:
   594:         if self.paper_trade:
   595:             logging.info(
   596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
   597:             )
   598:             return {"success": True, "code": 0}
   599:         body = {"productType": self.product_type}
   600:         if symbol:
   601:             body["symbol"] = self._format_symbol(symbol)
   602:         if margin_coin is None:
   603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   604:         if margin_coin:
   605:             body["marginCoin"] = margin_coin
   606:         return self._private_request(
   607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
   608:         )
   609: 
   610:     def close_position(
   611:         self,
   612:         symbol: str,
   613:         size: Optional[int] = None,
   614:         hold_side: Optional[str] = None,
   615:     ) -> Dict[str, Any]:
   616:         """Close an open position for ``symbol``.
   617: 
   618:         Parameters
   619:         ----------
   620:         symbol:
   621:             Trading symbol to close.
   622:         size:
   623:             Optional number of contracts to close. If omitted the entire
   624:             position is closed.
   625:         hold_side:
   626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
   627:             specified. If not provided the exchange will infer it.
   628:         """
   629: 
   630:         if self.paper_trade:
   631:             logging.info(
   632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
   633:             )
   634:             return {"success": True, "code": 0}
   635: 
   636:         body = {"symbol": self._format_symbol(symbol)}
   637:         if size is not None:
   638:             body["size"] = int(size)
   639:         if hold_side:
   640:             body["holdSide"] = hold_side
   641: 
   642:         body["productType"] = self.product_type
   643:         return self._private_request(
   644:             "POST", "/api/v2/mix/position/close-position", body=body
   645:         )
   646: 
   647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   648:         """Close all open positions."""
   649:         results = []
   650:         try:
   651:             for pos in self.get_positions(product_type).get("data", []):
   652:                 sym = pos.get("symbol")
   653:                 if sym:
   654:                     results.append(self.close_position(sym))
   655:         except Exception as exc:  # pragma: no cover - best effort
   656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
   657:         return {"success": True, "data": results}

--------------------------------------------------------------------------------
FILE: engine/client.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: import logging
     2: from typing import Any, Dict, Optional
     3: 
     4: import requests
     5: from requests.adapters import HTTPAdapter
     6: from urllib3.util.retry import Retry
     7: 
     8: 
     9: class HTTPError(RuntimeError):
    10:     """Raised when an HTTP request fails"""
    11: 
    12: 
    13: class HttpClient:
    14:     """Simple HTTP client with persistent session and retry logic.
    15: 
    16:     The client exposes a :py:meth:`close` method and implements the context
    17:     manager protocol so it can be used with ``with`` statements to ensure
    18:     that the underlying :class:`requests.Session` is properly closed.
    19:     """
    20: 
    21:     def __init__(
    22:         self,
    23:         base_url: str,
    24:         *,
    25:         timeout: float = 10.0,
    26:         max_retries: int = 3,
    27:         backoff_factor: float = 0.3,
    28:         status_forcelist: Optional[list[int]] = None,
    29:     ) -> None:
    30:         self.base_url = base_url.rstrip("/")
    31:         self.timeout = timeout
    32:         self.session = requests.Session()
    33:         retry = Retry(
    34:             total=max_retries,
    35:             backoff_factor=backoff_factor,
    36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
    37:             allowed_methods=[
    38:                 "HEAD",
    39:                 "GET",
    40:                 "OPTIONS",
    41:                 "POST",
    42:                 "PUT",
    43:                 "DELETE",
    44:                 "PATCH",
    45:             ],
    46:         )
    47:         adapter = HTTPAdapter(max_retries=retry)
    48:         self.session.mount("http://", adapter)
    49:         self.session.mount("https://", adapter)
    50: 
    51:     def close(self) -> None:
    52:         """Close the underlying :class:`requests.Session`."""
    53:         self.session.close()
    54: 
    55:     # ------------------------------------------------------------------
    56:     # Context manager support
    57:     # ------------------------------------------------------------------
    58:     def __enter__(self) -> "HttpClient":
    59:         return self
    60: 
    61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
    62:         self.close()
    63: 
    64:     def request(
    65:         self,
    66:         method: str,
    67:         path: str,
    68:         *,
    69:         params: Optional[Dict[str, Any]] = None,
    70:         json: Optional[Dict[str, Any]] = None,
    71:         headers: Optional[Dict[str, str]] = None,
    72:     ) -> Dict[str, Any]:
    73:         """Perform an HTTP request and return JSON data.
    74: 
    75:         Errors during the request raise ``HTTPError``. If the response cannot
    76:         be decoded as JSON, a dictionary describing the issue is returned.
    77:         """
    78:         url = f"{self.base_url}{path}"
    79:         try:
    80:             resp = self.session.request(
    81:                 method,
    82:                 url,
    83:                 params=params,
    84:                 json=json,
    85:                 headers=headers,
    86:                 timeout=self.timeout,
    87:             )
    88:             resp.raise_for_status()
    89:         except requests.RequestException as exc:  # network or HTTP errors
    90:             msg = f"HTTP error calling {url}: {exc}"
    91:             logging.error(msg)
    92:             raise HTTPError(msg) from exc
    93: 
    94:         try:
    95:             return resp.json()
    96:         except ValueError:  # invalid JSON
    97:             msg = "Invalid JSON in response"
    98:             logging.error("%s for %s: %s", msg, url, resp.text)
    99:             return {"success": False, "error": msg, "text": resp.text}

--------------------------------------------------------------------------------
FILE: engine/config/config.yaml  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: runtime:
     2:   data_dir: /notebooks/scalp_data/data
     3:   log_dir: /notebooks/scalp_data/logs
     4:   reports_dir: /notebooks/scalp_data/reports
     5:   paper_trade: true
     6:   allowed_symbols: []
     7:   refresh_secs: 5
     8: 
     9: strategy:
    10:   live_timeframe: 1m
    11:   ema_fast: 20
    12:   ema_slow: 50
    13:   atr_period: 14
    14:   trail_atr_mult: 2.0
    15:   risk_pct_equity: 0.02

--------------------------------------------------------------------------------
FILE: engine/config/loader.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import os
     3: from pathlib import Path
     4: from typing import Any, Dict, Tuple
     5: 
     6: try:
     7:     import yaml
     8: except Exception:
     9:     yaml = None
    10: 
    11: _ALIASES: Dict[str, Tuple[str, ...]] = {
    12:     "BITGET_ACCESS_KEY": ("BITGET_API_KEY", "BITGET_KEY"),
    13:     "BITGET_SECRET_KEY": ("BITGET_API_SECRET", "BITGET_SECRET"),
    14:     "BITGET_PASSPHRASE": ("BITGET_API_PASSPHRASE", "BITGET_PASSWORD", "BITGET_API_PASSWORD"),
    15:     "TELEGRAM_BOT_TOKEN": ("TELEGRAM_TOKEN", "TG_TOKEN"),
    16:     "TELEGRAM_CHAT_ID": ("TG_CHAT_ID", "TELEGRAM_TO", "CHAT_ID"),
    17: }
    18: 
    19: def _adopt_alias(target: str) -> None:
    20:     if os.getenv(target):
    21:         return
    22:     for alt in _ALIASES.get(target, ()):
    23:         v = os.getenv(alt)
    24:         if v:
    25:             os.environ[target] = v
    26:             return
    27: 
    28: def apply_env_aliases() -> None:
    29:     for k in _ALIASES:
    30:         _adopt_alias(k)
    31: 
    32: def _default_paths() -> Dict[str, str]:
    33:     data_root = os.getenv("DATA_ROOT", "/notebooks/scalp_data")
    34:     root = Path(data_root)
    35:     return {
    36:         "data_dir": str(root / "data"),
    37:         "log_dir": str(root / "logs"),
    38:         "reports_dir": str(root / "reports"),
    39:     }
    40: 
    41: def load_yaml_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    42:     if path is None:
    43:         path = Path(__file__).resolve().parent / "config.yaml"
    44:     path = Path(path)
    45:     if yaml is None or not path.exists():
    46:         return {}
    47:     with path.open("r", encoding="utf-8") as fh:
    48:         return yaml.safe_load(fh) or {}
    49: 
    50: def load_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    51:     cfg = load_yaml_config(path)
    52:     apply_env_aliases()
    53: 
    54:     cfg.setdefault("secrets", {})
    55:     cfg["secrets"]["bitget"] = {
    56:         "access": os.getenv("BITGET_ACCESS_KEY") or "",
    57:         "secret": os.getenv("BITGET_SECRET_KEY") or "",
    58:         "passphrase": os.getenv("BITGET_PASSPHRASE") or "",
    59:     }
    60:     cfg["secrets"]["telegram"] = {
    61:         "token": os.getenv("TELEGRAM_BOT_TOKEN") or "",
    62:         "chat_id": os.getenv("TELEGRAM_CHAT_ID") or "",
    63:     }
    64: 
    65:     defaults = _default_paths()
    66:     r = cfg.setdefault("runtime", {})
    67:     r.setdefault("data_dir", defaults["data_dir"])
    68:     r.setdefault("log_dir", defaults["log_dir"])
    69:     r.setdefault("reports_dir", defaults["reports_dir"])
    70:     r.setdefault("paper_trade", True)
    71:     r.setdefault("allowed_symbols", [])
    72:     r.setdefault("refresh_secs", 5)
    73: 
    74:     s = cfg.setdefault("strategy", {})
    75:     s.setdefault("live_timeframe", "1m")
    76: 
    77:     return cfg

--------------------------------------------------------------------------------
FILE: engine/config/strategies.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/config/strategies.py
     2: from __future__ import annotations
     3: import json
     4: from pathlib import Path
     5: from typing import Any, Dict
     6: 
     7: def _target_path() -> Path:
     8:     # Fichier promu par jobs/promote.py
     9:     return Path(__file__).resolve().parent / "strategies.yml"
    10: 
    11: def _load_json_compat(path: Path) -> Dict[str, Any]:
    12:     # On stocke en JSON lisible (extension .yml pour compat) -> lecture JSON
    13:     try:
    14:         return json.loads(path.read_text(encoding="utf-8"))
    15:     except Exception:
    16:         return {}
    17: 
    18: def load_strategies() -> Dict[str, Dict[str, Any]]:
    19:     """
    20:     Retourne un mapping {"SYMBOL:TF": {params...}, ...}
    21:     Si vide/non trouvé -> {}.
    22:     """
    23:     p = _target_path()
    24:     if not p.exists():
    25:         return {}
    26:     doc = _load_json_compat(p)
    27:     strategies = doc.get("strategies") or {}
    28:     # normalise clés en "BTCUSDT:1m"
    29:     out: Dict[str, Dict[str, Any]] = {}
    30:     for k, v in strategies.items():
    31:         if not isinstance(v, dict):
    32:             continue
    33:         out[str(k).replace("_", "").upper()] = dict(v)
    34:     return out

--------------------------------------------------------------------------------
FILE: engine/config/watchlist.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/config/watchlist.py
     2: from __future__ import annotations
     3: import json, os, time
     4: from dataclasses import asdict
     5: from pathlib import Path
     6: from typing import Any, Dict, List
     7: 
     8: from engine.config.loader import load_config
     9: from engine.pairs.selector import PairMetrics
    10: 
    11: def _watchlist_path() -> Path:
    12:     # Fichier versionné ou non ? -> dans DATA_ROOT/reports (hors repo)
    13:     cfg = load_config()
    14:     p = Path(cfg["runtime"]["reports_dir"]) / "watchlist.yml"
    15:     p.parent.mkdir(parents=True, exist_ok=True)
    16:     return p
    17: 
    18: def save_watchlist(pairs: List[PairMetrics], *, timestamp: int | None = None) -> Path:
    19:     path = _watchlist_path()
    20:     doc = {
    21:         "updated_at": int(timestamp or time.time()),
    22:         "top": [asdict(p) for p in pairs],
    23:     }
    24:     # json lisible (compat .yml reader simple)
    25:     path.write_text(json.dumps(doc, indent=2), encoding="utf-8")
    26:     return path
    27: 
    28: def load_watchlist() -> Dict[str, Any]:
    29:     p = _watchlist_path()
    30:     if not p.exists():
    31:         return {"updated_at": 0, "top": []}
    32:     try:
    33:         return json.loads(p.read_text(encoding="utf-8"))
    34:     except Exception:
    35:         return {"updated_at": 0, "top": []}

--------------------------------------------------------------------------------
FILE: engine/core/indicators.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import pandas as pd
     3: 
     4: def ema(s: pd.Series, n: int) -> pd.Series:
     5:     return s.ewm(span=max(1,int(n)), adjust=False).mean()
     6: 
     7: def macd(close: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9):
     8:     macd_line = ema(close, fast) - ema(close, slow)
     9:     signal_line = ema(macd_line, signal)
    10:     hist = macd_line - signal_line
    11:     return macd_line, signal_line, hist
    12: 
    13: def atr(df: pd.DataFrame, n: int = 14) -> pd.Series:
    14:     high, low, close = df["high"], df["low"], df["close"]
    15:     prev_close = close.shift(1)
    16:     tr = (high - low).abs().combine((high - prev_close).abs(), max).combine((low - prev_close).abs(), max)
    17:     return tr.rolling(max(1,int(n))).mean()

--------------------------------------------------------------------------------
FILE: engine/core/signal.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import pandas as pd
     3: from .indicators import ema, atr
     4: 
     5: def compute_signals(df: pd.DataFrame, params: dict) -> pd.DataFrame:
     6:     fast = int(params.get("ema_fast", 20))
     7:     slow = int(params.get("ema_slow", 50))
     8:     atr_n = int(params.get("atr_period", 14))
     9:     df = df.copy()
    10:     df["ema_fast"] = ema(df["close"], fast)
    11:     df["ema_slow"] = ema(df["close"], slow)
    12:     df["atr"] = atr(df, atr_n)
    13:     # signal = +1 si croisement haussier, -1 si baissier, 0 sinon
    14:     cond_up = (df["ema_fast"] > df["ema_slow"]) & (df["ema_fast"].shift(1) <= df["ema_slow"].shift(1))
    15:     cond_dn = (df["ema_fast"] < df["ema_slow"]) & (df["ema_fast"].shift(1) >= df["ema_slow"].shift(1))
    16:     df["signal"] = 0
    17:     df.loc[cond_up, "signal"] = 1
    18:     df.loc[cond_dn, "signal"] = -1
    19:     return df

--------------------------------------------------------------------------------
FILE: engine/core/signals.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/core/signals.py
     2: from __future__ import annotations
     3: import pandas as pd
     4: 
     5: def _ema(series: pd.Series, period: int) -> pd.Series:
     6:     return series.ewm(span=period, adjust=False).mean()
     7: 
     8: def _atr(df: pd.DataFrame, period: int = 14) -> pd.Series:
     9:     high, low, close = df["high"], df["low"], df["close"]
    10:     prev_close = close.shift(1)
    11:     tr = pd.concat([
    12:         high - low,
    13:         (high - prev_close).abs(),
    14:         (low - prev_close).abs()
    15:     ], axis=1).max(axis=1)
    16:     return tr.rolling(period).mean()
    17: 
    18: def compute_signals(df: pd.DataFrame, params: dict[str, float]) -> pd.DataFrame:
    19:     """
    20:     Applique EMA crossover + ATR.
    21:     Retourne DataFrame avec colonnes: ts, open, high, low, close, volume, ema_fast, ema_slow, atr, signal
    22:     signal = +1 long / -1 short / 0 neutre
    23:     """
    24:     fast = int(params.get("ema_fast", 20))
    25:     slow = int(params.get("ema_slow", 50))
    26:     atr_period = int(params.get("atr_period", 14))
    27: 
    28:     out = df.copy()
    29:     out["ema_fast"] = _ema(out["close"], fast)
    30:     out["ema_slow"] = _ema(out["close"], slow)
    31:     out["atr"] = _atr(out, atr_period)
    32: 
    33:     sig = 0
    34:     signals = []
    35:     for f, s in zip(out["ema_fast"], out["ema_slow"]):
    36:         if pd.isna(f) or pd.isna(s):
    37:             signals.append(0)
    38:         elif f > s and sig <= 0:
    39:             sig = 1
    40:             signals.append(1)
    41:         elif f < s and sig >= 0:
    42:             sig = -1
    43:             signals.append(-1)
    44:         else:
    45:             signals.append(sig)
    46:     out["signal"] = signals
    47:     return out

--------------------------------------------------------------------------------
FILE: engine/exchange/bitget_ccxt.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import asyncio
     3: from typing import Any, List, Sequence
     4: 
     5: class BitgetExchange:
     6:     """Wrapper CCXT async. Installe `ccxt` pour l'utiliser, sinon bot tombera sur REST."""
     7:     def __init__(self, api_key: str, secret: str, password: str, data_dir: str):
     8:         try:
     9:             import ccxt.async_support as ccxt  # type: ignore
    10:         except Exception as e:  # ccxt non installé
    11:             raise RuntimeError(f"ccxt non disponible: {e}")
    12:         self._ccxt = ccxt.bitget({"apiKey": api_key, "secret": secret, "password": password})
    13:         self.data_dir = data_dir
    14: 
    15:     async def fetch_ohlcv(self, symbol: str, timeframe: str, limit: int = 150) -> List[List[float]]:
    16:         return await self._ccxt.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    17: 
    18:     async def close(self) -> None:
    19:         try:
    20:             await self._ccxt.close()
    21:         except Exception:
    22:             pass

--------------------------------------------------------------------------------
FILE: engine/exchange/bitget_rest.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/exchange/bitget_rest.py
     2: from __future__ import annotations
     3: 
     4: import base64
     5: import hashlib
     6: import hmac
     7: import json
     8: import logging
     9: import time
    10: from dataclasses import dataclass
    11: from typing import Any, Dict, Mapping, Optional
    12: 
    13: import requests
    14: 
    15: __all__ = ["BitgetFuturesClient", "ApiError"]
    16: 
    17: log = logging.getLogger("engine.exchange.bitget_rest")
    18: 
    19: 
    20: # =============================================================================
    21: # Exceptions
    22: # =============================================================================
    23: class ApiError(RuntimeError):
    24:     """Erreur API Bitget (HTTP != 200, code != '00000', ou payload invalide)."""
    25: 
    26:     def __init__(self, message: str, *, http_status: int | None = None, body: Any | None = None):
    27:         super().__init__(message)
    28:         self.http_status = http_status
    29:         self.body = body
    30: 
    31: 
    32: # =============================================================================
    33: # Helpers
    34: # =============================================================================
    35: def _now_ms() -> int:
    36:     return int(time.time() * 1000)
    37: 
    38: 
    39: def _canonical_json(obj: Mapping[str, Any] | None) -> str:
    40:     if not obj:
    41:         return ""
    42:     # JSON compact, trié, ascii pour signature stable
    43:     return json.dumps(obj, separators=(",", ":"), sort_keys=True, ensure_ascii=True)
    44: 
    45: 
    46: # =============================================================================
    47: # Client REST Futures (USDT-M)
    48: # =============================================================================
    49: @dataclass
    50: class _Auth:
    51:     access_key: str
    52:     secret_key: str
    53:     passphrase: str
    54:     recv_window: int = 30_000  # ms
    55: 
    56: 
    57: class BitgetFuturesClient:
    58:     """
    59:     Client REST léger pour les Futures USDT-M de Bitget.
    60: 
    61:     Points clés:
    62:     - Public: get_ticker(symbol?), get_klines(symbol, interval, limit, start/end?)
    63:     - Privé : get_account(), get_open_orders(symbol?), cancel_order(), cancel_all()
    64:               place_market_order_one_way(), place_limit_order_one_way()
    65:               set_position_mode_one_way(), set_leverage()
    66:     - Safe: gestion d’erreurs centralisée, timeouts, session réutilisable.
    67:     """
    68: 
    69:     def __init__(
    70:         self,
    71:         *,
    72:         access_key: str = "",
    73:         secret_key: str = "",
    74:         passphrase: str = "",
    75:         base_url: str = "https://api.bitget.com",
    76:         paper_trade: bool = True,
    77:         timeout: float = 10.0,
    78:         session: Optional[requests.Session] = None,
    79:     ) -> None:
    80:         self.base_url = base_url.rstrip("/")
    81:         self.auth = _Auth(access_key, secret_key, passphrase)
    82:         self.paper = paper_trade
    83:         self.timeout = float(timeout)
    84:         self.sess = session or requests.Session()
    85:         self.sess.headers.update({"Accept": "application/json"})
    86:         log.info("BitgetFuturesClient ready (paper=%s base=%s)", self.paper, self.base_url)
    87: 
    88:     # -------------------------------------------------------------------------
    89:     # Core HTTP
    90:     # -------------------------------------------------------------------------
    91:     def _sign(self, ts_ms: int, method: str, path: str, query: str, body: str) -> str:
    92:         """
    93:         Signature :
    94:           sign = base64( HMAC_SHA256(secret, f"{ts}{method}{path}{query}{body}") )
    95:         - method en MAJUSCULES
    96:         - query inclut '?' si présent, sinon ""
    97:         - body = chaîne JSON canonique (ou vide)
    98:         """
    99:         msg = f"{ts_ms}{method.upper()}{path}{query}{body}"
   100:         return base64.b64encode(hmac.new(self.auth.secret_key.encode(), msg.encode(), hashlib.sha256).digest()).decode()
   101: 
   102:     def _request(
   103:         self,
   104:         method: str,
   105:         path: str,
   106:         *,
   107:         params: Optional[Mapping[str, Any]] = None,
   108:         body: Optional[Mapping[str, Any]] = None,
   109:         signed: bool = False,
   110:     ) -> Dict[str, Any]:
   111:         url = f"{self.base_url}{path}"
   112:         params = dict(params or {})
   113:         body_json = _canonical_json(body)
   114:         query = ""
   115: 
   116:         headers = {"Content-Type": "application/json"}
   117:         if not signed:
   118:             # Public
   119:             resp = self.sess.request(
   120:                 method=method.upper(),
   121:                 url=url,
   122:                 params=params or None,
   123:                 timeout=self.timeout,
   124:                 headers=headers,
   125:             )
   126:         else:
   127:             # Privé: timestamp + recvWindow
   128:             ts = _now_ms()
   129:             if "recvWindow" not in params:
   130:                 params["recvWindow"] = self.auth.recv_window
   131:             # Construire la query string stable (requests la reformate si on passe 'params')
   132:             if params:
   133:                 q_items = "&".join(f"{k}={params[k]}" for k in sorted(params))
   134:                 query = f"?{q_items}"
   135:             signature = self._sign(ts, method, path, query, body_json)
   136: 
   137:             headers.update(
   138:                 {
   139:                     "ACCESS-KEY": self.auth.access_key,
   140:                     "ACCESS-SIGN": signature,
   141:                     "ACCESS-TIMESTAMP": str(ts),
   142:                     "ACCESS-PASSPHRASE": self.auth.passphrase,
   143:                 }
   144:             )
   145: 
   146:             resp = self.sess.request(
   147:                 method=method.upper(),
   148:                 url=url,
   149:                 params=params or None,
   150:                 data=body_json if body_json else None,
   151:                 timeout=self.timeout,
   152:                 headers=headers,
   153:             )
   154: 
   155:         # Gestion d’erreurs HTTP
   156:         if resp.status_code != 200:
   157:             raise ApiError(f"HTTP {resp.status_code} for {path}", http_status=resp.status_code, body=resp.text)
   158: 
   159:         # Décodage JSON
   160:         try:
   161:             data = resp.json()
   162:         except Exception as exc:
   163:             raise ApiError(f"Non-JSON response for {path}: {resp.text[:200]}") from exc
   164: 
   165:         # Protocole Bitget: code == '00000' attendu
   166:         code = str(data.get("code", ""))
   167:         if code and code != "00000":
   168:             raise ApiError(f"Bitget API error code={code} for {path}", body=data)
   169: 
   170:         return data
   171: 
   172:     # -------------------------------------------------------------------------
   173:     # PUBLIC
   174:     # -------------------------------------------------------------------------
   175:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   176:         """
   177:         Ticker futures. Si `symbol` est fourni, retourne uniquement cette entrée.
   178:         """
   179:         params = {"productType": "USDT-FUTURES"}
   180:         data = self._request("GET", "/api/v2/mix/market/tickers", params=params, signed=False)
   181:         if not symbol:
   182:             return data
   183: 
   184:         # Harmoniser: extraire l’entrée du symbole demandé
   185:         items = data.get("data") or []
   186:         sym = symbol.replace("_", "").upper()
   187:         hit: Dict[str, Any] | None = None
   188:         for it in items:
   189:             if (it.get("symbol") or "").replace("_", "").upper() == sym:
   190:                 hit = it
   191:                 break
   192:         return {"data": hit or {}}
   193: 
   194:     def get_klines(
   195:         self,
   196:         symbol: str,
   197:         interval: str = "1m",
   198:         limit: int = 100,
   199:         start: Optional[int] = None,
   200:         end: Optional[int] = None,
   201:     ) -> Dict[str, Any]:
   202:         """
   203:         OHLCV Futures.
   204:         interval: '1m', '5m', '15m', '1h', ...
   205:         start/end: timestamps ms optionnels.
   206:         """
   207:         params: Dict[str, Any] = {
   208:             "symbol": symbol.replace("_", "").upper(),
   209:             "granularity": interval,
   210:             "productType": "USDT-FUTURES",
   211:             "limit": max(1, min(int(limit), 1000)),
   212:         }
   213:         if start is not None:
   214:             params["startTime"] = int(start)
   215:         if end is not None:
   216:             params["endTime"] = int(end)
   217: 
   218:         return self._request("GET", "/api/v2/mix/market/candles", params=params, signed=False)
   219: 
   220:     # -------------------------------------------------------------------------
   221:     # PRIVÉ (Futures One-Way par défaut)
   222:     # -------------------------------------------------------------------------
   223:     def get_account(self) -> Dict[str, Any]:
   224:         """Infos compte futures (marges, balances)."""
   225:         return self._request("GET", "/api/v2/mix/account/accounts", params={"productType": "USDT-FUTURES"}, signed=True)
   226: 
   227:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   228:         params: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   229:         if symbol:
   230:             params["symbol"] = symbol.replace("_", "").upper()
   231:         return self._request("GET", "/api/v2/mix/order/open-orders", params=params, signed=True)
   232: 
   233:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   234:         body = {
   235:             "symbol": symbol.replace("_", "").upper(),
   236:             "productType": "USDT-FUTURES",
   237:             "orderId": order_id,
   238:         }
   239:         return self._request("POST", "/api/v2/mix/order/cancel-order", body=body, signed=True)
   240: 
   241:     def cancel_all(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   242:         body: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   243:         if symbol:
   244:             body["symbol"] = symbol.replace("_", "").upper()
   245:         return self._request("POST", "/api/v2/mix/order/cancel-batch-orders", body=body, signed=True)
   246: 
   247:     # -- Mode de position & levier ---------------------------------------------
   248:     def set_position_mode_one_way(self, symbol: str, product_type: str = "USDT-FUTURES") -> Dict[str, Any]:
   249:         """Passe le mode de position en One-Way (si nécessaire)."""
   250:         body = {
   251:             "productType": product_type,
   252:             "symbol": symbol.replace("_", "").upper(),
   253:             "holdMode": "one_way",
   254:         }
   255:         return self._request("POST", "/api/v2/mix/account/set-position-mode", body=body, signed=True)
   256: 
   257:     def set_leverage(
   258:         self,
   259:         symbol: str,
   260:         product_type: str = "USDT-FUTURES",
   261:         margin_coin: str = "USDT",
   262:         leverage: int = 2,
   263:         side: str = "long",
   264:     ) -> Dict[str, Any]:
   265:         """Règle l’effet de levier (par side 'long'/'short' ou global selon l’API)."""
   266:         lev = max(1, int(leverage))
   267:         body = {
   268:             "symbol": symbol.replace("_", "").upper(),
   269:             "productType": product_type,
   270:             "marginCoin": margin_coin,
   271:             "leverage": str(lev),
   272:             "holdSide": side.lower(),  # 'long' ou 'short'
   273:         }
   274:         return self._request("POST", "/api/v2/mix/account/set-leverage", body=body, signed=True)
   275: 
   276:     # -- Placement d’ordres (One-Way) ------------------------------------------
   277:     def place_market_order_one_way(
   278:         self,
   279:         symbol: str,
   280:         side: str,
   281:         size: float,
   282:         product_type: str = "USDT-FUTURES",
   283:         margin_coin: str = "USDT",
   284:         client_oid: Optional[str] = None,
   285:     ) -> Dict[str, Any]:
   286:         """
   287:         Place un ordre MARKET en mode one-way.
   288:         side: 'buy' ou 'sell'
   289:         size: quantité de contrat (format arrondi côté serveur)
   290:         """
   291:         body: Dict[str, Any] = {
   292:             "symbol": symbol.replace("_", "").upper(),
   293:             "productType": product_type,
   294:             "marginCoin": margin_coin,
   295:             "size": f"{float(size):.6f}",
   296:             "side": side.lower(),
   297:             "orderType": "market",
   298:         }
   299:         if client_oid:
   300:             body["clientOid"] = client_oid
   301:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   302: 
   303:     def place_limit_order_one_way(
   304:         self,
   305:         symbol: str,
   306:         side: str,
   307:         size: float,
   308:         price: float,
   309:         product_type: str = "USDT-FUTURES",
   310:         margin_coin: str = "USDT",
   311:         tif: str = "GTC",
   312:         client_oid: Optional[str] = None,
   313:     ) -> Dict[str, Any]:
   314:         """
   315:         Place un ordre LIMIT en mode one-way.
   316:         tif: GTC/IOC/FOK suivant l’API.
   317:         """
   318:         body: Dict[str, Any] = {
   319:             "symbol": symbol.replace("_", "").upper(),
   320:             "productType": product_type,
   321:             "marginCoin": margin_coin,
   322:             "size": f"{float(size):.6f}",
   323:             "price": f"{float(price):.8f}",
   324:             "side": side.lower(),
   325:             "orderType": "limit",
   326:             "timeInForceValue": tif.upper(),
   327:         }
   328:         if client_oid:
   329:             body["clientOid"] = client_oid
   330:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   331: 
   332:     # -------------------------------------------------------------------------
   333:     # Helpers d’accès
   334:     # -------------------------------------------------------------------------
   335:     def last_price(self, symbol: str) -> float:
   336:         """Renvoie un prix last connu en tolérant plusieurs structures/clefs."""
   337:         tick = self.get_ticker(symbol)
   338:         data = tick.get("data")
   339:         if isinstance(data, list) and data:
   340:             data = data[0]
   341:         if not isinstance(data, dict):
   342:             return 0.0
   343:         price_str = (
   344:             data.get("lastPr")
   345:             or data.get("lastPrice")
   346:             or data.get("close")
   347:             or data.get("price")
   348:             or data.get("l")
   349:         )
   350:         try:
   351:             return float(price_str)
   352:         except Exception:
   353:             return 0.0

--------------------------------------------------------------------------------
FILE: engine/hooks/prewarm_cache.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: """
     3: Pré-chauffe léger du cache OHLCV.
     4: 
     5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
     6: pour chaque symbole, et on s'assure que le dossier data existe.
     7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
     8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
     9: signature.
    10: """
    11: from __future__ import annotations
    12: from pathlib import Path
    13: from typing import Iterable
    14: 
    15: 
    16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
    17:     out = Path(out_dir)
    18:     out.mkdir(parents=True, exist_ok=True)
    19:     for sym in symbols:
    20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
    21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
    22:         print(f"[cache] warmup OK for {sym}")

--------------------------------------------------------------------------------
FILE: engine/live/commands.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/live/commands.py
     2: from __future__ import annotations
     3: import asyncio
     4: import logging
     5: import os
     6: from typing import Any, AsyncIterator, Dict, Optional
     7: 
     8: import requests
     9: 
    10: log = logging.getLogger("engine.live.commands")
    11: 
    12: 
    13: async def telegram_command_stream(
    14:     token: str,
    15:     chat_id: str,
    16:     *,
    17:     poll_secs: int = 5,
    18:     allowed_cmds: Optional[set[str]] = None,
    19: ) -> AsyncIterator[Dict[str, Any]]:
    20:     """
    21:     Flux de commandes Telegram via long‑polling.
    22:     Émet des dicts {type: "tg", cmd: "status" | "reload" | "stop" | "help", raw: <update>}
    23:     """
    24:     allowed_cmds = allowed_cmds or {"status", "reload", "stop", "help", "watchlist"}
    25:     url = f"https://api.telegram.org/bot{token}/getUpdates"
    26:     offset = 0
    27: 
    28:     while True:
    29:         try:
    30:             r = requests.get(url, params={"timeout": poll_secs, "offset": offset + 1}, timeout=poll_secs + 3)
    31:             data = r.json()
    32:             for upd in data.get("result", []):
    33:                 offset = upd.get("update_id", offset)
    34:                 msg = upd.get("message") or upd.get("edited_message") or {}
    35:                 if str(msg.get("chat", {}).get("id")) != str(chat_id):
    36:                     continue
    37:                 text = (msg.get("text") or "").strip()
    38:                 if not text.startswith("/"):
    39:                     continue
    40:                 cmd = text.lstrip("/").split()[0].lower()
    41:                 if cmd in allowed_cmds:
    42:                     yield {"type": "tg", "cmd": cmd, "raw": upd}
    43:         except Exception:
    44:             log.debug("poll telegram failed", exc_info=True)
    45:         await asyncio.sleep(poll_secs)
    46: 
    47: 
    48: def build_command_stream(cfg: Dict[str, Any] | None = None) -> Optional[AsyncIterator[Dict[str, Any]]]:
    49:     """
    50:     Construit un flux de commandes si TELEGRAM_* sont présents.
    51:     Définir DISABLE_TG_COMMANDS=1 pour désactiver.
    52:     """
    53:     if os.getenv("DISABLE_TG_COMMANDS", "").lower() in {"1", "true", "yes"}:
    54:         return None
    55: 
    56:     token = os.getenv("TELEGRAM_BOT_TOKEN") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("token")
    57:     chat_id = os.getenv("TELEGRAM_CHAT_ID") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("chat_id")
    58:     if token and chat_id:
    59:         return telegram_command_stream(token, chat_id)
    60:     return None

--------------------------------------------------------------------------------
FILE: engine/live/notify.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/live/notify.py
     2: from __future__ import annotations
     3: import asyncio
     4: import logging
     5: import os
     6: from typing import Any
     7: 
     8: import requests
     9: 
    10: log = logging.getLogger("engine.live.notify")
    11: 
    12: 
    13: class _NullNotifier:
    14:     async def send(self, text: str) -> None:
    15:         log.info("[NOTIFY] %s", text)
    16: 
    17: 
    18: class TelegramNotifier:
    19:     def __init__(self, token: str, chat_id: str, timeout: float = 5.0) -> None:
    20:         self.token, self.chat_id, self.timeout = token, chat_id, timeout
    21: 
    22:     async def send(self, text: str) -> None:
    23:         url = f"https://api.telegram.org/bot{self.token}/sendMessage"
    24:         payload = {"chat_id": self.chat_id, "text": text}
    25:         def _post() -> None:
    26:             requests.post(url, json=payload, timeout=self.timeout)
    27:         await asyncio.get_running_loop().run_in_executor(None, _post)
    28: 
    29: 
    30: def build_notifier(cfg: dict | None = None) -> Any:
    31:     token = os.getenv("TELEGRAM_BOT_TOKEN") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("token")
    32:     chat_id = os.getenv("TELEGRAM_CHAT_ID") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("chat_id")
    33:     if token and chat_id:
    34:         return TelegramNotifier(token, chat_id)
    35:     return _NullNotifier()

--------------------------------------------------------------------------------
FILE: engine/live/orchestrator.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/live/orchestrator.py
     2: from __future__ import annotations
     3: import asyncio
     4: import logging
     5: import time
     6: from dataclasses import dataclass
     7: from pathlib import Path
     8: from typing import Any, AsyncIterator, Dict, List, Sequence
     9: 
    10: import pandas as pd
    11: 
    12: from engine.config.watchlist import load_watchlist
    13: from engine.config.strategies import load_strategies
    14: from engine.core.signals import compute_signals
    15: from engine.live.trader import Trader, OrderLogger
    16: 
    17: log = logging.getLogger("engine.live.orchestrator")
    18: 
    19: 
    20: @dataclass(slots=True)
    21: class RunConfig:
    22:     symbols: Sequence[str]
    23:     timeframe: str = "1m"
    24:     refresh_secs: int = 5
    25:     cache_dir: str = "/notebooks/scalp_data/data"
    26:     watchlist_refresh_secs: int = 8 * 3600  # 8h
    27: 
    28: 
    29: def _ensure_dir(p: str | Path) -> Path:
    30:     path = Path(p)
    31:     path.mkdir(parents=True, exist_ok=True)
    32:     return path
    33: 
    34: 
    35: def _parse_last_price(ohlcv: List[List[float]]) -> float:
    36:     if not ohlcv:
    37:         return 0.0
    38:     try:
    39:         return float(ohlcv[-1][4])
    40:     except Exception:
    41:         return 0.0
    42: 
    43: 
    44: async def _fetch_ohlcv_any(exchange: Any, symbol: str, timeframe: str, limit: int = 200) -> List[List[float]]:
    45:     # 1) CCXT
    46:     fetch = getattr(exchange, "fetch_ohlcv", None)
    47:     if callable(fetch):
    48:         try:
    49:             return list(await fetch(symbol, timeframe, limit=limit))
    50:         except TypeError:
    51:             return list(fetch(symbol, timeframe, limit=limit))
    52:         except Exception:
    53:             pass
    54:     # 2) REST
    55:     get_klines = getattr(exchange, "get_klines", None)
    56:     if callable(get_klines):
    57:         try:
    58:             resp = get_klines(symbol, interval=timeframe, limit=int(limit))
    59:             rows = resp.get("data") or []
    60:             out: List[List[float]] = []
    61:             for r in rows:
    62:                 try:
    63:                     out.append(
    64:                         [
    65:                             int(r[0]),
    66:                             float(r[1]),
    67:                             float(r[2]),
    68:                             float(r[3]),
    69:                             float(r[4]),
    70:                             float(r[5]) if len(r) > 5 else 0.0,
    71:                         ]
    72:                     )
    73:                 except Exception:
    74:                     continue
    75:             out.sort(key=lambda x: x[0])
    76:             return out
    77:         except Exception:
    78:             pass
    79:     return []
    80: 
    81: 
    82: class _NullNotifier:
    83:     async def send(self, text: str) -> None:
    84:         log.info("[NOTIFY] %s", text)
    85: 
    86: 
    87: def _csv_row(path: Path, headers, row) -> None:
    88:     path.parent.mkdir(parents=True, exist_ok=True)
    89:     new = not path.exists()
    90:     with path.open("a", encoding="utf-8") as f:
    91:         if new:
    92:             f.write(",".join(headers) + "\n")
    93:         f.write(",".join(str(v).replace(",", " ") for v in row) + "\n")
    94: 
    95: 
    96: def _read_watchlist_symbols() -> List[str]:
    97:     wl = load_watchlist()
    98:     return [d.get("symbol") for d in wl.get("top", []) if d.get("symbol")]
    99: 
   100: 
   101: def _load_params_for(symbol: str, tf: str, strategies: Dict[str, Dict[str, float]],
   102:                      defaults: Dict[str, float]) -> Dict[str, float]:
   103:     key = f"{symbol.replace('_','').upper()}:{tf}"
   104:     p = dict(defaults)
   105:     p.update(strategies.get(key, {}))
   106:     # garde un petit set minimal garanti
   107:     p.setdefault("ema_fast", 20)
   108:     p.setdefault("ema_slow", 50)
   109:     p.setdefault("atr_period", 14)
   110:     p.setdefault("trail_atr_mult", 2.0)
   111:     p.setdefault("risk_pct_equity", 0.02)
   112:     return p
   113: 
   114: 
   115: async def run_orchestrator(
   116:     exchange: Any,
   117:     cfg: RunConfig,
   118:     notifier: Any | None = None,
   119:     command_stream: AsyncIterator[dict] | None = None,
   120: ) -> None:
   121:     notifier = notifier or _NullNotifier()
   122: 
   123:     # Fichiers live
   124:     base_dir = _ensure_dir(Path(cfg.cache_dir) / "live")
   125:     log_dir = _ensure_dir(base_dir / "logs")
   126:     sig_path = log_dir / "signals.csv"
   127:     orders_path = base_dir / "orders.csv"
   128: 
   129:     # Trader (paper mode si pas de vrai trading)
   130:     # On détecte le mode paper via presence d'attribut 'paper' sur le client si possible, sinon True.
   131:     paper_trade = True
   132:     if hasattr(exchange, "paper"):
   133:         try:
   134:             paper_trade = bool(getattr(exchange, "paper"))
   135:         except Exception:
   136:             paper_trade = True
   137:     trader = Trader(paper_trade=paper_trade, client=getattr(exchange, "client", exchange), order_logger=OrderLogger(orders_path))
   138: 
   139:     # Watchlist initiale
   140:     symbols = list(cfg.symbols) if cfg.symbols else (_read_watchlist_symbols() or ["BTCUSDT", "ETHUSDT", "SOLUSDT"])
   141:     # Stratégies promues + defaults
   142:     strategies = load_strategies()
   143:     defaults = {"ema_fast": 20, "ema_slow": 50, "atr_period": 14, "trail_atr_mult": 2.0, "risk_pct_equity": 0.02}
   144: 
   145:     await notifier.send(f"Bot démarré • tf={cfg.timeframe} • {len(symbols)} symboles • strategies={len(strategies)}")
   146: 
   147:     last_hb = 0.0
   148:     last_wl_reload = 0.0
   149:     stop_flag = False
   150: 
   151:     async def _handle_commands() -> None:
   152:         nonlocal symbols, stop_flag, last_wl_reload, strategies
   153:         if command_stream is None:
   154:             return
   155:         try:
   156:             async for cmd in command_stream:
   157:                 k = (cmd.get("cmd") or "").lower()
   158:                 if k == "status":
   159:                     await notifier.send(f"Watchlist ({len(symbols)}): {', '.join(symbols[:10])}")
   160:                 elif k == "reload":
   161:                     wl = _read_watchlist_symbols()
   162:                     if wl:
   163:                         symbols = wl[:10]
   164:                         last_wl_reload = time.time()
   165:                         await notifier.send(f"Watchlist rechargée ({len(symbols)}) ✅")
   166:                     else:
   167:                         await notifier.send("Watchlist vide ou introuvable ❔")
   168:                 elif k == "watchlist":
   169:                     wl = _read_watchlist_symbols()
   170:                     await notifier.send("Watchlist: " + (", ".join(wl[:10]) if wl else "(vide)"))
   171:                 elif k == "stop":
   172:                     stop_flag = True
   173:                     await notifier.send("Arrêt demandé 📴")
   174:                     return
   175:                 elif k == "help":
   176:                     await notifier.send("Cmds: /status, /reload, /watchlist, /stop")
   177:         except Exception:
   178:             log.debug("command stream ended", exc_info=True)
   179: 
   180:     cmd_task = asyncio.create_task(_handle_commands())
   181: 
   182:     try:
   183:         while not stop_flag:
   184:             ts = int(time.time() * 1000)
   185:             # Reload périodique de la watchlist
   186:             if (time.time() - last_wl_reload) > max(60, cfg.watchlist_refresh_secs):
   187:                 wl_syms = _read_watchlist_symbols()
   188:                 if wl_syms:
   189:                     symbols = wl_syms[:10]
   190:                     await notifier.send(f"Watchlist rechargée ({len(symbols)})")
   191:                 last_wl_reload = time.time()
   192: 
   193:             for sym in symbols:
   194:                 # 1) OHLCV
   195:                 ohlcv = await _fetch_ohlcv_any(exchange, sym, cfg.timeframe, limit=220)
   196:                 if len(ohlcv) < 50:
   197:                     continue
   198:                 price = _parse_last_price(ohlcv)
   199:                 if price > 0:
   200:                     _csv_row(sig_path, ["ts", "symbol", "price", "tf"], [ts, sym, price, cfg.timeframe])
   201: 
   202:                 # 2) Stratégie paramétrée pour ce (sym, tf)
   203:                 params = _load_params_for(sym, cfg.timeframe, strategies, defaults)
   204: 
   205:                 # 3) Signaux sur DataFrame
   206:                 df = pd.DataFrame(ohlcv, columns=["ts","open","high","low","close","volume"])
   207:                 df = df.sort_values("ts").reset_index(drop=True)
   208:                 df_sig = compute_signals(df, params).dropna()
   209:                 if len(df_sig) < 3:
   210:                     continue
   211:                 sig_prev = int(df_sig["signal"].iloc[-2])
   212:                 sig_now = int(df_sig["signal"].iloc[-1])
   213:                 atr_now = float(df_sig["atr"].iloc[-1])
   214: 
   215:                 # 4) Trading (paper ou réel)
   216:                 trader.on_signal(symbol=sym, tf=cg.timeframe if (cg:=cfg) else cfg.timeframe,
   217:                                  price=price, atr=atr_now, params=params,
   218:                                  signal_now=sig_now, signal_prev=sig_prev, ts=ts)
   219: 
   220:             now = time.time()
   221:             if now - last_hb > max(30, cfg.refresh_secs * 6):
   222:                 try:
   223:                     await notifier.send("Listing ok ✅")
   224:                 except Exception:
   225:                     pass
   226:                 last_hb = now
   227: 
   228:             await asyncio.sleep(max(1, int(cfg.refresh_secs)))
   229:     except asyncio.CancelledError:
   230:         raise
   231:     except KeyboardInterrupt:
   232:         log.info("Arrêt orchestrateur (Ctrl+C)")
   233:     finally:
   234:         cmd_task.cancel()
   235:         try:
   236:             await notifier.send("Bot arrêté proprement 📴")
   237:         except Exception:
   238:             pass

--------------------------------------------------------------------------------
FILE: engine/live/trader.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/live/trader.py
     2: from __future__ import annotations
     3: import math
     4: import time
     5: from dataclasses import dataclass
     6: from pathlib import Path
     7: from typing import Any, Dict, Optional, Sequence
     8: 
     9: @dataclass
    10: class Position:
    11:     symbol: str
    12:     tf: str
    13:     side: str = "flat"   # "long" | "flat"
    14:     entry: float = 0.0
    15:     size: float = 0.0
    16:     trail: Optional[float] = None
    17: 
    18: class OrderLogger:
    19:     def __init__(self, path: Path) -> None:
    20:         self.path = path
    21:         self.path.parent.mkdir(parents=True, exist_ok=True)
    22:         if not self.path.exists():
    23:             self._write(["ts","symbol","tf","action","price","size","reason"])
    24: 
    25:     def _write(self, row: Sequence[str | float | int]) -> None:
    26:         with self.path.open("a", encoding="utf-8") as f:
    27:             f.write(",".join(str(x).replace(",", " ") for x in row) + "\n")
    28: 
    29:     def log(self, **kw) -> None:
    30:         self._write([kw.get("ts", int(time.time()*1000)), kw["symbol"], kw["tf"],
    31:                      kw["action"], kw.get("price", 0.0), kw.get("size", 0.0),
    32:                      kw.get("reason","")])
    33: 
    34: class Trader:
    35:     """
    36:     Gère un état de position très simple (one-way, long only) + logs, et passe
    37:     aux ordres réels si paper_trade=False.
    38:     """
    39:     def __init__(self, *, paper_trade: bool, client: Any | None, order_logger: OrderLogger) -> None:
    40:         self.paper = paper_trade
    41:         self.client = client
    42:         self.log = order_logger
    43:         self.state: Dict[tuple[str,str], Position] = {}
    44: 
    45:     def _pos(self, symbol: str, tf: str) -> Position:
    46:         key = (symbol, tf)
    47:         if key not in self.state:
    48:             self.state[key] = Position(symbol=symbol, tf=tf)
    49:         return self.state[key]
    50: 
    51:     def _order_real_market(self, symbol: str, side: str, size: float) -> None:
    52:         if not self.client:
    53:             return
    54:         try:
    55:             self.client.place_market_order_one_way(symbol, side, size)
    56:         except Exception:
    57:             # on se contente de logguer; l'orchestrateur poursuit
    58:             pass
    59: 
    60:     def compute_size(self, equity: float, price: float, atr: float, risk_pct: float) -> float:
    61:         # risk par unité ~ ATR (garde-fou min)
    62:         risk_per_unit = max(atr, price * 0.002)
    63:         risk_cash = max(0.0, equity * risk_pct)
    64:         units = risk_cash / risk_per_unit if risk_per_unit > 0 else 0.0
    65:         return max(0.0, round(units, 6))
    66: 
    67:     def on_signal(self, *, symbol: str, tf: str, price: float, atr: float,
    68:                   params: Dict[str, float], signal_now: int, signal_prev: int,
    69:                   equity: float = 10_000.0, ts: int | None = None) -> None:
    70:         ts = ts or int(time.time() * 1000)
    71:         p = self._pos(symbol, tf)
    72:         trail_mult = float(params.get("trail_atr_mult", 2.0))
    73:         risk_pct = float(params.get("risk_pct_equity", 0.02))
    74:         if p.side == "flat":
    75:             if signal_prev <= 0 and signal_now > 0:
    76:                 size = self.compute_size(equity, price, atr, risk_pct)
    77:                 p.side = "long"; p.entry = price; p.size = size
    78:                 p.trail = price - trail_mult * atr if atr > 0 else None
    79:                 self.log.log(ts=ts, symbol=symbol, tf=tf, action="BUY", price=price, size=size, reason="ema_cross_up")
    80:                 if not self.paper and size > 0:
    81:                     self._order_real_market(symbol, "buy", size)
    82:         else:
    83:             # update trailing stop
    84:             new_trail = price - trail_mult * atr if atr > 0 else None
    85:             if new_trail is not None and (p.trail is None or new_trail > p.trail):
    86:                 p.trail = new_trail
    87:             # sortie par signal inverse ou par cassure du trail
    88:             exit_by_signal = (signal_prev >= 0 and signal_now < 0)
    89:             exit_by_trail = (p.trail is not None and price < p.trail)
    90:             if exit_by_signal or exit_by_trail:
    91:                 self.log.log(ts=ts, symbol=symbol, tf=tf, action="SELL", price=price, size=p.size,
    92:                              reason="ema_cross_down" if exit_by_signal else "trail_hit")
    93:                 if not self.paper and p.size > 0:
    94:                     self._order_real_market(symbol, "sell", p.size)
    95:                 # flat
    96:                 self.state[(symbol, tf)] = Position(symbol=symbol, tf=tf)

--------------------------------------------------------------------------------
FILE: engine/logging_utils.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Logging helpers for the Scalp bot."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import atexit
     6: import csv
     7: import json
     8: import os
     9: import sqlite3
    10: import time
    11: from pathlib import Path
    12: from typing import Any, Dict, List
    13: 
    14: 
    15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    16:     """Return a callable that logs events as JSON lines.
    17: 
    18:     Parameters
    19:     ----------
    20:     path: str
    21:         Target file path for JSON lines.
    22:     max_bytes: int, optional
    23:         If >0, rotate the file when its size exceeds this value.
    24:     backup_count: int, optional
    25:         Number of rotated files to keep when ``max_bytes`` is set.
    26:     """
    27:     os.makedirs(os.path.dirname(path), exist_ok=True)
    28:     log_file = open(path, "a", encoding="utf-8")
    29: 
    30:     def _close_file() -> None:
    31:         try:
    32:             log_file.close()
    33:         except Exception:
    34:             pass
    35: 
    36:     atexit.register(_close_file)
    37: 
    38:     def _rotate() -> None:
    39:         nonlocal log_file
    40:         log_file.close()
    41:         for i in range(backup_count - 1, 0, -1):
    42:             src = f"{path}.{i}"
    43:             dst = f"{path}.{i + 1}"
    44:             if os.path.exists(src):
    45:                 os.replace(src, dst)
    46:         os.replace(path, f"{path}.1")
    47:         log_file = open(path, "a", encoding="utf-8")
    48: 
    49:     def _log(event: str, payload: Dict[str, Any]) -> None:
    50:         nonlocal log_file
    51:         payload = dict(payload or {})
    52:         payload["event"] = event
    53:         payload["ts"] = int(time.time() * 1000)
    54:         line = json.dumps(payload, ensure_ascii=False)
    55:         if max_bytes and backup_count > 0:
    56:             if log_file.tell() + len(line) + 1 > max_bytes:
    57:                 _rotate()
    58:         log_file.write(line + "\n")
    59:         log_file.flush()
    60: 
    61:     return _log
    62: 
    63: 
    64: class TradeLogger:
    65:     """Helper writing trade information to CSV and SQLite files."""
    66: 
    67:     fields = [
    68:         "pair",
    69:         "tf",
    70:         "dir",
    71:         "entry",
    72:         "sl",
    73:         "tp",
    74:         "score",
    75:         "reasons",
    76:         "pnl",
    77:     ]
    78: 
    79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
    80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
    81:         self.csv_path = csv_path
    82:         self.sqlite_path = sqlite_path
    83: 
    84:         # Ensure CSV has header
    85:         if not os.path.exists(csv_path):
    86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
    87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
    88:                 writer.writeheader()
    89: 
    90:         # Setup SQLite store
    91:         self.conn = sqlite3.connect(sqlite_path)
    92:         cur = self.conn.cursor()
    93:         cur.execute(
    94:             """
    95:             CREATE TABLE IF NOT EXISTS trades (
    96:                 pair TEXT,
    97:                 tf TEXT,
    98:                 dir TEXT,
    99:                 entry REAL,
   100:                 sl REAL,
   101:                 tp REAL,
   102:                 score REAL,
   103:                 reasons TEXT,
   104:                 pnl REAL
   105:             )
   106:             """
   107:         )
   108:         self.conn.commit()
   109:         atexit.register(self.conn.close)
   110: 
   111:     def log(self, data: Dict[str, Any]) -> None:
   112:         row = {k: data.get(k) for k in self.fields}
   113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
   114:             writer = csv.DictWriter(f, fieldnames=self.fields)
   115:             writer.writerow(row)
   116:         cur = self.conn.cursor()
   117:         cur.execute(
   118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
   119:             (
   120:                 row["pair"],
   121:                 row["tf"],
   122:                 row["dir"],
   123:                 row["entry"],
   124:                 row["sl"],
   125:                 row["tp"],
   126:                 row["score"],
   127:                 row["reasons"],
   128:                 row["pnl"],
   129:             ),
   130:         )
   131:         self.conn.commit()
   132: 
   133: 
   134: BASE_DIR = Path(__file__).resolve().parents[2]
   135: 
   136: 
   137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
   138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
   139:     path.parent.mkdir(parents=True, exist_ok=True)
   140:     file_exists = path.exists()
   141:     with path.open("a", newline="", encoding="utf-8") as f:
   142:         writer = csv.DictWriter(f, fieldnames=fields)
   143:         if not file_exists:
   144:             writer.writeheader()
   145:         writer.writerow({k: row.get(k) for k in fields})
   146: 
   147: 
   148: def log_position(data: Dict[str, Any]) -> None:
   149:     """Log a closed position to ``../positions.csv``."""
   150:     fields = [
   151:         "timestamp",
   152:         "pair",
   153:         "direction",
   154:         "entry",
   155:         "exit",
   156:         "pnl_pct",
   157:         "fee_rate",
   158:         "notes",
   159:     ]
   160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
   161: 
   162: 
   163: def log_operation_memo(data: Dict[str, Any]) -> None:
   164:     """Log operation details to ``../operations_memo.csv``."""
   165:     fields = ["timestamp", "pair", "details"]
   166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)

--------------------------------------------------------------------------------
FILE: engine/metrics.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Utility metrics for trading calculations."""
     2: 
     3: from __future__ import annotations
     4: 
     5: 
     6: from typing import Iterable
     7: 
     8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
     9: 
    10: 
    11: def calc_pnl_pct(
    12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
    13: ) -> float:
    14:     """Return percentage PnL between entry and exit prices minus fees.
    15: 
    16: 
    17:     Parameters
    18:     ----------
    19:     entry_price: float
    20:         Trade entry price (>0).
    21:     exit_price: float
    22:         Trade exit price (>0).
    23:     side: int
    24:         +1 for long, -1 for short.
    25:     fee_rate: float, optional
    26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
    27:         applied twice (entry + exit).
    28:     """
    29:     if entry_price <= 0 or exit_price <= 0:
    30:         raise ValueError("Prices must be positive")
    31:     if side not in (1, -1):
    32:         raise ValueError("side must be +1 (long) or -1 (short)")
    33: 
    34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
    36:     return pnl - fee_pct
    37: 
    38: 
    39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
    41: 
    42: 
    43:     Parameters
    44:     ----------
    45:     prices:
    46:         Ordered sequence of closing prices.
    47:     period:
    48:         Number of periods to use for the calculation. Must be positive and the
    49:         length of ``prices`` must be at least ``period + 1``.
    50:     """
    51: 
    52:     prices_list = [float(p) for p in prices]
    53: 
    54:     if period <= 0:
    55:         raise ValueError("period must be positive")
    56:     if len(prices_list) < period + 1:
    57: 
    58:         raise ValueError("len(prices) must be >= period + 1")
    59: 
    60:     gains: list[float] = []
    61:     losses: list[float] = []
    62:     for i in range(1, period + 1):
    63: 
    64:         diff = prices_list[i] - prices_list[i - 1]
    65: 
    66:         if diff >= 0:
    67:             gains.append(diff)
    68:             losses.append(0.0)
    69:         else:
    70:             gains.append(0.0)
    71:             losses.append(-diff)
    72: 
    73:     avg_gain = sum(gains) / period
    74:     avg_loss = sum(losses) / period
    75: 
    76:     for i in range(period + 1, len(prices_list)):
    77:         diff = prices_list[i] - prices_list[i - 1]
    78: 
    79:         gain = max(diff, 0.0)
    80:         loss = max(-diff, 0.0)
    81:         avg_gain = (avg_gain * (period - 1) + gain) / period
    82:         avg_loss = (avg_loss * (period - 1) + loss) / period
    83: 
    84:     if avg_gain == 0 and avg_loss == 0:
    85:         return 50.0
    86:     if avg_loss == 0:
    87:         return 100.0
    88:     if avg_gain == 0:
    89:         return 0.0
    90:     rs = avg_gain / avg_loss
    91:     return 100.0 - (100.0 / (1.0 + rs))
    92: 
    93: 
    94: def calc_atr(
    95:     highs: Iterable[float],
    96:     lows: Iterable[float],
    97:     closes: Iterable[float],
    98:     period: int = 14,
    99: ) -> float:
   100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
   101: 
   102: 
   103:     Parameters
   104:     ----------
   105:     highs, lows, closes:
   106:         Ordered sequences of high, low and close prices. All sequences must
   107:         have the same length and contain at least ``period + 1`` elements.
   108:     period:
   109:         Number of periods to use for the calculation. Must be positive.
   110:     """
   111: 
   112:     highs_list = [float(h) for h in highs]
   113:     lows_list = [float(low) for low in lows]
   114:     closes_list = [float(c) for c in closes]
   115: 
   116:     length = len(highs_list)
   117:     if length != len(lows_list) or length != len(closes_list):
   118: 
   119:         raise ValueError("Input sequences must have the same length")
   120:     if period <= 0:
   121:         raise ValueError("period must be positive")
   122:     if length < period + 1:
   123:         raise ValueError("Input sequences must have at least period + 1 elements")
   124: 
   125:     trs: list[float] = []
   126:     for i in range(1, len(highs_list)):
   127:         tr = max(
   128:             highs_list[i] - lows_list[i],
   129:             abs(highs_list[i] - closes_list[i - 1]),
   130:             abs(lows_list[i] - closes_list[i - 1]),
   131:         )
   132:         trs.append(tr)
   133: 
   134:     atr = sum(trs[:period]) / period
   135:     for tr in trs[period:]:
   136:         atr = (atr * (period - 1) + tr) / period
   137:     return atr
   138: 
   139: 
   140: def calc_macd(
   141:     prices: Sequence[float],
   142:     fast: int = 12,
   143:     slow: int = 26,
   144:     signal: int = 9,
   145: ) -> tuple[float, float, float]:
   146:     """Return MACD, signal line and histogram values.
   147: 
   148:     The implementation computes exponential moving averages using Wilder's
   149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
   150:     """
   151: 
   152:     prices_list = [float(p) for p in prices]
   153:     if fast <= 0 or slow <= 0 or signal <= 0:
   154:         raise ValueError("periods must be positive")
   155:     min_len = max(fast, slow) + signal
   156:     if len(prices_list) < min_len:
   157:         raise ValueError("len(prices) must be >= slow + signal")
   158: 
   159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
   160:         k = 2.0 / (window + 1.0)
   161:         out = [float(series[0])]
   162:         for x in series[1:]:
   163:             out.append(float(x) * k + out[-1] * (1.0 - k))
   164:         return out
   165: 
   166:     fast_ema = _ema_series(prices_list, fast)
   167:     slow_ema = _ema_series(prices_list, slow)
   168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
   169:     signal_series = _ema_series(macd_series, signal)
   170:     macd_val = macd_series[-1]
   171:     signal_val = signal_series[-1]
   172:     hist = macd_val - signal_val
   173:     return macd_val, signal_val, hist
   174: 
   175: 
   176: def backtest_position(
   177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
   178: ) -> bool:
   179:     """Run a basic backtest to verify a position's coherence.
   180: 
   181:     Parameters
   182:     ----------
   183:     prices: list[float]
   184:         Sequential list of prices to evaluate.
   185:     entry_idx: int
   186:         Index in ``prices`` where the position is opened.
   187:     exit_idx: int
   188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
   189:     side: int
   190:         +1 for long, -1 for short.
   191: 
   192:     Returns
   193:     -------
   194:     bool
   195:         ``True`` if the resulting PnL is non-negative, meaning the position is
   196:         coherent with the direction of price movement. ``False`` otherwise.
   197:     """
   198:     if side not in (1, -1):
   199:         raise ValueError("side must be +1 (long) or -1 (short)")
   200:     if not (0 <= entry_idx < exit_idx < len(prices)):
   201:         raise ValueError(
   202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
   203:         )
   204: 
   205:     entry_price = float(prices[entry_idx])
   206:     exit_price = float(prices[exit_idx])
   207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
   208:     return pnl >= 0.0

--------------------------------------------------------------------------------
FILE: engine/pairs/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/pairs/__init__.py
     2: from .selector import PairMetrics, select_top_pairs  # re-export
     3: __all__ = ["PairMetrics", "select_top_pairs"]

--------------------------------------------------------------------------------
FILE: engine/pairs/selector.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/pairs/selector.py
     2: from __future__ import annotations
     3: import math, statistics as stats, time
     4: from dataclasses import dataclass
     5: from typing import Any, Iterable, List, Dict, Tuple
     6: 
     7: @dataclass
     8: class PairMetrics:
     9:     symbol: str
    10:     vol_usd_24h: float     # volume $ 24h (proxy)
    11:     atr_pct_24h: float     # volatilité (ATR% sur close)
    12:     score: float           # score combiné
    13: 
    14: def _ohlcv_to_atr_pct(rows: List[List[float]]) -> float:
    15:     """rows: [ts,o,h,l,c,v]. Renvoie ATR% moyen ~ 24h (proxy simple)."""
    16:     if not rows:
    17:         return 0.0
    18:     atr_vals: List[float] = []
    19:     for i in range(1, len(rows)):
    20:         o,h,l,c,_ = rows[i][1], rows[i][2], rows[i][3], rows[i][4], rows[i][5] if len(rows[i])>5 else 0.0
    21:         pc = rows[i-1][4]
    22:         tr = max(h-l, abs(h-pc), abs(l-pc))
    23:         if c:
    24:             atr_vals.append(tr / c)
    25:     if not atr_vals:
    26:         return 0.0
    27:     return float(sum(atr_vals)/len(atr_vals))
    28: 
    29: def _norm(vals: List[float]) -> List[float]:
    30:     if not vals: return []
    31:     lo, hi = min(vals), max(vals)
    32:     if hi <= 0 or hi == lo:
    33:         return [0.0 for _ in vals]
    34:     return [(v - lo)/(hi - lo) for v in vals]
    35: 
    36: def select_top_pairs(
    37:     exchange: Any,
    38:     *,
    39:     universe: Iterable[str] | None = None,
    40:     timeframe: str = "5m",
    41:     lookback_candles: int = 300,   # ~ 24h en 5m
    42:     top_n: int = 10,
    43:     vol_weight: float = 0.6,
    44:     volat_weight: float = 0.4,
    45: ) -> List[PairMetrics]:
    46:     """
    47:     Récupère OHLCV pour chaque symbole du 'universe' (sinon via tickers),
    48:     calcule volume USD et ATR% 24h, puis score = 0.6*norm(volume) + 0.4*norm(volatilité).
    49:     Retourne le Top N.
    50:     """
    51:     # 1) Construire l’univers
    52:     symbols: List[str]
    53:     if universe:
    54:         symbols = list(dict.fromkeys([s.replace("_","").upper() for s in universe]))
    55:     else:
    56:         # essaie via exchange.get_ticker() (liste complète)
    57:         try:
    58:             data = exchange.get_ticker().get("data") or []
    59:             symbols = [str(d.get("symbol","")).replace("_","").upper() for d in data if d.get("symbol")]
    60:         except Exception:
    61:             symbols = ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","LTCUSDT","LINKUSDT","MATICUSDT"]
    62: 
    63:     # 2) Collecte OHLCV + proxies volume
    64:     metrics: List[Tuple[str, float, float]] = []  # (symbol, vol_usd, atr_pct)
    65:     for sym in symbols:
    66:         try:
    67:             ohlcv = exchange.get_klines(sym, interval=timeframe, limit=lookback_candles).get("data") or []
    68:             if len(ohlcv) < 50:
    69:                 continue
    70:             atr_pct = _ohlcv_to_atr_pct(ohlcv)
    71:             # proxy volume $ : somme(close*volume)
    72:             vol_usd = 0.0
    73:             for r in ohlcv[-288:]:  # ~ dernier jour
    74:                 close = float(r[4]); vol = float(r[5]) if len(r)>5 else 0.0
    75:                 vol_usd += close * vol
    76:             metrics.append((sym, vol_usd, atr_pct))
    77:         except Exception:
    78:             continue
    79: 
    80:     if not metrics:
    81:         return []
    82: 
    83:     vols = [m[1] for m in metrics]
    84:     vols_norm = _norm(vols)
    85:     atrs = [m[2] for m in metrics]
    86:     atrs_norm = _norm(atrs)
    87: 
    88:     scored: List[PairMetrics] = []
    89:     for (sym, vol_usd, atr_pct), nv, na in zip(metrics, vols_norm, atrs_norm):
    90:         s = vol_weight*nv + volat_weight*na
    91:         scored.append(PairMetrics(symbol=sym, vol_usd_24h=vol_usd, atr_pct_24h=atr_pct, score=s))
    92: 
    93:     scored.sort(key=lambda x: x.score, reverse=True)
    94:     return scored[:top_n]

--------------------------------------------------------------------------------
FILE: engine/pairs.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Utilities to select trading pairs and detect signals."""
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Callable
     4: from engine.strategy import Signal
     5: 
     6: from engine.bot_config import CONFIG
     7: from engine.strategy import ema as default_ema, cross as default_cross
     8: from engine.notifier import notify
     9: 
    10: 
    11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    12:     """Return all trading pairs using the client's ``get_ticker`` method."""
    13:     tick = client.get_ticker()
    14:     data = tick.get("data") if isinstance(tick, dict) else []
    15:     if not data:
    16:         return []
    17:     return data if isinstance(data, list) else [data]
    18: 
    19: 
    20: def filter_trade_pairs(
    21:     client: Any,
    22:     *,
    23:     volume_min: float = 5_000_000,
    24:     max_spread_bps: float = 5.0,
    25:     top_n: int = 40,
    26: ) -> List[Dict[str, Any]]:
    27:     """Filter pairs by volume and spread."""
    28:     pairs = get_trade_pairs(client)
    29:     eligible: List[Dict[str, Any]] = []
    30: 
    31:     for info in pairs:
    32:         sym = info.get("symbol")
    33:         if not sym:
    34:             continue
    35:         try:
    36:             vol = float(info.get("volume", 0))
    37:         except (TypeError, ValueError):
    38:             continue
    39:         if vol < volume_min:
    40:             continue
    41:         try:
    42:             bid = float(info.get("bidPrice", 0))
    43:             ask = float(info.get("askPrice", 0))
    44:         except (TypeError, ValueError):
    45:             continue
    46:         if bid <= 0 or ask <= 0:
    47:             continue
    48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
    49:         if spread_bps >= max_spread_bps:
    50:             continue
    51:         eligible.append(info)
    52: 
    53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    54:     return eligible[:top_n]
    55: 
    56: 
    57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
    58:     """Return ``top_n`` pairs sorted by ``key``."""
    59:     pairs = get_trade_pairs(client)
    60: 
    61:     def volume(row: Dict[str, Any]) -> float:
    62:         try:
    63:             return float(row.get(key, 0))
    64:         except (TypeError, ValueError):
    65:             return 0.0
    66: 
    67:     pairs.sort(key=volume, reverse=True)
    68:     return pairs[:top_n]
    69: 
    70: 
    71: def _ancienne_impl(
    72:     client: Any,
    73:     pairs: List[Dict[str, Any]],
    74:     *,
    75:     interval: str = "1m",
    76:     ema_fast_n: Optional[int] = None,
    77:     ema_slow_n: Optional[int] = None,
    78:     ema_func=default_ema,
    79:     cross_func=default_cross,
    80: ) -> List[Dict[str, Any]]:
    81:     """Original implementation returning dicts."""
    82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    84:     results: List[Dict[str, Any]] = []
    85: 
    86:     for info in pairs:
    87:         symbol = info.get("symbol")
    88:         if not symbol:
    89:             continue
    90:         k = client.get_kline(symbol, interval=interval)
    91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
    92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
    93:             continue
    94:         efull = ema_func(closes, ema_fast_n)
    95:         eslow = ema_func(closes, ema_slow_n)
    96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
    97:         if signal == 1:
    98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
    99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
   100:         elif signal == -1:
   101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
   102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
   103:     return results
   104: 
   105: 
   106: def _to_signal(d: dict) -> Signal:
   107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
   108:     return Signal(
   109:         symbol=d.get("symbol"),
   110:         side=side,
   111:         entry=float(d.get("price", d.get("entry", 0))),
   112:         sl=float(d.get("sl", 0)),
   113:         tp1=float(d.get("tp1", 0)) or None,
   114:         tp2=float(d.get("tp2", 0)) or None,
   115:         score=d.get("score"),
   116:         quality=d.get("quality"),
   117:         reasons=d.get("reasons", []),
   118:     )
   119: 
   120: 
   121: def find_trade_positions(
   122:     client: Any,
   123:     pairs: List[Dict[str, Any]],
   124:     *,
   125:     interval: str = "1m",
   126:     ema_fast_n: Optional[int] = None,
   127:     ema_slow_n: Optional[int] = None,
   128:     ema_func=default_ema,
   129:     cross_func=default_cross,
   130: ) -> List[Signal]:
   131:     raw = _ancienne_impl(
   132:         client,
   133:         pairs,
   134:         interval=interval,
   135:         ema_fast_n=ema_fast_n,
   136:         ema_slow_n=ema_slow_n,
   137:         ema_func=ema_func,
   138:         cross_func=cross_func,
   139:     )
   140:     return [_to_signal(x) for x in raw]
   141: 
   142: 
   143: def send_selected_pairs(
   144:     client: Any,
   145:     top_n: int = 40,
   146:     *,
   147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
   148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
   149: ) -> Dict[str, str]:
   150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
   151: 
   152:     Returns the payload sent to ``notify_fn``. The mapping contains the
   153:     comma-separated symbols for each color group (``green``, ``orange`` and
   154:     ``red``) or an empty dictionary when no pairs are available.
   155:     """
   156: 
   157:     def split_symbol(sym: str) -> tuple[str, str]:
   158:         if "_" in sym:
   159:             left, right = sym.split("_", 1)
   160:             # Legacy style: BTC_USDT
   161:             if len(right) <= 4:
   162:                 return left, right
   163:             # Bitget futures style: BTCUSDT_UMCBL
   164:             main = left
   165:             if main.endswith("USDT"):
   166:                 return main[:-4], "USDT"
   167:             if main.endswith("USDC"):
   168:                 return main[:-4], "USDC"
   169:             if main.endswith("USD"):
   170:                 return main[:-3], "USD"
   171:             return main, ""
   172:         if sym.endswith("USDT"):
   173:             return sym[:-4], "USDT"
   174:         if sym.endswith("USDC"):
   175:             return sym[:-4], "USDC"
   176:         if sym.endswith("USD"):
   177:             return sym[:-3], "USD"
   178:         return sym, ""
   179: 
   180:     pairs = select_fn(client, top_n=top_n * 3)
   181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
   182:     by_base: Dict[str, Dict[str, Any]] = {}
   183:     for info in pairs:
   184:         sym = info.get("symbol")
   185:         if not sym:
   186:             continue
   187:         norm_sym = sym.split("_")[0].upper()
   188:         if allowed and norm_sym not in allowed:
   189:             continue
   190:         base, quote = split_symbol(sym)
   191:         existing = by_base.get(base)
   192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
   193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
   194:             by_base[base] = {"data": info, "quote": quote}
   195: 
   196:     unique = sorted(
   197:         (v["data"] for v in by_base.values()),
   198:         key=lambda row: float(row.get("volume", 0)),
   199:         reverse=True,
   200:     )
   201:     symbols: list[str] = []
   202:     for row in unique[:top_n]:
   203:         sym = row.get("symbol")
   204:         if not sym:
   205:             continue
   206:         base, _ = split_symbol(sym)
   207:         symbols.append(base)
   208:     if symbols:
   209:         n = len(symbols)
   210:         third = max(n // 3, 1)
   211:         green = symbols[:third]
   212:         orange = symbols[third : 2 * third]
   213:         red = symbols[2 * third :]
   214:         payload: Dict[str, str] = {}
   215:         if green:
   216:             payload["green"] = ", ".join(green)
   217:         if orange:
   218:             payload["orange"] = ", ".join(orange)
   219:         if red:
   220:             payload["red"] = ", ".join(red)
   221:         notify_fn("pair_list", payload)
   222:         return payload
   223:     return {}
   224: 
   225: 
   226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
   227:     """Return a heat score combining volatility, volume and a news flag."""
   228:     mult = 2.0 if news else 1.0
   229:     return volatility * volume * mult
   230: 
   231: 
   232: def select_top_heat_pairs(
   233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
   234: ) -> List[Dict[str, Any]]:
   235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
   236: 
   237:     scored: List[Dict[str, Any]] = []
   238:     for info in pairs:
   239:         try:
   240:             vol = float(info.get("volatility", 0))
   241:             volume = float(info.get("volume", 0))
   242:         except (TypeError, ValueError):
   243:             continue
   244:         score = heat_score(vol, volume, bool(info.get("news")))
   245:         row = dict(info)
   246:         row["heat_score"] = score
   247:         scored.append(row)
   248: 
   249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
   250:     return scored[:top_n]
   251: 
   252: 
   253: def decorrelate_pairs(
   254:     pairs: List[Dict[str, Any]],
   255:     corr: Dict[str, Dict[str, float]],
   256:     *,
   257:     threshold: float = 0.8,
   258:     top_n: int = 3,
   259: ) -> List[Dict[str, Any]]:
   260:     """Return top pairs while avoiding highly correlated symbols.
   261: 
   262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
   263:     pairs are considered too correlated when the absolute value of the
   264:     correlation exceeds ``threshold``.
   265:     """
   266: 
   267:     selected: List[Dict[str, Any]] = []
   268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
   269:         sym = info.get("symbol")
   270:         if not sym:
   271:             continue
   272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
   273:             selected.append(info)
   274:         if len(selected) >= top_n:
   275:             break
   276:     return selected

--------------------------------------------------------------------------------
FILE: engine/positions/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/positions/state.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: from dataclasses import dataclass, field
     3: from enum import Enum, auto
     4: from typing import List, Optional
     5: import time
     6: 
     7: class PositionStatus(Enum):
     8:     IDLE = auto()
     9:     PENDING_ENTRY = auto()
    10:     OPEN = auto()
    11:     PENDING_EXIT = auto()
    12:     CLOSED = auto()
    13: 
    14: class PositionSide(Enum):
    15:     LONG = 1
    16:     SHORT = -1
    17: 
    18: @dataclass
    19: class Fill:
    20:     order_id: str
    21:     trade_id: str
    22:     price: float
    23:     qty: float
    24:     fee: float
    25:     ts: int
    26: 
    27: @dataclass
    28: class PositionState:
    29:     symbol: str
    30:     side: PositionSide
    31:     status: PositionStatus = PositionStatus.IDLE
    32:     entry_order_id: Optional[str] = None
    33:     exit_order_id: Optional[str] = None
    34:     req_qty: float = 0.0
    35:     filled_qty: float = 0.0
    36:     avg_entry_price: float = 0.0
    37:     avg_exit_price: float = 0.0
    38:     sl: Optional[float] = None
    39:     tp: Optional[float] = None
    40:     realized_pnl: float = 0.0
    41:     fees: float = 0.0
    42:     opened_ts: Optional[int] = None
    43:     closed_ts: Optional[int] = None
    44:     fills: List[Fill] = field(default_factory=list)
    45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
    46: 
    47:     def apply_fill_entry(self, f: Fill) -> None:
    48:         self.fills.append(f)
    49:         self.filled_qty += f.qty
    50:         # moyenne pondérée
    51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
    52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
    53:         self.fees += abs(f.fee)
    54:         if self.opened_ts is None:
    55:             self.opened_ts = f.ts
    56:         if self.filled_qty > 1e-12:
    57:             self.status = PositionStatus.OPEN
    58: 
    59:     def apply_fill_exit(self, f: Fill) -> None:
    60:         self.fills.append(f)
    61:         qty = min(self.filled_qty, f.qty)
    62:         # realized pnl sur la quantité fermée
    63:         if self.side == PositionSide.LONG:
    64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
    65:         else:
    66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
    67:         self.fees += abs(f.fee)
    68:         self.filled_qty = max(0.0, self.filled_qty - qty)
    69:         # moyenne de sortie indicative
    70:         closed_q = (self.req_qty - self.filled_qty)
    71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
    72:         if self.filled_qty <= 1e-12:
    73:             self.status = PositionStatus.CLOSED
    74:             self.closed_ts = f.ts
    75: 

--------------------------------------------------------------------------------
FILE: engine/risk/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/risk/__init__.py
     2: from .manager import (
     3:     Caps,
     4:     compute_size,
     5:     calc_position_size,  # alias legacy
     6:     RiskManager,         # shim legacy
     7: )
     8: 
     9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]

--------------------------------------------------------------------------------
FILE: engine/risk/manager.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/risk/manager.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any
     5: 
     6: @dataclass
     7: class Caps:
     8:     min_qty: float = 0.0
     9:     min_notional: float = 0.0
    10:     max_leverage: float = 20.0
    11: 
    12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
    13:     if not caps_by_symbol:
    14:         return Caps()
    15:     c = caps_by_symbol.get(symbol, {})
    16:     return Caps(
    17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
    18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
    19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
    20:     )
    21: 
    22: def compute_size(
    23:     *,
    24:     symbol: str,
    25:     price: float,
    26:     balance_cash: float,
    27:     risk_pct: float = 0.5,
    28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
    29: ) -> float:
    30:     """Sizing robuste avec gardes min_notional / min_qty."""
    31:     price = max(1e-9, float(price))
    32:     balance_cash = max(0.0, float(balance_cash))
    33:     risk_pct = max(0.0, float(risk_pct))
    34: 
    35:     notionnel = balance_cash * risk_pct
    36:     qty = notionnel / price
    37: 
    38:     caps = _get_caps(caps_by_symbol, symbol)
    39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
    40:         qty = caps.min_notional / price
    41:     if caps.min_qty > 0 and qty < caps.min_qty:
    42:         qty = caps.min_qty
    43:     return max(0.0, qty)
    44: 
    45: # --- Shims pour compatibilité ancienne API -----------------------------------
    46: 
    47: def calc_position_size(symbol: str, price: float, balance_cash: float,
    48:                        risk_pct: float = 0.5,
    49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
    50:     """Alias legacy → compute_size."""
    51:     return compute_size(
    52:         symbol=symbol, price=price, balance_cash=balance_cash,
    53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
    54:     )
    55: 
    56: class RiskManager:
    57:     """
    58:     Shim minimal compatible avec l'ancien code:
    59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
    60:       qty = rm.size(symbol, price, balance_cash)
    61:     """
    62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
    63:         self.risk_pct = float(risk_pct)
    64:         self.caps_by_symbol = caps_by_symbol or {}
    65: 
    66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
    67:         return compute_size(
    68:             symbol=symbol, price=price, balance_cash=balance_cash,
    69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
    70:         )

--------------------------------------------------------------------------------
FILE: engine/selection/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Pair selection helpers for the Scalp bot.
     2: 
     3: This package exposes two utilities used during the preparation phase of the
     4: trading strategy:
     5: 
     6: ``scan_pairs``
     7:     Performs the first level market scan by filtering pairs based on volume,
     8:     spread and hourly volatility.
     9: 
    10: ``select_active_pairs``
    11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
    12:     crossover and a sufficiently high ATR.
    13: """
    14: 
    15: from .scanner import scan_pairs
    16: from .momentum import select_active_pairs
    17: 
    18: __all__ = ["scan_pairs", "select_active_pairs"]
    19: 

--------------------------------------------------------------------------------
FILE: engine/selection/momentum.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Utilities to select pairs exhibiting strong momentum."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List, Sequence
     6: 
     7: from ..metrics import calc_atr
     8: 
     9: 
    10: def ema(series: Sequence[float], window: int) -> List[float]:
    11:     """Simple exponential moving average implementation."""
    12: 
    13:     if window <= 1 or not series:
    14:         return list(series)
    15:     k = 2.0 / (window + 1.0)
    16:     out: List[float] = [float(series[0])]
    17:     prev = out[0]
    18:     for x in series[1:]:
    19:         prev = float(x) * k + prev * (1.0 - k)
    20:         out.append(prev)
    21:     return out
    22: 
    23: 
    24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
    26: 
    27:     if prev_fast <= prev_slow and last_fast > last_slow:
    28:         return 1
    29:     if prev_fast >= prev_slow and last_fast < last_slow:
    30:         return -1
    31:     return 0
    32: 
    33: 
    34: def _quantile(values: Sequence[float], q: float) -> float:
    35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
    36: 
    37:     if not values:
    38:         return 0.0
    39:     q = min(max(q, 0.0), 1.0)
    40:     vals = sorted(values)
    41:     idx = int((len(vals) - 1) * q)
    42:     return vals[idx]
    43: 
    44: 
    45: def select_active_pairs(
    46:     client: Any,
    47:     pairs: Sequence[Dict[str, Any]],
    48:     *,
    49:     interval: str = "Min5",
    50:     ema_fast: int = 20,
    51:     ema_slow: int = 50,
    52:     atr_period: int = 14,
    53:     atr_quantile: float = 0.5,
    54:     top_n: int = 5,
    55: ) -> List[Dict[str, Any]]:
    56:     """Return pairs with an EMA crossover and high ATR.
    57: 
    58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    59:     Among those candidates, the Average True Range is computed and only pairs
    60:     whose ATR is above the provided quantile are returned.  The resulting
    61:     dictionaries include an ``atr`` key for convenience.
    62:     """
    63: 
    64:     candidates: List[Dict[str, Any]] = []
    65:     atrs: List[float] = []
    66: 
    67:     for info in pairs:
    68:         sym = info.get("symbol")
    69:         if not sym:
    70:             continue
    71:         k = client.get_kline(sym, interval=interval)
    72:         kdata = k.get("data") if isinstance(k, dict) else {}
    73:         closes = kdata.get("close", [])
    74:         highs = kdata.get("high", [])
    75:         lows = kdata.get("low", [])
    76:         if len(closes) < max(ema_slow, atr_period) + 2:
    77:             continue
    78:         efast = ema(closes, ema_fast)
    79:         eslow = ema(closes, ema_slow)
    80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
    81:             continue
    82:         atr_val = calc_atr(highs, lows, closes, atr_period)
    83:         row = dict(info)
    84:         row["atr"] = atr_val
    85:         candidates.append(row)
    86:         atrs.append(atr_val)
    87: 
    88:     if not candidates:
    89:         return []
    90: 
    91:     threshold = _quantile(atrs, atr_quantile)
    92:     selected = [row for row in candidates if row["atr"] >= threshold]
    93:     selected.sort(key=lambda r: r["atr"], reverse=True)
    94:     return selected[:top_n]
    95: 
    96: 
    97: __all__ = ["select_active_pairs"]
    98: 

--------------------------------------------------------------------------------
FILE: engine/selection/scanner.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Utilities for scanning tradable pairs on the exchange."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List
     6: 
     7: 
     8: def scan_pairs(
     9:     client: Any,
    10:     *,
    11:     volume_min: float = 5_000_000,
    12:     max_spread_bps: float = 5.0,
    13:     min_hourly_vol: float = 0.0,
    14:     top_n: int = 40,
    15: ) -> List[Dict[str, Any]]:
    16:     """Return pairs satisfying basic liquidity and volatility filters.
    17: 
    18:     Parameters
    19:     ----------
    20:     client: Any
    21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    22:     volume_min: float, optional
    23:         Minimum 24h volume required to keep a pair.
    24:     max_spread_bps: float, optional
    25:         Maximum allowed bid/ask spread expressed in basis points.
    26:     min_hourly_vol: float, optional
    27:         Minimum volatility over the last hour expressed as ``(high - low) /
    28:         close``.  When set to ``0`` the filter is disabled.
    29:     top_n: int, optional
    30:         Limit the number of returned pairs.
    31:     """
    32: 
    33:     tick = client.get_ticker()
    34:     data = tick.get("data") if isinstance(tick, dict) else []
    35:     if not isinstance(data, list):
    36:         data = [data]
    37: 
    38:     eligible: List[Dict[str, Any]] = []
    39: 
    40:     for row in data:
    41:         sym = row.get("symbol")
    42:         if not sym:
    43:             continue
    44:         try:
    45:             vol = float(row.get("volume", 0))
    46:             bid = float(row.get("bidPrice", 0))
    47:             ask = float(row.get("askPrice", 0))
    48:         except (TypeError, ValueError):
    49:             continue
    50:         if vol < volume_min or bid <= 0 or ask <= 0:
    51:             continue
    52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
    53:         if spread_bps >= max_spread_bps:
    54:             continue
    55: 
    56:         if min_hourly_vol > 0:
    57:             k = client.get_kline(sym, interval="Min60")
    58:             kdata = k.get("data") if isinstance(k, dict) else {}
    59:             highs = kdata.get("high", [])
    60:             lows = kdata.get("low", [])
    61:             closes = kdata.get("close", [])
    62:             if not highs or not lows or not closes:
    63:                 continue
    64:             try:
    65:                 h = float(highs[-1])
    66:                 l = float(lows[-1])
    67:                 c = float(closes[-1])
    68:             except (TypeError, ValueError):
    69:                 continue
    70:             hourly_vol = (h - l) / c if c else 0.0
    71:             if hourly_vol < min_hourly_vol:
    72:                 continue
    73: 
    74:         eligible.append(row)
    75: 
    76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    77:     return eligible[:top_n]
    78: 
    79: 
    80: __all__ = ["scan_pairs"]
    81: 

--------------------------------------------------------------------------------
FILE: engine/selfcheck.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/selfcheck.py
     2: from __future__ import annotations
     3: import os, sys, importlib, traceback
     4: from pathlib import Path
     5: 
     6: NOTEBOOKS = Path("/notebooks")
     7: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
     8: 
     9: def _mask(val: str) -> str:
    10:     if not val: return ""
    11:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
    12: 
    13: def _try_import(modname: str):
    14:     try:
    15:         m = importlib.import_module(modname)
    16:         return True, m
    17:     except Exception:
    18:         return False, traceback.format_exc()
    19: 
    20: def preflight(verbose: bool = False) -> list[str]:
    21:     """
    22:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
    23:     Ne lève pas d'exception. N'écrit que de l'info lisible.
    24:     """
    25:     issues: list[str] = []
    26:     # s'assurer que le repo est bien dans sys.path
    27:     if str(REPO) not in sys.path:
    28:         sys.path.insert(0, str(REPO))
    29: 
    30:     print("=== SCALPER PREFLIGHT ===")
    31:     print(f"[i] Repo: {REPO}")
    32:     print(f"[i] Python: {sys.version.split()[0]}")
    33: 
    34:     # backtest API
    35:     ok, mod = _try_import("engine.backtest")
    36:     if not ok:
    37:         print("[✗] Import engine.backtest KO")
    38:         if verbose: print(mod)  # ici 'mod' contient la trace
    39:         issues.append("backtest import")
    40:     else:
    41:         has_single = hasattr(mod, "run_single")
    42:         has_multi  = hasattr(mod, "run_multi")
    43:         print(f"[✓] engine.backtest: run_single={has_single} run_multi={has_multi}")
    44:         if not (has_single and has_multi):
    45:             issues.append("backtest API incomplète")
    46: 
    47:     # trade_utils
    48:     ok, mod = _try_import("engine.trade_utils")
    49:     if not ok:
    50:         print("[✗] Import engine.trade_utils KO")
    51:         if verbose: print(mod)
    52:         issues.append("trade_utils import")
    53:     else:
    54:         print(f"[✓] engine.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
    55: 
    56:     # fees
    57:     ok, mod = _try_import("engine.exchange.fees")
    58:     if not ok:
    59:         print("[✗] Import engine.exchange.fees KO")
    60:         if verbose: print(mod)
    61:         issues.append("fees import")
    62:     else:
    63:         need = {"get_fee", "load_bitget_fees"}
    64:         miss = [n for n in need if not hasattr(mod, n)]
    65:         if miss: issues.append("fees API manquante: " + ",".join(miss))
    66:         print("[✓] engine.exchange.fees OK")
    67: 
    68:     # notify/commands/backtest_telegram/orchestrator
    69:     for name, required in [
    70:         ("engine.live.notify", ("build_notifier_and_stream",)),
    71:         ("engine.live.commands", ("CommandHandler",)),
    72:         ("engine.live.backtest_telegram", ("handle_backtest_command",)),
    73:         ("engine.live.orchestrator", ("run_orchestrator", "Orchestrator")),
    74:     ]:
    75:         ok, mod = _try_import(name)
    76:         if not ok:
    77:             print(f"[✗] Import {name} KO")
    78:             if verbose: print(mod)
    79:             issues.append(f"{name} import")
    80:         else:
    81:             miss = [a for a in required if not hasattr(mod, a)]
    82:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
    83:             print(f"[✓] {name} OK")
    84: 
    85:     # ENV (masqué)
    86:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
    87:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
    88:     gu   = os.getenv("GIT_USER", "")
    89:     gt   = os.getenv("GIT_TOKEN", "")
    90:     print("\n-- ENV --")
    91:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
    92:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
    93:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
    94:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
    95: 
    96:     # Data
    97:     data_dir = (REPO / "data")
    98:     print("\n-- DATA --")
    99:     if data_dir.exists():
   100:         csvs = list(data_dir.glob("*.csv"))
   101:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
   102:     else:
   103:         print("  data/ absent (OK si loader API)")
   104: 
   105:     return issues
   106: 
   107: def preflight_or_die(verbose: bool = False) -> None:
   108:     issues = preflight(verbose=verbose)
   109:     if issues:
   110:         print("\n[✗] Préflight a détecté des problèmes :")
   111:         for it in issues: print("   -", it)
   112:         print("\nConseils :")
   113:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
   114:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
   115:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
   116:         raise SystemExit(1)
   117:     print("\n[✓] Préflight OK — démarrage du bot.")

--------------------------------------------------------------------------------
FILE: engine/services/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/services/data_cache.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/services/data_cache.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Iterable, List, Optional, Tuple, Dict
     9: 
    10: # ---------------------------------------------------------------------
    11: # Réglages via env (valeurs sûres par défaut)
    12: # ---------------------------------------------------------------------
    13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
    14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
    15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
    16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
    17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
    18: 
    19: os.makedirs(DATA_DIR, exist_ok=True)
    20: 
    21: 
    22: # ---------------------------------------------------------------------
    23: # Helpers
    24: # ---------------------------------------------------------------------
    25: def parse_timeframe_to_seconds(tf: str) -> int:
    26:     tf = tf.strip().lower()
    27:     unit = tf[-1]
    28:     try:
    29:         n = int(tf[:-1])
    30:     except Exception as e:
    31:         raise ValueError(f"timeframe invalide: {tf}") from e
    32:     if unit == "m":
    33:         return n * 60
    34:     if unit == "h":
    35:         return n * 3600
    36:     if unit == "d":
    37:         return n * 86400
    38:     raise ValueError(f"timeframe invalide: {tf}")
    39: 
    40: 
    41: def csv_path(symbol: str, timeframe: str) -> str:
    42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
    43: 
    44: 
    45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
    46:     rows: List[Tuple[int, float, float, float, float, float]] = []
    47:     if not os.path.exists(path):
    48:         return rows
    49:     with open(path, "r", newline="") as f:
    50:         r = csv.reader(f)
    51:         header = next(r, None)  # accepte avec ou sans header
    52:         for line in r:
    53:             if not line:
    54:                 continue
    55:             ts, o, h, l, c, v = line[:6]
    56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
    57:     return rows
    58: 
    59: 
    60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
    61:     first = not os.path.exists(path)
    62:     os.makedirs(os.path.dirname(path), exist_ok=True)
    63:     with open(path, "a", newline="") as f:
    64:         w = csv.writer(f)
    65:         if first:
    66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    67:         for row in data:
    68:             w.writerow(row)
    69: 
    70: 
    71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
    72:     return rows[-1][0] if rows else None
    73: 
    74: 
    75: # ---------------------------------------------------------------------
    76: # Fetch CCXT paginé
    77: # ---------------------------------------------------------------------
    78: async def ccxt_fetch_ohlcv_all(
    79:     exchange,
    80:     symbol: str,
    81:     timeframe: str,
    82:     since_ms: Optional[int],
    83:     limit: int = 1000,
    84: ) -> List[Tuple[int, float, float, float, float, float]]:
    85:     """
    86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
    87:     Retourne une liste triée/dédupliquée.
    88:     """
    89:     out: List[Tuple[int, float, float, float, float, float]] = []
    90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
    91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
    92: 
    93:     cursor = since_ms or (now_ms - 200 * tf_ms)
    94:     while True:
    95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
    96:         if not batch:
    97:             break
    98:         for ts, o, h, l, c, v in batch:
    99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
   100:         next_cursor = batch[-1][0] + tf_ms
   101:         if next_cursor <= cursor:
   102:             break
   103:         cursor = next_cursor
   104:         if cursor >= now_ms + (2 * tf_ms):
   105:             break
   106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
   107: 
   108:     out.sort(key=lambda x: x[0])
   109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
   110:     seen = set()
   111:     for row in out:
   112:         if row[0] in seen:
   113:             continue
   114:         seen.add(row[0])
   115:         dedup.append(row)
   116:     return dedup
   117: 
   118: 
   119: # ---------------------------------------------------------------------
   120: # Cache manager
   121: # ---------------------------------------------------------------------
   122: async def ensure_symbol_csv_cache(
   123:     exchange,
   124:     symbol: str,
   125:     timeframe: str,
   126:     min_rows: int = CSV_MIN_ROWS,
   127: ) -> str:
   128:     """
   129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
   130:     Crée/append si nécessaire. Retourne le chemin.
   131:     """
   132:     path = csv_path(symbol, timeframe)
   133:     rows = read_csv_ohlcv(path)
   134:     tf_sec = parse_timeframe_to_seconds(timeframe)
   135:     tf_ms = tf_sec * 1000
   136:     now_ms = int(time.time() * 1000)
   137: 
   138:     # âge max
   139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
   140: 
   141:     need_full = False
   142:     need_append = False
   143: 
   144:     if not rows:
   145:         need_full = True
   146:     else:
   147:         last = last_ts(rows) or 0
   148:         age_sec = max(0, (now_ms - last) // 1000)
   149:         if age_sec > max_age or len(rows) < min_rows:
   150:             need_append = True
   151: 
   152:     if need_full:
   153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
   154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   155:         if len(fresh) < min_rows:
   156:             since = now_ms - (tf_ms * 5000)
   157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   158:         if os.path.exists(path):
   159:             os.remove(path)
   160:         write_csv_ohlcv(path, fresh)
   161:         return path
   162: 
   163:     if need_append:
   164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
   165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   166:         if fresh:
   167:             write_csv_ohlcv(path, fresh)
   168: 
   169:     return path
   170: 
   171: 
   172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
   173:     """
   174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
   175:     Retourne {symbol: path}.
   176:     """
   177:     sem = asyncio.Semaphore(PREFETCH_CONC)
   178:     result: Dict[str, str] = {}
   179: 
   180:     async def _one(sym: str):
   181:         async with sem:
   182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
   183:             result[sym] = p
   184: 
   185:     await asyncio.gather(*[_one(s) for s in symbols])
   186:     return result

--------------------------------------------------------------------------------
FILE: engine/services/order_service.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: from dataclasses import dataclass
     3: from typing import Any, Dict, Optional, Protocol
     4: from engine.trade_utils import extract_available_balance
     5: 
     6: 
     7: @dataclass
     8: class OrderCaps:
     9:     min_trade_usdt: float = 5.0
    10:     leverage: float = 1.0
    11: 
    12: 
    13: @dataclass
    14: class OrderRequest:
    15:     symbol: str
    16:     side: str
    17:     price: float
    18:     sl: float
    19:     tp: Optional[float]
    20:     risk_pct: float
    21: 
    22: 
    23: @dataclass
    24: class OrderResult:
    25:     accepted: bool
    26:     reason: str = ""
    27:     payload: Dict[str, Any] = None
    28:     order_id: Optional[str] = None
    29:     status: Optional[str] = None
    30:     avg_price: Optional[float] = None
    31:     filled_qty: Optional[float] = None
    32: 
    33: 
    34: class Exchange(Protocol):
    35:     def get_assets(self) -> Dict[str, Any]: ...
    36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
    37:     def place_order(
    38:         self,
    39:         symbol: str,
    40:         side: str,
    41:         quantity: float,
    42:         order_type: str,
    43:         price: Optional[float] = None,
    44:         stop_loss: Optional[float] = None,
    45:         take_profit: Optional[float] = None,
    46:     ) -> Dict[str, Any]: ...
    47: 
    48: 
    49: class OrderService:
    50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
    51:         self.exchange = exchange
    52:         self.caps = caps
    53: 
    54:     @staticmethod
    55:     def _abs(x: float) -> float:
    56:         return -x if x < 0 else x
    57: 
    58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
    59:         dist = self._abs(price - sl)
    60:         if dist <= 0:
    61:             return 0.0
    62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
    63:         return 0.0 if price <= 0 else (risk_usdt / dist)
    64: 
    65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
    66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
    67:         if qty <= 0:
    68:             return OrderResult(False, "invalid_size")
    69:         notional = qty * req.price
    70:         if notional < self.caps.min_trade_usdt:
    71:             return OrderResult(False, "under_min_notional")
    72:         assets = self.exchange.get_assets()
    73:         available = extract_available_balance(assets)
    74:         required_margin = notional / max(1.0, self.caps.leverage)
    75:         if available < required_margin:
    76:             return OrderResult(False, "insufficient_margin")
    77:         side = "BUY" if req.side == "long" else "SELL"
    78:         out = self.exchange.place_order(
    79:             symbol=req.symbol, side=side, quantity=qty,
    80:             order_type="limit", price=req.price,
    81:             stop_loss=req.sl, take_profit=req.tp
    82:         )
    83:         # extraire infos utiles
    84:         oid = None; status = None; avg = None; filled = None
    85:         try:
    86:             data = out.get("data") if isinstance(out, dict) else out
    87:             if isinstance(data, dict):
    88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
    89:                 status = (data.get("status") or data.get("state") or "new").lower()
    90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
    91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
    92:         except Exception:
    93:             pass
    94:         return OrderResult(True, "", out, oid, status, avg, filled)

--------------------------------------------------------------------------------
FILE: engine/services/utils.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/services/utils.py
     2: from __future__ import annotations
     3: import asyncio
     4: from typing import Callable, Any
     5: 
     6: 
     7: class NullNotifier:
     8:     async def send(self, _msg: str) -> None:
     9:         return
    10: 
    11: 
    12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
    13:     if notifier is None:
    14:         notifier = NullNotifier()
    15:     try:
    16:         while running_getter():
    17:             await notifier.send("heartbeat alive")
    18:             await asyncio.sleep(period)
    19:     except asyncio.CancelledError:
    20:         pass
    21: 
    22: 
    23: async def log_stats_task(
    24:     notifier: Any,
    25:     ticks_getter: Callable[[], int],
    26:     symbols_getter: Callable[[], list[str]],
    27:     period: float = 30.0,
    28: ) -> None:
    29:     if notifier is None:
    30:         notifier = NullNotifier()
    31:     last = 0
    32:     try:
    33:         while True:
    34:             total = int(ticks_getter() or 0)
    35:             delta = total - last
    36:             last = total
    37:             syms = symbols_getter() or []
    38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
    39:             print(msg)
    40:             await notifier.send(msg)
    41:             await asyncio.sleep(period)
    42:     except asyncio.CancelledError:
    43:         pass

--------------------------------------------------------------------------------
FILE: engine/signals/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: __all__ = ["factory"]

--------------------------------------------------------------------------------
FILE: engine/signals/current.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/signals/current.py
     2: from __future__ import annotations
     3: 
     4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
     5: from engine.strategy import generate_signal as _generate_signal
     6: 
     7: def generate_signal(**kwargs):
     8:     """
     9:     Expose la même signature que engine.strategy.generate_signal.
    10:     Sert d’adaptateur pour la factory.
    11:     """
    12:     return _generate_signal(**kwargs)

--------------------------------------------------------------------------------
FILE: engine/signals/factory.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/signals/factory.py
     2: from __future__ import annotations
     3: from typing import Callable, Dict, Any
     4: import importlib
     5: import os
     6: import json
     7: 
     8: try:
     9:     import yaml  # type: ignore
    10: except Exception:
    11:     yaml = None  # type: ignore
    12: 
    13: SignalFn = Callable[..., Any]
    14: 
    15: # IMPORTANT : on pointe par défaut sur TA stratégie actuelle dans scalper/strategy.py
    16: _REGISTRY: Dict[str, str] = {
    17:     "current": "engine.strategy:generate_signal",
    18:     # Tu pourras ajouter d'autres stratégies ici, par ex :
    19:     # "ema_cross": "engine.strategies.ema_cross:generate_signal",
    20: }
    21: 
    22: def _load_callable(path: str) -> SignalFn:
    23:     if ":" not in path:
    24:         raise ValueError(f"Chemin callable invalide: {path}")
    25:     module_name, attr = path.split(":", 1)
    26:     mod = importlib.import_module(module_name)
    27:     fn = getattr(mod, attr, None)
    28:     if not callable(fn):
    29:         raise ValueError(f"{attr} n'est pas callable dans {module_name}")
    30:     return fn  # type: ignore
    31: 
    32: def load_signal(name: str) -> SignalFn:
    33:     key = (name or "").strip().lower()
    34:     if key not in _REGISTRY:
    35:         raise KeyError(f"Stratégie inconnue: '{name}'. Registre: {list(_REGISTRY)}")
    36:     return _load_callable(_REGISTRY[key])
    37: 
    38: def _read_yaml(path: str) -> dict:
    39:     if yaml is None:
    40:         with open(path, "r", encoding="utf-8") as f:
    41:             return json.load(f)
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         return yaml.safe_load(f) or {}
    44: 
    45: def load_strategies_cfg(path: str | None) -> dict:
    46:     """
    47:     Charge le mapping (symbole, timeframe) -> nom de stratégie.
    48:     Si le fichier n'existe pas, retourne une config par défaut fonctionnelle.
    49:     """
    50:     default_cfg = {"default": "current", "by_timeframe": {}, "by_symbol": {}}
    51:     if not path:
    52:         return default_cfg
    53:     if not os.path.isfile(path):
    54:         # Pas de fichier ? On continue avec les valeurs par défaut.
    55:         return default_cfg
    56:     cfg = _read_yaml(path)
    57:     cfg.setdefault("default", "current")
    58:     cfg.setdefault("by_timeframe", {})
    59:     cfg.setdefault("by_symbol", {})
    60:     return cfg
    61: 
    62: def resolve_strategy_name(symbol: str, timeframe: str, cfg: dict) -> str:
    63:     symbol = (symbol or "").upper()
    64:     timeframe = (timeframe or "").lower()
    65:     return (
    66:         cfg.get("by_symbol", {}).get(symbol, {}).get(timeframe)
    67:         or cfg.get("by_timeframe", {}).get(timeframe)
    68:         or cfg.get("default", "current")
    69:     )
    70: 
    71: def resolve_signal_fn(symbol: str, timeframe: str, cfg: dict) -> SignalFn:
    72:     return load_signal(resolve_strategy_name(symbol, timeframe, cfg))

--------------------------------------------------------------------------------
FILE: engine/signals/generator.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from typing import Any, Dict, List, Optional
     4: 
     5: import pandas as pd
     6: 
     7: from data.indicators import compute_all
     8: 
     9: __all__ = ["generate_signal"]
    10: 
    11: 
    12: def _quality_from_score(score: float) -> str:
    13:     if score >= 0.8:
    14:         return "A"
    15:     if score >= 0.5:
    16:         return "B"
    17:     return "C"
    18: 
    19: 
    20: def generate_signal(
    21:     df: pd.DataFrame,
    22:     *,
    23:     trend_tf: Optional[pd.DataFrame] = None,
    24:     confirm_tf: Optional[pd.DataFrame] = None,
    25:     atr_mult: float = 1.0,
    26:     trailing: bool = False,
    27:     **_: Any,
    28: ) -> Optional[Dict[str, Any]]:
    29:     """Generate a trading signal with confluence scoring.
    30: 
    31:     Parameters
    32:     ----------
    33:     df: pd.DataFrame
    34:         Primary timeframe OHLCV data.
    35:     trend_tf: pd.DataFrame, optional
    36:         Higher timeframe used for trend filtering.
    37:     confirm_tf: pd.DataFrame, optional
    38:         Lower timeframe used for confirmation.
    39:     atr_mult: float, optional
    40:         Multiplier applied to ATR for stop/target calculation.
    41:     trailing: bool, optional
    42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
    43: 
    44:     Returns
    45:     -------
    46:     dict | None
    47:         Dictionary describing the signal or ``None`` if no trade setup exists.
    48:     """
    49: 
    50:     if df is None or len(df) < 2:
    51:         return None
    52: 
    53:     df = compute_all(df)
    54:     last = df.iloc[-1]
    55: 
    56:     conditions: List[bool] = []
    57:     reasons: List[str] = []
    58:     direction: Optional[str] = None
    59: 
    60:     # --- Basic trend via EMAs ----------------------------------------------
    61:     if last["close"] > last["ema20"] > last["ema50"]:
    62:         direction = "long"
    63:         reasons.append("price_above_ema")
    64:         conditions.append(True)
    65:     elif last["close"] < last["ema20"] < last["ema50"]:
    66:         direction = "short"
    67:         reasons.append("price_below_ema")
    68:         conditions.append(True)
    69:     else:
    70:         conditions.append(False)
    71:         return None
    72: 
    73:     # --- RSI ---------------------------------------------------------------
    74:     if direction == "long":
    75:         cond = last["rsi"] > 55
    76:         if cond:
    77:             reasons.append("rsi_bullish")
    78:         conditions.append(cond)
    79:     else:
    80:         cond = last["rsi"] < 45
    81:         if cond:
    82:             reasons.append("rsi_bearish")
    83:         conditions.append(cond)
    84: 
    85:     # --- MACD --------------------------------------------------------------
    86:     if direction == "long":
    87:         cond = last["macd"] > last["macd_signal"]
    88:         if cond:
    89:             reasons.append("macd_bullish")
    90:         conditions.append(cond)
    91:     else:
    92:         cond = last["macd"] < last["macd_signal"]
    93:         if cond:
    94:             reasons.append("macd_bearish")
    95:         conditions.append(cond)
    96: 
    97:     # --- OBV momentum ------------------------------------------------------
    98:     if len(df) >= 2:
    99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
   100:         if obv_up:
   101:             reasons.append("obv_trending")
   102:         conditions.append(obv_up)
   103: 
   104:     # --- Trend timeframe filter -------------------------------------------
   105:     if trend_tf is not None and len(trend_tf) >= 2:
   106:         tdf = compute_all(trend_tf)
   107:         ema50 = tdf["ema50"]
   108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
   109:         if direction == "long":
   110:             cond = slope > 0
   111:             if cond:
   112:                 reasons.append("trend_up")
   113:             conditions.append(cond)
   114:         else:
   115:             cond = slope < 0
   116:             if cond:
   117:                 reasons.append("trend_down")
   118:             conditions.append(cond)
   119: 
   120:     # --- Confirmation timeframe filter ------------------------------------
   121:     if confirm_tf is not None and len(confirm_tf) > 0:
   122:         cdf = compute_all(confirm_tf)
   123:         rsi = cdf["rsi"].iloc[-1]
   124:         if direction == "long":
   125:             cond = rsi > 50
   126:             if cond:
   127:                 reasons.append("confirm_rsi_bullish")
   128:             conditions.append(cond)
   129:         else:
   130:             cond = rsi < 50
   131:             if cond:
   132:                 reasons.append("confirm_rsi_bearish")
   133:             conditions.append(cond)
   134: 
   135:     score = (
   136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
   137:     )
   138:     quality = _quality_from_score(score)
   139: 
   140:     atr = last.get("atr")
   141:     if pd.isna(atr) or atr == 0:
   142:         return None
   143: 
   144:     entry = float(last["close"])
   145:     if direction == "long":
   146:         sl = entry - atr * atr_mult
   147:         tp = entry + atr * atr_mult * 2
   148:     else:
   149:         sl = entry + atr * atr_mult
   150:         tp = entry - atr * atr_mult * 2
   151: 
   152:     result: Dict[str, Any] = {
   153:         "direction": direction,
   154:         "entry": entry,
   155:         "sl": sl,
   156:         "tp": tp,
   157:         "score": round(score, 3),
   158:         "reasons": reasons,
   159:         "quality": quality,
   160:     }
   161: 
   162:     if trailing:
   163:         result["trail"] = atr * atr_mult
   164: 
   165:     return result

--------------------------------------------------------------------------------
FILE: engine/strategy/factory.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: annulé

--------------------------------------------------------------------------------
FILE: engine/strategy.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
     2: 
     3: This module implements a minimal but functional version of the strategy
     4: outlined in the project specification.  The focus is on pure Python
     5: implementations so the logic can easily be unit tested without requiring
     6: external services or heavy third‑party dependencies.
     7: 
     8: The strategy is deliberately stateless; functions operate on passed data and
     9: return simple data structures.  This makes it easy to plug the logic into
    10: real‑time trading loops or backtest engines.
    11: """
    12: 
    13: from __future__ import annotations
    14: 
    15: from dataclasses import dataclass
    16: from typing import Sequence, List, Dict, Optional, Tuple, Any
    17: 
    18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
    19: from .risk import calc_position_size
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Helpers
    23: # ---------------------------------------------------------------------------
    24: 
    25: def ema(series: Sequence[float], window: int) -> List[float]:
    26:     """Return the exponential moving average of *series*.
    27: 
    28:     The first value is the raw input to remain consistent with most trading
    29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
    30:     returned unchanged.
    31:     """
    32: 
    33:     if window <= 1 or not series:
    34:         return list(series)
    35:     k = 2.0 / (window + 1.0)
    36:     out: List[float] = [float(series[0])]
    37:     prev = out[0]
    38:     for x in series[1:]:
    39:         prev = float(x) * k + prev * (1.0 - k)
    40:         out.append(prev)
    41:     return out
    42: 
    43: def vwap(highs: Sequence[float], lows: Sequence[float],
    44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
    45:     """Compute the volume weighted average price (VWAP).
    46: 
    47:     Parameters
    48:     ----------
    49:     highs, lows, closes, volumes: Sequence[float]
    50:         Matching sequences for the period considered.
    51:     """
    52: 
    53:     tp_vol = 0.0
    54:     vol_sum = 0.0
    55:     for h, low, c, v in zip(highs, lows, closes, volumes):
    56:         tp = (h + low + c) / 3.0
    57:         tp_vol += tp * v
    58:         vol_sum += v
    59:     return tp_vol / vol_sum if vol_sum else 0.0
    60: 
    61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    62:     """Return the On Balance Volume (OBV) series."""
    63: 
    64:     if not closes:
    65:         return []
    66:     out: List[float] = [0.0]
    67:     for i in range(1, len(closes)):
    68:         if closes[i] > closes[i - 1]:
    69:             out.append(out[-1] + volumes[i])
    70:         elif closes[i] < closes[i - 1]:
    71:             out.append(out[-1] - volumes[i])
    72:         else:
    73:             out.append(out[-1])
    74:     return out
    75: 
    76: 
    77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    78:     """Detect a crossing between two series.
    79: 
    80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    81:     ``0`` otherwise.
    82:     """
    83: 
    84:     if prev_fast <= prev_slow and last_fast > last_slow:
    85:         return 1
    86:     if prev_fast >= prev_slow and last_fast < last_slow:
    87:         return -1
    88:     return 0
    89: 
    90: 
    91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    92:     """Compute order book imbalance.
    93: 
    94:     The value is normalised between ``-1`` and ``1`` where positive numbers
    95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
    96:     """
    97: 
    98:     total = bid_vol + ask_vol
    99:     return (bid_vol - ask_vol) / total if total else 0.0
   100: 
   101: 
   102: def swing_levels(
   103:     highs: Sequence[float], lows: Sequence[float], lookback: int
   104: ) -> Tuple[float, float]:
   105:     """Return the most recent swing high and swing low.
   106: 
   107:     ``lookback`` defines how many completed candles are inspected.  The current
   108:     candle is excluded to avoid look‑ahead bias.
   109:     """
   110: 
   111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
   112:         return highs[-1], lows[-1]
   113:     high = max(highs[-lookback - 1 : -1])
   114:     low = min(lows[-lookback - 1 : -1])
   115:     return high, low
   116: 
   117: # ---------------------------------------------------------------------------
   118: # Pair selection
   119: # ---------------------------------------------------------------------------
   120: 
   121: # The first and second level pair selection helpers now live in
   122: # :mod:`engine.selection`.  They are re-exported here for backward compatibility
   123: # and to keep the public API unchanged.
   124: from .selection.scanner import scan_pairs  # noqa: E402
   125: from .selection.momentum import select_active_pairs  # noqa: E402
   126: 
   127: # ---------------------------------------------------------------------------
   128: # Signal generation
   129: # ---------------------------------------------------------------------------
   130: 
   131: @dataclass
   132: class Signal:
   133:     """Trading signal with risk parameters."""
   134: 
   135:     symbol: str
   136:     side: int  # 1 for long, -1 for short
   137:     entry: float
   138:     sl: float
   139:     tp1: float
   140:     tp2: float
   141:     qty: float = 0.0
   142:     score: Optional[float] = None
   143:     quality: Optional[float] = None
   144:     reasons: Optional[List[str]] = None
   145: 
   146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
   147:         if isinstance(self.side, str):
   148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
   149: 
   150:     @property
   151:     def price(self) -> float:
   152:         return self.entry
   153: 
   154: 
   155: def _generate_signal(
   156:     symbol: str,
   157:     ohlcv: Dict[str, Sequence[float]],
   158:     *,
   159:     equity: float,
   160:     risk_pct: float,
   161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
   162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
   163:     order_book: Optional[Dict[str, float]] = None,
   164:     tick_ratio_buy: Optional[float] = None,
   165:     atr_disable_pct: float = 0.2,
   166:     atr_reduce_pct: float = 2.0,
   167:     swing_lookback: int = 5,
   168:     macd_fast: int = 12,
   169:     macd_slow: int = 26,
   170:     macd_signal: int = 9,
   171:     trend_ema_period: int = 200,
   172: ) -> Optional[Signal]:
   173:     """Return a trading :class:`Signal` if conditions are met.
   174: 
   175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
   176:     sequences ordered from oldest to newest.  The function checks the following
   177:     rules:
   178: 
   179:     * price positioned relative to VWAP and EMA20/EMA50 trend
   180:     * RSI(14) crossing key levels (40/60)
   181:     * OBV rising or high short‑term volume
   182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
   183:     * Micro‑structure breakout of last swing high/low
   184:     * MACD trend filter
   185:     * Long‑term trend via configurable EMA filter
   186:     * Order book imbalance and tape filters
   187:     * Dynamic ATR‑based stop‑loss and take‑profit
   188:     * Position sizing via ``calc_position_size``
   189:     """
   190: 
   191:     closes = [float(x) for x in ohlcv.get("close", [])]
   192:     highs = [float(x) for x in ohlcv.get("high", [])]
   193:     lows = [float(x) for x in ohlcv.get("low", [])]
   194:     vols = [float(x) for x in ohlcv.get("volume", [])]
   195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
   196:         return None
   197: 
   198:     price = closes[-1]
   199:     ema20 = ema(closes, 20)
   200:     ema50 = ema(closes, 50)
   201:     ema_trend = ema(closes, trend_ema_period)
   202:     v = vwap(highs, lows, closes, vols)
   203:     obv_series = obv(closes, vols)
   204:     obv_rising = obv_series[-1] > obv_series[-2]
   205:     vol_last3 = sum(vols[-3:])
   206:     vol_ma20 = sum(vols[-20:]) / 20.0
   207:     vol_rising = vol_last3 > vol_ma20
   208: 
   209:     macd_val, macd_sig, _ = calc_macd(
   210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
   211:     )
   212: 
   213:     # Multi timeframe filters -------------------------------------------------
   214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
   215:     if ohlcv_1h:
   216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
   217:         if len(h_closes) >= 52:
   218:             h_ema50 = ema(h_closes, 50)
   219:             if len(h_ema50) >= 2:
   220:                 slope = h_ema50[-1] - h_ema50[-2]
   221:                 if slope > 0:
   222:                     trend_dir = 1
   223:                 elif slope < 0:
   224:                     trend_dir = -1
   225: 
   226:     rsi_15 = None
   227:     if ohlcv_15m:
   228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
   229:         if len(m_closes) >= 15:
   230:             rsi_15 = calc_rsi(m_closes, 14)
   231: 
   232:     # RSI crossing logic (5m)
   233:     rsi_curr = calc_rsi(closes[-15:], 14)
   234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
   235: 
   236:     atr = calc_atr(highs, lows, closes, 14)
   237:     atr_pct = atr / price * 100.0 if price else 0.0
   238:     if atr_pct < atr_disable_pct:
   239:         return None
   240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
   241: 
   242:     sl_dist = 0.5 * atr
   243:     tp1_dist = 1.0 * atr
   244:     tp2_dist = 1.5 * atr
   245: 
   246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
   247: 
   248:     obi_ok_long = obi_ok_short = True
   249:     if order_book is not None:
   250:         bid = float(order_book.get("bid_vol_aggreg", 0))
   251:         ask = float(order_book.get("ask_vol_aggreg", 0))
   252:         obi = order_book_imbalance(bid, ask)
   253:         obi_ok_long = obi > 0.1
   254:         obi_ok_short = obi < -0.1
   255: 
   256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
   257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
   258: 
   259:     def _size(dist: float) -> float:
   260:         return calc_position_size(equity, risk_pct, dist) * size_mult
   261:     weights = {
   262:         "ema": 15.0,
   263:         "macd": 15.0,
   264:         "vwap": 15.0,
   265:         "rsi": 15.0,
   266:         "obv": 10.0,
   267:         "swing": 10.0,
   268:         "atr": 20.0,
   269:     }
   270: 
   271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
   272: 
   273:     long_score = atr_score
   274:     long_reasons: List[str] = []
   275:     if price > v:
   276:         long_score += weights["vwap"]
   277:         long_reasons.append("vwap")
   278:     if ema20[-1] > ema50[-1]:
   279:         long_score += weights["ema"]
   280:         long_reasons.append("ema")
   281:     if rsi_prev <= 40 < rsi_curr:
   282:         long_score += weights["rsi"]
   283:         long_reasons.append("rsi")
   284:     if macd_val > macd_sig:
   285:         long_score += weights["macd"]
   286:         long_reasons.append("macd")
   287:     if obv_rising or vol_rising:
   288:         long_score += weights["obv"]
   289:         long_reasons.append("obv")
   290:     if price > swing_high:
   291:         long_score += weights["swing"]
   292:         long_reasons.append("swing")
   293: 
   294:     short_score = atr_score
   295:     short_reasons: List[str] = []
   296:     if price < v:
   297:         short_score += weights["vwap"]
   298:         short_reasons.append("vwap")
   299:     if ema20[-1] < ema50[-1]:
   300:         short_score += weights["ema"]
   301:         short_reasons.append("ema")
   302:     if rsi_prev >= 60 > rsi_curr:
   303:         short_score += weights["rsi"]
   304:         short_reasons.append("rsi")
   305:     if macd_val < macd_sig:
   306:         short_score += weights["macd"]
   307:         short_reasons.append("macd")
   308:     if obv_series[-1] < obv_series[-2] or vol_rising:
   309:         short_score += weights["obv"]
   310:         short_reasons.append("obv")
   311:     if price < swing_low:
   312:         short_score += weights["swing"]
   313:         short_reasons.append("swing")
   314: 
   315:     side: Optional[str] = None
   316:     score: float = 0.0
   317:     reasons: List[str] = []
   318:     if (
   319:         long_score >= short_score
   320:         and long_score > 0
   321:         and macd_val > macd_sig
   322:         and obi_ok_long
   323:         and tick_ok_long
   324:         and trend_dir >= 0
   325:         and price > ema_trend[-1]
   326:     ):
   327:         side = "long"
   328:         score = long_score
   329:         reasons = long_reasons
   330:         sl = price - sl_dist
   331:         tp1 = price + tp1_dist
   332:         tp2 = price + tp2_dist
   333:     elif (
   334:         short_score > long_score
   335:         and short_score > 0
   336:         and macd_val < macd_sig
   337:         and obi_ok_short
   338:         and tick_ok_short
   339:         and trend_dir <= 0
   340:         and price < ema_trend[-1]
   341:     ):
   342:         side = "short"
   343:         score = short_score
   344:         reasons = short_reasons
   345:         sl = price + sl_dist
   346:         tp1 = price - tp1_dist
   347:         tp2 = price - tp2_dist
   348:     else:
   349:         return None
   350: 
   351:     qty = _size(sl_dist)
   352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
   353: 
   354: 
   355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
   356:     if "config" in kwargs:
   357:         config = kwargs.pop("config")
   358:         symbol = kwargs.pop("symbol", None)
   359:         ohlcv = kwargs.pop("ohlcv", None)
   360:         if ohlcv is None:
   361:             raise TypeError("ohlcv argument required")
   362:         return _generate_signal(
   363:             symbol or ohlcv.get("symbol", ""),
   364:             ohlcv,
   365:             equity=kwargs.pop("equity", 0.0),
   366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
   367:             **kwargs,
   368:         )
   369:     return _generate_signal(*args, **kwargs)
   370: 
   371: # ---------------------------------------------------------------------------
   372: # Backtesting utilities
   373: # ---------------------------------------------------------------------------
   374: 
   375: def max_drawdown(equity_curve: Sequence[float]) -> float:
   376:     peak = equity_curve[0]
   377:     mdd = 0.0
   378:     for x in equity_curve:
   379:         if x > peak:
   380:             peak = x
   381:         dd = (peak - x) / peak * 100.0
   382:         if dd > mdd:
   383:             mdd = dd
   384:     return mdd
   385: 
   386: def backtest(
   387:     trades: Sequence[Dict[str, Any]],
   388:     *,
   389:     equity_start: float = 1_000.0,
   390:     fee_rate: float = 0.0,
   391: ) -> Dict[str, float]:
   392:     """Evaluate a list of trade dictionaries.
   393: 
   394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
   395:     optionally include ``duration`` in minutes.  Results are aggregated into
   396:     common performance metrics to quickly evaluate the strategy.
   397:     """
   398: 
   399:     equity = equity_start
   400:     equity_curve = [equity]
   401:     pnl_pct_list: List[float] = []
   402:     wins = losses = 0
   403:     win_sum = loss_sum = 0.0
   404:     total_duration = 0.0
   405: 
   406:     for t in trades:
   407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
   408:         pnl_pct_list.append(pnl_pct)
   409:         if pnl_pct >= 0:
   410:             wins += 1
   411:             win_sum += pnl_pct
   412:         else:
   413:             losses += 1
   414:             loss_sum += pnl_pct
   415:         equity *= 1 + pnl_pct / 100.0
   416:         equity_curve.append(equity)
   417:         total_duration += float(t.get("duration", 0.0))
   418: 
   419:     pnl_pct_total = sum(pnl_pct_list)
   420:     pnl_usdt = equity - equity_start
   421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
   422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
   423:     mdd = max_drawdown(equity_curve)
   424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
   425:     exposure = total_duration  # in minutes, callers can normalise if desired
   426:     # Sharpe ratio based on per-trade returns
   427:     if len(pnl_pct_list) > 1:
   428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
   429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
   430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
   431:     else:
   432:         sharpe = 0.0
   433: 
   434:     return {
   435:         "pnl_usdt": pnl_usdt,
   436:         "pnl_pct": pnl_pct_total,
   437:         "profit_factor": profit_factor,
   438:         "winrate": winrate,
   439:         "max_drawdown": mdd,
   440:         "avg_trade_time": avg_trade_time,
   441:         "exposure": exposure,
   442:         "sharpe": sharpe,
   443:     }

--------------------------------------------------------------------------------
FILE: engine/trade_utils.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/trade_utils.py
     2: from __future__ import annotations
     3: 
     4: from typing import Optional
     5: 
     6: 
     7: def compute_position_size(
     8:     equity: float,
     9:     price: float,
    10:     risk_pct: float,
    11:     *,
    12:     symbol: Optional[str] = None,
    13:     min_qty: float = 0.0,
    14:     max_leverage: float = 1.0,
    15: ) -> float:
    16:     """
    17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
    18:     qty = notionnel / price
    19:     - min_qty : borne basse éventuelle (0 pour ignorer)
    20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
    21:     """
    22:     equity = float(max(0.0, equity))
    23:     price = float(max(1e-12, price))
    24:     risk_pct = float(max(0.0, risk_pct))
    25:     notionnel = equity * risk_pct * max_leverage
    26:     qty = notionnel / price
    27:     if min_qty > 0 and qty < min_qty:
    28:         return 0.0
    29:     return float(qty)

--------------------------------------------------------------------------------
FILE: engine/utils/bootstrap.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # engine/utils/bootstrap.py
     2: from __future__ import annotations
     3: import importlib
     4: import json
     5: import os
     6: import subprocess
     7: import sys
     8: from pathlib import Path
     9: from typing import Dict, Tuple
    10: 
    11: _MARK_DIR = Path("/notebooks/.scalp")
    12: _MARK_DIR.mkdir(parents=True, exist_ok=True)
    13: STATE = _MARK_DIR / "DEPS.json"
    14: 
    15: # import_name -> pip_spec
    16: CORE_REQS: Dict[str, str] = {
    17:     "requests": "requests>=2.31",
    18:     "pandas": "pandas>=2.1",
    19:     "numpy": "numpy>=1.26",
    20:     "yaml": "PyYAML>=6.0",
    21:     "dotenv": "python-dotenv>=1.0",
    22: }
    23: DASH_REQS: Dict[str, str] = {"streamlit": "streamlit>=1.33"}
    24: CCXT_REQS: Dict[str, str] = {"ccxt": "ccxt>=4.0.0"}
    25: 
    26: 
    27: def _need(import_name: str) -> bool:
    28:     try:
    29:         importlib.import_module(import_name)
    30:         return False
    31:     except Exception:
    32:         return True
    33: 
    34: 
    35: def _pip(spec: str) -> Tuple[bool, str]:
    36:     try:
    37:         # upgrade pip une seule fois par session (léger)
    38:         if not getattr(_pip, "_upgraded", False):
    39:             subprocess.run([sys.executable, "-m", "pip", "install", "--upgrade", "pip"],
    40:                            check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    41:             _pip._upgraded = True  # type: ignore[attr-defined]
    42:         proc = subprocess.run([sys.executable, "-m", "pip", "install", spec],
    43:                               capture_output=True, text=True, check=False)
    44:         ok = (proc.returncode == 0)
    45:         return ok, (proc.stdout + proc.stderr)[-3000:]
    46:     except Exception as e:
    47:         return False, f"pip failed: {e}"
    48: 
    49: 
    50: def ensure_dependencies(*, with_dash: bool = True, with_ccxt: bool = True) -> Dict[str, str]:
    51:     """
    52:     Idempotent: installe seulement ce qui manque.
    53:     Écrit l'état dans /notebooks/.scalp/DEPS.json
    54:     """
    55:     plan: Dict[str, str] = {}
    56:     reqs = dict(CORE_REQS)
    57:     if with_dash:
    58:         reqs.update(DASH_REQS)
    59:     if with_ccxt:
    60:         reqs.update(CCXT_REQS)
    61: 
    62:     for import_name, spec in reqs.items():
    63:         if _need(import_name):
    64:             ok, log_tail = _pip(spec)
    65:             plan[spec] = "installed" if ok else f"failed: {log_tail}"
    66:         else:
    67:             plan[spec] = "ok"
    68: 
    69:     try:
    70:         STATE.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    71:     except Exception:
    72:         pass
    73:     return plan

--------------------------------------------------------------------------------
FILE: engine/version.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Utilities for managing the Scalp bot version."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from pathlib import Path
     6: import re
     7: 
     8: import subprocess
     9: 
    10: 
    11: # Path to the VERSION file within the package
    12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
    13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
    14: 
    15: 
    16: def get_version() -> str:
    17:     """Return the current version of the bot.
    18: 
    19:     If the VERSION file does not exist the default version ``0.0.0`` is
    20:     returned.
    21:     """
    22:     if not _VERSION_FILE.exists():
    23:         return "0.0.0"
    24:     return _VERSION_FILE.read_text().strip()
    25: 
    26: 
    27: def _parse(version: str) -> tuple[int, int, int]:
    28:     match = _VERSION_RE.match(version)
    29:     if not match:
    30:         raise ValueError(f"Invalid version: {version!r}")
    31:     return tuple(int(x) for x in match.groups())
    32: 
    33: 
    34: def bump_version(part: str = "patch") -> str:
    35:     """Bump the version stored in the VERSION file.
    36: 
    37:     Parameters
    38:     ----------
    39:     part:
    40:         Which component to increment. Accepted values are ``"major"``,
    41:         ``"minor"`` and ``"patch"`` (default).
    42:     """
    43:     major, minor, patch = _parse(get_version())
    44:     if part == "major":
    45:         major += 1
    46:         minor = 0
    47:         patch = 0
    48:     elif part == "minor":
    49:         minor += 1
    50:         patch = 0
    51: 
    52:     elif part == "patch":
    53:         patch += 1
    54:     else:
    55:         raise ValueError(f"Unknown part: {part}")
    56:     new_version = f"{major}.{minor}.{patch}"
    57:     _VERSION_FILE.write_text(f"{new_version}\n")
    58:     return new_version
    59: 
    60: 
    61: def bump_version_from_message(message: str) -> str:
    62:     """Bump the version according to a commit message.
    63: 
    64:     ``message`` is evaluated using a tiny subset of the Conventional
    65:     Commits spec. Messages starting with ``feat`` bump the *minor*
    66:     version, messages whose header ends with ``!`` or contain
    67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
    68:     bump the *patch* component.
    69:     """
    70: 
    71:     header = message.strip().splitlines()[0].lower()
    72:     lower = message.lower()
    73:     type_part = header.split(":")[0]
    74:     if "!" in type_part or "breaking change" in lower:
    75:         part = "major"
    76:     elif type_part.startswith("feat"):
    77:         part = "minor"
    78:     else:
    79:         part = "patch"
    80:     return bump_version(part)
    81: 
    82: 
    83: def bump_version_from_git() -> str:
    84:     """Read the latest git commit message and bump the version accordingly."""
    85:     try:
    86:         message = subprocess.check_output(
    87:             ["git", "log", "-1", "--pretty=%B"], text=True
    88:         ).strip()
    89:     except Exception:
    90:         message = ""
    91:     return bump_version_from_message(message)
    92: 
    93: 
    94: if __name__ == "__main__":
    95:     print(bump_version_from_git())

--------------------------------------------------------------------------------
FILE: engine/ws.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: """Minimal websocket manager with heartbeat and auto-resubscribe.
     2: 
     3: This module provides a light-weight framework to maintain a realtime
     4: connection to an exchange.  The actual network layer is expected to be
     5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
     6: manager handles retrying failed connections and periodically invoking the
     7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
     8: without opening real network sockets.
     9: """
    10: from __future__ import annotations
    11: 
    12: import asyncio
    13: import logging
    14: from typing import Awaitable, Callable, Optional
    15: 
    16: 
    17: class WebsocketManager:
    18:     """Maintain a websocket connection with heartbeat and retry."""
    19: 
    20:     def __init__(
    21:         self,
    22:         connect: Callable[[], Awaitable[None]],
    23:         subscribe: Callable[[], Awaitable[None]],
    24:         *,
    25:         heartbeat_interval: float = 30.0,
    26:         max_retries: int = 3,
    27:     ) -> None:
    28:         self._connect = connect
    29:         self._subscribe = subscribe
    30:         self.heartbeat_interval = heartbeat_interval
    31:         self.max_retries = max_retries
    32:         self._heartbeat_task: Optional[asyncio.Task] = None
    33: 
    34:     async def run(self) -> None:
    35:         """Open the connection retrying on failure."""
    36:         retries = 0
    37:         while True:
    38:             try:
    39:                 await self._connect()
    40:                 await self._subscribe()
    41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
    42:                 return
    43:             except Exception as exc:  # pragma: no cover - network errors
    44:                 logging.error("websocket connect failed: %s", exc)
    45:                 retries += 1
    46:                 if retries > self.max_retries:
    47:                     raise
    48:                 await asyncio.sleep(1)
    49: 
    50:     async def _heartbeat(self) -> None:
    51:         """Send periodic heartbeats and resubscribe on failure."""
    52:         while True:
    53:             await asyncio.sleep(self.heartbeat_interval)
    54:             try:
    55:                 await self._subscribe()
    56:             except Exception as exc:  # pragma: no cover - network errors
    57:                 logging.warning("websocket heartbeat failed: %s", exc)
    58:                 await self.run()
    59:                 break
    60: 
    61:     async def stop(self) -> None:
    62:         """Cancel the heartbeat task if it is running."""
    63:         task = self._heartbeat_task
    64:         if task and not task.done():
    65:             task.cancel()
    66:             try:
    67:                 await task
    68:             except BaseException:  # pragma: no cover - cancellation
    69:                 pass
    70:         self._heartbeat_task = None

--------------------------------------------------------------------------------
FILE: init.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: """Install all project dependencies.
     3: 
     4: Run this script once to install every ``requirements*.txt`` file found in the
     5: repository as well as the packages needed for the test suite.  All subsequent
     6: invocations of the bot or its submodules will then share the same Python
     7: environment with the required dependencies available.
     8: """
     9: 
    10: from __future__ import annotations
    11: 
    12: import subprocess
    13: import sys
    14: from pathlib import Path
    15: 
    16: 
    17: def install_packages(*args: str) -> None:
    18:     """Install packages using pip for the current Python interpreter."""
    19:     cmd = [sys.executable, "-m", "pip", "install", *args]
    20:     subprocess.check_call(cmd)
    21: 
    22: 
    23: def main() -> None:
    24:     repo_root = Path(__file__).resolve().parent
    25: 
    26:     # Install from any requirements*.txt file across the repository so that
    27:     # sub-packages with their own dependency lists are also covered.
    28:     for req in sorted(repo_root.rglob("requirements*.txt")):
    29:         install_packages("-r", str(req))
    30: 
    31:     # Ensure test dependencies are available
    32:     install_packages("pytest")
    33: 
    34: 
    35: if __name__ == "__main__":
    36:     main()

--------------------------------------------------------------------------------
FILE: jobs/backfill.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import argparse, os
     3: from pathlib import Path
     4: from engine.config.loader import load_config
     5: from engine.exchange.bitget_rest import BitgetFuturesClient
     6: from engine.backtest.loader_csv import write_csv_ohlcv
     7: 
     8: def main() -> int:
     9:     ap = argparse.ArgumentParser(description="Backfill OHLCV -> DATA_ROOT/data")
    10:     ap.add_argument("--symbols", required=True, help="BTCUSDT,ETHUSDT")
    11:     ap.add_argument("--tfs", required=True, help="1m,5m,15m,1h")
    12:     ap.add_argument("--limit", type=int, default=5000)
    13:     args = ap.parse_args()
    14: 
    15:     cfg = load_config()
    16:     out_dir = Path(cfg["runtime"]["data_dir"]).resolve()
    17:     out_dir.mkdir(parents=True, exist_ok=True)
    18: 
    19:     client = BitgetFuturesClient(
    20:         access_key=cfg["secrets"]["bitget"]["access"],
    21:         secret_key=cfg["secrets"]["bitget"]["secret"],
    22:         passphrase=cfg["secrets"]["bitget"]["passphrase"],
    23:         base_url=os.getenv("BITGET_BASE_URL","https://api.bitget.com"),
    24:     )
    25: 
    26:     symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]
    27:     tfs = [t.strip() for t in args.tfs.split(",") if t.strip()]
    28:     for sym in symbols:
    29:         for tf in tfs:
    30:             resp = client.get_klines(sym, interval=tf, limit=args.limit)
    31:             rows = resp.get("data") or []
    32:             write_csv_ohlcv(out_dir, sym, tf, rows)
    33:             print(f"[✓] {sym} {tf} -> {out_dir}")
    34:     return 0
    35: 
    36: if __name__ == "__main__":
    37:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: jobs/backtest.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: import argparse, json
     4: from pathlib import Path
     5: from typing import Any, Dict, List
     6: from engine.config.loader import load_config
     7: from engine.config.watchlist import load_watchlist
     8: from engine.backtest.loader_csv import load_csv_ohlcv
     9: from engine.backtest.engine import run_backtest_once, compute_metrics, grid_params
    10: 
    11: def main() -> int:
    12:     ap = argparse.ArgumentParser(description="Backtests grid -> DATA_ROOT/reports")
    13:     ap.add_argument("--symbols", default="", help="Liste explicite (sinon watchlist)")
    14:     ap.add_argument("--from-watchlist", action="store_true", help="Utiliser la watchlist (top N)")
    15:     ap.add_argument("--tfs", required=True, help="1m,5m,15m,1h")
    16:     ap.add_argument("--out", default=None)
    17:     args = ap.parse_args()
    18: 
    19:     cfg = load_config()
    20:     data_dir = Path(cfg["runtime"]["data_dir"])
    21:     reports_dir = Path(args.out or cfg["runtime"]["reports_dir"])
    22:     reports_dir.mkdir(parents=True, exist_ok=True)
    23: 
    24:     if args.from_watchlist:
    25:         wl = load_watchlist()
    26:         symbols = [d["symbol"] for d in wl.get("top", [])]
    27:     else:
    28:         symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]
    29:     tfs = [t.strip() for t in args.tfs.split(",") if t.strip()]
    30: 
    31:     summary: List[Dict[str, Any]] = []
    32:     best: Dict[str, Dict[str, Any]] = {}
    33: 
    34:     for sym in symbols:
    35:         for tf in tfs:
    36:             csv_path = data_dir / f"{sym.replace('/','').replace('_','')}-{tf}.csv"
    37:             if not csv_path.exists():
    38:                 print(f"[!] CSV manquant: {csv_path} — fais d'abord jobs/refresh_pairs.py")
    39:                 continue
    40:             df = load_csv_ohlcv(csv_path)
    41:             best_score = None
    42:             best_params = None
    43:             for p in grid_params():
    44:                 res = run_backtest_once(sym, tf, df, params=p)
    45:                 m = res["metrics"]
    46:                 summary.append({"symbol": sym, "tf": tf, **p, **m})
    47:                 sc = float(m["score"])
    48:                 if (best_score is None) or (sc > best_score):
    49:                     best_score, best_params = sc, p
    50:             if best_params:
    51:                 best[f"{sym}:{tf}"] = best_params
    52: 
    53:     (reports_dir / "summary.json").write_text(json.dumps(summary, indent=2), encoding="utf-8")
    54:     (reports_dir / "strategies.yml.next").write_text(json.dumps({"strategies": best}, indent=2), encoding="utf-8")
    55:     print(f"[✓] Résumé -> {reports_dir/'summary.json'}")
    56:     print(f"[✓] Brouillon stratégie -> {reports_dir/'strategies.yml.next'}")
    57:     return 0
    58: 
    59: if __name__ == "__main__":
    60:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: jobs/dash.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: """
     3: jobs/dash.py — Lance le dashboard Streamlit du projet scalp
     4: Usage:
     5:     python jobs/dash.py
     6: Options:
     7:     --port 8501       Port HTTP (défaut 8501)
     8:     --headless true   Mode headless (recommandé en remote)
     9: """
    10: 
    11: import argparse
    12: import subprocess
    13: import sys
    14: from pathlib import Path
    15: 
    16: def main(argv=None):
    17:     ap = argparse.ArgumentParser()
    18:     ap.add_argument("--port", type=int, default=8501, help="Port HTTP (défaut 8501)")
    19:     ap.add_argument("--headless", action="store_true", help="Force mode headless")
    20:     args = ap.parse_args(argv)
    21: 
    22:     app_path = Path(__file__).resolve().parents[1] / "dash" / "app.py"
    23:     if not app_path.exists():
    24:         sys.exit(f"Dashboard introuvable: {app_path}")
    25: 
    26:     cmd = [
    27:         sys.executable, "-m", "streamlit", "run", str(app_path),
    28:         "--server.port", str(args.port),
    29:     ]
    30:     if args.headless:
    31:         cmd += ["--server.headless", "true"]
    32: 
    33:     print(f"[i] Lancement du dashboard Streamlit sur port {args.port} ...")
    34:     print(" ".join(cmd))
    35:     subprocess.run(cmd)
    36: 
    37: if __name__ == "__main__":
    38:     main()

--------------------------------------------------------------------------------
FILE: jobs/promote.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import argparse, json
     3: from pathlib import Path
     4: 
     5: def main() -> int:
     6:     ap = argparse.ArgumentParser(description="Promouvoir stratégies validées")
     7:     ap.add_argument("--draft", required=True, help=".../strategies.yml.next (JSON lisible)")
     8:     ap.add_argument("--target", default="engine/config/strategies.yml")
     9:     args = ap.parse_args()
    10: 
    11:     draft = Path(args.draft); target = Path(args.target)
    12:     if not draft.exists():
    13:         print(f"[!] Draft introuvable: {draft}"); return 1
    14:     target.parent.mkdir(parents=True, exist_ok=True)
    15:     if target.exists():
    16:         target.with_suffix(".yml.bak").write_text(target.read_text(encoding="utf-8"), encoding="utf-8")
    17:     target.write_text(draft.read_text(encoding="utf-8"), encoding="utf-8")
    18:     print(f"[✓] Stratégies promues -> {target}")
    19:     return 0
    20: 
    21: if __name__ == "__main__":
    22:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: jobs/refresh_pairs.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: import argparse, os, time
     4: from pathlib import Path
     5: from engine.config.loader import load_config
     6: from engine.exchange.bitget_rest import BitgetFuturesClient
     7: from engine.pairs.selector import select_top_pairs
     8: from engine.config.watchlist import save_watchlist
     9: from engine.backtest.loader_csv import write_csv_ohlcv
    10: 
    11: def main() -> int:
    12:     ap = argparse.ArgumentParser(description="Sélection dynamique des paires + backfill")
    13:     ap.add_argument("--universe", default="", help="Liste de symboles à considérer (sinon auto)")
    14:     ap.add_argument("--timeframe", default="5m")
    15:     ap.add_argument("--top", type=int, default=10)
    16:     ap.add_argument("--backfill-tfs", default="1m,5m,15m,1h", help="TF à stocker pour backtests")
    17:     ap.add_argument("--limit", type=int, default=2000, help="bougies par TF")
    18:     args = ap.parse_args()
    19: 
    20:     cfg = load_config()
    21:     client = BitgetFuturesClient(
    22:         access_key=cfg["secrets"]["bitget"]["access"],
    23:         secret_key=cfg["secrets"]["bitget"]["secret"],
    24:         passphrase=cfg["secrets"]["bitget"]["passphrase"],
    25:         base_url=os.getenv("BITGET_BASE_URL","https://api.bitget.com"),
    26:     )
    27: 
    28:     universe = [s.strip() for s in args.universe.split(",") if s.strip()] or None
    29:     top = select_top_pairs(client, universe=universe, timeframe=args.timeframe, top_n=int(args.top))
    30:     wl_path = save_watchlist(top)
    31:     print(f"[✓] Watchlist ({len(top)}) écrite -> {wl_path}")
    32: 
    33:     # Backfill pour ces paires sur les TF demandés
    34:     data_dir = Path(cfg["runtime"]["data_dir"])
    35:     tfs = [t.strip() for t in args.backfill_tfs.split(",") if t.strip()]
    36:     for item in top:
    37:         for tf in tfs:
    38:             resp = client.get_klines(item.symbol, interval=tf, limit=args.limit)
    39:             rows = resp.get("data") or []
    40:             write_csv_ohlcv(data_dir, item.symbol, tf, rows)
    41:             print(f"[↓] {item.symbol} {tf} -> {data_dir}")
    42:     print("[✓] Refresh pairs + backfill terminé.")
    43:     return 0
    44: 
    45: if __name__ == "__main__":
    46:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: jobs/viewer.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # jobs/viewer.py
     3: from __future__ import annotations
     4: 
     5: import argparse
     6: import json
     7: import os
     8: from pathlib import Path
     9: from typing import Any, Dict, Iterable, List, Sequence
    10: 
    11: from engine.config.loader import load_config
    12: 
    13: # ---------- utils paths ----------
    14: 
    15: def _data_root_cfg() -> Dict[str, str]:
    16:     cfg = load_config()
    17:     rt = cfg.get("runtime", {})
    18:     return {
    19:         "data_dir": rt.get("data_dir") or "/notebooks/scalp_data/data",
    20:         "reports_dir": rt.get("reports_dir") or "/notebooks/scalp_data/reports",
    21:     }
    22: 
    23: def _live_dir() -> Path:
    24:     return Path(_data_root_cfg()["data_dir"]) / "live"
    25: 
    26: def _orders_csv() -> Path:
    27:     return _live_dir() / "orders.csv"
    28: 
    29: def _signals_csv() -> Path:
    30:     return _live_dir() / "logs" / "signals.csv"
    31: 
    32: def _watchlist_yml() -> Path:
    33:     return Path(_data_root_cfg()["reports_dir"]) / "watchlist.yml"
    34: 
    35: def _strategies_yml() -> Path:
    36:     # stocké en JSON lisible (extension .yml)
    37:     return Path(__file__).resolve().parents[1] / "engine" / "config" / "strategies.yml"
    38: 
    39: # ---------- pretty helpers ----------
    40: 
    41: def _print_table(rows: Sequence[Sequence[Any]], headers: Sequence[str] | None = None) -> None:
    42:     if headers:
    43:         rows = [headers, ["-"*len(h) for h in headers], *rows]
    44:     widths = [max(len(str(r[i])) for r in rows) for i in range(len(rows[0]))] if rows else []
    45:     for r in rows:
    46:         line = " | ".join(str(v).ljust(widths[i]) for i, v in enumerate(r))
    47:         print(line)
    48: 
    49: def _tail(path: Path, n: int = 20) -> List[str]:
    50:     if not path.exists():
    51:         return []
    52:     try:
    53:         # simple tail sans dépendances
    54:         with path.open("r", encoding="utf-8", errors="ignore") as f:
    55:             lines = f.readlines()[-n:]
    56:         return [l.rstrip("\n") for l in lines]
    57:     except Exception:
    58:         return []
    59: 
    60: # ---------- viewers ----------
    61: 
    62: def cmd_watchlist(_: argparse.Namespace) -> int:
    63:     p = _watchlist_yml()
    64:     if not p.exists():
    65:         print(f"(watchlist introuvable) {p}")
    66:         return 1
    67:     try:
    68:         doc = json.loads(p.read_text(encoding="utf-8"))
    69:     except Exception:
    70:         print(f"(format non lisible) {p}")
    71:         return 1
    72:     top = doc.get("top") or []
    73:     rows = []
    74:     for d in top:
    75:         rows.append([d.get("symbol",""), f"{float(d.get('vol_usd_24h',0.0)):.0f}", f"{float(d.get('atr_pct_24h',0.0))*100:.2f}%", f"{float(d.get('score',0.0)):.3f}"])
    76:     _print_table(rows, headers=["SYMBOL","VOL_USD_24H","ATR% (approx)","SCORE"])
    77:     return 0
    78: 
    79: def cmd_strategies(_: argparse.Namespace) -> int:
    80:     p = _strategies_yml()
    81:     if not p.exists():
    82:         print(f"(strategies.yml introuvable) {p}")
    83:         return 1
    84:     try:
    85:         doc = json.loads(p.read_text(encoding="utf-8"))
    86:     except Exception:
    87:         print(f"(format non lisible) {p}")
    88:         return 1
    89:     strat = doc.get("strategies") or {}
    90:     rows = []
    91:     for k, v in strat.items():
    92:         rows.append([
    93:             k,
    94:             v.get("ema_fast",""),
    95:             v.get("ema_slow",""),
    96:             v.get("atr_period",""),
    97:             v.get("trail_atr_mult",""),
    98:             v.get("risk_pct_equity",""),
    99:         ])
   100:     rows.sort(key=lambda r: r[0])
   101:     _print_table(rows, headers=["PAIR:TF","ema_fast","ema_slow","atr_period","trail_mult","risk_pct"])
   102:     return 0
   103: 
   104: def cmd_tail_orders(ns: argparse.Namespace) -> int:
   105:     p = _orders_csv()
   106:     lines = _tail(p, ns.lines)
   107:     if not lines:
   108:         print(f"(pas de contenu) {p}")
   109:         return 0
   110:     print(f"# {p}")
   111:     for ln in lines:
   112:         print(ln)
   113:     return 0
   114: 
   115: def cmd_tail_signals(ns: argparse.Namespace) -> int:
   116:     p = _signals_csv()
   117:     lines = _tail(p, ns.lines)
   118:     if not lines:
   119:         print(f"(pas de contenu) {p}")
   120:         return 0
   121:     print(f"# {p}")
   122:     for ln in lines:
   123:         print(ln)
   124:     return 0
   125: 
   126: def cmd_status(_: argparse.Namespace) -> int:
   127:     dr = _data_root_cfg()
   128:     print("=== STATUS ===")
   129:     print("DATA_DIR    :", dr["data_dir"])
   130:     print("REPORTS_DIR :", dr["reports_dir"])
   131:     wl = _watchlist_yml()
   132:     st = _strategies_yml()
   133:     od = _orders_csv()
   134:     sg = _signals_csv()
   135:     print("watchlist   :", wl, "(ok)" if wl.exists() else "(absent)")
   136:     print("strategies  :", st, "(ok)" if st.exists() else "(absent)")
   137:     print("orders.csv  :", od, f"(tail {len(_tail(od,1)) and 'non-vide' or 'vide'})")
   138:     print("signals.csv :", sg, f"(tail {len(_tail(sg,1)) and 'non-vide' or 'vide'})")
   139:     return 0
   140: 
   141: # ---------- main ----------
   142: 
   143: def main(argv: Iterable[str] | None = None) -> int:
   144:     ap = argparse.ArgumentParser(description="Mini viewer scalp")
   145:     sub = ap.add_subparsers(dest="cmd", required=True)
   146: 
   147:     sub.add_parser("status", help="Résumé chemins + présence des fichiers").set_defaults(func=cmd_status)
   148:     sub.add_parser("watchlist", help="Affiche la watchlist top N").set_defaults(func=cmd_watchlist)
   149:     sub.add_parser("strategies", help="Affiche les stratégies promues").set_defaults(func=cmd_strategies)
   150: 
   151:     p1 = sub.add_parser("orders", help="Tail des ordres (paper ou réel)")
   152:     p1.add_argument("--lines", type=int, default=30)
   153:     p1.set_defaults(func=cmd_tail_orders)
   154: 
   155:     p2 = sub.add_parser("signals", help="Tail des signaux prix live")
   156:     p2.add_argument("--lines", type=int, default=30)
   157:     p2.set_defaults(func=cmd_tail_signals)
   158: 
   159:     ns = ap.parse_args(argv)
   160:     return int(ns.func(ns))
   161: 
   162: if __name__ == "__main__":
   163:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: pytest.ini  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: [pytest]
     2: addopts = -q

--------------------------------------------------------------------------------
FILE: requirements-dev.txt  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: annulé

--------------------------------------------------------------------------------
FILE: requirements.txt  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Dépendances principales du projet scalp
     2: 
     3: # HTTP / API
     4: requests>=2.31
     5: 
     6: # Data science
     7: pandas>=2.1
     8: numpy>=1.26
     9: 
    10: # Config et environnements
    11: PyYAML>=6.0
    12: python-dotenv>=1.0
    13: 
    14: # Dashboard (inclus par défaut pour éviter de multiplier les fichiers)
    15: streamlit>=1.33
    16: 
    17: # Exchange (optionnel mais utile si activé)
    18: ccxt>=4.0.0

--------------------------------------------------------------------------------
FILE: resultat.log  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: .................................................................................................                        [100%]
     2: 97 passed in 0.42s

--------------------------------------------------------------------------------
FILE: scalper/config/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from .loader import load_settings
     2: __all__ = ['load_settings']

--------------------------------------------------------------------------------
FILE: scalper/config/loader.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/config/loader.py
     2: from __future__ import annotations
     3: import os, json
     4: from typing import Any, Dict, Tuple
     5: 
     6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
     7: try:
     8:     import yaml  # type: ignore
     9: except Exception:
    10:     yaml = None  # fallback JSON si besoin
    11: 
    12: # dotenv (facultatif) pour charger un .env automatiquement
    13: try:
    14:     from dotenv import load_dotenv  # type: ignore
    15: except Exception:
    16:     load_dotenv = None
    17: 
    18: # ---------------- Utils ----------------
    19: 
    20: def _parse_bool(x: Any, default: bool = False) -> bool:
    21:     if isinstance(x, bool): return x
    22:     s = str(x).strip().lower()
    23:     if s in ("1","true","yes","y","on"): return True
    24:     if s in ("0","false","no","n","off",""): return False
    25:     return default
    26: 
    27: def _parse_float(x: Any, default: float | None = None) -> float | None:
    28:     try: return float(x)
    29:     except Exception: return default
    30: 
    31: def _parse_int(x: Any, default: int | None = None) -> int | None:
    32:     try: return int(str(x).strip())
    33:     except Exception: return default
    34: 
    35: def _parse_csv(x: Any) -> list[str]:
    36:     if x is None: return []
    37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
    38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
    39: 
    40: def _read_yaml(path: str) -> Dict[str, Any]:
    41:     if not os.path.exists(path): return {}
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         if yaml:
    44:             return yaml.safe_load(f) or {}
    45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
    46:         try:
    47:             return json.load(f)
    48:         except Exception:
    49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
    50: 
    51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    52:     # shallow merge suffisant ici (structure plate)
    53:     out = dict(a)
    54:     out.update({k: v for k, v in b.items() if v is not None})
    55:     return out
    56: 
    57: # ---------------- Public API ----------------
    58: 
    59: def load_settings(
    60:     config_path: str = "config.yml",
    61:     config_local_path: str = "config.local.yml",
    62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    63:     """
    64:     Retourne (config_runtime, secrets) :
    65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
    66:       - secrets        : clés API & tokens (NE PAS versionner)
    67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
    68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
    69:     """
    70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
    71:     if load_dotenv is not None:
    72:         load_dotenv(override=False)
    73: 
    74:     # 2) Charge YAML (config.yml + override local)
    75:     base = _read_yaml(config_path)
    76:     local = _read_yaml(config_local_path)
    77:     cfg = _merge_dict(base, local)
    78: 
    79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
    80:     env_overlay: Dict[str, Any] = {}
    81:     # Verbosité
    82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
    83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
    84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
    85:     # Runtime / Stratégie
    86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
    87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
    88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
    89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
    90:     # Watchlist
    91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
    92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
    93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
    94:     )
    95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
    96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
    97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
    98:     caps_env = os.getenv("CAPS_JSON")
    99:     if caps_env:
   100:         try:
   101:             env_overlay["CAPS"] = json.loads(caps_env)
   102:         except Exception:
   103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
   104:     else:
   105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
   106: 
   107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
   108:     secrets = {
   109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
   110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
   111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
   112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
   113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
   114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
   115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
   116:     }
   117: 
   118:     # 5) Runtime normalisé pour l’orchestrateur
   119:     runtime = {
   120:         "quiet": bool(env_overlay["QUIET"]),
   121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
   122:         "timeframe": str(env_overlay["TIMEFRAME"]),
   123:         "cash": float(env_overlay["CASH"]),
   124:         "risk_pct": float(env_overlay["RISK_PCT"]),
   125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
   126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
   127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
   128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
   129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
   130:         "caps": env_overlay["CAPS"],                        # dict
   131:         # rempli au boot par les frais Bitget
   132:         "fees_by_symbol": {}, 
   133:     }
   134: 
   135:     return runtime, secrets
   136:     

--------------------------------------------------------------------------------
FILE: scalper/config/strategies.yml  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/config/strategies.yml
     2: default: current
     3: by_timeframe:
     4:   "1m": current
     5:   "5m": current
     6:   "15m": current
     7:   "1h": current
     8: by_symbol:
     9:   BTCUSDT:
    10:     "1m": current
    11:     "5m": current
    12:   ETHUSDT:
    13:     "5m": current

--------------------------------------------------------------------------------
FILE: scalper/exchange/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # Rend le sous-package exchanges importable
     2: __all__ = ["bitget"]

--------------------------------------------------------------------------------
FILE: scalper/exchange/bitget.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/exchange/bitget.py
     2: from __future__ import annotations
     3: import os
     4: import requests
     5: from typing import List, Dict, Any
     6: 
     7: BASE_URL = "https://api.bitget.com"
     8: 
     9: # Spot: period strings
    10: _SPOT_PERIOD = {
    11:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min", "30m": "30min",
    12:     "1h": "1hour", "4h": "4hour", "6h": "6hour", "12h": "12hour",
    13:     "1d": "1day", "3d": "3day", "1w": "1week",
    14: }
    15: # Mix: granularity seconds
    16: _MIX_GRAN = {
    17:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    18:     "1h": 3600, "4h": 14400, "6h": 21600, "12h": 43200,
    19:     "1d": 86400, "3d": 259200, "1w": 604800,
    20: }
    21: 
    22: def _market_from_symbol(symbol: str) -> str:
    23:     s = symbol.upper()
    24:     if s.endswith("_SPBL"):
    25:         return "spot"
    26:     if s.endswith("_UMCBL"):
    27:         return "umcbl"
    28:     if s.endswith("_DMCBL"):
    29:         return "dmcbl"
    30:     if s.endswith("_CMCBL"):
    31:         return "cmcbl"
    32:     # fallback env / défaut umcbl
    33:     return os.getenv("BITGET_MARKET", "umcbl").lower()
    34: 
    35: def _product_type(market: str) -> str:
    36:     # valeur attendue par les endpoints mix (umcbl/dmcbl/cmcbl)
    37:     if market in ("umcbl", "dmcbl", "cmcbl"):
    38:         return market
    39:     return "umcbl"
    40: 
    41: class BitgetExchange:
    42:     """
    43:     Wrapper simple: get_ohlcv(symbol, timeframe, limit) -> [[ts, o, h, l, c, v], ...]
    44:     symbol spot ex: BTCUSDT_SPBL
    45:     symbol perp ex: BTCUSDT_UMCBL / BTCUSD_DMCBL / BTCUSD_CMCBL
    46:     """
    47:     def __init__(self, api_key: str = "", api_secret: str = "", api_passphrase: str = "", timeout: int = 20) -> None:
    48:         self.session = requests.Session()
    49:         self.session.headers.update({"User-Agent": "scalp-bot/1.0"})
    50:         self.timeout = timeout
    51: 
    52:     def _get(self, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
    53:         url = BASE_URL + path
    54:         r = self.session.get(url, params=params, timeout=self.timeout)
    55:         r.raise_for_status()
    56:         data = r.json()
    57:         # Bitget: {"code":"00000","msg":"success","requestTime":..., "data":[...]}
    58:         if not isinstance(data, dict) or str(data.get("code")) not in ("00000", "0", "200"):
    59:             raise RuntimeError(f"Bitget error payload: {data}")
    60:         return data
    61: 
    62:     def get_ohlcv(self, symbol: str, timeframe: str = "5m", limit: int = 500) -> List[List[float]]:
    63:         timeframe = timeframe.lower()
    64:         mkt = _market_from_symbol(symbol)
    65: 
    66:         if mkt == "spot":
    67:             period = _SPOT_PERIOD.get(timeframe)
    68:             if not period:
    69:                 raise ValueError(f"timeframe spot non supporté: {timeframe}")
    70:             # Bitget spot: limit max souvent 1000
    71:             lim = max(1, min(int(limit), 1000))
    72:             params = {"symbol": symbol, "period": period, "limit": lim}
    73:             data = self._get("/api/spot/v1/market/candles", params=params)
    74:             rows = data.get("data") or []
    75:             out: List[List[float]] = []
    76:             # Bitget renvoie décroissant -> on inverse
    77:             for r in reversed(rows):
    78:                 ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
    79:                 out.append([ts, o, h, l, c, v])
    80:             return out
    81: 
    82:         # MIX (umcbl/dmcbl/cmcbl)
    83:         gran = _MIX_GRAN.get(timeframe)
    84:         if not gran:
    85:             raise ValueError(f"timeframe mix non supporté: {timeframe}")
    86: 
    87:         # Bitget mix: limit max souvent 200, granularity en secondes, productType parfois requis
    88:         lim = max(1, min(int(limit), 200))
    89:         params = {
    90:             "symbol": symbol,
    91:             "granularity": int(gran),
    92:             "limit": lim,
    93:             "productType": _product_type(mkt),
    94:         }
    95: 
    96:         # essais: candles -> history-candles (certaines régions)
    97:         try:
    98:             data = self._get("/api/mix/v1/market/candles", params=params)
    99:         except requests.HTTPError:
   100:             data = self._get("/api/mix/v1/market/history-candles", params=params)
   101: 
   102:         rows = data.get("data") or []
   103:         out: List[List[float]] = []
   104:         for r in reversed(rows):
   105:             ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
   106:             out.append([ts, o, h, l, c, v])
   107:         return out

--------------------------------------------------------------------------------
FILE: scalper/exchange/bitget_ccxt.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/exchange/bitget_ccxt.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Any, List, Optional
     9: 
    10: # CCXT async
    11: try:
    12:     import ccxt.async_support as ccxt
    13: except Exception as e:  # noqa: BLE001
    14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
    15: 
    16: 
    17: def _now_ms() -> int:
    18:     return int(time.time() * 1000)
    19: 
    20: 
    21: class BitgetExchange:
    22:     """
    23:     Échange Bitget via CCXT (async) avec cache CSV local.
    24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
    25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
    26:         [[ts, open, high, low, close, volume], ...]
    27:     """
    28: 
    29:     def __init__(
    30:         self,
    31:         *,
    32:         api_key: Optional[str] = None,
    33:         secret: Optional[str] = None,
    34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
    35:         data_dir: str = "/notebooks/data",
    36:         use_cache: bool = True,
    37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
    38:         spot: bool = True,           # True = SPOT (recommandé ici)
    39:     ) -> None:
    40:         self.data_dir = data_dir
    41:         self.use_cache = use_cache
    42:         self.min_fresh = int(min_fresh_seconds)
    43:         self.spot = spot
    44: 
    45:         os.makedirs(self.data_dir, exist_ok=True)
    46: 
    47:         # Instance CCXT (async)
    48:         self.ex = ccxt.bitget({
    49:             "apiKey": api_key or "",
    50:             "secret": secret or "",
    51:             "password": password or "",
    52:             "enableRateLimit": True,
    53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
    54:         })
    55: 
    56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
    57:         self._markets_task: Optional[asyncio.Task[Any]] = None
    58: 
    59:     async def _ensure_markets(self) -> None:
    60:         if self._markets_task is None:
    61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
    62:         await self._markets_task
    63: 
    64:     # ---------- CSV cache ----------
    65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
    66:         safe = symbol.replace("/", "").replace(":", "")
    67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
    68: 
    69:     def _read_cache(self, path: str) -> List[List[float]]:
    70:         if not os.path.exists(path):
    71:             return []
    72:         rows: List[List[float]] = []
    73:         try:
    74:             with open(path, "r", newline="") as f:
    75:                 rd = csv.reader(f)
    76:                 for r in rd:
    77:                     if not r:
    78:                         continue
    79:                     # ts, o, h, l, c, v
    80:                     try:
    81:                         rows.append([
    82:                             int(r[0]),
    83:                             float(r[1]),
    84:                             float(r[2]),
    85:                             float(r[3]),
    86:                             float(r[4]),
    87:                             float(r[5]),
    88:                         ])
    89:                     except Exception:
    90:                         # on ignore les lignes corrompues
    91:                         continue
    92:         except Exception:
    93:             return []
    94:         return rows
    95: 
    96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
    97:         # On ré‑écrit intégralement (simple et sûr)
    98:         tmp = path + ".tmp"
    99:         with open(tmp, "w", newline="") as f:
   100:             wr = csv.writer(f)
   101:             wr.writerows(data)
   102:         os.replace(tmp, path)
   103: 
   104:     # ---------- API publique pour orchestrateur ----------
   105:     async def fetch_ohlcv(
   106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
   107:     ) -> List[List[float]]:
   108:         """
   109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
   110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
   111:         """
   112:         await self._ensure_markets()
   113: 
   114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
   115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
   116:         cache_path = self._csv_path(symbol, timeframe)
   117: 
   118:         # 1) Cache
   119:         if self.use_cache:
   120:             cached = self._read_cache(cache_path)
   121:             if cached:
   122:                 # fraicheur = diff entre maintenant et ts dernière bougie
   123:                 last_ts = int(cached[-1][0])
   124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
   125:                     # suffisant => on retourne la fin
   126:                     if len(cached) >= limit:
   127:                         return cached[-limit:]
   128:                     # pas assez, on essaiera de compléter via CCXT plus bas
   129:                 # sinon: on tentera de rafraîchir plus loin
   130: 
   131:         # 2) Remote via CCXT
   132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
   133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
   134:         params: dict[str, Any] = {}
   135:         if self.spot is True:
   136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
   137: 
   138:         try:
   139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
   140:         except Exception as e:  # noqa: BLE001
   141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
   142:             cached = self._read_cache(cache_path) if self.use_cache else []
   143:             if cached:
   144:                 return cached[-limit:]
   145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
   146: 
   147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
   148:         if self.use_cache:
   149:             base = self._read_cache(cache_path)
   150:             merged = _merge_ohlcv(base, ohlcv)
   151:             self._write_cache(cache_path, merged)
   152:             # retourne la fin
   153:             return merged[-limit:]
   154: 
   155:         return ohlcv[-limit:]
   156: 
   157:     async def close(self) -> None:
   158:         try:
   159:             await self.ex.close()
   160:         except Exception:
   161:             pass
   162: 
   163: 
   164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
   165:     """
   166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
   167:     """
   168:     if not a:
   169:         return list(b)
   170:     if not b:
   171:         return list(a)
   172: 
   173:     # index rapide par ts
   174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
   175:     for row in b:
   176:         by_ts[int(row[0])] = row
   177:     return [by_ts[k] for k in sorted(by_ts)]

--------------------------------------------------------------------------------
FILE: scalper/exchange/fees.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/exchange/fees.py
     2: from __future__ import annotations
     3: 
     4: from typing import Dict, Iterable
     5: 
     6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
     7: DEFAULT_TAKER_BPS = 6    # 0.06%
     8: DEFAULT_MAKER_BPS = 2    # 0.02%
     9: 
    10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
    11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
    12: 
    13: 
    14: def get_fee(symbol: str, kind: str = "taker") -> float:
    15:     """
    16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
    17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
    18:     """
    19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
    20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
    21:     return float(bps) / 10_000.0
    22: 
    23: 
    24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
    25:     """
    26:     Tente de charger les frais auprès de l'exchange (type ccxt):
    27:       - fetch_trading_fees(symbols) si dispo
    28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
    29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
    30:     """
    31:     symbols = list(symbols)
    32:     fees: Dict[str, Dict[str, float]] = {}
    33: 
    34:     try:
    35:         if hasattr(exchange, "fetch_trading_fees"):
    36:             data = await exchange.fetch_trading_fees(symbols)
    37:             for s in symbols:
    38:                 d = (data or {}).get(s, {}) or {}
    39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    42:         else:
    43:             for s in symbols:
    44:                 try:
    45:                     d = await exchange.fetch_trading_fee(s)
    46:                 except Exception:
    47:                     d = {}
    48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    51:     except Exception:
    52:         # fallback: défauts
    53:         for s in symbols:
    54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
    55: 
    56:     # maj du cache
    57:     _FEES_BY_SYMBOL.update(fees)
    58:     return fees

--------------------------------------------------------------------------------
FILE: scalper/live/__init__.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: __all__ = ["orchestrator", "fetcher", "runner"]

--------------------------------------------------------------------------------
FILE: scalper/live/backtest_telegram.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/backtest_telegram.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import os
     6: from typing import List
     7: 
     8: from engine.backtest import BTCfg, run_multi
     9: from engine.services.utils import safe_call
    10: 
    11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
    12: async def _get_exchange():
    13:     try:
    14:         import ccxt.async_support as ccxt  # type: ignore
    15:     except Exception:
    16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
    17:     return ccxt.bitget()
    18: 
    19: def _parse_symbols(defaults: List[str]) -> List[str]:
    20:     env = os.getenv("BACKTEST_SYMBOLS", "")
    21:     if env.strip():
    22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
    23:     return defaults
    24: 
    25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
    26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
    27:     symbols = _parse_symbols(defaults)
    28:     cash = float(os.getenv("BT_CASH", "10000"))
    29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
    30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
    31:     limit = int(os.getenv("BT_LIMIT", "1500"))
    32: 
    33:     await notifier.send(
    34:         "🧪 Backtest en cours...\n"
    35:         f"• Symbols: {', '.join(symbols)}\n"
    36:         f"• TF: {timeframe}\n"
    37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
    38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
    39:     )
    40: 
    41:     async def _run():
    42:         exchange = await _get_exchange()
    43:         try:
    44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
    45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
    46:             res = await run_multi(cfg, exchange)
    47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
    48:         finally:
    49:             try:
    50:                 await exchange.close()
    51:             except Exception:
    52:                 pass
    53: 
    54:     try:
    55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
    56:     except Exception as e:
    57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")

--------------------------------------------------------------------------------
FILE: scalper/live/commands.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/commands.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: from typing import Awaitable, Callable
     6: 
     7: 
     8: class CommandHandler:
     9:     """
    10:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
    11:     Chaque commande est routée vers un callback approprié.
    12:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
    13:     """
    14: 
    15:     def __init__(self, notifier, command_stream, status_getter, status_sender):
    16:         self.notifier = notifier
    17:         self.stream = command_stream
    18:         self.status_getter = status_getter
    19:         self.status_sender = status_sender
    20: 
    21:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
    22:         try:
    23:             await coro
    24:         except Exception as e:
    25:             try:
    26:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
    27:             except Exception:
    28:                 pass  # on ne propage jamais
    29: 
    30:     async def run(
    31:         self,
    32:         on_pause: Callable[[], None],
    33:         on_resume: Callable[[], None],
    34:         on_stop: Callable[[], Awaitable[None]] | None,
    35:         on_setup_apply: Callable[[dict], None],
    36:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
    37:     ):
    38:         """
    39:         Boucle asynchrone qui lit les lignes du CommandStream
    40:         et exécute le callback approprié.
    41:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
    42:         """
    43:         async for line in self.stream:
    44:             txt = (line or "").strip()
    45:             if not txt:
    46:                 continue
    47: 
    48:             try:
    49:                 if txt.startswith("/pause"):
    50:                     on_pause()
    51:                     await self.notifier.send("⏸️ Pause.")
    52: 
    53:                 elif txt.startswith("/resume"):
    54:                     on_resume()
    55:                     await self.notifier.send("▶️ Resume.")
    56: 
    57:                 elif txt.startswith("/stop"):
    58:                     if on_stop:
    59:                         await self._safe_call(on_stop(), "Arrêt échoué")
    60: 
    61:                 elif txt.startswith("/status"):
    62:                     snap = self.status_getter()
    63:                     await self.notifier.send(f"ℹ️ {snap}")
    64: 
    65:                 elif txt.startswith("/setup"):
    66:                     await self.notifier.send("🧩 Setup wizard à compléter.")
    67: 
    68:                 elif txt.startswith("/backtest"):
    69:                     if on_backtest:
    70:                         tail = txt[len("/backtest"):].strip()
    71:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
    72:                         asyncio.create_task(self._safe_call(
    73:                             on_backtest(tail), "Backtest échoué"
    74:                         ))
    75:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
    76:                     else:
    77:                         await self.notifier.send("⚠️ Backtest non disponible.")
    78: 
    79:                 else:
    80:                     await self.notifier.send(
    81:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
    82:                     )
    83: 
    84:             except Exception as e:
    85:                 # On protège la boucle quoi qu'il arrive
    86:                 try:
    87:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
    88:                 except Exception:
    89:                     pass

--------------------------------------------------------------------------------
FILE: scalper/live/data_utils.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/data_utils.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Sequence
     4: 
     5: Cols = ("timestamp", "open", "high", "low", "close", "volume")
     6: 
     7: def ohlcv_rows_to_dict(rows: Sequence[Sequence[float]]) -> Dict[str, List[float]]:
     8:     """
     9:     Convertit [[ts,o,h,l,c,v], ...] -> dict de listes.
    10:     Tolère float|int|str numériques.
    11:     """
    12:     out: Dict[str, List[float]] = {k: [] for k in Cols}
    13:     for r in rows:
    14:         if len(r) < 6:
    15:             raise ValueError("Ligne OHLCV invalide (6 colonnes attendues).")
    16:         out["timestamp"].append(float(r[0]))
    17:         out["open"].append(float(r[1]))
    18:         out["high"].append(float(r[2]))
    19:         out["low"].append(float(r[3]))
    20:         out["close"].append(float(r[4]))
    21:         out["volume"].append(float(r[5]))
    22:     return out
    23: 
    24: def ohlcv_df_or_dict_to_dict(obj) -> Dict[str, List[float]]:
    25:     """
    26:     Accepte:
    27:       - pandas.DataFrame avec colonnes Cols
    28:       - dict de listes
    29:     """
    30:     if hasattr(obj, "columns"):
    31:         missing = [c for c in Cols if c not in obj.columns]
    32:         if missing:
    33:             raise ValueError(f"Colonnes OHLCV manquantes: {missing}")
    34:         return {k: [float(x) for x in obj[k].tolist()] for k in Cols}
    35:     if isinstance(obj, dict):
    36:         missing = [c for c in Cols if c not in obj]
    37:         if missing:
    38:             raise ValueError(f"Clés OHLCV manquantes: {missing}")
    39:         return {k: [float(x) for x in obj[k]] for k in Cols}
    40:     raise TypeError("Format OHLCV non supporté (DataFrame ou dict attendu).")
    41: 
    42: def map_index_secondary(ts_main: float, ts_arr: List[float]) -> int:
    43:     """
    44:     Retourne l'index i du timestamp secondaire le plus proche
    45:     inférieur/égal à ts_main. Recherche linéaire suffisante en live.
    46:     """
    47:     j = 0
    48:     n = len(ts_arr)
    49:     while j + 1 < n and ts_arr[j + 1] <= ts_main:
    50:         j += 1
    51:     return j

--------------------------------------------------------------------------------
FILE: scalper/live/fetcher.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/fetcher.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional, Any
     4: 
     5: class DataFetcher:
     6:     """
     7:     Récupération OHLCV depuis un client d'exchange.
     8:     Compatible:
     9:       - Wrapper custom: client.get_ohlcv(symbol, timeframe, limit)
    10:       - ccxt direct:    client.fetch_ohlcv(symbol, timeframe=..., limit=...)
    11:     Retour standardisé: dict[str, list[float]] avec clés:
    12:       timestamp, open, high, low, close, volume
    13:     """
    14:     def __init__(self, client: Any) -> None:
    15:         self.client = client
    16:         # Détection des méthodes disponibles
    17:         self._has_get = hasattr(client, "get_ohlcv")
    18:         self._has_fetch = hasattr(client, "fetch_ohlcv")
    19: 
    20:         if not (self._has_get or self._has_fetch):
    21:             raise AttributeError(
    22:                 "Le client exchange doit exposer get_ohlcv(...) ou fetch_ohlcv(...). "
    23:                 "Ex: wrapper custom ou objet ccxt.bitget."
    24:             )
    25: 
    26:     @staticmethod
    27:     def _to_dict(rows: List[List[float]]) -> Dict[str, List[float]]:
    28:         cols = ("timestamp", "open", "high", "low", "close", "volume")
    29:         out = {k: [] for k in cols}
    30:         for r in rows:
    31:             # rows: [ts, open, high, low, close, volume]
    32:             out["timestamp"].append(float(r[0]))
    33:             out["open"].append(float(r[1]))
    34:             out["high"].append(float(r[2]))
    35:             out["low"].append(float(r[3]))
    36:             out["close"].append(float(r[4]))
    37:             out["volume"].append(float(r[5]))
    38:         return out
    39: 
    40:     def fetch(self, symbol: str, timeframe: str, limit: int = 1500) -> Dict[str, List[float]]:
    41:         if self._has_get:
    42:             rows = self.client.get_ohlcv(symbol=symbol, timeframe=timeframe, limit=limit)
    43:         else:
    44:             # ccxt: fetch_ohlcv(symbol, timeframe=..., limit=...)
    45:             rows = self.client.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    46:         return self._to_dict(rows)
    47: 
    48:     def try_fetch_1h(self, symbol: str, limit: int = 1500) -> Optional[Dict[str, List[float]]]:
    49:         try:
    50:             if self._has_get:
    51:                 rows = self.client.get_ohlcv(symbol=symbol, timeframe="1h", limit=limit)
    52:             else:
    53:                 rows = self.client.fetch_ohlcv(symbol, timeframe="1h", limit=limit)
    54:             return self._to_dict(rows)
    55:         except Exception:
    56:             return None

--------------------------------------------------------------------------------
FILE: scalper/live/journal.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import os, csv
     3: from typing import Any, Dict, List
     4: 
     5: class LogWriter:
     6:     """Gestion simple des CSV (création à la volée + append)."""
     7:     def __init__(self, dirpath: str) -> None:
     8:         self.dir = dirpath
     9:         os.makedirs(self.dir, exist_ok=True)
    10: 
    11:     def init(self, fname: str, headers: List[str]) -> None:
    12:         p = os.path.join(self.dir, fname)
    13:         if not os.path.exists(p):
    14:             with open(p, "w", newline="", encoding="utf-8") as f:
    15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
    16: 
    17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
    18:         p = os.path.join(self.dir, fname)
    19:         with open(p, "a", newline="", encoding="utf-8") as f:
    20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)

--------------------------------------------------------------------------------
FILE: scalper/live/logs.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/live/logs.py
     2: from __future__ import annotations
     3: import os, csv
     4: from typing import Any, List, Dict
     5: 
     6: class CsvLog:
     7:     def __init__(self, path: str, headers: List[str]):
     8:         self.path = path
     9:         self.headers = headers
    10:         self._ensure_header()
    11: 
    12:     def _ensure_header(self):
    13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
    14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
    15:         if must_write:
    16:             with open(self.path, "w", newline="") as f:
    17:                 csv.writer(f).writerow(self.headers)
    18: 
    19:     def write_row(self, row: Dict[str, Any]):
    20:         with open(self.path, "a", newline="") as f:
    21:             w = csv.DictWriter(f, fieldnames=self.headers)
    22:             w.writerow({k: row.get(k, "") for k in self.headers})

--------------------------------------------------------------------------------
FILE: scalper/live/loops/trade.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalp/live/loops/trade.py
     2: from __future__ import annotations
     3: import asyncio, os
     4: from dataclasses import dataclass, field
     5: from typing import Any, Dict, List, Callable
     6: 
     7: from ...services.utils import safe_call
     8: from ...risk.manager import compute_size
     9: 
    10: QUIET = int(os.getenv("QUIET", "0") or "0")
    11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
    12: 
    13: class PositionFSM:
    14:     def __init__(self):
    15:         self.state = "FLAT"
    16:         self.side = "flat"
    17:         self.entry = 0.0
    18:         self.qty = 0.0
    19:     def can_open(self): return self.state == "FLAT"
    20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
    21:     def can_close(self): return self.state == "OPEN"
    22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
    23: 
    24: @dataclass
    25: class SymbolContext:
    26:     symbol: str
    27:     timeframe: str
    28:     ohlcv: List[List[float]] = field(default_factory=list)
    29:     ticks: int = 0
    30:     fsm: PositionFSM = field(default_factory=PositionFSM)
    31: 
    32: class TradeLoop:
    33:     """
    34:     Boucle par symbole, indépendante de l'orchestrateur.
    35:     """
    36:     def __init__(
    37:         self,
    38:         symbol: str,
    39:         timeframe: str,
    40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
    41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
    42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
    43:         config: Dict[str, Any],
    44:         mode_getter: Callable[[], str],
    45:         log_signals, log_orders, log_fills,
    46:         tick_counter_add: Callable[[int], None],
    47:     ):
    48:         self.symbol = symbol
    49:         self.timeframe = timeframe
    50:         self.fetch = ohlcv_fetch
    51:         self.order_market = order_market
    52:         self.generate_signal = generate_signal
    53:         self.config = config
    54:         self.get_mode = mode_getter
    55:         self.log_signals = log_signals
    56:         self.log_orders = log_orders
    57:         self.log_fills = log_fills
    58:         self.ctx = SymbolContext(symbol, timeframe)
    59:         self._tick_add = tick_counter_add
    60: 
    61:         # Risk/frais
    62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
    63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
    64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
    65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
    66: 
    67:     def _bps_for(self, order_type: str = "market") -> float:
    68:         # market -> taker; limit post-only -> maker
    69:         per = self.fees_map.get(self.symbol, {})
    70:         if order_type == "limit":
    71:             return float(per.get("maker_bps", 0.0))
    72:         return float(per.get("taker_bps", 0.0))
    73: 
    74:     async def run(self, running: Callable[[], bool]):
    75:         lookback = 200
    76:         while running():
    77:             if self.get_mode() != "RUNNING":
    78:                 await asyncio.sleep(0.5); continue
    79: 
    80:             async def _fetch():
    81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
    82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
    83:             if not ohlcv or len(ohlcv) < lookback+1:
    84:                 await asyncio.sleep(1.0); continue
    85: 
    86:             self.ctx.ohlcv = ohlcv
    87:             self.ctx.ticks += 1
    88:             self._tick_add(1)
    89: 
    90:             window = ohlcv[-(lookback+1):]
    91:             ts, _o, _h, _l, c, _v = window[-1]
    92: 
    93:             try:
    94:                 sig = self.generate_signal(window, self.config) or {}
    95:             except Exception as e:
    96:                 if not QUIET:
    97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
    98:                 await asyncio.sleep(0.5); continue
    99: 
   100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
   101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
   102: 
   103:             # --- Entrée (market -> taker)
   104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
   105:                 balance = float(self.config.get("cash", 10_000.0))
   106:                 qty = compute_size(
   107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
   108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
   109:                 )
   110:                 if qty > 0:
   111:                     async def _place():
   112:                         return await self.order_market(self.symbol, side, qty)
   113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
   114:                     self.ctx.fsm.on_open(side, entry or c, qty)
   115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
   116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
   117: 
   118:             # --- Sortie (market -> taker)
   119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
   120:                 qty = self.ctx.fsm.qty
   121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
   122:                 async def _close():
   123:                     return await self.order_market(self.symbol, exit_side, qty)
   124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
   125: 
   126:                 # fill avec slippage + frais (taker)
   127:                 price_fill = float(c)
   128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
   129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
   130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
   131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
   132:                                           "order_id": (order or {}).get("id","")})
   133:                 self.ctx.fsm.on_close()
   134: 
   135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
   136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
   137: 
   138:             await asyncio.sleep(0.1 if QUIET else 0.01)

--------------------------------------------------------------------------------
FILE: scalper/live/notify.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: from __future__ import annotations
     3: import os
     4: import asyncio
     5: from dataclasses import dataclass
     6: from typing import AsyncIterator, Optional
     7: 
     8: 
     9: @dataclass
    10: class BaseNotifier:
    11:     async def send(self, text: str) -> None:  # pragma: no cover
    12:         print(text)
    13: 
    14: 
    15: class NullNotifier(BaseNotifier):
    16:     pass
    17: 
    18: 
    19: class TelegramNotifier(BaseNotifier):
    20:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
    21:         import aiohttp  # lazy
    22:         self._token = token
    23:         self._chat = chat_id
    24:         self._session: aiohttp.ClientSession | None = None
    25: 
    26:     async def _ensure(self):
    27:         import aiohttp
    28:         if self._session is None or self._session.closed:
    29:             self._session = aiohttp.ClientSession()
    30: 
    31:     async def send(self, text: str) -> None:
    32:         import aiohttp
    33:         await self._ensure()
    34:         # pas de markdown pour éviter les erreurs 400 de parsing
    35:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
    36:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
    37:         try:
    38:             async with self._session.post(url, json=payload, timeout=20) as r:
    39:                 await r.text()  # on ignore la réponse pour rester simple
    40:         except Exception:
    41:             # on fait un fallback silencieux pour ne pas casser le bot
    42:             print("[notify:telegram] send fail (ignored)")
    43: 
    44:     async def close(self):
    45:         if self._session and not self._session.closed:
    46:             await self._session.close()
    47: 
    48: 
    49: class _NullCommands:
    50:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
    51:     def __aiter__(self) -> AsyncIterator[str]:
    52:         return self
    53:     async def __anext__(self) -> str:
    54:         await asyncio.sleep(3600)  # jamais
    55:         raise StopAsyncIteration
    56: 
    57: 
    58: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
    59:     """
    60:     Retourne (notifier, command_stream).
    61: 
    62:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
    63:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
    64:       commandes interactives plus tard.
    65:     - Sinon: NullNotifier + flux vide.
    66:     """
    67:     token = os.getenv("TELEGRAM_BOT_TOKEN")
    68:     chat = os.getenv("TELEGRAM_CHAT_ID")
    69:     if token and chat:
    70:         print("[notify] TELEGRAM configured.")
    71:         return TelegramNotifier(token, chat), _NullCommands()
    72:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
    73:     return NullNotifier(), _NullCommands()

--------------------------------------------------------------------------------
FILE: scalper/live/ohlcv_service.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import time
     3: from typing import Any, Dict, List, Optional
     4: 
     5: try:
     6:     from engine.adapters.market_data import MarketData
     7: except Exception:
     8:     MarketData = None  # type: ignore
     9: 
    10: class OhlcvService:
    11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
    12:     def __init__(self, exchange) -> None:
    13:         self.exchange = exchange
    14:         self.md = MarketData(exchange) if MarketData is not None else None
    15: 
    16:     @staticmethod
    17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
    18:         out: List[Dict[str, float]] = []
    19:         if not rows: return out
    20:         for r in rows:
    21:             if isinstance(r, dict):
    22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
    23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
    24:                 v = float(r.get("volume", r.get("vol", 0.0)))
    25:             else:
    26:                 rr = list(r)
    27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
    28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
    29:                 else:
    30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
    31:                     h = float(rr[1]) if len(rr) > 1 else o
    32:                     l = float(rr[2]) if len(rr) > 2 else o
    33:                     c = float(rr[3]) if len(rr) > 3 else o
    34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
    35:                     ts = int(rr[5]) if len(rr) > 5 else 0
    36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
    37:         return out
    38: 
    39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
    40:         # 1) MarketData (si dispo)
    41:         if self.md is not None:
    42:             try:
    43:                 d = self.md.get_ohlcv(symbol, interval, limit)
    44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
    45:                     return self.normalize_rows(d["data"])
    46:             except Exception:
    47:                 pass
    48: 
    49:         # 2) Exchange natif
    50:         rows: List[Any] = []
    51:         try:
    52:             data = self.exchange.get_kline(symbol, interval=interval)
    53:         except Exception:
    54:             data = None
    55: 
    56:         if isinstance(data, dict):
    57:             rows = (
    58:                 data.get("data") or data.get("result") or data.get("records") or
    59:                 data.get("list") or data.get("items") or data.get("candles") or []
    60:             )
    61:             guard = 0
    62:             while isinstance(rows, dict) and guard < 3:
    63:                 rows = (
    64:                     rows.get("data") or rows.get("result") or rows.get("records") or
    65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
    66:                 )
    67:                 guard += 1
    68:         elif isinstance(data, (list, tuple)):
    69:             rows = list(data)
    70: 
    71:         out = self.normalize_rows(rows)[-limit:]
    72:         if out: return out
    73: 
    74:         # 3) Fallback strict via ticker -> bougie synthétique
    75:         try:
    76:             tkr = self.exchange.get_ticker(symbol)
    77:             items = []
    78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
    79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
    80:             if items:
    81:                 last = items[0]
    82:                 if isinstance(last, dict):
    83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
    84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
    85:                 else:
    86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
    87:                 ts = int(time.time()*1000)
    88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
    89:         except Exception:
    90:             pass
    91:         return []

--------------------------------------------------------------------------------
FILE: scalper/live/orchestrator.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/orchestrator.py
     2: from __future__ import annotations
     3: import time
     4: from typing import List, Tuple, Dict, Any
     5: from engine.live.fetcher import DataFetcher
     6: from engine.live.runner import JobRunner
     7: 
     8: class Orchestrator:
     9:     def __init__(
    10:         self,
    11:         *,
    12:         exchange_client: Any,
    13:         strategies_cfg: Dict[str, Any],
    14:         jobs: List[Tuple[str, str]],   # [(symbol, timeframe)]
    15:         interval_sec: int = 60,
    16:         equity: float = 1000.0,
    17:         risk_pct: float = 0.01,
    18:     ) -> None:
    19:         self.fetcher = DataFetcher(exchange_client)
    20:         self.runner = JobRunner(strategies_cfg, equity, risk_pct)
    21:         self.jobs = [(s.upper(), tf) for s, tf in jobs]
    22:         self.interval = max(5, int(interval_sec))
    23: 
    24:     def _tick(self) -> None:
    25:         for symbol, tf in self.jobs:
    26:             try:
    27:                 data = self.fetcher.fetch(symbol, tf)
    28:                 data_1h = self.fetcher.try_fetch_1h(symbol)
    29:                 sig = self.runner.run_once(symbol=symbol, timeframe=tf, ohlcv=data, ohlcv_1h=data_1h)
    30:                 if sig is None:
    31:                     print(f"[{symbol}/{tf}] Aucun signal.")
    32:                 else:
    33:                     d = sig.as_dict()
    34:                     print(f"[{symbol}/{tf}] side={d['side']} entry={d['entry']:.6f} "
    35:                           f"sl={d['sl']:.6f} tp1={d['tp1']:.6f} tp2={d['tp2']:.6f} "
    36:                           f"score={d['score']} q={d['quality']:.2f} :: {d.get('reasons','')}")
    37:             except Exception as e:
    38:                 print(f"[{symbol}/{tf}] ERREUR: {e}")
    39: 
    40:     def loop(self) -> None:
    41:         print(f"[Orchestrator] jobs={self.jobs} interval={self.interval}s")
    42:         while True:
    43:             t0 = time.time()
    44:             self._tick()
    45:             dt = time.time() - t0
    46:             time.sleep(max(0.0, self.interval - dt))

--------------------------------------------------------------------------------
FILE: scalper/live/orders.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # live/orders.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Any, Optional
     5: 
     6: from engine.services.order_service import OrderService, OrderRequest
     7: 
     8: @dataclass
     9: class OrderResult:
    10:     accepted: bool
    11:     order_id: str | None = None
    12:     status: str | None = None
    13:     reason: str | None = None
    14: 
    15: class OrderExecutor:
    16:     """
    17:     Fine couche autour d'OrderService + exchange :
    18:       - calcule l'équité USDT
    19:       - place une entrée (risk_pct)
    20:       - récupère les fills (normalisés)
    21:     L'orchestrateur n’appelle plus OrderService directement.
    22:     """
    23: 
    24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
    25:         self.order_service = order_service
    26:         self.exchange = exchange
    27:         self.config = config
    28: 
    29:     # ---------- Equity ----------
    30:     def get_equity_usdt(self) -> float:
    31:         equity = 0.0
    32:         try:
    33:             assets = self.exchange.get_assets()
    34:             if isinstance(assets, dict):
    35:                 for a in (assets.get("data") or []):
    36:                     if str(a.get("currency")).upper() == "USDT":
    37:                         equity = float(a.get("equity", 0.0))
    38:                         break
    39:         except Exception:
    40:             pass
    41:         return equity
    42: 
    43:     # ---------- Entrée ----------
    44:     def place_entry(self, *, symbol: str, side: str, price: float,
    45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
    46:         """
    47:         side: 'long' | 'short'
    48:         Retourne OrderResult(accepted, order_id, status, reason)
    49:         """
    50:         equity = self.get_equity_usdt()
    51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
    52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
    53:                            risk_pct=float(risk_pct))
    54:         try:
    55:             res = self.order_service.prepare_and_place(equity, req)
    56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
    57:                                order_id=getattr(res, "order_id", None),
    58:                                status=getattr(res, "status", None),
    59:                                reason=getattr(res, "reason", None))
    60:         except Exception as e:
    61:             return OrderResult(accepted=False, reason=str(e))
    62: 
    63:     # ---------- Fills ----------
    64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
    65:         """
    66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
    67:         """
    68:         try:
    69:             raw = self.exchange.get_fills(symbol, order_id, limit)
    70:         except Exception:
    71:             return []
    72: 
    73:         items: list = []
    74:         if isinstance(raw, dict):
    75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
    76:         elif isinstance(raw, (list, tuple)):
    77:             items = list(raw)
    78: 
    79:         out: list[dict] = []
    80:         for f in items:
    81:             if isinstance(f, dict):
    82:                 out.append({
    83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
    84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
    85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
    86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
    87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
    88:                 })
    89:             else:
    90:                 try:
    91:                     seq = list(f)
    92:                     out.append({
    93:                         "orderId": str(seq[0]) if seq else "",
    94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
    95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
    96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
    97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
    98:                     })
    99:                 except Exception:
   100:                     continue
   101:         return out

--------------------------------------------------------------------------------
FILE: scalper/live/position_fsm.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # live/position_fsm.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any, List
     5: 
     6: 
     7: STATE_FLAT = "FLAT"
     8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
     9: STATE_OPEN = "OPEN"
    10: STATE_PENDING_EXIT = "PENDING_EXIT"
    11: 
    12: 
    13: @dataclass
    14: class PositionState:
    15:     symbol: str
    16:     state: str = STATE_FLAT
    17:     order_id: Optional[str] = None
    18:     side: Optional[str] = None   # "long" | "short"
    19:     qty: float = 0.0
    20:     entry: float = 0.0
    21: 
    22: 
    23: class PositionFSM:
    24:     """
    25:     FSM ultra-simple par symbole.
    26:     - set_pending_entry(order_id, side)
    27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
    28:     """
    29: 
    30:     def __init__(self, symbols: List[str]) -> None:
    31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
    32: 
    33:     # -------- API utilisateur --------
    34:     def ensure_symbol(self, symbol: str) -> None:
    35:         if symbol not in self._by_symbol:
    36:             self._by_symbol[symbol] = PositionState(symbol)
    37: 
    38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
    39:         self.ensure_symbol(symbol)
    40:         st = self._by_symbol[symbol]
    41:         st.state = STATE_PENDING_ENTRY
    42:         st.order_id = order_id
    43:         st.side = side
    44: 
    45:     def mark_pending_exit(self, symbol: str) -> None:
    46:         self.ensure_symbol(symbol)
    47:         st = self._by_symbol[symbol]
    48:         st.state = STATE_PENDING_EXIT
    49: 
    50:     def force_flat(self, symbol: str) -> None:
    51:         self._by_symbol[symbol] = PositionState(symbol)
    52: 
    53:     # -------- Lecture --------
    54:     def get(self, symbol: str) -> PositionState:
    55:         self.ensure_symbol(symbol)
    56:         return self._by_symbol[symbol]
    57: 
    58:     def all(self) -> Dict[str, PositionState]:
    59:         return self._by_symbol
    60: 
    61:     # -------- Réconciliation --------
    62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
    63:         """
    64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
    65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
    66:         """
    67:         # indexer positions ouvertes
    68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
    69: 
    70:         for sym, st in self._by_symbol.items():
    71:             p = idx_open.get(sym)
    72: 
    73:             if st.state == STATE_PENDING_ENTRY:
    74:                 # si on voit des fills de l'ordre en attente -> OPEN
    75:                 f_list = fills.get(sym) or []
    76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
    77:                 if qty_filled > 0.0 or p:
    78:                     st.state = STATE_OPEN
    79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
    80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
    81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
    82:             elif st.state == STATE_OPEN:
    83:                 # si plus de position ouverte -> FLAT
    84:                 if not p:
    85:                     st.state = STATE_FLAT
    86:                     st.order_id = None
    87:                     st.side = None
    88:                     st.qty = 0.0
    89:                     st.entry = 0.0
    90:                 else:
    91:                     st.qty = float(p.get("qty", st.qty))
    92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
    93:             elif st.state == STATE_PENDING_EXIT:
    94:                 # si plus de position -> FLAT ; sinon reste OPEN
    95:                 if not p:
    96:                     st.state = STATE_FLAT
    97:                     st.order_id = None
    98:                     st.side = None
    99:                     st.qty = 0.0
   100:                     st.entry = 0.0
   101:                 else:
   102:                     st.state = STATE_OPEN  # pas encore clos
   103:             else:
   104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
   105:                 if p:
   106:                     st.state = STATE_OPEN
   107:                     st.qty = float(p.get("qty", 0.0))
   108:                     st.entry = float(p.get("avgEntryPrice", 0.0))

--------------------------------------------------------------------------------
FILE: scalper/live/runner.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # scalper/live/runner.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional
     4: from engine.signals.factory import resolve_signal_fn
     5: 
     6: class JobRunner:
     7:     def __init__(self, strategies_cfg: dict, equity: float, risk_pct: float) -> None:
     8:         self.cfg = strategies_cfg
     9:         self.equity = float(equity)
    10:         self.risk = float(risk_pct)
    11: 
    12:     def run_once(
    13:         self, *, symbol: str, timeframe: str,
    14:         ohlcv: Dict[str, List[float]],
    15:         ohlcv_1h: Optional[Dict[str, List[float]]] = None
    16:     ):
    17:         fn = resolve_signal_fn(symbol, timeframe, self.cfg)
    18:         return fn(
    19:             symbol=symbol, timeframe=timeframe, ohlcv=ohlcv,
    20:             equity=self.equity, risk_pct=self.risk, ohlcv_1h=ohlcv_1h
    21:         )

--------------------------------------------------------------------------------
FILE: scalper/live/setup_wizard.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import asyncio, os
     3: from dataclasses import dataclass
     4: from typing import List, Dict, Optional, Callable
     5: from ..signals.factory import load_signal
     6: from ..backtest.runner import BacktestRunner
     7: from .notify import Notifier, CommandStream
     8: 
     9: @dataclass
    10: class SetupResult:
    11:     strategy: str
    12:     symbols: List[str]
    13:     timeframes: List[str]
    14:     risk_pct: float
    15:     accepted: bool
    16:     summary_path: str
    17: 
    18: class SetupWizard:
    19:     """
    20:     Wizard interactif Telegram avant lancement des trades.
    21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
    22:     """
    23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
    24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
    25:                  admin_chat_id: Optional[int]=None):
    26:         self.notifier = notifier
    27:         self.cmd_stream = cmd_stream
    28:         self.loader = ohlcv_loader_sync
    29:         self.out_dir = out_dir
    30:         self.admin_chat_id = admin_chat_id
    31: 
    32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
    33:         await self.notifier.send_menu(prompt, choices)
    34:         async for msg in self.cmd_stream:
    35:             txt = msg.strip()
    36:             if allow_multi and ("," in txt or " " in txt):
    37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
    38:                 return sel
    39:             if txt.isdigit():
    40:                 i = int(txt)-1
    41:                 if 0 <= i < len(choices):
    42:                     return [choices[i]]
    43:             if txt in choices:
    44:                 return [txt]
    45:             await self.notifier.send("Entrée invalide. Réessaie.")
    46: 
    47:     async def _ask_value(self, prompt: str, cast: Callable, default):
    48:         await self.notifier.send(f"{prompt} (défaut: {default})")
    49:         async for msg in self.cmd_stream:
    50:             txt = msg.strip()
    51:             if txt == "" or txt.lower() in ("d","defaut","default"):
    52:                 return default
    53:             try:
    54:                 return cast(txt)
    55:             except Exception:
    56:                 await self.notifier.send("Entrée invalide. Réessaie.")
    57: 
    58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
    59:                   default_strategy: str="current") -> SetupResult:
    60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
    61:         # 1) stratégie
    62:         strategies = ["current","ema_cross","vwap_break"]
    63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
    64: 
    65:         # 2) symboles
    66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
    67: 
    68:         # 3) timeframes
    69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
    70: 
    71:         # 4) risk %
    72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
    73: 
    74:         # 5) période backtest
    75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
    76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
    77: 
    78:         # 6) run backtest
    79:         from ..backtest.cli import parse_ts
    80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
    81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
    82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
    83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
    84: 
    85:         # 7) résumé
    86:         sum_path = os.path.join(self.out_dir, "metrics.json")
    87:         prop = res["proposal"]
    88:         lines = ["**Proposition** :"]
    89:         for sym, best in prop["per_symbol_best"].items():
    90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
    91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
    92: 
    93:         # 8) décision
    94:         async for msg in self.cmd_stream:
    95:             t = msg.strip().lower()
    96:             if t in ("accepter","accept","ok","go","start"):
    97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
    98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
    99:             if t in ("modifier","again","repeat"):
   100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
   101:             if t in ("annuler","cancel","stop"):
   102:                 await self.notifier.send("❌ Annulé.")
   103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)

--------------------------------------------------------------------------------
FILE: scalper/live/state_store.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # live/state_store.py
     2: from __future__ import annotations
     3: import json, os, time, asyncio
     4: from typing import Callable, Dict, Any
     5: 
     6: class StateStore:
     7:     """
     8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
     9:     - save_state(snapshot: dict) -> écrit sur disque
    10:     - load_state() -> dict
    11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
    12:     """
    13: 
    14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
    15:         self.filepath = filepath
    16:         self.period_s = period_s
    17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
    18:         self._running = False
    19: 
    20:     # -------- I/O --------
    21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
    22:         tmp = self.filepath + ".tmp"
    23:         with open(tmp, "w", encoding="utf-8") as f:
    24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
    25:         os.replace(tmp, self.filepath)
    26: 
    27:     def load_state(self) -> Dict[str, Any]:
    28:         if not os.path.exists(self.filepath):
    29:             return {}
    30:         try:
    31:             with open(self.filepath, "r", encoding="utf-8") as f:
    32:                 return json.load(f)
    33:         except Exception:
    34:             return {}
    35: 
    36:     # -------- Autosave --------
    37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
    38:         self._running = True
    39:         while self._running:
    40:             try:
    41:                 snap = get_snapshot()
    42:                 snap["saved_at"] = int(time.time() * 1000)
    43:                 self.save_state(snap)
    44:             except Exception:
    45:                 pass
    46:             await asyncio.sleep(self.period_s)
    47: 
    48:     def stop(self): self._running = False

--------------------------------------------------------------------------------
FILE: scalper/live/telegram_async.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import time
     3: import requests
     4: import asyncio
     5: from typing import Optional, Dict, Any, List
     6: 
     7: 
     8: class TelegramAsync:
     9:     """
    10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
    11:     Sans nouvelle dépendance.
    12:     """
    13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
    14:         self.token = token
    15:         self.chat_id = chat_id
    16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
    17:         self._offset = 0
    18:         self._enabled = bool(token and chat_id)
    19: 
    20:     def enabled(self) -> bool:
    21:         return self._enabled
    22: 
    23:     # ---------- sync I/O (appelées via to_thread) ----------
    24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
    25:         if not self._enabled:
    26:             return {"ok": False, "reason": "disabled"}
    27:         url = f"{self.base}/sendMessage"
    28:         payload = {"chat_id": self.chat_id, "text": text}
    29:         try:
    30:             r = requests.post(url, json=payload, timeout=10)
    31:             return r.json()
    32:         except Exception as e:
    33:             return {"ok": False, "error": repr(e)}
    34: 
    35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
    36:         if not self._enabled:
    37:             return {"ok": True, "result": []}
    38:         url = f"{self.base}/getUpdates"
    39:         params = {"timeout": timeout_s, "offset": self._offset}
    40:         try:
    41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
    42:             return r.json()
    43:         except Exception as e:
    44:             return {"ok": False, "error": repr(e), "result": []}
    45: 
    46:     # ---------- async wrappers ----------
    47:     async def send_message(self, text: str) -> None:
    48:         await asyncio.to_thread(self._send_message_sync, text)
    49: 
    50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
    51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
    52:         if not data.get("ok"):
    53:             return []
    54:         out = []
    55:         for upd in data.get("result", []):
    56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
    57:             msg = upd.get("message") or {}
    58:             text = (msg.get("text") or "").strip()
    59:             if not text:
    60:                 continue
    61:             out.append({
    62:                 "date": msg.get("date"),
    63:                 "chat": str((msg.get("chat") or {}).get("id")),
    64:                 "text": text,
    65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
    66:             })
    67:         return out

--------------------------------------------------------------------------------
FILE: scalper/live/watchlist.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import List
     5: 
     6: 
     7: @dataclass
     8: class WatchlistManager:
     9:     symbols: List[str]
    10: 
    11:     @classmethod
    12:     def from_env_or_default(cls) -> "WatchlistManager":
    13:         # Tu peux lire une variable d'env ici si tu veux surcharger
    14:         default = [
    15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
    16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
    17:         ]
    18:         return cls(default)

--------------------------------------------------------------------------------
FILE: sitecustomize.py  (last modified: 2025-08-24 18:01:27)
--------------------------------------------------------------------------------
     1: # sitecustomize.py
     2: # Chargé automatiquement par Python s'il est sur le PYTHONPATH (racine du repo).
     3: # - charge /notebooks/.env
     4: # - AUTO-INSTALL des dépendances manquantes (core + dash + ccxt)
     5: # - affiche un récap clair à la console (ok/installed/failed)
     6: # - prépare DATA_ROOT (data/logs/reports)
     7: # - écrit un green-flag JSON avec l'état des checks
     8: 
     9: from __future__ import annotations
    10: import json
    11: import os
    12: from pathlib import Path
    13: 
    14: READY_PATH = Path("/notebooks/.scalp/READY.json")
    15: 
    16: 
    17: def _load_dotenv_parent() -> None:
    18:     try:
    19:         from dotenv import load_dotenv  # type: ignore
    20:         load_dotenv("/notebooks/.env")
    21:         print("[i] .env chargé depuis /notebooks/.env")
    22:     except Exception:
    23:         print("[-] Impossible de charger /notebooks/.env (dotenv indisponible ?)")
    24: 
    25: 
    26: def _auto_install_verbose() -> dict:
    27:     """
    28:     Installation auto, toujours activée (idempotente).
    29:     Tu peux limiter via variables d'env si besoin:
    30:       DISABLE_DASH=1  -> n'installe pas streamlit
    31:       DISABLE_CCXT=1  -> n'installe pas ccxt
    32:     """
    33:     try:
    34:         from engine.utils.bootstrap import ensure_dependencies  # type: ignore
    35:     except Exception as e:
    36:         print(f"[!] Bootstrap manquant: {e}")
    37:         return {"bootstrap": "missing"}
    38: 
    39:     with_dash = os.getenv("DISABLE_DASH", "").lower() not in {"1", "true", "yes"}
    40:     with_ccxt = os.getenv("DISABLE_CCXT", "").lower() not in {"1", "true", "yes"}
    41: 
    42:     print("[*] Vérification des dépendances (auto-install si nécessaire)...")
    43:     deps = ensure_dependencies(with_dash=with_dash, with_ccxt=with_ccxt)
    44: 
    45:     # Affichage lisible
    46:     ok, inst, fail = [], [], []
    47:     for spec, status in deps.items():
    48:         if status == "ok":
    49:             ok.append(spec)
    50:         elif status == "installed":
    51:             inst.append(spec)
    52:         else:
    53:             fail.append((spec, status))
    54: 
    55:     if ok:
    56:         print("    [OK]     " + ", ".join(ok))
    57:     if inst:
    58:         print("    [INST]   " + ", ".join(inst))
    59:     if fail:
    60:         print("    [FAILED] " + ", ".join(f"{s} -> {st}" for s, st in fail))
    61: 
    62:     return deps
    63: 
    64: 
    65: def _paths_from_env() -> dict:
    66:     data_root = os.getenv("DATA_ROOT", "/notebooks/scalp_data")
    67:     d = Path(data_root)
    68:     for sub in ("data", "logs", "reports"):
    69:         try:
    70:             (d / sub).mkdir(parents=True, exist_ok=True)
    71:         except Exception as e:
    72:             print(f"[!] Impossible de créer {d/sub}: {e}")
    73:     print(f"[i] DATA_ROOT: {d}")
    74:     return {
    75:         "DATA_ROOT": str(d),
    76:         "data_dir": str(d / "data"),
    77:         "log_dir": str(d / "logs"),
    78:         "reports_dir": str(d / "reports"),
    79:     }
    80: 
    81: 
    82: def _write_ready(payload: dict) -> None:
    83:     try:
    84:         READY_PATH.parent.mkdir(parents=True, exist_ok=True)
    85:         READY_PATH.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    86:         print(f"[✓] Préflight OK — green-flag écrit: {READY_PATH}")
    87:     except Exception as e:
    88:         print(f"[!] Impossible d'écrire {READY_PATH}: {e}")
    89: 
    90: 
    91: def _apply_env_aliases() -> None:
    92:     try:
    93:         from engine.config.loader import apply_env_aliases  # type: ignore
    94:         apply_env_aliases()
    95:     except Exception:
    96:         pass
    97: 
    98: 
    99: try:
   100:     _load_dotenv_parent()
   101:     _apply_env_aliases()
   102:     deps = _auto_install_verbose()
   103:     paths = _paths_from_env()
   104: 
   105:     # mini check secrets (non bloquant)
   106:     miss = []
   107:     if not (os.getenv("BITGET_ACCESS_KEY") and os.getenv("BITGET_SECRET_KEY") and os.getenv("BITGET_PASSPHRASE")):
   108:         miss.append("BITGET_*")
   109:     if not (os.getenv("TELEGRAM_BOT_TOKEN") and os.getenv("TELEGRAM_CHAT_ID")):
   110:         miss.append("TELEGRAM_*")
   111:     if miss:
   112:         print("[-] Secrets manquants:", ", ".join(miss))
   113: 
   114:     _write_ready({"status": "ok", "deps": deps, "paths": paths, "missing": miss})
   115: except Exception as e:
   116:     print(f"[!] Préflight partiel: {e}")
   117:     _write_ready({"status": "partial", "error": str(e)})

--------------------------------------------------------------------------------
FILE: tg_diag.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # tg_diag.py
     2: import asyncio, os, aiohttp
     3: 
     4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
     5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
     6: 
     7: async def main():
     8:     if not TOKEN or not CHAT:
     9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
    10:         return
    11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
    13:     try:
    14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
    15:             async with s.post(url, json=payload) as r:
    16:                 body = await r.text()
    17:                 print("HTTP:", r.status)
    18:                 print("Body:", body[:500])
    19:     except Exception as e:
    20:         print("❌ Exception:", repr(e))
    21: 
    22: if __name__ == "__main__":
    23:     asyncio.run(main())

--------------------------------------------------------------------------------
FILE: tools/dump-repo.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: import datetime as dt, sys
     4: from pathlib import Path
     5: 
     6: REPO_ROOT = Path(__file__).resolve().parents[1]
     7: DUMP_DIR = REPO_ROOT / "dumps"; DUMP_DIR.mkdir(parents=True, exist_ok=True)
     8: TS = dt.datetime.now().strftime("%Y%m%d-%H%M%S")
     9: OUT_PATH = DUMP_DIR / f"DUMP_{TS}.txt"
    10: 
    11: IGNORE_EXT = {".png",".jpg",".jpeg",".gif",".pdf",".pkl",".db",".sqlite",".zip",".tar",".gz",".pyc",".pyo"}
    12: IGNORE_DIRS = {".git","__pycache__", ".ipynb_checkpoints", "dumps"}
    13: IGNORE_PREFIX = {"TRASH_"}
    14: 
    15: def is_text_file(p: Path) -> bool:
    16:     if p.suffix.lower() in IGNORE_EXT: return False
    17:     try:
    18:         with p.open("rb") as f:
    19:             if b"\x00" in f.read(1024): return False
    20:         return True
    21:     except Exception: return False
    22: 
    23: def write_header(f, t): f.write("\n"+"="*80+"\n"+t+"\n"+"="*80+"\n")
    24: 
    25: def dump_tree(root: Path, f):
    26:     write_header(f,"ARBORESCENCE")
    27:     for p in sorted(root.rglob("*")):
    28:         rel=p.relative_to(root)
    29:         if any(part in IGNORE_DIRS for part in rel.parts): continue
    30:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX): continue
    31:         if p.is_file():
    32:             m=dt.datetime.fromtimestamp(p.stat().st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    33:             f.write(f"{rel}  (last modified: {m})\n")
    34:         else:
    35:             f.write(str(rel)+"/\n")
    36: 
    37: def dump_files(root: Path, f):
    38:     write_header(f,"FICHIERS COMPLETS")
    39:     for p in sorted(root.rglob("*")):
    40:         rel=p.relative_to(root)
    41:         if p.is_dir(): continue
    42:         if any(part in IGNORE_DIRS for part in rel.parts): continue
    43:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX): continue
    44:         if not is_text_file(p): continue
    45:         try: lines=p.read_text(encoding="utf-8",errors="replace").splitlines()
    46:         except Exception as e:
    47:             f.write(f"\n[!!] Impossible de lire {rel}: {e}\n"); continue
    48:         m=dt.datetime.fromtimestamp(p.stat().st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    49:         f.write("\n"+"-"*80+"\n"); f.write(f"FILE: {rel}  (last modified: {m})\n"); f.write("-"*80+"\n")
    50:         for i, line in enumerate(lines, 1): f.write(f"{i:6d}: {line}\n")
    51: 
    52: def prune_old_dumps():
    53:     for old in sorted(DUMP_DIR.glob("DUMP_*.txt")):
    54:         if old != OUT_PATH:
    55:             try: old.unlink(); print(f"[x] Ancien dump supprimé: {old.name}")
    56:             except Exception as e: print(f"[!] Suppression échouée {old}: {e}")
    57: 
    58: def main() -> int:
    59:     with OUT_PATH.open("w", encoding="utf-8") as f:
    60:         f.write(f"# DUMP {TS}\nRepo: {REPO_ROOT}\n")
    61:         dump_tree(REPO_ROOT, f); dump_files(REPO_ROOT, f)
    62:     prune_old_dumps(); print(f"[✓] Dump écrit: {OUT_PATH}"); return 0
    63: 
    64: if __name__ == "__main__": sys.exit(main())

--------------------------------------------------------------------------------
FILE: tools/migrate-to-engine.py  (last modified: 2025-08-24 16:58:01)
--------------------------------------------------------------------------------
     1: # ops/migrate_to_engine.py
     2: from __future__ import annotations
     3: import re, shutil
     4: from pathlib import Path
     5: 
     6: ROOT = Path(__file__).resolve().parents[1]
     7: ENGINE = ROOT / "engine"
     8: ENGINE.mkdir(exist_ok=True)
     9: 
    10: # 1) Déplacer anciens packages s'ils existent
    11: CANDIDATE_PKGS = ["scalper", "scalp"]  # anciens noms possibles de package interne
    12: for name in CANDIDATE_PKGS:
    13:     src = ROOT / name
    14:     if src.exists() and src.is_dir():
    15:         dst = ENGINE
    16:         # on déplace le contenu interne dans engine/
    17:         for p in src.iterdir():
    18:             dest = dst / p.name
    19:             if dest.exists():
    20:                 continue
    21:             shutil.move(str(p), str(dest))
    22:         # on laisse le répertoire racine (vide) à supprimer manuellement si besoin
    23: 
    24: # 2) Mettre à jour les imports dans tout le repo (hors TRASH et .git)
    25: PATTERNS = [
    26:     (re.compile(r"\bscalper\."), "engine."),
    27:     (re.compile(r"\bscalp\."), "engine."),   # ancien package interne homonyme du repo
    28: ]
    29: def fix_file(path: Path) -> None:
    30:     try:
    31:         txt = path.read_text(encoding="utf-8")
    32:     except Exception:
    33:         return
    34:     orig = txt
    35:     for rx, repl in PATTERNS:
    36:         txt = rx.sub(repl, txt)
    37:     if txt != orig:
    38:         path.write_text(txt, encoding="utf-8")
    39: 
    40: for p in ROOT.rglob("*.py"):
    41:     rel = p.relative_to(ROOT)
    42:     if any(part.startswith("TRASH_") for part in rel.parts):
    43:         continue
    44:     if rel.parts and rel.parts[0] in (".git",):
    45:         continue
    46:     fix_file(p)
    47: 
    48: print("[✓] Migration terminée. Vérifie les imports et supprime l’ancien dossier vide si présent.")

--------------------------------------------------------------------------------
FILE: tools/trashify.py  (last modified: 2025-08-24 19:22:16)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # tools/trashify.py
     3: """
     4: Ménage du dépôt : déplace les éléments legacy/ inutiles vers .trash/<TIMESTAMP>/
     5: - DRY RUN par défaut (aucune action tant que --apply n'est pas passé)
     6: - Liste adaptée au dump le plus récent
     7: - Prend soin de garder le dernier dump dans dumps/
     8: - Sécurisé : ne touche jamais .git/ ni .trash/
     9: 
    10: Usage :
    11:   python tools/trashify.py                 # aperçu (DRY RUN)
    12:   python tools/trashify.py --apply         # exécute les déplacements
    13:   python tools/trashify.py --restore PATH  # restaure depuis .trash/
    14:   python tools/trashify.py --aggressive    # inclut fichiers/dev en plus (toujours DRY tant que --apply pas présent)
    15: """
    16: 
    17: from __future__ import annotations
    18: import argparse
    19: import os
    20: import shutil
    21: import time
    22: from pathlib import Path
    23: from typing import Iterable, List
    24: 
    25: REPO_ROOT = Path(__file__).resolve().parents[1]
    26: 
    27: 
    28: # --- Cibles principales (safe) ------------------------------------------------
    29: TRASH_DIRS_SAFE = [
    30:     "scalper",                 # ancien moteur non utilisé par bot.py
    31:     "tests",                   # dossiers de tests obsolètes
    32:     "data",                    # les données doivent être hors dépôt
    33: ]
    34: 
    35: TRASH_GLOBS_COMMON = [
    36:     "**/__pycache__",          # caches py
    37:     "**/.ipynb_checkpoints",   # artefacts jupyter
    38: ]
    39: 
    40: TRASH_FILES_SAFE = [
    41:     "engine/core/signal.py",   # doublon vs signals.py
    42:     "dump.txt",                # vieux dump
    43:     "requirements-dash.txt",   # on garde un seul requirements.txt
    44:     "requirements-dev.txt",
    45: ]
    46: 
    47: # --- Cibles 'agressives' optionnelles ----------------------------------------
    48: TRASH_FILES_AGGRESSIVE = [
    49:     "pytest.ini",
    50:     ".pytest_cache",
    51: ]
    52: 
    53: 
    54: # --- Helpers ------------------------------------------------------------------
    55: def _existing(paths: Iterable[Path]) -> List[Path]:
    56:     out: List[Path] = []
    57:     for p in paths:
    58:         try:
    59:             if p.exists():
    60:                 out.append(p)
    61:         except OSError:
    62:             pass
    63:     return out
    64: 
    65: def _is_protected(p: Path) -> bool:
    66:     rp = p.resolve()
    67:     # ne jamais toucher au repo root lui‑même, ni .git, ni .trash
    68:     for forbid in [REPO_ROOT, REPO_ROOT / ".git", REPO_ROOT / ".trash"]:
    69:         try:
    70:             if rp == forbid.resolve() or str(rp).startswith(str(forbid.resolve())):
    71:                 return True
    72:         except Exception:
    73:             continue
    74:     return False
    75: 
    76: def _collect_basic_targets(aggressive: bool) -> List[Path]:
    77:     items: List[Path] = []
    78: 
    79:     # dossiers exacts
    80:     items += _existing([REPO_ROOT / d for d in TRASH_DIRS_SAFE])
    81: 
    82:     # fichiers exacts
    83:     base_files = TRASH_FILES_SAFE + (TRASH_FILES_AGGRESSIVE if aggressive else [])
    84:     items += _existing([REPO_ROOT / f for f in base_files])
    85: 
    86:     # globs
    87:     for pat in TRASH_GLOBS_COMMON:
    88:         for p in REPO_ROOT.glob(pat):
    89:             items.append(p)
    90: 
    91:     # filtre de sécurité
    92:     safe = [p for p in items if not _is_protected(p)]
    93:     # dédupliquer et trier (dossiers parents avant enfants)
    94:     safe_sorted = sorted(set(safe), key=lambda x: (str(x).count(os.sep), str(x)))
    95:     return safe_sorted
    96: 
    97: def _collect_old_dumps() -> List[Path]:
    98:     """Dans dumps/, garder le fichier le plus récent et déplacer les autres."""
    99:     d = REPO_ROOT / "dumps"
   100:     if not d.exists() or not d.is_dir():
   101:         return []
   102:     files = sorted([p for p in d.glob("DUMP_*.txt") if p.is_file()],
   103:                    key=lambda p: p.stat().st_mtime, reverse=True)
   104:     if len(files) <= 1:
   105:         return []
   106:     # on garde files[0] (le plus récent), on déplace le reste
   107:     return files[1:]
   108: 
   109: def _move_to_trash(paths: List[Path], apply: bool, label: str = "") -> None:
   110:     if not paths:
   111:         return
   112:     dest_root = REPO_ROOT / ".trash" / time.strftime("%Y%m%d-%H%M%S")
   113:     print(f"Destination: {dest_root} {label}".rstrip())
   114:     for p in paths:
   115:         rel = p.relative_to(REPO_ROOT)
   116:         dest = dest_root / rel
   117:         print(f"- {rel}  ->  .trash/{dest.relative_to(REPO_ROOT / '.trash')}")
   118:         if apply:
   119:             dest.parent.mkdir(parents=True, exist_ok=True)
   120:             try:
   121:                 shutil.move(str(p), str(dest))
   122:             except Exception as e:
   123:                 print(f"  [!] move failed: {e}")
   124: 
   125: def _restore_from_trash(src: Path) -> None:
   126:     src = src.resolve()
   127:     if (REPO_ROOT / ".trash") not in src.parents:
   128:         raise SystemExit("Le chemin à restaurer doit provenir de .trash/")
   129:     rel = src.relative_to(REPO_ROOT / ".trash")
   130:     dest = REPO_ROOT / rel
   131:     print(f"RESTORE  .trash/{rel} -> {rel}")
   132:     dest.parent.mkdir(parents=True, exist_ok=True)
   133:     shutil.move(str(src), str(dest))
   134: 
   135: 
   136: # --- Main ---------------------------------------------------------------------
   137: def main(argv: Iterable[str] | None = None) -> int:
   138:     ap = argparse.ArgumentParser()
   139:     ap.add_argument("--apply", action="store_true", help="Exécuter réellement (sinon DRY RUN).")
   140:     ap.add_argument("--restore", type=str, default="", help="Chemin à restaurer depuis .trash/")
   141:     ap.add_argument("--aggressive", action="store_true", help="Inclut aussi fichiers/dev optionnels (pytest.ini, etc.).")
   142:     args = ap.parse_args(list(argv) if argv is not None else None)
   143: 
   144:     if args.restore:
   145:         _restore_from_trash(Path(args.restore))
   146:         return 0
   147: 
   148:     print(f"[trashify] Repo : {REPO_ROOT}")
   149:     basic = _collect_basic_targets(args.aggressive)
   150:     print(f"[trashify] Cibles de base détectées : {len(basic)}")
   151:     _move_to_trash(basic, apply=args.apply)
   152: 
   153:     # dumps obsolètes (garde le plus récent)
   154:     old_dumps = _collect_old_dumps()
   155:     if old_dumps:
   156:         print(f"[trashify] Dumps obsolètes : {len(old_dumps)} (le plus récent est conservé)")
   157:         _move_to_trash(old_dumps, apply=args.apply, label="(dumps)")
   158: 
   159:     if not args.apply:
   160:         print("\nDRY RUN — ajoute --apply pour déplacer réellement.")
   161:     else:
   162:         print("\n[✓] Déplacement terminé. Vérifie .trash/, puis commit/push si ok.")
   163:     return 0
   164: 
   165: 
   166: if __name__ == "__main__":
   167:     raise SystemExit(main())
