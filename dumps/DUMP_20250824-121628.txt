# DUMP 20250824-121628
Repo: /notebooks/scalp

================================================================================
ARBORESCENCE
================================================================================
.gitignore  (last modified: 2025-08-24 12:14:38)
CHANGELOG.md  (last modified: 2025-08-24 12:14:38)
Makefile  (last modified: 2025-08-24 12:14:38)
PROMPT.md  (last modified: 2025-08-24 12:14:38)
README.md  (last modified: 2025-08-24 12:14:38)
STRATEGY.md  (last modified: 2025-08-24 12:14:38)
bot.py  (last modified: 2025-08-24 12:14:38)
cli.py  (last modified: 2025-08-24 12:16:03)
data/
data/BTCUSDT-1m.csv  (last modified: 2025-08-24 12:14:38)
data/__init__.py  (last modified: 2025-08-24 12:14:38)
dump.txt  (last modified: 2025-08-24 12:14:38)
dumps/
dumps/DUMP_20250824-112618.txt  (last modified: 2025-08-24 12:14:38)
dumps/DUMP_20250824-121628.txt  (last modified: 2025-08-24 12:16:28)
engine/
engine/VERSION  (last modified: 2025-08-24 12:14:38)
engine/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/adapters/
engine/adapters/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/adapters/bitget.py  (last modified: 2025-08-24 12:16:03)
engine/adapters/bitget_fetch.py  (last modified: 2025-08-24 12:14:38)
engine/adapters/market_data.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/
engine/backtest/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/cache.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/cli.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/engine.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/grid_search.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/loader_csv.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/market_data.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/metrics.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/optimize.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/position_sizing.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/run_multi.py  (last modified: 2025-08-24 12:14:38)
engine/backtest/runner.py  (last modified: 2025-08-24 12:16:03)
engine/backtest/walkforward.py  (last modified: 2025-08-24 12:14:38)
engine/bitget_client.py  (last modified: 2025-08-24 12:14:38)
engine/client.py  (last modified: 2025-08-24 12:14:38)
engine/config/
engine/config/loader.py  (last modified: 2025-08-24 12:14:38)
engine/core/
engine/core/indicators.py  (last modified: 2025-08-24 12:14:38)
engine/core/signal.py  (last modified: 2025-08-24 12:14:38)
engine/exchange/
engine/exchange/bitget_rest.py  (last modified: 2025-08-24 12:14:38)
engine/hooks/
engine/hooks/prewarm_cache.py  (last modified: 2025-08-24 12:14:38)
engine/live/
engine/live/notify.py  (last modified: 2025-08-24 12:14:38)
engine/live/orchestrator.py  (last modified: 2025-08-24 12:14:38)
engine/logging_utils.py  (last modified: 2025-08-24 12:14:38)
engine/metrics.py  (last modified: 2025-08-24 12:14:38)
engine/pairs.py  (last modified: 2025-08-24 12:16:03)
engine/positions/
engine/positions/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/positions/state.py  (last modified: 2025-08-24 12:14:38)
engine/risk/
engine/risk/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/risk/manager.py  (last modified: 2025-08-24 12:14:38)
engine/selection/
engine/selection/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/selection/momentum.py  (last modified: 2025-08-24 12:14:38)
engine/selection/scanner.py  (last modified: 2025-08-24 12:14:38)
engine/selfcheck.py  (last modified: 2025-08-24 12:16:03)
engine/services/
engine/services/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/services/data_cache.py  (last modified: 2025-08-24 12:14:38)
engine/services/order_service.py  (last modified: 2025-08-24 12:16:03)
engine/services/utils.py  (last modified: 2025-08-24 12:14:38)
engine/signals/
engine/signals/__init__.py  (last modified: 2025-08-24 12:14:38)
engine/signals/current.py  (last modified: 2025-08-24 12:16:03)
engine/signals/factory.py  (last modified: 2025-08-24 12:16:03)
engine/signals/generator.py  (last modified: 2025-08-24 12:14:38)
engine/strategy/
engine/strategy/factory.py  (last modified: 2025-08-24 12:14:38)
engine/strategy.py  (last modified: 2025-08-24 12:16:03)
engine/trade_utils.py  (last modified: 2025-08-24 12:14:38)
engine/version.py  (last modified: 2025-08-24 12:14:38)
engine/ws.py  (last modified: 2025-08-24 12:14:38)
init.py  (last modified: 2025-08-24 12:14:38)
pytest.ini  (last modified: 2025-08-24 12:14:38)
requirements-dev.txt  (last modified: 2025-08-24 12:14:38)
requirements.txt  (last modified: 2025-08-24 12:14:38)
resultat.log  (last modified: 2025-08-24 12:14:38)
scalper/
scalper/config/
scalper/config/__init__.py  (last modified: 2025-08-24 12:14:38)
scalper/config/loader.py  (last modified: 2025-08-24 12:14:38)
scalper/config/strategies.yml  (last modified: 2025-08-24 12:14:38)
scalper/exchange/
scalper/exchange/__init__.py  (last modified: 2025-08-24 12:14:38)
scalper/exchange/bitget.py  (last modified: 2025-08-24 12:14:38)
scalper/exchange/bitget_ccxt.py  (last modified: 2025-08-24 12:14:38)
scalper/exchange/fees.py  (last modified: 2025-08-24 12:14:38)
scalper/live/
scalper/live/__init__.py  (last modified: 2025-08-24 12:14:38)
scalper/live/backtest_telegram.py  (last modified: 2025-08-24 12:16:03)
scalper/live/commands.py  (last modified: 2025-08-24 12:14:38)
scalper/live/data_utils.py  (last modified: 2025-08-24 12:14:38)
scalper/live/fetcher.py  (last modified: 2025-08-24 12:14:38)
scalper/live/journal.py  (last modified: 2025-08-24 12:14:38)
scalper/live/logs.py  (last modified: 2025-08-24 12:14:38)
scalper/live/loops/
scalper/live/loops/trade.py  (last modified: 2025-08-24 12:14:38)
scalper/live/notify.py  (last modified: 2025-08-24 12:14:38)
scalper/live/ohlcv_service.py  (last modified: 2025-08-24 12:16:03)
scalper/live/orchestrator.py  (last modified: 2025-08-24 12:16:03)
scalper/live/orders.py  (last modified: 2025-08-24 12:16:03)
scalper/live/position_fsm.py  (last modified: 2025-08-24 12:14:38)
scalper/live/runner.py  (last modified: 2025-08-24 12:16:03)
scalper/live/setup_wizard.py  (last modified: 2025-08-24 12:14:38)
scalper/live/state_store.py  (last modified: 2025-08-24 12:14:38)
scalper/live/telegram_async.py  (last modified: 2025-08-24 12:14:38)
scalper/live/watchlist.py  (last modified: 2025-08-24 12:14:38)
sitecustomize.py  (last modified: 2025-08-24 12:16:03)
tests/
tests/conftest.py  (last modified: 2025-08-24 12:14:38)
tests/test_analyse_risque.py  (last modified: 2025-08-24 12:14:38)
tests/test_backtest.py  (last modified: 2025-08-24 12:14:38)
tests/test_backtest_multi.py  (last modified: 2025-08-24 12:16:03)
tests/test_backtest_position.py  (last modified: 2025-08-24 12:16:03)
tests/test_bitget_futures_pairs.py  (last modified: 2025-08-24 12:14:38)
tests/test_bot_place_order_caps.py  (last modified: 2025-08-24 12:14:38)
tests/test_bot_update.py  (last modified: 2025-08-24 12:14:38)
tests/test_break_even_stop.py  (last modified: 2025-08-24 12:16:03)
tests/test_calc_pnl_pct.py  (last modified: 2025-08-24 12:16:03)
tests/test_check_config.py  (last modified: 2025-08-24 12:14:38)
tests/test_cli.py  (last modified: 2025-08-24 12:14:38)
tests/test_client.py  (last modified: 2025-08-24 12:16:03)
tests/test_compute_position_size.py  (last modified: 2025-08-24 12:14:38)
tests/test_compute_position_size_cap.py  (last modified: 2025-08-24 12:14:38)
tests/test_dynamic_allocation.py  (last modified: 2025-08-24 12:16:03)
tests/test_effective_leverage.py  (last modified: 2025-08-24 12:16:03)
tests/test_env_loading.py  (last modified: 2025-08-24 12:14:38)
tests/test_grid_search.py  (last modified: 2025-08-24 12:16:03)
tests/test_heat_score.py  (last modified: 2025-08-24 12:16:03)
tests/test_indicators.py  (last modified: 2025-08-24 12:16:03)
tests/test_min_qty_rules.py  (last modified: 2025-08-24 12:14:38)
tests/test_notifier.py  (last modified: 2025-08-24 12:16:03)
tests/test_notional_and_pnl_units.py  (last modified: 2025-08-24 12:16:03)
tests/test_pair_selection.py  (last modified: 2025-08-24 12:14:38)
tests/test_pairs.py  (last modified: 2025-08-24 12:14:38)
tests/test_risk_manager.py  (last modified: 2025-08-24 12:14:38)
tests/test_risk_utils.py  (last modified: 2025-08-24 12:16:03)
tests/test_signal_risk.py  (last modified: 2025-08-24 12:14:38)
tests/test_slippage.py  (last modified: 2025-08-24 12:16:03)
tests/test_strategy_v2.py  (last modified: 2025-08-24 12:16:03)
tests/test_telegram_bot.py  (last modified: 2025-08-24 12:16:03)
tests/test_utils.py  (last modified: 2025-08-24 12:16:03)
tests/test_version.py  (last modified: 2025-08-24 12:14:38)
tests/test_walk_forward.py  (last modified: 2025-08-24 12:16:03)
tests/test_ws.py  (last modified: 2025-08-24 12:16:03)
tg_diag.py  (last modified: 2025-08-24 12:14:38)
tools/
tools/dump-repo.py  (last modified: 2025-08-24 12:14:38)
tools/migrate-to-engine.py  (last modified: 2025-08-24 12:14:38)
tools/trashify.py  (last modified: 2025-08-24 12:14:38)

================================================================================
FICHIERS COMPLETS
================================================================================

--------------------------------------------------------------------------------
FILE: .gitignore  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: __pycache__/
     2: *.pyc
     3: .pytest_cache/
     4: logs/

--------------------------------------------------------------------------------
FILE: CHANGELOG.md  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Changelog
     2: 
     3: ## Unreleased
     4: 
     5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
     6:   signal levels.
     7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
     8:   user risk level.
     9: - Notional and margin caps with available balance check to avoid Bitget error
    10:   `40762`.
    11: - Risk notifications with green/yellow/red indicators for terminal and
    12:   Telegram.

--------------------------------------------------------------------------------
FILE: Makefile  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: .PHONY: test
     2: 
     3: test:
     4: 	pytest

--------------------------------------------------------------------------------
FILE: PROMPT.md  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Prompt de re-création du bot Scalp (version spot)
     2: 
     3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
     4: 
     5: ## Structure principale
     6: 
     7: ### bot.py
     8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
     9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
    10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
    11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
    12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
    13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
    14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
    15: 
    16: ### cli.py
    17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
    18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
    19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
    20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
    21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
    22: 
    23: ### init.py
    24: - `install_packages(*args)` : installe des paquets via `pip`.
    25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
    26: 
    27: ## Modules `scalp`
    28: 
    29: ### bot_config.py
    30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
    31: 
    32: ### metrics.py
    33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
    34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
    35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
    36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
    37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
    38: 
    39: ### strategy.py
    40: - `ema(series, window)` : moyenne mobile exponentielle.
    41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
    42: - `obv(closes, volumes)` : série On Balance Volume.
    43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
    44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
    45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
    46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
    47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
    48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
    49: 
    50: ### trade_utils.py
    51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
    52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
    53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
    54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
    55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
    56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
    57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
    58: 
    59: ### risk
    60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
    61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
    62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
    63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
    64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
    65: 
    66: ### notifier.py
    67: - `_pair_name(symbol)` : formatte le nom d’une paire.
    68: - `_format_text(event, payload=None)` : construit un message lisible.
    69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
    70: 
    71: ### logging_utils.py
    72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
    73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
    74: 
    75: ### bitget_client.py
    76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
    77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
    78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
    79:   - `get_account()`, `get_open_orders(symbol=None)`.
    80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
    81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
    82: 
    83: ### pairs.py
    84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
    85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
    86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
    87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
    88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
    89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
    90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
    91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
    92: 
    93: ### telegram_bot.py
    94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
    95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
    96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
    97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
    98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
    99: 
   100: ## Utilisation
   101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   102: 2. Exécuter `init.py` pour installer les dépendances.
   103: 3. Lancer `bot.py` pour démarrer le trading.
   104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   105: 
   106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   107: 

--------------------------------------------------------------------------------
FILE: README.md  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Scalp
     2: 
     3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
     4: 
     5: ## Installation
     6: 
     7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
     8: 
     9: ```bash
    10: pip install -r requirements.txt
    11: ```
    12: 
    13: Pour développer ou exécuter les tests :
    14: 
    15: ```bash
    16: pip install -r requirements-dev.txt
    17: pytest  # ou make test
    18: ```
    19: 
    20: ## Configuration
    21: 
    22: Le bot lit sa configuration via des variables d'environnement :
    23: 
    24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
    25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
    26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
    27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
    28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
    29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
    30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
    31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
    32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
    33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
    34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
    35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
    36: 
    37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
    38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
    39: 
    40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
    41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
    42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
    43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
    44: bot.
    45: 
    46: 
    47: Exemple :
    48: 
    49: ```bash
    50: export BITGET_ACCESS_KEY="votre_cle"
    51: export BITGET_SECRET_KEY="votre_secret"
    52: export PAPER_TRADE=true
    53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
    54: export TELEGRAM_CHAT_ID="123456789"
    55: python bot.py
    56: ```
    57: 
    58: ## Lancement
    59: 
    60: Après configuration, lancez simplement :
    61: 
    62: ```bash
    63: python bot.py
    64: ```
    65: 
    66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
    67: 
    68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
    69: 
    70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
    71: 
    72: 
    73: ## Stratégie
    74: 
    75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
    76: rapidement les pertes.
    77: 
    78: Principes généraux :
    79: 
    80: - sélection de paires liquides au fort momentum ;
    81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
    82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
    83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
    84:   calculée selon le risque ;
    85: - limites quotidiennes pour protéger le capital.
    86: 
    87: Les règles détaillées et l’algorithme complet sont décrits dans
    88: `STRATEGY.md`.
    89: 
    90: ## Version
    91: 
    92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
    93: le code via la variable `scalp.__version__` :
    94: 
    95: ```python
    96: from scalp import __version__
    97: print(__version__)
    98: ```
    99: 
   100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   101: 
   102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   103: `scalp.version.bump_version_from_message` permet également de déterminer
   104: automatiquement l'incrément à appliquer à partir d'un message de commit
   105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   106: 
   107: Exemple d'incrément basé sur un message :
   108: 
   109: ```python
   110: from scalp.version import bump_version_from_message
   111: bump_version_from_message("feat: add new strategy")
   112: ```
   113: 
   114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   115: message de commit `git` et met à jour le fichier `VERSION` en
   116: conséquence.
   117: 
   118: La même opération peut être déclenchée depuis la ligne de commande via
   119: `cli.py` :
   120: 
   121: ```bash
   122: python cli.py bump-version
   123: ```
   124: 
   125: 
   126: ## Changelog
   127: 
   128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   129: 
   130: ## Avertissement
   131: 
   132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.

--------------------------------------------------------------------------------
FILE: STRATEGY.md  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Stratégie de trading
     2: 
     3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
     4: 
     5: ## Principes généraux
     6: 
     7: - ne traiter que des actifs liquides à fort momentum ;
     8: - suivre la tendance dominante et éviter les marchés plats ;
     9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
    10: - dimensionner chaque position selon un pourcentage fixe du capital ;
    11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
    12: 
    13: ## Sélection des paires
    14: 
    15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
    16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
    17:    - croisement entre EMA20 et EMA50 ;
    18:    - ATR élevé pour privilégier les actifs volatils.
    19: 
    20: ## Génération du signal
    21: 
    22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
    23: 
    24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
    25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
    26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
    27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
    28: - cassure du dernier **swing high/low** ;
    29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
    30: 
    31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
    32: 
    33: ## Gestion du risque
    34: 
    35: La classe `RiskManager` applique plusieurs garde‑fous :
    36: 
    37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
    38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
    39: - pause forcée en cas de pertes consécutives prolongées ;
    40: - contrôle du nombre maximal de positions ouvertes.
    41: 
    42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.

--------------------------------------------------------------------------------
FILE: bot.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import logging
     6: import os
     7: import sys
     8: from typing import Any, Dict, Iterable, Optional, Sequence
     9: 
    10: from engine.config.loader import load_config
    11: from engine.live.orchestrator import RunConfig, run_orchestrator
    12: from engine.live.notify import build_notifier_and_commands
    13: 
    14: LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
    15: logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
    16:                     format="%(asctime)s %(levelname)s %(name)s: %(message)s")
    17: log = logging.getLogger("bot")
    18: 
    19: def _build_exchange(cfg: Dict[str, Any]):
    20:     # CCXT si dispo -> sinon REST
    21:     try:
    22:         from engine.exchange.bitget_ccxt import BitgetExchange
    23:         ex = BitgetExchange(
    24:             api_key=cfg["secrets"]["bitget"]["access"],
    25:             secret=cfg["secrets"]["bitget"]["secret"],
    26:             password=cfg["secrets"]["bitget"]["passphrase"],
    27:             data_dir=cfg["runtime"]["data_dir"],
    28:         )
    29:         log.info("Exchange CCXT initialisé")
    30:         return ex
    31:     except Exception as exc:
    32:         log.warning("CCXT indisponible (%s) — fallback REST", exc)
    33:         from engine.exchange.bitget_rest import BitgetFuturesClient
    34:         return BitgetFuturesClient(
    35:             access_key=cfg["secrets"]["bitget"]["access"],
    36:             secret_key=cfg["secrets"]["bitget"]["secret"],
    37:             passphrase=cfg["secrets"]["bitget"]["passphrase"],
    38:             base_url=os.getenv("BITGET_BASE_URL", "https://api.bitget.com"),
    39:             paper_trade=cfg["runtime"].get("paper_trade", True),
    40:         )
    41: 
    42: async def _run() -> int:
    43:     cfg = load_config()
    44:     runtime = cfg.get("runtime", {})
    45:     strategy = cfg.get("strategy", {})
    46:     symbols: Sequence[str] = runtime.get("allowed_symbols") or ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
    47: 
    48:     run_cfg = RunConfig(
    49:         symbols=symbols,
    50:         timeframe=strategy.get("live_timeframe", "1m"),
    51:         refresh_secs=int(runtime.get("refresh_secs", 5)),
    52:         cache_dir=str(runtime.get("data_dir")),  # DATA_ROOT/data (hors repo)
    53:     )
    54:     ex = _build_exchange(cfg)
    55:     notifier, cmd_stream = build_notifier_and_commands(cfg)
    56:     await run_orchestrator(ex, run_cfg, notifier, cmd_stream)
    57:     return 0
    58: 
    59: def main(argv: Optional[Iterable[str]] = None) -> int:
    60:     try:
    61:         return asyncio.run(_run())
    62:     except KeyboardInterrupt:
    63:         log.info("Arrêt demandé (Ctrl+C)")
    64:         return 0
    65: 
    66: if __name__ == "__main__":
    67:     raise SystemExit(main(sys.argv[1:]))

--------------------------------------------------------------------------------
FILE: cli.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: """Command line utilities for the Scalp project.
     2: 
     3: This module exposes a small command line interface used throughout the
     4: project.  The actual trading logic lives in other modules, however the CLI is
     5: responsible for parsing parameters and dispatching the appropriate routines.
     6: 
     7: The implementation intentionally keeps the invoked functions minimal so that
     8: tests can patch them easily.  In a real deployment these functions would
     9: perform optimisation, walk‑forward analysis or run the live pipeline.
    10: """
    11: 
    12: from __future__ import annotations
    13: 
    14: import argparse
    15: import asyncio
    16: from typing import Iterable, List
    17: 
    18: from engine.version import bump_version_from_git
    19: 
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Placeholder implementations
    23: # ---------------------------------------------------------------------------
    24: 
    25: 
    26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
    27:     """Run a parallel parameter optimisation.
    28: 
    29:     The real project dispatches a potentially heavy optimisation routine.  The
    30:     function is kept trivial so unit tests can verify that the CLI wiring works
    31:     without actually performing the optimisation.
    32:     """
    33: 
    34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
    35: 
    36: 
    37: def run_walkforward_analysis(
    38:     pair: str, timeframe: str, splits: int, train_ratio: float
    39: ) -> None:
    40:     """Execute a walk-forward analysis."""
    41: 
    42:     print(
    43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
    44:     )
    45: 
    46: 
    47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
    48:     """Run the live trading pipeline."""
    49: 
    50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
    51: 
    52: 
    53: # ---------------------------------------------------------------------------
    54: # Argument parsing
    55: # ---------------------------------------------------------------------------
    56: 
    57: 
    58: def create_parser() -> argparse.ArgumentParser:
    59:     """Create the top-level argument parser."""
    60: 
    61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
    62:     sub = parser.add_subparsers(dest="command")
    63: 
    64:     # --- ``opt`` command -------------------------------------------------
    65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
    66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    67:     opt_p.add_argument("--tf", required=True, help="timeframe")
    68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
    69:     opt_p.set_defaults(
    70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
    71:     )
    72: 
    73:     # --- ``walkforward`` command ----------------------------------------
    74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
    75:     wf_p.add_argument("--pair", required=True, help="trading pair")
    76:     wf_p.add_argument("--tf", required=True, help="timeframe")
    77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
    78:     wf_p.add_argument(
    79:         "--train-ratio",
    80:         type=float,
    81:         default=0.7,
    82:         help="portion of data used for training",
    83:     )
    84:     wf_p.set_defaults(
    85:         func=lambda a: run_walkforward_analysis(
    86:             a.pair, a.tf, a.splits, a.train_ratio
    87:         )
    88:     )
    89: 
    90:     # --- ``live`` command -----------------------------------------------
    91:     live_p = sub.add_parser("live", help="run the live async pipeline")
    92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
    93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
    94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
    95: 
    96:     # --- ``bump-version`` command -------------------------------------
    97:     bv_p = sub.add_parser(
    98:         "bump-version",
    99:         help="update the VERSION file based on the latest git commit",
   100:     )
   101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
   102: 
   103:     return parser
   104: 
   105: 
   106: def main(argv: Iterable[str] | None = None) -> int:
   107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
   108: 
   109:     parser = create_parser()
   110:     args = parser.parse_args(argv)
   111:     if not hasattr(args, "func"):
   112:         parser.print_help()
   113:         return 0
   114:     result = args.func(args)
   115:     return 0 if result is None else int(result)
   116: 
   117: 
   118: if __name__ == "__main__":  # pragma: no cover - manual invocation
   119:     raise SystemExit(main())
   120: 

--------------------------------------------------------------------------------
FILE: data/BTCUSDT-1m.csv  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: ts,open,high,low,close,volume
     2: 1625097600000,34000,34100,33950,34050,123.4
     3: 1625097660000,34050,34200,34000,34150,150.7
     4: 1625097720000,34150,34300,34100,34250,180.3
     5: 1625097780000,34250,34400,34200,34350,200.1
     6: 1625097840000,34350,34500,34300,34450,220.8

--------------------------------------------------------------------------------
FILE: data/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Indicator computation helpers."""
     2: 
     3: from .indicators import compute_all
     4: 
     5: __all__ = ["compute_all"]

--------------------------------------------------------------------------------
FILE: dump.txt  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: Dump created: 2025-08-24 03:12:35
     2: Repository tree:
     3: Scalp/
     4:     CHANGELOG.md
     5:     Makefile
     6:     PROMPT.md
     7:     README.md
     8:     STRATEGY.md
     9:     bot.py
    10:     cli.py
    11:     init.py
    12:     pytest.ini
    13:     requirements-dev.txt
    14:     requirements.txt
    15:     sitecustomize.py
    16:     tg_diag.py
    17:     scalper/
    18:         VERSION
    19:         __init__.py
    20:         bitget_client.py
    21:         client.py
    22:         logging_utils.py
    23:         metrics.py
    24:         pairs.py
    25:         selfcheck.py
    26:         strategy.py
    27:         trade_utils.py
    28:         version.py
    29:         ws.py
    30:         positions/
    31:             __init__.py
    32:             state.py
    33:         risk/
    34:             __init__.py
    35:             manager.py
    36:         hooks/
    37:             prewarm_cache.py
    38:         exchange/
    39:             __init__.py
    40:             bitget_ccxt.py
    41:             fees.py
    42:         selection/
    43:             __init__.py
    44:             momentum.py
    45:             scanner.py
    46:         config/
    47:             __init__.py
    48:             loader.py
    49:         backtest/
    50:             __init__.py
    51:             cache.py
    52:             cli.py
    53:             engine.py
    54:             grid_search.py
    55:             loader_csv.py
    56:             market_data.py
    57:             metrics.py
    58:             optimize.py
    59:             run_multi.py
    60:             runner.py
    61:             walkforward.py
    62:         services/
    63:             __init__.py
    64:             data_cache.py
    65:             order_service.py
    66:             utils.py
    67:         signals/
    68:             __init__.py
    69:             current.py
    70:             factory.py
    71:             generator.py
    72:         adapters/
    73:             __init__.py
    74:             bitget.py
    75:             bitget_fetch.py
    76:             market_data.py
    77:         live/
    78:             __init__.py
    79:             backtest_telegram.py
    80:             commands.py
    81:             journal.py
    82:             logs.py
    83:             notify.py
    84:             ohlcv_service.py
    85:             orchestrator.py
    86:             orders.py
    87:             position_fsm.py
    88:             setup_wizard.py
    89:             state_store.py
    90:             telegram_async.py
    91:             watchlist.py
    92:             loops/
    93:                 trade.py
    94:     TRASH_20250823-124533/
    95:         bitget_futures_pairs.py
    96:         dashboard.py
    97:         dump_repo.py
    98:         quick_order.py
    99:         rr.py
   100:         run_backtest.py
   101:         short_one_way.py
   102:         notebooks/
   103:             spot/
   104:                 bitget_bot.py
   105:         scalper/
   106:             bot_config.py
   107:             legacy_config.py
   108:             notifier.py
   109:             telegram_bot.py
   110:         result/
   111:     data/
   112:         BTCUSDT-1m.csv
   113:         __init__.py
   114:         indicators.py
   115:     tests/
   116:         conftest.py
   117:         test_analyse_risque.py
   118:         test_backtest.py
   119:         test_backtest_multi.py
   120:         test_backtest_position.py
   121:         test_bitget_futures_pairs.py
   122:         test_bot_place_order_caps.py
   123:         test_bot_update.py
   124:         test_break_even_stop.py
   125:         test_calc_pnl_pct.py
   126:         test_check_config.py
   127:         test_cli.py
   128:         test_client.py
   129:         test_compute_position_size.py
   130:         test_compute_position_size_cap.py
   131:         test_dynamic_allocation.py
   132:         test_effective_leverage.py
   133:         test_env_loading.py
   134:         test_grid_search.py
   135:         test_heat_score.py
   136:         test_indicators.py
   137:         test_min_qty_rules.py
   138:         test_notifier.py
   139:         test_notional_and_pnl_units.py
   140:         test_pair_selection.py
   141:         test_pairs.py
   142:         test_risk_manager.py
   143:         test_risk_utils.py
   144:         test_signal_risk.py
   145:         test_slippage.py
   146:         test_strategy_v2.py
   147:         test_telegram_bot.py
   148:         test_utils.py
   149:         test_version.py
   150:         test_walk_forward.py
   151:         test_ws.py
   152: 
   153: ## CHANGELOG.md (last modified: 2025-08-23 20:57:14)
   154:      1: # Changelog
   155:      2: 
   156:      3: ## Unreleased
   157:      4: 
   158:      5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
   159:      6:   signal levels.
   160:      7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
   161:      8:   user risk level.
   162:      9: - Notional and margin caps with available balance check to avoid Bitget error
   163:     10:   `40762`.
   164:     11: - Risk notifications with green/yellow/red indicators for terminal and
   165:     12:   Telegram.
   166: 
   167: 
   168: ## Makefile (last modified: 2025-08-23 20:57:14)
   169:      1: .PHONY: test
   170:      2: 
   171:      3: test:
   172:      4: 	pytest
   173: 
   174: 
   175: ## PROMPT.md (last modified: 2025-08-23 20:57:14)
   176:      1: # Prompt de re-création du bot Scalp (version spot)
   177:      2: 
   178:      3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
   179:      4: 
   180:      5: ## Structure principale
   181:      6: 
   182:      7: ### bot.py
   183:      8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
   184:      9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
   185:     10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
   186:     11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
   187:     12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
   188:     13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
   189:     14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
   190:     15: 
   191:     16: ### cli.py
   192:     17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
   193:     18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
   194:     19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
   195:     20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
   196:     21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
   197:     22: 
   198:     23: ### init.py
   199:     24: - `install_packages(*args)` : installe des paquets via `pip`.
   200:     25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
   201:     26: 
   202:     27: ## Modules `scalp`
   203:     28: 
   204:     29: ### bot_config.py
   205:     30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
   206:     31: 
   207:     32: ### metrics.py
   208:     33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
   209:     34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
   210:     35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
   211:     36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
   212:     37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
   213:     38: 
   214:     39: ### strategy.py
   215:     40: - `ema(series, window)` : moyenne mobile exponentielle.
   216:     41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
   217:     42: - `obv(closes, volumes)` : série On Balance Volume.
   218:     43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
   219:     44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
   220:     45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
   221:     46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
   222:     47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
   223:     48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
   224:     49: 
   225:     50: ### trade_utils.py
   226:     51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
   227:     52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
   228:     53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
   229:     54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
   230:     55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
   231:     56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
   232:     57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
   233:     58: 
   234:     59: ### risk
   235:     60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
   236:     61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
   237:     62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
   238:     63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
   239:     64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
   240:     65: 
   241:     66: ### notifier.py
   242:     67: - `_pair_name(symbol)` : formatte le nom d’une paire.
   243:     68: - `_format_text(event, payload=None)` : construit un message lisible.
   244:     69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
   245:     70: 
   246:     71: ### logging_utils.py
   247:     72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
   248:     73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
   249:     74: 
   250:     75: ### bitget_client.py
   251:     76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
   252:     77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
   253:     78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
   254:     79:   - `get_account()`, `get_open_orders(symbol=None)`.
   255:     80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
   256:     81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
   257:     82: 
   258:     83: ### pairs.py
   259:     84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
   260:     85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
   261:     86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
   262:     87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
   263:     88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
   264:     89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
   265:     90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
   266:     91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
   267:     92: 
   268:     93: ### telegram_bot.py
   269:     94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
   270:     95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
   271:     96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
   272:     97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
   273:     98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
   274:     99: 
   275:    100: ## Utilisation
   276:    101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   277:    102: 2. Exécuter `init.py` pour installer les dépendances.
   278:    103: 3. Lancer `bot.py` pour démarrer le trading.
   279:    104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   280:    105: 
   281:    106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   282:    107: 
   283: 
   284: 
   285: ## README.md (last modified: 2025-08-23 20:57:14)
   286:      1: # Scalp
   287:      2: 
   288:      3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
   289:      4: 
   290:      5: ## Installation
   291:      6: 
   292:      7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
   293:      8: 
   294:      9: ```bash
   295:     10: pip install -r requirements.txt
   296:     11: ```
   297:     12: 
   298:     13: Pour développer ou exécuter les tests :
   299:     14: 
   300:     15: ```bash
   301:     16: pip install -r requirements-dev.txt
   302:     17: pytest  # ou make test
   303:     18: ```
   304:     19: 
   305:     20: ## Configuration
   306:     21: 
   307:     22: Le bot lit sa configuration via des variables d'environnement :
   308:     23: 
   309:     24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
   310:     25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
   311:     26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
   312:     27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
   313:     28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
   314:     29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
   315:     30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
   316:     31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
   317:     32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
   318:     33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
   319:     34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
   320:     35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
   321:     36: 
   322:     37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
   323:     38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
   324:     39: 
   325:     40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
   326:     41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
   327:     42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
   328:     43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
   329:     44: bot.
   330:     45: 
   331:     46: 
   332:     47: Exemple :
   333:     48: 
   334:     49: ```bash
   335:     50: export BITGET_ACCESS_KEY="votre_cle"
   336:     51: export BITGET_SECRET_KEY="votre_secret"
   337:     52: export PAPER_TRADE=true
   338:     53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
   339:     54: export TELEGRAM_CHAT_ID="123456789"
   340:     55: python bot.py
   341:     56: ```
   342:     57: 
   343:     58: ## Lancement
   344:     59: 
   345:     60: Après configuration, lancez simplement :
   346:     61: 
   347:     62: ```bash
   348:     63: python bot.py
   349:     64: ```
   350:     65: 
   351:     66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
   352:     67: 
   353:     68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
   354:     69: 
   355:     70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
   356:     71: 
   357:     72: 
   358:     73: ## Stratégie
   359:     74: 
   360:     75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
   361:     76: rapidement les pertes.
   362:     77: 
   363:     78: Principes généraux :
   364:     79: 
   365:     80: - sélection de paires liquides au fort momentum ;
   366:     81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
   367:     82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
   368:     83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
   369:     84:   calculée selon le risque ;
   370:     85: - limites quotidiennes pour protéger le capital.
   371:     86: 
   372:     87: Les règles détaillées et l’algorithme complet sont décrits dans
   373:     88: `STRATEGY.md`.
   374:     89: 
   375:     90: ## Version
   376:     91: 
   377:     92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
   378:     93: le code via la variable `scalp.__version__` :
   379:     94: 
   380:     95: ```python
   381:     96: from scalp import __version__
   382:     97: print(__version__)
   383:     98: ```
   384:     99: 
   385:    100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   386:    101: 
   387:    102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   388:    103: `scalp.version.bump_version_from_message` permet également de déterminer
   389:    104: automatiquement l'incrément à appliquer à partir d'un message de commit
   390:    105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   391:    106: 
   392:    107: Exemple d'incrément basé sur un message :
   393:    108: 
   394:    109: ```python
   395:    110: from scalp.version import bump_version_from_message
   396:    111: bump_version_from_message("feat: add new strategy")
   397:    112: ```
   398:    113: 
   399:    114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   400:    115: message de commit `git` et met à jour le fichier `VERSION` en
   401:    116: conséquence.
   402:    117: 
   403:    118: La même opération peut être déclenchée depuis la ligne de commande via
   404:    119: `cli.py` :
   405:    120: 
   406:    121: ```bash
   407:    122: python cli.py bump-version
   408:    123: ```
   409:    124: 
   410:    125: 
   411:    126: ## Changelog
   412:    127: 
   413:    128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   414:    129: 
   415:    130: ## Avertissement
   416:    131: 
   417:    132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.
   418: 
   419: 
   420: ## STRATEGY.md (last modified: 2025-08-23 20:57:14)
   421:      1: # Stratégie de trading
   422:      2: 
   423:      3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
   424:      4: 
   425:      5: ## Principes généraux
   426:      6: 
   427:      7: - ne traiter que des actifs liquides à fort momentum ;
   428:      8: - suivre la tendance dominante et éviter les marchés plats ;
   429:      9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
   430:     10: - dimensionner chaque position selon un pourcentage fixe du capital ;
   431:     11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
   432:     12: 
   433:     13: ## Sélection des paires
   434:     14: 
   435:     15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
   436:     16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
   437:     17:    - croisement entre EMA20 et EMA50 ;
   438:     18:    - ATR élevé pour privilégier les actifs volatils.
   439:     19: 
   440:     20: ## Génération du signal
   441:     21: 
   442:     22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
   443:     23: 
   444:     24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
   445:     25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
   446:     26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
   447:     27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
   448:     28: - cassure du dernier **swing high/low** ;
   449:     29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
   450:     30: 
   451:     31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
   452:     32: 
   453:     33: ## Gestion du risque
   454:     34: 
   455:     35: La classe `RiskManager` applique plusieurs garde‑fous :
   456:     36: 
   457:     37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
   458:     38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
   459:     39: - pause forcée en cas de pertes consécutives prolongées ;
   460:     40: - contrôle du nombre maximal de positions ouvertes.
   461:     41: 
   462:     42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.
   463: 
   464: 
   465: ## TRASH_20250823-124533/bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
   466:      1: #!/usr/bin/env python3
   467:      2: """Fetch the list of Bitget futures contracts.
   468:      3: 
   469:      4: This helper script queries the public Bitget REST API to retrieve futures
   470:      5: trading pairs for the specified product types and saves them to CSV and JSON
   471:      6: files. It mirrors the standalone example provided by the user but integrates
   472:      7: with the repository's configuration system.
   473:      8: 
   474:      9: Usage examples::
   475:     10: 
   476:     11:     python bitget_futures_pairs.py
   477:     12:     python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
   478:     13:     python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
   479:     14: """
   480:     15: from __future__ import annotations
   481:     16: 
   482:     17: import argparse
   483:     18: import csv
   484:     19: import json
   485:     20: import sys
   486:     21: import time
   487:     22: from typing import Any, Dict, List
   488:     23: 
   489:     24: from scalper.bot_config import CONFIG
   490:     25: 
   491:     26: try:  # pragma: no cover - import guard
   492:     27:     import requests
   493:     28: except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
   494:     29:     sys.stderr.write(
   495:     30:         "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
   496:     31:     )
   497:     32:     raise
   498:     33: 
   499:     34: BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
   500:     35: CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
   501:     36: DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]
   502:     37: 
   503:     38: 
   504:     39: def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
   505:     40:     """Return contract metadata for ``product_type``."""
   506:     41:     url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
   507:     42:     params = {"productType": product_type}
   508:     43:     resp = requests.get(url, params=params, timeout=timeout)
   509:     44:     try:
   510:     45:         data = resp.json()
   511:     46:     except json.JSONDecodeError as exc:  # pragma: no cover - network failure
   512:     47:         raise RuntimeError(
   513:     48:             f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
   514:     49:         ) from exc
   515:     50:     if resp.status_code != 200 or data.get("code") != "00000":
   516:     51:         raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
   517:     52:     return data.get("data", [])
   518:     53: 
   519:     54: 
   520:     55: def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
   521:     56:     """Select and rename key fields for CSV/JSON output."""
   522:     57:     rows: List[Dict[str, Any]] = []
   523:     58:     for c in contracts:
   524:     59:         row = {
   525:     60:             "productType": product_type,
   526:     61:             "symbol": c.get("symbol"),
   527:     62:             "baseCoin": c.get("baseCoin"),
   528:     63:             "quoteCoin": c.get("quoteCoin"),
   529:     64:             "symbolType": c.get("symbolType"),
   530:     65:             "symbolStatus": c.get("symbolStatus"),
   531:     66:             "maxLever": c.get("maxLever"),
   532:     67:             "minLever": c.get("minLever"),
   533:     68:             "minTradeNum": c.get("minTradeNum"),
   534:     69:             "sizeMultiplier": c.get("sizeMultiplier"),
   535:     70:             "pricePlace": c.get("pricePlace"),
   536:     71:             "volumePlace": c.get("volumePlace"),
   537:     72:             "launchTime": c.get("launchTime"),
   538:     73:             "deliveryTime": c.get("deliveryTime"),
   539:     74:         }
   540:     75:         rows.append(row)
   541:     76:     return rows
   542:     77: 
   543:     78: 
   544:     79: def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
   545:     80:     """Write ``rows`` to ``path`` in CSV format."""
   546:     81:     headers = [
   547:     82:         "productType",
   548:     83:         "symbol",
   549:     84:         "baseCoin",
   550:     85:         "quoteCoin",
   551:     86:         "symbolType",
   552:     87:         "symbolStatus",
   553:     88:         "maxLever",
   554:     89:         "minLever",
   555:     90:         "minTradeNum",
   556:     91:         "sizeMultiplier",
   557:     92:         "pricePlace",
   558:     93:         "volumePlace",
   559:     94:         "launchTime",
   560:     95:         "deliveryTime",
   561:     96:     ]
   562:     97:     with open(path, "w", newline="", encoding="utf-8") as fh:
   563:     98:         writer = csv.DictWriter(fh, fieldnames=headers)
   564:     99:         writer.writeheader()
   565:    100:         if rows:
   566:    101:             writer.writerows(rows)
   567:    102: 
   568:    103: 
   569:    104: def main(argv: List[str] | None = None) -> int:
   570:    105:     parser = argparse.ArgumentParser(
   571:    106:         description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
   572:    107:     )
   573:    108:     parser.add_argument(
   574:    109:         "--types",
   575:    110:         nargs="+",
   576:    111:         default=DEFAULT_PRODUCT_TYPES,
   577:    112:         help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
   578:    113:     )
   579:    114:     parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
   580:    115:     parser.add_argument(
   581:    116:         "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
   582:    117:     )
   583:    118:     parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
   584:    119:     args = parser.parse_args(argv)
   585:    120: 
   586:    121:     all_rows: List[Dict[str, Any]] = []
   587:    122:     merged_json: Dict[str, List[Dict[str, Any]]] = {}
   588:    123: 
   589:    124:     for i, pt in enumerate(args.types):
   590:    125:         try:
   591:    126:             contracts = fetch_contracts(pt)
   592:    127:         except Exception as exc:  # pragma: no cover - network/runtime error
   593:    128:             sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
   594:    129:             continue
   595:    130:         rows = normalize_rows(pt, contracts)
   596:    131:         all_rows.extend(rows)
   597:    132:         merged_json[pt] = contracts
   598:    133:         if i < len(args.types) - 1 and args.sleep > 0:
   599:    134:             time.sleep(args.sleep)
   600:    135: 
   601:    136:     all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))
   602:    137: 
   603:    138:     write_csv(all_rows, args.out)
   604:    139:     with open(args.json_out, "w", encoding="utf-8") as fh:
   605:    140:         json.dump(merged_json, fh, ensure_ascii=False, indent=2)
   606:    141: 
   607:    142:     counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
   608:    143:     total = sum(counts.values())
   609:    144:     print(
   610:    145:         f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
   611:    146:     )
   612:    147:     for pt, n in counts.items():
   613:    148:         print(f"  - {pt}: {n} pairs")
   614:    149:     return 0
   615:    150: 
   616:    151: 
   617:    152: if __name__ == "__main__":  # pragma: no cover - CLI execution
   618:    153:     raise SystemExit(main())
   619: 
   620: 
   621: ## TRASH_20250823-124533/dashboard.py (last modified: 2025-08-23 20:57:14)
   622:      1: # dashboard.py
   623:      2: from __future__ import annotations
   624:      3: 
   625:      4: import os
   626:      5: import time
   627:      6: from pathlib import Path
   628:      7: from typing import Dict, Tuple
   629:      8: 
   630:      9: import pandas as pd
   631:     10: import streamlit as st
   632:     11: 
   633:     12: # ------------------------------------------------------------
   634:     13: # Réglages
   635:     14: # ------------------------------------------------------------
   636:     15: LOG_DIR = Path("scalp/live/logs")  # emplacement des CSV créés par l'orchestrateur
   637:     16: REFRESH_SECS = 5                   # auto-refresh UI
   638:     17: MAX_ROWS_SHOW = 2000               # clamp mémoire
   639:     18: 
   640:     19: 
   641:     20: # ------------------------------------------------------------
   642:     21: # Utilitaires lecture robuste CSV
   643:     22: # ------------------------------------------------------------
   644:     23: def _safe_read_csv(path: Path) -> pd.DataFrame:
   645:     24:     if not path.exists():
   646:     25:         return pd.DataFrame()
   647:     26:     try:
   648:     27:         df = pd.read_csv(path)
   649:     28:         # clamp pour éviter d’exploser en RAM si les logs deviennent énormes
   650:     29:         if len(df) > MAX_ROWS_SHOW:
   651:     30:             df = df.tail(MAX_ROWS_SHOW).reset_index(drop=True)
   652:     31:         return df
   653:     32:     except Exception:
   654:     33:         # fichier en cours d’écriture → on réessaiera au prochain tick
   655:     34:         return pd.DataFrame()
   656:     35: 
   657:     36: 
   658:     37: def load_logs() -> Dict[str, pd.DataFrame]:
   659:     38:     return {
   660:     39:         "signals": _safe_read_csv(LOG_DIR / "signals.csv"),
   661:     40:         "orders": _safe_read_csv(LOG_DIR / "orders.csv"),
   662:     41:         "fills": _safe_read_csv(LOG_DIR / "fills.csv"),
   663:     42:         "positions": _safe_read_csv(LOG_DIR / "positions.csv"),
   664:     43:     }
   665:     44: 
   666:     45: 
   667:     46: def _format_ts_ms_to_str(df: pd.DataFrame, col: str = "ts") -> pd.DataFrame:
   668:     47:     if col in df.columns:
   669:     48:         try:
   670:     49:             df[col] = pd.to_datetime(df[col], unit="ms")
   671:     50:         except Exception:
   672:     51:             try:
   673:     52:                 df[col] = pd.to_datetime(df[col])
   674:     53:             except Exception:
   675:     54:                 pass
   676:     55:     return df
   677:     56: 
   678:     57: 
   679:     58: # ------------------------------------------------------------
   680:     59: # Métriques & agrégats simples
   681:     60: # ------------------------------------------------------------
   682:     61: def compute_activity_metrics(df_orders: pd.DataFrame, df_fills: pd.DataFrame) -> Tuple[float, float, int]:
   683:     62:     """
   684:     63:     Retourne: (volume notionnel approx, fees cumulés, nb fills)
   685:     64:     - notionnel approx = somme(|price * qty|) sur les fills (indépendant du sens)
   686:     65:     - fees = somme(fee) si dispo
   687:     66:     """
   688:     67:     notional = 0.0
   689:     68:     fees = 0.0
   690:     69:     n_fills = 0
   691:     70: 
   692:     71:     if not df_fills.empty:
   693:     72:         # normalisation colonnes
   694:     73:         price_col = next((c for c in ["price", "fillPrice", "fill_px"] if c in df_fills.columns), None)
   695:     74:         qty_col = next((c for c in ["qty", "size", "fillQty", "fill_sz"] if c in df_fills.columns), None)
   696:     75:         fee_col = next((c for c in ["fee", "fillFee"] if c in df_fills.columns), None)
   697:     76: 
   698:     77:         if price_col and qty_col:
   699:     78:             notional = float((df_fills[price_col].abs() * df_fills[qty_col].abs()).sum())
   700:     79:             n_fills = int(len(df_fills))
   701:     80:         if fee_col:
   702:     81:             fees = float(df_fills[fee_col].fillna(0).sum())
   703:     82: 
   704:     83:     return notional, fees, n_fills
   705:     84: 
   706:     85: 
   707:     86: def last_positions_snapshot(df_positions: pd.DataFrame) -> pd.DataFrame:
   708:     87:     """Dernier état par symbole (state/qty/entry)."""
   709:     88:     if df_positions.empty:
   710:     89:         return df_positions
   711:     90:     df = df_positions.copy()
   712:     91:     df = _format_ts_ms_to_str(df, "ts")
   713:     92:     # on prend le dernier enregistrement par symbol
   714:     93:     last = df.sort_values("ts").groupby("symbol", as_index=False).tail(1)
   715:     94:     return last.sort_values("symbol").reset_index(drop=True)
   716:     95: 
   717:     96: 
   718:     97: def recent_signals(df_signals: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   719:     98:     if df_signals.empty:
   720:     99:         return df_signals
   721:    100:     df = df_signals.copy()
   722:    101:     df = _format_ts_ms_to_str(df, "ts")
   723:    102:     df = df.sort_values("ts", ascending=False).head(limit)
   724:    103:     return df.reset_index(drop=True)
   725:    104: 
   726:    105: 
   727:    106: def recent_orders(df_orders: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
   728:    107:     if df_orders.empty:
   729:    108:         return df_orders
   730:    109:     df = df_orders.copy()
   731:    110:     df = _format_ts_ms_to_str(df, "ts")
   732:    111:     df = df.sort_values("ts", ascending=False).head(limit)
   733:    112:     # petites colonnes utiles en premier
   734:    113:     cols = [c for c in ["ts", "symbol", "side", "status", "price", "sl", "tp", "risk_pct", "order_id"] if c in df.columns]
   735:    114:     other = [c for c in df.columns if c not in cols]
   736:    115:     return df[cols + other]
   737:    116: 
   738:    117: 
   739:    118: def recent_fills(df_fills: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
   740:    119:     if df_fills.empty:
   741:    120:         return df_fills
   742:    121:     df = df_fills.copy()
   743:    122:     df = _format_ts_ms_to_str(df, "ts")
   744:    123:     df = df.sort_values("ts", ascending=False).head(limit)
   745:    124:     cols = [c for c in ["ts", "symbol", "order_id", "trade_id", "price", "qty", "fee"] if c in df.columns]
   746:    125:     other = [c for c in df.columns if c not in cols]
   747:    126:     return df[cols + other]
   748:    127: 
   749:    128: 
   750:    129: # ------------------------------------------------------------
   751:    130: # UI
   752:    131: # ------------------------------------------------------------
   753:    132: st.set_page_config(page_title="ScalpBot Dashboard", layout="wide")
   754:    133: st.title("📊 ScalpBot — Dashboard Live")
   755:    134: 
   756:    135: # auto-refresh
   757:    136: st.caption("Auto-refresh toutes les {}s".format(REFRESH_SECS))
   758:    137: st_autorefresh = st.experimental_rerun if False else None  # placeholder to keep code readable
   759:    138: # Streamlit v1.32+ propose st.autorefresh :
   760:    139: try:
   761:    140:     st_autorefresh = st.experimental_rerun  # fallback compat
   762:    141:     from streamlit.runtime.scriptrunner import add_script_run_ctx  # noqa: F401
   763:    142:     st_autorefresh = None
   764:    143: except Exception:
   765:    144:     pass
   766:    145: 
   767:    146: try:
   768:    147:     st_autorefresh = st.autorefresh(interval=REFRESH_SECS * 1000, key="autorf")
   769:    148: except Exception:
   770:    149:     pass
   771:    150: 
   772:    151: # Choix du dossier de logs (utile si on lance le dashboard depuis un autre cwd)
   773:    152: default_dir = str(LOG_DIR.resolve())
   774:    153: custom_dir = st.sidebar.text_input("Dossier de logs", value=default_dir)
   775:    154: LOG_DIR = Path(custom_dir) if custom_dir else LOG_DIR
   776:    155: 
   777:    156: if not LOG_DIR.exists():
   778:    157:     st.error(f"Dossier introuvable : {LOG_DIR}")
   779:    158:     st.stop()
   780:    159: 
   781:    160: data = load_logs()
   782:    161: df_sig, df_ord, df_fill, df_pos = data["signals"], data["orders"], data["fills"], data["positions"]
   783:    162: 
   784:    163: # KPIs rapides
   785:    164: notional, fees, n_fills = compute_activity_metrics(df_ord, df_fill)
   786:    165: col_a, col_b, col_c, col_d = st.columns(4)
   787:    166: col_a.metric("Paires actives (Top 10)", "10")
   788:    167: col_b.metric("Fills (total)", f"{n_fills}")
   789:    168: col_c.metric("Notionnel cumulé (approx)", f"{notional:,.0f} USDT")
   790:    169: col_d.metric("Frais cumulés", f"{fees:,.2f} USDT")
   791:    170: 
   792:    171: st.divider()
   793:    172: 
   794:    173: # 1) Positions snapshot
   795:    174: st.subheader("📌 Positions (snapshot courant par symbole)")
   796:    175: pos_snapshot = last_positions_snapshot(df_pos)
   797:    176: if pos_snapshot.empty:
   798:    177:     st.info("Aucune position pour l’instant.")
   799:    178: else:
   800:    179:     # Met un peu d'ordre dans les colonnes
   801:    180:     order_cols = [c for c in ["symbol", "state", "qty", "entry", "ts"] if c in pos_snapshot.columns]
   802:    181:     pos_snapshot = pos_snapshot[order_cols + [c for c in pos_snapshot.columns if c not in order_cols]]
   803:    182:     st.dataframe(pos_snapshot, use_container_width=True, height=260)
   804:    183: 
   805:    184: # 2) Derniers signaux
   806:    185: st.subheader("📣 Derniers signaux")
   807:    186: sig_tbl = recent_signals(df_sig, limit=40)
   808:    187: if sig_tbl.empty:
   809:    188:     st.info("Pas encore de signaux.")
   810:    189: else:
   811:    190:     # comptage LONG/SHORT
   812:    191:     try:
   813:    192:         by_side = sig_tbl.assign(side_norm=sig_tbl["side"].astype(str).str.upper()).groupby("side_norm").size()
   814:    193:         st.bar_chart(by_side)
   815:    194:     except Exception:
   816:    195:         pass
   817:    196:     st.dataframe(sig_tbl, use_container_width=True, height=300)
   818:    197: 
   819:    198: # 3) Ordres récents
   820:    199: st.subheader("🧾 Ordres récents")
   821:    200: ord_tbl = recent_orders(df_ord, limit=40)
   822:    201: if ord_tbl.empty:
   823:    202:     st.info("Pas encore d’ordres.")
   824:    203: else:
   825:    204:     st.dataframe(ord_tbl, use_container_width=True, height=280)
   826:    205: 
   827:    206: # 4) Fills récents
   828:    207: st.subheader("✅ Fills récents")
   829:    208: fills_tbl = recent_fills(df_fill, limit=80)
   830:    209: if fills_tbl.empty:
   831:    210:     st.info("Pas encore d’exécutions (fills).")
   832:    211: else:
   833:    212:     st.dataframe(fills_tbl, use_container_width=True, height=320)
   834:    213: 
   835:    214: st.caption(f"Logs: {LOG_DIR}")
   836: 
   837: ## TRASH_20250823-124533/dump_repo.py (last modified: 2025-08-23 20:57:14)
   838:      1: import os
   839:      2: from datetime import datetime
   840:      3: from pathlib import Path
   841:      4: 
   842:      5: IGNORE_EXTENSIONS = {'.log', '.pyc'}
   843:      6: IGNORE_DIRS = {'__pycache__'}
   844:      7: 
   845:      8: 
   846:      9: def _is_ignored(path: Path) -> bool:
   847:     10:     """Return True if the path should be ignored."""
   848:     11:     if any(part.startswith('.') for part in path.parts):
   849:     12:         return True
   850:     13:     if path.suffix in IGNORE_EXTENSIONS:
   851:     14:         return True
   852:     15:     if any(part in IGNORE_DIRS for part in path.parts):
   853:     16:         return True
   854:     17:     return False
   855:     18: 
   856:     19: 
   857:     20: def _build_tree(root: Path, ignore_path: Path) -> str:
   858:     21:     lines = []
   859:     22:     for dirpath, dirnames, filenames in os.walk(root):
   860:     23:         dirpath = Path(dirpath)
   861:     24:         dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
   862:     25:         depth = len(dirpath.relative_to(root).parts)
   863:     26:         indent = '    ' * depth
   864:     27:         lines.append(f"{indent}{dirpath.name}/")
   865:     28:         for fname in sorted(filenames):
   866:     29:             fpath = dirpath / fname
   867:     30:             if fpath == ignore_path or _is_ignored(fpath):
   868:     31:                 continue
   869:     32:             lines.append(f"{indent}    {fname}")
   870:     33:     return '\n'.join(lines)
   871:     34: 
   872:     35: 
   873:     36: def _iter_files(root: Path):
   874:     37:     for path in sorted(root.rglob('*')):
   875:     38:         if path.is_file() and not _is_ignored(path):
   876:     39:             yield path
   877:     40: 
   878:     41: 
   879:     42: def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
   880:     43:     """Create a text dump of the repository tree and file contents."""
   881:     44:     root_path = Path(root).resolve()
   882:     45:     output_path = root_path / output_path
   883:     46:     now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
   884:     47:     with output_path.open('w', encoding='utf-8') as dump:
   885:     48:         dump.write(f"Dump created: {now}\n")
   886:     49:         dump.write('Repository tree:\n')
   887:     50:         dump.write(_build_tree(root_path, output_path))
   888:     51:         dump.write('\n\n')
   889:     52:         for file_path in _iter_files(root_path):
   890:     53:             rel_path = file_path.relative_to(root_path)
   891:     54:             if file_path == output_path:
   892:     55:                 continue
   893:     56:             mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
   894:     57:             dump.write(f"## {rel_path} (last modified: {mod_time})\n")
   895:     58:             try:
   896:     59:                 with file_path.open('r', encoding='utf-8') as f:
   897:     60:                     for i, line in enumerate(f, 1):
   898:     61:                         dump.write(f"{i:6}: {line}")
   899:     62:             except Exception:
   900:     63:                 dump.write('[unreadable file]\n')
   901:     64:             dump.write('\n\n')
   902:     65: 
   903:     66: 
   904:     67: if __name__ == '__main__':
   905:     68:     create_dump_file()
   906: 
   907: 
   908: ## TRASH_20250823-124533/notebooks/spot/bitget_bot.py (last modified: 2025-08-23 20:57:14)
   909:      1: import os
   910:      2: import time
   911:      3: import hmac
   912:      4: import hashlib
   913:      5: import base64
   914:      6: import logging
   915:      7: from argparse import ArgumentParser
   916:      8: from pathlib import Path
   917:      9: from typing import Any, Dict, List
   918:     10: from urllib.parse import urlencode
   919:     11: 
   920:     12: import requests
   921:     13: from dotenv import load_dotenv
   922:     14: 
   923:     15: BASE_URL = "https://api.bitget.com"
   924:     16: RECV_WINDOW = 5000
   925:     17: 
   926:     18: 
   927:     19: def load_keys() -> Dict[str, str]:
   928:     20:     parent = Path(__file__).resolve().parent.parent
   929:     21:     load_dotenv(parent / ".env")
   930:     22:     api_key = os.getenv("BITGET_API_KEY")
   931:     23:     api_secret = os.getenv("BITGET_API_SECRET")
   932:     24:     if not api_key or not api_secret:
   933:     25:         raise RuntimeError("API keys not found in environment")
   934:     26:     return {"key": api_key, "secret": api_secret}
   935:     27: 
   936:     28: 
   937:     29: class BitgetClient:
   938:     30:     def __init__(self) -> None:
   939:     31:         creds = load_keys()
   940:     32:         self.api_key = creds["key"]
   941:     33:         self.api_secret = creds["secret"]
   942:     34:         self.session = requests.Session()
   943:     35:         self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
   944:     36:         self.time_offset = self._compute_time_offset()
   945:     37: 
   946:     38:     def _compute_time_offset(self) -> int:
   947:     39:         server = self.server_time()
   948:     40:         return int(server["serverTime"]) - int(time.time() * 1000)
   949:     41: 
   950:     42:     def _timestamp(self) -> int:
   951:     43:         return int(time.time() * 1000) + self.time_offset
   952:     44: 
   953:     45:     def _request(
   954:     46:         self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
   955:     47:     ) -> Any:
   956:     48:         params = params or {}
   957:     49:         if signed:
   958:     50:             params["timestamp"] = self._timestamp()
   959:     51:             params["recvWindow"] = RECV_WINDOW
   960:     52:             query = urlencode(params)
   961:     53:             signature = base64.b64encode(
   962:     54:                 hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
   963:     55:             ).decode()
   964:     56:             query += f"&signature={signature}"
   965:     57:             headers = {"X-BITGET-APIKEY": self.api_key}
   966:     58:             if method.upper() == "GET":
   967:     59:                 url = f"{BASE_URL}{path}?{query}"
   968:     60:                 resp = self.session.get(url, headers=headers)
   969:     61:             else:
   970:     62:                 url = f"{BASE_URL}{path}"
   971:     63:                 headers["Content-Type"] = "application/x-www-form-urlencoded"
   972:     64:                 resp = self.session.post(url, data=query, headers=headers)
   973:     65:         else:
   974:     66:             url = f"{BASE_URL}{path}"
   975:     67:             resp = self.session.request(method, url, params=params)
   976:     68: 
   977:     69:         resp.raise_for_status()
   978:     70:         if resp.text:
   979:     71:             return resp.json()
   980:     72:         return {}
   981:     73: 
   982:     74:     # Helpers
   983:     75:     def server_time(self) -> Any:
   984:     76:         return self._request("GET", "/api/v3/time")
   985:     77: 
   986:     78:     def ticker_price(self, symbol: str) -> Any:
   987:     79:         return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})
   988:     80: 
   989:     81:     def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
   990:     82:         return self._request(
   991:     83:             "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
   992:     84:         )
   993:     85: 
   994:     86:     def test_order(self, **params: Any) -> Any:
   995:     87:         return self._request("POST", "/api/v3/order/test", params, signed=True)
   996:     88: 
   997:     89:     def place_order(self, **params: Any) -> Any:
   998:     90:         return self._request("POST", "/api/v3/order", params, signed=True)
   999:     91: 
  1000:     92:     def account_info(self) -> Any:
  1001:     93:         return self._request("GET", "/api/v3/account", signed=True)
  1002:     94: 
  1003:     95:     def book_ticker(self, symbol: str) -> Any:
  1004:     96:         return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})
  1005:     97: 
  1006:     98: 
  1007:     99: def sma(values: List[float], period: int) -> float:
  1008:    100:     if len(values) < period:
  1009:    101:         raise ValueError("Not enough data for SMA")
  1010:    102:     return sum(values[-period:]) / period
  1011:    103: 
  1012:    104: 
  1013:    105: def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
  1014:    106:     kl = client.klines(symbol, limit=50)
  1015:    107:     closes = [float(k[4]) for k in kl]
  1016:    108:     sma9_prev = sma(closes[:-1], 9)
  1017:    109:     sma21_prev = sma(closes[:-1], 21)
  1018:    110:     sma9_curr = sma(closes, 9)
  1019:    111:     sma21_curr = sma(closes, 21)
  1020:    112: 
  1021:    113:     cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
  1022:    114:     cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr
  1023:    115: 
  1024:    116:     log = logging.getLogger("bitget_bot")
  1025:    117: 
  1026:    118:     if cross_up:
  1027:    119:         book = client.book_ticker(symbol)
  1028:    120:         ask = float(book["askPrice"])
  1029:    121:         qty = quote_usdt / ask
  1030:    122:         params = {
  1031:    123:             "symbol": symbol,
  1032:    124:             "side": "BUY",
  1033:    125:             "type": "LIMIT",
  1034:    126:             "timeInForce": "IOC",
  1035:    127:             "quantity": f"{qty:.6f}",
  1036:    128:             "price": book["askPrice"],
  1037:    129:         }
  1038:    130:         log.info("BUY signal %s", params)
  1039:    131:         resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1040:    132:         log.info("response %s", resp)
  1041:    133:     elif cross_down:
  1042:    134:         account = client.account_info()
  1043:    135:         base = symbol.rstrip("USDT")
  1044:    136:         bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
  1045:    137:         qty = float(bal["free"])
  1046:    138:         if qty > 0:
  1047:    139:             book = client.book_ticker(symbol)
  1048:    140:             params = {
  1049:    141:                 "symbol": symbol,
  1050:    142:                 "side": "SELL",
  1051:    143:                 "type": "LIMIT",
  1052:    144:                 "timeInForce": "IOC",
  1053:    145:                 "quantity": f"{qty:.6f}",
  1054:    146:                 "price": book["bidPrice"],
  1055:    147:             }
  1056:    148:             log.info("SELL signal %s", params)
  1057:    149:             resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1058:    150:             log.info("response %s", resp)
  1059:    151:         else:
  1060:    152:             log.info("No balance to sell")
  1061:    153: 
  1062:    154: 
  1063:    155: def interval_seconds(interval: str) -> int:
  1064:    156:     unit = interval[-1]
  1065:    157:     qty = int(interval[:-1])
  1066:    158:     if unit == "m":
  1067:    159:         return qty * 60
  1068:    160:     if unit == "h":
  1069:    161:         return qty * 3600
  1070:    162:     if unit == "d":
  1071:    163:         return qty * 86400
  1072:    164:     return 60
  1073:    165: 
  1074:    166: 
  1075:    167: def main() -> None:
  1076:    168:     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
  1077:    169:     parser = ArgumentParser(description="Bitget SMA crossover bot")
  1078:    170:     parser.add_argument("--symbol", default="BTCUSDT")
  1079:    171:     parser.add_argument("--quote-usdt", type=float, default=10.0)
  1080:    172:     parser.add_argument("--interval", default="1m")
  1081:    173:     parser.add_argument("--loop", action="store_true")
  1082:    174:     parser.add_argument("--dry-run", dest="dry_run", action="store_true")
  1083:    175:     parser.add_argument("--live", dest="dry_run", action="store_false")
  1084:    176:     parser.set_defaults(dry_run=True)
  1085:    177:     args = parser.parse_args()
  1086:    178: 
  1087:    179:     client = BitgetClient()
  1088:    180:     delay = interval_seconds(args.interval)
  1089:    181: 
  1090:    182:     while True:
  1091:    183:         try:
  1092:    184:             analyze(client, args.symbol, args.quote_usdt, args.dry_run)
  1093:    185:         except Exception as exc:
  1094:    186:             logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
  1095:    187:         if not args.loop:
  1096:    188:             break
  1097:    189:         time.sleep(delay)
  1098:    190: 
  1099:    191: 
  1100:    192: if __name__ == "__main__":
  1101:    193:     main()
  1102: 
  1103: 
  1104: ## TRASH_20250823-124533/quick_order.py (last modified: 2025-08-23 20:57:14)
  1105:      1: #!/usr/bin/env python3
  1106:      2: """Submit a simple market order on Bitget futures.
  1107:      3: 
  1108:      4: This helper reads API credentials and trade parameters from environment
  1109:      5: variables (optionally loaded from a `.env` file) and places a one-way
  1110:      6: market order.  Only the essential steps from the user's reference script
  1111:      7: are kept to minimise latency and redundant code.
  1112:      8: 
  1113:      9: Environment variables:
  1114:     10:     BITGET_API_KEY / BITGET_ACCESS_KEY
  1115:     11:     BITGET_API_SECRET / BITGET_SECRET_KEY
  1116:     12:     BITGET_API_PASSPHRASE
  1117:     13:     BITGET_BASE_URL (default https://api.bitget.com)
  1118:     14:     BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
  1119:     15:     BITGET_MARGIN_COIN (default ``USDT``)
  1120:     16:     BITGET_SYMBOL (e.g. ``BTCUSDT``)
  1121:     17:     BITGET_TEST_NOTIONAL_USDT (default ``5``)
  1122:     18: 
  1123:     19: Usage:
  1124:     20:     python quick_order.py buy
  1125:     21:     python quick_order.py sell
  1126:     22: """
  1127:     23: 
  1128:     24: from __future__ import annotations
  1129:     25: 
  1130:     26: import os
  1131:     27: import sys
  1132:     28: from pathlib import Path
  1133:     29: 
  1134:     30: from dotenv import load_dotenv
  1135:     31: 
  1136:     32: from scalper.bitget_client import BitgetFuturesClient
  1137:     33: 
  1138:     34: # Load variables from `.env` if present
  1139:     35: load_dotenv(Path(__file__).resolve().parent / ".env")
  1140:     36: 
  1141:     37: side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
  1142:     38: if side not in {"buy", "sell"}:
  1143:     39:     raise SystemExit("Usage: quick_order.py [buy|sell]")
  1144:     40: 
  1145:     41: base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
  1146:     42: ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
  1147:     43: sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
  1148:     44: ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
  1149:     45: product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
  1150:     46: margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
  1151:     47: symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
  1152:     48: notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))
  1153:     49: 
  1154:     50: if not (ak and sk and ph):
  1155:     51:     raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")
  1156:     52: 
  1157:     53: client = BitgetFuturesClient(
  1158:     54:     access_key=ak,
  1159:     55:     secret_key=sk,
  1160:     56:     base_url=base,
  1161:     57:     passphrase=ph,
  1162:     58:     paper_trade=False,
  1163:     59: )
  1164:     60: 
  1165:     61: tick = client.get_ticker(symbol)
  1166:     62: price = None
  1167:     63: try:
  1168:     64:     data = tick.get("data")
  1169:     65:     if isinstance(data, list) and data:
  1170:     66:         price_str = data[0].get("lastPr") or data[0].get("lastPrice")
  1171:     67:         if price_str is not None:
  1172:     68:             price = float(price_str)
  1173:     69:     elif isinstance(data, dict):
  1174:     70:         price_str = data.get("lastPr") or data.get("lastPrice")
  1175:     71:         if price_str is not None:
  1176:     72:             price = float(price_str)
  1177:     73: except Exception:
  1178:     74:     pass
  1179:     75: if price is None or price <= 0:
  1180:     76:     raise SystemExit("Prix introuvable pour le ticker")
  1181:     77: 
  1182:     78: size = round(notional / price, 6)
  1183:     79: client.set_position_mode_one_way(symbol, product_type)
  1184:     80: client.set_leverage(symbol, product_type, margin_coin, leverage=2)
  1185:     81: resp = client.place_market_order_one_way(
  1186:     82:     symbol, side, size, product_type, margin_coin
  1187:     83: )
  1188:     84: print(resp)
  1189: 
  1190: 
  1191: ## TRASH_20250823-124533/rr.py (last modified: 2025-08-23 20:57:14)
  1192:      1: #!/usr/bin/env python3
  1193:      2: from __future__ import annotations
  1194:      3: import argparse, shutil, re, os, datetime as dt
  1195:      4: from pathlib import Path
  1196:      5: 
  1197:      6: # ---------- helpers ----------
  1198:      7: def info(msg): print(f"[i] {msg}")
  1199:      8: def ok(msg):   print(f"[✓] {msg}")
  1200:      9: def warn(msg): print(f"[!] {msg}")
  1201:     10: 
  1202:     11: def backup_repo(repo: Path) -> Path:
  1203:     12:     ts = dt.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
  1204:     13:     dst = repo.parent / f".backup-refactor-{ts}"
  1205:     14:     shutil.copytree(repo, dst)
  1206:     15:     ok(f"Sauvegarde créée: {dst}")
  1207:     16:     return dst
  1208:     17: 
  1209:     18: def ensure_pkg_init(path: Path):
  1210:     19:     initp = path / "__init__.py"
  1211:     20:     if not initp.exists():
  1212:     21:         initp.write_text("# package\n", encoding="utf-8")
  1213:     22: 
  1214:     23: def move_dir(src: Path, dst: Path):
  1215:     24:     if not src.exists(): return
  1216:     25:     dst.mkdir(parents=True, exist_ok=True)
  1217:     26:     for child in src.iterdir():
  1218:     27:         shutil.move(str(child), str(dst / child.name))
  1219:     28:     # supprime le répertoire source s'il est vide
  1220:     29:     try: src.rmdir()
  1221:     30:     except Exception: pass
  1222:     31: 
  1223:     32: # règles initiales (rangement)
  1224:     33: IMPORT_RULES_STAGE1 = [
  1225:     34:     (re.compile(r"from\s+scalp\.config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1226:     35:     (re.compile(r"from\s+config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1227:     36:     (re.compile(r"from\s+scalp\.config\s+import\s+load_settings"), "from scalper.config import load_settings"),
  1228:     37:     (re.compile(r"from\s+live(\.| import)"), r"from scalper.live\1"),
  1229:     38:     (re.compile(r"import\s+live(\s|$)"), r"import scalper.live\1"),
  1230:     39:     (re.compile(r"from\s+backtest(\.| import)"), r"from scalper.backtest\1"),
  1231:     40:     (re.compile(r"import\s+backtest(\s|$)"), r"import scalper.backtest\1"),
  1232:     41:     (re.compile(r"from\s+signals(\.| import)"), r"from scalper.signals\1"),
  1233:     42:     (re.compile(r"import\s+signals(\s|$)"), r"import scalper.signals\1"),
  1234:     43:     (re.compile(r"from\s+exchange(\.| import)"), r"from scalper.exchange\1"),
  1235:     44:     (re.compile(r"import\s+exchange(\s|$)"), r"import scalper.exchange\1"),
  1236:     45: ]
  1237:     46: 
  1238:     47: def rewrite_imports(root: Path, rules):
  1239:     48:     changed = 0
  1240:     49:     for py in root.rglob("*.py"):
  1241:     50:         if ".backup-" in str(py) or ".backup" in str(py):  # safety
  1242:     51:             continue
  1243:     52:         txt = py.read_text(encoding="utf-8")
  1244:     53:         new = txt
  1245:     54:         for pat, rep in rules:
  1246:     55:             new = pat.sub(rep, new)
  1247:     56:         if new != txt:
  1248:     57:             py.write_text(new, encoding="utf-8")
  1249:     58:             changed += 1
  1250:     59:     return changed
  1251:     60: 
  1252:     61: def ensure_config_package(scalp_pkg: Path):
  1253:     62:     """Transforme scalp/config.py en package scalp/config/loader.py et ajoute __init__.py exportant load_settings."""
  1254:     63:     flat = scalp_pkg / "config.py"
  1255:     64:     pkg = scalp_pkg / "config"
  1256:     65:     loader = pkg / "loader.py"
  1257:     66:     initp = pkg / "__init__.py"
  1258:     67: 
  1259:     68:     # si un config.py existe, le renommer pour archivage
  1260:     69:     if flat.exists():
  1261:     70:         legacy = scalp_pkg / "legacy_config.py"
  1262:     71:         if legacy.exists(): legacy.unlink()
  1263:     72:         shutil.move(str(flat), str(legacy))
  1264:     73:         info(f"renommé {flat} -> {legacy}")
  1265:     74: 
  1266:     75:     pkg.mkdir(parents=True, exist_ok=True)
  1267:     76:     ensure_pkg_init(pkg)
  1268:     77: 
  1269:     78:     # si pas de loader.py, créer un loader minimal (tu pourras le remplacer par ta version complète)
  1270:     79:     if not loader.exists():
  1271:     80:         loader.write_text(
  1272:     81:             'from __future__ import annotations\n'
  1273:     82:             'import os, json\n'
  1274:     83:             'from typing import Any, Dict, Tuple\n'
  1275:     84:             'try:\n'
  1276:     85:             '    import yaml\n'
  1277:     86:             'except Exception:\n'
  1278:     87:             '    yaml = None\n'
  1279:     88:             'try:\n'
  1280:     89:             '    from dotenv import load_dotenv\n'
  1281:     90:             'except Exception:\n'
  1282:     91:             '    load_dotenv = None\n'
  1283:     92:             '\n'
  1284:     93:             'def _read_yaml(path: str):\n'
  1285:     94:             '    if not os.path.exists(path): return {}\n'
  1286:     95:             '    with open(path, "r", encoding="utf-8") as f:\n'
  1287:     96:             '        if yaml: return yaml.safe_load(f) or {}\n'
  1288:     97:             '        return json.load(f)\n'
  1289:     98:             '\n'
  1290:     99:             'def load_settings(config_path: str="config.yml", config_local_path: str="config.local.yml"):\n'
  1291:    100:             '    if load_dotenv: load_dotenv(override=False)\n'
  1292:    101:             '    base = _read_yaml(config_path)\n'
  1293:    102:             '    local = _read_yaml(config_local_path)\n'
  1294:    103:             '    cfg = {**base, **local}\n'
  1295:    104:             '    runtime = {\n'
  1296:    105:             '        "quiet": bool(cfg.get("QUIET", 1)),\n'
  1297:    106:             '        "print_sample": bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)),\n'
  1298:    107:             '        "timeframe": str(cfg.get("TIMEFRAME", "5m")),\n'
  1299:    108:             '        "cash": float(cfg.get("CASH", 10000)),\n'
  1300:    109:             '        "risk_pct": float(cfg.get("RISK_PCT", 0.5)),\n'
  1301:    110:             '        "slippage_bps": float(cfg.get("SLIPPAGE_BPS", 2)),\n'
  1302:    111:             '        "watchlist_mode": str(cfg.get("WATCHLIST_MODE", "local")),\n'
  1303:    112:             '        "watchlist_local_conc": int(cfg.get("WATCHLIST_LOCAL_CONC", 5)),\n'
  1304:    113:             '        "top_symbols": cfg.get("TOP_SYMBOLS", []),\n'
  1305:    114:             '        "top_candidates": cfg.get("TOP_CANDIDATES", []),\n'
  1306:    115:             '        "caps": cfg.get("CAPS", {}),\n'
  1307:    116:             '        "fees_by_symbol": {},\n'
  1308:    117:             '    }\n'
  1309:    118:             '    secrets = {\n'
  1310:    119:             '        "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),\n'
  1311:    120:             '        "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),\n'
  1312:    121:             '        "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),\n'
  1313:    122:             '        "BITGET_USE_TESTNET": os.getenv("BITGET_USE_TESTNET", "1") in ("1","true","True"),\n'
  1314:    123:             '        "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),\n'
  1315:    124:             '        "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),\n'
  1316:    125:             '        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),\n'
  1317:    126:             '    }\n'
  1318:    127:             '    return runtime, secrets\n',
  1319:    128:             encoding="utf-8"
  1320:    129:         )
  1321:    130:     # __init__.py exporte load_settings
  1322:    131:     initp.write_text("from .loader import load_settings\n__all__ = ['load_settings']\n", encoding="utf-8")
  1323:    132: 
  1324:    133: def stage1_restructure(repo: Path):
  1325:    134:     """Range les modules à l’intérieur du package 'scalp/' + fix imports."""
  1326:    135:     scalp_pkg = repo / "scalp"
  1327:    136:     scalp_pkg.mkdir(exist_ok=True)
  1328:    137:     ensure_pkg_init(scalp_pkg)
  1329:    138: 
  1330:    139:     for mod in ("live", "backtest", "signals", "config", "exchange"):
  1331:    140:         src = repo / mod
  1332:    141:         if src.exists() and src.is_dir():
  1333:    142:             dst = scalp_pkg / mod
  1334:    143:             info(f"déplacement {src} -> {dst}")
  1335:    144:             move_dir(src, dst)
  1336:    145:             ensure_pkg_init(dst)
  1337:    146: 
  1338:    147:     # gérer config.py -> package config/loader.py
  1339:    148:     ensure_config_package(scalp_pkg)
  1340:    149: 
  1341:    150:     # réécriture imports vers scalper.*
  1342:    151:     changed = rewrite_imports(repo, IMPORT_RULES_STAGE1)
  1343:    152:     ok(f"imports stage1 réécrits dans {changed} fichier(s)")
  1344:    153: 
  1345:    154: def stage2_rename_package(repo: Path, old="scalp", new="scalper"):
  1346:    155:     """Renomme le package interne old -> new et réécrit tous les imports."""
  1347:    156:     pkg_old = repo / old
  1348:    157:     pkg_new = repo / new
  1349:    158:     if not pkg_old.exists():
  1350:    159:         warn(f"package {pkg_old} introuvable (déjà renommé ?)")
  1351:    160:     else:
  1352:    161:         shutil.move(str(pkg_old), str(pkg_new))
  1353:    162:         ok(f"package renommé {pkg_old.name} -> {pkg_new.name}")
  1354:    163: 
  1355:    164:     # réécriture imports 'old.' -> 'new.'
  1356:    165:     pat = re.compile(rf"\b{old}\.")
  1357:    166:     changed = 0
  1358:    167:     for py in repo.rglob("*.py"):
  1359:    168:         if ".backup" in str(py): continue
  1360:    169:         txt = py.read_text(encoding="utf-8")
  1361:    170:         new_txt = pat.sub(f"{new}.", txt)
  1362:    171:         if new_txt != txt:
  1363:    172:             py.write_text(new_txt, encoding="utf-8")
  1364:    173:             changed += 1
  1365:    174:     ok(f"imports stage2 réécrits dans {changed} fichier(s)")
  1366:    175: 
  1367:    176: def main():
  1368:    177:     ap = argparse.ArgumentParser(description="Restructure + rename Python package (scalp -> scalper).")
  1369:    178:     ap.add_argument("--repo", default="./", help="Chemin du repo (racine qui contient bot.py).")
  1370:    179:     args = ap.parse_args()
  1371:    180:     repo = Path(args.repo).resolve()
  1372:    181:     if not repo.exists(): raise SystemExit(f"Repo introuvable: {repo}")
  1373:    182: 
  1374:    183:     # 1) sauvegarde
  1375:    184:     backup_repo(repo)
  1376:    185: 
  1377:    186:     # 2) ranger les modules sous scalp/ (package) + fixer imports
  1378:    187:     stage1_restructure(repo)
  1379:    188: 
  1380:    189:     # 3) renommer le package interne scalp/ -> scalper/ + fixer imports
  1381:    190:     stage2_rename_package(repo, old="scalp", new="scalper")
  1382:    191: 
  1383:    192:     ok("Refactor complet terminé.")
  1384:    193:     print("\n➡️ Vérifie maintenant:\n"
  1385:    194:           "   python - <<'PY'\n"
  1386:    195:           "import importlib; m = importlib.import_module('scalper.config'); print('OK:', hasattr(m, 'load_settings'))\n"
  1387:    196:           "PY\n"
  1388:    197:           "\nPuis lance:\n"
  1389:    198:           "   python bot.py\n")
  1390:    199: 
  1391:    200: if __name__ == "__main__":
  1392:    201:     main()
  1393: 
  1394: ## TRASH_20250823-124533/run_backtest.py (last modified: 2025-08-23 20:57:14)
  1395:      1: #!/usr/bin/env python3
  1396:      2: import os
  1397:      3: from scalper.backtest.engine import BacktestEngine
  1398:      4: 
  1399:      5: def main():
  1400:      6:     print("[*] Lancement du backtest...")
  1401:      7:     
  1402:      8:     # ⚡ Tu pourras changer ces paramètres
  1403:      9:     pairs = ["BTCUSDT", "ETHUSDT"]  # pour commencer simple
  1404:     10:     start_date = "2024-01-01"
  1405:     11:     end_date = "2024-02-01"
  1406:     12: 
  1407:     13:     # Dossier résultat
  1408:     14:     result_dir = os.path.join(os.path.dirname(__file__), "result")
  1409:     15:     os.makedirs(result_dir, exist_ok=True)
  1410:     16: 
  1411:     17:     # Création du moteur
  1412:     18:     engine = BacktestEngine(
  1413:     19:         pairs=pairs,
  1414:     20:         start_date=start_date,
  1415:     21:         end_date=end_date,
  1416:     22:         result_dir=result_dir
  1417:     23:     )
  1418:     24: 
  1419:     25:     # Lancer le backtest
  1420:     26:     engine.run()
  1421:     27: 
  1422:     28:     print("[✅] Backtest terminé ! Résultats disponibles dans /result/")
  1423:     29: 
  1424:     30: if __name__ == "__main__":
  1425:     31:     main()
  1426: 
  1427: ## TRASH_20250823-124533/scalper/bot_config.py (last modified: 2025-08-23 20:57:14)
  1428:      1: import os
  1429:      2: 
  1430:      3: 
  1431:      4: DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"
  1432:      5: 
  1433:      6: CONFIG = {
  1434:      7:     "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
  1435:      8:     or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
  1436:      9:     "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
  1437:     10:     or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
  1438:     11:     "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
  1439:     12:     "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
  1440:     13:     "SYMBOL": DEFAULT_SYMBOL,
  1441:     14:     "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
  1442:     15:     "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
  1443:     16:     "INTERVAL": os.getenv("INTERVAL", "1m"),
  1444:     17:     "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
  1445:     18:     "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
  1446:     19:     "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
  1447:     20:     "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
  1448:     21:     "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
  1449:     22:     "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
  1450:     23:     "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
  1451:     24:     "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
  1452:     25:     "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
  1453:     26:     "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
  1454:     27:     "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
  1455:     28:     "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
  1456:     29:     "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
  1457:     30:     "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
  1458:     31:     "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
  1459:     32:     "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
  1460:     33:     "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
  1461:     34:     "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
  1462:     35:     "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
  1463:     36:     "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
  1464:     37:     "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
  1465:     38:     # --- Sécurité / Sizing -------------------------------------------------
  1466:     39:     "ALLOWED_SYMBOLS": [
  1467:     40:         s.strip().upper()
  1468:     41:         for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
  1469:     42:         if s.strip()
  1470:     43:     ],
  1471:     44:     "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
  1472:     45:     "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
  1473:     46:     "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
  1474:     47:     "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
  1475:     48:     "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
  1476:     49:     "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
  1477:     50:     "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
  1478:     51:     "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
  1479:     52:     "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
  1480:     53: }
  1481:     54: 
  1482: 
  1483: 
  1484: ## TRASH_20250823-124533/scalper/legacy_config.py (last modified: 2025-08-23 20:57:14)
  1485:      1: # scalp/config.py
  1486:      2: from __future__ import annotations
  1487:      3: import os, sys
  1488:      4: from typing import Optional
  1489:      5: 
  1490:      6: # ---------------------------
  1491:      7: #  Chargement .env (sans dep)
  1492:      8: # ---------------------------
  1493:      9: def _load_dotenv_if_present(path: str = ".env") -> None:
  1494:     10:     try:
  1495:     11:         if not os.path.isfile(path):
  1496:     12:             return
  1497:     13:         with open(path, "r", encoding="utf-8") as f:
  1498:     14:             for line in f:
  1499:     15:                 s = line.strip()
  1500:     16:                 if not s or s.startswith("#") or "=" not in s:
  1501:     17:                     continue
  1502:     18:                 k, v = s.split("=", 1)
  1503:     19:                 k = k.strip()
  1504:     20:                 v = v.strip().strip('"').strip("'")
  1505:     21:                 # ne pas écraser une var déjà définie par l'env
  1506:     22:                 os.environ.setdefault(k, v)
  1507:     23:     except Exception:
  1508:     24:         pass
  1509:     25: 
  1510:     26: _load_dotenv_if_present()
  1511:     27: 
  1512:     28: # ---------------------------
  1513:     29: #  Aliases variables d'env
  1514:     30: # ---------------------------
  1515:     31: def _env_alias(name: str, *aliases: str) -> Optional[str]:
  1516:     32:     """Retourne la première valeur non nulle parmi name et ses alias."""
  1517:     33:     if name in os.environ and os.environ[name]:
  1518:     34:         return os.environ[name]
  1519:     35:     for a in aliases:
  1520:     36:         v = os.environ.get(a)
  1521:     37:         if v:
  1522:     38:             return v
  1523:     39:     return None
  1524:     40: 
  1525:     41: def _env_bool(name: str, default: bool) -> bool:
  1526:     42:     raw = os.environ.get(name)
  1527:     43:     if raw is None:
  1528:     44:         return default
  1529:     45:     return raw.lower() in ("1", "true", "yes", "on")
  1530:     46: 
  1531:     47: # ---------------------------
  1532:     48: #  Pydantic v1 si dispo
  1533:     49: # ---------------------------
  1534:     50: try:
  1535:     51:     from pydantic import BaseModel, Field, ValidationError  # type: ignore
  1536:     52:     _HAVE_PYDANTIC = True
  1537:     53: except Exception:
  1538:     54:     _HAVE_PYDANTIC = False
  1539:     55: 
  1540:     56: if _HAVE_PYDANTIC:
  1541:     57: 
  1542:     58:     class AppConfig(BaseModel):
  1543:     59:         # Clés Bitget
  1544:     60:         BITGET_API_KEY: str = Field(..., min_length=3)
  1545:     61:         BITGET_API_SECRET: str = Field(..., min_length=3)
  1546:     62:         BITGET_PASSPHRASE: str = Field(..., min_length=1)
  1547:     63: 
  1548:     64:         # Trading
  1549:     65:         RISK_PCT: float = Field(0.01, ge=0.0, le=0.2)
  1550:     66:         MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
  1551:     67:         LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
  1552:     68:         PAPER_TRADE: bool = Field(True)
  1553:     69: 
  1554:     70:         # Telegram (facultatif)
  1555:     71:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  1556:     72:         TELEGRAM_CHAT_ID: Optional[str] = None
  1557:     73: 
  1558:     74:     def load_or_exit() -> "AppConfig":
  1559:     75:         try:
  1560:     76:             # supporte aussi ACCESS_KEY/SECRET_KEY (alias)
  1561:     77:             api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  1562:     78:             api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  1563:     79:             api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  1564:     80: 
  1565:     81:             return AppConfig(
  1566:     82:                 BITGET_API_KEY=api_key,
  1567:     83:                 BITGET_API_SECRET=api_sec,
  1568:     84:                 BITGET_PASSPHRASE=api_pass,
  1569:     85:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  1570:     86:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  1571:     87:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  1572:     88:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  1573:     89:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  1574:     90:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  1575:     91:             )
  1576:     92:         except ValidationError as e:
  1577:     93:             print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
  1578:     94:             sys.exit(2)
  1579:     95: 
  1580:     96: else:
  1581:     97:     # ---------------------------
  1582:     98:     #  Fallback dataclass simple
  1583:     99:     # ---------------------------
  1584:    100:     from dataclasses import dataclass
  1585:    101: 
  1586:    102:     @dataclass
  1587:    103:     class AppConfig:
  1588:    104:         BITGET_API_KEY: str
  1589:    105:         BITGET_API_SECRET: str
  1590:    106:         BITGET_PASSPHRASE: str
  1591:    107: 
  1592:    108:         RISK_PCT: float = 0.01
  1593:    109:         MIN_TRADE_USDT: float = 5.0
  1594:    110:         LEVERAGE: float = 1.0
  1595:    111:         PAPER_TRADE: bool = True
  1596:    112: 
  1597:    113:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  1598:    114:         TELEGRAM_CHAT_ID: Optional[str] = None
  1599:    115: 
  1600:    116:     def load_or_exit() -> "AppConfig":
  1601:    117:         api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  1602:    118:         api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  1603:    119:         api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  1604:    120: 
  1605:    121:         if not api_key or not api_sec or not api_pass:
  1606:    122:             print("[CONFIG] Missing Bitget credentials. Expected either:", file=sys.stderr)
  1607:    123:             print("        - BITGET_API_KEY / BITGET_API_SECRET / BITGET_PASSPHRASE", file=sys.stderr)
  1608:    124:             print("          or", file=sys.stderr)
  1609:    125:             print("        - BITGET_ACCESS_KEY / BITGET_SECRET_KEY / BITGET_PASSPHRASE", file=sys.stderr)
  1610:    126:             sys.exit(2)
  1611:    127: 
  1612:    128:         try:
  1613:    129:             return AppConfig(
  1614:    130:                 BITGET_API_KEY=api_key,
  1615:    131:                 BITGET_API_SECRET=api_sec,
  1616:    132:                 BITGET_PASSPHRASE=api_pass,
  1617:    133:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  1618:    134:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  1619:    135:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  1620:    136:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  1621:    137:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  1622:    138:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  1623:    139:             )
  1624:    140:         except Exception as e:
  1625:    141:             print(f"[CONFIG] Invalid configuration values: {e!r}", file=sys.stderr)
  1626:    142:             sys.exit(2)
  1627: 
  1628: ## TRASH_20250823-124533/scalper/notifier.py (last modified: 2025-08-23 20:57:14)
  1629:      1: """Simple notifier for bot events."""
  1630:      2: 
  1631:      3: from __future__ import annotations
  1632:      4: 
  1633:      5: import logging
  1634:      6: import os
  1635:      7: from typing import Any, Dict
  1636:      8: 
  1637:      9: try:  # pragma: no cover - guarded import for optional dependency
  1638:     10:     import requests as _requests
  1639:     11: 
  1640:     12:     # ``requests`` may be provided as a stub during tests. Ensure it exposes a
  1641:     13:     # ``post`` attribute so callers can monkeypatch it reliably.
  1642:     14:     if not hasattr(_requests, "post"):
  1643:     15:         raise ImportError
  1644:     16:     requests = _requests
  1645:     17: except Exception:  # pragma: no cover - fallback when ``requests`` is missing
  1646:     18: 
  1647:     19:     class _Requests:
  1648:     20:         """Minimal stand‑in for :mod:`requests` when the real library is absent."""
  1649:     21: 
  1650:     22:         def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
  1651:     23:             raise RuntimeError("requests.post unavailable")
  1652:     24: 
  1653:     25:     requests = _Requests()  # type: ignore[assignment]
  1654:     26: 
  1655:     27: 
  1656:     28: def _pair_name(symbol: str) -> str:
  1657:     29:     """Return a human friendly pair name without the base ``USDT``."""
  1658:     30:     if "_" in symbol:
  1659:     31:         base, quote = symbol.split("_", 1)
  1660:     32:     elif symbol.endswith("USDT"):
  1661:     33:         base, quote = symbol[:-4], "USDT"
  1662:     34:     else:
  1663:     35:         base, quote = symbol, ""
  1664:     36:     if not quote or quote == "USDT":
  1665:     37:         return base
  1666:     38:     return f"{base}/{quote}"
  1667:     39: 
  1668:     40: 
  1669:     41: def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
  1670:     42:     """Format a position open/close payload."""
  1671:     43: 
  1672:     44:     side = payload.get("side")
  1673:     45:     symbol = payload.get("symbol")
  1674:     46:     if symbol:
  1675:     47:         symbol = _pair_name(symbol)
  1676:     48: 
  1677:     49:     if event == "position_opened":
  1678:     50:         rc = payload.get("risk_color", "")
  1679:     51:         head = f"{rc} Ouvre {side} {symbol}".strip()
  1680:     52:         lines = [head]
  1681:     53:         lines.append(
  1682:     54:             f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
  1683:     55:         )
  1684:     56:         lines.append(
  1685:     57:             "Marge estimée: {} USDT (dispo: {} USDT)".format(
  1686:     58:                 payload.get("required_margin_usdt"), payload.get("available_usdt")
  1687:     59:             )
  1688:     60:         )
  1689:     61:         lines.append(
  1690:     62:             "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
  1691:     63:                 payload.get("signal_level"),
  1692:     64:                 payload.get("risk_level_user"),
  1693:     65:                 float(payload.get("risk_pct_eff", 0.0)) * 100,
  1694:     66:             )
  1695:     67:         )
  1696:     68:         lines.append(
  1697:     69:             "Prix: {}   Vol: {} (cs={})".format(
  1698:     70:                 payload.get("price"),
  1699:     71:                 payload.get("vol"),
  1700:     72:                 payload.get("contract_size"),
  1701:     73:             )
  1702:     74:         )
  1703:     75:         return "\n".join(lines)
  1704:     76: 
  1705:     77:     # position_closed
  1706:     78:     rc = payload.get("risk_color", "")
  1707:     79:     head = f"Ferme {side} {symbol} {rc}".strip()
  1708:     80:     lines = [head]
  1709:     81:     pnl_usdt = payload.get("pnl_usdt")
  1710:     82:     fees = payload.get("fees_usdt")
  1711:     83:     if pnl_usdt is not None and fees is not None:
  1712:     84:         lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
  1713:     85:     pct = payload.get("pnl_pct_on_margin")
  1714:     86:     if pct is not None:
  1715:     87:         lines.append(f"% sur marge: {pct:.2f}%")
  1716:     88:     lines.append(
  1717:     89:         "Entrée: {}  Sortie: {}".format(
  1718:     90:             payload.get("entry_price"), payload.get("exit_price")
  1719:     91:         )
  1720:     92:     )
  1721:     93:     lines.append(
  1722:     94:         "Vol: {}  Notional: in {} → out {} USDT".format(
  1723:     95:             payload.get("vol"),
  1724:     96:             payload.get("notional_entry_usdt"),
  1725:     97:             payload.get("notional_exit_usdt"),
  1726:     98:         )
  1727:     99:     )
  1728:    100:     return "\n".join(lines)
  1729:    101: 
  1730:    102: 
  1731:    103: def _format_pair_list(payload: Dict[str, Any]) -> str:
  1732:    104:     """Format the pair list payload.
  1733:    105: 
  1734:    106:     The detailed pair listing is intentionally hidden from terminal output to
  1735:    107:     reduce noise. Only an acknowledgement message is returned.
  1736:    108:     """
  1737:    109: 
  1738:    110:     return "Listing ok"
  1739:    111: 
  1740:    112: 
  1741:    113: def _format_generic(event: str, payload: Dict[str, Any]) -> str:
  1742:    114:     text = event
  1743:    115:     if payload:
  1744:    116:         items = "\n".join(f"{k}={v}" for k, v in payload.items())
  1745:    117:         text = f"{text}\n{items}"
  1746:    118:     return text
  1747:    119: 
  1748:    120: 
  1749:    121: def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
  1750:    122:     """Return a human readable text describing the event payload."""
  1751:    123:     payload = payload or {}
  1752:    124:     if event in {"position_opened", "position_closed"}:
  1753:    125:         return _format_position_event(event, payload)
  1754:    126:     if event == "pair_list":
  1755:    127:         return _format_pair_list(payload)
  1756:    128:     if event == "bot_started":
  1757:    129:         return "🤖 Bot démarré"
  1758:    130:     return _format_generic(event, payload)
  1759:    131: 
  1760:    132: 
  1761:    133: def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
  1762:    134:     """Send an event payload to configured endpoints.
  1763:    135: 
  1764:    136:     Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
  1765:    137:     and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
  1766:    138:     ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
  1767:    139:     ignored so they do not interrupt the bot's execution.
  1768:    140:     """
  1769:    141: 
  1770:    142:     data = {"event": event}
  1771:    143:     if payload:
  1772:    144:         data.update(payload)
  1773:    145: 
  1774:    146:     # Generic HTTP webhook
  1775:    147:     url = os.getenv("NOTIFY_URL")
  1776:    148:     if url:
  1777:    149:         try:
  1778:    150:             requests.post(url, json=data, timeout=5)
  1779:    151:         except Exception as exc:  # pragma: no cover - best effort only
  1780:    152:             logging.error("Notification error for %s: %s", event, exc)
  1781:    153: 
  1782:    154:     # Telegram notification
  1783:    155:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  1784:    156:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  1785:    157:     # ``pair_list`` notifications are intentionally not forwarded to Telegram
  1786:    158:     if token and chat_id and event != "pair_list":
  1787:    159:         text = _format_text(event, payload or {})
  1788:    160:         t_url = f"https://api.telegram.org/bot{token}/sendMessage"
  1789:    161:         t_payload = {"chat_id": chat_id, "text": text}
  1790:    162:         try:  # pragma: no cover - network
  1791:    163:             requests.post(t_url, json=t_payload, timeout=5)
  1792:    164:         except Exception as exc:  # pragma: no cover - best effort only
  1793:    165:             logging.error("Telegram notification error for %s: %s", event, exc)
  1794: 
  1795: 
  1796: ## TRASH_20250823-124533/scalper/telegram_bot.py (last modified: 2025-08-23 20:57:14)
  1797:      1: from __future__ import annotations
  1798:      2: 
  1799:      3: import logging
  1800:      4: import os
  1801:      5: from typing import Any, Dict, Optional
  1802:      6: 
  1803:      7: try:  # pragma: no cover - optional dependency
  1804:      8:     import requests as _requests
  1805:      9:     requests = _requests
  1806:     10: except Exception:  # pragma: no cover
  1807:     11:     class _Requests:
  1808:     12:         def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  1809:     13:             raise RuntimeError("requests.get unavailable")
  1810:     14: 
  1811:     15:         def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  1812:     16:             raise RuntimeError("requests.post unavailable")
  1813:     17: 
  1814:     18:     requests = _Requests()  # type: ignore[assignment]
  1815:     19: 
  1816:     20: 
  1817:     21: class TelegramBot:
  1818:     22:     """Minimal Telegram bot using the HTTP API.
  1819:     23: 
  1820:     24: 
  1821:     25:     The bot exposes a simple *menu* based interface with clickable buttons so
  1822:     26:     users do not have to remember text commands.  A sub-menu lets the user set
  1823:     27:     the risk level.
  1824:     28: 
  1825:     29:     """
  1826:     30: 
  1827:     31:     def __init__(
  1828:     32:         self,
  1829:     33:         token: str,
  1830:     34:         chat_id: str,
  1831:     35:         client: Any,
  1832:     36:         config: Dict[str, Any],
  1833:     37:         risk_mgr: Any,
  1834:     38:         *,
  1835:     39:         requests_module: Any = requests,
  1836:     40:     ) -> None:
  1837:     41:         self.token = token
  1838:     42:         self.chat_id = str(chat_id)
  1839:     43:         self.client = client
  1840:     44:         self.config = config
  1841:     45:         self.risk_mgr = risk_mgr
  1842:     46:         self.requests = requests_module
  1843:     47:         self.last_update_id: Optional[int] = None
  1844:     48:         self.stop_requested = False
  1845:     49: 
  1846:     50: 
  1847:     51:         self.main_keyboard = [
  1848:     52:             [{"text": "Positions ouvertes", "callback_data": "positions"}],
  1849:     53:             [{"text": "Update Cryptos", "callback_data": "update"}],
  1850:     54:             [{"text": "Réglages", "callback_data": "settings"}],
  1851:     55:             [{"text": "Arrêt bot", "callback_data": "shutdown"}],
  1852:     56:         ]
  1853:     57:         self.settings_keyboard = [
  1854:     58:             [{"text": "Stop trade", "callback_data": "stop"}],
  1855:     59:             [{"text": "Réglage risk", "callback_data": "risk"}],
  1856:     60:             [{"text": "Nb positions", "callback_data": "maxpos"}],
  1857:     61:             [{"text": "Reset risk", "callback_data": "reset_risk"}],
  1858:     62:             [{"text": "Reset total", "callback_data": "reset_all"}],
  1859:     63:             [{"text": "Retour", "callback_data": "back"}],
  1860:     64:         ]
  1861:     65:         self.risk_keyboard = [
  1862:     66:             [
  1863:     67:                 {"text": "🟢", "callback_data": "risk_green"},
  1864:     68:                 {"text": "🟠", "callback_data": "risk_orange"},
  1865:     69:                 {"text": "🔴", "callback_data": "risk_red"},
  1866:     70:             ],
  1867:     71:             [{"text": "Retour", "callback_data": "back"}],
  1868:     72:         ]
  1869:     73:         self.maxpos_keyboard = [
  1870:     74:             [
  1871:     75:                 {"text": "1", "callback_data": "maxpos_1"},
  1872:     76:                 {"text": "2", "callback_data": "maxpos_2"},
  1873:     77:                 {"text": "3", "callback_data": "maxpos_3"},
  1874:     78:             ],
  1875:     79:             [
  1876:     80:                 {"text": "4", "callback_data": "maxpos_4"},
  1877:     81:                 {"text": "5", "callback_data": "maxpos_5"},
  1878:     82:             ],
  1879:     83:             [{"text": "Retour", "callback_data": "back"}],
  1880:     84:         ]
  1881:     85: 
  1882:     86:         # Show menu on startup with zero PnL session
  1883:     87:         self.send_main_menu(0.0)
  1884:     88: 
  1885:     89: 
  1886:     90:     def _base_symbol(self, symbol: str) -> str:
  1887:     91:         sym = symbol.replace("_", "")
  1888:     92:         return sym[:-4] if sym.endswith("USDT") else sym
  1889:     93: 
  1890:     94:     def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
  1891:     95:         pos = self.client.get_positions() or {}
  1892:     96:         buttons: list[list[Dict[str, str]]] = []
  1893:     97:         for p in pos.get("data") or []:
  1894:     98:             sym = p.get("symbol")
  1895:     99:             if not sym:
  1896:    100:                 continue
  1897:    101:             base = self._base_symbol(sym)
  1898:    102:             # Use the full symbol in the callback so we can properly
  1899:    103:             # identify the position to close.  Only the label shows the
  1900:    104:             # base asset to keep the interface concise.
  1901:    105:             buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
  1902:    106:         buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
  1903:    107:         buttons.append([{"text": "Retour", "callback_data": "back"}])
  1904:    108:         return buttons
  1905:    109: 
  1906:    110: 
  1907:    111:     def _menu_text(self, session_pnl: float) -> str:
  1908:    112:         assets = self.client.get_assets() or {}
  1909:    113:         equity = 0.0
  1910:    114:         for row in assets.get("data") or []:
  1911:    115:             if row.get("currency") == "USDT":
  1912:    116:                 try:
  1913:    117:                     equity = float(row.get("equity", 0.0))
  1914:    118:                 except Exception:
  1915:    119:                     equity = 0.0
  1916:    120:                 break
  1917:    121:         return (
  1918:    122:             f"Solde: {equity:.2f} USDT\n"
  1919:    123:             f"PnL session: {session_pnl:.2f} USDT\n"
  1920:    124:             f"Positions max: {self.risk_mgr.max_positions}\n"
  1921:    125:             f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
  1922:    126:             "Choisissez une option:"
  1923:    127:         )
  1924:    128: 
  1925:    129:     def send_main_menu(self, session_pnl: float) -> None:
  1926:    130:         self.send(self._menu_text(session_pnl), self.main_keyboard)
  1927:    131: 
  1928:    132:     def update_pairs(self) -> None:
  1929:    133:         from bot import update as _update  # lazy import to avoid cycle
  1930:    134:         _update(self.client, top_n=40)
  1931:    135: 
  1932:    136:     # ------------------------------------------------------------------
  1933:    137:     def _api_url(self, method: str) -> str:
  1934:    138:         return f"https://api.telegram.org/bot{self.token}/{method}"
  1935:    139: 
  1936:    140: 
  1937:    141:     def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
  1938:    142:         payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
  1939:    143:         if keyboard:
  1940:    144:             payload["reply_markup"] = {"inline_keyboard": keyboard}
  1941:    145: 
  1942:    146:         try:  # pragma: no cover - network
  1943:    147:             self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
  1944:    148:         except Exception as exc:  # pragma: no cover - best effort
  1945:    149:             logging.error("Telegram send error: %s", exc)
  1946:    150: 
  1947:    151:     def answer_callback(self, cb_id: str) -> None:
  1948:    152:         payload = {"callback_query_id": cb_id}
  1949:    153:         try:  # pragma: no cover - network
  1950:    154:             self.requests.post(
  1951:    155:                 self._api_url("answerCallbackQuery"), json=payload, timeout=5
  1952:    156:             )
  1953:    157:         except Exception as exc:  # pragma: no cover - best effort
  1954:    158:             logging.error("Telegram answerCallback error: %s", exc)
  1955:    159: 
  1956:    160: 
  1957:    161:     # ------------------------------------------------------------------
  1958:    162:     def fetch_updates(self) -> list[Dict[str, Any]]:
  1959:    163:         params: Dict[str, Any] = {}
  1960:    164:         if self.last_update_id is not None:
  1961:    165:             params["offset"] = self.last_update_id + 1
  1962:    166:         try:  # pragma: no cover - network
  1963:    167:             r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
  1964:    168:             r.raise_for_status()
  1965:    169:             data = r.json()
  1966:    170:         except Exception as exc:  # pragma: no cover - best effort
  1967:    171:             logging.error("Telegram getUpdates error: %s", exc)
  1968:    172:             return []
  1969:    173:         updates = data.get("result", [])
  1970:    174:         if updates:
  1971:    175:             self.last_update_id = updates[-1].get("update_id")
  1972:    176:         return updates
  1973:    177: 
  1974:    178:     # ------------------------------------------------------------------
  1975:    179:     def handle_updates(self, session_pnl: float) -> None:
  1976:    180:         for update in self.fetch_updates():
  1977:    181: 
  1978:    182:             callback = update.get("callback_query")
  1979:    183:             if callback:
  1980:    184:                 if str(callback.get("from", {}).get("id")) != self.chat_id:
  1981:    185:                     continue
  1982:    186:                 data = callback.get("data", "")
  1983:    187:                 reply, kb = self.handle_callback(data, session_pnl)
  1984:    188:                 if reply:
  1985:    189:                     self.send(reply, kb)
  1986:    190:                 cb_id = callback.get("id")
  1987:    191:                 if cb_id:
  1988:    192:                     self.answer_callback(cb_id)
  1989:    193:                 continue
  1990:    194: 
  1991:    195: 
  1992:    196:             msg = update.get("message") or {}
  1993:    197:             chat = msg.get("chat") or {}
  1994:    198:             if str(chat.get("id")) != self.chat_id:
  1995:    199:                 continue
  1996:    200: 
  1997:    201:             # Any text message triggers the main menu with balance and PnL
  1998:    202:             self.send_main_menu(session_pnl)
  1999:    203: 
  2000:    204:     # ------------------------------------------------------------------
  2001:    205:     def handle_callback(
  2002:    206:         self, data: str, session_pnl: float
  2003:    207:     ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
  2004:    208:         if not data:
  2005:    209:             return None, None
  2006:    210:         if data == "balance":
  2007:    211:             assets = self.client.get_assets() or {}
  2008:    212:             equity = 0.0
  2009:    213:             for row in assets.get("data") or []:
  2010:    214:                 if row.get("currency") == "USDT":
  2011:    215:                     try:
  2012:    216:                         equity = float(row.get("equity", 0.0))
  2013:    217:                     except Exception:
  2014:    218:                         equity = 0.0
  2015:    219:                     break
  2016:    220: 
  2017:    221:             return f"Solde: {equity:.2f} USDT", self.main_keyboard
  2018:    222:         if data == "positions":
  2019:    223:             pos = self.client.get_positions() or {}
  2020:    224:             lines = []
  2021:    225:             for p in pos.get("data") or []:
  2022:    226:                 symbol = p.get("symbol", "")
  2023:    227:                 base = self._base_symbol(symbol)
  2024:    228:                 side = p.get("side")
  2025:    229:                 vol = p.get("vol")
  2026:    230:                 pnl = p.get("pnl_usdt")
  2027:    231:                 if pnl is None:
  2028:    232:                     pnl = p.get("pnl_usd")
  2029:    233:                 if pnl is None:
  2030:    234:                     pnl = p.get("pnl")
  2031:    235:                 pnl_pct = p.get("pnl_pct_on_margin")
  2032:    236:                 if pnl_pct is None:
  2033:    237:                     pnl_pct = p.get("pnl_pct")
  2034:    238:                 line = f"{base} {side} {vol}"
  2035:    239:                 if pnl is not None and pnl_pct is not None:
  2036:    240:                     line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
  2037:    241:                 lines.append(line)
  2038:    242:             if not lines:
  2039:    243: 
  2040:    244:                 return "Aucune position ouverte", self.main_keyboard
  2041:    245:             return "Positions:\n" + "\n".join(lines), self.main_keyboard
  2042:    246:         if data == "pnl":
  2043:    247:             return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
  2044:    248:         if data == "risk":
  2045:    249:             return "Choisissez le niveau de risque:", self.risk_keyboard
  2046:    250:         if data == "settings":
  2047:    251:             return "Réglages:", self.settings_keyboard
  2048:    252:         if data == "maxpos":
  2049:    253:             return "Choisissez le nombre de positions:", self.maxpos_keyboard
  2050:    254:         if data == "reset_risk":
  2051:    255:             try:
  2052:    256:                 self.risk_mgr.reset_day()
  2053:    257:                 return "Risque réinitialisé", self.settings_keyboard
  2054:    258:             except Exception:
  2055:    259:                 return "Erreur reset risque", self.settings_keyboard
  2056:    260:         if data == "update":
  2057:    261:             try:
  2058:    262:                 self.update_pairs()
  2059:    263:                 return "Liste cryptos mise à jour", self.main_keyboard
  2060:    264:             except Exception:
  2061:    265:                 return "Erreur mise à jour", self.main_keyboard
  2062:    266:         if data.startswith("risk"):
  2063:    267:             mapping = {
  2064:    268:                 "risk_green": 1,
  2065:    269:                 "risk_orange": 2,
  2066:    270:                 "risk_red": 3,
  2067:    271:             }
  2068:    272:             lvl = mapping.get(data)
  2069:    273:             if lvl:
  2070:    274:                 self.config["RISK_LEVEL"] = lvl
  2071:    275:                 return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
  2072:    276:             return "Niveau de risque inchangé", self.main_keyboard
  2073:    277: 
  2074:    278:         if data.startswith("maxpos_"):
  2075:    279:             try:
  2076:    280:                 lvl = int(data.split("_", 1)[1])
  2077:    281:             except Exception:
  2078:    282:                 lvl = None
  2079:    283:             if lvl:
  2080:    284:                 self.config["MAX_POSITIONS"] = lvl
  2081:    285:                 self.risk_mgr.max_positions = lvl
  2082:    286:                 return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
  2083:    287:             return "Nombre de positions inchangé", self.main_keyboard
  2084:    288: 
  2085:    289:         if data == "reset_all":
  2086:    290:             try:
  2087:    291:                 self.client.close_all_positions()
  2088:    292:                 self.risk_mgr.reset_day()
  2089:    293:                 return "Positions et risque réinitialisés", self.settings_keyboard
  2090:    294:             except Exception:
  2091:    295:                 return "Erreur lors du reset total", self.settings_keyboard
  2092:    296: 
  2093:    297:         if data == "stop":
  2094:    298:             pos = self.client.get_positions() or {}
  2095:    299:             if not (pos.get("data") or []):
  2096:    300:                 return "Aucune crypto sélectionnée", self.settings_keyboard
  2097:    301:             return "Choisissez la position à fermer:", self._build_stop_keyboard()
  2098:    302:         if data == "stop_all":
  2099:    303:             try:
  2100:    304:                 self.client.close_all_positions()
  2101:    305:                 return "Toutes les positions fermées", self.settings_keyboard
  2102:    306:             except Exception:
  2103:    307:                 return "Erreur arrêt trade", self.settings_keyboard
  2104:    308:         if data.startswith("stop_"):
  2105:    309:             sym = data[5:]
  2106:    310:             try:
  2107:    311:                 self.client.close_position(sym)
  2108:    312:                 return f"Position {sym} fermée", self.settings_keyboard
  2109:    313:             except Exception:
  2110:    314:                 return f"Erreur arrêt trade {sym}", self.settings_keyboard
  2111:    315: 
  2112:    316:         if data == "shutdown":
  2113:    317:             self.stop_requested = True
  2114:    318:             return "Arrêt du bot demandé", self.main_keyboard
  2115:    319: 
  2116:    320:         if data == "back":
  2117:    321:             return self._menu_text(session_pnl), self.main_keyboard
  2118:    322:         return None, None
  2119:    323: 
  2120:    324: 
  2121:    325: def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
  2122:    326:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  2123:    327:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  2124:    328:     if token and chat_id:
  2125:    329:         return TelegramBot(token, chat_id, client, config, risk_mgr)
  2126:    330:     return None
  2127: 
  2128: 
  2129: ## TRASH_20250823-124533/short_one_way.py (last modified: 2025-08-23 20:57:14)
  2130:      1: #!/usr/bin/env python3
  2131:      2: # -*- coding: utf-8 -*-
  2132:      3: """Example script to open a one-way short on Bitget futures.
  2133:      4: 
  2134:      5: This standalone script signs and sends a market sell order using the
  2135:      6: Bitget REST API. Environment variables required (defined in a `.env`
  2136:      7: file alongside this script):
  2137:      8: 
  2138:      9: - ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
  2139:     10: - ``BITGET_API_KEY``
  2140:     11: - ``BITGET_API_SECRET``
  2141:     12: - ``BITGET_API_PASSPHRASE``
  2142:     13: - ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
  2143:     14: - ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
  2144:     15: - ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
  2145:     16: - ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)
  2146:     17: 
  2147:     18: The script retrieves the current contract specification and price,
  2148:     19: ensures account settings (one-way mode & leverage) and finally places a
  2149:     20: market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.
  2150:     21: 
  2151:     22: The intent is purely demonstrational; use at your own risk.
  2152:     23: """
  2153:     24: 
  2154:     25: import base64
  2155:     26: import hashlib
  2156:     27: import hmac
  2157:     28: import json
  2158:     29: import os
  2159:     30: import sys
  2160:     31: import time
  2161:     32: import uuid
  2162:     33: from pathlib import Path
  2163:     34: 
  2164:     35: import requests
  2165:     36: 
  2166:     37: try:  # lazy dependency import for dotenv
  2167:     38:     from dotenv import load_dotenv
  2168:     39: except ImportError:  # pragma: no cover - installation fallback
  2169:     40:     import subprocess
  2170:     41: 
  2171:     42:     subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
  2172:     43:     from dotenv import load_dotenv
  2173:     44: 
  2174:     45: # load environment variables
  2175:     46: load_dotenv(Path(__file__).resolve().parent / ".env")
  2176:     47: 
  2177:     48: 
  2178:     49: def T(x):  # small helper used throughout configuration
  2179:     50:     return x.strip() if isinstance(x, str) else x
  2180:     51: 
  2181:     52: 
  2182:     53: BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
  2183:     54: AK = T(os.getenv("BITGET_API_KEY"))
  2184:     55: SK = T(os.getenv("BITGET_API_SECRET"))
  2185:     56: PH = T(os.getenv("BITGET_API_PASSPHRASE"))
  2186:     57: PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
  2187:     58: MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
  2188:     59: SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
  2189:     60: NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))
  2190:     61: 
  2191:     62: if not (AK and SK and PH):
  2192:     63:     sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")
  2193:     64: 
  2194:     65: print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")
  2195:     66: 
  2196:     67: 
  2197:     68: # ---------- signing helpers ----------
  2198:     69: def sign_get(ts, path, params):
  2199:     70:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  2200:     71:     pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
  2201:     72:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  2202:     73:     return sig, qs
  2203:     74: 
  2204:     75: 
  2205:     76: def sign_post(ts, path, body, params=None):
  2206:     77:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  2207:     78:     body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
  2208:     79:     pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
  2209:     80:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  2210:     81:     return sig, body_str, qs
  2211:     82: 
  2212:     83: 
  2213:     84: def headers(sig, ts):
  2214:     85:     return {
  2215:     86:         "ACCESS-KEY": AK,
  2216:     87:         "ACCESS-SIGN": sig,
  2217:     88:         "ACCESS-TIMESTAMP": str(ts),
  2218:     89:         "ACCESS-PASSPHRASE": PH,
  2219:     90:         "ACCESS-RECV-WINDOW": "60000",
  2220:     91:         "Content-Type": "application/json",
  2221:     92:     }
  2222:     93: 
  2223:     94: 
  2224:     95: def pick_price(d: dict):
  2225:     96:     for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
  2226:     97:         try:
  2227:     98:             v = float(d.get(k))
  2228:     99:             if v > 0:
  2229:    100:                 return v
  2230:    101:         except Exception:
  2231:    102:             pass
  2232:    103:     return None
  2233:    104: 
  2234:    105: 
  2235:    106: # ---------- public endpoints ----------
  2236:    107: def get_contract_spec():
  2237:    108:     r = requests.get(
  2238:    109:         f"{BASE}/api/v2/mix/market/contracts",
  2239:    110:         params={"productType": PT, "symbol": SYMB},
  2240:    111:         timeout=12,
  2241:    112:     )
  2242:    113:     r.raise_for_status()
  2243:    114:     arr = r.json().get("data") or []
  2244:    115:     if not arr:
  2245:    116:         raise RuntimeError("Contrat introuvable")
  2246:    117:     return arr[0]
  2247:    118: 
  2248:    119: 
  2249:    120: def get_price():
  2250:    121:     # 1) ticker (obj/list) avec productType
  2251:    122:     try:
  2252:    123:         r = requests.get(
  2253:    124:             f"{BASE}/api/v2/mix/market/ticker",
  2254:    125:             params={"symbol": SYMB, "productType": PT},
  2255:    126:             timeout=10,
  2256:    127:         )
  2257:    128:         r.raise_for_status()
  2258:    129:         data = r.json().get("data")
  2259:    130:         if isinstance(data, dict):
  2260:    131:             p = pick_price(data)
  2261:    132:             if p:
  2262:    133:                 return p
  2263:    134:         if isinstance(data, list) and data:
  2264:    135:             p = pick_price(data[0])
  2265:    136:             if p:
  2266:    137:                 return p
  2267:    138:     except requests.HTTPError as e:
  2268:    139:         print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
  2269:    140:     except Exception as e:
  2270:    141:         print("⚠️ ticker err:", e)
  2271:    142: 
  2272:    143:     # 2) tickers (liste entière)
  2273:    144:     try:
  2274:    145:         r = requests.get(
  2275:    146:             f"{BASE}/api/v2/mix/market/tickers",
  2276:    147:             params={"productType": PT},
  2277:    148:             timeout=10,
  2278:    149:         )
  2279:    150:         r.raise_for_status()
  2280:    151:         arr = r.json().get("data") or []
  2281:    152:         row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
  2282:    153:         p = pick_price(row or {})
  2283:    154:         if p:
  2284:    155:             return p
  2285:    156:     except requests.HTTPError as e:
  2286:    157:         print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
  2287:    158:     except Exception as e:
  2288:    159:         print("⚠️ tickers err:", e)
  2289:    160: 
  2290:    161:     # 3) candles 1m (close)
  2291:    162:     try:
  2292:    163:         # ``symbol`` must be provided as a query parameter; placing it in the
  2293:    164:         # path triggers a 404 response from Bitget.
  2294:    165:         r = requests.get(
  2295:    166:             f"{BASE}/api/v2/mix/market/candles",
  2296:    167:             params={"symbol": SYMB, "granularity": "1m"},
  2297:    168:             timeout=10,
  2298:    169:         )
  2299:    170:         r.raise_for_status()
  2300:    171:         arr = r.json().get("data") or []
  2301:    172:         if arr:
  2302:    173:             return float(arr[0][4])
  2303:    174:     except requests.HTTPError as e:
  2304:    175:         print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
  2305:    176:     except Exception as e:
  2306:    177:         print("⚠️ candles err:", e)
  2307:    178: 
  2308:    179:     raise RuntimeError("prix indisponible")
  2309:    180: 
  2310:    181: 
  2311:    182: # ---------- private endpoints ----------
  2312:    183: def check_accounts():
  2313:    184:     path = "/api/v2/mix/account/accounts"
  2314:    185:     ts = int(time.time() * 1000)
  2315:    186:     params = {"productType": PT}
  2316:    187:     sig, qs = sign_get(ts, path, params)
  2317:    188:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2318:    189:     r = requests.get(url, headers=headers(sig, ts), timeout=12)
  2319:    190:     print("accounts", r.status_code, r.text[:160])
  2320:    191:     r.raise_for_status()
  2321:    192:     j = r.json()
  2322:    193:     if str(j.get("code")) not in ("00000", "0"):
  2323:    194:         raise RuntimeError(j)
  2324:    195: 
  2325:    196: 
  2326:    197: def set_position_mode_one_way():
  2327:    198:     path = "/api/v2/mix/account/set-position-mode"
  2328:    199:     ts = int(time.time() * 1000)
  2329:    200:     body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
  2330:    201:     sig, b, qs = sign_post(ts, path, body)
  2331:    202:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2332:    203:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  2333:    204:     print("set-position-mode(one-way)", r.status_code, r.text[:160])
  2334:    205:     r.raise_for_status()
  2335:    206: 
  2336:    207: 
  2337:    208: def set_leverage(lv: int = 2):
  2338:    209:     path = "/api/v2/mix/account/set-leverage"
  2339:    210:     ts = int(time.time() * 1000)
  2340:    211:     body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
  2341:    212:     sig, b, qs = sign_post(ts, path, body)
  2342:    213:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2343:    214:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  2344:    215:     print("set-leverage", r.status_code, r.text[:160])
  2345:    216:     r.raise_for_status()
  2346:    217: 
  2347:    218: 
  2348:    219: def place_one_way_sell(size_coin: float):
  2349:    220:     """Ouvre un SHORT en one_way_mode (market SELL)."""
  2350:    221:     path = "/api/v2/mix/order/place-order"
  2351:    222:     ts = int(time.time() * 1000)
  2352:    223:     body = {
  2353:    224:         "symbol": SYMB,
  2354:    225:         "productType": PT,
  2355:    226:         "marginCoin": MC,
  2356:    227:         "marginMode": "crossed",
  2357:    228:         "posMode": "one_way_mode",
  2358:    229:         "orderType": "market",
  2359:    230:         "side": "sell",  # <-- SHORT
  2360:    231:         "size": str(size_coin),
  2361:    232:         "timeInForceValue": "normal",
  2362:    233:         "clientOid": str(uuid.uuid4())[:32],
  2363:    234:     }
  2364:    235:     sig, b, qs = sign_post(ts, path, body)
  2365:    236:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  2366:    237:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
  2367:    238:     print("place-order(one-way SELL)", r.status_code, r.text[:220])
  2368:    239:     r.raise_for_status()
  2369:    240:     j = r.json()
  2370:    241:     if str(j.get("code")) not in ("00000", "0"):
  2371:    242:         raise RuntimeError(j)
  2372:    243:     return j
  2373:    244: 
  2374:    245: 
  2375:    246: # ---------- main ----------
  2376:    247: def main():
  2377:    248:     spec = get_contract_spec()
  2378:    249:     min_usdt = float(spec.get("minTradeUSDT") or 5)
  2379:    250:     min_num = float(spec.get("minTradeNum") or 0)
  2380:    251:     size_place = int(spec.get("sizePlace") or 6)
  2381:    252:     print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")
  2382:    253: 
  2383:    254:     px = get_price()
  2384:    255:     print(f"Prix OK ≈ {px}")
  2385:    256: 
  2386:    257:     check_accounts()
  2387:    258:     set_position_mode_one_way()
  2388:    259:     set_leverage(2)
  2389:    260: 
  2390:    261:     target = max(NOTIONAL, min_usdt)
  2391:    262:     size = max(target / px, min_num)
  2392:    263:     size = float(f"{size:.{size_place}f}")
  2393:    264:     print(f"Taille={size} (target≈{target}USDT)")
  2394:    265: 
  2395:    266:     j = place_one_way_sell(size)
  2396:    267:     print("✅ SHORT OK")
  2397:    268:     print(json.dumps(j, indent=2, ensure_ascii=False))
  2398:    269: 
  2399:    270: 
  2400:    271: if __name__ == "__main__":  # pragma: no cover - script entrypoint
  2401:    272:     main()
  2402: 
  2403: 
  2404: ## bot.py (last modified: 2025-08-24 03:12:00)
  2405:      1: # bot.py
  2406:      2: from __future__ import annotations
  2407:      3: 
  2408:      4: import asyncio
  2409:      5: import os
  2410:      6: import sys
  2411:      7: import json
  2412:      8: from dataclasses import dataclass
  2413:      9: from pathlib import Path
  2414:     10: from typing import Sequence, Optional
  2415:     11: 
  2416:     12: # --- utils ---
  2417:     13: 
  2418:     14: def ensure_ccxt() -> None:
  2419:     15:     try:
  2420:     16:         import ccxt  # noqa: F401
  2421:     17:     except ImportError:
  2422:     18:         import subprocess
  2423:     19:         print("[setup] ccxt manquant, installation…")
  2424:     20:         subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "ccxt"])
  2425:     21:         import ccxt  # noqa: F401
  2426:     22: 
  2427:     23: def getenv(name: str, default: str = "") -> str:
  2428:     24:     """Lit d’abord les variables d’environnement, sinon .env local s’il existe."""
  2429:     25:     val = os.environ.get(name)
  2430:     26:     if val is not None:
  2431:     27:         return val
  2432:     28:     dot = Path(".env")
  2433:     29:     if dot.exists():
  2434:     30:         for line in dot.read_text().splitlines():
  2435:     31:             line = line.strip()
  2436:     32:             if not line or line.startswith("#") or "=" not in line:
  2437:     33:                 continue
  2438:     34:             k, v = line.split("=", 1)
  2439:     35:             if k == name:
  2440:     36:                 return v
  2441:     37:     return default
  2442:     38: 
  2443:     39: # --- config ---
  2444:     40: 
  2445:     41: @dataclass
  2446:     42: class RunConfig:
  2447:     43:     symbols: Sequence[str]
  2448:     44:     live_tf: str
  2449:     45:     data_dir: Path
  2450:     46:     csv_min_rows: int = 200           # seuil minimal d’un CSV “ok”
  2451:     47:     ready_flag: Path = Path("scalp/.ready.json")
  2452:     48: 
  2453:     49: # --- notifier (Telegram ou Null) ---
  2454:     50: 
  2455:     51: class NullNotifier:
  2456:     52:     async def send(self, msg: str) -> None:
  2457:     53:         print(f"[notify:null] {msg}")
  2458:     54: 
  2459:     55: async def build_notifier_and_commands() -> tuple[object, object]:
  2460:     56:     """Retourne (notifier, command_stream). Ici soit Telegram, soit Null."""
  2461:     57:     bot_token = getenv("TELEGRAM_BOT_TOKEN")
  2462:     58:     chat_id   = getenv("TELEGRAM_CHAT_ID")
  2463:     59:     if bot_token and chat_id:
  2464:     60:         # Implémentation simple via httpx/aiohttp → pour garder le fichier autonome, on renvoie un proxy minimal.
  2465:     61:         class TelegramNotifier:
  2466:     62:             def __init__(self, token: str, chat: str):
  2467:     63:                 self.token = token
  2468:     64:                 self.chat  = chat
  2469:     65:             async def send(self, msg: str) -> None:
  2470:     66:                 # en mode simple: on n’échoue pas si Telegram refuse le markdown
  2471:     67:                 import aiohttp
  2472:     68:                 url = f"https://api.telegram.org/bot{self.token}/sendMessage"
  2473:     69:                 payload = {"chat_id": self.chat, "text": msg, "disable_web_page_preview": True, "parse_mode": "Markdown"}
  2474:     70:                 try:
  2475:     71:                     async with aiohttp.ClientSession() as sess:
  2476:     72:                         async with sess.post(url, json=payload, timeout=15) as r:
  2477:     73:                             if r.status >= 400:
  2478:     74:                                 txt = await r.text()
  2479:     75:                                 print(f"[notify:telegram] send fail {r.status}: {txt[:180]}")
  2480:     76:                 except Exception as e:
  2481:     77:                     print(f"[notify:telegram] send error: {e}")
  2482:     78: 
  2483:     79:         notifier = TelegramNotifier(bot_token, chat_id)
  2484:     80:         # Pas de commandes interactives dans cette version : on renvoie un stream “nul”
  2485:     81:         return notifier, None
  2486:     82:     else:
  2487:     83:         print("[notify] TELEGRAM non configuré → Null notifier.")
  2488:     84:         return NullNotifier(), None
  2489:     85: 
  2490:     86: # --- préchauffage cache CSV ---
  2491:     87: 
  2492:     88: def csv_ok(p: Path, min_rows: int) -> bool:
  2493:     89:     if not p.exists():
  2494:     90:         return False
  2495:     91:     try:
  2496:     92:         # compte rapide des lignes
  2497:     93:         n = sum(1 for _ in p.open("r", encoding="utf-8", errors="ignore"))
  2498:     94:         return n >= min_rows
  2499:     95:     except Exception:
  2500:     96:         return False
  2501:     97: 
  2502:     98: async def prewarm_cache(cfg: RunConfig) -> None:
  2503:     99:     cfg.data_dir.mkdir(parents=True, exist_ok=True)
  2504:    100:     ok = True
  2505:    101:     for sym in cfg.symbols:
  2506:    102:         csv = cfg.data_dir / f"{sym}-{cfg.live_tf}.csv"
  2507:    103:         if csv_ok(csv, cfg.csv_min_rows):
  2508:    104:             print(f"[cache] ready -> {csv.relative_to(Path.cwd())}")
  2509:    105:         else:
  2510:    106:             ok = False
  2511:    107:             print(f"[cache] MISSING for {sym} -> {csv.relative_to(Path.cwd())}")
  2512:    108:     # ici on ne fetch pas pour rester autonome ; tu as déjà so.py si besoin
  2513:    109: 
  2514:    110: # --- orchestrateur glue ---
  2515:    111: 
  2516:    112: # ⛔️ ADAPTE CE CHEMIN SI TON WRAPPER N’EST PAS ICI
  2517:    113: # ex: from scalper.services.market import BitgetExchange
  2518:    114: from scalper.exchanges.bitget import BitgetExchange  # <-- ajuste ce chemin si besoin
  2519:    115: 
  2520:    116: async def run_orchestrator(exchange, cfg: RunConfig, notifier, command_stream=None):
  2521:    117:     """
  2522:    118:     Adapte-toi à la signature de ton vrai orchestrateur si tu en utilises un.
  2523:    119:     Ici on illustre une boucle “heartbeat + ticks_total” minimale.
  2524:    120:     """
  2525:    121:     ticks_total = 0
  2526:    122:     await notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  2527:    123:     try:
  2528:    124:         while True:
  2529:    125:             await asyncio.sleep(30)
  2530:    126:             await notifier.send(f"[stats] ticks_total={ticks_total} (+0 /30s) | pairs={','.join(cfg.symbols)}")
  2531:    127:     except asyncio.CancelledError:
  2532:    128:         await notifier.send("🛑 Arrêt orchestrateur.")
  2533:    129:         raise
  2534:    130: 
  2535:    131: # --- setup + ready flag ---
  2536:    132: 
  2537:    133: def write_ready_flag(cfg: RunConfig, reason: str = "ok") -> None:
  2538:    134:     cfg.ready_flag.parent.mkdir(parents=True, exist_ok=True)
  2539:    135:     cfg.ready_flag.write_text(json.dumps({"status": "ok", "reason": reason}, ensure_ascii=False, indent=2))
  2540:    136: 
  2541:    137: def is_ready(cfg: RunConfig) -> bool:
  2542:    138:     return cfg.ready_flag.exists()
  2543:    139: 
  2544:    140: async def setup_once(cfg: RunConfig, notifier) -> None:
  2545:    141:     await prewarm_cache(cfg)
  2546:    142:     await notifier.send("Setup wizard terminé (cache vérifié).")
  2547:    143:     write_ready_flag(cfg, "cache verified")
  2548:    144: 
  2549:    145: # --- lance l’orchestrateur avec shim .symbols/.timeframe ---
  2550:    146: 
  2551:    147: async def launch_orchestrator(cfg: RunConfig):
  2552:    148:     notifier, command_stream = await build_notifier_and_commands()
  2553:    149: 
  2554:    150:     # Setup si nécessaire
  2555:    151:     if not is_ready(cfg):
  2556:    152:         await notifier.send("Setup requis → exécution…")
  2557:    153:         await setup_once(cfg, notifier)
  2558:    154:         await notifier.send(f"[setup] flag écrit -> {cfg.ready_flag}")
  2559:    155: 
  2560:    156:     # Crée l’exchange
  2561:    157:     ex = BitgetExchange(
  2562:    158:         api_key=getenv("BITGET_ACCESS"),
  2563:    159:         secret=getenv("BITGET_SECRET"),
  2564:    160:         password=getenv("BITGET_PASSPHRASE"),
  2565:    161:         data_dir=str(cfg.data_dir),
  2566:    162:         use_cache=True,
  2567:    163:         spot=True,
  2568:    164:     )
  2569:    165: 
  2570:    166:     # --- SHIM IMPORTANT : certains orchestrateurs lisent exchange.symbols / exchange.timeframe
  2571:    167:     if not hasattr(ex, "symbols"):
  2572:    168:         setattr(ex, "symbols", tuple(cfg.symbols))
  2573:    169:     if not hasattr(ex, "timeframe"):
  2574:    170:         setattr(ex, "timeframe", cfg.live_tf)
  2575:    171: 
  2576:    172:     # Démarre l’orchestrateur (remplace par ton vrai import/runner si tu en as un)
  2577:    173:     await run_orchestrator(ex, cfg, notifier, command_stream)
  2578:    174: 
  2579:    175: # --- main ---
  2580:    176: 
  2581:    177: async def main():
  2582:    178:     ensure_ccxt()
  2583:    179:     symbols = (
  2584:    180:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  2585:    181:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  2586:    182:     )
  2587:    183:     cfg = RunConfig(
  2588:    184:         symbols=symbols,
  2589:    185:         live_tf="5m",
  2590:    186:         data_dir=Path("scalp/data"),
  2591:    187:     )
  2592:    188:     await launch_orchestrator(cfg)
  2593:    189: 
  2594:    190: if __name__ == "__main__":
  2595:    191:     try:
  2596:    192:         asyncio.run(main())
  2597:    193:     except KeyboardInterrupt:
  2598:    194:         pass
  2599: 
  2600: ## cli.py (last modified: 2025-08-23 20:57:14)
  2601:      1: """Command line utilities for the Scalp project.
  2602:      2: 
  2603:      3: This module exposes a small command line interface used throughout the
  2604:      4: project.  The actual trading logic lives in other modules, however the CLI is
  2605:      5: responsible for parsing parameters and dispatching the appropriate routines.
  2606:      6: 
  2607:      7: The implementation intentionally keeps the invoked functions minimal so that
  2608:      8: tests can patch them easily.  In a real deployment these functions would
  2609:      9: perform optimisation, walk‑forward analysis or run the live pipeline.
  2610:     10: """
  2611:     11: 
  2612:     12: from __future__ import annotations
  2613:     13: 
  2614:     14: import argparse
  2615:     15: import asyncio
  2616:     16: from typing import Iterable, List
  2617:     17: 
  2618:     18: from scalper.version import bump_version_from_git
  2619:     19: 
  2620:     20: 
  2621:     21: # ---------------------------------------------------------------------------
  2622:     22: # Placeholder implementations
  2623:     23: # ---------------------------------------------------------------------------
  2624:     24: 
  2625:     25: 
  2626:     26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
  2627:     27:     """Run a parallel parameter optimisation.
  2628:     28: 
  2629:     29:     The real project dispatches a potentially heavy optimisation routine.  The
  2630:     30:     function is kept trivial so unit tests can verify that the CLI wiring works
  2631:     31:     without actually performing the optimisation.
  2632:     32:     """
  2633:     33: 
  2634:     34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
  2635:     35: 
  2636:     36: 
  2637:     37: def run_walkforward_analysis(
  2638:     38:     pair: str, timeframe: str, splits: int, train_ratio: float
  2639:     39: ) -> None:
  2640:     40:     """Execute a walk-forward analysis."""
  2641:     41: 
  2642:     42:     print(
  2643:     43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
  2644:     44:     )
  2645:     45: 
  2646:     46: 
  2647:     47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
  2648:     48:     """Run the live trading pipeline."""
  2649:     49: 
  2650:     50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
  2651:     51: 
  2652:     52: 
  2653:     53: # ---------------------------------------------------------------------------
  2654:     54: # Argument parsing
  2655:     55: # ---------------------------------------------------------------------------
  2656:     56: 
  2657:     57: 
  2658:     58: def create_parser() -> argparse.ArgumentParser:
  2659:     59:     """Create the top-level argument parser."""
  2660:     60: 
  2661:     61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
  2662:     62:     sub = parser.add_subparsers(dest="command")
  2663:     63: 
  2664:     64:     # --- ``opt`` command -------------------------------------------------
  2665:     65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
  2666:     66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  2667:     67:     opt_p.add_argument("--tf", required=True, help="timeframe")
  2668:     68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
  2669:     69:     opt_p.set_defaults(
  2670:     70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
  2671:     71:     )
  2672:     72: 
  2673:     73:     # --- ``walkforward`` command ----------------------------------------
  2674:     74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
  2675:     75:     wf_p.add_argument("--pair", required=True, help="trading pair")
  2676:     76:     wf_p.add_argument("--tf", required=True, help="timeframe")
  2677:     77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
  2678:     78:     wf_p.add_argument(
  2679:     79:         "--train-ratio",
  2680:     80:         type=float,
  2681:     81:         default=0.7,
  2682:     82:         help="portion of data used for training",
  2683:     83:     )
  2684:     84:     wf_p.set_defaults(
  2685:     85:         func=lambda a: run_walkforward_analysis(
  2686:     86:             a.pair, a.tf, a.splits, a.train_ratio
  2687:     87:         )
  2688:     88:     )
  2689:     89: 
  2690:     90:     # --- ``live`` command -----------------------------------------------
  2691:     91:     live_p = sub.add_parser("live", help="run the live async pipeline")
  2692:     92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  2693:     93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
  2694:     94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
  2695:     95: 
  2696:     96:     # --- ``bump-version`` command -------------------------------------
  2697:     97:     bv_p = sub.add_parser(
  2698:     98:         "bump-version",
  2699:     99:         help="update the VERSION file based on the latest git commit",
  2700:    100:     )
  2701:    101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
  2702:    102: 
  2703:    103:     return parser
  2704:    104: 
  2705:    105: 
  2706:    106: def main(argv: Iterable[str] | None = None) -> int:
  2707:    107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
  2708:    108: 
  2709:    109:     parser = create_parser()
  2710:    110:     args = parser.parse_args(argv)
  2711:    111:     if not hasattr(args, "func"):
  2712:    112:         parser.print_help()
  2713:    113:         return 0
  2714:    114:     result = args.func(args)
  2715:    115:     return 0 if result is None else int(result)
  2716:    116: 
  2717:    117: 
  2718:    118: if __name__ == "__main__":  # pragma: no cover - manual invocation
  2719:    119:     raise SystemExit(main())
  2720:    120: 
  2721: 
  2722: 
  2723: ## data/BTCUSDT-1m.csv (last modified: 2025-08-23 20:57:14)
  2724:      1: ts,open,high,low,close,volume
  2725:      2: 1625097600000,34000,34100,33950,34050,123.4
  2726:      3: 1625097660000,34050,34200,34000,34150,150.7
  2727:      4: 1625097720000,34150,34300,34100,34250,180.3
  2728:      5: 1625097780000,34250,34400,34200,34350,200.1
  2729:      6: 1625097840000,34350,34500,34300,34450,220.8
  2730: 
  2731: ## data/__init__.py (last modified: 2025-08-23 20:57:14)
  2732:      1: """Indicator computation helpers."""
  2733:      2: 
  2734:      3: from .indicators import compute_all
  2735:      4: 
  2736:      5: __all__ = ["compute_all"]
  2737: 
  2738: 
  2739: ## data/indicators.py (last modified: 2025-08-23 20:57:14)
  2740:      1: import pandas as pd
  2741:      2: 
  2742:      3: __all__ = ["compute_all"]
  2743:      4: 
  2744:      5: def compute_all(
  2745:      6:     df: pd.DataFrame,
  2746:      7:     *,
  2747:      8:     ema_fast: int = 20,
  2748:      9:     ema_slow: int = 50,
  2749:     10:     rsi_period: int = 14,
  2750:     11:     macd_fast: int = 12,
  2751:     12:     macd_slow: int = 26,
  2752:     13:     macd_signal: int = 9,
  2753:     14:     atr_period: int = 14,
  2754:     15:     swing_lookback: int = 5,
  2755:     16: ) -> pd.DataFrame:
  2756:     17:     """Compute common indicators and return enriched DataFrame.
  2757:     18: 
  2758:     19:     Parameters
  2759:     20:     ----------
  2760:     21:     df : pd.DataFrame
  2761:     22:         DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
  2762:     23:         ``volume`` columns ordered chronologically.
  2763:     24: 
  2764:     25:     Returns
  2765:     26:     -------
  2766:     27:     pd.DataFrame
  2767:     28:         New DataFrame with additional indicator columns.
  2768:     29:     """
  2769:     30: 
  2770:     31:     if df.empty:
  2771:     32:         return df.copy()
  2772:     33: 
  2773:     34:     df = df.copy()
  2774:     35: 
  2775:     36:     # --- VWAP ---------------------------------------------------------------
  2776:     37:     typical = (df["high"] + df["low"] + df["close"]) / 3.0
  2777:     38:     vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
  2778:     39:     df["vwap"] = vwap
  2779:     40: 
  2780:     41:     # --- EMAs ---------------------------------------------------------------
  2781:     42:     df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
  2782:     43:     df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()
  2783:     44: 
  2784:     45:     # --- RSI ----------------------------------------------------------------
  2785:     46:     delta = df["close"].diff()
  2786:     47:     gain = delta.where(delta > 0, 0.0)
  2787:     48:     loss = -delta.where(delta < 0, 0.0)
  2788:     49:     avg_gain = gain.rolling(rsi_period).mean()
  2789:     50:     avg_loss = loss.rolling(rsi_period).mean()
  2790:     51:     rs = avg_gain / avg_loss
  2791:     52:     rsi = 100 - (100 / (1 + rs))
  2792:     53:     df["rsi"] = rsi.fillna(50.0)
  2793:     54: 
  2794:     55:     # --- MACD ---------------------------------------------------------------
  2795:     56:     ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
  2796:     57:     ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
  2797:     58:     macd = ema_fast_series - ema_slow_series
  2798:     59:     signal = macd.ewm(span=macd_signal, adjust=False).mean()
  2799:     60:     df["macd"] = macd
  2800:     61:     df["macd_signal"] = signal
  2801:     62:     df["macd_hist"] = macd - signal
  2802:     63: 
  2803:     64:     # --- OBV ----------------------------------------------------------------
  2804:     65:     obv = [0.0]
  2805:     66:     closes = df["close"].tolist()
  2806:     67:     vols = df["volume"].tolist()
  2807:     68:     for i in range(1, len(df)):
  2808:     69:         if closes[i] > closes[i - 1]:
  2809:     70:             obv.append(obv[-1] + vols[i])
  2810:     71:         elif closes[i] < closes[i - 1]:
  2811:     72:             obv.append(obv[-1] - vols[i])
  2812:     73:         else:
  2813:     74:             obv.append(obv[-1])
  2814:     75:     df["obv"] = obv
  2815:     76: 
  2816:     77:     # --- ATR ----------------------------------------------------------------
  2817:     78:     high_low = df["high"] - df["low"]
  2818:     79:     high_close = (df["high"] - df["close"].shift()).abs()
  2819:     80:     low_close = (df["low"] - df["close"].shift()).abs()
  2820:     81:     tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
  2821:     82:     df["atr"] = tr.rolling(atr_period).mean()
  2822:     83: 
  2823:     84:     # --- Swing highs/lows ---------------------------------------------------
  2824:     85:     df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
  2825:     86:     df["swing_low"] = df["low"].rolling(window=swing_lookback).min()
  2826:     87: 
  2827:     88:     return df
  2828: 
  2829: 
  2830: ## init.py (last modified: 2025-08-23 20:57:14)
  2831:      1: #!/usr/bin/env python3
  2832:      2: """Install all project dependencies.
  2833:      3: 
  2834:      4: Run this script once to install every ``requirements*.txt`` file found in the
  2835:      5: repository as well as the packages needed for the test suite.  All subsequent
  2836:      6: invocations of the bot or its submodules will then share the same Python
  2837:      7: environment with the required dependencies available.
  2838:      8: """
  2839:      9: 
  2840:     10: from __future__ import annotations
  2841:     11: 
  2842:     12: import subprocess
  2843:     13: import sys
  2844:     14: from pathlib import Path
  2845:     15: 
  2846:     16: 
  2847:     17: def install_packages(*args: str) -> None:
  2848:     18:     """Install packages using pip for the current Python interpreter."""
  2849:     19:     cmd = [sys.executable, "-m", "pip", "install", *args]
  2850:     20:     subprocess.check_call(cmd)
  2851:     21: 
  2852:     22: 
  2853:     23: def main() -> None:
  2854:     24:     repo_root = Path(__file__).resolve().parent
  2855:     25: 
  2856:     26:     # Install from any requirements*.txt file across the repository so that
  2857:     27:     # sub-packages with their own dependency lists are also covered.
  2858:     28:     for req in sorted(repo_root.rglob("requirements*.txt")):
  2859:     29:         install_packages("-r", str(req))
  2860:     30: 
  2861:     31:     # Ensure test dependencies are available
  2862:     32:     install_packages("pytest")
  2863:     33: 
  2864:     34: 
  2865:     35: if __name__ == "__main__":
  2866:     36:     main()
  2867: 
  2868: 
  2869: ## pytest.ini (last modified: 2025-08-23 20:57:14)
  2870:      1: [pytest]
  2871:      2: addopts = -q
  2872: 
  2873: 
  2874: ## requirements-dev.txt (last modified: 2025-08-23 20:57:14)
  2875:      1: pytest
  2876: 
  2877: 
  2878: ## requirements.txt (last modified: 2025-08-23 20:57:14)
  2879:      1: requests
  2880:      2: python-dotenv
  2881:      3: pydantic==1.10.15 ; python_version < "3.11"
  2882:      4: 
  2883:      5: # pydantic v1 déjà pin si environnement ancien
  2884:      6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)
  2885: 
  2886: 
  2887: ## scalper/VERSION (last modified: 2025-08-23 20:57:14)
  2888:      1: 0.3.0
  2889:      2: 
  2890: 
  2891: 
  2892: ## scalper/__init__.py (last modified: 2025-08-23 20:57:14)
  2893:      1: """Utilities and helpers for Scalp bot.
  2894:      2: 
  2895:      3: When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
  2896:      4: keys to live in ``notebook/.env``.  On import this module attempts to load the
  2897:      5: variables from that file so that API keys can remain outside of the repository
  2898:      6: yet still be available at runtime.
  2899:      7: """
  2900:      8: 
  2901:      9: from __future__ import annotations
  2902:     10: 
  2903:     11: import os
  2904:     12: from pathlib import Path
  2905:     13: import sys
  2906:     14: 
  2907:     15: 
  2908:     16: def _load_parent_env() -> None:
  2909:     17:     """Load environment variables from ``../.env`` relative to the entry script.
  2910:     18: 
  2911:     19:     The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
  2912:     20:     are expected to be stored one directory above (``notebook/.env``).  If that
  2913:     21:     file is not found the function falls back to the historical behaviour of
  2914:     22:     checking ``../.env`` relative to the package itself.
  2915:     23:     """
  2916:     24: 
  2917:     25:     script_path = Path(sys.argv[0]).resolve()
  2918:     26:     env_file = script_path.parent.parent / ".env"
  2919:     27:     if not env_file.exists():
  2920:     28:         env_file = Path(__file__).resolve().parents[2] / ".env"
  2921:     29:         if not env_file.exists():
  2922:     30:             return
  2923:     31: 
  2924:     32:     try:
  2925:     33:         from dotenv import load_dotenv
  2926:     34: 
  2927:     35:         load_dotenv(env_file)
  2928:     36:     except Exception:  # pragma: no cover - optional dependency
  2929:     37:         for line in env_file.read_text().splitlines():
  2930:     38:             line = line.strip()
  2931:     39:             if not line or line.startswith("#") or "=" not in line:
  2932:     40:                 continue
  2933:     41:             key, value = line.split("=", 1)
  2934:     42:             os.environ.setdefault(key.strip(), value.strip().strip("'\""))
  2935:     43: 
  2936:     44: 
  2937:     45: _load_parent_env()
  2938:     46: 
  2939:     47: from .version import get_version, bump_version_from_message  # noqa: E402
  2940:     48: from .strategy import (  # noqa: E402
  2941:     49:     Signal,
  2942:     50:     scan_pairs,
  2943:     51:     select_active_pairs,
  2944:     52:     generate_signal,
  2945:     53:     backtest,
  2946:     54: )
  2947:     55: from .risk.manager import RiskManager  # noqa: E402
  2948:     56: 
  2949:     57: __all__ = [
  2950:     58:     "get_version",
  2951:     59:     "bump_version_from_message",
  2952:     60:     "__version__",
  2953:     61:     "Signal",
  2954:     62:     "scan_pairs",
  2955:     63:     "select_active_pairs",
  2956:     64:     "generate_signal",
  2957:     65:     "RiskManager",
  2958:     66:     "backtest",
  2959:     67: ]
  2960:     68: 
  2961:     69: __version__ = get_version()
  2962: 
  2963: 
  2964: ## scalper/adapters/__init__.py (last modified: 2025-08-23 20:57:14)
  2965: 
  2966: 
  2967: ## scalper/adapters/bitget.py (last modified: 2025-08-23 20:57:14)
  2968:      1: # scalp/adapters/bitget.py
  2969:      2: from __future__ import annotations
  2970:      3: from typing import Any, Dict, List, Optional
  2971:      4: import inspect, os
  2972:      5: import requests
  2973:      6: 
  2974:      7: # Client bas-niveau fourni par le repo
  2975:      8: from scalper.bitget_client import BitgetFuturesClient as _Base
  2976:      9: 
  2977:     10: 
  2978:     11: def _to_float(x, default: float = 0.0) -> float:
  2979:     12:     try:
  2980:     13:         return float(x)
  2981:     14:     except Exception:
  2982:     15:         return default
  2983:     16: 
  2984:     17: 
  2985:     18: def _select_base_url() -> str:
  2986:     19:     env = os.environ.get("BITGET_BASE_URL")
  2987:     20:     if env:
  2988:     21:         return env
  2989:     22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
  2990:     23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
  2991:     24: 
  2992:     25: 
  2993:     26: class BitgetFuturesClient(_Base):
  2994:     27:     """
  2995:     28:     Adaptateur Bitget:
  2996:     29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
  2997:     30:       - Normalisations robustes: assets, ticker(s), positions, fills
  2998:     31:     """
  2999:     32: 
  3000:     33:     # --------------------- INIT dynamique ---------------------
  3001:     34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
  3002:     35:         """
  3003:     36:         Accepte indifféremment:
  3004:     37:           api_key/apiKey/access_key/accessKey/key
  3005:     38:           api_secret/apiSecret/secret/secret_key/secretKey
  3006:     39:           passphrase/password/api_passphrase/apiPassphrase
  3007:     40:           base_url/baseUrl/host/endpoint (ou auto)
  3008:     41:         On n'envoie au client de base que les noms présents dans sa signature.
  3009:     42:         """
  3010:     43:         user_kwargs = dict(kwargs)
  3011:     44: 
  3012:     45:         # Collecte des valeurs possibles (tous alias)
  3013:     46:         incoming_key = (
  3014:     47:             user_kwargs.pop("api_key", None)
  3015:     48:             or user_kwargs.pop("apiKey", None)
  3016:     49:             or user_kwargs.pop("access_key", None)
  3017:     50:             or user_kwargs.pop("accessKey", None)
  3018:     51:             or user_kwargs.pop("key", None)
  3019:     52:             or user_kwargs.pop("API_KEY", None)
  3020:     53:         )
  3021:     54:         incoming_secret = (
  3022:     55:             user_kwargs.pop("api_secret", None)
  3023:     56:             or user_kwargs.pop("apiSecret", None)
  3024:     57:             or user_kwargs.pop("secret_key", None)
  3025:     58:             or user_kwargs.pop("secretKey", None)
  3026:     59:             or user_kwargs.pop("secret", None)
  3027:     60:             or user_kwargs.pop("API_SECRET", None)
  3028:     61:         )
  3029:     62:         incoming_pass = (
  3030:     63:             user_kwargs.pop("passphrase", None)
  3031:     64:             or user_kwargs.pop("password", None)
  3032:     65:             or user_kwargs.pop("api_passphrase", None)
  3033:     66:             or user_kwargs.pop("apiPassphrase", None)
  3034:     67:         )
  3035:     68:         incoming_base = (
  3036:     69:             user_kwargs.pop("base_url", None)
  3037:     70:             or user_kwargs.pop("baseUrl", None)
  3038:     71:             or user_kwargs.pop("host", None)
  3039:     72:             or user_kwargs.pop("endpoint", None)
  3040:     73:             or _select_base_url()
  3041:     74:         )
  3042:     75: 
  3043:     76:         # Signature réelle du client bas-niveau
  3044:     77:         sig = inspect.signature(_Base.__init__)
  3045:     78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
  3046:     79: 
  3047:     80:         def pick_name(cands: List[str]) -> Optional[str]:
  3048:     81:             for c in cands:
  3049:     82:                 if c in param_names:
  3050:     83:                     return c
  3051:     84:             return None
  3052:     85: 
  3053:     86:         # Noms réellement supportés
  3054:     87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
  3055:     88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
  3056:     89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
  3057:     90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
  3058:     91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
  3059:     92: 
  3060:     93:         # Construire kwargs à transmettre (une seule fois par nom)
  3061:     94:         base_kwargs: Dict[str, Any] = {}
  3062:     95:         if key_name and incoming_key is not None:
  3063:     96:             base_kwargs[key_name] = incoming_key
  3064:     97:         if sec_name and incoming_secret is not None:
  3065:     98:             base_kwargs[sec_name] = incoming_secret
  3066:     99:         if pas_name and incoming_pass is not None:
  3067:    100:             base_kwargs[pas_name] = incoming_pass
  3068:    101:         if base_name:
  3069:    102:             base_kwargs[base_name] = incoming_base
  3070:    103:         if req_mod_name:
  3071:    104:             base_kwargs[req_mod_name] = requests
  3072:    105: 
  3073:    106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
  3074:    107:         # qui n'a pas été défini ci-dessus, on le relaie.
  3075:    108:         for k, v in list(user_kwargs.items()):
  3076:    109:             if k in param_names and k not in base_kwargs:
  3077:    110:                 base_kwargs[k] = v
  3078:    111: 
  3079:    112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
  3080:    113:         super().__init__(**base_kwargs)
  3081:    114: 
  3082:    115:     # --------------------- COMPTES / ASSETS ---------------------
  3083:    116:     def get_assets(self) -> Dict[str, Any]:
  3084:    117:         raw = super().get_assets()
  3085:    118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
  3086:    119:         norm: List[Dict[str, Any]] = []
  3087:    120:         for a in data:
  3088:    121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
  3089:    122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
  3090:    123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
  3091:    124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
  3092:    125:         return {"success": True, "data": norm}
  3093:    126: 
  3094:    127:     # ------------------------ TICKER(S) -------------------------
  3095:    128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  3096:    129:         """
  3097:    130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
  3098:    131:         Tolère top-level dict/list et items dict/list.
  3099:    132:         """
  3100:    133:         try:
  3101:    134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
  3102:    135:         except Exception as e:
  3103:    136:             return {"success": False, "error": repr(e), "data": []}
  3104:    137: 
  3105:    138:         items: List[Any] = []
  3106:    139:         if isinstance(raw, dict):
  3107:    140:             d = raw.get("data")
  3108:    141:             if symbol and isinstance(d, dict):
  3109:    142:                 items = [d]
  3110:    143:             else:
  3111:    144:                 items = d or raw.get("result") or raw.get("tickers") or []
  3112:    145:         elif isinstance(raw, (list, tuple)):
  3113:    146:             items = list(raw)
  3114:    147: 
  3115:    148:         norm: List[Dict[str, Any]] = []
  3116:    149:         for t in items:
  3117:    150:             if isinstance(t, dict):
  3118:    151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
  3119:    152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
  3120:    153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
  3121:    154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
  3122:    155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
  3123:    156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
  3124:    157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
  3125:    158:                 norm.append({
  3126:    159:                     "symbol": s,
  3127:    160:                     "lastPrice": _to_float(last_),
  3128:    161:                     "bidPrice": _to_float(bid_),
  3129:    162:                     "askPrice": _to_float(ask_),
  3130:    163:                     "volume": volume
  3131:    164:                 })
  3132:    165:             else:
  3133:    166:                 seq = list(t)
  3134:    167:                 if len(seq) >= 5:
  3135:    168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
  3136:    169:                     if first_ts:
  3137:    170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
  3138:    171:                     else:
  3139:    172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
  3140:    173:                 else:
  3141:    174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
  3142:    175:                 s = (symbol or "").replace("_", "")
  3143:    176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
  3144:    177: 
  3145:    178:         return {"success": True, "data": norm}
  3146:    179: 
  3147:    180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
  3148:    181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  3149:    182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
  3150:    183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
  3151:    184:         out: List[Dict[str, Any]] = []
  3152:    185:         for p in items:
  3153:    186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
  3154:    187:             if symbol and s != symbol:
  3155:    188:                 continue
  3156:    189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
  3157:    190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
  3158:    191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
  3159:    192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
  3160:    193:         return {"success": True, "data": out}
  3161:    194: 
  3162:    195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
  3163:    196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
  3164:    197:         items = raw.get("data") or raw.get("result") or []
  3165:    198:         out: List[Dict[str, Any]] = []
  3166:    199:         for f in items[:limit]:
  3167:    200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
  3168:    201:             if s != symbol:
  3169:    202:                 continue
  3170:    203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
  3171:    204:                 continue
  3172:    205:             out.append({
  3173:    206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
  3174:    207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
  3175:    208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
  3176:    209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
  3177:    210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
  3178:    211:                 "ts": int(f.get("ts", f.get("time", 0))),
  3179:    212:             })
  3180:    213:         return {"success": True, "data": out}
  3181:    214: 
  3182:    215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
  3183:    216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
  3184:    217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
  3185:    218:         return {"success": ok, "data": {"orderId": order_id}}
  3186: 
  3187: ## scalper/adapters/bitget_fetch.py (last modified: 2025-08-23 20:57:14)
  3188:      1: # scalper/adapters/bitget_fetch.py
  3189:      2: from __future__ import annotations
  3190:      3: 
  3191:      4: import asyncio
  3192:      5: import inspect
  3193:      6: import os
  3194:      7: from typing import Any, Optional
  3195:      8: 
  3196:      9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  3197:     10: 
  3198:     11: def _log(msg: str) -> None:
  3199:     12:     if BT_DEBUG:
  3200:     13:         print(f"[bt.debug] {msg}", flush=True)
  3201:     14: 
  3202:     15: _TF_TO_SECS = {
  3203:     16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  3204:     17:     "1h": 3600, "4h": 14400, "1d": 86400,
  3205:     18: }
  3206:     19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
  3207:     20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  3208:     21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
  3209:     22: }
  3210:     23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
  3211:     24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  3212:     25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
  3213:     26: }
  3214:     27: 
  3215:     28: def _await_if_needed(val: Any) -> Any:
  3216:     29:     if inspect.isawaitable(val):
  3217:     30:         try:
  3218:     31:             asyncio.get_running_loop()
  3219:     32:         except RuntimeError:
  3220:     33:             return asyncio.run(val)
  3221:     34:         else:
  3222:     35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
  3223:     36:             return fut.result()
  3224:     37:     return val
  3225:     38: 
  3226:     39: class BitgetFetchAdapter:
  3227:     40:     """
  3228:     41:     Adaptateur qui fournit une méthode CCXT-like:
  3229:     42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
  3230:     43:     au-dessus d'un client Bitget existant (sync ou async).
  3231:     44:     """
  3232:     45:     def __init__(self, client: Any, *, market_hint: str | None = None):
  3233:     46:         self.client = client
  3234:     47:         self.market_hint = (market_hint or "").lower() or None
  3235:     48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
  3236:     49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
  3237:     50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
  3238:     51: 
  3239:     52:     @staticmethod
  3240:     53:     def _possible_methods(client: Any) -> list[str]:
  3241:     54:         names = dir(client)
  3242:     55:         base = [
  3243:     56:             "fetch_ohlcv",
  3244:     57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
  3245:     58:             "klines", "get_klines", "kline",
  3246:     59:             "mix_get_candles", "mix_candles",
  3247:     60:             "spot_get_candles", "spot_candles",
  3248:     61:             "market_candles", "public_candles",
  3249:     62:         ]
  3250:     63:         # + heuristique: tout ce qui contient candle/kline
  3251:     64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
  3252:     65:         out = []
  3253:     66:         for n in base + extra:
  3254:     67:             if n in names and callable(getattr(client, n)) and n not in out:
  3255:     68:                 out.append(n)
  3256:     69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
  3257:     70:         return out
  3258:     71: 
  3259:     72:     @staticmethod
  3260:     73:     def _sym_variants(sym: str) -> list[str]:
  3261:     74:         s = sym.upper()
  3262:     75:         out = [s]
  3263:     76:         if not s.endswith("_UMCBL"):
  3264:     77:             out.append(f"{s}_UMCBL")
  3265:     78:         if not s.endswith("_SPBL"):
  3266:     79:             out.append(f"{s}_SPBL")
  3267:     80:         _log(f"Variantes symbole testées: {out}")
  3268:     81:         return out
  3269:     82: 
  3270:     83:     @staticmethod
  3271:     84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
  3272:     85:         secs = _TF_TO_SECS.get(timeframe, 300)
  3273:     86:         mix = _TF_TO_MIX.get(timeframe, "5min")
  3274:     87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
  3275:     88:         variants = []
  3276:     89:         if market_hint == "mix":
  3277:     90:             variants.append({"granularity": mix})
  3278:     91:         if market_hint == "spot":
  3279:     92:             variants.append({"period": spot})
  3280:     93:         variants += [
  3281:     94:             {"timeframe": timeframe},
  3282:     95:             {"interval": timeframe},
  3283:     96:             {"k": secs},
  3284:     97:             {"granularity": mix},
  3285:     98:             {"period": spot},
  3286:     99:         ]
  3287:    100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
  3288:    101:         return variants
  3289:    102: 
  3290:    103:     @staticmethod
  3291:    104:     def _normalize_rows(raw: Any) -> list[list[float]]:
  3292:    105:         import pandas as pd  # local import
  3293:    106:         if raw is None:
  3294:    107:             raise ValueError("OHLCV vide")
  3295:    108:         if isinstance(raw, dict) and "data" in raw:
  3296:    109:             raw = raw["data"]
  3297:    110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
  3298:    111:             out = []
  3299:    112:             for r in raw:
  3300:    113:                 ts = int(str(r[0]))
  3301:    114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
  3302:    115:                 out.append([ts, o, h, l, c, v])
  3303:    116:             return out
  3304:    117:         if "pandas" in str(type(raw)):
  3305:    118:             df = raw
  3306:    119:             if "timestamp" in df.columns:
  3307:    120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  3308:    121:                 df = df.set_index("timestamp").sort_index()
  3309:    122:             df = df[["open", "high", "low", "close", "volume"]]
  3310:    123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
  3311:    124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
  3312:    125: 
  3313:    126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
  3314:    127:         methods = self._possible_methods(self.client)
  3315:    128:         if not methods:
  3316:    129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
  3317:    130: 
  3318:    131:         last_err: Exception | None = None
  3319:    132:         for mname in methods:
  3320:    133:             fn = getattr(self.client, mname)
  3321:    134:             for sym in self._sym_variants(symbol):
  3322:    135:                 for par in self._param_variants(timeframe, self.market_hint):
  3323:    136:                     kwargs = dict(par)
  3324:    137:                     kwargs.setdefault("symbol", sym)
  3325:    138:                     kwargs.setdefault("limit", limit)
  3326:    139:                     if since is not None:
  3327:    140:                         kwargs.setdefault("since", since)
  3328:    141:                     try:
  3329:    142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
  3330:    143:                         res = _await_if_needed(fn(**kwargs))
  3331:    144:                         rows = self._normalize_rows(res)
  3332:    145:                         if rows:
  3333:    146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
  3334:    147:                             first = rows[0][0]; last = rows[-1][0]
  3335:    148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
  3336:    149:                                  f"t0={first} {unit}, t1={last} {unit}")
  3337:    150:                             return rows
  3338:    151:                     except TypeError as e:
  3339:    152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
  3340:    153:                         last_err = e
  3341:    154:                     except Exception as e:
  3342:    155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
  3343:    156:                         last_err = e
  3344:    157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
  3345:    158: 
  3346:    159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
  3347:    160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
  3348:    161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
  3349:    162:         _log("exchange.fetch_ohlcv() déjà présent.")
  3350:    163:         return exchange
  3351:    164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
  3352:    165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)
  3353: 
  3354: ## scalper/adapters/market_data.py (last modified: 2025-08-23 20:57:14)
  3355:      1: # scalper/backtest/market_data.py
  3356:      2: from __future__ import annotations
  3357:      3: 
  3358:      4: import os
  3359:      5: from pathlib import Path
  3360:      6: from typing import Any
  3361:      7: 
  3362:      8: import pandas as pd
  3363:      9: 
  3364:     10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  3365:     11: 
  3366:     12: def _log(msg: str) -> None:
  3367:     13:     if BT_DEBUG:
  3368:     14:         print(f"[bt.debug] {msg}", flush=True)
  3369:     15: 
  3370:     16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
  3371:     17:     root = Path(data_dir)
  3372:     18:     root.mkdir(parents=True, exist_ok=True)
  3373:     19:     tf = timeframe.replace(":", "")
  3374:     20:     return root / f"{symbol}-{tf}.csv"
  3375:     21: 
  3376:     22: def _read_csv(path: Path) -> pd.DataFrame:
  3377:     23:     _log(f"lecture CSV: {path}")
  3378:     24:     df = pd.read_csv(path)
  3379:     25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
  3380:     26:     if ts_col is None:
  3381:     27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
  3382:     28:     df = df.rename(columns={ts_col: "timestamp"})
  3383:     29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  3384:     30:     df = df.set_index("timestamp").sort_index()
  3385:     31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  3386:     32:     return df
  3387:     33: 
  3388:     34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  3389:     35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
  3390:     36:     if "timestamp" not in tmp.columns:
  3391:     37:         tmp = tmp.rename(columns={"index": "timestamp"})
  3392:     38:     tmp.to_csv(path, index=False)
  3393:     39:     _log(f"écrit CSV: {path} (n={len(df)})")
  3394:     40: 
  3395:     41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  3396:     42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
  3397:     43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
  3398:     44:     # Normalisation minimaliste (liste de listes)
  3399:     45:     rows = []
  3400:     46:     for r in raw:
  3401:     47:         ts = int(r[0])
  3402:     48:         unit = "ms" if ts > 10_000_000_000 else "s"
  3403:     49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
  3404:     50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
  3405:     51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
  3406:     52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  3407:     53:     return df
  3408:     54: 
  3409:     55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
  3410:     56:     """
  3411:     57:     Loader hybride:
  3412:     58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
  3413:     59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
  3414:     60:     """
  3415:     61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  3416:     62:         path = _csv_path(data_dir, symbol, timeframe)
  3417:     63:         if path.exists():
  3418:     64:             df = _read_csv(path)
  3419:     65:             src = "csv"
  3420:     66:         else:
  3421:     67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
  3422:     68:             _write_csv(path, df)
  3423:     69:             src = "exchange"
  3424:     70:         if start:
  3425:     71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  3426:     72:         if end:
  3427:     73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  3428:     74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
  3429:     75:              f"range=[{df.index.min()} .. {df.index.max()}]")
  3430:     76:         return df
  3431:     77:     return load
  3432: 
  3433: ## scalper/backtest/__init__.py (last modified: 2025-08-23 20:57:14)
  3434:      1: # scalper/backtest/__init__.py
  3435:      2: from .runner import (
  3436:      3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
  3437:      4:     run_multi, run_single,  # mêmes signatures async
  3438:      5:     save_results,           # no-op compat
  3439:      6: )
  3440:      7: from .cache import (
  3441:      8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
  3442:      9:     tf_to_seconds,
  3443:     10: )
  3444: 
  3445: ## scalper/backtest/cache.py (last modified: 2025-08-23 20:57:14)
  3446:      1: # scalper/backtest/cache.py
  3447:      2: from __future__ import annotations
  3448:      3: 
  3449:      4: import csv
  3450:      5: import json
  3451:      6: import os
  3452:      7: import time
  3453:      8: from dataclasses import dataclass
  3454:      9: from pathlib import Path
  3455:     10: from typing import Dict, List, Tuple, Iterable, Optional
  3456:     11: 
  3457:     12: # ---------------- Timeframe utils ----------------
  3458:     13: 
  3459:     14: _TF_SECONDS = {
  3460:     15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  3461:     16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
  3462:     17:     "1d": 86400, "3d": 259200, "1w": 604800,
  3463:     18: }
  3464:     19: 
  3465:     20: def tf_to_seconds(tf: str) -> int:
  3466:     21:     tf = tf.strip().lower()
  3467:     22:     if tf not in _TF_SECONDS:
  3468:     23:         raise ValueError(f"Timeframe inconnu: {tf}")
  3469:     24:     return _TF_SECONDS[tf]
  3470:     25: 
  3471:     26: # ---------------- Fraîcheur cible par TF ----------------
  3472:     27: 
  3473:     28: _DEFAULT_MAX_AGE = {
  3474:     29:     # règle empirique (peut être surchargée par ENV)
  3475:     30:     "1m": 2 * 3600,        # 2h
  3476:     31:     "3m": 4 * 3600,        # 4h
  3477:     32:     "5m": 12 * 3600,       # 12h
  3478:     33:     "15m": 24 * 3600,      # 24h
  3479:     34:     "30m": 36 * 3600,      # 36h
  3480:     35:     "1h": 3 * 86400,       # 3 jours
  3481:     36:     "2h": 5 * 86400,       # 5 jours
  3482:     37:     "4h": 10 * 86400,      # 10 jours
  3483:     38:     "6h": 15 * 86400,      # 15 jours
  3484:     39:     "12h": 20 * 86400,     # 20 jours
  3485:     40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
  3486:     41:     "3d": 10 * 86400,
  3487:     42:     "1w": 30 * 86400,
  3488:     43: }
  3489:     44: 
  3490:     45: def max_age_for_tf(tf: str) -> int:
  3491:     46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
  3492:     47:     tf = tf.lower()
  3493:     48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
  3494:     49:     if env_key in os.environ:
  3495:     50:         try:
  3496:     51:             return int(os.environ[env_key])
  3497:     52:         except Exception:
  3498:     53:             pass
  3499:     54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
  3500:     55: 
  3501:     56: # ---------------- CSV I/O ----------------
  3502:     57: 
  3503:     58: def data_dir() -> Path:
  3504:     59:     d = Path(os.getenv("DATA_DIR", "data"))
  3505:     60:     d.mkdir(parents=True, exist_ok=True)
  3506:     61:     return d
  3507:     62: 
  3508:     63: def csv_path(symbol: str, tf: str) -> Path:
  3509:     64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
  3510:     65: 
  3511:     66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
  3512:     67:     out: List[List[float]] = []
  3513:     68:     if not path.exists():
  3514:     69:         return out
  3515:     70:     with path.open("r", newline="") as f:
  3516:     71:         r = csv.reader(f)
  3517:     72:         header = next(r, None)
  3518:     73:         for row in r:
  3519:     74:             # columns: timestamp,open,high,low,close,volume
  3520:     75:             try:
  3521:     76:                 ts, o, h, l, c, v = row[:6]
  3522:     77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
  3523:     78:             except Exception:
  3524:     79:                 continue
  3525:     80:     return out
  3526:     81: 
  3527:     82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
  3528:     83:     new_file = not path.exists()
  3529:     84:     with path.open("w", newline="") as f:
  3530:     85:         w = csv.writer(f)
  3531:     86:         w.writerow(["timestamp","open","high","low","close","volume"])
  3532:     87:         for r in rows:
  3533:     88:             w.writerow(r)
  3534:     89: 
  3535:     90: # ---------------- Validation / Chargement / Fetch ----------------
  3536:     91: 
  3537:     92: @dataclass
  3538:     93: class CacheInfo:
  3539:     94:     symbol: str
  3540:     95:     tf: str
  3541:     96:     path: Path
  3542:     97:     exists: bool
  3543:     98:     fresh: bool
  3544:     99:     last_ts: Optional[int] = None
  3545:    100:     rows: int = 0
  3546:    101: 
  3547:    102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
  3548:    103:     if not last_ts:
  3549:    104:         return False
  3550:    105:     age = int(time.time()) - int(last_ts / 1000)
  3551:    106:     return age <= max_age_for_tf(tf)
  3552:    107: 
  3553:    108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
  3554:    109:     p = csv_path(symbol, tf)
  3555:    110:     if not p.exists():
  3556:    111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
  3557:    112:     rows = read_csv_ohlcv(p)
  3558:    113:     last_ts = rows[-1][0] if rows else None
  3559:    114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
  3560:    115: 
  3561:    116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
  3562:    117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
  3563:    118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
  3564:    119: 
  3565:    120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
  3566:    121:     info = inspect_csv(symbol, tf)
  3567:    122:     if info.exists and info.fresh:
  3568:    123:         data = read_csv_ohlcv(info.path)
  3569:    124:         return info, data
  3570:    125: 
  3571:    126:     # fetch & persist
  3572:    127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
  3573:    128:     if data:
  3574:    129:         write_csv_ohlcv(info.path, data)
  3575:    130:         info = inspect_csv(symbol, tf)  # refresh stats
  3576:    131:     return info, data
  3577:    132: 
  3578:    133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
  3579:    134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
  3580:    135:     out: Dict[str, List[List[float]]] = {}
  3581:    136:     for s in symbols:
  3582:    137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
  3583:    138:         out[s] = rows
  3584:    139:     return out
  3585:    140: 
  3586:    141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
  3587:    142:     report = []
  3588:    143:     for s in symbols:
  3589:    144:         info = inspect_csv(s, tf)
  3590:    145:         report.append({
  3591:    146:             "symbol": s,
  3592:    147:             "tf": tf,
  3593:    148:             "path": str(info.path),
  3594:    149:             "exists": info.exists,
  3595:    150:             "fresh": info.fresh,
  3596:    151:             "last_ts": info.last_ts,
  3597:    152:             "rows": info.rows,
  3598:    153:             "max_age": max_age_for_tf(tf),
  3599:    154:         })
  3600:    155:     out_path.parent.mkdir(parents=True, exist_ok=True)
  3601:    156:     out_path.write_text(json.dumps(report, indent=2))
  3602: 
  3603: ## scalper/backtest/cli.py (last modified: 2025-08-23 20:57:14)
  3604:      1: from __future__ import annotations
  3605:      2: 
  3606:      3: import argparse
  3607:      4: from scalper.backtest.runner import run_multi, csv_loader_factory
  3608:      5: 
  3609:      6: def create_parser() -> argparse.ArgumentParser:
  3610:      7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
  3611:      8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
  3612:      9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
  3613:     10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
  3614:     11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
  3615:     12:     p.add_argument("--cash", type=float, default=10_000.0)
  3616:     13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
  3617:     14:     p.add_argument("--slippage-bps", type=float, default=1.5)
  3618:     15:     return p
  3619:     16: 
  3620:     17: def main(argv: list[str] | None = None) -> int:
  3621:     18:     p = create_parser()
  3622:     19:     a = p.parse_args(argv)
  3623:     20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
  3624:     21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
  3625:     22:     loader = csv_loader_factory(a.data_dir)
  3626:     23:     run_multi(
  3627:     24:         symbols=symbols,
  3628:     25:         timeframes=tfs,
  3629:     26:         loader=loader,
  3630:     27:         out_dir=a.out_dir,
  3631:     28:         initial_cash=a.cash,
  3632:     29:         risk_pct=a.risk,
  3633:     30:         slippage_bps=a.slippage_bps,
  3634:     31:     )
  3635:     32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
  3636:     33:     return 0
  3637:     34: 
  3638:     35: if __name__ == "__main__":
  3639:     36:     raise SystemExit(main())
  3640: 
  3641: ## scalper/backtest/engine.py (last modified: 2025-08-23 20:57:14)
  3642:      1: # scalper/backtest/engine.py
  3643:      2: from __future__ import annotations
  3644:      3: 
  3645:      4: import math
  3646:      5: from dataclasses import dataclass, asdict
  3647:      6: from typing import Callable, Dict, List, Optional, Tuple
  3648:      7: 
  3649:      8: import pandas as pd
  3650:      9: 
  3651:     10: from scalper.strategy import generate_signal
  3652:     11: from scalper.trade_utils import compute_position_size
  3653:     12: from scalper.exchange.fees import get_fee
  3654:     13: 
  3655:     14: OHLCVLoader = Callable[[str, str, Optional[str], Optional[str]], pd.DataFrame]
  3656:     15: 
  3657:     16: 
  3658:     17: @dataclass
  3659:     18: class Fill:
  3660:     19:     ts: pd.Timestamp
  3661:     20:     symbol: str
  3662:     21:     side: str       # "long" | "short" | "flat"
  3663:     22:     price: float
  3664:     23:     qty: float
  3665:     24:     fee: float
  3666:     25:     reason: str     # "entry"|"tp"|"sl"|"exit"|"reverse"|"final_exit"
  3667:     26: 
  3668:     27: 
  3669:     28: @dataclass
  3670:     29: class Trade:
  3671:     30:     symbol: str
  3672:     31:     side: str
  3673:     32:     entry_ts: pd.Timestamp
  3674:     33:     entry_px: float
  3675:     34:     qty: float
  3676:     35:     exit_ts: pd.Timestamp
  3677:     36:     exit_px: float
  3678:     37:     fee_entry: float
  3679:     38:     fee_exit: float
  3680:     39:     pnl: float
  3681:     40:     pnl_pct: float
  3682:     41: 
  3683:     42: 
  3684:     43: @dataclass
  3685:     44: class EquityPoint:
  3686:     45:     ts: pd.Timestamp
  3687:     46:     equity: float
  3688:     47: 
  3689:     48: 
  3690:     49: def _apply_slippage(price: float, side: str, slippage_bps: float) -> float:
  3691:     50:     if slippage_bps <= 0:
  3692:     51:         return price
  3693:     52:     mult = 1.0 + (slippage_bps / 10_000.0)
  3694:     53:     return price * (mult if side in ("buy", "long") else 1.0 / mult)
  3695:     54: 
  3696:     55: 
  3697:     56: def _hit_tp_sl(row: pd.Series, side: str, tp: float, sl: float) -> Tuple[bool, str, float]:
  3698:     57:     high, low, close = float(row.high), float(row.low), float(row.close)
  3699:     58:     if side == "long":
  3700:     59:         if low <= sl <= high:
  3701:     60:             return True, "sl", sl
  3702:     61:         if low <= tp <= high:
  3703:     62:             return True, "tp", tp
  3704:     63:         return False, "", close
  3705:     64:     else:
  3706:     65:         if low <= tp <= high:
  3707:     66:             return True, "tp", tp
  3708:     67:         if low <= sl <= high:
  3709:     68:             return True, "sl", sl
  3710:     69:         return False, "", close
  3711:     70: 
  3712:     71: 
  3713:     72: def run_single(
  3714:     73:     *,
  3715:     74:     symbol: str,
  3716:     75:     timeframe: str,
  3717:     76:     loader: OHLCVLoader,
  3718:     77:     start: str | None = None,
  3719:     78:     end: str | None = None,
  3720:     79:     initial_cash: float = 10_000.0,
  3721:     80:     risk_pct: float = 0.005,
  3722:     81:     slippage_bps: float = 1.5,
  3723:     82:     taker: bool = True,
  3724:     83:     quiet: bool = True,
  3725:     84: ) -> Dict[str, object]:
  3726:     85:     df = loader(symbol, timeframe, start, end).copy()
  3727:     86:     if df.empty:
  3728:     87:         raise ValueError(f"Pas de données pour {symbol} {timeframe}")
  3729:     88:     df.columns = [c.lower() for c in df.columns]
  3730:     89:     for c in ("open", "high", "low", "close", "volume"):
  3731:     90:         if c not in df.columns:
  3732:     91:             raise ValueError(f"OHLCV invalide: colonne {c} manquante")
  3733:     92: 
  3734:     93:     fee_rate = get_fee(symbol, "taker" if taker else "maker")
  3735:     94: 
  3736:     95:     equity = float(initial_cash)
  3737:     96:     pos_side: str = "flat"
  3738:     97:     pos_qty: float = 0.0
  3739:     98:     entry_px: float = 0.0
  3740:     99:     fee_entry: float = 0.0
  3741:    100:     sl: float = math.nan
  3742:    101:     tp: float = math.nan
  3743:    102: 
  3744:    103:     eq: List[EquityPoint] = []
  3745:    104:     fills: List[Fill] = []
  3746:    105:     closed: List[Trade] = []
  3747:    106: 
  3748:    107:     for ts, row in df.iterrows():
  3749:    108:         ts = pd.Timestamp(ts)
  3750:    109: 
  3751:    110:         # gérer SL/TP quand en position
  3752:    111:         if pos_side in ("long", "short"):
  3753:    112:             hit, reason, exec_px = _hit_tp_sl(row, pos_side, tp, sl)
  3754:    113:             if hit:
  3755:    114:                 px = _apply_slippage(exec_px, "sell" if pos_side == "long" else "buy", slippage_bps)
  3756:    115:                 fee = abs(px * pos_qty) * fee_rate
  3757:    116:                 pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  3758:    117:                 equity += pnl - fee
  3759:    118:                 fills.append(Fill(ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, reason))
  3760:    119:                 closed.append(
  3761:    120:                     Trade(
  3762:    121:                         symbol=symbol, side=pos_side, entry_ts=ts, entry_px=entry_px, qty=pos_qty,
  3763:    122:                         exit_ts=ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  3764:    123:                         pnl=pnl - fee_entry - fee,
  3765:    124:                         pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  3766:    125:                     )
  3767:    126:                 )
  3768:    127:                 pos_side, pos_qty, entry_px, sl, tp, fee_entry = "flat", 0.0, 0.0, math.nan, math.nan, 0.0
  3769:    128: 
  3770:    129:         # signal de la stratégie live
  3771:    130:         sig = generate_signal(
  3772:    131:             symbol=symbol,
  3773:    132:             ohlcv=df.loc[:ts].tail(300),
  3774:    133:             equity=equity,
  3775:    134:             risk_pct=risk_pct,
  3776:    135:         )
  3777:    136:         if sig and getattr(sig, "side", None) and pos_side == "flat":
  3778:    137:             side = sig.side  # "long"|"short"
  3779:    138:             px = _apply_slippage(float(sig.price), "buy" if side == "long" else "sell", slippage_bps)
  3780:    139:             qty = float(getattr(sig, "qty", 0.0)) or compute_position_size(equity, px, risk_pct, symbol=symbol)
  3781:    140:             if qty > 0:
  3782:    141:                 fee = abs(px * qty) * fee_rate
  3783:    142:                 pos_side, pos_qty, entry_px = side, qty, px
  3784:    143:                 sl = float(getattr(sig, "sl", px * (0.995 if side == "long" else 1.005)))
  3785:    144:                 tp = float(getattr(sig, "tp", getattr(sig, "tp1", px * (1.005 if side == "long" else 0.995))))
  3786:    145:                 fee_entry = fee
  3787:    146:                 equity -= fee
  3788:    147:                 fills.append(Fill(ts, symbol, side, px, qty if side == "long" else -qty, fee, "entry"))
  3789:    148: 
  3790:    149:         eq.append(EquityPoint(ts, equity))
  3791:    150: 
  3792:    151:     # sortie forcée fin de série
  3793:    152:     if pos_side in ("long", "short"):
  3794:    153:         last_ts = pd.Timestamp(df.index[-1])
  3795:    154:         px = _apply_slippage(float(df["close"].iloc[-1]), "sell" if pos_side == "long" else "buy", slippage_bps)
  3796:    155:         fee = abs(px * pos_qty) * fee_rate
  3797:    156:         pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  3798:    157:         equity += pnl - fee
  3799:    158:         fills.append(Fill(last_ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, "final_exit"))
  3800:    159:         closed.append(
  3801:    160:             Trade(
  3802:    161:                 symbol=symbol, side=pos_side, entry_ts=last_ts, entry_px=entry_px, qty=pos_qty,
  3803:    162:                 exit_ts=last_ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  3804:    163:                 pnl=pnl - fee_entry - fee, pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  3805:    164:             )
  3806:    165:         )
  3807:    166: 
  3808:    167:     eq_df = pd.DataFrame([asdict(e) for e in eq])
  3809:    168:     tr_df = pd.DataFrame([asdict(t) for t in closed])
  3810:    169:     fills_df = pd.DataFrame([asdict(f) for f in fills])
  3811:    170: 
  3812:    171:     metrics = {
  3813:    172:         "symbol": symbol,
  3814:    173:         "timeframe": timeframe,
  3815:    174:         "initial_cash": initial_cash,
  3816:    175:         "final_equity": float(eq_df["equity"].iloc[-1] if not eq_df.empty else initial_cash),
  3817:    176:         "return_pct": float(((eq_df["equity"].iloc[-1] / initial_cash) - 1.0) * 100.0 if initial_cash and not eq_df.empty else 0.0),
  3818:    177:         "n_trades": int(len(tr_df)),
  3819:    178:         "win_rate_pct": float((tr_df["pnl"] > 0).mean() * 100.0) if not tr_df.empty else 0.0,
  3820:    179:         "avg_trade_pnl": float(tr_df["pnl"].mean()) if not tr_df.empty else 0.0,
  3821:    180:         "max_dd_pct": float(((eq_df["equity"].cummax() - eq_df["equity"]) / eq_df["equity"].cummax()).max() * 100.0) if not eq_df.empty else 0.0,
  3822:    181:     }
  3823:    182: 
  3824:    183:     return {"equity_curve": eq_df, "trades": tr_df, "fills": fills_df, "metrics": metrics}
  3825: 
  3826: ## scalper/backtest/grid_search.py (last modified: 2025-08-23 20:57:14)
  3827:      1: """Grid-search express module to evaluate hyperparameter combinations.
  3828:      2: 
  3829:      3: This module builds combinations of strategy and engine parameters, runs the
  3830:      4: existing multi symbol backtester for each combination, collects key metrics and
  3831:      5: selects the best configuration according to:
  3832:      6: 
  3833:      7: 1. Profit factor (descending)
  3834:      8: 2. Maximum drawdown percentage (ascending)
  3835:      9: 3. Net PnL in USDT (descending)
  3836:     10: 4. Number of trades (ascending)
  3837:     11: 
  3838:     12: Results are written under ``result/grid`` by default and a short summary is
  3839:     13: printed to the console.
  3840:     14: """
  3841:     15: from __future__ import annotations
  3842:     16: 
  3843:     17: from dataclasses import dataclass
  3844:     18: import csv
  3845:     19: import json
  3846:     20: import os
  3847:     21: import random
  3848:     22: from itertools import product
  3849:     23: from typing import Any, Callable, Dict, Iterable, List, Sequence
  3850:     24: 
  3851:     25: # ---------------------------------------------------------------------------
  3852:     26: # Utilities
  3853:     27: # ---------------------------------------------------------------------------
  3854:     28: 
  3855:     29: 
  3856:     30: def parse_hours(hours: str) -> List[int]:
  3857:     31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
  3858:     32: 
  3859:     33:     Each comma separated element can either be a single hour (``"8"``) or a
  3860:     34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
  3861:     35:     """
  3862:     36: 
  3863:     37:     if not hours:
  3864:     38:         return []
  3865:     39:     result: List[int] = []
  3866:     40:     for part in hours.split(","):
  3867:     41:         part = part.strip()
  3868:     42:         if not part:
  3869:     43:             continue
  3870:     44:         if "-" in part:
  3871:     45:             start_s, end_s = part.split("-", 1)
  3872:     46:             start, end = int(start_s), int(end_s)
  3873:     47:             result.extend(range(start, end + 1))
  3874:     48:         else:
  3875:     49:             result.append(int(part))
  3876:     50:     return sorted(set(result))
  3877:     51: 
  3878:     52: 
  3879:     53: # Order of parameters used throughout the module and in CSV output
  3880:     54: PARAM_KEYS = [
  3881:     55:     "timeframe",
  3882:     56:     "score_min",
  3883:     57:     "atr_min_ratio",
  3884:     58:     "rr_min",
  3885:     59:     "risk_pct",
  3886:     60:     "slippage_bps",
  3887:     61:     "fee_rate",
  3888:     62:     "cooldown_secs",
  3889:     63:     "hours",
  3890:     64: ]
  3891:     65: 
  3892:     66: # Default values used if a parameter is not provided in the grid
  3893:     67: DEFAULTS = {
  3894:     68:     "score_min": 55,
  3895:     69:     "atr_min_ratio": 0.002,
  3896:     70:     "rr_min": 1.2,
  3897:     71:     "risk_pct": 0.01,
  3898:     72:     "slippage_bps": 2,
  3899:     73:     "fee_rate": 0.001,
  3900:     74:     "cooldown_secs": 300,
  3901:     75:     "hours": "7-11,13-17",
  3902:     76: }
  3903:     77: 
  3904:     78: 
  3905:     79: @dataclass
  3906:     80: class GridResult:
  3907:     81:     params: Dict[str, Any]
  3908:     82:     metrics: Dict[str, float]
  3909:     83: 
  3910:     84: 
  3911:     85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
  3912:     86:     if isinstance(val, (list, tuple, set)):
  3913:     87:         return list(val)
  3914:     88:     return [val]
  3915:     89: 
  3916:     90: 
  3917:     91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
  3918:     92:     """Return a list of parameter combinations.
  3919:     93: 
  3920:     94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
  3921:     95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
  3922:     96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
  3923:     97:     variety of timeframes and ``atr_min_ratio`` values.
  3924:     98:     """
  3925:     99: 
  3926:    100:     lists: Dict[str, List[Any]] = {}
  3927:    101:     for key in PARAM_KEYS:
  3928:    102:         if key == "timeframe":
  3929:    103:             # timeframe must be explicitly provided; default empty -> "1m"
  3930:    104:             vals = param_lists.get(key) or ["1m"]
  3931:    105:         else:
  3932:    106:             vals = param_lists.get(key)
  3933:    107:             if not vals:
  3934:    108:                 default = DEFAULTS[key]
  3935:    109:                 vals = [default]
  3936:    110:         lists[key] = _ensure_list(vals)
  3937:    111: 
  3938:    112:     combos: List[Dict[str, Any]] = [
  3939:    113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
  3940:    114:     ]
  3941:    115: 
  3942:    116:     # Uniform sampling if exceeding grid_max
  3943:    117:     if len(combos) > grid_max:
  3944:    118:         step = len(combos) / float(grid_max)
  3945:    119:         sampled = []
  3946:    120:         for i in range(grid_max):
  3947:    121:             idx = int(round(i * step))
  3948:    122:             if idx >= len(combos):
  3949:    123:                 idx = len(combos) - 1
  3950:    124:             sampled.append(combos[idx])
  3951:    125:         # ensure each timeframe appears at least once
  3952:    126:         wanted_tfs = set(lists["timeframe"])
  3953:    127:         present_tfs = {c["timeframe"] for c in sampled}
  3954:    128:         missing = list(wanted_tfs - present_tfs)
  3955:    129:         if missing:
  3956:    130:             for tf in missing:
  3957:    131:                 for c in combos:
  3958:    132:                     if c["timeframe"] == tf and c not in sampled:
  3959:    133:                         sampled.append(c)
  3960:    134:                         break
  3961:    135:             sampled = sampled[:grid_max]
  3962:    136:         combos = sampled
  3963:    137:     return combos
  3964:    138: 
  3965:    139: 
  3966:    140: # ---------------------------------------------------------------------------
  3967:    141: # Core runner
  3968:    142: # ---------------------------------------------------------------------------
  3969:    143: 
  3970:    144: 
  3971:    145: def run_grid_search(
  3972:    146:     *,
  3973:    147:     symbols: Sequence[str],
  3974:    148:     exchange: str,
  3975:    149:     base_params: Dict[str, Any],
  3976:    150:     param_lists: Dict[str, Sequence[Any]],
  3977:    151:     grid_max: int = 12,
  3978:    152:     csv_dir: str | None = None,
  3979:    153:     initial_equity: float = 1000.0,
  3980:    154:     leverage: float = 1.0,
  3981:    155:     paper_constraints: bool = True,
  3982:    156:     seed: int | None = None,
  3983:    157:     out_dir: str = "./result/grid",
  3984:    158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
  3985:    159:     run_func: Callable[..., Any] | None = None,
  3986:    160: ) -> List[GridResult]:
  3987:    161:     """Execute grid search across parameter combinations.
  3988:    162: 
  3989:    163:     ``base_params`` provides default single values for parameters. ``param_lists``
  3990:    164:     contains the grid specifications from CLI (already parsed into sequences).
  3991:    165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
  3992:    166:     """
  3993:    167: 
  3994:    168:     if seed is not None:
  3995:    169:         random.seed(seed)
  3996:    170: 
  3997:    171:     if run_func is None:  # avoid circular import at module load
  3998:    172:         from .run_multi import run_backtest_multi  # late import
  3999:    173: 
  4000:    174:         run_func = run_backtest_multi
  4001:    175: 
  4002:    176:     # merge lists with defaults
  4003:    177:     full_lists: Dict[str, Sequence[Any]] = {}
  4004:    178:     for k in PARAM_KEYS:
  4005:    179:         if k == "timeframe":
  4006:    180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
  4007:    181:         else:
  4008:    182:             if param_lists.get(k) is not None:
  4009:    183:                 full_lists[k] = param_lists[k]
  4010:    184:             else:
  4011:    185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
  4012:    186: 
  4013:    187:     combos = build_param_grid(full_lists, grid_max)
  4014:    188: 
  4015:    189:     results: List[GridResult] = []
  4016:    190:     os.makedirs(out_dir, exist_ok=True)
  4017:    191: 
  4018:    192:     for combo in combos:
  4019:    193:         # Build parameters for backtester
  4020:    194:         tf = combo["timeframe"]
  4021:    195:         fee = float(combo["fee_rate"])
  4022:    196:         slip = float(combo["slippage_bps"])
  4023:    197:         risk = float(combo["risk_pct"])
  4024:    198: 
  4025:    199:         summary, _trades = run_func(
  4026:    200:             symbols=list(symbols),
  4027:    201:             exchange=exchange,
  4028:    202:             timeframe=tf,
  4029:    203:             csv_dir=csv_dir,
  4030:    204:             fee_rate=fee,
  4031:    205:             slippage_bps=slip,
  4032:    206:             risk_pct=risk,
  4033:    207:             initial_equity=initial_equity,
  4034:    208:             leverage=leverage,
  4035:    209:             paper_constraints=paper_constraints,
  4036:    210:             seed=seed,
  4037:    211:             out_dir=os.path.join(out_dir, "tmp"),
  4038:    212:             plot=False,
  4039:    213:             dry_run=True,
  4040:    214:         )
  4041:    215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
  4042:    216:         metrics = {
  4043:    217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
  4044:    218:             "profit_factor": float(total.get("profit_factor", 0.0)),
  4045:    219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
  4046:    220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
  4047:    221:             "trades": float(total.get("trades", 0.0)),
  4048:    222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
  4049:    223:         }
  4050:    224:         results.append(GridResult(params=combo, metrics=metrics))
  4051:    225: 
  4052:    226:     # sort results
  4053:    227:     results.sort(
  4054:    228:         key=lambda r: (
  4055:    229:             -r.metrics["profit_factor"],
  4056:    230:             r.metrics["max_dd_pct"],
  4057:    231:             -r.metrics["pnl_usdt"],
  4058:    232:             r.metrics["trades"],
  4059:    233:         )
  4060:    234:     )
  4061:    235: 
  4062:    236:     # console output -------------------------------------------------------
  4063:    237:     print(
  4064:    238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
  4065:    239:     )
  4066:    240:     header = (
  4067:    241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
  4068:    242:     )
  4069:    243:     print(header)
  4070:    244:     for r in results[:10]:
  4071:    245:         m = r.metrics
  4072:    246:         print(
  4073:    247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
  4074:    248:         )
  4075:    249: 
  4076:    250:     # write csv ------------------------------------------------------------
  4077:    251:     csv_cols = PARAM_KEYS + [
  4078:    252:         "pnl_usdt",
  4079:    253:         "profit_factor",
  4080:    254:         "max_dd_pct",
  4081:    255:         "winrate_pct",
  4082:    256:         "trades",
  4083:    257:         "final_equity",
  4084:    258:     ]
  4085:    259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
  4086:    260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
  4087:    261:         writer.writeheader()
  4088:    262:         for r in results:
  4089:    263:             row = {**r.params, **r.metrics}
  4090:    264:             writer.writerow(row)
  4091:    265: 
  4092:    266:     best = results[0]
  4093:    267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
  4094:    268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
  4095:    269: 
  4096:    270:     # markdown summary -----------------------------------------------------
  4097:    271:     md_path = os.path.join(out_dir, "grid_summary.md")
  4098:    272:     with open(md_path, "w", encoding="utf8") as fh:
  4099:    273:         fh.write(
  4100:    274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
  4101:    275:         )
  4102:    276:         for r in results[:10]:
  4103:    277:             m = r.metrics
  4104:    278:             fh.write(
  4105:    279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
  4106:    280:             )
  4107:    281: 
  4108:    282:     # optional scatter plot ------------------------------------------------
  4109:    283:     try:  # pragma: no cover - optional dependency
  4110:    284:         import matplotlib.pyplot as plt
  4111:    285: 
  4112:    286:         pf = [r.metrics["profit_factor"] for r in results]
  4113:    287:         dd = [r.metrics["max_dd_pct"] for r in results]
  4114:    288:         trades = [r.metrics["trades"] for r in results]
  4115:    289:         tfs = [r.params["timeframe"] for r in results]
  4116:    290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
  4117:    291:         c = [colors[tf] for tf in tfs]
  4118:    292:         plt.figure(figsize=(6, 4))
  4119:    293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
  4120:    294:         plt.xlabel("MaxDD%")
  4121:    295:         plt.ylabel("Profit Factor")
  4122:    296:         plt.title("PF vs MaxDD")
  4123:    297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
  4124:    298:         plt.close()
  4125:    299:     except Exception:  # pragma: no cover
  4126:    300:         pass
  4127:    301: 
  4128:    302:     return results
  4129:    303: 
  4130:    304: 
  4131:    305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]
  4132: 
  4133: 
  4134: ## scalper/backtest/loader_csv.py (last modified: 2025-08-23 20:57:14)
  4135:      1: # scalper/backtest/loader_csv.py
  4136:      2: from __future__ import annotations
  4137:      3: 
  4138:      4: import csv
  4139:      5: from typing import Dict, List
  4140:      6: 
  4141:      7: from scalper.services.data_cache import csv_path
  4142:      8: 
  4143:      9: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
  4144:     10: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
  4145:     11:     path = csv_path(symbol, timeframe)
  4146:     12:     rows: List[List[float]] = []
  4147:     13:     with open(path, "r") as f:
  4148:     14:         r = csv.DictReader(f)
  4149:     15:         for row in r:
  4150:     16:             rows.append([
  4151:     17:                 int(row["timestamp"]),
  4152:     18:                 float(row["open"]),
  4153:     19:                 float(row["high"]),
  4154:     20:                 float(row["low"]),
  4155:     21:                 float(row["close"]),
  4156:     22:                 float(row["volume"]),
  4157:     23:             ])
  4158:     24:     rows.sort(key=lambda x: x[0])
  4159:     25:     return rows
  4160:     26: 
  4161:     27: 
  4162:     28: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
  4163:     29:     out: Dict[str, List[List[float]]] = {}
  4164:     30:     for s in symbols:
  4165:     31:         out[s] = load_ohlcv_csv(s, timeframe)
  4166:     32:     return out
  4167: 
  4168: ## scalper/backtest/market_data.py (last modified: 2025-08-23 20:57:14)
  4169:      1: from __future__ import annotations
  4170:      2: 
  4171:      3: import json
  4172:      4: import os
  4173:      5: import time
  4174:      6: from pathlib import Path
  4175:      7: from typing import Any, Iterable, Optional, Sequence, Tuple
  4176:      8: from urllib.request import Request, urlopen
  4177:      9: from urllib.error import URLError, HTTPError
  4178:     10: 
  4179:     11: import pandas as pd
  4180:     12: 
  4181:     13: # ============================================================================
  4182:     14: # Logs & utilitaires
  4183:     15: # ============================================================================
  4184:     16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  4185:     17: def _log(msg: str) -> None:
  4186:     18:     if BT_DEBUG:
  4187:     19:         print(f"[bt.debug] {msg}", flush=True)
  4188:     20: 
  4189:     21: def _now_ms() -> int:
  4190:     22:     return int(time.time() * 1000)
  4191:     23: 
  4192:     24: def _tf_to_seconds(tf: str) -> int:
  4193:     25:     tf = tf.lower().strip()
  4194:     26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
  4195:     27:     if tf not in table:
  4196:     28:         raise ValueError(f"Timeframe non supporté: {tf}")
  4197:     29:     return table[tf]
  4198:     30: 
  4199:     31: def _parse_duration(s: str) -> int:
  4200:     32:     """
  4201:     33:     '90s','15m','2h','3d' -> secondes
  4202:     34:     """
  4203:     35:     s = s.strip().lower()
  4204:     36:     if s.endswith("s"): return int(float(s[:-1]))
  4205:     37:     if s.endswith("m"): return int(float(s[:-1])*60)
  4206:     38:     if s.endswith("h"): return int(float(s[:-1])*3600)
  4207:     39:     if s.endswith("d"): return int(float(s[:-1])*86400)
  4208:     40:     return int(float(s))  # secondes
  4209:     41: 
  4210:     42: # ============================================================================
  4211:     43: # Politique de fraîcheur (par défaut + overrides via ENV)
  4212:     44: # ============================================================================
  4213:     45: def _default_max_age_seconds(tf: str) -> int:
  4214:     46:     """
  4215:     47:     Règles par défaut (conservatrices) :
  4216:     48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
  4217:     49:       - 30m     : 1h
  4218:     50:       - 1h      : 6h
  4219:     51:       - 4h      : 24h
  4220:     52:       - 1d      : 3d
  4221:     53:     """
  4222:     54:     tf = tf.lower()
  4223:     55:     if tf in ("1m","3m","5m","15m"):
  4224:     56:         return 2 * _tf_to_seconds(tf)
  4225:     57:     if tf == "30m":
  4226:     58:         return 3600
  4227:     59:     if tf == "1h":
  4228:     60:         return 6*3600
  4229:     61:     if tf == "4h":
  4230:     62:         return 24*3600
  4231:     63:     if tf == "1d":
  4232:     64:         return 3*86400
  4233:     65:     raise ValueError(tf)
  4234:     66: 
  4235:     67: def _max_age_seconds(tf: str) -> int:
  4236:     68:     """
  4237:     69:     Overrides possibles (au choix) :
  4238:     70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
  4239:     71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
  4240:     72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
  4241:     73:     """
  4242:     74:     tfk = tf.lower().replace(":", "")
  4243:     75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
  4244:     76:     if env_spec:
  4245:     77:         return _parse_duration(env_spec)
  4246:     78:     mult = os.getenv("CSV_MAX_AGE_MULT")
  4247:     79:     if mult:
  4248:     80:         return int(float(mult) * _tf_to_seconds(tf))
  4249:     81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
  4250:     82:     if g:
  4251:     83:         return _parse_duration(g)
  4252:     84:     return _default_max_age_seconds(tf)
  4253:     85: 
  4254:     86: # ============================================================================
  4255:     87: # CSV helpers + validation
  4256:     88: # ============================================================================
  4257:     89: def _data_dir(default: str = "data") -> Path:
  4258:     90:     root = Path(os.getenv("DATA_DIR", default))
  4259:     91:     root.mkdir(parents=True, exist_ok=True)
  4260:     92:     return root
  4261:     93: 
  4262:     94: def _csv_path(symbol: str, timeframe: str) -> Path:
  4263:     95:     tf = timeframe.replace(":", "")
  4264:     96:     return _data_dir() / f"{symbol}-{tf}.csv"
  4265:     97: 
  4266:     98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
  4267:     99:     rows = list(rows)
  4268:    100:     if not rows:
  4269:    101:         raise ValueError("OHLCV vide")
  4270:    102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
  4271:    103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
  4272:    104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
  4273:    105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
  4274:    106: 
  4275:    107: def _read_csv(path: Path) -> pd.DataFrame:
  4276:    108:     df = pd.read_csv(path)
  4277:    109:     # tolère quelques variations de colonnes
  4278:    110:     cols = {c.lower(): c for c in df.columns}
  4279:    111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
  4280:    112:     if not ts_col:
  4281:    113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
  4282:    114:     rename = {ts_col: "timestamp"}
  4283:    115:     for c in ("open","high","low","close","volume"):
  4284:    116:         if c not in cols:
  4285:    117:             raise ValueError(f"Colonne manquante: {c}")
  4286:    118:         rename[cols[c]] = c
  4287:    119:     df = df.rename(columns=rename)
  4288:    120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  4289:    121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
  4290:    122:     df = df.drop_duplicates("timestamp")
  4291:    123:     df = df.set_index("timestamp")
  4292:    124:     return df
  4293:    125: 
  4294:    126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  4295:    127:     out = df.reset_index().rename(columns={"index": "timestamp"})
  4296:    128:     out.to_csv(path, index=False)
  4297:    129: 
  4298:    130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
  4299:    131:     """
  4300:    132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
  4301:    133:       - schéma valide
  4302:    134:       - assez de lignes
  4303:    135:       - fraîcheur < seuil selon TF
  4304:    136:     """
  4305:    137:     if not path.exists():
  4306:    138:         return False, "absent"
  4307:    139:     try:
  4308:    140:         df = _read_csv(path)
  4309:    141:     except Exception as e:
  4310:    142:         return False, f"invalid({e})"
  4311:    143:     if len(df) < min_rows:
  4312:    144:         return False, f"too_few_rows({len(df)}<{min_rows})"
  4313:    145:     # Fraîcheur
  4314:    146:     last_ts = int(df.index.max().timestamp())
  4315:    147:     age_s = int(time.time()) - last_ts
  4316:    148:     max_age = _max_age_seconds(timeframe)
  4317:    149:     if age_s > max_age:
  4318:    150:         return False, f"stale({age_s}s>{max_age}s)"
  4319:    151:     # Monotonicité (échantillon)
  4320:    152:     if not df.index.is_monotonic_increasing:
  4321:    153:         return False, "not_monotonic"
  4322:    154:     return True, "ok"
  4323:    155: 
  4324:    156: # ============================================================================
  4325:    157: # Fallback réseau (CCXT d'abord, HTTP sinon)
  4326:    158: # ============================================================================
  4327:    159: def _ensure_ccxt() -> Any | None:
  4328:    160:     try:
  4329:    161:         import ccxt  # type: ignore
  4330:    162:         return ccxt
  4331:    163:     except Exception:
  4332:    164:         return None
  4333:    165: 
  4334:    166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  4335:    167:     ccxt = _ensure_ccxt()
  4336:    168:     if not ccxt:
  4337:    169:         _log("ccxt indisponible")
  4338:    170:         return None
  4339:    171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
  4340:    172:     ex.load_markets()
  4341:    173:     base = symbol.upper()
  4342:    174:     if not base.endswith("USDT"):
  4343:    175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
  4344:    176:     coin = base[:-4]
  4345:    177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
  4346:    178:     for ccxt_sym in candidates:
  4347:    179:         try:
  4348:    180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
  4349:    181:             if rows:
  4350:    182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
  4351:    183:         except Exception as e:
  4352:    184:             _log(f"ccxt fail {ccxt_sym}: {e}")
  4353:    185:             continue
  4354:    186:     return None
  4355:    187: 
  4356:    188: # === (facultatif) HTTP Bitget v1 minimal ===
  4357:    189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
  4358:    190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
  4359:    191: 
  4360:    192: def _http_get(url: str, timeout: int = 20) -> dict | list:
  4361:    193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
  4362:    194:     with urlopen(req, timeout=timeout) as resp:
  4363:    195:         return json.loads(resp.read().decode("utf-8"))
  4364:    196: 
  4365:    197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
  4366:    198:     rows = payload.get("data") if isinstance(payload, dict) else payload
  4367:    199:     if not isinstance(rows, list):
  4368:    200:         raise ValueError(f"Réponse inattendue: {payload}")
  4369:    201:     out = []
  4370:    202:     for r in rows:
  4371:    203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
  4372:    204:         out.append([ts,o,h,l,c,v])
  4373:    205:     out.sort(key=lambda x:x[0])
  4374:    206:     return out
  4375:    207: 
  4376:    208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  4377:    209:     tf = timeframe.lower()
  4378:    210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
  4379:    211:     if not (g and p):
  4380:    212:         return None
  4381:    213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
  4382:    214:     trials = [
  4383:    215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
  4384:    216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
  4385:    217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
  4386:    218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
  4387:    219:     ]
  4388:    220:     for url in trials:
  4389:    221:         try:
  4390:    222:             payload = _http_get(url)
  4391:    223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
  4392:    224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
  4393:    225:             rows = _normalize_http_rows(payload)
  4394:    226:             if rows:
  4395:    227:                 return _rows_to_df(rows)
  4396:    228:         except Exception as e:
  4397:    229:             _log(f"HTTP fail: {url} -> {e}")
  4398:    230:             continue
  4399:    231:     return None
  4400:    232: 
  4401:    233: # ============================================================================
  4402:    234: # API publique utilisée par l’orchestrateur/backtest
  4403:    235: # ============================================================================
  4404:    236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  4405:    237:     """
  4406:    238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
  4407:    239:     """
  4408:    240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
  4409:    241:     if df is not None:
  4410:    242:         _log(f"source=ccxt  n={len(df)}")
  4411:    243:         return df
  4412:    244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
  4413:    245:     if df is not None:
  4414:    246:         _log(f"source=http  n={len(df)}")
  4415:    247:         return df
  4416:    248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
  4417:    249: 
  4418:    250: def hybrid_loader(
  4419:    251:     data_dir: str = "data",
  4420:    252:     *,
  4421:    253:     use_cache_first: bool = True,
  4422:    254:     min_rows: int = 100,
  4423:    255:     refill_if_stale: bool = True,
  4424:    256:     network_limit: int = 1000,
  4425:    257: ):
  4426:    258:     """
  4427:    259:     Loader smart :
  4428:    260:       1) si CSV présent ET frais/valide → le renvoie
  4429:    261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
  4430:    262:       3) sinon → lève
  4431:    263:     """
  4432:    264:     os.environ.setdefault("DATA_DIR", data_dir)
  4433:    265: 
  4434:    266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  4435:    267:         path = _csv_path(symbol, timeframe)
  4436:    268: 
  4437:    269:         if use_cache_first:
  4438:    270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
  4439:    271:             if ok:
  4440:    272:                 _log(f"CSV OK: {path}")
  4441:    273:                 df = _read_csv(path)
  4442:    274:             else:
  4443:    275:                 _log(f"CSV non utilisable ({why}): {path}")
  4444:    276:                 if not refill_if_stale:
  4445:    277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
  4446:    278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  4447:    279:                 _write_csv(path, df)
  4448:    280:         else:
  4449:    281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  4450:    282:             _write_csv(path, df)
  4451:    283: 
  4452:    284:         # Fenêtrage temporel si demandé (timestamps UTC)
  4453:    285:         if start:
  4454:    286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  4455:    287:         if end:
  4456:    288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  4457:    289:         return df
  4458:    290: 
  4459:    291:     return load
  4460: 
  4461: ## scalper/backtest/metrics.py (last modified: 2025-08-23 20:57:14)
  4462:      1: from __future__ import annotations
  4463:      2: import math
  4464:      3: from dataclasses import dataclass
  4465:      4: from typing import List, Dict
  4466:      5: 
  4467:      6: @dataclass
  4468:      7: class Trade:
  4469:      8:     ts: int
  4470:      9:     side: str
  4471:     10:     entry: float
  4472:     11:     exit: float
  4473:     12:     pnl_abs: float
  4474:     13:     pnl_pct: float
  4475:     14:     dur_min: float
  4476:     15: 
  4477:     16: def equity_to_drawdown(equity: List[float]) -> float:
  4478:     17:     peak = -1e18; maxdd = 0.0
  4479:     18:     for v in equity:
  4480:     19:         if v > peak: peak = v
  4481:     20:         dd = 0.0 if peak == 0 else (peak - v) / peak
  4482:     21:         if dd > maxdd: maxdd = dd
  4483:     22:     return maxdd
  4484:     23: 
  4485:     24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
  4486:     25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
  4487:     26:     if not returns: return 0.0
  4488:     27:     mean = sum(returns)/len(returns)
  4489:     28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
  4490:     29:     std = math.sqrt(var) if var>0 else 0.0
  4491:     30:     if std == 0: return 0.0
  4492:     31:     return (mean - rf) / std * math.sqrt(period_per_year)
  4493:     32: 
  4494:     33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
  4495:     34:     wins = [t for t in trades if t.pnl_abs > 0]
  4496:     35:     losses = [t for t in trades if t.pnl_abs < 0]
  4497:     36:     wr = len(wins)/len(trades) if trades else 0.0
  4498:     37:     gross_win = sum(t.pnl_abs for t in wins)
  4499:     38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
  4500:     39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
  4501:     40:     mdd = equity_to_drawdown(equity)
  4502:     41:     shp = sharpe(bar_returns)
  4503:     42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
  4504:     43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
  4505:     44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
  4506:     45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
  4507:     46:     return {
  4508:     47:         "trades": len(trades),
  4509:     48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
  4510:     49:         "expectancy": expectancy, "cagr": cagr, "score": score,
  4511:     50:         "equity_start": equity[0] if equity else None,
  4512:     51:         "equity_end": equity[-1] if equity else None,
  4513:     52:     }
  4514: 
  4515: ## scalper/backtest/optimize.py (last modified: 2025-08-23 20:57:14)
  4516:      1: from __future__ import annotations
  4517:      2: 
  4518:      3: """Parameter sweep utilities for strategy optimisation.
  4519:      4: 
  4520:      5: This module performs a grid search over a parameter space in parallel.  It
  4521:      6: tries to use :mod:`ray` for distributed execution when available and falls
  4522:      7: back to :mod:`multiprocessing` otherwise.
  4523:      8: """
  4524:      9: 
  4525:     10: import itertools
  4526:     11: import json
  4527:     12: import multiprocessing as mp
  4528:     13: import os
  4529:     14: from typing import Any, Dict, Iterable, List, Sequence
  4530:     15: 
  4531:     16: try:  # Optional dependency
  4532:     17:     import ray  # type: ignore
  4533:     18: except Exception:  # pragma: no cover - ray is optional
  4534:     19:     ray = None
  4535:     20: 
  4536:     21: from scalper.backtest import backtest_trades
  4537:     22: 
  4538:     23: 
  4539:     24: # ---------------------------------------------------------------------------
  4540:     25: # Parameter space
  4541:     26: # ---------------------------------------------------------------------------
  4542:     27: 
  4543:     28: def param_space_default() -> Dict[str, Sequence[Any]]:
  4544:     29:     """Return the default parameter search space.
  4545:     30: 
  4546:     31:     The keys correspond to strategy parameters while the values are iterables
  4547:     32:     of possible settings.  The defaults represent a small but representative
  4548:     33:     grid and can be overridden by callers.
  4549:     34:     """
  4550:     35: 
  4551:     36:     return {
  4552:     37:         "ema_fast": [10, 20, 30],
  4553:     38:         "ema_slow": [50, 100, 200],
  4554:     39:         "rsi_period": [14, 21],
  4555:     40:         "atr_period": [14, 21],
  4556:     41:     }
  4557:     42: 
  4558:     43: 
  4559:     44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
  4560:     45:     """Expand *space* into a list of parameter combinations."""
  4561:     46: 
  4562:     47:     keys = list(space)
  4563:     48:     values = [space[k] for k in keys]
  4564:     49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
  4565:     50: 
  4566:     51: 
  4567:     52: # ---------------------------------------------------------------------------
  4568:     53: # Evaluation
  4569:     54: # ---------------------------------------------------------------------------
  4570:     55: 
  4571:     56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
  4572:     57:     """Run a backtest for a single parameter combination.
  4573:     58: 
  4574:     59:     ``grid_item`` contains the parameter values along with optional ``trades``
  4575:     60:     to evaluate.  The function returns a copy of the parameters augmented with
  4576:     61:     the computed PnL under the key ``pnl``.
  4577:     62:     """
  4578:     63: 
  4579:     64:     params = dict(grid_item)
  4580:     65:     trades = params.pop("trades", [])
  4581:     66:     fee_rate = params.pop("fee_rate", None)
  4582:     67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
  4583:     68:     params["pnl"] = pnl
  4584:     69:     return params
  4585:     70: 
  4586:     71: 
  4587:     72: # ---------------------------------------------------------------------------
  4588:     73: # Orchestration
  4589:     74: # ---------------------------------------------------------------------------
  4590:     75: 
  4591:     76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
  4592:     77:     """Evaluate the full parameter grid in parallel and return results."""
  4593:     78: 
  4594:     79:     space = space or param_space_default()
  4595:     80:     grid = _param_grid(space)
  4596:     81: 
  4597:     82:     # Determine execution backend
  4598:     83:     use_ray = False
  4599:     84:     if ray is not None:
  4600:     85:         try:  # pragma: no cover - depends on ray
  4601:     86:             ray.init(ignore_reinit_error=True)
  4602:     87:             use_ray = True
  4603:     88:         except Exception:
  4604:     89:             use_ray = False
  4605:     90: 
  4606:     91:     if use_ray:
  4607:     92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
  4608:     93:         futures = [remote_eval.remote(g) for g in grid]
  4609:     94:         results = ray.get(futures)
  4610:     95:     else:
  4611:     96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
  4612:     97:         with mp.Pool(processes=jobs) as pool:
  4613:     98:             results = pool.map(eval_params_one, grid)
  4614:     99: 
  4615:    100:     return results
  4616:    101: 
  4617:    102: 
  4618:    103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
  4619:    104:     """High level helper executing the sweep and saving aggregated results."""
  4620:    105: 
  4621:    106:     results = run_param_sweep(space, jobs=jobs)
  4622:    107:     with open(outfile, "w", encoding="utf8") as fh:
  4623:    108:         json.dump(results, fh, indent=2, sort_keys=True)
  4624:    109:     return results
  4625:    110: 
  4626:    111: 
  4627:    112: def main() -> None:  # pragma: no cover - convenience CLI
  4628:    113:     optimize()
  4629:    114: 
  4630:    115: 
  4631:    116: if __name__ == "__main__":  # pragma: no cover
  4632:    117:     main()
  4633: 
  4634: 
  4635: ## scalper/backtest/run_multi.py (last modified: 2025-08-23 20:57:14)
  4636:      1: # annulé
  4637: 
  4638: ## scalper/backtest/runner.py (last modified: 2025-08-23 20:57:14)
  4639:      1: # scalper/backtest/runner.py
  4640:      2: from __future__ import annotations
  4641:      3: 
  4642:      4: import json
  4643:      5: import math
  4644:      6: import os
  4645:      7: import time
  4646:      8: from dataclasses import dataclass, replace
  4647:      9: from pathlib import Path
  4648:     10: from typing import Dict, List, Tuple, Callable
  4649:     11: 
  4650:     12: from .cache import ensure_csv_cache, read_csv_ohlcv, csv_path, tf_to_seconds, dump_validation_report
  4651:     13: 
  4652:     14: # --------- Chargement de la stratégie ---------
  4653:     15: def load_signal_fn() -> Callable[[str, List[List[float]], float, float], Tuple[str, float]]:
  4654:     16:     try:
  4655:     17:         from scalper.signals.factory import load_signal  # type: ignore
  4656:     18:         name = os.getenv("STRATEGY", "current")
  4657:     19:         return load_signal(name)
  4658:     20:     except Exception:
  4659:     21:         def _fallback(symbol: str, ohlcv: List[List[float]], cash: float, risk_pct: float) -> Tuple[str, float]:
  4660:     22:             closes = [r[4] for r in (ohlcv[-10:] if len(ohlcv) >= 10 else ohlcv)]
  4661:     23:             if not closes:
  4662:     24:                 return "HOLD", 0.0
  4663:     25:             avg = sum(closes) / len(closes)
  4664:     26:             last = closes[-1]
  4665:     27:             if last > avg * 1.002:
  4666:     28:                 return "BUY", 1.0
  4667:     29:             if last < avg * 0.998:
  4668:     30:                 return "SELL", 1.0
  4669:     31:             return "HOLD", 0.0
  4670:     32:         return _fallback
  4671:     33: 
  4672:     34: # --------- Config ---------
  4673:     35: @dataclass
  4674:     36: class BTCfg:
  4675:     37:     symbols: List[str]
  4676:     38:     timeframe: str = "5m"
  4677:     39:     limit: int = 1500
  4678:     40:     cash: float = 10_000.0
  4679:     41:     risk_pct: float = 0.05
  4680:     42:     slippage_bps: float = 0.0
  4681:     43:     fee_bps: float = 6.0
  4682:     44:     data_dir: str = "data"
  4683:     45:     strategy: str = os.getenv("STRATEGY", "current")
  4684:     46: 
  4685:     47: # --------- Petit moteur PnL ---------
  4686:     48: def _bps(x: float) -> float: return x / 10_000.0
  4687:     49: 
  4688:     50: def simulate_symbol(ohlcv: List[List[float]], cfg: BTCfg, signal_fn: Callable) -> Tuple[List[Tuple[int,float]], Dict]:
  4689:     51:     equity = cfg.cash
  4690:     52:     position = 0.0
  4691:     53:     entry_price = 0.0
  4692:     54:     equity_curve: List[Tuple[int, float]] = []
  4693:     55:     trades = 0
  4694:     56: 
  4695:     57:     fee = _bps(cfg.fee_bps)
  4696:     58:     slip = _bps(cfg.slippage_bps)
  4697:     59: 
  4698:     60:     for i in range(1, len(ohlcv)):
  4699:     61:         window = ohlcv[: i+1]
  4700:     62:         ts, _, _, _, price, _ = ohlcv[i]
  4701:     63:         signal, strength = signal_fn("SYMBOL", window, equity, cfg.risk_pct)
  4702:     64: 
  4703:     65:         if position != 0:
  4704:     66:             equity += position * (price - ohlcv[i-1][4])
  4705:     67: 
  4706:     68:         target_pos = 0.0
  4707:     69:         if signal == "BUY":
  4708:     70:             notional = equity * cfg.risk_pct * strength
  4709:     71:             target_pos = max(0.0, notional / price)
  4710:     72:         elif signal == "SELL":
  4711:     73:             notional = equity * cfg.risk_pct * strength
  4712:     74:             target_pos = - max(0.0, notional / price)
  4713:     75: 
  4714:     76:         if target_pos != position:
  4715:     77:             delta = target_pos - position
  4716:     78:             if delta != 0:
  4717:     79:                 trades += 1
  4718:     80:                 trade_price = price * (1 + slip * (1 if delta > 0 else -1))
  4719:     81:                 equity -= abs(delta) * trade_price * fee
  4720:     82:                 position = target_pos
  4721:     83:                 entry_price = trade_price if position != 0 else 0.0
  4722:     84: 
  4723:     85:         equity_curve.append((ts, equity))
  4724:     86: 
  4725:     87:     if position != 0 and ohlcv:
  4726:     88:         last_price = ohlcv[-1][4]
  4727:     89:         equity += position * (last_price - entry_price)
  4728:     90:         equity -= abs(position) * last_price * fee
  4729:     91:         position = 0
  4730:     92: 
  4731:     93:     eq = [e for _, e in equity_curve]
  4732:     94:     ret_tot = (eq[-1] / eq[0] - 1.0) if len(eq) >= 2 else 0.0
  4733:     95:     max_dd = 0.0
  4734:     96:     peak = -1.0
  4735:     97:     for v in eq:
  4736:     98:         if v > peak: peak = v
  4737:     99:         dd = (peak - v) / peak if peak > 0 else 0.0
  4738:    100:         max_dd = max(max_dd, dd)
  4739:    101: 
  4740:    102:     tf_sec = tf_to_seconds(cfg.timeframe)
  4741:    103:     bpy = int((365.0 * 86400.0) / tf_sec)
  4742:    104:     rets = []
  4743:    105:     for i in range(1, len(eq)):
  4744:    106:         r = (eq[i] / eq[i-1]) - 1.0
  4745:    107:         rets.append(r)
  4746:    108:     if len(rets) > 1:
  4747:    109:         mu = sum(rets) / len(rets)
  4748:    110:         var = sum((x - mu) ** 2 for x in rets) / (len(rets) - 1)
  4749:    111:         std = math.sqrt(var) if var > 0 else 0.0
  4750:    112:         sharpe = (mu * bpy) / (std * math.sqrt(bpy)) if std > 0 else 0.0
  4751:    113:     else:
  4752:    114:         sharpe = 0.0
  4753:    115: 
  4754:    116:     metrics = {
  4755:    117:         "final_equity": round(eq[-1], 4) if eq else cfg.cash,
  4756:    118:         "total_return_pct": round(ret_tot * 100, 4),
  4757:    119:         "max_drawdown_pct": round(max_dd * 100, 4),
  4758:    120:         "sharpe_like": round(sharpe, 4),
  4759:    121:         "trades": trades,
  4760:    122:     }
  4761:    123:     return equity_curve, metrics
  4762:    124: 
  4763:    125: # --------- Runner principal ---------
  4764:    126: async def run_multi(cfg: BTCfg, exchange) -> Dict:
  4765:    127:     data = await ensure_csv_cache(exchange, cfg.symbols, cfg.timeframe, cfg.limit)
  4766:    128: 
  4767:    129:     signal_fn = load_signal_fn()
  4768:    130:     per_symbol: Dict[str, Dict] = {}
  4769:    131:     aligned_ts: List[int] = []
  4770:    132: 
  4771:    133:     sets_ts = []
  4772:    134:     for s in cfg.symbols:
  4773:    135:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  4774:    136:         sets_ts.append({r[0] for r in rows})
  4775:    137:     if sets_ts:
  4776:    138:         aligned_ts = sorted(list(set.intersection(*sets_ts)))
  4777:    139: 
  4778:    140:     results_curves: Dict[str, List[Tuple[int, float]]] = {}
  4779:    141:     for s in cfg.symbols:
  4780:    142:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  4781:    143:         rows = [r for r in rows if r[0] in set(aligned_ts)]
  4782:    144:         curve, metr = simulate_symbol(rows, cfg, signal_fn)
  4783:    145:         results_curves[s] = curve
  4784:    146:         per_symbol[s] = metr
  4785:    147: 
  4786:    148:     fused: List[Tuple[int, float]] = []
  4787:    149:     for i in range(len(aligned_ts)):
  4788:    150:         ts = aligned_ts[i]
  4789:    151:         vals = []
  4790:    152:         for s in cfg.symbols:
  4791:    153:             cv = results_curves[s]
  4792:    154:             if i < len(cv) and cv[i][0] == ts:
  4793:    155:                 vals.append(cv[i][1])
  4794:    156:         if vals:
  4795:    157:             fused.append((ts, sum(vals) / len(vals)))
  4796:    158: 
  4797:    159:     glob_metrics = {}
  4798:    160:     if fused:
  4799:    161:         eq = [e for _, e in fused]
  4800:    162:         ret_tot = (eq[-1]/eq[0]-1.0) if len(eq)>=2 else 0.0
  4801:    163:         peak = -1.0; max_dd = 0.0
  4802:    164:         for v in eq:
  4803:    165:             if v > peak: peak = v
  4804:    166:             dd = (peak - v) / peak if peak > 0 else 0.0
  4805:    167:             max_dd = max(max_dd, dd)
  4806:    168:         tf_sec = tf_to_seconds(cfg.timeframe)
  4807:    169:         bpy = int((365.0*86400.0)/tf_sec)
  4808:    170:         rets = []
  4809:    171:         for i in range(1, len(eq)):
  4810:    172:             rets.append((eq[i]/eq[i-1]) - 1.0)
  4811:    173:         if len(rets) > 1:
  4812:    174:             mu = sum(rets)/len(rets)
  4813:    175:             var = sum((x-mu)**2 for x in rets)/(len(rets)-1)
  4814:    176:             std = math.sqrt(var) if var>0 else 0.0
  4815:    177:             sharpe = (mu*bpy)/(std*math.sqrt(bpy)) if std>0 else 0.0
  4816:    178:         else:
  4817:    179:             sharpe = 0.0
  4818:    180:         glob_metrics = {
  4819:    181:             "final_equity": round(eq[-1], 4),
  4820:    182:             "total_return_pct": round(ret_tot*100, 4),
  4821:    183:             "max_drawdown_pct": round(max_dd*100, 4),
  4822:    184:             "sharpe_like": round(sharpe, 4),
  4823:    185:         }
  4824:    186: 
  4825:    187:     stamp = time.strftime("%Y%m%d-%H%M%S")
  4826:    188:     out_dir = Path(os.getenv("BACKTEST_OUT", f"result/backtest-{stamp}"))
  4827:    189:     out_dir.mkdir(parents=True, exist_ok=True)
  4828:    190: 
  4829:    191:     (out_dir / "equity_curve.csv").write_text(
  4830:    192:         "timestamp,equity\n" + "\n".join(f"{ts},{eq:.6f}" for ts, eq in fused)
  4831:    193:     )
  4832:    194:     all_metrics = {"global": glob_metrics, "per_symbol": per_symbol}
  4833:    195:     (out_dir / "metrics.json").write_text(json.dumps(all_metrics, indent=2))
  4834:    196:     dump_validation_report(cfg.symbols, cfg.timeframe, out_dir / "csv_validation.json")
  4835:    197: 
  4836:    198:     return {
  4837:    199:         "out_dir": str(out_dir),
  4838:    200:         "equity_curve": str(out_dir / "equity_curve.csv"),
  4839:    201:         "metrics": str(out_dir / "metrics.json"),
  4840:    202:         "csv_validation": str(out_dir / "csv_validation.json"),
  4841:    203:     }
  4842:    204: 
  4843:    205: # --------- Alias rétro-compatibilité ---------
  4844:    206: # Certains fichiers live importaient: BTConfig, run_single, save_results
  4845:    207: BTConfig = BTCfg  # alias
  4846:    208: 
  4847:    209: async def run_single(cfg: BTCfg, exchange, symbol: str | None = None) -> Dict:
  4848:    210:     """Compat : lance un backtest mono-symbole en réutilisant run_multi."""
  4849:    211:     if symbol:
  4850:    212:         cfg = replace(cfg, symbols=[symbol])
  4851:    213:     return await run_multi(cfg, exchange)
  4852:    214: 
  4853:    215: def save_results(res: Dict) -> Dict:
  4854:    216:     """Compat no-op : les fichiers sont déjà écrits par run_multi."""
  4855:    217:     return res
  4856:    218: 
  4857:    219: # --------- CLI ---------
  4858:    220: if __name__ == "__main__":
  4859:    221:     import asyncio
  4860:    222:     try:
  4861:    223:         import ccxt.async_support as ccxt  # type: ignore
  4862:    224:     except Exception:
  4863:    225:         raise SystemExit("Installe ccxt: pip install ccxt")
  4864:    226: 
  4865:    227:     symbols = os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",")
  4866:    228:     cfg = BTCfg(
  4867:    229:         symbols=[s.strip().upper() for s in symbols if s.strip()],
  4868:    230:         timeframe=os.getenv("TF", "5m"),
  4869:    231:         limit=int(os.getenv("LIMIT", "1500")),
  4870:    232:         cash=float(os.getenv("CASH", "10000")),
  4871:    233:         risk_pct=float(os.getenv("RISK_PCT", "0.05")),
  4872:    234:         slippage_bps=float(os.getenv("SLIPPAGE_BPS", "0.0")),
  4873:    235:         fee_bps=float(os.getenv("FEE_BPS", "6.0")),
  4874:    236:     )
  4875:    237:     exchange = ccxt.bitget()
  4876:    238:     res = asyncio.run(run_multi(cfg, exchange))
  4877:    239:     print("Résultats écrits dans:", res["out_dir"])
  4878: 
  4879: ## scalper/backtest/walkforward.py (last modified: 2025-08-23 20:57:14)
  4880:      1: from __future__ import annotations
  4881:      2: 
  4882:      3: from itertools import product
  4883:      4: from statistics import mean, stdev
  4884:      5: from typing import Dict, Iterable, Optional
  4885:      6: 
  4886:      7: from ..strategy import max_drawdown
  4887:      8: 
  4888:      9: 
  4889:     10: def _sharpe(returns: Iterable[float]) -> float:
  4890:     11:     vals = list(returns)
  4891:     12:     if not vals:
  4892:     13:         return 0.0
  4893:     14:     mu = mean(vals)
  4894:     15:     if len(vals) > 1:
  4895:     16:         sd = stdev(vals)
  4896:     17:     else:
  4897:     18:         sd = 0.0
  4898:     19:     return mu / sd if sd > 0 else 0.0
  4899:     20: 
  4900:     21: 
  4901:     22: def _stability(equity: Iterable[float]) -> float:
  4902:     23:     curve = list(equity)
  4903:     24:     n = len(curve)
  4904:     25:     if n < 2:
  4905:     26:         return 0.0
  4906:     27:     x = list(range(n))
  4907:     28:     x_mean = sum(x) / n
  4908:     29:     y_mean = sum(curve) / n
  4909:     30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
  4910:     31:     denom = sum((xi - x_mean) ** 2 for xi in x)
  4911:     32:     if denom == 0 or ss_tot == 0:
  4912:     33:         return 0.0
  4913:     34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
  4914:     35:     a = y_mean - b * x_mean
  4915:     36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
  4916:     37:     return 1 - ss_res / ss_tot
  4917:     38: 
  4918:     39: 
  4919:     40: def walk_forward(
  4920:     41:     df,
  4921:     42:     splits: int = 5,
  4922:     43:     train_ratio: float = 0.7,
  4923:     44:     params: Optional[Dict[str, Iterable]] = None,
  4924:     45: ) -> Dict[str, float]:
  4925:     46:     """Perform walk-forward optimisation and evaluation.
  4926:     47: 
  4927:     48:     Parameters
  4928:     49:     ----------
  4929:     50:     df:
  4930:     51:         DataFrame containing per-period percentage returns. The first column is
  4931:     52:         used when a dedicated ``"returns"`` column is not found.
  4932:     53:     splits:
  4933:     54:         Number of walk-forward test windows.
  4934:     55:     train_ratio:
  4935:     56:         Proportion of the data used for training in the initial window.
  4936:     57:     params:
  4937:     58:         Optional parameter grid. If provided, columns in ``df`` matching each
  4938:     59:         parameter combination are evaluated and the best Sharpe ratio on the
  4939:     60:         training window is selected. When ``None``, the first column is used.
  4940:     61:     """
  4941:     62: 
  4942:     63:     if df.empty:
  4943:     64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
  4944:     65: 
  4945:     66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
  4946:     67:     data = df.copy()
  4947:     68: 
  4948:     69:     n = len(data)
  4949:     70:     train_len = max(1, int(n * train_ratio))
  4950:     71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
  4951:     72: 
  4952:     73:     sharpe_list = []
  4953:     74:     mdd_list = []
  4954:     75:     pnl_list = []
  4955:     76:     stability_list = []
  4956:     77: 
  4957:     78:     from . import walk_forward_windows
  4958:     79: 
  4959:     80:     indices = list(range(n))
  4960:     81: 
  4961:     82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
  4962:     83:         train_df = data.iloc[tr_idx]
  4963:     84:         test_df = data.iloc[te_idx]
  4964:     85: 
  4965:     86:         # Parameter optimisation based on Sharpe ratio
  4966:     87:         if params:
  4967:     88:             best_col = None
  4968:     89:             best_score = float("-inf")
  4969:     90:             keys, values = zip(*params.items()) if params else ([], [])
  4970:     91:             for combo in product(*values):
  4971:     92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
  4972:     93:                 if col_name not in data.columns:
  4973:     94:                     continue
  4974:     95:                 score = _sharpe(train_df[col_name])
  4975:     96:                 if score > best_score:
  4976:     97:                     best_score = score
  4977:     98:                     best_col = col_name
  4978:     99:             series = test_df[best_col] if best_col else test_df[returns_col]
  4979:    100:         else:
  4980:    101:             series = test_df[returns_col]
  4981:    102: 
  4982:    103:         sharpe_list.append(_sharpe(series))
  4983:    104:         equity = (1 + series / 100.0).cumprod()
  4984:    105:         mdd_list.append(max_drawdown(equity))
  4985:    106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
  4986:    107:         stability_list.append(_stability(equity))
  4987:    108: 
  4988:    109:     count = len(sharpe_list) or 1
  4989:    110:     mean_sharpe = sum(sharpe_list) / count
  4990:    111:     mean_mdd = sum(mdd_list) / count
  4991:    112:     mean_pnl = sum(pnl_list) / count
  4992:    113:     mean_stability = sum(stability_list) / count
  4993:    114: 
  4994:    115:     return {
  4995:    116:         "sharpe": mean_sharpe,
  4996:    117:         "mdd": mean_mdd,
  4997:    118:         "pnl": mean_pnl,
  4998:    119:         "stability": mean_stability,
  4999:    120:     }
  5000: 
  5001: 
  5002: ## scalper/bitget_client.py (last modified: 2025-08-23 20:57:14)
  5003:      1: import json
  5004:      2: import logging
  5005:      3: import time
  5006:      4: import hmac
  5007:      5: import hashlib
  5008:      6: import base64
  5009:      7: import uuid
  5010:      8: from typing import Any, Dict, List, Optional
  5011:      9: 
  5012:     10: import requests
  5013:     11: 
  5014:     12: 
  5015:     13: # Mapping of deprecated v1 product type identifiers to the new v2 names
  5016:     14: _PRODUCT_TYPE_ALIASES = {
  5017:     15:     "UMCBL": "USDT-FUTURES",
  5018:     16:     "DMCBL": "USDC-FUTURES",
  5019:     17:     "CMCBL": "COIN-FUTURES",
  5020:     18: }
  5021:     19: 
  5022:     20: # Granularity aliases from v1 to v2 nomenclature
  5023:     21: _GRANULARITY_ALIASES = {
  5024:     22:     "MIN1": "1m",
  5025:     23:     "MIN3": "3m",
  5026:     24:     "MIN5": "5m",
  5027:     25:     "MIN15": "15m",
  5028:     26:     "MIN30": "30m",
  5029:     27:     "HOUR1": "1H",
  5030:     28:     "HOUR4": "4H",
  5031:     29:     "HOUR12": "12H",
  5032:     30:     "DAY1": "1D",
  5033:     31:     "WEEK1": "1W",
  5034:     32: }
  5035:     33: 
  5036:     34: 
  5037:     35: # Default margin coin for each product type. Some authenticated endpoints
  5038:     36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
  5039:     37: # default avoids ``400 Bad Request`` responses when the caller does not provide
  5040:     38: # it explicitly.
  5041:     39: _DEFAULT_MARGIN_COIN = {
  5042:     40:     "USDT-FUTURES": "USDT",
  5043:     41:     "USDC-FUTURES": "USDC",
  5044:     42: }
  5045:     43: 
  5046:     44: 
  5047:     45: class BitgetFuturesClient:
  5048:     46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
  5049:     47: 
  5050:     48:     def __init__(
  5051:     49:         self,
  5052:     50:         access_key: str,
  5053:     51:         secret_key: str,
  5054:     52:         base_url: str,
  5055:     53:         *,
  5056:     54:         product_type: str = "USDT-FUTURES",
  5057:     55:         recv_window: int = 30,
  5058:     56:         paper_trade: bool = True,
  5059:     57:         requests_module: Any = requests,
  5060:     58:         log_event: Optional[Any] = None,
  5061:     59:         passphrase: Optional[str] = None,
  5062:     60:     ) -> None:
  5063:     61:         self.ak = access_key
  5064:     62:         self.sk = secret_key
  5065:     63:         self.base = base_url.rstrip("/")
  5066:     64:         pt = product_type.upper()
  5067:     65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
  5068:     66:         self.recv_window = recv_window
  5069:     67:         self.paper_trade = paper_trade
  5070:     68:         self.requests = requests_module
  5071:     69:         self.log_event = log_event or (lambda *a, **k: None)
  5072:     70:         self.passphrase = passphrase
  5073:     71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
  5074:     72:             logging.warning(
  5075:     73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
  5076:     74:             )
  5077:     75:         # Cache for contract precision details to avoid repeated network calls
  5078:     76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
  5079:     77: 
  5080:     78:     # ------------------------------------------------------------------
  5081:     79:     # Helpers
  5082:     80:     # ------------------------------------------------------------------
  5083:     81:     @staticmethod
  5084:     82:     def _ms() -> int:
  5085:     83:         return int(time.time() * 1000)
  5086:     84: 
  5087:     85:     @staticmethod
  5088:     86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
  5089:     87:         if not params:
  5090:     88:             return ""
  5091:     89:         items = []
  5092:     90:         for k in sorted(params.keys()):
  5093:     91:             v = "" if params[k] is None else str(params[k])
  5094:     92:             items.append(f"{k}={v}")
  5095:     93:         return "&".join(items)
  5096:     94: 
  5097:     95:     def _sign(self, prehash: str) -> str:
  5098:     96:         """Return a base64-encoded HMAC SHA256 signature."""
  5099:     97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
  5100:     98:         return base64.b64encode(digest).decode()
  5101:     99: 
  5102:    100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
  5103:    101:         headers = {
  5104:    102:             "ACCESS-KEY": self.ak,
  5105:    103:             "ACCESS-SIGN": signature,
  5106:    104:             "ACCESS-TIMESTAMP": str(timestamp),
  5107:    105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
  5108:    106:             "Content-Type": "application/json",
  5109:    107:         }
  5110:    108:         if self.passphrase:
  5111:    109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
  5112:    110:         return headers
  5113:    111: 
  5114:    112:     def _format_symbol(self, symbol: str) -> str:
  5115:    113:         """Return ``symbol`` formatted for Bitget API.
  5116:    114: 
  5117:    115:         The v2 endpoints expect the trading pair without any product type
  5118:    116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
  5119:    117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
  5120:    118:         separators and any trailing product type string (legacy or v2).
  5121:    119:         """
  5122:    120: 
  5123:    121:         if not symbol:
  5124:    122:             return symbol
  5125:    123: 
  5126:    124:         sym = symbol.replace("_", "").upper()
  5127:    125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
  5128:    126:         if sym.endswith(self.product_type):
  5129:    127:             sym = sym[: -len(self.product_type)]
  5130:    128:         else:
  5131:    129:             for old in _PRODUCT_TYPE_ALIASES.keys():
  5132:    130:                 if sym.endswith(old):
  5133:    131:                     sym = sym[: -len(old)]
  5134:    132:                     break
  5135:    133:         return sym
  5136:    134: 
  5137:    135:     def _product_type(self, pt: Optional[str] = None) -> str:
  5138:    136:         """Normalise ``pt`` to a valid v2 product type identifier."""
  5139:    137:         key = (pt or self.product_type or "").upper()
  5140:    138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
  5141:    139: 
  5142:    140:     # ------------------------------------------------------------------
  5143:    141:     # Public endpoints
  5144:    142:     # ------------------------------------------------------------------
  5145:    143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5146:    144:         """Return futures contract information.
  5147:    145: 
  5148:    146:         The previous implementation queried ``/contract-detail`` which does not
  5149:    147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
  5150:    148:         endpoint is ``/contracts`` with the symbol supplied as a query
  5151:    149:         parameter."""
  5152:    150: 
  5153:    151:         url = f"{self.base}/api/v2/mix/market/contracts"
  5154:    152:         params: Dict[str, Any] = {"productType": self.product_type}
  5155:    153:         if symbol:
  5156:    154:             params["symbol"] = self._format_symbol(symbol)
  5157:    155:         r = self.requests.get(url, params=params, timeout=15)
  5158:    156:         if r.status_code == 404:  # pragma: no cover - depends on network
  5159:    157:             logging.error("Contract detail introuvable pour %s", symbol)
  5160:    158:             return {"success": False, "code": 404, "data": None}
  5161:    159:         r.raise_for_status()
  5162:    160:         return r.json()
  5163:    161: 
  5164:    162:     # ------------------------------------------------------------------
  5165:    163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
  5166:    164:         """Return price and volume precision for ``symbol``.
  5167:    165: 
  5168:    166:         Results are cached to minimise HTTP requests. If the contract
  5169:    167:         information cannot be retrieved, ``(0, 0)`` is returned.
  5170:    168:         """
  5171:    169:         sym = self._format_symbol(symbol)
  5172:    170:         info = self._contract_cache.get(sym)
  5173:    171:         if info is None:
  5174:    172:             detail = self.get_contract_detail(sym)
  5175:    173:             try:
  5176:    174:                 data = detail.get("data", [])
  5177:    175:                 if isinstance(data, list) and data:
  5178:    176:                     info = data[0]
  5179:    177:                 else:
  5180:    178:                     info = {}
  5181:    179:             except Exception:
  5182:    180:                 info = {}
  5183:    181:             self._contract_cache[sym] = info
  5184:    182:         price_place = int(info.get("pricePlace") or 0)
  5185:    183:         volume_place = int(info.get("volumePlace") or 0)
  5186:    184:         return price_place, volume_place
  5187:    185: 
  5188:    186:     def get_kline(
  5189:    187:         self,
  5190:    188:         symbol: str,
  5191:    189:         interval: str = "1m",
  5192:    190:         start: Optional[int] = None,
  5193:    191:         end: Optional[int] = None,
  5194:    192:     ) -> Dict[str, Any]:
  5195:    193:         # Endpoint expects the trading pair in query parameters rather than
  5196:    194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
  5197:    195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
  5198:    196:         url = f"{self.base}/api/v2/mix/market/candles"
  5199:    197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
  5200:    198:         params: Dict[str, Any] = {
  5201:    199:             "symbol": self._format_symbol(symbol),
  5202:    200:             "productType": self.product_type,
  5203:    201:             "granularity": interval_norm,
  5204:    202:         }
  5205:    203:         if start is not None:
  5206:    204:             params["startTime"] = int(start)
  5207:    205:         if end is not None:
  5208:    206:             params["endTime"] = int(end)
  5209:    207:         r = self.requests.get(url, params=params, timeout=15)
  5210:    208:         r.raise_for_status()
  5211:    209:         data = r.json()
  5212:    210: 
  5213:    211:         rows = data.get("data") if isinstance(data, dict) else None
  5214:    212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
  5215:    213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  5216:    214:             for row in rows:
  5217:    215:                 if len(row) < 7:
  5218:    216:                     continue
  5219:    217:                 try:
  5220:    218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
  5221:    219:                     cols["ts"].append(int(ts))
  5222:    220:                     cols["open"].append(float(op))
  5223:    221:                     cols["high"].append(float(hi))
  5224:    222:                     cols["low"].append(float(lo))
  5225:    223:                     cols["close"].append(float(cl))
  5226:    224:                     cols["volume"].append(float(vol))
  5227:    225:                     cols["quoteVolume"].append(float(qv))
  5228:    226:                 except (TypeError, ValueError):
  5229:    227:                     continue
  5230:    228:             data["data"] = cols
  5231:    229:         elif isinstance(rows, list):
  5232:    230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  5233:    231:         return data
  5234:    232: 
  5235:    233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5236:    234:         if symbol:
  5237:    235:             url = f"{self.base}/api/v2/mix/market/ticker"
  5238:    236:             params = {
  5239:    237:                 "symbol": self._format_symbol(symbol),
  5240:    238:                 "productType": self.product_type,
  5241:    239:             }
  5242:    240:         else:
  5243:    241:             url = f"{self.base}/api/v2/mix/market/tickers"
  5244:    242:             params = {"productType": self.product_type}
  5245:    243:         r = self.requests.get(url, params=params, timeout=15)
  5246:    244:         r.raise_for_status()
  5247:    245:         return r.json()
  5248:    246: 
  5249:    247:     # ------------------------------------------------------------------
  5250:    248:     # Private endpoints
  5251:    249:     # ------------------------------------------------------------------
  5252:    250:     def _private_request(
  5253:    251:         self,
  5254:    252:         method: str,
  5255:    253:         path: str,
  5256:    254:         *,
  5257:    255:         params: Optional[Dict[str, Any]] = None,
  5258:    256:         body: Optional[Dict[str, Any]] = None,
  5259:    257:     ) -> Dict[str, Any]:
  5260:    258:         method = method.upper()
  5261:    259:         ts = self._ms()
  5262:    260: 
  5263:    261:         if method in ("GET", "DELETE"):
  5264:    262:             qs = self._urlencode_sorted(params or {})
  5265:    263:             req_path = path + (f"?{qs}" if qs else "")
  5266:    264:             sig = self._sign(f"{ts}{method}{req_path}")
  5267:    265:             headers = self._headers(sig, ts)
  5268:    266:             url = f"{self.base}{req_path}"
  5269:    267:             r = self.requests.request(method, url, headers=headers, timeout=20)
  5270:    268:         elif method == "POST":
  5271:    269:             qs = self._urlencode_sorted(params or {})
  5272:    270:             req_path = path + (f"?{qs}" if qs else "")
  5273:    271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
  5274:    272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
  5275:    273:             headers = self._headers(sig, ts)
  5276:    274:             url = f"{self.base}{req_path}"
  5277:    275:             r = self.requests.post(
  5278:    276:                 url,
  5279:    277:                 data=body_str.encode("utf-8"),
  5280:    278:                 headers=headers,
  5281:    279:                 timeout=20,
  5282:    280:             )
  5283:    281:         else:
  5284:    282:             raise ValueError("M\u00e9thode non support\u00e9e")
  5285:    283: 
  5286:    284:         resp_text = getattr(r, "text", "")
  5287:    285:         try:
  5288:    286:             data = r.json()
  5289:    287:         except Exception:
  5290:    288:             data = {
  5291:    289:                 "success": False,
  5292:    290:                 "error": resp_text,
  5293:    291:                 "status_code": getattr(r, "status_code", None),
  5294:    292:             }
  5295:    293: 
  5296:    294:         status = getattr(r, "status_code", 0)
  5297:    295:         if status >= 400:
  5298:    296:             code = str(data.get("code")) if isinstance(data, dict) else ""
  5299:    297:             if code == "22001":
  5300:    298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
  5301:    299:             else:
  5302:    300:                 try:
  5303:    301:                     r.raise_for_status()
  5304:    302:                 except Exception as e:
  5305:    303:                     if not resp_text:
  5306:    304:                         resp_text = getattr(r, "text", "") or str(e)
  5307:    305:                 logging.error(
  5308:    306:                     "Erreur HTTP/JSON %s %s -> %s %s",
  5309:    307:                     method,
  5310:    308:                     path,
  5311:    309:                     status,
  5312:    310:                     resp_text,
  5313:    311:                 )
  5314:    312:                 if isinstance(data, dict):
  5315:    313:                     data.setdefault("success", False)
  5316:    314:                     data.setdefault("status_code", status)
  5317:    315:                     data.setdefault("error", resp_text)
  5318:    316: 
  5319:    317:         self.log_event(
  5320:    318:             "http_private",
  5321:    319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
  5322:    320:         )
  5323:    321:         return data
  5324:    322: 
  5325:    323:     # Accounts & positions -------------------------------------------------
  5326:    324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
  5327:    325:         if self.paper_trade:
  5328:    326:             return {
  5329:    327:                 "success": True,
  5330:    328:                 "code": 0,
  5331:    329:                 "data": [
  5332:    330:                     {
  5333:    331:                         "currency": "USDT",
  5334:    332:                         "equity": 100.0,
  5335:    333:                     }
  5336:    334:                 ],
  5337:    335:             }
  5338:    336: 
  5339:    337:         params = {"productType": self.product_type}
  5340:    338:         if margin_coin is None:
  5341:    339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5342:    340:         if margin_coin:
  5343:    341:             params["marginCoin"] = margin_coin
  5344:    342:         data = self._private_request(
  5345:    343:             "GET", "/api/v2/mix/account/accounts", params=params
  5346:    344:         )
  5347:    345:         if isinstance(data, dict):
  5348:    346:             data.setdefault("success", str(data.get("code")) == "00000")
  5349:    347:         try:
  5350:    348:             for row in data.get("data", []):
  5351:    349:                 if "currency" not in row and row.get("marginCoin"):
  5352:    350:                     row["currency"] = str(row["marginCoin"]).upper()
  5353:    351:                 chosen = None
  5354:    352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
  5355:    353:                     val = row.get(key)
  5356:    354:                     if val is not None:
  5357:    355:                         chosen = val
  5358:    356:                         break
  5359:    357:                 if chosen is not None:
  5360:    358:                     row["equity"] = chosen
  5361:    359:                 try:
  5362:    360:                     row["equity"] = float(row["equity"])
  5363:    361:                 except Exception:
  5364:    362:                     pass
  5365:    363:         except Exception:  # pragma: no cover - best effort
  5366:    364:             pass
  5367:    365:         return data
  5368:    366: 
  5369:    367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  5370:    368:         if self.paper_trade:
  5371:    369:             return {"success": True, "code": 0, "data": []}
  5372:    370:         data = self._private_request(
  5373:    371:             "GET",
  5374:    372:             "/api/v2/mix/position/all-position",
  5375:    373:             params={"productType": self._product_type(product_type)},
  5376:    374:         )
  5377:    375:         try:
  5378:    376:             positions = data.get("data", [])
  5379:    377:             filtered = []
  5380:    378:             for pos in positions:
  5381:    379:                 vol = pos.get("vol")
  5382:    380:                 try:
  5383:    381:                     if vol is not None and float(vol) > 0:
  5384:    382:                         filtered.append(pos)
  5385:    383:                 except (TypeError, ValueError):
  5386:    384:                     continue
  5387:    385:             data["data"] = filtered
  5388:    386:         except Exception:  # pragma: no cover - best effort
  5389:    387:             pass
  5390:    388:         return data
  5391:    389: 
  5392:    390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  5393:    391:         if self.paper_trade:
  5394:    392:             return {"success": True, "code": 0, "data": []}
  5395:    393:         params: Dict[str, Any] = {"productType": self.product_type}
  5396:    394:         if symbol:
  5397:    395:             params["symbol"] = self._format_symbol(symbol)
  5398:    396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
  5399:    397: 
  5400:    398:     # Account configuration -------------------------------------------------
  5401:    399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
  5402:    400:         body = {
  5403:    401:             "productType": self._product_type(product_type),
  5404:    402:             "symbol": self._format_symbol(symbol),
  5405:    403:             "posMode": "one_way_mode",
  5406:    404:         }
  5407:    405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
  5408:    406: 
  5409:    407:     def set_leverage(
  5410:    408:         self,
  5411:    409:         symbol: str,
  5412:    410:         product_type: Optional[str] = None,
  5413:    411:         margin_coin: str = "USDT",
  5414:    412:         leverage: int = 1,
  5415:    413:     ) -> Dict[str, Any]:
  5416:    414:         body = {
  5417:    415:             "symbol": self._format_symbol(symbol),
  5418:    416:             "productType": self._product_type(product_type),
  5419:    417:             "marginCoin": margin_coin,
  5420:    418:             "leverage": int(leverage),
  5421:    419:         }
  5422:    420:         return self._private_request(
  5423:    421:             "POST", "/api/v2/mix/account/set-leverage", body=body
  5424:    422:         )
  5425:    423: 
  5426:    424:     def place_market_order_one_way(
  5427:    425:         self,
  5428:    426:         symbol: str,
  5429:    427:         side: str,
  5430:    428:         size: float,
  5431:    429:         product_type: Optional[str] = None,
  5432:    430:         margin_coin: str = "USDT",
  5433:    431:         *,
  5434:    432:         time_in_force: str = "normal",
  5435:    433:     ) -> Dict[str, Any]:
  5436:    434:         side = side.lower()
  5437:    435:         if side not in {"buy", "sell"}:
  5438:    436:             raise ValueError("side must be 'buy' or 'sell'")
  5439:    437:         body = {
  5440:    438:             "symbol": self._format_symbol(symbol),
  5441:    439:             "productType": self._product_type(product_type),
  5442:    440:             "marginCoin": margin_coin,
  5443:    441:             "marginMode": "crossed",
  5444:    442:             "posMode": "one_way_mode",
  5445:    443:             "orderType": "market",
  5446:    444:             "side": side,
  5447:    445:             "size": str(size),
  5448:    446:             "timeInForceValue": time_in_force,
  5449:    447:             "clientOid": str(uuid.uuid4())[:32],
  5450:    448:         }
  5451:    449:         return self._private_request(
  5452:    450:             "POST", "/api/v2/mix/order/place-order", body=body
  5453:    451:         )
  5454:    452: 
  5455:    453:     # Orders ---------------------------------------------------------------
  5456:    454:     def place_order(
  5457:    455:         self,
  5458:    456:         symbol: str,
  5459:    457:         side: int,
  5460:    458:         vol: int,
  5461:    459:         order_type: int,
  5462:    460:         *,
  5463:    461:         price: Optional[float] = None,
  5464:    462:         open_type: int = 1,
  5465:    463:         leverage: Optional[int] = None,
  5466:    464:         position_id: Optional[int] = None,
  5467:    465:         external_oid: Optional[str] = None,
  5468:    466:         stop_loss: Optional[float] = None,
  5469:    467:         take_profit: Optional[float] = None,
  5470:    468:         position_mode: Optional[int] = None,
  5471:    469:         margin_coin: Optional[str] = None,
  5472:    470:         time_in_force: str = "normal",
  5473:    471:     ) -> Dict[str, Any]:
  5474:    472:         """Submit an order.
  5475:    473: 
  5476:    474:         This helper keeps backward compatibility with the older numeric
  5477:    475:         parameters used by the bot while translating them to the string based
  5478:    476:         fields required by Bitget's v2 API.
  5479:    477:         """
  5480:    478:         if self.paper_trade:
  5481:    479:             logging.info(
  5482:    480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
  5483:    481:                 side,
  5484:    482:                 vol,
  5485:    483:                 order_type,
  5486:    484:                 price,
  5487:    485:             )
  5488:    486:             return {
  5489:    487:                 "success": True,
  5490:    488:                 "paperTrade": True,
  5491:    489:                 "simulated": {
  5492:    490:                     "symbol": symbol,
  5493:    491:                     "side": side,
  5494:    492:                     "vol": vol,
  5495:    493:                     "type": order_type,
  5496:    494:                     "price": price,
  5497:    495:                     "openType": open_type,
  5498:    496:                     "leverage": leverage,
  5499:    497:                     "stopLossPrice": stop_loss,
  5500:    498:                     "takeProfitPrice": take_profit,
  5501:    499:                 },
  5502:    500:             }
  5503:    501: 
  5504:    502:         # ------------------------------------------------------------------
  5505:    503:         # Parameter mapping
  5506:    504:         # ------------------------------------------------------------------
  5507:    505:         side_map = {
  5508:    506:             1: ("buy", "long"),
  5509:    507:             2: ("buy", "short"),
  5510:    508:             3: ("sell", "short"),
  5511:    509:             4: ("sell", "long"),
  5512:    510:         }
  5513:    511:         if isinstance(side, int):
  5514:    512:             mapped = side_map.get(side)
  5515:    513:             if not mapped:
  5516:    514:                 raise ValueError(f"Invalid side value: {side}")
  5517:    515:             side_str, pos_side = mapped
  5518:    516:         else:
  5519:    517:             side_str = str(side)
  5520:    518:             pos_side = None
  5521:    519: 
  5522:    520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
  5523:    521:         if isinstance(order_type, int):
  5524:    522:             order_str = order_map.get(order_type)
  5525:    523:             if order_str is None:
  5526:    524:                 order_str = "limit" if price is not None else "market"
  5527:    525:         else:
  5528:    526:             order_str = str(order_type)
  5529:    527: 
  5530:    528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
  5531:    529: 
  5532:    530:         if margin_coin is None:
  5533:    531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5534:    532: 
  5535:    533:         # ------------------------------------------------------------------
  5536:    534:         # Precision handling
  5537:    535:         # ------------------------------------------------------------------
  5538:    536:         try:
  5539:    537:             price_place, volume_place = self._get_contract_precision(symbol)
  5540:    538:         except Exception:  # pragma: no cover - best effort
  5541:    539:             price_place = volume_place = 0
  5542:    540:         if price is not None:
  5543:    541:             price = round(float(price), price_place)
  5544:    542:         if vol is not None:
  5545:    543:             vol = round(float(vol), volume_place)
  5546:    544: 
  5547:    545:         body = {
  5548:    546:             "symbol": self._format_symbol(symbol),
  5549:    547:             "productType": self.product_type,
  5550:    548:             "marginMode": margin_mode,
  5551:    549:             "orderType": order_str,
  5552:    550:             "side": side_str,
  5553:    551:             "size": vol,
  5554:    552:             "timeInForceValue": time_in_force,
  5555:    553:         }
  5556:    554:         if pos_side is not None:
  5557:    555:             body["posSide"] = pos_side
  5558:    556:         if margin_coin:
  5559:    557:             body["marginCoin"] = margin_coin
  5560:    558:         if price is not None:
  5561:    559:             body["price"] = float(price)
  5562:    560:         if leverage is not None:
  5563:    561:             body["leverage"] = int(leverage)
  5564:    562:         if position_id is not None:
  5565:    563:             body["positionId"] = int(position_id)
  5566:    564:         if external_oid:
  5567:    565:             body["clientOid"] = str(external_oid)[:32]
  5568:    566:         else:
  5569:    567:             body["clientOid"] = str(uuid.uuid4())[:32]
  5570:    568:         if stop_loss is not None:
  5571:    569:             body["stopLossPrice"] = float(stop_loss)
  5572:    570:         if take_profit is not None:
  5573:    571:             body["takeProfitPrice"] = float(take_profit)
  5574:    572:         if position_mode is not None:
  5575:    573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
  5576:    574:         elif pos_side is not None:
  5577:    575:             body["posMode"] = "hedge_mode"
  5578:    576: 
  5579:    577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
  5580:    578: 
  5581:    579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
  5582:    580:         if self.paper_trade:
  5583:    581:             logging.info(
  5584:    582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
  5585:    583:             )
  5586:    584:             return {"success": True, "code": 0}
  5587:    585:         return self._private_request(
  5588:    586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
  5589:    587:         )
  5590:    588: 
  5591:    589:     def cancel_all(
  5592:    590:         self,
  5593:    591:         symbol: Optional[str] = None,
  5594:    592:         margin_coin: Optional[str] = None,
  5595:    593:     ) -> Dict[str, Any]:
  5596:    594:         if self.paper_trade:
  5597:    595:             logging.info(
  5598:    596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
  5599:    597:             )
  5600:    598:             return {"success": True, "code": 0}
  5601:    599:         body = {"productType": self.product_type}
  5602:    600:         if symbol:
  5603:    601:             body["symbol"] = self._format_symbol(symbol)
  5604:    602:         if margin_coin is None:
  5605:    603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  5606:    604:         if margin_coin:
  5607:    605:             body["marginCoin"] = margin_coin
  5608:    606:         return self._private_request(
  5609:    607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
  5610:    608:         )
  5611:    609: 
  5612:    610:     def close_position(
  5613:    611:         self,
  5614:    612:         symbol: str,
  5615:    613:         size: Optional[int] = None,
  5616:    614:         hold_side: Optional[str] = None,
  5617:    615:     ) -> Dict[str, Any]:
  5618:    616:         """Close an open position for ``symbol``.
  5619:    617: 
  5620:    618:         Parameters
  5621:    619:         ----------
  5622:    620:         symbol:
  5623:    621:             Trading symbol to close.
  5624:    622:         size:
  5625:    623:             Optional number of contracts to close. If omitted the entire
  5626:    624:             position is closed.
  5627:    625:         hold_side:
  5628:    626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
  5629:    627:             specified. If not provided the exchange will infer it.
  5630:    628:         """
  5631:    629: 
  5632:    630:         if self.paper_trade:
  5633:    631:             logging.info(
  5634:    632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
  5635:    633:             )
  5636:    634:             return {"success": True, "code": 0}
  5637:    635: 
  5638:    636:         body = {"symbol": self._format_symbol(symbol)}
  5639:    637:         if size is not None:
  5640:    638:             body["size"] = int(size)
  5641:    639:         if hold_side:
  5642:    640:             body["holdSide"] = hold_side
  5643:    641: 
  5644:    642:         body["productType"] = self.product_type
  5645:    643:         return self._private_request(
  5646:    644:             "POST", "/api/v2/mix/position/close-position", body=body
  5647:    645:         )
  5648:    646: 
  5649:    647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  5650:    648:         """Close all open positions."""
  5651:    649:         results = []
  5652:    650:         try:
  5653:    651:             for pos in self.get_positions(product_type).get("data", []):
  5654:    652:                 sym = pos.get("symbol")
  5655:    653:                 if sym:
  5656:    654:                     results.append(self.close_position(sym))
  5657:    655:         except Exception as exc:  # pragma: no cover - best effort
  5658:    656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
  5659:    657:         return {"success": True, "data": results}
  5660: 
  5661: 
  5662: ## scalper/client.py (last modified: 2025-08-23 20:57:14)
  5663:      1: import logging
  5664:      2: from typing import Any, Dict, Optional
  5665:      3: 
  5666:      4: import requests
  5667:      5: from requests.adapters import HTTPAdapter
  5668:      6: from urllib3.util.retry import Retry
  5669:      7: 
  5670:      8: 
  5671:      9: class HTTPError(RuntimeError):
  5672:     10:     """Raised when an HTTP request fails"""
  5673:     11: 
  5674:     12: 
  5675:     13: class HttpClient:
  5676:     14:     """Simple HTTP client with persistent session and retry logic.
  5677:     15: 
  5678:     16:     The client exposes a :py:meth:`close` method and implements the context
  5679:     17:     manager protocol so it can be used with ``with`` statements to ensure
  5680:     18:     that the underlying :class:`requests.Session` is properly closed.
  5681:     19:     """
  5682:     20: 
  5683:     21:     def __init__(
  5684:     22:         self,
  5685:     23:         base_url: str,
  5686:     24:         *,
  5687:     25:         timeout: float = 10.0,
  5688:     26:         max_retries: int = 3,
  5689:     27:         backoff_factor: float = 0.3,
  5690:     28:         status_forcelist: Optional[list[int]] = None,
  5691:     29:     ) -> None:
  5692:     30:         self.base_url = base_url.rstrip("/")
  5693:     31:         self.timeout = timeout
  5694:     32:         self.session = requests.Session()
  5695:     33:         retry = Retry(
  5696:     34:             total=max_retries,
  5697:     35:             backoff_factor=backoff_factor,
  5698:     36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
  5699:     37:             allowed_methods=[
  5700:     38:                 "HEAD",
  5701:     39:                 "GET",
  5702:     40:                 "OPTIONS",
  5703:     41:                 "POST",
  5704:     42:                 "PUT",
  5705:     43:                 "DELETE",
  5706:     44:                 "PATCH",
  5707:     45:             ],
  5708:     46:         )
  5709:     47:         adapter = HTTPAdapter(max_retries=retry)
  5710:     48:         self.session.mount("http://", adapter)
  5711:     49:         self.session.mount("https://", adapter)
  5712:     50: 
  5713:     51:     def close(self) -> None:
  5714:     52:         """Close the underlying :class:`requests.Session`."""
  5715:     53:         self.session.close()
  5716:     54: 
  5717:     55:     # ------------------------------------------------------------------
  5718:     56:     # Context manager support
  5719:     57:     # ------------------------------------------------------------------
  5720:     58:     def __enter__(self) -> "HttpClient":
  5721:     59:         return self
  5722:     60: 
  5723:     61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
  5724:     62:         self.close()
  5725:     63: 
  5726:     64:     def request(
  5727:     65:         self,
  5728:     66:         method: str,
  5729:     67:         path: str,
  5730:     68:         *,
  5731:     69:         params: Optional[Dict[str, Any]] = None,
  5732:     70:         json: Optional[Dict[str, Any]] = None,
  5733:     71:         headers: Optional[Dict[str, str]] = None,
  5734:     72:     ) -> Dict[str, Any]:
  5735:     73:         """Perform an HTTP request and return JSON data.
  5736:     74: 
  5737:     75:         Errors during the request raise ``HTTPError``. If the response cannot
  5738:     76:         be decoded as JSON, a dictionary describing the issue is returned.
  5739:     77:         """
  5740:     78:         url = f"{self.base_url}{path}"
  5741:     79:         try:
  5742:     80:             resp = self.session.request(
  5743:     81:                 method,
  5744:     82:                 url,
  5745:     83:                 params=params,
  5746:     84:                 json=json,
  5747:     85:                 headers=headers,
  5748:     86:                 timeout=self.timeout,
  5749:     87:             )
  5750:     88:             resp.raise_for_status()
  5751:     89:         except requests.RequestException as exc:  # network or HTTP errors
  5752:     90:             msg = f"HTTP error calling {url}: {exc}"
  5753:     91:             logging.error(msg)
  5754:     92:             raise HTTPError(msg) from exc
  5755:     93: 
  5756:     94:         try:
  5757:     95:             return resp.json()
  5758:     96:         except ValueError:  # invalid JSON
  5759:     97:             msg = "Invalid JSON in response"
  5760:     98:             logging.error("%s for %s: %s", msg, url, resp.text)
  5761:     99:             return {"success": False, "error": msg, "text": resp.text}
  5762: 
  5763: 
  5764: ## scalper/config/__init__.py (last modified: 2025-08-23 20:57:14)
  5765:      1: from .loader import load_settings
  5766:      2: __all__ = ['load_settings']
  5767: 
  5768: 
  5769: ## scalper/config/loader.py (last modified: 2025-08-23 20:57:14)
  5770:      1: # scalp/config/loader.py
  5771:      2: from __future__ import annotations
  5772:      3: import os, json
  5773:      4: from typing import Any, Dict, Tuple
  5774:      5: 
  5775:      6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
  5776:      7: try:
  5777:      8:     import yaml  # type: ignore
  5778:      9: except Exception:
  5779:     10:     yaml = None  # fallback JSON si besoin
  5780:     11: 
  5781:     12: # dotenv (facultatif) pour charger un .env automatiquement
  5782:     13: try:
  5783:     14:     from dotenv import load_dotenv  # type: ignore
  5784:     15: except Exception:
  5785:     16:     load_dotenv = None
  5786:     17: 
  5787:     18: # ---------------- Utils ----------------
  5788:     19: 
  5789:     20: def _parse_bool(x: Any, default: bool = False) -> bool:
  5790:     21:     if isinstance(x, bool): return x
  5791:     22:     s = str(x).strip().lower()
  5792:     23:     if s in ("1","true","yes","y","on"): return True
  5793:     24:     if s in ("0","false","no","n","off",""): return False
  5794:     25:     return default
  5795:     26: 
  5796:     27: def _parse_float(x: Any, default: float | None = None) -> float | None:
  5797:     28:     try: return float(x)
  5798:     29:     except Exception: return default
  5799:     30: 
  5800:     31: def _parse_int(x: Any, default: int | None = None) -> int | None:
  5801:     32:     try: return int(str(x).strip())
  5802:     33:     except Exception: return default
  5803:     34: 
  5804:     35: def _parse_csv(x: Any) -> list[str]:
  5805:     36:     if x is None: return []
  5806:     37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
  5807:     38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
  5808:     39: 
  5809:     40: def _read_yaml(path: str) -> Dict[str, Any]:
  5810:     41:     if not os.path.exists(path): return {}
  5811:     42:     with open(path, "r", encoding="utf-8") as f:
  5812:     43:         if yaml:
  5813:     44:             return yaml.safe_load(f) or {}
  5814:     45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
  5815:     46:         try:
  5816:     47:             return json.load(f)
  5817:     48:         except Exception:
  5818:     49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
  5819:     50: 
  5820:     51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
  5821:     52:     # shallow merge suffisant ici (structure plate)
  5822:     53:     out = dict(a)
  5823:     54:     out.update({k: v for k, v in b.items() if v is not None})
  5824:     55:     return out
  5825:     56: 
  5826:     57: # ---------------- Public API ----------------
  5827:     58: 
  5828:     59: def load_settings(
  5829:     60:     config_path: str = "config.yml",
  5830:     61:     config_local_path: str = "config.local.yml",
  5831:     62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
  5832:     63:     """
  5833:     64:     Retourne (config_runtime, secrets) :
  5834:     65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
  5835:     66:       - secrets        : clés API & tokens (NE PAS versionner)
  5836:     67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
  5837:     68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
  5838:     69:     """
  5839:     70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
  5840:     71:     if load_dotenv is not None:
  5841:     72:         load_dotenv(override=False)
  5842:     73: 
  5843:     74:     # 2) Charge YAML (config.yml + override local)
  5844:     75:     base = _read_yaml(config_path)
  5845:     76:     local = _read_yaml(config_local_path)
  5846:     77:     cfg = _merge_dict(base, local)
  5847:     78: 
  5848:     79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
  5849:     80:     env_overlay: Dict[str, Any] = {}
  5850:     81:     # Verbosité
  5851:     82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
  5852:     83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
  5853:     84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
  5854:     85:     # Runtime / Stratégie
  5855:     86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
  5856:     87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
  5857:     88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
  5858:     89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
  5859:     90:     # Watchlist
  5860:     91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
  5861:     92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
  5862:     93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
  5863:     94:     )
  5864:     95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
  5865:     96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
  5866:     97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
  5867:     98:     caps_env = os.getenv("CAPS_JSON")
  5868:     99:     if caps_env:
  5869:    100:         try:
  5870:    101:             env_overlay["CAPS"] = json.loads(caps_env)
  5871:    102:         except Exception:
  5872:    103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
  5873:    104:     else:
  5874:    105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
  5875:    106: 
  5876:    107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
  5877:    108:     secrets = {
  5878:    109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
  5879:    110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
  5880:    111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
  5881:    112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
  5882:    113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
  5883:    114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
  5884:    115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
  5885:    116:     }
  5886:    117: 
  5887:    118:     # 5) Runtime normalisé pour l’orchestrateur
  5888:    119:     runtime = {
  5889:    120:         "quiet": bool(env_overlay["QUIET"]),
  5890:    121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
  5891:    122:         "timeframe": str(env_overlay["TIMEFRAME"]),
  5892:    123:         "cash": float(env_overlay["CASH"]),
  5893:    124:         "risk_pct": float(env_overlay["RISK_PCT"]),
  5894:    125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
  5895:    126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
  5896:    127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
  5897:    128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
  5898:    129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
  5899:    130:         "caps": env_overlay["CAPS"],                        # dict
  5900:    131:         # rempli au boot par les frais Bitget
  5901:    132:         "fees_by_symbol": {}, 
  5902:    133:     }
  5903:    134: 
  5904:    135:     return runtime, secrets
  5905:    136:     
  5906: 
  5907: ## scalper/exchange/__init__.py (last modified: 2025-08-23 20:57:14)
  5908:      1: # package
  5909: 
  5910: 
  5911: ## scalper/exchange/bitget_ccxt.py (last modified: 2025-08-23 20:57:14)
  5912:      1: # scalper/exchange/bitget_ccxt.py
  5913:      2: from __future__ import annotations
  5914:      3: 
  5915:      4: import asyncio
  5916:      5: import csv
  5917:      6: import os
  5918:      7: import time
  5919:      8: from typing import Any, List, Optional
  5920:      9: 
  5921:     10: # CCXT async
  5922:     11: try:
  5923:     12:     import ccxt.async_support as ccxt
  5924:     13: except Exception as e:  # noqa: BLE001
  5925:     14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
  5926:     15: 
  5927:     16: 
  5928:     17: def _now_ms() -> int:
  5929:     18:     return int(time.time() * 1000)
  5930:     19: 
  5931:     20: 
  5932:     21: class BitgetExchange:
  5933:     22:     """
  5934:     23:     Échange Bitget via CCXT (async) avec cache CSV local.
  5935:     24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
  5936:     25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
  5937:     26:         [[ts, open, high, low, close, volume], ...]
  5938:     27:     """
  5939:     28: 
  5940:     29:     def __init__(
  5941:     30:         self,
  5942:     31:         *,
  5943:     32:         api_key: Optional[str] = None,
  5944:     33:         secret: Optional[str] = None,
  5945:     34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
  5946:     35:         data_dir: str = "/notebooks/data",
  5947:     36:         use_cache: bool = True,
  5948:     37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
  5949:     38:         spot: bool = True,           # True = SPOT (recommandé ici)
  5950:     39:     ) -> None:
  5951:     40:         self.data_dir = data_dir
  5952:     41:         self.use_cache = use_cache
  5953:     42:         self.min_fresh = int(min_fresh_seconds)
  5954:     43:         self.spot = spot
  5955:     44: 
  5956:     45:         os.makedirs(self.data_dir, exist_ok=True)
  5957:     46: 
  5958:     47:         # Instance CCXT (async)
  5959:     48:         self.ex = ccxt.bitget({
  5960:     49:             "apiKey": api_key or "",
  5961:     50:             "secret": secret or "",
  5962:     51:             "password": password or "",
  5963:     52:             "enableRateLimit": True,
  5964:     53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
  5965:     54:         })
  5966:     55: 
  5967:     56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
  5968:     57:         self._markets_task: Optional[asyncio.Task[Any]] = None
  5969:     58: 
  5970:     59:     async def _ensure_markets(self) -> None:
  5971:     60:         if self._markets_task is None:
  5972:     61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
  5973:     62:         await self._markets_task
  5974:     63: 
  5975:     64:     # ---------- CSV cache ----------
  5976:     65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
  5977:     66:         safe = symbol.replace("/", "").replace(":", "")
  5978:     67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
  5979:     68: 
  5980:     69:     def _read_cache(self, path: str) -> List[List[float]]:
  5981:     70:         if not os.path.exists(path):
  5982:     71:             return []
  5983:     72:         rows: List[List[float]] = []
  5984:     73:         try:
  5985:     74:             with open(path, "r", newline="") as f:
  5986:     75:                 rd = csv.reader(f)
  5987:     76:                 for r in rd:
  5988:     77:                     if not r:
  5989:     78:                         continue
  5990:     79:                     # ts, o, h, l, c, v
  5991:     80:                     try:
  5992:     81:                         rows.append([
  5993:     82:                             int(r[0]),
  5994:     83:                             float(r[1]),
  5995:     84:                             float(r[2]),
  5996:     85:                             float(r[3]),
  5997:     86:                             float(r[4]),
  5998:     87:                             float(r[5]),
  5999:     88:                         ])
  6000:     89:                     except Exception:
  6001:     90:                         # on ignore les lignes corrompues
  6002:     91:                         continue
  6003:     92:         except Exception:
  6004:     93:             return []
  6005:     94:         return rows
  6006:     95: 
  6007:     96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
  6008:     97:         # On ré‑écrit intégralement (simple et sûr)
  6009:     98:         tmp = path + ".tmp"
  6010:     99:         with open(tmp, "w", newline="") as f:
  6011:    100:             wr = csv.writer(f)
  6012:    101:             wr.writerows(data)
  6013:    102:         os.replace(tmp, path)
  6014:    103: 
  6015:    104:     # ---------- API publique pour orchestrateur ----------
  6016:    105:     async def fetch_ohlcv(
  6017:    106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
  6018:    107:     ) -> List[List[float]]:
  6019:    108:         """
  6020:    109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
  6021:    110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
  6022:    111:         """
  6023:    112:         await self._ensure_markets()
  6024:    113: 
  6025:    114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
  6026:    115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
  6027:    116:         cache_path = self._csv_path(symbol, timeframe)
  6028:    117: 
  6029:    118:         # 1) Cache
  6030:    119:         if self.use_cache:
  6031:    120:             cached = self._read_cache(cache_path)
  6032:    121:             if cached:
  6033:    122:                 # fraicheur = diff entre maintenant et ts dernière bougie
  6034:    123:                 last_ts = int(cached[-1][0])
  6035:    124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
  6036:    125:                     # suffisant => on retourne la fin
  6037:    126:                     if len(cached) >= limit:
  6038:    127:                         return cached[-limit:]
  6039:    128:                     # pas assez, on essaiera de compléter via CCXT plus bas
  6040:    129:                 # sinon: on tentera de rafraîchir plus loin
  6041:    130: 
  6042:    131:         # 2) Remote via CCXT
  6043:    132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
  6044:    133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
  6045:    134:         params: dict[str, Any] = {}
  6046:    135:         if self.spot is True:
  6047:    136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
  6048:    137: 
  6049:    138:         try:
  6050:    139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
  6051:    140:         except Exception as e:  # noqa: BLE001
  6052:    141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
  6053:    142:             cached = self._read_cache(cache_path) if self.use_cache else []
  6054:    143:             if cached:
  6055:    144:                 return cached[-limit:]
  6056:    145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
  6057:    146: 
  6058:    147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
  6059:    148:         if self.use_cache:
  6060:    149:             base = self._read_cache(cache_path)
  6061:    150:             merged = _merge_ohlcv(base, ohlcv)
  6062:    151:             self._write_cache(cache_path, merged)
  6063:    152:             # retourne la fin
  6064:    153:             return merged[-limit:]
  6065:    154: 
  6066:    155:         return ohlcv[-limit:]
  6067:    156: 
  6068:    157:     async def close(self) -> None:
  6069:    158:         try:
  6070:    159:             await self.ex.close()
  6071:    160:         except Exception:
  6072:    161:             pass
  6073:    162: 
  6074:    163: 
  6075:    164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
  6076:    165:     """
  6077:    166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
  6078:    167:     """
  6079:    168:     if not a:
  6080:    169:         return list(b)
  6081:    170:     if not b:
  6082:    171:         return list(a)
  6083:    172: 
  6084:    173:     # index rapide par ts
  6085:    174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
  6086:    175:     for row in b:
  6087:    176:         by_ts[int(row[0])] = row
  6088:    177:     return [by_ts[k] for k in sorted(by_ts)]
  6089: 
  6090: ## scalper/exchange/fees.py (last modified: 2025-08-23 20:57:14)
  6091:      1: # scalper/exchange/fees.py
  6092:      2: from __future__ import annotations
  6093:      3: 
  6094:      4: from typing import Dict, Iterable
  6095:      5: 
  6096:      6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
  6097:      7: DEFAULT_TAKER_BPS = 6    # 0.06%
  6098:      8: DEFAULT_MAKER_BPS = 2    # 0.02%
  6099:      9: 
  6100:     10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
  6101:     11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
  6102:     12: 
  6103:     13: 
  6104:     14: def get_fee(symbol: str, kind: str = "taker") -> float:
  6105:     15:     """
  6106:     16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
  6107:     17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
  6108:     18:     """
  6109:     19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
  6110:     20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
  6111:     21:     return float(bps) / 10_000.0
  6112:     22: 
  6113:     23: 
  6114:     24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
  6115:     25:     """
  6116:     26:     Tente de charger les frais auprès de l'exchange (type ccxt):
  6117:     27:       - fetch_trading_fees(symbols) si dispo
  6118:     28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
  6119:     29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
  6120:     30:     """
  6121:     31:     symbols = list(symbols)
  6122:     32:     fees: Dict[str, Dict[str, float]] = {}
  6123:     33: 
  6124:     34:     try:
  6125:     35:         if hasattr(exchange, "fetch_trading_fees"):
  6126:     36:             data = await exchange.fetch_trading_fees(symbols)
  6127:     37:             for s in symbols:
  6128:     38:                 d = (data or {}).get(s, {}) or {}
  6129:     39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  6130:     40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  6131:     41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  6132:     42:         else:
  6133:     43:             for s in symbols:
  6134:     44:                 try:
  6135:     45:                     d = await exchange.fetch_trading_fee(s)
  6136:     46:                 except Exception:
  6137:     47:                     d = {}
  6138:     48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  6139:     49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  6140:     50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  6141:     51:     except Exception:
  6142:     52:         # fallback: défauts
  6143:     53:         for s in symbols:
  6144:     54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
  6145:     55: 
  6146:     56:     # maj du cache
  6147:     57:     _FEES_BY_SYMBOL.update(fees)
  6148:     58:     return fees
  6149: 
  6150: ## scalper/hooks/prewarm_cache.py (last modified: 2025-08-24 03:12:00)
  6151:      1: # -*- coding: utf-8 -*-
  6152:      2: """
  6153:      3: Pré-chauffe léger du cache OHLCV.
  6154:      4: 
  6155:      5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
  6156:      6: pour chaque symbole, et on s'assure que le dossier data existe.
  6157:      7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
  6158:      8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
  6159:      9: signature.
  6160:     10: """
  6161:     11: from __future__ import annotations
  6162:     12: from pathlib import Path
  6163:     13: from typing import Iterable
  6164:     14: 
  6165:     15: 
  6166:     16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
  6167:     17:     out = Path(out_dir)
  6168:     18:     out.mkdir(parents=True, exist_ok=True)
  6169:     19:     for sym in symbols:
  6170:     20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
  6171:     21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
  6172:     22:         print(f"[cache] warmup OK for {sym}")
  6173: 
  6174: ## scalper/live/__init__.py (last modified: 2025-08-24 03:12:00)
  6175:      1: from .orchestrator import RunConfig, Orchestrator, run_orchestrator  # re‑exports
  6176:      2: from .notify import build_notifier_and_commands  # utile pour bot.py
  6177: 
  6178: ## scalper/live/backtest_telegram.py (last modified: 2025-08-23 20:57:14)
  6179:      1: # scalper/live/backtest_telegram.py
  6180:      2: from __future__ import annotations
  6181:      3: 
  6182:      4: import asyncio
  6183:      5: import os
  6184:      6: from typing import List
  6185:      7: 
  6186:      8: from scalper.backtest import BTCfg, run_multi
  6187:      9: from scalper.services.utils import safe_call
  6188:     10: 
  6189:     11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
  6190:     12: async def _get_exchange():
  6191:     13:     try:
  6192:     14:         import ccxt.async_support as ccxt  # type: ignore
  6193:     15:     except Exception:
  6194:     16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
  6195:     17:     return ccxt.bitget()
  6196:     18: 
  6197:     19: def _parse_symbols(defaults: List[str]) -> List[str]:
  6198:     20:     env = os.getenv("BACKTEST_SYMBOLS", "")
  6199:     21:     if env.strip():
  6200:     22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
  6201:     23:     return defaults
  6202:     24: 
  6203:     25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
  6204:     26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
  6205:     27:     symbols = _parse_symbols(defaults)
  6206:     28:     cash = float(os.getenv("BT_CASH", "10000"))
  6207:     29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
  6208:     30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
  6209:     31:     limit = int(os.getenv("BT_LIMIT", "1500"))
  6210:     32: 
  6211:     33:     await notifier.send(
  6212:     34:         "🧪 Backtest en cours...\n"
  6213:     35:         f"• Symbols: {', '.join(symbols)}\n"
  6214:     36:         f"• TF: {timeframe}\n"
  6215:     37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
  6216:     38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
  6217:     39:     )
  6218:     40: 
  6219:     41:     async def _run():
  6220:     42:         exchange = await _get_exchange()
  6221:     43:         try:
  6222:     44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
  6223:     45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
  6224:     46:             res = await run_multi(cfg, exchange)
  6225:     47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
  6226:     48:         finally:
  6227:     49:             try:
  6228:     50:                 await exchange.close()
  6229:     51:             except Exception:
  6230:     52:                 pass
  6231:     53: 
  6232:     54:     try:
  6233:     55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
  6234:     56:     except Exception as e:
  6235:     57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")
  6236: 
  6237: ## scalper/live/commands.py (last modified: 2025-08-23 20:57:14)
  6238:      1: # scalper/live/commands.py
  6239:      2: from __future__ import annotations
  6240:      3: 
  6241:      4: import asyncio
  6242:      5: from typing import Awaitable, Callable
  6243:      6: 
  6244:      7: 
  6245:      8: class CommandHandler:
  6246:      9:     """
  6247:     10:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
  6248:     11:     Chaque commande est routée vers un callback approprié.
  6249:     12:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
  6250:     13:     """
  6251:     14: 
  6252:     15:     def __init__(self, notifier, command_stream, status_getter, status_sender):
  6253:     16:         self.notifier = notifier
  6254:     17:         self.stream = command_stream
  6255:     18:         self.status_getter = status_getter
  6256:     19:         self.status_sender = status_sender
  6257:     20: 
  6258:     21:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
  6259:     22:         try:
  6260:     23:             await coro
  6261:     24:         except Exception as e:
  6262:     25:             try:
  6263:     26:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
  6264:     27:             except Exception:
  6265:     28:                 pass  # on ne propage jamais
  6266:     29: 
  6267:     30:     async def run(
  6268:     31:         self,
  6269:     32:         on_pause: Callable[[], None],
  6270:     33:         on_resume: Callable[[], None],
  6271:     34:         on_stop: Callable[[], Awaitable[None]] | None,
  6272:     35:         on_setup_apply: Callable[[dict], None],
  6273:     36:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
  6274:     37:     ):
  6275:     38:         """
  6276:     39:         Boucle asynchrone qui lit les lignes du CommandStream
  6277:     40:         et exécute le callback approprié.
  6278:     41:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
  6279:     42:         """
  6280:     43:         async for line in self.stream:
  6281:     44:             txt = (line or "").strip()
  6282:     45:             if not txt:
  6283:     46:                 continue
  6284:     47: 
  6285:     48:             try:
  6286:     49:                 if txt.startswith("/pause"):
  6287:     50:                     on_pause()
  6288:     51:                     await self.notifier.send("⏸️ Pause.")
  6289:     52: 
  6290:     53:                 elif txt.startswith("/resume"):
  6291:     54:                     on_resume()
  6292:     55:                     await self.notifier.send("▶️ Resume.")
  6293:     56: 
  6294:     57:                 elif txt.startswith("/stop"):
  6295:     58:                     if on_stop:
  6296:     59:                         await self._safe_call(on_stop(), "Arrêt échoué")
  6297:     60: 
  6298:     61:                 elif txt.startswith("/status"):
  6299:     62:                     snap = self.status_getter()
  6300:     63:                     await self.notifier.send(f"ℹ️ {snap}")
  6301:     64: 
  6302:     65:                 elif txt.startswith("/setup"):
  6303:     66:                     await self.notifier.send("🧩 Setup wizard à compléter.")
  6304:     67: 
  6305:     68:                 elif txt.startswith("/backtest"):
  6306:     69:                     if on_backtest:
  6307:     70:                         tail = txt[len("/backtest"):].strip()
  6308:     71:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
  6309:     72:                         asyncio.create_task(self._safe_call(
  6310:     73:                             on_backtest(tail), "Backtest échoué"
  6311:     74:                         ))
  6312:     75:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
  6313:     76:                     else:
  6314:     77:                         await self.notifier.send("⚠️ Backtest non disponible.")
  6315:     78: 
  6316:     79:                 else:
  6317:     80:                     await self.notifier.send(
  6318:     81:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
  6319:     82:                     )
  6320:     83: 
  6321:     84:             except Exception as e:
  6322:     85:                 # On protège la boucle quoi qu'il arrive
  6323:     86:                 try:
  6324:     87:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
  6325:     88:                 except Exception:
  6326:     89:                     pass
  6327: 
  6328: ## scalper/live/journal.py (last modified: 2025-08-23 20:57:14)
  6329:      1: from __future__ import annotations
  6330:      2: import os, csv
  6331:      3: from typing import Any, Dict, List
  6332:      4: 
  6333:      5: class LogWriter:
  6334:      6:     """Gestion simple des CSV (création à la volée + append)."""
  6335:      7:     def __init__(self, dirpath: str) -> None:
  6336:      8:         self.dir = dirpath
  6337:      9:         os.makedirs(self.dir, exist_ok=True)
  6338:     10: 
  6339:     11:     def init(self, fname: str, headers: List[str]) -> None:
  6340:     12:         p = os.path.join(self.dir, fname)
  6341:     13:         if not os.path.exists(p):
  6342:     14:             with open(p, "w", newline="", encoding="utf-8") as f:
  6343:     15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
  6344:     16: 
  6345:     17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
  6346:     18:         p = os.path.join(self.dir, fname)
  6347:     19:         with open(p, "a", newline="", encoding="utf-8") as f:
  6348:     20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)
  6349: 
  6350: ## scalper/live/logs.py (last modified: 2025-08-23 20:57:14)
  6351:      1: # scalp/live/logs.py
  6352:      2: from __future__ import annotations
  6353:      3: import os, csv
  6354:      4: from typing import Any, List, Dict
  6355:      5: 
  6356:      6: class CsvLog:
  6357:      7:     def __init__(self, path: str, headers: List[str]):
  6358:      8:         self.path = path
  6359:      9:         self.headers = headers
  6360:     10:         self._ensure_header()
  6361:     11: 
  6362:     12:     def _ensure_header(self):
  6363:     13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
  6364:     14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
  6365:     15:         if must_write:
  6366:     16:             with open(self.path, "w", newline="") as f:
  6367:     17:                 csv.writer(f).writerow(self.headers)
  6368:     18: 
  6369:     19:     def write_row(self, row: Dict[str, Any]):
  6370:     20:         with open(self.path, "a", newline="") as f:
  6371:     21:             w = csv.DictWriter(f, fieldnames=self.headers)
  6372:     22:             w.writerow({k: row.get(k, "") for k in self.headers})
  6373: 
  6374: ## scalper/live/loops/trade.py (last modified: 2025-08-23 20:57:14)
  6375:      1: # scalp/live/loops/trade.py
  6376:      2: from __future__ import annotations
  6377:      3: import asyncio, os
  6378:      4: from dataclasses import dataclass, field
  6379:      5: from typing import Any, Dict, List, Callable
  6380:      6: 
  6381:      7: from ...services.utils import safe_call
  6382:      8: from ...risk.manager import compute_size
  6383:      9: 
  6384:     10: QUIET = int(os.getenv("QUIET", "0") or "0")
  6385:     11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
  6386:     12: 
  6387:     13: class PositionFSM:
  6388:     14:     def __init__(self):
  6389:     15:         self.state = "FLAT"
  6390:     16:         self.side = "flat"
  6391:     17:         self.entry = 0.0
  6392:     18:         self.qty = 0.0
  6393:     19:     def can_open(self): return self.state == "FLAT"
  6394:     20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
  6395:     21:     def can_close(self): return self.state == "OPEN"
  6396:     22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
  6397:     23: 
  6398:     24: @dataclass
  6399:     25: class SymbolContext:
  6400:     26:     symbol: str
  6401:     27:     timeframe: str
  6402:     28:     ohlcv: List[List[float]] = field(default_factory=list)
  6403:     29:     ticks: int = 0
  6404:     30:     fsm: PositionFSM = field(default_factory=PositionFSM)
  6405:     31: 
  6406:     32: class TradeLoop:
  6407:     33:     """
  6408:     34:     Boucle par symbole, indépendante de l'orchestrateur.
  6409:     35:     """
  6410:     36:     def __init__(
  6411:     37:         self,
  6412:     38:         symbol: str,
  6413:     39:         timeframe: str,
  6414:     40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
  6415:     41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
  6416:     42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
  6417:     43:         config: Dict[str, Any],
  6418:     44:         mode_getter: Callable[[], str],
  6419:     45:         log_signals, log_orders, log_fills,
  6420:     46:         tick_counter_add: Callable[[int], None],
  6421:     47:     ):
  6422:     48:         self.symbol = symbol
  6423:     49:         self.timeframe = timeframe
  6424:     50:         self.fetch = ohlcv_fetch
  6425:     51:         self.order_market = order_market
  6426:     52:         self.generate_signal = generate_signal
  6427:     53:         self.config = config
  6428:     54:         self.get_mode = mode_getter
  6429:     55:         self.log_signals = log_signals
  6430:     56:         self.log_orders = log_orders
  6431:     57:         self.log_fills = log_fills
  6432:     58:         self.ctx = SymbolContext(symbol, timeframe)
  6433:     59:         self._tick_add = tick_counter_add
  6434:     60: 
  6435:     61:         # Risk/frais
  6436:     62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
  6437:     63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
  6438:     64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
  6439:     65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
  6440:     66: 
  6441:     67:     def _bps_for(self, order_type: str = "market") -> float:
  6442:     68:         # market -> taker; limit post-only -> maker
  6443:     69:         per = self.fees_map.get(self.symbol, {})
  6444:     70:         if order_type == "limit":
  6445:     71:             return float(per.get("maker_bps", 0.0))
  6446:     72:         return float(per.get("taker_bps", 0.0))
  6447:     73: 
  6448:     74:     async def run(self, running: Callable[[], bool]):
  6449:     75:         lookback = 200
  6450:     76:         while running():
  6451:     77:             if self.get_mode() != "RUNNING":
  6452:     78:                 await asyncio.sleep(0.5); continue
  6453:     79: 
  6454:     80:             async def _fetch():
  6455:     81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
  6456:     82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
  6457:     83:             if not ohlcv or len(ohlcv) < lookback+1:
  6458:     84:                 await asyncio.sleep(1.0); continue
  6459:     85: 
  6460:     86:             self.ctx.ohlcv = ohlcv
  6461:     87:             self.ctx.ticks += 1
  6462:     88:             self._tick_add(1)
  6463:     89: 
  6464:     90:             window = ohlcv[-(lookback+1):]
  6465:     91:             ts, _o, _h, _l, c, _v = window[-1]
  6466:     92: 
  6467:     93:             try:
  6468:     94:                 sig = self.generate_signal(window, self.config) or {}
  6469:     95:             except Exception as e:
  6470:     96:                 if not QUIET:
  6471:     97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
  6472:     98:                 await asyncio.sleep(0.5); continue
  6473:     99: 
  6474:    100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
  6475:    101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
  6476:    102: 
  6477:    103:             # --- Entrée (market -> taker)
  6478:    104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
  6479:    105:                 balance = float(self.config.get("cash", 10_000.0))
  6480:    106:                 qty = compute_size(
  6481:    107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
  6482:    108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  6483:    109:                 )
  6484:    110:                 if qty > 0:
  6485:    111:                     async def _place():
  6486:    112:                         return await self.order_market(self.symbol, side, qty)
  6487:    113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
  6488:    114:                     self.ctx.fsm.on_open(side, entry or c, qty)
  6489:    115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
  6490:    116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
  6491:    117: 
  6492:    118:             # --- Sortie (market -> taker)
  6493:    119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
  6494:    120:                 qty = self.ctx.fsm.qty
  6495:    121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
  6496:    122:                 async def _close():
  6497:    123:                     return await self.order_market(self.symbol, exit_side, qty)
  6498:    124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
  6499:    125: 
  6500:    126:                 # fill avec slippage + frais (taker)
  6501:    127:                 price_fill = float(c)
  6502:    128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
  6503:    129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
  6504:    130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
  6505:    131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
  6506:    132:                                           "order_id": (order or {}).get("id","")})
  6507:    133:                 self.ctx.fsm.on_close()
  6508:    134: 
  6509:    135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
  6510:    136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
  6511:    137: 
  6512:    138:             await asyncio.sleep(0.1 if QUIET else 0.01)
  6513: 
  6514: ## scalper/live/notify.py (last modified: 2025-08-24 03:12:00)
  6515:      1: # -*- coding: utf-8 -*-
  6516:      2: from __future__ import annotations
  6517:      3: import os
  6518:      4: import asyncio
  6519:      5: from dataclasses import dataclass
  6520:      6: from typing import AsyncIterator, Optional
  6521:      7: 
  6522:      8: 
  6523:      9: @dataclass
  6524:     10: class BaseNotifier:
  6525:     11:     async def send(self, text: str) -> None:  # pragma: no cover
  6526:     12:         print(text)
  6527:     13: 
  6528:     14: 
  6529:     15: class NullNotifier(BaseNotifier):
  6530:     16:     pass
  6531:     17: 
  6532:     18: 
  6533:     19: class TelegramNotifier(BaseNotifier):
  6534:     20:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
  6535:     21:         import aiohttp  # lazy
  6536:     22:         self._token = token
  6537:     23:         self._chat = chat_id
  6538:     24:         self._session: aiohttp.ClientSession | None = None
  6539:     25: 
  6540:     26:     async def _ensure(self):
  6541:     27:         import aiohttp
  6542:     28:         if self._session is None or self._session.closed:
  6543:     29:             self._session = aiohttp.ClientSession()
  6544:     30: 
  6545:     31:     async def send(self, text: str) -> None:
  6546:     32:         import aiohttp
  6547:     33:         await self._ensure()
  6548:     34:         # pas de markdown pour éviter les erreurs 400 de parsing
  6549:     35:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
  6550:     36:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
  6551:     37:         try:
  6552:     38:             async with self._session.post(url, json=payload, timeout=20) as r:
  6553:     39:                 await r.text()  # on ignore la réponse pour rester simple
  6554:     40:         except Exception:
  6555:     41:             # on fait un fallback silencieux pour ne pas casser le bot
  6556:     42:             print("[notify:telegram] send fail (ignored)")
  6557:     43: 
  6558:     44:     async def close(self):
  6559:     45:         if self._session and not self._session.closed:
  6560:     46:             await self._session.close()
  6561:     47: 
  6562:     48: 
  6563:     49: class _NullCommands:
  6564:     50:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
  6565:     51:     def __aiter__(self) -> AsyncIterator[str]:
  6566:     52:         return self
  6567:     53:     async def __anext__(self) -> str:
  6568:     54:         await asyncio.sleep(3600)  # jamais
  6569:     55:         raise StopAsyncIteration
  6570:     56: 
  6571:     57: 
  6572:     58: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
  6573:     59:     """
  6574:     60:     Retourne (notifier, command_stream).
  6575:     61: 
  6576:     62:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
  6577:     63:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
  6578:     64:       commandes interactives plus tard.
  6579:     65:     - Sinon: NullNotifier + flux vide.
  6580:     66:     """
  6581:     67:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  6582:     68:     chat = os.getenv("TELEGRAM_CHAT_ID")
  6583:     69:     if token and chat:
  6584:     70:         print("[notify] TELEGRAM configured.")
  6585:     71:         return TelegramNotifier(token, chat), _NullCommands()
  6586:     72:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
  6587:     73:     return NullNotifier(), _NullCommands()
  6588: 
  6589: ## scalper/live/ohlcv_service.py (last modified: 2025-08-23 20:57:14)
  6590:      1: from __future__ import annotations
  6591:      2: import time
  6592:      3: from typing import Any, Dict, List, Optional
  6593:      4: 
  6594:      5: try:
  6595:      6:     from scalper.adapters.market_data import MarketData
  6596:      7: except Exception:
  6597:      8:     MarketData = None  # type: ignore
  6598:      9: 
  6599:     10: class OhlcvService:
  6600:     11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
  6601:     12:     def __init__(self, exchange) -> None:
  6602:     13:         self.exchange = exchange
  6603:     14:         self.md = MarketData(exchange) if MarketData is not None else None
  6604:     15: 
  6605:     16:     @staticmethod
  6606:     17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
  6607:     18:         out: List[Dict[str, float]] = []
  6608:     19:         if not rows: return out
  6609:     20:         for r in rows:
  6610:     21:             if isinstance(r, dict):
  6611:     22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
  6612:     23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
  6613:     24:                 v = float(r.get("volume", r.get("vol", 0.0)))
  6614:     25:             else:
  6615:     26:                 rr = list(r)
  6616:     27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
  6617:     28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
  6618:     29:                 else:
  6619:     30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
  6620:     31:                     h = float(rr[1]) if len(rr) > 1 else o
  6621:     32:                     l = float(rr[2]) if len(rr) > 2 else o
  6622:     33:                     c = float(rr[3]) if len(rr) > 3 else o
  6623:     34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
  6624:     35:                     ts = int(rr[5]) if len(rr) > 5 else 0
  6625:     36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
  6626:     37:         return out
  6627:     38: 
  6628:     39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
  6629:     40:         # 1) MarketData (si dispo)
  6630:     41:         if self.md is not None:
  6631:     42:             try:
  6632:     43:                 d = self.md.get_ohlcv(symbol, interval, limit)
  6633:     44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
  6634:     45:                     return self.normalize_rows(d["data"])
  6635:     46:             except Exception:
  6636:     47:                 pass
  6637:     48: 
  6638:     49:         # 2) Exchange natif
  6639:     50:         rows: List[Any] = []
  6640:     51:         try:
  6641:     52:             data = self.exchange.get_kline(symbol, interval=interval)
  6642:     53:         except Exception:
  6643:     54:             data = None
  6644:     55: 
  6645:     56:         if isinstance(data, dict):
  6646:     57:             rows = (
  6647:     58:                 data.get("data") or data.get("result") or data.get("records") or
  6648:     59:                 data.get("list") or data.get("items") or data.get("candles") or []
  6649:     60:             )
  6650:     61:             guard = 0
  6651:     62:             while isinstance(rows, dict) and guard < 3:
  6652:     63:                 rows = (
  6653:     64:                     rows.get("data") or rows.get("result") or rows.get("records") or
  6654:     65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
  6655:     66:                 )
  6656:     67:                 guard += 1
  6657:     68:         elif isinstance(data, (list, tuple)):
  6658:     69:             rows = list(data)
  6659:     70: 
  6660:     71:         out = self.normalize_rows(rows)[-limit:]
  6661:     72:         if out: return out
  6662:     73: 
  6663:     74:         # 3) Fallback strict via ticker -> bougie synthétique
  6664:     75:         try:
  6665:     76:             tkr = self.exchange.get_ticker(symbol)
  6666:     77:             items = []
  6667:     78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
  6668:     79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
  6669:     80:             if items:
  6670:     81:                 last = items[0]
  6671:     82:                 if isinstance(last, dict):
  6672:     83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
  6673:     84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
  6674:     85:                 else:
  6675:     86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
  6676:     87:                 ts = int(time.time()*1000)
  6677:     88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
  6678:     89:         except Exception:
  6679:     90:             pass
  6680:     91:         return []
  6681: 
  6682: ## scalper/live/orchestrator.py (last modified: 2025-08-24 03:12:00)
  6683:      1: # -*- coding: utf-8 -*-
  6684:      2: from __future__ import annotations
  6685:      3: import asyncio
  6686:      4: from dataclasses import dataclass, field
  6687:      5: from typing import Callable, Iterable, List, Optional, AsyncIterator
  6688:      6: 
  6689:      7: from scalper.hooks.prewarm_cache import prewarm_cache
  6690:      8: 
  6691:      9: 
  6692:     10: @dataclass
  6693:     11: class RunConfig:
  6694:     12:     symbols: List[str] = field(default_factory=lambda: [
  6695:     13:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  6696:     14:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  6697:     15:     ])
  6698:     16:     timeframe: str = "5m"
  6699:     17:     refresh_secs: float = 30.0
  6700:     18:     cache_dir: str = "/notebooks/data"
  6701:     19:     # Tu peux ajouter d'autres paramètres ici (risques, stratégie, etc.)
  6702:     20: 
  6703:     21: 
  6704:     22: class Orchestrator:
  6705:     23:     def __init__(self, cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None):
  6706:     24:         self.cfg = cfg
  6707:     25:         self.notifier = notifier
  6708:     26:         self._cache_dir_factory = cache_dir_factory
  6709:     27:         self._bg_tasks: list[asyncio.Task] = []
  6710:     28:         self._ticks_total: int = 0
  6711:     29:         self._running: bool = False
  6712:     30: 
  6713:     31:     # --- getters exposés aux tâches de log/heartbeat
  6714:     32:     def ticks_total(self) -> int:
  6715:     33:         return self._ticks_total
  6716:     34: 
  6717:     35:     def symbols(self) -> List[str]:
  6718:     36:         return list(self.cfg.symbols)
  6719:     37: 
  6720:     38:     async def _heartbeat_task(self) -> None:
  6721:     39:         while self._running:
  6722:     40:             try:
  6723:     41:                 await self.notifier.send("heartbeat alive")
  6724:     42:             finally:
  6725:     43:                 await asyncio.sleep(30)
  6726:     44: 
  6727:     45:     async def _log_stats_task(self) -> None:
  6728:     46:         # log toutes les 30s
  6729:     47:         while self._running:
  6730:     48:             try:
  6731:     49:                 msg = f"[stats] ticks_total={self._ticks_total} (+0 /30s) | pairs={','.join(self.cfg.symbols) if self.cfg.symbols else ''}"
  6732:     50:                 await self.notifier.send(msg)
  6733:     51:             finally:
  6734:     52:                 await asyncio.sleep(30)
  6735:     53: 
  6736:     54:     async def _main_loop(self) -> None:
  6737:     55:         """Boucle principale ultra‑simple qui incrémente un compteur."""
  6738:     56:         refresh = max(2.0, float(self.cfg.refresh_secs))
  6739:     57:         while self._running:
  6740:     58:             # Ici tu brancheras fetch_ohlcv / signaux / stratégies
  6741:     59:             self._ticks_total += len(self.cfg.symbols)
  6742:     60:             await asyncio.sleep(refresh)
  6743:     61: 
  6744:     62:     async def start(self) -> None:
  6745:     63:         # Pré‑chauffe cache (non bloquant et robuste)
  6746:     64:         prewarm_cache(
  6747:     65:             cfg={},  # placeholder
  6748:     66:             symbols=self.cfg.symbols,
  6749:     67:             timeframe=self.cfg.timeframe,
  6750:     68:             out_dir=(self._cache_dir_factory() if self._cache_dir_factory else self.cfg.cache_dir),
  6751:     69:         )
  6752:     70:         await self.notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  6753:     71: 
  6754:     72:         self._running = True
  6755:     73:         self._bg_tasks.append(asyncio.create_task(self._heartbeat_task()))
  6756:     74:         self._bg_tasks.append(asyncio.create_task(self._log_stats_task()))
  6757:     75:         try:
  6758:     76:             await self._main_loop()
  6759:     77:         finally:
  6760:     78:             # arrêt propre
  6761:     79:             self._running = False
  6762:     80:             for t in self._bg_tasks:
  6763:     81:                 t.cancel()
  6764:     82:             self._bg_tasks.clear()
  6765:     83: 
  6766:     84:     async def run(self) -> None:
  6767:     85:         await self.start()
  6768:     86: 
  6769:     87: 
  6770:     88: async def run_orchestrator(cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None) -> None:
  6771:     89:     """Entrée unique utilisée par bot.py"""
  6772:     90:     orch = Orchestrator(cfg, notifier, cache_dir_factory)
  6773:     91:     await orch.run()
  6774: 
  6775: ## scalper/live/orders.py (last modified: 2025-08-23 20:57:14)
  6776:      1: # live/orders.py
  6777:      2: from __future__ import annotations
  6778:      3: from dataclasses import dataclass
  6779:      4: from typing import Any, Optional
  6780:      5: 
  6781:      6: from scalper.services.order_service import OrderService, OrderRequest
  6782:      7: 
  6783:      8: @dataclass
  6784:      9: class OrderResult:
  6785:     10:     accepted: bool
  6786:     11:     order_id: str | None = None
  6787:     12:     status: str | None = None
  6788:     13:     reason: str | None = None
  6789:     14: 
  6790:     15: class OrderExecutor:
  6791:     16:     """
  6792:     17:     Fine couche autour d'OrderService + exchange :
  6793:     18:       - calcule l'équité USDT
  6794:     19:       - place une entrée (risk_pct)
  6795:     20:       - récupère les fills (normalisés)
  6796:     21:     L'orchestrateur n’appelle plus OrderService directement.
  6797:     22:     """
  6798:     23: 
  6799:     24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
  6800:     25:         self.order_service = order_service
  6801:     26:         self.exchange = exchange
  6802:     27:         self.config = config
  6803:     28: 
  6804:     29:     # ---------- Equity ----------
  6805:     30:     def get_equity_usdt(self) -> float:
  6806:     31:         equity = 0.0
  6807:     32:         try:
  6808:     33:             assets = self.exchange.get_assets()
  6809:     34:             if isinstance(assets, dict):
  6810:     35:                 for a in (assets.get("data") or []):
  6811:     36:                     if str(a.get("currency")).upper() == "USDT":
  6812:     37:                         equity = float(a.get("equity", 0.0))
  6813:     38:                         break
  6814:     39:         except Exception:
  6815:     40:             pass
  6816:     41:         return equity
  6817:     42: 
  6818:     43:     # ---------- Entrée ----------
  6819:     44:     def place_entry(self, *, symbol: str, side: str, price: float,
  6820:     45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
  6821:     46:         """
  6822:     47:         side: 'long' | 'short'
  6823:     48:         Retourne OrderResult(accepted, order_id, status, reason)
  6824:     49:         """
  6825:     50:         equity = self.get_equity_usdt()
  6826:     51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
  6827:     52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
  6828:     53:                            risk_pct=float(risk_pct))
  6829:     54:         try:
  6830:     55:             res = self.order_service.prepare_and_place(equity, req)
  6831:     56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
  6832:     57:                                order_id=getattr(res, "order_id", None),
  6833:     58:                                status=getattr(res, "status", None),
  6834:     59:                                reason=getattr(res, "reason", None))
  6835:     60:         except Exception as e:
  6836:     61:             return OrderResult(accepted=False, reason=str(e))
  6837:     62: 
  6838:     63:     # ---------- Fills ----------
  6839:     64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
  6840:     65:         """
  6841:     66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
  6842:     67:         """
  6843:     68:         try:
  6844:     69:             raw = self.exchange.get_fills(symbol, order_id, limit)
  6845:     70:         except Exception:
  6846:     71:             return []
  6847:     72: 
  6848:     73:         items: list = []
  6849:     74:         if isinstance(raw, dict):
  6850:     75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
  6851:     76:         elif isinstance(raw, (list, tuple)):
  6852:     77:             items = list(raw)
  6853:     78: 
  6854:     79:         out: list[dict] = []
  6855:     80:         for f in items:
  6856:     81:             if isinstance(f, dict):
  6857:     82:                 out.append({
  6858:     83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
  6859:     84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
  6860:     85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
  6861:     86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
  6862:     87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
  6863:     88:                 })
  6864:     89:             else:
  6865:     90:                 try:
  6866:     91:                     seq = list(f)
  6867:     92:                     out.append({
  6868:     93:                         "orderId": str(seq[0]) if seq else "",
  6869:     94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
  6870:     95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
  6871:     96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
  6872:     97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
  6873:     98:                     })
  6874:     99:                 except Exception:
  6875:    100:                     continue
  6876:    101:         return out
  6877: 
  6878: ## scalper/live/position_fsm.py (last modified: 2025-08-23 20:57:14)
  6879:      1: # live/position_fsm.py
  6880:      2: from __future__ import annotations
  6881:      3: from dataclasses import dataclass
  6882:      4: from typing import Optional, Dict, Any, List
  6883:      5: 
  6884:      6: 
  6885:      7: STATE_FLAT = "FLAT"
  6886:      8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
  6887:      9: STATE_OPEN = "OPEN"
  6888:     10: STATE_PENDING_EXIT = "PENDING_EXIT"
  6889:     11: 
  6890:     12: 
  6891:     13: @dataclass
  6892:     14: class PositionState:
  6893:     15:     symbol: str
  6894:     16:     state: str = STATE_FLAT
  6895:     17:     order_id: Optional[str] = None
  6896:     18:     side: Optional[str] = None   # "long" | "short"
  6897:     19:     qty: float = 0.0
  6898:     20:     entry: float = 0.0
  6899:     21: 
  6900:     22: 
  6901:     23: class PositionFSM:
  6902:     24:     """
  6903:     25:     FSM ultra-simple par symbole.
  6904:     26:     - set_pending_entry(order_id, side)
  6905:     27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
  6906:     28:     """
  6907:     29: 
  6908:     30:     def __init__(self, symbols: List[str]) -> None:
  6909:     31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
  6910:     32: 
  6911:     33:     # -------- API utilisateur --------
  6912:     34:     def ensure_symbol(self, symbol: str) -> None:
  6913:     35:         if symbol not in self._by_symbol:
  6914:     36:             self._by_symbol[symbol] = PositionState(symbol)
  6915:     37: 
  6916:     38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
  6917:     39:         self.ensure_symbol(symbol)
  6918:     40:         st = self._by_symbol[symbol]
  6919:     41:         st.state = STATE_PENDING_ENTRY
  6920:     42:         st.order_id = order_id
  6921:     43:         st.side = side
  6922:     44: 
  6923:     45:     def mark_pending_exit(self, symbol: str) -> None:
  6924:     46:         self.ensure_symbol(symbol)
  6925:     47:         st = self._by_symbol[symbol]
  6926:     48:         st.state = STATE_PENDING_EXIT
  6927:     49: 
  6928:     50:     def force_flat(self, symbol: str) -> None:
  6929:     51:         self._by_symbol[symbol] = PositionState(symbol)
  6930:     52: 
  6931:     53:     # -------- Lecture --------
  6932:     54:     def get(self, symbol: str) -> PositionState:
  6933:     55:         self.ensure_symbol(symbol)
  6934:     56:         return self._by_symbol[symbol]
  6935:     57: 
  6936:     58:     def all(self) -> Dict[str, PositionState]:
  6937:     59:         return self._by_symbol
  6938:     60: 
  6939:     61:     # -------- Réconciliation --------
  6940:     62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
  6941:     63:         """
  6942:     64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
  6943:     65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
  6944:     66:         """
  6945:     67:         # indexer positions ouvertes
  6946:     68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
  6947:     69: 
  6948:     70:         for sym, st in self._by_symbol.items():
  6949:     71:             p = idx_open.get(sym)
  6950:     72: 
  6951:     73:             if st.state == STATE_PENDING_ENTRY:
  6952:     74:                 # si on voit des fills de l'ordre en attente -> OPEN
  6953:     75:                 f_list = fills.get(sym) or []
  6954:     76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
  6955:     77:                 if qty_filled > 0.0 or p:
  6956:     78:                     st.state = STATE_OPEN
  6957:     79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
  6958:     80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
  6959:     81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
  6960:     82:             elif st.state == STATE_OPEN:
  6961:     83:                 # si plus de position ouverte -> FLAT
  6962:     84:                 if not p:
  6963:     85:                     st.state = STATE_FLAT
  6964:     86:                     st.order_id = None
  6965:     87:                     st.side = None
  6966:     88:                     st.qty = 0.0
  6967:     89:                     st.entry = 0.0
  6968:     90:                 else:
  6969:     91:                     st.qty = float(p.get("qty", st.qty))
  6970:     92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
  6971:     93:             elif st.state == STATE_PENDING_EXIT:
  6972:     94:                 # si plus de position -> FLAT ; sinon reste OPEN
  6973:     95:                 if not p:
  6974:     96:                     st.state = STATE_FLAT
  6975:     97:                     st.order_id = None
  6976:     98:                     st.side = None
  6977:     99:                     st.qty = 0.0
  6978:    100:                     st.entry = 0.0
  6979:    101:                 else:
  6980:    102:                     st.state = STATE_OPEN  # pas encore clos
  6981:    103:             else:
  6982:    104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
  6983:    105:                 if p:
  6984:    106:                     st.state = STATE_OPEN
  6985:    107:                     st.qty = float(p.get("qty", 0.0))
  6986:    108:                     st.entry = float(p.get("avgEntryPrice", 0.0))
  6987: 
  6988: ## scalper/live/setup_wizard.py (last modified: 2025-08-23 20:57:14)
  6989:      1: from __future__ import annotations
  6990:      2: import asyncio, os
  6991:      3: from dataclasses import dataclass
  6992:      4: from typing import List, Dict, Optional, Callable
  6993:      5: from ..signals.factory import load_signal
  6994:      6: from ..backtest.runner import BacktestRunner
  6995:      7: from .notify import Notifier, CommandStream
  6996:      8: 
  6997:      9: @dataclass
  6998:     10: class SetupResult:
  6999:     11:     strategy: str
  7000:     12:     symbols: List[str]
  7001:     13:     timeframes: List[str]
  7002:     14:     risk_pct: float
  7003:     15:     accepted: bool
  7004:     16:     summary_path: str
  7005:     17: 
  7006:     18: class SetupWizard:
  7007:     19:     """
  7008:     20:     Wizard interactif Telegram avant lancement des trades.
  7009:     21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
  7010:     22:     """
  7011:     23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
  7012:     24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
  7013:     25:                  admin_chat_id: Optional[int]=None):
  7014:     26:         self.notifier = notifier
  7015:     27:         self.cmd_stream = cmd_stream
  7016:     28:         self.loader = ohlcv_loader_sync
  7017:     29:         self.out_dir = out_dir
  7018:     30:         self.admin_chat_id = admin_chat_id
  7019:     31: 
  7020:     32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
  7021:     33:         await self.notifier.send_menu(prompt, choices)
  7022:     34:         async for msg in self.cmd_stream:
  7023:     35:             txt = msg.strip()
  7024:     36:             if allow_multi and ("," in txt or " " in txt):
  7025:     37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
  7026:     38:                 return sel
  7027:     39:             if txt.isdigit():
  7028:     40:                 i = int(txt)-1
  7029:     41:                 if 0 <= i < len(choices):
  7030:     42:                     return [choices[i]]
  7031:     43:             if txt in choices:
  7032:     44:                 return [txt]
  7033:     45:             await self.notifier.send("Entrée invalide. Réessaie.")
  7034:     46: 
  7035:     47:     async def _ask_value(self, prompt: str, cast: Callable, default):
  7036:     48:         await self.notifier.send(f"{prompt} (défaut: {default})")
  7037:     49:         async for msg in self.cmd_stream:
  7038:     50:             txt = msg.strip()
  7039:     51:             if txt == "" or txt.lower() in ("d","defaut","default"):
  7040:     52:                 return default
  7041:     53:             try:
  7042:     54:                 return cast(txt)
  7043:     55:             except Exception:
  7044:     56:                 await self.notifier.send("Entrée invalide. Réessaie.")
  7045:     57: 
  7046:     58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
  7047:     59:                   default_strategy: str="current") -> SetupResult:
  7048:     60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
  7049:     61:         # 1) stratégie
  7050:     62:         strategies = ["current","ema_cross","vwap_break"]
  7051:     63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
  7052:     64: 
  7053:     65:         # 2) symboles
  7054:     66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
  7055:     67: 
  7056:     68:         # 3) timeframes
  7057:     69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
  7058:     70: 
  7059:     71:         # 4) risk %
  7060:     72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
  7061:     73: 
  7062:     74:         # 5) période backtest
  7063:     75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
  7064:     76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
  7065:     77: 
  7066:     78:         # 6) run backtest
  7067:     79:         from ..backtest.cli import parse_ts
  7068:     80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
  7069:     81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
  7070:     82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
  7071:     83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
  7072:     84: 
  7073:     85:         # 7) résumé
  7074:     86:         sum_path = os.path.join(self.out_dir, "metrics.json")
  7075:     87:         prop = res["proposal"]
  7076:     88:         lines = ["**Proposition** :"]
  7077:     89:         for sym, best in prop["per_symbol_best"].items():
  7078:     90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
  7079:     91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
  7080:     92: 
  7081:     93:         # 8) décision
  7082:     94:         async for msg in self.cmd_stream:
  7083:     95:             t = msg.strip().lower()
  7084:     96:             if t in ("accepter","accept","ok","go","start"):
  7085:     97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
  7086:     98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
  7087:     99:             if t in ("modifier","again","repeat"):
  7088:    100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
  7089:    101:             if t in ("annuler","cancel","stop"):
  7090:    102:                 await self.notifier.send("❌ Annulé.")
  7091:    103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)
  7092: 
  7093: ## scalper/live/state_store.py (last modified: 2025-08-23 20:57:14)
  7094:      1: # live/state_store.py
  7095:      2: from __future__ import annotations
  7096:      3: import json, os, time, asyncio
  7097:      4: from typing import Callable, Dict, Any
  7098:      5: 
  7099:      6: class StateStore:
  7100:      7:     """
  7101:      8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
  7102:      9:     - save_state(snapshot: dict) -> écrit sur disque
  7103:     10:     - load_state() -> dict
  7104:     11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
  7105:     12:     """
  7106:     13: 
  7107:     14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
  7108:     15:         self.filepath = filepath
  7109:     16:         self.period_s = period_s
  7110:     17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
  7111:     18:         self._running = False
  7112:     19: 
  7113:     20:     # -------- I/O --------
  7114:     21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
  7115:     22:         tmp = self.filepath + ".tmp"
  7116:     23:         with open(tmp, "w", encoding="utf-8") as f:
  7117:     24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
  7118:     25:         os.replace(tmp, self.filepath)
  7119:     26: 
  7120:     27:     def load_state(self) -> Dict[str, Any]:
  7121:     28:         if not os.path.exists(self.filepath):
  7122:     29:             return {}
  7123:     30:         try:
  7124:     31:             with open(self.filepath, "r", encoding="utf-8") as f:
  7125:     32:                 return json.load(f)
  7126:     33:         except Exception:
  7127:     34:             return {}
  7128:     35: 
  7129:     36:     # -------- Autosave --------
  7130:     37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
  7131:     38:         self._running = True
  7132:     39:         while self._running:
  7133:     40:             try:
  7134:     41:                 snap = get_snapshot()
  7135:     42:                 snap["saved_at"] = int(time.time() * 1000)
  7136:     43:                 self.save_state(snap)
  7137:     44:             except Exception:
  7138:     45:                 pass
  7139:     46:             await asyncio.sleep(self.period_s)
  7140:     47: 
  7141:     48:     def stop(self): self._running = False
  7142: 
  7143: ## scalper/live/telegram_async.py (last modified: 2025-08-23 20:57:14)
  7144:      1: from __future__ import annotations
  7145:      2: import time
  7146:      3: import requests
  7147:      4: import asyncio
  7148:      5: from typing import Optional, Dict, Any, List
  7149:      6: 
  7150:      7: 
  7151:      8: class TelegramAsync:
  7152:      9:     """
  7153:     10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
  7154:     11:     Sans nouvelle dépendance.
  7155:     12:     """
  7156:     13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
  7157:     14:         self.token = token
  7158:     15:         self.chat_id = chat_id
  7159:     16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
  7160:     17:         self._offset = 0
  7161:     18:         self._enabled = bool(token and chat_id)
  7162:     19: 
  7163:     20:     def enabled(self) -> bool:
  7164:     21:         return self._enabled
  7165:     22: 
  7166:     23:     # ---------- sync I/O (appelées via to_thread) ----------
  7167:     24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
  7168:     25:         if not self._enabled:
  7169:     26:             return {"ok": False, "reason": "disabled"}
  7170:     27:         url = f"{self.base}/sendMessage"
  7171:     28:         payload = {"chat_id": self.chat_id, "text": text}
  7172:     29:         try:
  7173:     30:             r = requests.post(url, json=payload, timeout=10)
  7174:     31:             return r.json()
  7175:     32:         except Exception as e:
  7176:     33:             return {"ok": False, "error": repr(e)}
  7177:     34: 
  7178:     35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
  7179:     36:         if not self._enabled:
  7180:     37:             return {"ok": True, "result": []}
  7181:     38:         url = f"{self.base}/getUpdates"
  7182:     39:         params = {"timeout": timeout_s, "offset": self._offset}
  7183:     40:         try:
  7184:     41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
  7185:     42:             return r.json()
  7186:     43:         except Exception as e:
  7187:     44:             return {"ok": False, "error": repr(e), "result": []}
  7188:     45: 
  7189:     46:     # ---------- async wrappers ----------
  7190:     47:     async def send_message(self, text: str) -> None:
  7191:     48:         await asyncio.to_thread(self._send_message_sync, text)
  7192:     49: 
  7193:     50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
  7194:     51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
  7195:     52:         if not data.get("ok"):
  7196:     53:             return []
  7197:     54:         out = []
  7198:     55:         for upd in data.get("result", []):
  7199:     56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
  7200:     57:             msg = upd.get("message") or {}
  7201:     58:             text = (msg.get("text") or "").strip()
  7202:     59:             if not text:
  7203:     60:                 continue
  7204:     61:             out.append({
  7205:     62:                 "date": msg.get("date"),
  7206:     63:                 "chat": str((msg.get("chat") or {}).get("id")),
  7207:     64:                 "text": text,
  7208:     65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
  7209:     66:             })
  7210:     67:         return out
  7211: 
  7212: 
  7213: ## scalper/live/watchlist.py (last modified: 2025-08-24 03:12:00)
  7214:      1: # -*- coding: utf-8 -*-
  7215:      2: from __future__ import annotations
  7216:      3: from dataclasses import dataclass
  7217:      4: from typing import List
  7218:      5: 
  7219:      6: 
  7220:      7: @dataclass
  7221:      8: class WatchlistManager:
  7222:      9:     symbols: List[str]
  7223:     10: 
  7224:     11:     @classmethod
  7225:     12:     def from_env_or_default(cls) -> "WatchlistManager":
  7226:     13:         # Tu peux lire une variable d'env ici si tu veux surcharger
  7227:     14:         default = [
  7228:     15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  7229:     16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  7230:     17:         ]
  7231:     18:         return cls(default)
  7232: 
  7233: ## scalper/logging_utils.py (last modified: 2025-08-23 20:57:14)
  7234:      1: """Logging helpers for the Scalp bot."""
  7235:      2: 
  7236:      3: from __future__ import annotations
  7237:      4: 
  7238:      5: import atexit
  7239:      6: import csv
  7240:      7: import json
  7241:      8: import os
  7242:      9: import sqlite3
  7243:     10: import time
  7244:     11: from pathlib import Path
  7245:     12: from typing import Any, Dict, List
  7246:     13: 
  7247:     14: 
  7248:     15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
  7249:     16:     """Return a callable that logs events as JSON lines.
  7250:     17: 
  7251:     18:     Parameters
  7252:     19:     ----------
  7253:     20:     path: str
  7254:     21:         Target file path for JSON lines.
  7255:     22:     max_bytes: int, optional
  7256:     23:         If >0, rotate the file when its size exceeds this value.
  7257:     24:     backup_count: int, optional
  7258:     25:         Number of rotated files to keep when ``max_bytes`` is set.
  7259:     26:     """
  7260:     27:     os.makedirs(os.path.dirname(path), exist_ok=True)
  7261:     28:     log_file = open(path, "a", encoding="utf-8")
  7262:     29: 
  7263:     30:     def _close_file() -> None:
  7264:     31:         try:
  7265:     32:             log_file.close()
  7266:     33:         except Exception:
  7267:     34:             pass
  7268:     35: 
  7269:     36:     atexit.register(_close_file)
  7270:     37: 
  7271:     38:     def _rotate() -> None:
  7272:     39:         nonlocal log_file
  7273:     40:         log_file.close()
  7274:     41:         for i in range(backup_count - 1, 0, -1):
  7275:     42:             src = f"{path}.{i}"
  7276:     43:             dst = f"{path}.{i + 1}"
  7277:     44:             if os.path.exists(src):
  7278:     45:                 os.replace(src, dst)
  7279:     46:         os.replace(path, f"{path}.1")
  7280:     47:         log_file = open(path, "a", encoding="utf-8")
  7281:     48: 
  7282:     49:     def _log(event: str, payload: Dict[str, Any]) -> None:
  7283:     50:         nonlocal log_file
  7284:     51:         payload = dict(payload or {})
  7285:     52:         payload["event"] = event
  7286:     53:         payload["ts"] = int(time.time() * 1000)
  7287:     54:         line = json.dumps(payload, ensure_ascii=False)
  7288:     55:         if max_bytes and backup_count > 0:
  7289:     56:             if log_file.tell() + len(line) + 1 > max_bytes:
  7290:     57:                 _rotate()
  7291:     58:         log_file.write(line + "\n")
  7292:     59:         log_file.flush()
  7293:     60: 
  7294:     61:     return _log
  7295:     62: 
  7296:     63: 
  7297:     64: class TradeLogger:
  7298:     65:     """Helper writing trade information to CSV and SQLite files."""
  7299:     66: 
  7300:     67:     fields = [
  7301:     68:         "pair",
  7302:     69:         "tf",
  7303:     70:         "dir",
  7304:     71:         "entry",
  7305:     72:         "sl",
  7306:     73:         "tp",
  7307:     74:         "score",
  7308:     75:         "reasons",
  7309:     76:         "pnl",
  7310:     77:     ]
  7311:     78: 
  7312:     79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
  7313:     80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
  7314:     81:         self.csv_path = csv_path
  7315:     82:         self.sqlite_path = sqlite_path
  7316:     83: 
  7317:     84:         # Ensure CSV has header
  7318:     85:         if not os.path.exists(csv_path):
  7319:     86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
  7320:     87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
  7321:     88:                 writer.writeheader()
  7322:     89: 
  7323:     90:         # Setup SQLite store
  7324:     91:         self.conn = sqlite3.connect(sqlite_path)
  7325:     92:         cur = self.conn.cursor()
  7326:     93:         cur.execute(
  7327:     94:             """
  7328:     95:             CREATE TABLE IF NOT EXISTS trades (
  7329:     96:                 pair TEXT,
  7330:     97:                 tf TEXT,
  7331:     98:                 dir TEXT,
  7332:     99:                 entry REAL,
  7333:    100:                 sl REAL,
  7334:    101:                 tp REAL,
  7335:    102:                 score REAL,
  7336:    103:                 reasons TEXT,
  7337:    104:                 pnl REAL
  7338:    105:             )
  7339:    106:             """
  7340:    107:         )
  7341:    108:         self.conn.commit()
  7342:    109:         atexit.register(self.conn.close)
  7343:    110: 
  7344:    111:     def log(self, data: Dict[str, Any]) -> None:
  7345:    112:         row = {k: data.get(k) for k in self.fields}
  7346:    113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
  7347:    114:             writer = csv.DictWriter(f, fieldnames=self.fields)
  7348:    115:             writer.writerow(row)
  7349:    116:         cur = self.conn.cursor()
  7350:    117:         cur.execute(
  7351:    118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
  7352:    119:             (
  7353:    120:                 row["pair"],
  7354:    121:                 row["tf"],
  7355:    122:                 row["dir"],
  7356:    123:                 row["entry"],
  7357:    124:                 row["sl"],
  7358:    125:                 row["tp"],
  7359:    126:                 row["score"],
  7360:    127:                 row["reasons"],
  7361:    128:                 row["pnl"],
  7362:    129:             ),
  7363:    130:         )
  7364:    131:         self.conn.commit()
  7365:    132: 
  7366:    133: 
  7367:    134: BASE_DIR = Path(__file__).resolve().parents[2]
  7368:    135: 
  7369:    136: 
  7370:    137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
  7371:    138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
  7372:    139:     path.parent.mkdir(parents=True, exist_ok=True)
  7373:    140:     file_exists = path.exists()
  7374:    141:     with path.open("a", newline="", encoding="utf-8") as f:
  7375:    142:         writer = csv.DictWriter(f, fieldnames=fields)
  7376:    143:         if not file_exists:
  7377:    144:             writer.writeheader()
  7378:    145:         writer.writerow({k: row.get(k) for k in fields})
  7379:    146: 
  7380:    147: 
  7381:    148: def log_position(data: Dict[str, Any]) -> None:
  7382:    149:     """Log a closed position to ``../positions.csv``."""
  7383:    150:     fields = [
  7384:    151:         "timestamp",
  7385:    152:         "pair",
  7386:    153:         "direction",
  7387:    154:         "entry",
  7388:    155:         "exit",
  7389:    156:         "pnl_pct",
  7390:    157:         "fee_rate",
  7391:    158:         "notes",
  7392:    159:     ]
  7393:    160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
  7394:    161: 
  7395:    162: 
  7396:    163: def log_operation_memo(data: Dict[str, Any]) -> None:
  7397:    164:     """Log operation details to ``../operations_memo.csv``."""
  7398:    165:     fields = ["timestamp", "pair", "details"]
  7399:    166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)
  7400: 
  7401: 
  7402: ## scalper/metrics.py (last modified: 2025-08-23 20:57:14)
  7403:      1: """Utility metrics for trading calculations."""
  7404:      2: 
  7405:      3: from __future__ import annotations
  7406:      4: 
  7407:      5: 
  7408:      6: from typing import Iterable
  7409:      7: 
  7410:      8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
  7411:      9: 
  7412:     10: 
  7413:     11: def calc_pnl_pct(
  7414:     12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
  7415:     13: ) -> float:
  7416:     14:     """Return percentage PnL between entry and exit prices minus fees.
  7417:     15: 
  7418:     16: 
  7419:     17:     Parameters
  7420:     18:     ----------
  7421:     19:     entry_price: float
  7422:     20:         Trade entry price (>0).
  7423:     21:     exit_price: float
  7424:     22:         Trade exit price (>0).
  7425:     23:     side: int
  7426:     24:         +1 for long, -1 for short.
  7427:     25:     fee_rate: float, optional
  7428:     26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
  7429:     27:         applied twice (entry + exit).
  7430:     28:     """
  7431:     29:     if entry_price <= 0 or exit_price <= 0:
  7432:     30:         raise ValueError("Prices must be positive")
  7433:     31:     if side not in (1, -1):
  7434:     32:         raise ValueError("side must be +1 (long) or -1 (short)")
  7435:     33: 
  7436:     34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
  7437:     35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
  7438:     36:     return pnl - fee_pct
  7439:     37: 
  7440:     38: 
  7441:     39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
  7442:     40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
  7443:     41: 
  7444:     42: 
  7445:     43:     Parameters
  7446:     44:     ----------
  7447:     45:     prices:
  7448:     46:         Ordered sequence of closing prices.
  7449:     47:     period:
  7450:     48:         Number of periods to use for the calculation. Must be positive and the
  7451:     49:         length of ``prices`` must be at least ``period + 1``.
  7452:     50:     """
  7453:     51: 
  7454:     52:     prices_list = [float(p) for p in prices]
  7455:     53: 
  7456:     54:     if period <= 0:
  7457:     55:         raise ValueError("period must be positive")
  7458:     56:     if len(prices_list) < period + 1:
  7459:     57: 
  7460:     58:         raise ValueError("len(prices) must be >= period + 1")
  7461:     59: 
  7462:     60:     gains: list[float] = []
  7463:     61:     losses: list[float] = []
  7464:     62:     for i in range(1, period + 1):
  7465:     63: 
  7466:     64:         diff = prices_list[i] - prices_list[i - 1]
  7467:     65: 
  7468:     66:         if diff >= 0:
  7469:     67:             gains.append(diff)
  7470:     68:             losses.append(0.0)
  7471:     69:         else:
  7472:     70:             gains.append(0.0)
  7473:     71:             losses.append(-diff)
  7474:     72: 
  7475:     73:     avg_gain = sum(gains) / period
  7476:     74:     avg_loss = sum(losses) / period
  7477:     75: 
  7478:     76:     for i in range(period + 1, len(prices_list)):
  7479:     77:         diff = prices_list[i] - prices_list[i - 1]
  7480:     78: 
  7481:     79:         gain = max(diff, 0.0)
  7482:     80:         loss = max(-diff, 0.0)
  7483:     81:         avg_gain = (avg_gain * (period - 1) + gain) / period
  7484:     82:         avg_loss = (avg_loss * (period - 1) + loss) / period
  7485:     83: 
  7486:     84:     if avg_gain == 0 and avg_loss == 0:
  7487:     85:         return 50.0
  7488:     86:     if avg_loss == 0:
  7489:     87:         return 100.0
  7490:     88:     if avg_gain == 0:
  7491:     89:         return 0.0
  7492:     90:     rs = avg_gain / avg_loss
  7493:     91:     return 100.0 - (100.0 / (1.0 + rs))
  7494:     92: 
  7495:     93: 
  7496:     94: def calc_atr(
  7497:     95:     highs: Iterable[float],
  7498:     96:     lows: Iterable[float],
  7499:     97:     closes: Iterable[float],
  7500:     98:     period: int = 14,
  7501:     99: ) -> float:
  7502:    100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
  7503:    101: 
  7504:    102: 
  7505:    103:     Parameters
  7506:    104:     ----------
  7507:    105:     highs, lows, closes:
  7508:    106:         Ordered sequences of high, low and close prices. All sequences must
  7509:    107:         have the same length and contain at least ``period + 1`` elements.
  7510:    108:     period:
  7511:    109:         Number of periods to use for the calculation. Must be positive.
  7512:    110:     """
  7513:    111: 
  7514:    112:     highs_list = [float(h) for h in highs]
  7515:    113:     lows_list = [float(low) for low in lows]
  7516:    114:     closes_list = [float(c) for c in closes]
  7517:    115: 
  7518:    116:     length = len(highs_list)
  7519:    117:     if length != len(lows_list) or length != len(closes_list):
  7520:    118: 
  7521:    119:         raise ValueError("Input sequences must have the same length")
  7522:    120:     if period <= 0:
  7523:    121:         raise ValueError("period must be positive")
  7524:    122:     if length < period + 1:
  7525:    123:         raise ValueError("Input sequences must have at least period + 1 elements")
  7526:    124: 
  7527:    125:     trs: list[float] = []
  7528:    126:     for i in range(1, len(highs_list)):
  7529:    127:         tr = max(
  7530:    128:             highs_list[i] - lows_list[i],
  7531:    129:             abs(highs_list[i] - closes_list[i - 1]),
  7532:    130:             abs(lows_list[i] - closes_list[i - 1]),
  7533:    131:         )
  7534:    132:         trs.append(tr)
  7535:    133: 
  7536:    134:     atr = sum(trs[:period]) / period
  7537:    135:     for tr in trs[period:]:
  7538:    136:         atr = (atr * (period - 1) + tr) / period
  7539:    137:     return atr
  7540:    138: 
  7541:    139: 
  7542:    140: def calc_macd(
  7543:    141:     prices: Sequence[float],
  7544:    142:     fast: int = 12,
  7545:    143:     slow: int = 26,
  7546:    144:     signal: int = 9,
  7547:    145: ) -> tuple[float, float, float]:
  7548:    146:     """Return MACD, signal line and histogram values.
  7549:    147: 
  7550:    148:     The implementation computes exponential moving averages using Wilder's
  7551:    149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
  7552:    150:     """
  7553:    151: 
  7554:    152:     prices_list = [float(p) for p in prices]
  7555:    153:     if fast <= 0 or slow <= 0 or signal <= 0:
  7556:    154:         raise ValueError("periods must be positive")
  7557:    155:     min_len = max(fast, slow) + signal
  7558:    156:     if len(prices_list) < min_len:
  7559:    157:         raise ValueError("len(prices) must be >= slow + signal")
  7560:    158: 
  7561:    159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
  7562:    160:         k = 2.0 / (window + 1.0)
  7563:    161:         out = [float(series[0])]
  7564:    162:         for x in series[1:]:
  7565:    163:             out.append(float(x) * k + out[-1] * (1.0 - k))
  7566:    164:         return out
  7567:    165: 
  7568:    166:     fast_ema = _ema_series(prices_list, fast)
  7569:    167:     slow_ema = _ema_series(prices_list, slow)
  7570:    168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
  7571:    169:     signal_series = _ema_series(macd_series, signal)
  7572:    170:     macd_val = macd_series[-1]
  7573:    171:     signal_val = signal_series[-1]
  7574:    172:     hist = macd_val - signal_val
  7575:    173:     return macd_val, signal_val, hist
  7576:    174: 
  7577:    175: 
  7578:    176: def backtest_position(
  7579:    177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
  7580:    178: ) -> bool:
  7581:    179:     """Run a basic backtest to verify a position's coherence.
  7582:    180: 
  7583:    181:     Parameters
  7584:    182:     ----------
  7585:    183:     prices: list[float]
  7586:    184:         Sequential list of prices to evaluate.
  7587:    185:     entry_idx: int
  7588:    186:         Index in ``prices`` where the position is opened.
  7589:    187:     exit_idx: int
  7590:    188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
  7591:    189:     side: int
  7592:    190:         +1 for long, -1 for short.
  7593:    191: 
  7594:    192:     Returns
  7595:    193:     -------
  7596:    194:     bool
  7597:    195:         ``True`` if the resulting PnL is non-negative, meaning the position is
  7598:    196:         coherent with the direction of price movement. ``False`` otherwise.
  7599:    197:     """
  7600:    198:     if side not in (1, -1):
  7601:    199:         raise ValueError("side must be +1 (long) or -1 (short)")
  7602:    200:     if not (0 <= entry_idx < exit_idx < len(prices)):
  7603:    201:         raise ValueError(
  7604:    202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
  7605:    203:         )
  7606:    204: 
  7607:    205:     entry_price = float(prices[entry_idx])
  7608:    206:     exit_price = float(prices[exit_idx])
  7609:    207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
  7610:    208:     return pnl >= 0.0
  7611: 
  7612: 
  7613: ## scalper/pairs.py (last modified: 2025-08-23 20:57:14)
  7614:      1: """Utilities to select trading pairs and detect signals."""
  7615:      2: from __future__ import annotations
  7616:      3: from typing import Any, Dict, List, Optional, Callable
  7617:      4: from scalper.strategy import Signal
  7618:      5: 
  7619:      6: from scalper.bot_config import CONFIG
  7620:      7: from scalper.strategy import ema as default_ema, cross as default_cross
  7621:      8: from scalper.notifier import notify
  7622:      9: 
  7623:     10: 
  7624:     11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
  7625:     12:     """Return all trading pairs using the client's ``get_ticker`` method."""
  7626:     13:     tick = client.get_ticker()
  7627:     14:     data = tick.get("data") if isinstance(tick, dict) else []
  7628:     15:     if not data:
  7629:     16:         return []
  7630:     17:     return data if isinstance(data, list) else [data]
  7631:     18: 
  7632:     19: 
  7633:     20: def filter_trade_pairs(
  7634:     21:     client: Any,
  7635:     22:     *,
  7636:     23:     volume_min: float = 5_000_000,
  7637:     24:     max_spread_bps: float = 5.0,
  7638:     25:     top_n: int = 40,
  7639:     26: ) -> List[Dict[str, Any]]:
  7640:     27:     """Filter pairs by volume and spread."""
  7641:     28:     pairs = get_trade_pairs(client)
  7642:     29:     eligible: List[Dict[str, Any]] = []
  7643:     30: 
  7644:     31:     for info in pairs:
  7645:     32:         sym = info.get("symbol")
  7646:     33:         if not sym:
  7647:     34:             continue
  7648:     35:         try:
  7649:     36:             vol = float(info.get("volume", 0))
  7650:     37:         except (TypeError, ValueError):
  7651:     38:             continue
  7652:     39:         if vol < volume_min:
  7653:     40:             continue
  7654:     41:         try:
  7655:     42:             bid = float(info.get("bidPrice", 0))
  7656:     43:             ask = float(info.get("askPrice", 0))
  7657:     44:         except (TypeError, ValueError):
  7658:     45:             continue
  7659:     46:         if bid <= 0 or ask <= 0:
  7660:     47:             continue
  7661:     48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
  7662:     49:         if spread_bps >= max_spread_bps:
  7663:     50:             continue
  7664:     51:         eligible.append(info)
  7665:     52: 
  7666:     53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
  7667:     54:     return eligible[:top_n]
  7668:     55: 
  7669:     56: 
  7670:     57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
  7671:     58:     """Return ``top_n`` pairs sorted by ``key``."""
  7672:     59:     pairs = get_trade_pairs(client)
  7673:     60: 
  7674:     61:     def volume(row: Dict[str, Any]) -> float:
  7675:     62:         try:
  7676:     63:             return float(row.get(key, 0))
  7677:     64:         except (TypeError, ValueError):
  7678:     65:             return 0.0
  7679:     66: 
  7680:     67:     pairs.sort(key=volume, reverse=True)
  7681:     68:     return pairs[:top_n]
  7682:     69: 
  7683:     70: 
  7684:     71: def _ancienne_impl(
  7685:     72:     client: Any,
  7686:     73:     pairs: List[Dict[str, Any]],
  7687:     74:     *,
  7688:     75:     interval: str = "1m",
  7689:     76:     ema_fast_n: Optional[int] = None,
  7690:     77:     ema_slow_n: Optional[int] = None,
  7691:     78:     ema_func=default_ema,
  7692:     79:     cross_func=default_cross,
  7693:     80: ) -> List[Dict[str, Any]]:
  7694:     81:     """Original implementation returning dicts."""
  7695:     82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
  7696:     83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
  7697:     84:     results: List[Dict[str, Any]] = []
  7698:     85: 
  7699:     86:     for info in pairs:
  7700:     87:         symbol = info.get("symbol")
  7701:     88:         if not symbol:
  7702:     89:             continue
  7703:     90:         k = client.get_kline(symbol, interval=interval)
  7704:     91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
  7705:     92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
  7706:     93:             continue
  7707:     94:         efull = ema_func(closes, ema_fast_n)
  7708:     95:         eslow = ema_func(closes, ema_slow_n)
  7709:     96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
  7710:     97:         if signal == 1:
  7711:     98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  7712:     99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
  7713:    100:         elif signal == -1:
  7714:    101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  7715:    102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
  7716:    103:     return results
  7717:    104: 
  7718:    105: 
  7719:    106: def _to_signal(d: dict) -> Signal:
  7720:    107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
  7721:    108:     return Signal(
  7722:    109:         symbol=d.get("symbol"),
  7723:    110:         side=side,
  7724:    111:         entry=float(d.get("price", d.get("entry", 0))),
  7725:    112:         sl=float(d.get("sl", 0)),
  7726:    113:         tp1=float(d.get("tp1", 0)) or None,
  7727:    114:         tp2=float(d.get("tp2", 0)) or None,
  7728:    115:         score=d.get("score"),
  7729:    116:         quality=d.get("quality"),
  7730:    117:         reasons=d.get("reasons", []),
  7731:    118:     )
  7732:    119: 
  7733:    120: 
  7734:    121: def find_trade_positions(
  7735:    122:     client: Any,
  7736:    123:     pairs: List[Dict[str, Any]],
  7737:    124:     *,
  7738:    125:     interval: str = "1m",
  7739:    126:     ema_fast_n: Optional[int] = None,
  7740:    127:     ema_slow_n: Optional[int] = None,
  7741:    128:     ema_func=default_ema,
  7742:    129:     cross_func=default_cross,
  7743:    130: ) -> List[Signal]:
  7744:    131:     raw = _ancienne_impl(
  7745:    132:         client,
  7746:    133:         pairs,
  7747:    134:         interval=interval,
  7748:    135:         ema_fast_n=ema_fast_n,
  7749:    136:         ema_slow_n=ema_slow_n,
  7750:    137:         ema_func=ema_func,
  7751:    138:         cross_func=cross_func,
  7752:    139:     )
  7753:    140:     return [_to_signal(x) for x in raw]
  7754:    141: 
  7755:    142: 
  7756:    143: def send_selected_pairs(
  7757:    144:     client: Any,
  7758:    145:     top_n: int = 40,
  7759:    146:     *,
  7760:    147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
  7761:    148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
  7762:    149: ) -> Dict[str, str]:
  7763:    150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
  7764:    151: 
  7765:    152:     Returns the payload sent to ``notify_fn``. The mapping contains the
  7766:    153:     comma-separated symbols for each color group (``green``, ``orange`` and
  7767:    154:     ``red``) or an empty dictionary when no pairs are available.
  7768:    155:     """
  7769:    156: 
  7770:    157:     def split_symbol(sym: str) -> tuple[str, str]:
  7771:    158:         if "_" in sym:
  7772:    159:             left, right = sym.split("_", 1)
  7773:    160:             # Legacy style: BTC_USDT
  7774:    161:             if len(right) <= 4:
  7775:    162:                 return left, right
  7776:    163:             # Bitget futures style: BTCUSDT_UMCBL
  7777:    164:             main = left
  7778:    165:             if main.endswith("USDT"):
  7779:    166:                 return main[:-4], "USDT"
  7780:    167:             if main.endswith("USDC"):
  7781:    168:                 return main[:-4], "USDC"
  7782:    169:             if main.endswith("USD"):
  7783:    170:                 return main[:-3], "USD"
  7784:    171:             return main, ""
  7785:    172:         if sym.endswith("USDT"):
  7786:    173:             return sym[:-4], "USDT"
  7787:    174:         if sym.endswith("USDC"):
  7788:    175:             return sym[:-4], "USDC"
  7789:    176:         if sym.endswith("USD"):
  7790:    177:             return sym[:-3], "USD"
  7791:    178:         return sym, ""
  7792:    179: 
  7793:    180:     pairs = select_fn(client, top_n=top_n * 3)
  7794:    181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
  7795:    182:     by_base: Dict[str, Dict[str, Any]] = {}
  7796:    183:     for info in pairs:
  7797:    184:         sym = info.get("symbol")
  7798:    185:         if not sym:
  7799:    186:             continue
  7800:    187:         norm_sym = sym.split("_")[0].upper()
  7801:    188:         if allowed and norm_sym not in allowed:
  7802:    189:             continue
  7803:    190:         base, quote = split_symbol(sym)
  7804:    191:         existing = by_base.get(base)
  7805:    192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
  7806:    193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
  7807:    194:             by_base[base] = {"data": info, "quote": quote}
  7808:    195: 
  7809:    196:     unique = sorted(
  7810:    197:         (v["data"] for v in by_base.values()),
  7811:    198:         key=lambda row: float(row.get("volume", 0)),
  7812:    199:         reverse=True,
  7813:    200:     )
  7814:    201:     symbols: list[str] = []
  7815:    202:     for row in unique[:top_n]:
  7816:    203:         sym = row.get("symbol")
  7817:    204:         if not sym:
  7818:    205:             continue
  7819:    206:         base, _ = split_symbol(sym)
  7820:    207:         symbols.append(base)
  7821:    208:     if symbols:
  7822:    209:         n = len(symbols)
  7823:    210:         third = max(n // 3, 1)
  7824:    211:         green = symbols[:third]
  7825:    212:         orange = symbols[third : 2 * third]
  7826:    213:         red = symbols[2 * third :]
  7827:    214:         payload: Dict[str, str] = {}
  7828:    215:         if green:
  7829:    216:             payload["green"] = ", ".join(green)
  7830:    217:         if orange:
  7831:    218:             payload["orange"] = ", ".join(orange)
  7832:    219:         if red:
  7833:    220:             payload["red"] = ", ".join(red)
  7834:    221:         notify_fn("pair_list", payload)
  7835:    222:         return payload
  7836:    223:     return {}
  7837:    224: 
  7838:    225: 
  7839:    226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
  7840:    227:     """Return a heat score combining volatility, volume and a news flag."""
  7841:    228:     mult = 2.0 if news else 1.0
  7842:    229:     return volatility * volume * mult
  7843:    230: 
  7844:    231: 
  7845:    232: def select_top_heat_pairs(
  7846:    233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
  7847:    234: ) -> List[Dict[str, Any]]:
  7848:    235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
  7849:    236: 
  7850:    237:     scored: List[Dict[str, Any]] = []
  7851:    238:     for info in pairs:
  7852:    239:         try:
  7853:    240:             vol = float(info.get("volatility", 0))
  7854:    241:             volume = float(info.get("volume", 0))
  7855:    242:         except (TypeError, ValueError):
  7856:    243:             continue
  7857:    244:         score = heat_score(vol, volume, bool(info.get("news")))
  7858:    245:         row = dict(info)
  7859:    246:         row["heat_score"] = score
  7860:    247:         scored.append(row)
  7861:    248: 
  7862:    249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
  7863:    250:     return scored[:top_n]
  7864:    251: 
  7865:    252: 
  7866:    253: def decorrelate_pairs(
  7867:    254:     pairs: List[Dict[str, Any]],
  7868:    255:     corr: Dict[str, Dict[str, float]],
  7869:    256:     *,
  7870:    257:     threshold: float = 0.8,
  7871:    258:     top_n: int = 3,
  7872:    259: ) -> List[Dict[str, Any]]:
  7873:    260:     """Return top pairs while avoiding highly correlated symbols.
  7874:    261: 
  7875:    262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
  7876:    263:     pairs are considered too correlated when the absolute value of the
  7877:    264:     correlation exceeds ``threshold``.
  7878:    265:     """
  7879:    266: 
  7880:    267:     selected: List[Dict[str, Any]] = []
  7881:    268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
  7882:    269:         sym = info.get("symbol")
  7883:    270:         if not sym:
  7884:    271:             continue
  7885:    272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
  7886:    273:             selected.append(info)
  7887:    274:         if len(selected) >= top_n:
  7888:    275:             break
  7889:    276:     return selected
  7890: 
  7891: 
  7892: ## scalper/positions/__init__.py (last modified: 2025-08-23 20:57:14)
  7893: 
  7894: 
  7895: ## scalper/positions/state.py (last modified: 2025-08-23 20:57:14)
  7896:      1: from __future__ import annotations
  7897:      2: from dataclasses import dataclass, field
  7898:      3: from enum import Enum, auto
  7899:      4: from typing import List, Optional
  7900:      5: import time
  7901:      6: 
  7902:      7: class PositionStatus(Enum):
  7903:      8:     IDLE = auto()
  7904:      9:     PENDING_ENTRY = auto()
  7905:     10:     OPEN = auto()
  7906:     11:     PENDING_EXIT = auto()
  7907:     12:     CLOSED = auto()
  7908:     13: 
  7909:     14: class PositionSide(Enum):
  7910:     15:     LONG = 1
  7911:     16:     SHORT = -1
  7912:     17: 
  7913:     18: @dataclass
  7914:     19: class Fill:
  7915:     20:     order_id: str
  7916:     21:     trade_id: str
  7917:     22:     price: float
  7918:     23:     qty: float
  7919:     24:     fee: float
  7920:     25:     ts: int
  7921:     26: 
  7922:     27: @dataclass
  7923:     28: class PositionState:
  7924:     29:     symbol: str
  7925:     30:     side: PositionSide
  7926:     31:     status: PositionStatus = PositionStatus.IDLE
  7927:     32:     entry_order_id: Optional[str] = None
  7928:     33:     exit_order_id: Optional[str] = None
  7929:     34:     req_qty: float = 0.0
  7930:     35:     filled_qty: float = 0.0
  7931:     36:     avg_entry_price: float = 0.0
  7932:     37:     avg_exit_price: float = 0.0
  7933:     38:     sl: Optional[float] = None
  7934:     39:     tp: Optional[float] = None
  7935:     40:     realized_pnl: float = 0.0
  7936:     41:     fees: float = 0.0
  7937:     42:     opened_ts: Optional[int] = None
  7938:     43:     closed_ts: Optional[int] = None
  7939:     44:     fills: List[Fill] = field(default_factory=list)
  7940:     45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
  7941:     46: 
  7942:     47:     def apply_fill_entry(self, f: Fill) -> None:
  7943:     48:         self.fills.append(f)
  7944:     49:         self.filled_qty += f.qty
  7945:     50:         # moyenne pondérée
  7946:     51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
  7947:     52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
  7948:     53:         self.fees += abs(f.fee)
  7949:     54:         if self.opened_ts is None:
  7950:     55:             self.opened_ts = f.ts
  7951:     56:         if self.filled_qty > 1e-12:
  7952:     57:             self.status = PositionStatus.OPEN
  7953:     58: 
  7954:     59:     def apply_fill_exit(self, f: Fill) -> None:
  7955:     60:         self.fills.append(f)
  7956:     61:         qty = min(self.filled_qty, f.qty)
  7957:     62:         # realized pnl sur la quantité fermée
  7958:     63:         if self.side == PositionSide.LONG:
  7959:     64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
  7960:     65:         else:
  7961:     66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
  7962:     67:         self.fees += abs(f.fee)
  7963:     68:         self.filled_qty = max(0.0, self.filled_qty - qty)
  7964:     69:         # moyenne de sortie indicative
  7965:     70:         closed_q = (self.req_qty - self.filled_qty)
  7966:     71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
  7967:     72:         if self.filled_qty <= 1e-12:
  7968:     73:             self.status = PositionStatus.CLOSED
  7969:     74:             self.closed_ts = f.ts
  7970:     75: 
  7971: 
  7972: 
  7973: ## scalper/risk/__init__.py (last modified: 2025-08-23 20:57:14)
  7974:      1: # scalp/risk/__init__.py
  7975:      2: from .manager import (
  7976:      3:     Caps,
  7977:      4:     compute_size,
  7978:      5:     calc_position_size,  # alias legacy
  7979:      6:     RiskManager,         # shim legacy
  7980:      7: )
  7981:      8: 
  7982:      9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]
  7983: 
  7984: ## scalper/risk/manager.py (last modified: 2025-08-23 20:57:14)
  7985:      1: # scalp/risk/manager.py
  7986:      2: from __future__ import annotations
  7987:      3: from dataclasses import dataclass
  7988:      4: from typing import Optional, Dict, Any
  7989:      5: 
  7990:      6: @dataclass
  7991:      7: class Caps:
  7992:      8:     min_qty: float = 0.0
  7993:      9:     min_notional: float = 0.0
  7994:     10:     max_leverage: float = 20.0
  7995:     11: 
  7996:     12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
  7997:     13:     if not caps_by_symbol:
  7998:     14:         return Caps()
  7999:     15:     c = caps_by_symbol.get(symbol, {})
  8000:     16:     return Caps(
  8001:     17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
  8002:     18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
  8003:     19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
  8004:     20:     )
  8005:     21: 
  8006:     22: def compute_size(
  8007:     23:     *,
  8008:     24:     symbol: str,
  8009:     25:     price: float,
  8010:     26:     balance_cash: float,
  8011:     27:     risk_pct: float = 0.5,
  8012:     28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
  8013:     29: ) -> float:
  8014:     30:     """Sizing robuste avec gardes min_notional / min_qty."""
  8015:     31:     price = max(1e-9, float(price))
  8016:     32:     balance_cash = max(0.0, float(balance_cash))
  8017:     33:     risk_pct = max(0.0, float(risk_pct))
  8018:     34: 
  8019:     35:     notionnel = balance_cash * risk_pct
  8020:     36:     qty = notionnel / price
  8021:     37: 
  8022:     38:     caps = _get_caps(caps_by_symbol, symbol)
  8023:     39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
  8024:     40:         qty = caps.min_notional / price
  8025:     41:     if caps.min_qty > 0 and qty < caps.min_qty:
  8026:     42:         qty = caps.min_qty
  8027:     43:     return max(0.0, qty)
  8028:     44: 
  8029:     45: # --- Shims pour compatibilité ancienne API -----------------------------------
  8030:     46: 
  8031:     47: def calc_position_size(symbol: str, price: float, balance_cash: float,
  8032:     48:                        risk_pct: float = 0.5,
  8033:     49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
  8034:     50:     """Alias legacy → compute_size."""
  8035:     51:     return compute_size(
  8036:     52:         symbol=symbol, price=price, balance_cash=balance_cash,
  8037:     53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
  8038:     54:     )
  8039:     55: 
  8040:     56: class RiskManager:
  8041:     57:     """
  8042:     58:     Shim minimal compatible avec l'ancien code:
  8043:     59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
  8044:     60:       qty = rm.size(symbol, price, balance_cash)
  8045:     61:     """
  8046:     62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
  8047:     63:         self.risk_pct = float(risk_pct)
  8048:     64:         self.caps_by_symbol = caps_by_symbol or {}
  8049:     65: 
  8050:     66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
  8051:     67:         return compute_size(
  8052:     68:             symbol=symbol, price=price, balance_cash=balance_cash,
  8053:     69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  8054:     70:         )
  8055: 
  8056: ## scalper/selection/__init__.py (last modified: 2025-08-23 20:57:14)
  8057:      1: """Pair selection helpers for the Scalp bot.
  8058:      2: 
  8059:      3: This package exposes two utilities used during the preparation phase of the
  8060:      4: trading strategy:
  8061:      5: 
  8062:      6: ``scan_pairs``
  8063:      7:     Performs the first level market scan by filtering pairs based on volume,
  8064:      8:     spread and hourly volatility.
  8065:      9: 
  8066:     10: ``select_active_pairs``
  8067:     11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
  8068:     12:     crossover and a sufficiently high ATR.
  8069:     13: """
  8070:     14: 
  8071:     15: from .scanner import scan_pairs
  8072:     16: from .momentum import select_active_pairs
  8073:     17: 
  8074:     18: __all__ = ["scan_pairs", "select_active_pairs"]
  8075:     19: 
  8076: 
  8077: 
  8078: ## scalper/selection/momentum.py (last modified: 2025-08-23 20:57:14)
  8079:      1: """Utilities to select pairs exhibiting strong momentum."""
  8080:      2: 
  8081:      3: from __future__ import annotations
  8082:      4: 
  8083:      5: from typing import Any, Dict, List, Sequence
  8084:      6: 
  8085:      7: from ..metrics import calc_atr
  8086:      8: 
  8087:      9: 
  8088:     10: def ema(series: Sequence[float], window: int) -> List[float]:
  8089:     11:     """Simple exponential moving average implementation."""
  8090:     12: 
  8091:     13:     if window <= 1 or not series:
  8092:     14:         return list(series)
  8093:     15:     k = 2.0 / (window + 1.0)
  8094:     16:     out: List[float] = [float(series[0])]
  8095:     17:     prev = out[0]
  8096:     18:     for x in series[1:]:
  8097:     19:         prev = float(x) * k + prev * (1.0 - k)
  8098:     20:         out.append(prev)
  8099:     21:     return out
  8100:     22: 
  8101:     23: 
  8102:     24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  8103:     25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
  8104:     26: 
  8105:     27:     if prev_fast <= prev_slow and last_fast > last_slow:
  8106:     28:         return 1
  8107:     29:     if prev_fast >= prev_slow and last_fast < last_slow:
  8108:     30:         return -1
  8109:     31:     return 0
  8110:     32: 
  8111:     33: 
  8112:     34: def _quantile(values: Sequence[float], q: float) -> float:
  8113:     35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
  8114:     36: 
  8115:     37:     if not values:
  8116:     38:         return 0.0
  8117:     39:     q = min(max(q, 0.0), 1.0)
  8118:     40:     vals = sorted(values)
  8119:     41:     idx = int((len(vals) - 1) * q)
  8120:     42:     return vals[idx]
  8121:     43: 
  8122:     44: 
  8123:     45: def select_active_pairs(
  8124:     46:     client: Any,
  8125:     47:     pairs: Sequence[Dict[str, Any]],
  8126:     48:     *,
  8127:     49:     interval: str = "Min5",
  8128:     50:     ema_fast: int = 20,
  8129:     51:     ema_slow: int = 50,
  8130:     52:     atr_period: int = 14,
  8131:     53:     atr_quantile: float = 0.5,
  8132:     54:     top_n: int = 5,
  8133:     55: ) -> List[Dict[str, Any]]:
  8134:     56:     """Return pairs with an EMA crossover and high ATR.
  8135:     57: 
  8136:     58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
  8137:     59:     Among those candidates, the Average True Range is computed and only pairs
  8138:     60:     whose ATR is above the provided quantile are returned.  The resulting
  8139:     61:     dictionaries include an ``atr`` key for convenience.
  8140:     62:     """
  8141:     63: 
  8142:     64:     candidates: List[Dict[str, Any]] = []
  8143:     65:     atrs: List[float] = []
  8144:     66: 
  8145:     67:     for info in pairs:
  8146:     68:         sym = info.get("symbol")
  8147:     69:         if not sym:
  8148:     70:             continue
  8149:     71:         k = client.get_kline(sym, interval=interval)
  8150:     72:         kdata = k.get("data") if isinstance(k, dict) else {}
  8151:     73:         closes = kdata.get("close", [])
  8152:     74:         highs = kdata.get("high", [])
  8153:     75:         lows = kdata.get("low", [])
  8154:     76:         if len(closes) < max(ema_slow, atr_period) + 2:
  8155:     77:             continue
  8156:     78:         efast = ema(closes, ema_fast)
  8157:     79:         eslow = ema(closes, ema_slow)
  8158:     80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
  8159:     81:             continue
  8160:     82:         atr_val = calc_atr(highs, lows, closes, atr_period)
  8161:     83:         row = dict(info)
  8162:     84:         row["atr"] = atr_val
  8163:     85:         candidates.append(row)
  8164:     86:         atrs.append(atr_val)
  8165:     87: 
  8166:     88:     if not candidates:
  8167:     89:         return []
  8168:     90: 
  8169:     91:     threshold = _quantile(atrs, atr_quantile)
  8170:     92:     selected = [row for row in candidates if row["atr"] >= threshold]
  8171:     93:     selected.sort(key=lambda r: r["atr"], reverse=True)
  8172:     94:     return selected[:top_n]
  8173:     95: 
  8174:     96: 
  8175:     97: __all__ = ["select_active_pairs"]
  8176:     98: 
  8177: 
  8178: 
  8179: ## scalper/selection/scanner.py (last modified: 2025-08-23 20:57:14)
  8180:      1: """Utilities for scanning tradable pairs on the exchange."""
  8181:      2: 
  8182:      3: from __future__ import annotations
  8183:      4: 
  8184:      5: from typing import Any, Dict, List
  8185:      6: 
  8186:      7: 
  8187:      8: def scan_pairs(
  8188:      9:     client: Any,
  8189:     10:     *,
  8190:     11:     volume_min: float = 5_000_000,
  8191:     12:     max_spread_bps: float = 5.0,
  8192:     13:     min_hourly_vol: float = 0.0,
  8193:     14:     top_n: int = 40,
  8194:     15: ) -> List[Dict[str, Any]]:
  8195:     16:     """Return pairs satisfying basic liquidity and volatility filters.
  8196:     17: 
  8197:     18:     Parameters
  8198:     19:     ----------
  8199:     20:     client: Any
  8200:     21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
  8201:     22:     volume_min: float, optional
  8202:     23:         Minimum 24h volume required to keep a pair.
  8203:     24:     max_spread_bps: float, optional
  8204:     25:         Maximum allowed bid/ask spread expressed in basis points.
  8205:     26:     min_hourly_vol: float, optional
  8206:     27:         Minimum volatility over the last hour expressed as ``(high - low) /
  8207:     28:         close``.  When set to ``0`` the filter is disabled.
  8208:     29:     top_n: int, optional
  8209:     30:         Limit the number of returned pairs.
  8210:     31:     """
  8211:     32: 
  8212:     33:     tick = client.get_ticker()
  8213:     34:     data = tick.get("data") if isinstance(tick, dict) else []
  8214:     35:     if not isinstance(data, list):
  8215:     36:         data = [data]
  8216:     37: 
  8217:     38:     eligible: List[Dict[str, Any]] = []
  8218:     39: 
  8219:     40:     for row in data:
  8220:     41:         sym = row.get("symbol")
  8221:     42:         if not sym:
  8222:     43:             continue
  8223:     44:         try:
  8224:     45:             vol = float(row.get("volume", 0))
  8225:     46:             bid = float(row.get("bidPrice", 0))
  8226:     47:             ask = float(row.get("askPrice", 0))
  8227:     48:         except (TypeError, ValueError):
  8228:     49:             continue
  8229:     50:         if vol < volume_min or bid <= 0 or ask <= 0:
  8230:     51:             continue
  8231:     52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
  8232:     53:         if spread_bps >= max_spread_bps:
  8233:     54:             continue
  8234:     55: 
  8235:     56:         if min_hourly_vol > 0:
  8236:     57:             k = client.get_kline(sym, interval="Min60")
  8237:     58:             kdata = k.get("data") if isinstance(k, dict) else {}
  8238:     59:             highs = kdata.get("high", [])
  8239:     60:             lows = kdata.get("low", [])
  8240:     61:             closes = kdata.get("close", [])
  8241:     62:             if not highs or not lows or not closes:
  8242:     63:                 continue
  8243:     64:             try:
  8244:     65:                 h = float(highs[-1])
  8245:     66:                 l = float(lows[-1])
  8246:     67:                 c = float(closes[-1])
  8247:     68:             except (TypeError, ValueError):
  8248:     69:                 continue
  8249:     70:             hourly_vol = (h - l) / c if c else 0.0
  8250:     71:             if hourly_vol < min_hourly_vol:
  8251:     72:                 continue
  8252:     73: 
  8253:     74:         eligible.append(row)
  8254:     75: 
  8255:     76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
  8256:     77:     return eligible[:top_n]
  8257:     78: 
  8258:     79: 
  8259:     80: __all__ = ["scan_pairs"]
  8260:     81: 
  8261: 
  8262: 
  8263: ## scalper/selfcheck.py (last modified: 2025-08-23 20:57:14)
  8264:      1: # scalper/selfcheck.py
  8265:      2: from __future__ import annotations
  8266:      3: import os, sys, importlib, traceback
  8267:      4: from pathlib import Path
  8268:      5: 
  8269:      6: NOTEBOOKS = Path("/notebooks")
  8270:      7: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
  8271:      8: 
  8272:      9: def _mask(val: str) -> str:
  8273:     10:     if not val: return ""
  8274:     11:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
  8275:     12: 
  8276:     13: def _try_import(modname: str):
  8277:     14:     try:
  8278:     15:         m = importlib.import_module(modname)
  8279:     16:         return True, m
  8280:     17:     except Exception:
  8281:     18:         return False, traceback.format_exc()
  8282:     19: 
  8283:     20: def preflight(verbose: bool = False) -> list[str]:
  8284:     21:     """
  8285:     22:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
  8286:     23:     Ne lève pas d'exception. N'écrit que de l'info lisible.
  8287:     24:     """
  8288:     25:     issues: list[str] = []
  8289:     26:     # s'assurer que le repo est bien dans sys.path
  8290:     27:     if str(REPO) not in sys.path:
  8291:     28:         sys.path.insert(0, str(REPO))
  8292:     29: 
  8293:     30:     print("=== SCALPER PREFLIGHT ===")
  8294:     31:     print(f"[i] Repo: {REPO}")
  8295:     32:     print(f"[i] Python: {sys.version.split()[0]}")
  8296:     33: 
  8297:     34:     # backtest API
  8298:     35:     ok, mod = _try_import("scalper.backtest")
  8299:     36:     if not ok:
  8300:     37:         print("[✗] Import scalper.backtest KO")
  8301:     38:         if verbose: print(mod)  # ici 'mod' contient la trace
  8302:     39:         issues.append("backtest import")
  8303:     40:     else:
  8304:     41:         has_single = hasattr(mod, "run_single")
  8305:     42:         has_multi  = hasattr(mod, "run_multi")
  8306:     43:         print(f"[✓] scalper.backtest: run_single={has_single} run_multi={has_multi}")
  8307:     44:         if not (has_single and has_multi):
  8308:     45:             issues.append("backtest API incomplète")
  8309:     46: 
  8310:     47:     # trade_utils
  8311:     48:     ok, mod = _try_import("scalper.trade_utils")
  8312:     49:     if not ok:
  8313:     50:         print("[✗] Import scalper.trade_utils KO")
  8314:     51:         if verbose: print(mod)
  8315:     52:         issues.append("trade_utils import")
  8316:     53:     else:
  8317:     54:         print(f"[✓] scalper.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
  8318:     55: 
  8319:     56:     # fees
  8320:     57:     ok, mod = _try_import("scalper.exchange.fees")
  8321:     58:     if not ok:
  8322:     59:         print("[✗] Import scalper.exchange.fees KO")
  8323:     60:         if verbose: print(mod)
  8324:     61:         issues.append("fees import")
  8325:     62:     else:
  8326:     63:         need = {"get_fee", "load_bitget_fees"}
  8327:     64:         miss = [n for n in need if not hasattr(mod, n)]
  8328:     65:         if miss: issues.append("fees API manquante: " + ",".join(miss))
  8329:     66:         print("[✓] scalper.exchange.fees OK")
  8330:     67: 
  8331:     68:     # notify/commands/backtest_telegram/orchestrator
  8332:     69:     for name, required in [
  8333:     70:         ("scalper.live.notify", ("build_notifier_and_stream",)),
  8334:     71:         ("scalper.live.commands", ("CommandHandler",)),
  8335:     72:         ("scalper.live.backtest_telegram", ("handle_backtest_command",)),
  8336:     73:         ("scalper.live.orchestrator", ("run_orchestrator", "Orchestrator")),
  8337:     74:     ]:
  8338:     75:         ok, mod = _try_import(name)
  8339:     76:         if not ok:
  8340:     77:             print(f"[✗] Import {name} KO")
  8341:     78:             if verbose: print(mod)
  8342:     79:             issues.append(f"{name} import")
  8343:     80:         else:
  8344:     81:             miss = [a for a in required if not hasattr(mod, a)]
  8345:     82:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
  8346:     83:             print(f"[✓] {name} OK")
  8347:     84: 
  8348:     85:     # ENV (masqué)
  8349:     86:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
  8350:     87:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
  8351:     88:     gu   = os.getenv("GIT_USER", "")
  8352:     89:     gt   = os.getenv("GIT_TOKEN", "")
  8353:     90:     print("\n-- ENV --")
  8354:     91:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
  8355:     92:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
  8356:     93:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
  8357:     94:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
  8358:     95: 
  8359:     96:     # Data
  8360:     97:     data_dir = (REPO / "data")
  8361:     98:     print("\n-- DATA --")
  8362:     99:     if data_dir.exists():
  8363:    100:         csvs = list(data_dir.glob("*.csv"))
  8364:    101:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
  8365:    102:     else:
  8366:    103:         print("  data/ absent (OK si loader API)")
  8367:    104: 
  8368:    105:     return issues
  8369:    106: 
  8370:    107: def preflight_or_die(verbose: bool = False) -> None:
  8371:    108:     issues = preflight(verbose=verbose)
  8372:    109:     if issues:
  8373:    110:         print("\n[✗] Préflight a détecté des problèmes :")
  8374:    111:         for it in issues: print("   -", it)
  8375:    112:         print("\nConseils :")
  8376:    113:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
  8377:    114:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
  8378:    115:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
  8379:    116:         raise SystemExit(1)
  8380:    117:     print("\n[✓] Préflight OK — démarrage du bot.")
  8381: 
  8382: ## scalper/services/__init__.py (last modified: 2025-08-23 20:57:14)
  8383: 
  8384: 
  8385: ## scalper/services/data_cache.py (last modified: 2025-08-23 20:57:14)
  8386:      1: # scalper/services/data_cache.py
  8387:      2: from __future__ import annotations
  8388:      3: 
  8389:      4: import asyncio
  8390:      5: import csv
  8391:      6: import os
  8392:      7: import time
  8393:      8: from typing import Iterable, List, Optional, Tuple, Dict
  8394:      9: 
  8395:     10: # ---------------------------------------------------------------------
  8396:     11: # Réglages via env (valeurs sûres par défaut)
  8397:     12: # ---------------------------------------------------------------------
  8398:     13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
  8399:     14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
  8400:     15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
  8401:     16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
  8402:     17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
  8403:     18: 
  8404:     19: os.makedirs(DATA_DIR, exist_ok=True)
  8405:     20: 
  8406:     21: 
  8407:     22: # ---------------------------------------------------------------------
  8408:     23: # Helpers
  8409:     24: # ---------------------------------------------------------------------
  8410:     25: def parse_timeframe_to_seconds(tf: str) -> int:
  8411:     26:     tf = tf.strip().lower()
  8412:     27:     unit = tf[-1]
  8413:     28:     try:
  8414:     29:         n = int(tf[:-1])
  8415:     30:     except Exception as e:
  8416:     31:         raise ValueError(f"timeframe invalide: {tf}") from e
  8417:     32:     if unit == "m":
  8418:     33:         return n * 60
  8419:     34:     if unit == "h":
  8420:     35:         return n * 3600
  8421:     36:     if unit == "d":
  8422:     37:         return n * 86400
  8423:     38:     raise ValueError(f"timeframe invalide: {tf}")
  8424:     39: 
  8425:     40: 
  8426:     41: def csv_path(symbol: str, timeframe: str) -> str:
  8427:     42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
  8428:     43: 
  8429:     44: 
  8430:     45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
  8431:     46:     rows: List[Tuple[int, float, float, float, float, float]] = []
  8432:     47:     if not os.path.exists(path):
  8433:     48:         return rows
  8434:     49:     with open(path, "r", newline="") as f:
  8435:     50:         r = csv.reader(f)
  8436:     51:         header = next(r, None)  # accepte avec ou sans header
  8437:     52:         for line in r:
  8438:     53:             if not line:
  8439:     54:                 continue
  8440:     55:             ts, o, h, l, c, v = line[:6]
  8441:     56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  8442:     57:     return rows
  8443:     58: 
  8444:     59: 
  8445:     60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
  8446:     61:     first = not os.path.exists(path)
  8447:     62:     os.makedirs(os.path.dirname(path), exist_ok=True)
  8448:     63:     with open(path, "a", newline="") as f:
  8449:     64:         w = csv.writer(f)
  8450:     65:         if first:
  8451:     66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
  8452:     67:         for row in data:
  8453:     68:             w.writerow(row)
  8454:     69: 
  8455:     70: 
  8456:     71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
  8457:     72:     return rows[-1][0] if rows else None
  8458:     73: 
  8459:     74: 
  8460:     75: # ---------------------------------------------------------------------
  8461:     76: # Fetch CCXT paginé
  8462:     77: # ---------------------------------------------------------------------
  8463:     78: async def ccxt_fetch_ohlcv_all(
  8464:     79:     exchange,
  8465:     80:     symbol: str,
  8466:     81:     timeframe: str,
  8467:     82:     since_ms: Optional[int],
  8468:     83:     limit: int = 1000,
  8469:     84: ) -> List[Tuple[int, float, float, float, float, float]]:
  8470:     85:     """
  8471:     86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
  8472:     87:     Retourne une liste triée/dédupliquée.
  8473:     88:     """
  8474:     89:     out: List[Tuple[int, float, float, float, float, float]] = []
  8475:     90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
  8476:     91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
  8477:     92: 
  8478:     93:     cursor = since_ms or (now_ms - 200 * tf_ms)
  8479:     94:     while True:
  8480:     95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
  8481:     96:         if not batch:
  8482:     97:             break
  8483:     98:         for ts, o, h, l, c, v in batch:
  8484:     99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  8485:    100:         next_cursor = batch[-1][0] + tf_ms
  8486:    101:         if next_cursor <= cursor:
  8487:    102:             break
  8488:    103:         cursor = next_cursor
  8489:    104:         if cursor >= now_ms + (2 * tf_ms):
  8490:    105:             break
  8491:    106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
  8492:    107: 
  8493:    108:     out.sort(key=lambda x: x[0])
  8494:    109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
  8495:    110:     seen = set()
  8496:    111:     for row in out:
  8497:    112:         if row[0] in seen:
  8498:    113:             continue
  8499:    114:         seen.add(row[0])
  8500:    115:         dedup.append(row)
  8501:    116:     return dedup
  8502:    117: 
  8503:    118: 
  8504:    119: # ---------------------------------------------------------------------
  8505:    120: # Cache manager
  8506:    121: # ---------------------------------------------------------------------
  8507:    122: async def ensure_symbol_csv_cache(
  8508:    123:     exchange,
  8509:    124:     symbol: str,
  8510:    125:     timeframe: str,
  8511:    126:     min_rows: int = CSV_MIN_ROWS,
  8512:    127: ) -> str:
  8513:    128:     """
  8514:    129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
  8515:    130:     Crée/append si nécessaire. Retourne le chemin.
  8516:    131:     """
  8517:    132:     path = csv_path(symbol, timeframe)
  8518:    133:     rows = read_csv_ohlcv(path)
  8519:    134:     tf_sec = parse_timeframe_to_seconds(timeframe)
  8520:    135:     tf_ms = tf_sec * 1000
  8521:    136:     now_ms = int(time.time() * 1000)
  8522:    137: 
  8523:    138:     # âge max
  8524:    139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
  8525:    140: 
  8526:    141:     need_full = False
  8527:    142:     need_append = False
  8528:    143: 
  8529:    144:     if not rows:
  8530:    145:         need_full = True
  8531:    146:     else:
  8532:    147:         last = last_ts(rows) or 0
  8533:    148:         age_sec = max(0, (now_ms - last) // 1000)
  8534:    149:         if age_sec > max_age or len(rows) < min_rows:
  8535:    150:             need_append = True
  8536:    151: 
  8537:    152:     if need_full:
  8538:    153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
  8539:    154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8540:    155:         if len(fresh) < min_rows:
  8541:    156:             since = now_ms - (tf_ms * 5000)
  8542:    157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8543:    158:         if os.path.exists(path):
  8544:    159:             os.remove(path)
  8545:    160:         write_csv_ohlcv(path, fresh)
  8546:    161:         return path
  8547:    162: 
  8548:    163:     if need_append:
  8549:    164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
  8550:    165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  8551:    166:         if fresh:
  8552:    167:             write_csv_ohlcv(path, fresh)
  8553:    168: 
  8554:    169:     return path
  8555:    170: 
  8556:    171: 
  8557:    172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
  8558:    173:     """
  8559:    174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
  8560:    175:     Retourne {symbol: path}.
  8561:    176:     """
  8562:    177:     sem = asyncio.Semaphore(PREFETCH_CONC)
  8563:    178:     result: Dict[str, str] = {}
  8564:    179: 
  8565:    180:     async def _one(sym: str):
  8566:    181:         async with sem:
  8567:    182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
  8568:    183:             result[sym] = p
  8569:    184: 
  8570:    185:     await asyncio.gather(*[_one(s) for s in symbols])
  8571:    186:     return result
  8572: 
  8573: ## scalper/services/order_service.py (last modified: 2025-08-23 20:57:14)
  8574:      1: from __future__ import annotations
  8575:      2: from dataclasses import dataclass
  8576:      3: from typing import Any, Dict, Optional, Protocol
  8577:      4: from scalper.trade_utils import extract_available_balance
  8578:      5: 
  8579:      6: 
  8580:      7: @dataclass
  8581:      8: class OrderCaps:
  8582:      9:     min_trade_usdt: float = 5.0
  8583:     10:     leverage: float = 1.0
  8584:     11: 
  8585:     12: 
  8586:     13: @dataclass
  8587:     14: class OrderRequest:
  8588:     15:     symbol: str
  8589:     16:     side: str
  8590:     17:     price: float
  8591:     18:     sl: float
  8592:     19:     tp: Optional[float]
  8593:     20:     risk_pct: float
  8594:     21: 
  8595:     22: 
  8596:     23: @dataclass
  8597:     24: class OrderResult:
  8598:     25:     accepted: bool
  8599:     26:     reason: str = ""
  8600:     27:     payload: Dict[str, Any] = None
  8601:     28:     order_id: Optional[str] = None
  8602:     29:     status: Optional[str] = None
  8603:     30:     avg_price: Optional[float] = None
  8604:     31:     filled_qty: Optional[float] = None
  8605:     32: 
  8606:     33: 
  8607:     34: class Exchange(Protocol):
  8608:     35:     def get_assets(self) -> Dict[str, Any]: ...
  8609:     36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
  8610:     37:     def place_order(
  8611:     38:         self,
  8612:     39:         symbol: str,
  8613:     40:         side: str,
  8614:     41:         quantity: float,
  8615:     42:         order_type: str,
  8616:     43:         price: Optional[float] = None,
  8617:     44:         stop_loss: Optional[float] = None,
  8618:     45:         take_profit: Optional[float] = None,
  8619:     46:     ) -> Dict[str, Any]: ...
  8620:     47: 
  8621:     48: 
  8622:     49: class OrderService:
  8623:     50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
  8624:     51:         self.exchange = exchange
  8625:     52:         self.caps = caps
  8626:     53: 
  8627:     54:     @staticmethod
  8628:     55:     def _abs(x: float) -> float:
  8629:     56:         return -x if x < 0 else x
  8630:     57: 
  8631:     58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
  8632:     59:         dist = self._abs(price - sl)
  8633:     60:         if dist <= 0:
  8634:     61:             return 0.0
  8635:     62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
  8636:     63:         return 0.0 if price <= 0 else (risk_usdt / dist)
  8637:     64: 
  8638:     65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
  8639:     66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
  8640:     67:         if qty <= 0:
  8641:     68:             return OrderResult(False, "invalid_size")
  8642:     69:         notional = qty * req.price
  8643:     70:         if notional < self.caps.min_trade_usdt:
  8644:     71:             return OrderResult(False, "under_min_notional")
  8645:     72:         assets = self.exchange.get_assets()
  8646:     73:         available = extract_available_balance(assets)
  8647:     74:         required_margin = notional / max(1.0, self.caps.leverage)
  8648:     75:         if available < required_margin:
  8649:     76:             return OrderResult(False, "insufficient_margin")
  8650:     77:         side = "BUY" if req.side == "long" else "SELL"
  8651:     78:         out = self.exchange.place_order(
  8652:     79:             symbol=req.symbol, side=side, quantity=qty,
  8653:     80:             order_type="limit", price=req.price,
  8654:     81:             stop_loss=req.sl, take_profit=req.tp
  8655:     82:         )
  8656:     83:         # extraire infos utiles
  8657:     84:         oid = None; status = None; avg = None; filled = None
  8658:     85:         try:
  8659:     86:             data = out.get("data") if isinstance(out, dict) else out
  8660:     87:             if isinstance(data, dict):
  8661:     88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
  8662:     89:                 status = (data.get("status") or data.get("state") or "new").lower()
  8663:     90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
  8664:     91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
  8665:     92:         except Exception:
  8666:     93:             pass
  8667:     94:         return OrderResult(True, "", out, oid, status, avg, filled)
  8668: 
  8669: 
  8670: ## scalper/services/utils.py (last modified: 2025-08-23 20:57:14)
  8671:      1: # scalper/services/utils.py
  8672:      2: from __future__ import annotations
  8673:      3: import asyncio
  8674:      4: from typing import Callable, Any
  8675:      5: 
  8676:      6: 
  8677:      7: class NullNotifier:
  8678:      8:     async def send(self, _msg: str) -> None:
  8679:      9:         return
  8680:     10: 
  8681:     11: 
  8682:     12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
  8683:     13:     if notifier is None:
  8684:     14:         notifier = NullNotifier()
  8685:     15:     try:
  8686:     16:         while running_getter():
  8687:     17:             await notifier.send("heartbeat alive")
  8688:     18:             await asyncio.sleep(period)
  8689:     19:     except asyncio.CancelledError:
  8690:     20:         pass
  8691:     21: 
  8692:     22: 
  8693:     23: async def log_stats_task(
  8694:     24:     notifier: Any,
  8695:     25:     ticks_getter: Callable[[], int],
  8696:     26:     symbols_getter: Callable[[], list[str]],
  8697:     27:     period: float = 30.0,
  8698:     28: ) -> None:
  8699:     29:     if notifier is None:
  8700:     30:         notifier = NullNotifier()
  8701:     31:     last = 0
  8702:     32:     try:
  8703:     33:         while True:
  8704:     34:             total = int(ticks_getter() or 0)
  8705:     35:             delta = total - last
  8706:     36:             last = total
  8707:     37:             syms = symbols_getter() or []
  8708:     38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
  8709:     39:             print(msg)
  8710:     40:             await notifier.send(msg)
  8711:     41:             await asyncio.sleep(period)
  8712:     42:     except asyncio.CancelledError:
  8713:     43:         pass
  8714: 
  8715: ## scalper/signals/__init__.py (last modified: 2025-08-23 20:57:14)
  8716:      1: # scalper/signals/__init__.py
  8717:      2: from .factory import load_signal, available_strategies
  8718:      3: 
  8719:      4: __all__ = ["load_signal", "available_strategies"]
  8720: 
  8721: ## scalper/signals/current.py (last modified: 2025-08-23 20:57:14)
  8722:      1: # scalper/signals/current.py
  8723:      2: from __future__ import annotations
  8724:      3: 
  8725:      4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
  8726:      5: from scalper.strategy import generate_signal as _generate_signal
  8727:      6: 
  8728:      7: def generate_signal(**kwargs):
  8729:      8:     """
  8730:      9:     Expose la même signature que scalper.strategy.generate_signal.
  8731:     10:     Sert d’adaptateur pour la factory.
  8732:     11:     """
  8733:     12:     return _generate_signal(**kwargs)
  8734: 
  8735: ## scalper/signals/factory.py (last modified: 2025-08-23 20:57:14)
  8736:      1: # scalper/signals/factory.py
  8737:      2: from __future__ import annotations
  8738:      3: 
  8739:      4: import importlib
  8740:      5: import importlib.util
  8741:      6: from typing import Callable, Dict, Optional
  8742:      7: 
  8743:      8: SignalFn = Callable[..., object]
  8744:      9: 
  8745:     10: # Mapping symbolique -> module (tu peux en ajouter librement)
  8746:     11: _REGISTRY: Dict[str, str] = {
  8747:     12:     # Stratégie "actuelle" (renvoie scalper.strategy.generate_signal)
  8748:     13:     "current": "scalper.signals.current",
  8749:     14: 
  8750:     15:     # Exemples de plugins (crée les fichiers si tu veux les utiliser)
  8751:     16:     "ema_cross": "scalper.signals.ema_cross",
  8752:     17:     "vwap_break": "scalper.signals.vwap_break",
  8753:     18: }
  8754:     19: 
  8755:     20: def _module_exists(modname: str) -> bool:
  8756:     21:     return importlib.util.find_spec(modname) is not None
  8757:     22: 
  8758:     23: def load_signal(name: str, *, default: str = "current") -> SignalFn:
  8759:     24:     """
  8760:     25:     Charge et retourne une fonction `generate_signal` pour la stratégie `name`.
  8761:     26:     Si le module n'existe pas, on retombe sur `default` (courant: 'current').
  8762:     27:     """
  8763:     28:     target = _REGISTRY.get(name, _REGISTRY.get(default, "scalper.signals.current"))
  8764:     29:     if not _module_exists(target):
  8765:     30:         # fallback direct sur 'current'
  8766:     31:         target = _REGISTRY.get(default, "scalper.signals.current")
  8767:     32: 
  8768:     33:     mod = importlib.import_module(target)
  8769:     34:     fn = getattr(mod, "generate_signal", None)
  8770:     35:     if not callable(fn):
  8771:     36:         # dernier filet de sécurité : stratégie live directe
  8772:     37:         from scalper.strategy import generate_signal as live_generate
  8773:     38:         return live_generate
  8774:     39:     return fn
  8775:     40: 
  8776:     41: def available_strategies() -> Dict[str, str]:
  8777:     42:     """
  8778:     43:     Retourne {nom: 'ok'/'missing'} pour afficher ce qui est disponible.
  8779:     44:     """
  8780:     45:     out: Dict[str, str] = {}
  8781:     46:     for name, mod in _REGISTRY.items():
  8782:     47:         out[name] = "ok" if _module_exists(mod) else "missing"
  8783:     48:     return out
  8784: 
  8785: ## scalper/signals/generator.py (last modified: 2025-08-23 20:57:14)
  8786:      1: from __future__ import annotations
  8787:      2: 
  8788:      3: from typing import Any, Dict, List, Optional
  8789:      4: 
  8790:      5: import pandas as pd
  8791:      6: 
  8792:      7: from data.indicators import compute_all
  8793:      8: 
  8794:      9: __all__ = ["generate_signal"]
  8795:     10: 
  8796:     11: 
  8797:     12: def _quality_from_score(score: float) -> str:
  8798:     13:     if score >= 0.8:
  8799:     14:         return "A"
  8800:     15:     if score >= 0.5:
  8801:     16:         return "B"
  8802:     17:     return "C"
  8803:     18: 
  8804:     19: 
  8805:     20: def generate_signal(
  8806:     21:     df: pd.DataFrame,
  8807:     22:     *,
  8808:     23:     trend_tf: Optional[pd.DataFrame] = None,
  8809:     24:     confirm_tf: Optional[pd.DataFrame] = None,
  8810:     25:     atr_mult: float = 1.0,
  8811:     26:     trailing: bool = False,
  8812:     27:     **_: Any,
  8813:     28: ) -> Optional[Dict[str, Any]]:
  8814:     29:     """Generate a trading signal with confluence scoring.
  8815:     30: 
  8816:     31:     Parameters
  8817:     32:     ----------
  8818:     33:     df: pd.DataFrame
  8819:     34:         Primary timeframe OHLCV data.
  8820:     35:     trend_tf: pd.DataFrame, optional
  8821:     36:         Higher timeframe used for trend filtering.
  8822:     37:     confirm_tf: pd.DataFrame, optional
  8823:     38:         Lower timeframe used for confirmation.
  8824:     39:     atr_mult: float, optional
  8825:     40:         Multiplier applied to ATR for stop/target calculation.
  8826:     41:     trailing: bool, optional
  8827:     42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
  8828:     43: 
  8829:     44:     Returns
  8830:     45:     -------
  8831:     46:     dict | None
  8832:     47:         Dictionary describing the signal or ``None`` if no trade setup exists.
  8833:     48:     """
  8834:     49: 
  8835:     50:     if df is None or len(df) < 2:
  8836:     51:         return None
  8837:     52: 
  8838:     53:     df = compute_all(df)
  8839:     54:     last = df.iloc[-1]
  8840:     55: 
  8841:     56:     conditions: List[bool] = []
  8842:     57:     reasons: List[str] = []
  8843:     58:     direction: Optional[str] = None
  8844:     59: 
  8845:     60:     # --- Basic trend via EMAs ----------------------------------------------
  8846:     61:     if last["close"] > last["ema20"] > last["ema50"]:
  8847:     62:         direction = "long"
  8848:     63:         reasons.append("price_above_ema")
  8849:     64:         conditions.append(True)
  8850:     65:     elif last["close"] < last["ema20"] < last["ema50"]:
  8851:     66:         direction = "short"
  8852:     67:         reasons.append("price_below_ema")
  8853:     68:         conditions.append(True)
  8854:     69:     else:
  8855:     70:         conditions.append(False)
  8856:     71:         return None
  8857:     72: 
  8858:     73:     # --- RSI ---------------------------------------------------------------
  8859:     74:     if direction == "long":
  8860:     75:         cond = last["rsi"] > 55
  8861:     76:         if cond:
  8862:     77:             reasons.append("rsi_bullish")
  8863:     78:         conditions.append(cond)
  8864:     79:     else:
  8865:     80:         cond = last["rsi"] < 45
  8866:     81:         if cond:
  8867:     82:             reasons.append("rsi_bearish")
  8868:     83:         conditions.append(cond)
  8869:     84: 
  8870:     85:     # --- MACD --------------------------------------------------------------
  8871:     86:     if direction == "long":
  8872:     87:         cond = last["macd"] > last["macd_signal"]
  8873:     88:         if cond:
  8874:     89:             reasons.append("macd_bullish")
  8875:     90:         conditions.append(cond)
  8876:     91:     else:
  8877:     92:         cond = last["macd"] < last["macd_signal"]
  8878:     93:         if cond:
  8879:     94:             reasons.append("macd_bearish")
  8880:     95:         conditions.append(cond)
  8881:     96: 
  8882:     97:     # --- OBV momentum ------------------------------------------------------
  8883:     98:     if len(df) >= 2:
  8884:     99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
  8885:    100:         if obv_up:
  8886:    101:             reasons.append("obv_trending")
  8887:    102:         conditions.append(obv_up)
  8888:    103: 
  8889:    104:     # --- Trend timeframe filter -------------------------------------------
  8890:    105:     if trend_tf is not None and len(trend_tf) >= 2:
  8891:    106:         tdf = compute_all(trend_tf)
  8892:    107:         ema50 = tdf["ema50"]
  8893:    108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
  8894:    109:         if direction == "long":
  8895:    110:             cond = slope > 0
  8896:    111:             if cond:
  8897:    112:                 reasons.append("trend_up")
  8898:    113:             conditions.append(cond)
  8899:    114:         else:
  8900:    115:             cond = slope < 0
  8901:    116:             if cond:
  8902:    117:                 reasons.append("trend_down")
  8903:    118:             conditions.append(cond)
  8904:    119: 
  8905:    120:     # --- Confirmation timeframe filter ------------------------------------
  8906:    121:     if confirm_tf is not None and len(confirm_tf) > 0:
  8907:    122:         cdf = compute_all(confirm_tf)
  8908:    123:         rsi = cdf["rsi"].iloc[-1]
  8909:    124:         if direction == "long":
  8910:    125:             cond = rsi > 50
  8911:    126:             if cond:
  8912:    127:                 reasons.append("confirm_rsi_bullish")
  8913:    128:             conditions.append(cond)
  8914:    129:         else:
  8915:    130:             cond = rsi < 50
  8916:    131:             if cond:
  8917:    132:                 reasons.append("confirm_rsi_bearish")
  8918:    133:             conditions.append(cond)
  8919:    134: 
  8920:    135:     score = (
  8921:    136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
  8922:    137:     )
  8923:    138:     quality = _quality_from_score(score)
  8924:    139: 
  8925:    140:     atr = last.get("atr")
  8926:    141:     if pd.isna(atr) or atr == 0:
  8927:    142:         return None
  8928:    143: 
  8929:    144:     entry = float(last["close"])
  8930:    145:     if direction == "long":
  8931:    146:         sl = entry - atr * atr_mult
  8932:    147:         tp = entry + atr * atr_mult * 2
  8933:    148:     else:
  8934:    149:         sl = entry + atr * atr_mult
  8935:    150:         tp = entry - atr * atr_mult * 2
  8936:    151: 
  8937:    152:     result: Dict[str, Any] = {
  8938:    153:         "direction": direction,
  8939:    154:         "entry": entry,
  8940:    155:         "sl": sl,
  8941:    156:         "tp": tp,
  8942:    157:         "score": round(score, 3),
  8943:    158:         "reasons": reasons,
  8944:    159:         "quality": quality,
  8945:    160:     }
  8946:    161: 
  8947:    162:     if trailing:
  8948:    163:         result["trail"] = atr * atr_mult
  8949:    164: 
  8950:    165:     return result
  8951: 
  8952: 
  8953: ## scalper/strategy.py (last modified: 2025-08-23 20:57:14)
  8954:      1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
  8955:      2: 
  8956:      3: This module implements a minimal but functional version of the strategy
  8957:      4: outlined in the project specification.  The focus is on pure Python
  8958:      5: implementations so the logic can easily be unit tested without requiring
  8959:      6: external services or heavy third‑party dependencies.
  8960:      7: 
  8961:      8: The strategy is deliberately stateless; functions operate on passed data and
  8962:      9: return simple data structures.  This makes it easy to plug the logic into
  8963:     10: real‑time trading loops or backtest engines.
  8964:     11: """
  8965:     12: 
  8966:     13: from __future__ import annotations
  8967:     14: 
  8968:     15: from dataclasses import dataclass
  8969:     16: from typing import Sequence, List, Dict, Optional, Tuple, Any
  8970:     17: 
  8971:     18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
  8972:     19: from .risk import calc_position_size
  8973:     20: 
  8974:     21: # ---------------------------------------------------------------------------
  8975:     22: # Helpers
  8976:     23: # ---------------------------------------------------------------------------
  8977:     24: 
  8978:     25: def ema(series: Sequence[float], window: int) -> List[float]:
  8979:     26:     """Return the exponential moving average of *series*.
  8980:     27: 
  8981:     28:     The first value is the raw input to remain consistent with most trading
  8982:     29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
  8983:     30:     returned unchanged.
  8984:     31:     """
  8985:     32: 
  8986:     33:     if window <= 1 or not series:
  8987:     34:         return list(series)
  8988:     35:     k = 2.0 / (window + 1.0)
  8989:     36:     out: List[float] = [float(series[0])]
  8990:     37:     prev = out[0]
  8991:     38:     for x in series[1:]:
  8992:     39:         prev = float(x) * k + prev * (1.0 - k)
  8993:     40:         out.append(prev)
  8994:     41:     return out
  8995:     42: 
  8996:     43: def vwap(highs: Sequence[float], lows: Sequence[float],
  8997:     44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
  8998:     45:     """Compute the volume weighted average price (VWAP).
  8999:     46: 
  9000:     47:     Parameters
  9001:     48:     ----------
  9002:     49:     highs, lows, closes, volumes: Sequence[float]
  9003:     50:         Matching sequences for the period considered.
  9004:     51:     """
  9005:     52: 
  9006:     53:     tp_vol = 0.0
  9007:     54:     vol_sum = 0.0
  9008:     55:     for h, low, c, v in zip(highs, lows, closes, volumes):
  9009:     56:         tp = (h + low + c) / 3.0
  9010:     57:         tp_vol += tp * v
  9011:     58:         vol_sum += v
  9012:     59:     return tp_vol / vol_sum if vol_sum else 0.0
  9013:     60: 
  9014:     61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
  9015:     62:     """Return the On Balance Volume (OBV) series."""
  9016:     63: 
  9017:     64:     if not closes:
  9018:     65:         return []
  9019:     66:     out: List[float] = [0.0]
  9020:     67:     for i in range(1, len(closes)):
  9021:     68:         if closes[i] > closes[i - 1]:
  9022:     69:             out.append(out[-1] + volumes[i])
  9023:     70:         elif closes[i] < closes[i - 1]:
  9024:     71:             out.append(out[-1] - volumes[i])
  9025:     72:         else:
  9026:     73:             out.append(out[-1])
  9027:     74:     return out
  9028:     75: 
  9029:     76: 
  9030:     77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  9031:     78:     """Detect a crossing between two series.
  9032:     79: 
  9033:     80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
  9034:     81:     ``0`` otherwise.
  9035:     82:     """
  9036:     83: 
  9037:     84:     if prev_fast <= prev_slow and last_fast > last_slow:
  9038:     85:         return 1
  9039:     86:     if prev_fast >= prev_slow and last_fast < last_slow:
  9040:     87:         return -1
  9041:     88:     return 0
  9042:     89: 
  9043:     90: 
  9044:     91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
  9045:     92:     """Compute order book imbalance.
  9046:     93: 
  9047:     94:     The value is normalised between ``-1`` and ``1`` where positive numbers
  9048:     95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
  9049:     96:     """
  9050:     97: 
  9051:     98:     total = bid_vol + ask_vol
  9052:     99:     return (bid_vol - ask_vol) / total if total else 0.0
  9053:    100: 
  9054:    101: 
  9055:    102: def swing_levels(
  9056:    103:     highs: Sequence[float], lows: Sequence[float], lookback: int
  9057:    104: ) -> Tuple[float, float]:
  9058:    105:     """Return the most recent swing high and swing low.
  9059:    106: 
  9060:    107:     ``lookback`` defines how many completed candles are inspected.  The current
  9061:    108:     candle is excluded to avoid look‑ahead bias.
  9062:    109:     """
  9063:    110: 
  9064:    111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
  9065:    112:         return highs[-1], lows[-1]
  9066:    113:     high = max(highs[-lookback - 1 : -1])
  9067:    114:     low = min(lows[-lookback - 1 : -1])
  9068:    115:     return high, low
  9069:    116: 
  9070:    117: # ---------------------------------------------------------------------------
  9071:    118: # Pair selection
  9072:    119: # ---------------------------------------------------------------------------
  9073:    120: 
  9074:    121: # The first and second level pair selection helpers now live in
  9075:    122: # :mod:`scalper.selection`.  They are re-exported here for backward compatibility
  9076:    123: # and to keep the public API unchanged.
  9077:    124: from .selection.scanner import scan_pairs  # noqa: E402
  9078:    125: from .selection.momentum import select_active_pairs  # noqa: E402
  9079:    126: 
  9080:    127: # ---------------------------------------------------------------------------
  9081:    128: # Signal generation
  9082:    129: # ---------------------------------------------------------------------------
  9083:    130: 
  9084:    131: @dataclass
  9085:    132: class Signal:
  9086:    133:     """Trading signal with risk parameters."""
  9087:    134: 
  9088:    135:     symbol: str
  9089:    136:     side: int  # 1 for long, -1 for short
  9090:    137:     entry: float
  9091:    138:     sl: float
  9092:    139:     tp1: float
  9093:    140:     tp2: float
  9094:    141:     qty: float = 0.0
  9095:    142:     score: Optional[float] = None
  9096:    143:     quality: Optional[float] = None
  9097:    144:     reasons: Optional[List[str]] = None
  9098:    145: 
  9099:    146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
  9100:    147:         if isinstance(self.side, str):
  9101:    148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
  9102:    149: 
  9103:    150:     @property
  9104:    151:     def price(self) -> float:
  9105:    152:         return self.entry
  9106:    153: 
  9107:    154: 
  9108:    155: def _generate_signal(
  9109:    156:     symbol: str,
  9110:    157:     ohlcv: Dict[str, Sequence[float]],
  9111:    158:     *,
  9112:    159:     equity: float,
  9113:    160:     risk_pct: float,
  9114:    161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
  9115:    162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
  9116:    163:     order_book: Optional[Dict[str, float]] = None,
  9117:    164:     tick_ratio_buy: Optional[float] = None,
  9118:    165:     atr_disable_pct: float = 0.2,
  9119:    166:     atr_reduce_pct: float = 2.0,
  9120:    167:     swing_lookback: int = 5,
  9121:    168:     macd_fast: int = 12,
  9122:    169:     macd_slow: int = 26,
  9123:    170:     macd_signal: int = 9,
  9124:    171:     trend_ema_period: int = 200,
  9125:    172: ) -> Optional[Signal]:
  9126:    173:     """Return a trading :class:`Signal` if conditions are met.
  9127:    174: 
  9128:    175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
  9129:    176:     sequences ordered from oldest to newest.  The function checks the following
  9130:    177:     rules:
  9131:    178: 
  9132:    179:     * price positioned relative to VWAP and EMA20/EMA50 trend
  9133:    180:     * RSI(14) crossing key levels (40/60)
  9134:    181:     * OBV rising or high short‑term volume
  9135:    182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
  9136:    183:     * Micro‑structure breakout of last swing high/low
  9137:    184:     * MACD trend filter
  9138:    185:     * Long‑term trend via configurable EMA filter
  9139:    186:     * Order book imbalance and tape filters
  9140:    187:     * Dynamic ATR‑based stop‑loss and take‑profit
  9141:    188:     * Position sizing via ``calc_position_size``
  9142:    189:     """
  9143:    190: 
  9144:    191:     closes = [float(x) for x in ohlcv.get("close", [])]
  9145:    192:     highs = [float(x) for x in ohlcv.get("high", [])]
  9146:    193:     lows = [float(x) for x in ohlcv.get("low", [])]
  9147:    194:     vols = [float(x) for x in ohlcv.get("volume", [])]
  9148:    195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
  9149:    196:         return None
  9150:    197: 
  9151:    198:     price = closes[-1]
  9152:    199:     ema20 = ema(closes, 20)
  9153:    200:     ema50 = ema(closes, 50)
  9154:    201:     ema_trend = ema(closes, trend_ema_period)
  9155:    202:     v = vwap(highs, lows, closes, vols)
  9156:    203:     obv_series = obv(closes, vols)
  9157:    204:     obv_rising = obv_series[-1] > obv_series[-2]
  9158:    205:     vol_last3 = sum(vols[-3:])
  9159:    206:     vol_ma20 = sum(vols[-20:]) / 20.0
  9160:    207:     vol_rising = vol_last3 > vol_ma20
  9161:    208: 
  9162:    209:     macd_val, macd_sig, _ = calc_macd(
  9163:    210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
  9164:    211:     )
  9165:    212: 
  9166:    213:     # Multi timeframe filters -------------------------------------------------
  9167:    214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
  9168:    215:     if ohlcv_1h:
  9169:    216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
  9170:    217:         if len(h_closes) >= 52:
  9171:    218:             h_ema50 = ema(h_closes, 50)
  9172:    219:             if len(h_ema50) >= 2:
  9173:    220:                 slope = h_ema50[-1] - h_ema50[-2]
  9174:    221:                 if slope > 0:
  9175:    222:                     trend_dir = 1
  9176:    223:                 elif slope < 0:
  9177:    224:                     trend_dir = -1
  9178:    225: 
  9179:    226:     rsi_15 = None
  9180:    227:     if ohlcv_15m:
  9181:    228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
  9182:    229:         if len(m_closes) >= 15:
  9183:    230:             rsi_15 = calc_rsi(m_closes, 14)
  9184:    231: 
  9185:    232:     # RSI crossing logic (5m)
  9186:    233:     rsi_curr = calc_rsi(closes[-15:], 14)
  9187:    234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
  9188:    235: 
  9189:    236:     atr = calc_atr(highs, lows, closes, 14)
  9190:    237:     atr_pct = atr / price * 100.0 if price else 0.0
  9191:    238:     if atr_pct < atr_disable_pct:
  9192:    239:         return None
  9193:    240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
  9194:    241: 
  9195:    242:     sl_dist = 0.5 * atr
  9196:    243:     tp1_dist = 1.0 * atr
  9197:    244:     tp2_dist = 1.5 * atr
  9198:    245: 
  9199:    246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
  9200:    247: 
  9201:    248:     obi_ok_long = obi_ok_short = True
  9202:    249:     if order_book is not None:
  9203:    250:         bid = float(order_book.get("bid_vol_aggreg", 0))
  9204:    251:         ask = float(order_book.get("ask_vol_aggreg", 0))
  9205:    252:         obi = order_book_imbalance(bid, ask)
  9206:    253:         obi_ok_long = obi > 0.1
  9207:    254:         obi_ok_short = obi < -0.1
  9208:    255: 
  9209:    256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
  9210:    257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
  9211:    258: 
  9212:    259:     def _size(dist: float) -> float:
  9213:    260:         return calc_position_size(equity, risk_pct, dist) * size_mult
  9214:    261:     weights = {
  9215:    262:         "ema": 15.0,
  9216:    263:         "macd": 15.0,
  9217:    264:         "vwap": 15.0,
  9218:    265:         "rsi": 15.0,
  9219:    266:         "obv": 10.0,
  9220:    267:         "swing": 10.0,
  9221:    268:         "atr": 20.0,
  9222:    269:     }
  9223:    270: 
  9224:    271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
  9225:    272: 
  9226:    273:     long_score = atr_score
  9227:    274:     long_reasons: List[str] = []
  9228:    275:     if price > v:
  9229:    276:         long_score += weights["vwap"]
  9230:    277:         long_reasons.append("vwap")
  9231:    278:     if ema20[-1] > ema50[-1]:
  9232:    279:         long_score += weights["ema"]
  9233:    280:         long_reasons.append("ema")
  9234:    281:     if rsi_prev <= 40 < rsi_curr:
  9235:    282:         long_score += weights["rsi"]
  9236:    283:         long_reasons.append("rsi")
  9237:    284:     if macd_val > macd_sig:
  9238:    285:         long_score += weights["macd"]
  9239:    286:         long_reasons.append("macd")
  9240:    287:     if obv_rising or vol_rising:
  9241:    288:         long_score += weights["obv"]
  9242:    289:         long_reasons.append("obv")
  9243:    290:     if price > swing_high:
  9244:    291:         long_score += weights["swing"]
  9245:    292:         long_reasons.append("swing")
  9246:    293: 
  9247:    294:     short_score = atr_score
  9248:    295:     short_reasons: List[str] = []
  9249:    296:     if price < v:
  9250:    297:         short_score += weights["vwap"]
  9251:    298:         short_reasons.append("vwap")
  9252:    299:     if ema20[-1] < ema50[-1]:
  9253:    300:         short_score += weights["ema"]
  9254:    301:         short_reasons.append("ema")
  9255:    302:     if rsi_prev >= 60 > rsi_curr:
  9256:    303:         short_score += weights["rsi"]
  9257:    304:         short_reasons.append("rsi")
  9258:    305:     if macd_val < macd_sig:
  9259:    306:         short_score += weights["macd"]
  9260:    307:         short_reasons.append("macd")
  9261:    308:     if obv_series[-1] < obv_series[-2] or vol_rising:
  9262:    309:         short_score += weights["obv"]
  9263:    310:         short_reasons.append("obv")
  9264:    311:     if price < swing_low:
  9265:    312:         short_score += weights["swing"]
  9266:    313:         short_reasons.append("swing")
  9267:    314: 
  9268:    315:     side: Optional[str] = None
  9269:    316:     score: float = 0.0
  9270:    317:     reasons: List[str] = []
  9271:    318:     if (
  9272:    319:         long_score >= short_score
  9273:    320:         and long_score > 0
  9274:    321:         and macd_val > macd_sig
  9275:    322:         and obi_ok_long
  9276:    323:         and tick_ok_long
  9277:    324:         and trend_dir >= 0
  9278:    325:         and price > ema_trend[-1]
  9279:    326:     ):
  9280:    327:         side = "long"
  9281:    328:         score = long_score
  9282:    329:         reasons = long_reasons
  9283:    330:         sl = price - sl_dist
  9284:    331:         tp1 = price + tp1_dist
  9285:    332:         tp2 = price + tp2_dist
  9286:    333:     elif (
  9287:    334:         short_score > long_score
  9288:    335:         and short_score > 0
  9289:    336:         and macd_val < macd_sig
  9290:    337:         and obi_ok_short
  9291:    338:         and tick_ok_short
  9292:    339:         and trend_dir <= 0
  9293:    340:         and price < ema_trend[-1]
  9294:    341:     ):
  9295:    342:         side = "short"
  9296:    343:         score = short_score
  9297:    344:         reasons = short_reasons
  9298:    345:         sl = price + sl_dist
  9299:    346:         tp1 = price - tp1_dist
  9300:    347:         tp2 = price - tp2_dist
  9301:    348:     else:
  9302:    349:         return None
  9303:    350: 
  9304:    351:     qty = _size(sl_dist)
  9305:    352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
  9306:    353: 
  9307:    354: 
  9308:    355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
  9309:    356:     if "config" in kwargs:
  9310:    357:         config = kwargs.pop("config")
  9311:    358:         symbol = kwargs.pop("symbol", None)
  9312:    359:         ohlcv = kwargs.pop("ohlcv", None)
  9313:    360:         if ohlcv is None:
  9314:    361:             raise TypeError("ohlcv argument required")
  9315:    362:         return _generate_signal(
  9316:    363:             symbol or ohlcv.get("symbol", ""),
  9317:    364:             ohlcv,
  9318:    365:             equity=kwargs.pop("equity", 0.0),
  9319:    366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
  9320:    367:             **kwargs,
  9321:    368:         )
  9322:    369:     return _generate_signal(*args, **kwargs)
  9323:    370: 
  9324:    371: # ---------------------------------------------------------------------------
  9325:    372: # Backtesting utilities
  9326:    373: # ---------------------------------------------------------------------------
  9327:    374: 
  9328:    375: def max_drawdown(equity_curve: Sequence[float]) -> float:
  9329:    376:     peak = equity_curve[0]
  9330:    377:     mdd = 0.0
  9331:    378:     for x in equity_curve:
  9332:    379:         if x > peak:
  9333:    380:             peak = x
  9334:    381:         dd = (peak - x) / peak * 100.0
  9335:    382:         if dd > mdd:
  9336:    383:             mdd = dd
  9337:    384:     return mdd
  9338:    385: 
  9339:    386: def backtest(
  9340:    387:     trades: Sequence[Dict[str, Any]],
  9341:    388:     *,
  9342:    389:     equity_start: float = 1_000.0,
  9343:    390:     fee_rate: float = 0.0,
  9344:    391: ) -> Dict[str, float]:
  9345:    392:     """Evaluate a list of trade dictionaries.
  9346:    393: 
  9347:    394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
  9348:    395:     optionally include ``duration`` in minutes.  Results are aggregated into
  9349:    396:     common performance metrics to quickly evaluate the strategy.
  9350:    397:     """
  9351:    398: 
  9352:    399:     equity = equity_start
  9353:    400:     equity_curve = [equity]
  9354:    401:     pnl_pct_list: List[float] = []
  9355:    402:     wins = losses = 0
  9356:    403:     win_sum = loss_sum = 0.0
  9357:    404:     total_duration = 0.0
  9358:    405: 
  9359:    406:     for t in trades:
  9360:    407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
  9361:    408:         pnl_pct_list.append(pnl_pct)
  9362:    409:         if pnl_pct >= 0:
  9363:    410:             wins += 1
  9364:    411:             win_sum += pnl_pct
  9365:    412:         else:
  9366:    413:             losses += 1
  9367:    414:             loss_sum += pnl_pct
  9368:    415:         equity *= 1 + pnl_pct / 100.0
  9369:    416:         equity_curve.append(equity)
  9370:    417:         total_duration += float(t.get("duration", 0.0))
  9371:    418: 
  9372:    419:     pnl_pct_total = sum(pnl_pct_list)
  9373:    420:     pnl_usdt = equity - equity_start
  9374:    421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
  9375:    422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
  9376:    423:     mdd = max_drawdown(equity_curve)
  9377:    424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
  9378:    425:     exposure = total_duration  # in minutes, callers can normalise if desired
  9379:    426:     # Sharpe ratio based on per-trade returns
  9380:    427:     if len(pnl_pct_list) > 1:
  9381:    428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
  9382:    429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
  9383:    430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
  9384:    431:     else:
  9385:    432:         sharpe = 0.0
  9386:    433: 
  9387:    434:     return {
  9388:    435:         "pnl_usdt": pnl_usdt,
  9389:    436:         "pnl_pct": pnl_pct_total,
  9390:    437:         "profit_factor": profit_factor,
  9391:    438:         "winrate": winrate,
  9392:    439:         "max_drawdown": mdd,
  9393:    440:         "avg_trade_time": avg_trade_time,
  9394:    441:         "exposure": exposure,
  9395:    442:         "sharpe": sharpe,
  9396:    443:     }
  9397: 
  9398: 
  9399: ## scalper/trade_utils.py (last modified: 2025-08-23 20:57:14)
  9400:      1: # scalper/trade_utils.py
  9401:      2: from __future__ import annotations
  9402:      3: 
  9403:      4: from typing import Optional
  9404:      5: 
  9405:      6: 
  9406:      7: def compute_position_size(
  9407:      8:     equity: float,
  9408:      9:     price: float,
  9409:     10:     risk_pct: float,
  9410:     11:     *,
  9411:     12:     symbol: Optional[str] = None,
  9412:     13:     min_qty: float = 0.0,
  9413:     14:     max_leverage: float = 1.0,
  9414:     15: ) -> float:
  9415:     16:     """
  9416:     17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
  9417:     18:     qty = notionnel / price
  9418:     19:     - min_qty : borne basse éventuelle (0 pour ignorer)
  9419:     20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
  9420:     21:     """
  9421:     22:     equity = float(max(0.0, equity))
  9422:     23:     price = float(max(1e-12, price))
  9423:     24:     risk_pct = float(max(0.0, risk_pct))
  9424:     25:     notionnel = equity * risk_pct * max_leverage
  9425:     26:     qty = notionnel / price
  9426:     27:     if min_qty > 0 and qty < min_qty:
  9427:     28:         return 0.0
  9428:     29:     return float(qty)
  9429: 
  9430: ## scalper/version.py (last modified: 2025-08-23 20:57:14)
  9431:      1: """Utilities for managing the Scalp bot version."""
  9432:      2: 
  9433:      3: from __future__ import annotations
  9434:      4: 
  9435:      5: from pathlib import Path
  9436:      6: import re
  9437:      7: 
  9438:      8: import subprocess
  9439:      9: 
  9440:     10: 
  9441:     11: # Path to the VERSION file within the package
  9442:     12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
  9443:     13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
  9444:     14: 
  9445:     15: 
  9446:     16: def get_version() -> str:
  9447:     17:     """Return the current version of the bot.
  9448:     18: 
  9449:     19:     If the VERSION file does not exist the default version ``0.0.0`` is
  9450:     20:     returned.
  9451:     21:     """
  9452:     22:     if not _VERSION_FILE.exists():
  9453:     23:         return "0.0.0"
  9454:     24:     return _VERSION_FILE.read_text().strip()
  9455:     25: 
  9456:     26: 
  9457:     27: def _parse(version: str) -> tuple[int, int, int]:
  9458:     28:     match = _VERSION_RE.match(version)
  9459:     29:     if not match:
  9460:     30:         raise ValueError(f"Invalid version: {version!r}")
  9461:     31:     return tuple(int(x) for x in match.groups())
  9462:     32: 
  9463:     33: 
  9464:     34: def bump_version(part: str = "patch") -> str:
  9465:     35:     """Bump the version stored in the VERSION file.
  9466:     36: 
  9467:     37:     Parameters
  9468:     38:     ----------
  9469:     39:     part:
  9470:     40:         Which component to increment. Accepted values are ``"major"``,
  9471:     41:         ``"minor"`` and ``"patch"`` (default).
  9472:     42:     """
  9473:     43:     major, minor, patch = _parse(get_version())
  9474:     44:     if part == "major":
  9475:     45:         major += 1
  9476:     46:         minor = 0
  9477:     47:         patch = 0
  9478:     48:     elif part == "minor":
  9479:     49:         minor += 1
  9480:     50:         patch = 0
  9481:     51: 
  9482:     52:     elif part == "patch":
  9483:     53:         patch += 1
  9484:     54:     else:
  9485:     55:         raise ValueError(f"Unknown part: {part}")
  9486:     56:     new_version = f"{major}.{minor}.{patch}"
  9487:     57:     _VERSION_FILE.write_text(f"{new_version}\n")
  9488:     58:     return new_version
  9489:     59: 
  9490:     60: 
  9491:     61: def bump_version_from_message(message: str) -> str:
  9492:     62:     """Bump the version according to a commit message.
  9493:     63: 
  9494:     64:     ``message`` is evaluated using a tiny subset of the Conventional
  9495:     65:     Commits spec. Messages starting with ``feat`` bump the *minor*
  9496:     66:     version, messages whose header ends with ``!`` or contain
  9497:     67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
  9498:     68:     bump the *patch* component.
  9499:     69:     """
  9500:     70: 
  9501:     71:     header = message.strip().splitlines()[0].lower()
  9502:     72:     lower = message.lower()
  9503:     73:     type_part = header.split(":")[0]
  9504:     74:     if "!" in type_part or "breaking change" in lower:
  9505:     75:         part = "major"
  9506:     76:     elif type_part.startswith("feat"):
  9507:     77:         part = "minor"
  9508:     78:     else:
  9509:     79:         part = "patch"
  9510:     80:     return bump_version(part)
  9511:     81: 
  9512:     82: 
  9513:     83: def bump_version_from_git() -> str:
  9514:     84:     """Read the latest git commit message and bump the version accordingly."""
  9515:     85:     try:
  9516:     86:         message = subprocess.check_output(
  9517:     87:             ["git", "log", "-1", "--pretty=%B"], text=True
  9518:     88:         ).strip()
  9519:     89:     except Exception:
  9520:     90:         message = ""
  9521:     91:     return bump_version_from_message(message)
  9522:     92: 
  9523:     93: 
  9524:     94: if __name__ == "__main__":
  9525:     95:     print(bump_version_from_git())
  9526: 
  9527: 
  9528: ## scalper/ws.py (last modified: 2025-08-23 20:57:14)
  9529:      1: """Minimal websocket manager with heartbeat and auto-resubscribe.
  9530:      2: 
  9531:      3: This module provides a light-weight framework to maintain a realtime
  9532:      4: connection to an exchange.  The actual network layer is expected to be
  9533:      5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
  9534:      6: manager handles retrying failed connections and periodically invoking the
  9535:      7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
  9536:      8: without opening real network sockets.
  9537:      9: """
  9538:     10: from __future__ import annotations
  9539:     11: 
  9540:     12: import asyncio
  9541:     13: import logging
  9542:     14: from typing import Awaitable, Callable, Optional
  9543:     15: 
  9544:     16: 
  9545:     17: class WebsocketManager:
  9546:     18:     """Maintain a websocket connection with heartbeat and retry."""
  9547:     19: 
  9548:     20:     def __init__(
  9549:     21:         self,
  9550:     22:         connect: Callable[[], Awaitable[None]],
  9551:     23:         subscribe: Callable[[], Awaitable[None]],
  9552:     24:         *,
  9553:     25:         heartbeat_interval: float = 30.0,
  9554:     26:         max_retries: int = 3,
  9555:     27:     ) -> None:
  9556:     28:         self._connect = connect
  9557:     29:         self._subscribe = subscribe
  9558:     30:         self.heartbeat_interval = heartbeat_interval
  9559:     31:         self.max_retries = max_retries
  9560:     32:         self._heartbeat_task: Optional[asyncio.Task] = None
  9561:     33: 
  9562:     34:     async def run(self) -> None:
  9563:     35:         """Open the connection retrying on failure."""
  9564:     36:         retries = 0
  9565:     37:         while True:
  9566:     38:             try:
  9567:     39:                 await self._connect()
  9568:     40:                 await self._subscribe()
  9569:     41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
  9570:     42:                 return
  9571:     43:             except Exception as exc:  # pragma: no cover - network errors
  9572:     44:                 logging.error("websocket connect failed: %s", exc)
  9573:     45:                 retries += 1
  9574:     46:                 if retries > self.max_retries:
  9575:     47:                     raise
  9576:     48:                 await asyncio.sleep(1)
  9577:     49: 
  9578:     50:     async def _heartbeat(self) -> None:
  9579:     51:         """Send periodic heartbeats and resubscribe on failure."""
  9580:     52:         while True:
  9581:     53:             await asyncio.sleep(self.heartbeat_interval)
  9582:     54:             try:
  9583:     55:                 await self._subscribe()
  9584:     56:             except Exception as exc:  # pragma: no cover - network errors
  9585:     57:                 logging.warning("websocket heartbeat failed: %s", exc)
  9586:     58:                 await self.run()
  9587:     59:                 break
  9588:     60: 
  9589:     61:     async def stop(self) -> None:
  9590:     62:         """Cancel the heartbeat task if it is running."""
  9591:     63:         task = self._heartbeat_task
  9592:     64:         if task and not task.done():
  9593:     65:             task.cancel()
  9594:     66:             try:
  9595:     67:                 await task
  9596:     68:             except BaseException:  # pragma: no cover - cancellation
  9597:     69:                 pass
  9598:     70:         self._heartbeat_task = None
  9599: 
  9600: 
  9601: ## sitecustomize.py (last modified: 2025-08-23 20:57:14)
  9602:      1: # sitecustomize.py
  9603:      2: """
  9604:      3: Ce fichier est importé automatiquement par Python au démarrage, si présent sur sys.path.
  9605:      4: On l'utilise pour lancer un préflight de 'scalper' avant l'exécution du bot,
  9606:      5: sans modifier bot.py. Désactivable via SKIP_PREFLIGHT=1.
  9607:      6: """
  9608:      7: 
  9609:      8: import os
  9610:      9: 
  9611:     10: if os.getenv("SKIP_PREFLIGHT", "0") not in ("1", "true", "yes"):
  9612:     11:     try:
  9613:     12:         # Optionnel: charger /notebooks/.env si présent
  9614:     13:         try:
  9615:     14:             from dotenv import load_dotenv  # pip install python-dotenv si besoin
  9616:     15:             load_dotenv("/notebooks/.env")
  9617:     16:         except Exception:
  9618:     17:             pass
  9619:     18: 
  9620:     19:     except Exception:
  9621:     20:         pass
  9622:     21: 
  9623:     22:     try:
  9624:     23:         from scalper.selfcheck import preflight_or_die
  9625:     24:         preflight_or_die(verbose=False)
  9626:     25:     except SystemExit:
  9627:     26:         # le préflight a signalé un problème -> on laisse l'arrêt se propager
  9628:     27:         raise
  9629:     28:     except Exception as e:
  9630:     29:         # On ne bloque pas le démarrage si le selfcheck lui-même plante,
  9631:     30:         # mais on affiche une alerte claire.
  9632:     31:         print(f"[sitecustomize] Avertissement: selfcheck non exécuté ({e})")
  9633: 
  9634: ## tests/conftest.py (last modified: 2025-08-23 20:57:14)
  9635:      1: """Test configuration and shared fixtures."""
  9636:      2: 
  9637:      3: import sys
  9638:      4: import types
  9639:      5: from pathlib import Path
  9640:      6: 
  9641:      7: 
  9642:      8: # Ensure the project root is importable so tests can ``import bot``.
  9643:      9: ROOT = Path(__file__).resolve().parents[1]
  9644:     10: sys.path.insert(0, str(ROOT))
  9645:     11: 
  9646:     12: 
  9647:     13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
  9648:     14: # the real dependency during test collection. Individual tests patch the
  9649:     15: # functions they need (``request``/``post``/``get``).
  9650:     16: sys.modules.setdefault(
  9651:     17:     "requests",
  9652:     18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
  9653:     19: )
  9654:     20: 
  9655: 
  9656: 
  9657: ## tests/test_analyse_risque.py (last modified: 2025-08-23 20:57:14)
  9658:      1: import os
  9659:      2: import sys
  9660:      3: import types
  9661:      4: 
  9662:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
  9663:      6: sys.modules['requests'] = types.SimpleNamespace(
  9664:      7:     request=lambda *a, **k: None,
  9665:      8:     post=lambda *a, **k: None,
  9666:      9:     HTTPError=Exception,
  9667:     10: )
  9668:     11: 
  9669:     12: from bot import analyse_risque  # noqa: E402
  9670:     13: 
  9671:     14: 
  9672:     15: def make_contract_detail():
  9673:     16:     return {
  9674:     17:         "data": [
  9675:     18:             {
  9676:     19:                 "symbol": "BTC_USDT",
  9677:     20:                 "contractSize": 0.01,
  9678:     21:                 "volUnit": 1,
  9679:     22:                 "minVol": 1,
  9680:     23:             }
  9681:     24:         ]
  9682:     25:     }
  9683:     26: 
  9684:     27: 
  9685:     28: def test_analyse_risque_limits_and_leverage():
  9686:     29:     contract_detail = make_contract_detail()
  9687:     30:     # Risk level 1: leverage halved, limit 1 position
  9688:     31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
  9689:     32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9690:     33:                                symbol="BTC_USDT", side="long", risk_level=1)
  9691:     34:     assert lev == 5
  9692:     35:     assert vol == 0  # already one long position
  9693:     36: 
  9694:     37:     # Risk level 2: base leverage, limit 3 positions
  9695:     38:     open_pos = [
  9696:     39:         {"symbol": "BTC_USDT", "side": "long"},
  9697:     40:         {"symbol": "BTC_USDT", "side": "long"},
  9698:     41:         {"symbol": "BTC_USDT", "side": "long"},
  9699:     42:     ]
  9700:     43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9701:     44:                                symbol="BTC_USDT", side="long", risk_level=2)
  9702:     45:     assert lev == 10
  9703:     46:     assert vol == 0
  9704:     47: 
  9705:     48:     # Risk level 3: leverage doubled, no existing position
  9706:     49:     open_pos = []
  9707:     50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
  9708:     51:                                symbol="BTC_USDT", side="long", risk_level=3)
  9709:     52:     assert lev == 20
  9710:     53:     assert vol == 1
  9711: 
  9712: 
  9713: ## tests/test_backtest.py (last modified: 2025-08-23 20:57:14)
  9714:      1: import pytest
  9715:      2: 
  9716:      3: import bot
  9717:      4: 
  9718:      5: 
  9719:      6: def test_backtest_trades():
  9720:      7:     trades = [
  9721:      8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
  9722:      9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
  9723:     10:     ]
  9724:     11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
  9725:     12:     # Both trades: 10% - 0.2% fee = 9.8% each
  9726:     13:     assert pnl == pytest.approx(19.6)
  9727: 
  9728: 
  9729: ## tests/test_backtest_multi.py (last modified: 2025-08-23 20:57:14)
  9730:      1: import csv
  9731:      2: import random
  9732:      3: from datetime import datetime, timedelta, timezone
  9733:      4: from pathlib import Path
  9734:      5: 
  9735:      6: import pytest
  9736:      7: 
  9737:      8: from scalper.backtest.run_multi import run_backtest_multi
  9738:      9: from scalper.strategy import Signal
  9739:     10: 
  9740:     11: 
  9741:     12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
  9742:     13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
  9743:     14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
  9744:     15:     with open(filename, "w", newline="") as fh:
  9745:     16:         writer = csv.writer(fh)
  9746:     17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
  9747:     18:         for i in range(200):
  9748:     19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
  9749:     20:             price = 100 + i
  9750:     21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
  9751:     22: 
  9752:     23: 
  9753:     24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9754:     25:     closes = ohlcv["close"]
  9755:     26:     if len(closes) < 10:
  9756:     27:         return None
  9757:     28:     price = closes[-1]
  9758:     29:     sl = price * 0.99
  9759:     30:     tp = price * 1.01
  9760:     31:     qty = equity * risk_pct / (price - sl)
  9761:     32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
  9762:     33: 
  9763:     34: 
  9764:     35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9765:     36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
  9766:     37:         return None
  9767:     38:     price = ohlcv["close"][-1]
  9768:     39:     sl = price * 0.99
  9769:     40:     tp = price * 1.01
  9770:     41:     qty = equity * risk_pct / (price - sl)
  9771:     42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
  9772:     43: 
  9773:     44: 
  9774:     45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
  9775:     46:     closes = ohlcv["close"]
  9776:     47:     if len(closes) < 10:
  9777:     48:         return None
  9778:     49:     price = closes[-1]
  9779:     50:     sl = price * 0.99
  9780:     51:     tp = price * 1.01
  9781:     52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
  9782:     53: 
  9783:     54: 
  9784:     55: def find_row(summary, symbol):
  9785:     56:     for row in summary:
  9786:     57:         if row["symbol"] == symbol:
  9787:     58:             return row
  9788:     59:     raise KeyError(symbol)
  9789:     60: 
  9790:     61: 
  9791:     62: def test_csv_multi_pairs(tmp_path, monkeypatch):
  9792:     63:     for sym in ["BTC/USDT", "ETH/USDT"]:
  9793:     64:         make_csv(tmp_path, sym)
  9794:     65:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
  9795:     66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
  9796:     67:     out = tmp_path / "out"
  9797:     68:     summary, trades = run_backtest_multi(
  9798:     69:         symbols=["BTC/USDT", "ETH/USDT"],
  9799:     70:         exchange="csv",
  9800:     71:         timeframe="1m",
  9801:     72:         csv_dir=str(tmp_path),
  9802:     73:         fee_rate=0.0,
  9803:     74:         slippage_bps=0.0,
  9804:     75:         risk_pct=0.01,
  9805:     76:         initial_equity=1000,
  9806:     77:         leverage=1.0,
  9807:     78:         paper_constraints=True,
  9808:     79:         seed=42,
  9809:     80:         out_dir=str(out),
  9810:     81:         plot=False,
  9811:     82:     )
  9812:     83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
  9813:     84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
  9814:     85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
  9815:     86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
  9816:     87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
  9817:     88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
  9818:     89:     # files
  9819:     90:     assert (out / "report_summary.csv").exists()
  9820:     91:     assert (out / "report_trades.csv").exists()
  9821:     92:     assert (out / "equity_curve_total.csv").exists()
  9822:     93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
  9823:     94:     # columns in trades
  9824:     95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
  9825:     96:         assert col in trades[0]
  9826:     97: 
  9827:     98: 
  9828:     99: def test_fee_slippage(tmp_path, monkeypatch):
  9829:    100:     make_csv(tmp_path, "BTC/USDT")
  9830:    101:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
  9831:    102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
  9832:    103:     summary1, _ = run_backtest_multi(
  9833:    104:         symbols=["BTC/USDT"],
  9834:    105:         exchange="csv",
  9835:    106:         timeframe="1m",
  9836:    107:         csv_dir=str(tmp_path),
  9837:    108:         fee_rate=0.0,
  9838:    109:         slippage_bps=0.0,
  9839:    110:         out_dir=str(tmp_path / "o1"),
  9840:    111:     )
  9841:    112:     summary2, _ = run_backtest_multi(
  9842:    113:         symbols=["BTC/USDT"],
  9843:    114:         exchange="csv",
  9844:    115:         timeframe="1m",
  9845:    116:         csv_dir=str(tmp_path),
  9846:    117:         fee_rate=0.01,
  9847:    118:         slippage_bps=100,
  9848:    119:         out_dir=str(tmp_path / "o2"),
  9849:    120:     )
  9850:    121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
  9851:    122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
  9852:    123:     assert pnl2 < pnl1
  9853:    124: 
  9854:    125: 
  9855:    126: def test_paper_constraints(tmp_path, monkeypatch):
  9856:    127:     make_csv(tmp_path, "BTC/USDT")
  9857:    128:     monkeypatch.setattr("scalper.strategy.generate_signal", tiny_qty_signal)
  9858:    129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
  9859:    130:     summary, trades = run_backtest_multi(
  9860:    131:         symbols=["BTC/USDT"],
  9861:    132:         exchange="csv",
  9862:    133:         timeframe="1m",
  9863:    134:         csv_dir=str(tmp_path),
  9864:    135:         paper_constraints=True,
  9865:    136:         out_dir=str(tmp_path / "o"),
  9866:    137:     )
  9867:    138:     assert all(t["qty"] >= 0.001 for t in trades)
  9868:    139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
  9869:    140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
  9870:    141: 
  9871:    142: 
  9872:    143: def test_seed_reproducible(tmp_path, monkeypatch):
  9873:    144:     make_csv(tmp_path, "BTC/USDT")
  9874:    145:     monkeypatch.setattr("scalper.strategy.generate_signal", random_signal)
  9875:    146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
  9876:    147:     s1, t1 = run_backtest_multi(
  9877:    148:         symbols=["BTC/USDT"],
  9878:    149:         exchange="csv",
  9879:    150:         timeframe="1m",
  9880:    151:         csv_dir=str(tmp_path),
  9881:    152:         seed=7,
  9882:    153:         out_dir=str(tmp_path / "o1"),
  9883:    154:     )
  9884:    155:     s2, t2 = run_backtest_multi(
  9885:    156:         symbols=["BTC/USDT"],
  9886:    157:         exchange="csv",
  9887:    158:         timeframe="1m",
  9888:    159:         csv_dir=str(tmp_path),
  9889:    160:         seed=7,
  9890:    161:         out_dir=str(tmp_path / "o2"),
  9891:    162:     )
  9892:    163:     assert t1 == t2
  9893:    164:     assert s1 == s2
  9894: 
  9895: 
  9896: ## tests/test_backtest_position.py (last modified: 2025-08-23 20:57:14)
  9897:      1: import os
  9898:      2: import sys
  9899:      3: import pytest
  9900:      4: 
  9901:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
  9902:      6: 
  9903:      7: from scalper.metrics import backtest_position
  9904:      8: 
  9905:      9: 
  9906:     10: def test_backtest_position_long():
  9907:     11:     prices = [100.0, 110.0, 120.0]
  9908:     12:     assert backtest_position(prices, 0, 2, 1) is True
  9909:     13: 
  9910:     14: 
  9911:     15: def test_backtest_position_short():
  9912:     16:     prices = [100.0, 90.0, 80.0]
  9913:     17:     assert backtest_position(prices, 0, 2, -1) is True
  9914:     18: 
  9915:     19: 
  9916:     20: def test_backtest_position_incoherent():
  9917:     21:     prices = [100.0, 110.0, 120.0]
  9918:     22:     assert backtest_position(prices, 0, 2, -1) is False
  9919:     23: 
  9920:     24: 
  9921:     25: def test_backtest_position_bad_indices():
  9922:     26:     prices = [100.0, 110.0]
  9923:     27:     with pytest.raises(ValueError):
  9924:     28:         backtest_position(prices, 1, 0, 1)
  9925: 
  9926: 
  9927: ## tests/test_bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
  9928:      1: import json
  9929:      2: from pathlib import Path
  9930:      3: from typing import Any, Dict
  9931:      4: 
  9932:      5: import pytest
  9933:      6: 
  9934:      7: import bitget_futures_pairs as bfp
  9935:      8: 
  9936:      9: 
  9937:     10: class DummyResponse:
  9938:     11:     def __init__(self, status: int, payload: Dict[str, Any]):
  9939:     12:         self.status_code = status
  9940:     13:         self._payload = payload
  9941:     14:         self.text = json.dumps(payload)
  9942:     15: 
  9943:     16:     def json(self):
  9944:     17:         return self._payload
  9945:     18: 
  9946:     19: 
  9947:     20: def test_fetch_contracts_success(monkeypatch):
  9948:     21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
  9949:     22: 
  9950:     23:     def fake_get(url, params=None, timeout=0):
  9951:     24:         return DummyResponse(200, payload)
  9952:     25: 
  9953:     26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
  9954:     27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
  9955:     28:     assert contracts == payload["data"]
  9956:     29: 
  9957:     30: 
  9958:     31: def test_fetch_contracts_error(monkeypatch):
  9959:     32:     payload = {"code": "10001"}
  9960:     33: 
  9961:     34:     def fake_get(url, params=None, timeout=0):
  9962:     35:         return DummyResponse(200, payload)
  9963:     36: 
  9964:     37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
  9965:     38:     with pytest.raises(RuntimeError):
  9966:     39:         bfp.fetch_contracts("USDT-FUTURES")
  9967:     40: 
  9968:     41: 
  9969:     42: def test_normalize_rows():
  9970:     43:     contracts = [
  9971:     44:         {
  9972:     45:             "symbol": "BTCUSDT",
  9973:     46:             "baseCoin": "BTC",
  9974:     47:             "quoteCoin": "USDT",
  9975:     48:             "symbolType": "perpetual",
  9976:     49:             "symbolStatus": "normal",
  9977:     50:             "maxLever": "50",
  9978:     51:             "minLever": "1",
  9979:     52:             "minTradeNum": "0.001",
  9980:     53:             "sizeMultiplier": "1",
  9981:     54:             "pricePlace": "2",
  9982:     55:             "volumePlace": "3",
  9983:     56:             "launchTime": 0,
  9984:     57:             "deliveryTime": 0,
  9985:     58:         }
  9986:     59:     ]
  9987:     60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
  9988:     61:     assert rows[0]["symbol"] == "BTCUSDT"
  9989:     62:     assert rows[0]["productType"] == "USDT-FUTURES"
  9990:     63: 
  9991:     64: 
  9992:     65: def test_write_csv(tmp_path: Path):
  9993:     66:     path = tmp_path / "pairs.csv"
  9994:     67:     bfp.write_csv([], str(path))
  9995:     68:     assert path.exists()
  9996:     69:     content = path.read_text().splitlines()
  9997:     70:     assert content[0].startswith("productType,")
  9998: 
  9999: 
 10000: ## tests/test_bot_place_order_caps.py (last modified: 2025-08-23 20:57:14)
 10001:      1: import os
 10002:      2: import sys
 10003:      3: import types
 10004:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10005:      5: sys.modules['requests'] = types.ModuleType('requests')
 10006:      6: 
 10007:      7: from bot import attempt_entry, Signal
 10008:      8: 
 10009:      9: 
 10010:     10: class DummyClient:
 10011:     11:     def __init__(self):
 10012:     12:         self.last_order = None
 10013:     13: 
 10014:     14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
 10015:     15:         self.last_order = (args, kwargs)
 10016:     16:         return {"code": "00000"}
 10017:     17: 
 10018:     18: 
 10019:     19: class DummyRisk:
 10020:     20:     def __init__(self, pct):
 10021:     21:         self.risk_pct = pct
 10022:     22: 
 10023:     23: 
 10024:     24: def _detail():
 10025:     25:     return {
 10026:     26:         "data": [
 10027:     27:             {
 10028:     28:                 "symbol": "BTC_USDT",
 10029:     29:                 "contractSize": 0.001,
 10030:     30:                 "volUnit": 1,
 10031:     31:                 "minVol": 1,
 10032:     32:                 "minTradeUSDT": 5,
 10033:     33:             }
 10034:     34:         ]
 10035:     35:     }
 10036:     36: 
 10037:     37: 
 10038:     38: def test_attempt_entry_respects_caps(monkeypatch):
 10039:     39:     captured = {}
 10040:     40: 
 10041:     41:     def fake_notify(event, payload):
 10042:     42:         captured[event] = payload
 10043:     43: 
 10044:     44:     monkeypatch.setattr("bot.notify", fake_notify)
 10045:     45:     client = DummyClient()
 10046:     46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10047:     47:     rm = DummyRisk(0.02)
 10048:     48:     equity = 100
 10049:     49:     available = 2.2  # just enough for 1 contract with buffer
 10050:     50:     params = attempt_entry(
 10051:     51:         client,
 10052:     52:         _detail(),
 10053:     53:         sig,
 10054:     54:         equity_usdt=equity,
 10055:     55:         available_usdt=available,
 10056:     56:         cfg={"LEVERAGE": 10},
 10057:     57:         risk_mgr=rm,
 10058:     58:         user_risk_level=1,
 10059:     59:     )
 10060:     60:     assert client.last_order is not None
 10061:     61:     assert params["vol"] >= 1
 10062:     62:     opened = captured["position_opened"]
 10063:     63:     assert opened["notional_usdt"] >= 5
 10064:     64:     assert opened["vol"] >= 1
 10065:     65: 
 10066:     66: 
 10067:     67: def test_attempt_entry_insufficient_margin(monkeypatch):
 10068:     68:     captured = {}
 10069:     69: 
 10070:     70:     def fake_notify(event, payload):
 10071:     71:         captured[event] = payload
 10072:     72: 
 10073:     73:     monkeypatch.setattr("bot.notify", fake_notify)
 10074:     74:     client = DummyClient()
 10075:     75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10076:     76:     rm = DummyRisk(0.02)
 10077:     77:     equity = 100
 10078:     78:     available = 1.0  # below required margin
 10079:     79:     params = attempt_entry(
 10080:     80:         client,
 10081:     81:         _detail(),
 10082:     82:         sig,
 10083:     83:         equity_usdt=equity,
 10084:     84:         available_usdt=available,
 10085:     85:         cfg={"LEVERAGE": 10},
 10086:     86:         risk_mgr=rm,
 10087:     87:         user_risk_level=1,
 10088:     88:     )
 10089:     89:     assert client.last_order is None
 10090:     90:     assert params["vol"] == 0
 10091:     91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 10092:     92: 
 10093:     93: 
 10094:     94: def test_attempt_entry_under_min_trade(monkeypatch):
 10095:     95:     captured = {}
 10096:     96: 
 10097:     97:     def fake_notify(event, payload):
 10098:     98:         captured[event] = payload
 10099:     99: 
 10100:    100:     monkeypatch.setattr("bot.notify", fake_notify)
 10101:    101:     client = DummyClient()
 10102:    102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10103:    103:     rm = DummyRisk(0.02)
 10104:    104:     detail = {
 10105:    105:         "data": [
 10106:    106:             {
 10107:    107:                 "symbol": "BTC_USDT",
 10108:    108:                 "contractSize": 0.001,
 10109:    109:                 "volUnit": 1,
 10110:    110:                 "minVol": 1,
 10111:    111:                 "minTradeUSDT": 50,
 10112:    112:             }
 10113:    113:         ]
 10114:    114:     }
 10115:    115:     equity = 100
 10116:    116:     available = 100
 10117:    117:     params = attempt_entry(
 10118:    118:         client,
 10119:    119:         detail,
 10120:    120:         sig,
 10121:    121:         equity_usdt=equity,
 10122:    122:         available_usdt=available,
 10123:    123:         cfg={"LEVERAGE": 10},
 10124:    124:         risk_mgr=rm,
 10125:    125:         user_risk_level=1,
 10126:    126:     )
 10127:    127:     assert client.last_order is None
 10128:    128:     assert params["vol"] == 0
 10129:    129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 10130: 
 10131: 
 10132: ## tests/test_bot_update.py (last modified: 2025-08-23 20:57:14)
 10133:      1: import logging
 10134:      2: import bot
 10135:      3: 
 10136:      4: 
 10137:      5: def test_update_displays_pairs(monkeypatch, caplog):
 10138:      6:     def fake_send(client, top_n=40):
 10139:      7:         assert (client, top_n) == ("cli", 5)
 10140:      8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
 10141:      9: 
 10142:     10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
 10143:     11:     with caplog.at_level(logging.INFO):
 10144:     12:         payload = bot.update("cli", top_n=5)
 10145:     13:     assert payload["green"] == "BTC"
 10146:     14:     assert "Listing ok" in caplog.text
 10147:     15: 
 10148:     16: 
 10149:     17: def test_update_survives_errors(monkeypatch, caplog):
 10150:     18:     """``update`` should never raise even if pair selection fails."""
 10151:     19: 
 10152:     20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
 10153:     21:         raise RuntimeError("network down")
 10154:     22: 
 10155:     23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
 10156:     24:     with caplog.at_level(logging.INFO):
 10157:     25:         payload = bot.update("cli", top_n=5)
 10158:     26: 
 10159:     27:     # The function returns an empty payload and logs the error, but still logs
 10160:     28:     # the "Listing ok" acknowledgement so callers can proceed.
 10161:     29:     assert payload == {}
 10162:     30:     assert "network down" in caplog.text
 10163:     31:     assert "Listing ok" in caplog.text
 10164:     32: 
 10165: 
 10166: 
 10167: ## tests/test_break_even_stop.py (last modified: 2025-08-23 20:57:14)
 10168:      1: from scalper.trade_utils import break_even_stop
 10169:      2: 
 10170:      3: 
 10171:      4: def test_break_even_stop_long() -> None:
 10172:      5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
 10173:      6:     assert sl == 100
 10174:      7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
 10175:      8:     assert sl == 95
 10176:      9: 
 10177:     10: 
 10178:     11: def test_break_even_stop_short() -> None:
 10179:     12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
 10180:     13:     assert sl == 100
 10181:     14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
 10182:     15:     assert sl == 105
 10183: 
 10184: 
 10185: ## tests/test_calc_pnl_pct.py (last modified: 2025-08-23 20:57:14)
 10186:      1: import os
 10187:      2: import sys
 10188:      3: import pytest
 10189:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10190:      5: 
 10191:      6: from scalper.metrics import calc_pnl_pct
 10192:      7: 
 10193:      8: 
 10194:      9: def test_calc_pnl_pct_long():
 10195:     10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
 10196:     11: 
 10197:     12: def test_calc_pnl_pct_short():
 10198:     13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
 10199:     14: 
 10200:     15: 
 10201:     16: def test_calc_pnl_pct_with_fee():
 10202:     17:     # 10% move minus 0.1%*2 fees = 9.8%
 10203:     18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)
 10204: 
 10205: 
 10206: ## tests/test_check_config.py (last modified: 2025-08-23 20:57:14)
 10207:      1: import logging
 10208:      2: from bot import check_config
 10209:      3: 
 10210:      4: 
 10211:      5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
 10212:      6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
 10213:      7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
 10214:      8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 10215:      9:     with caplog.at_level(logging.INFO):
 10216:     10:         check_config()
 10217:     11:     messages = [r.getMessage() for r in caplog.records]
 10218:     12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
 10219:     13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
 10220:     14:     assert all("NOTIFY_URL" not in m for m in messages)
 10221:     15: 
 10222:     16: 
 10223:     17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
 10224:     18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
 10225:     19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
 10226:     20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
 10227:     21:     with caplog.at_level(logging.INFO):
 10228:     22:         check_config()
 10229:     23:     assert caplog.records == []
 10230: 
 10231: 
 10232: ## tests/test_cli.py (last modified: 2025-08-23 20:57:14)
 10233:      1: """Tests for the command line interface defined in :mod:`cli`."""
 10234:      2: 
 10235:      3: from __future__ import annotations
 10236:      4: 
 10237:      5: import cli
 10238:      6: 
 10239:      7: 
 10240:      8: def test_opt_invokes_parallel_optimization(monkeypatch):
 10241:      9:     """The ``opt`` command should call ``run_parallel_optimization``."""
 10242:     10: 
 10243:     11:     called = {}
 10244:     12: 
 10245:     13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
 10246:     14:         called["args"] = (pairs, tf, jobs)
 10247:     15: 
 10248:     16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
 10249:     17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
 10250:     18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
 10251:     19: 
 10252:     20: 
 10253:     21: def test_walkforward_invokes_analysis(monkeypatch):
 10254:     22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
 10255:     23: 
 10256:     24:     called = {}
 10257:     25: 
 10258:     26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
 10259:     27:         called["args"] = (pair, tf, splits, train_ratio)
 10260:     28: 
 10261:     29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
 10262:     30:     cli.main(
 10263:     31:         [
 10264:     32:             "walkforward",
 10265:     33:             "--pair",
 10266:     34:             "BTCUSDT",
 10267:     35:             "--tf",
 10268:     36:             "1m",
 10269:     37:             "--splits",
 10270:     38:             "3",
 10271:     39:             "--train-ratio",
 10272:     40:             "0.8",
 10273:     41:         ]
 10274:     42:     )
 10275:     43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
 10276:     44: 
 10277:     45: 
 10278:     46: def test_live_invokes_async_pipeline(monkeypatch):
 10279:     47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
 10280:     48: 
 10281:     49:     called = {}
 10282:     50: 
 10283:     51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
 10284:     52:         called["args"] = (pairs, list(tfs))
 10285:     53: 
 10286:     54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
 10287:     55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
 10288:     56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
 10289:     57: 
 10290:     58: 
 10291:     59: def test_bump_version_invokes_helper(monkeypatch):
 10292:     60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
 10293:     61: 
 10294:     62:     called = {}
 10295:     63: 
 10296:     64:     def fake_bump():  # pragma: no cover - executed via CLI
 10297:     65:         called["called"] = True
 10298:     66:         return "0.1.0"
 10299:     67: 
 10300:     68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
 10301:     69:     cli.main(["bump-version"])
 10302:     70:     assert called["called"] is True
 10303:     71: 
 10304: 
 10305: 
 10306: ## tests/test_client.py (last modified: 2025-08-23 20:57:14)
 10307:      1: import json
 10308:      2: import hmac
 10309:      3: import hashlib
 10310:      4: import base64
 10311:      5: import pytest
 10312:      6: import bot
 10313:      7: from bot import BitgetFuturesClient
 10314:      8: 
 10315:      9: 
 10316:     10: @pytest.fixture(autouse=True)
 10317:     11: def no_log_event(monkeypatch):
 10318:     12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
 10319:     13: 
 10320:     14: 
 10321:     15: def test_private_request_get_signature(monkeypatch):
 10322:     16:     client = BitgetFuturesClient("key", "secret", "https://test")
 10323:     17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10324:     18: 
 10325:     19:     called = {}
 10326:     20: 
 10327:     21:     def fake_request(method, url, headers=None, timeout=None):
 10328:     22:         called["method"] = method
 10329:     23:         called["url"] = url
 10330:     24:         called["headers"] = headers
 10331:     25: 
 10332:     26:         class Resp:
 10333:     27:             def raise_for_status(self):
 10334:     28:                 pass
 10335:     29: 
 10336:     30:             def json(self):
 10337:     31:                 return {"success": True}
 10338:     32: 
 10339:     33:         return Resp()
 10340:     34: 
 10341:     35:     monkeypatch.setattr(bot.requests, "request", fake_request)
 10342:     36: 
 10343:     37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
 10344:     38:     assert resp["success"] is True
 10345:     39:     qs = "a=1&b=2"
 10346:     40:     prehash = f"1000GET/api/test?{qs}"
 10347:     41:     expected = base64.b64encode(
 10348:     42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 10349:     43:     ).decode()
 10350:     44:     assert called["headers"]["ACCESS-SIGN"] == expected
 10351:     45:     assert called["headers"]["ACCESS-KEY"] == "key"
 10352:     46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 10353:     47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 10354:     48:     assert called["url"] == "https://test/api/test?a=1&b=2"
 10355:     49: 
 10356:     50: 
 10357:     51: def test_private_request_post_signature(monkeypatch):
 10358:     52:     client = BitgetFuturesClient("key", "secret", "https://test")
 10359:     53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10360:     54: 
 10361:     55:     called = {}
 10362:     56: 
 10363:     57:     def fake_post(url, data=None, headers=None, timeout=None):
 10364:     58:         called["url"] = url
 10365:     59:         called["data"] = data
 10366:     60:         called["headers"] = headers
 10367:     61: 
 10368:     62:         class Resp:
 10369:     63:             def raise_for_status(self):
 10370:     64:                 pass
 10371:     65: 
 10372:     66:             def json(self):
 10373:     67:                 return {"success": True}
 10374:     68: 
 10375:     69:         return Resp()
 10376:     70: 
 10377:     71:     monkeypatch.setattr(bot.requests, "post", fake_post)
 10378:     72: 
 10379:     73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
 10380:     74:     assert resp["success"] is True
 10381:     75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
 10382:     76:     prehash = f"1000POST/api/test{body}"
 10383:     77:     expected = base64.b64encode(
 10384:     78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 10385:     79:     ).decode()
 10386:     80:     assert called["headers"]["ACCESS-SIGN"] == expected
 10387:     81:     assert called["headers"]["ACCESS-KEY"] == "key"
 10388:     82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 10389:     83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 10390:     84:     assert called["data"].decode("utf-8") == body
 10391:     85:     assert called["url"] == "https://test/api/test"
 10392:     86: 
 10393:     87: 
 10394:     88: def test_private_request_http_error(monkeypatch):
 10395:     89:     client = BitgetFuturesClient("key", "secret", "https://test")
 10396:     90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 10397:     91: 
 10398:     92:     class Resp:
 10399:     93:         status_code = 418
 10400:     94: 
 10401:     95:         def raise_for_status(self):
 10402:     96:             raise bot.requests.HTTPError("teapot")
 10403:     97: 
 10404:     98:         def json(self):
 10405:     99:             return {"unused": True}
 10406:    100: 
 10407:    101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
 10408:    102: 
 10409:    103:     resp = client._private_request("GET", "/api/test")
 10410:    104:     assert resp["success"] is False
 10411:    105:     assert resp["status_code"] == 418
 10412:    106:     assert "teapot" in resp["error"]
 10413:    107: 
 10414:    108: 
 10415:    109: def test_get_assets_normalization(monkeypatch):
 10416:    110:     client = BitgetFuturesClient("key", "secret", "https://test")
 10417:    111: 
 10418:    112:     called = {}
 10419:    113: 
 10420:    114:     def fake_private(self, method, path, params=None, body=None):
 10421:    115:         called["method"] = method
 10422:    116:         called["path"] = path
 10423:    117:         called["params"] = params
 10424:    118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
 10425:    119: 
 10426:    120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10427:    121: 
 10428:    122:     assets = client.get_assets()
 10429:    123: 
 10430:    124:     assert assets["success"] is True
 10431:    125:     usdt = assets.get("data", [])[0]
 10432:    126:     assert usdt["currency"].upper() == "USDT"
 10433:    127:     assert usdt["equity"] == 1.0
 10434:    128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
 10435:    129: 
 10436:    130: 
 10437:    131: def test_get_assets_equity_fallback(monkeypatch):
 10438:    132:     client = BitgetFuturesClient("key", "secret", "https://test")
 10439:    133: 
 10440:    134:     def fake_private(self, method, path, params=None, body=None):
 10441:    135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
 10442:    136: 
 10443:    137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10444:    138: 
 10445:    139:     assets = client.get_assets()
 10446:    140:     usdt = assets.get("data", [])[0]
 10447:    141:     assert usdt["currency"] == "USDT"
 10448:    142:     assert usdt["equity"] == 2.0
 10449:    143: 
 10450:    144: 
 10451:    145: def test_get_assets_prefers_available(monkeypatch):
 10452:    146:     """When both equity and available are returned, available should win."""
 10453:    147:     client = BitgetFuturesClient("key", "secret", "https://test")
 10454:    148: 
 10455:    149:     def fake_private(self, method, path, params=None, body=None):
 10456:    150:         return {
 10457:    151:             "code": "00000",
 10458:    152:             "data": [
 10459:    153:                 {
 10460:    154:                     "marginCoin": "USDT",
 10461:    155:                     "equity": "5",
 10462:    156:                     "available": "1",
 10463:    157:                 }
 10464:    158:             ],
 10465:    159:         }
 10466:    160: 
 10467:    161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10468:    162: 
 10469:    163:     assets = client.get_assets()
 10470:    164:     usdt = assets.get("data", [])[0]
 10471:    165:     assert usdt["equity"] == 1.0
 10472:    166: 
 10473:    167: 
 10474:    168: 
 10475:    169: def test_get_assets_zero_available(monkeypatch):
 10476:    170:     """Zero available balance should propagate as zero equity."""
 10477:    171:     client = BitgetFuturesClient("key", "secret", "https://test")
 10478:    172: 
 10479:    173:     def fake_private(self, method, path, params=None, body=None):
 10480:    174:         return {
 10481:    175:             "code": "00000",
 10482:    176:             "data": [
 10483:    177:                 {
 10484:    178:                     "marginCoin": "USDT",
 10485:    179:                     "available": "0",
 10486:    180:                     "equity": "5",
 10487:    181:                 }
 10488:    182:             ],
 10489:    183:         }
 10490:    184: 
 10491:    185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10492:    186: 
 10493:    187:     assets = client.get_assets()
 10494:    188:     usdt = assets.get("data", [])[0]
 10495:    189:     assert usdt["equity"] == 0.0
 10496:    190: 
 10497:    191: 
 10498:    192: def test_get_assets_available_balance(monkeypatch):
 10499:    193:     """Support alternative ``availableBalance`` field name."""
 10500:    194:     client = BitgetFuturesClient("key", "secret", "https://test")
 10501:    195: 
 10502:    196:     def fake_private(self, method, path, params=None, body=None):
 10503:    197:         return {
 10504:    198:             "code": "00000",
 10505:    199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
 10506:    200:         }
 10507:    201: 
 10508:    202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10509:    203: 
 10510:    204:     assets = client.get_assets()
 10511:    205:     usdt = assets.get("data", [])[0]
 10512:    206:     assert usdt["equity"] == 3.5
 10513:    207: 
 10514:    208: 
 10515:    209: def test_get_ticker_normalization(monkeypatch):
 10516:    210:     client = BitgetFuturesClient("key", "secret", "https://test")
 10517:    211: 
 10518:    212:     called = {}
 10519:    213: 
 10520:    214:     def fake_get(url, params=None, timeout=None):
 10521:    215:         called["url"] = url
 10522:    216:         called["params"] = params
 10523:    217: 
 10524:    218:         class Resp:
 10525:    219:             def raise_for_status(self):
 10526:    220:                 pass
 10527:    221: 
 10528:    222:             def json(self):
 10529:    223:                 return {
 10530:    224:                     "data": {
 10531:    225:                         "instId": "BTCUSDT",
 10532:    226:                         "lastPr": "1",
 10533:    227:                         "bestBidPrice": "0.9",
 10534:    228:                         "bestAskPrice": "1.1",
 10535:    229:                         "usdtVolume": "100",
 10536:    230:                     }
 10537:    231:                 }
 10538:    232: 
 10539:    233:         return Resp()
 10540:    234: 
 10541:    235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10542:    236: 
 10543:    237:     ticker = client.get_ticker("BTC_USDT")
 10544:    238: 
 10545:    239:     assert ticker["success"] is True
 10546:    240:     data = ticker["data"][0]
 10547:    241:     assert data["symbol"] == "BTCUSDT"
 10548:    242:     assert data["lastPrice"] == "1"
 10549:    243:     assert data["bidPrice"] == "0.9"
 10550:    244:     assert data["askPrice"] == "1.1"
 10551:    245:     assert data["volume"] == 100.0
 10552:    246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
 10553:    247: 
 10554:    248: 
 10555:    249: def test_http_client_context_manager(monkeypatch):
 10556:    250:     import sys
 10557:    251:     import importlib
 10558:    252:     sys.modules.pop('requests', None)
 10559:    253:     real_requests = importlib.import_module('requests')
 10560:    254:     sys.modules['requests'] = real_requests
 10561:    255:     import scalper.client as http_client
 10562:    256:     importlib.reload(http_client)
 10563:    257: 
 10564:    258:     closed = {"count": 0}
 10565:    259: 
 10566:    260:     class DummySession:
 10567:    261:         def mount(self, *a, **k):
 10568:    262:             pass
 10569:    263: 
 10570:    264:         def request(self, *a, **k):
 10571:    265:             class Resp:
 10572:    266:                 def raise_for_status(self):
 10573:    267:                     pass
 10574:    268: 
 10575:    269:                 def json(self):
 10576:    270:                     return {}
 10577:    271: 
 10578:    272:                 text = "{}"
 10579:    273: 
 10580:    274:             return Resp()
 10581:    275: 
 10582:    276:         def close(self):
 10583:    277:             closed["count"] += 1
 10584:    278: 
 10585:    279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
 10586:    280: 
 10587:    281:     http = http_client.HttpClient("http://example.com")
 10588:    282:     http.close()
 10589:    283:     assert closed["count"] == 1
 10590:    284: 
 10591:    285:     closed["count"] = 0
 10592:    286:     with http_client.HttpClient("http://example.com") as hc:
 10593:    287:         hc.request("GET", "/")
 10594:    288:     assert closed["count"] == 1
 10595:    289: 
 10596:    290: 
 10597:    291: def test_get_kline_query_params(monkeypatch):
 10598:    292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
 10599:    293:     query parameter. The previous implementation embedded the symbol in the
 10600:    294:     path which resulted in a 404 from Bitget."""
 10601:    295: 
 10602:    296:     client = BitgetFuturesClient("key", "secret", "https://test")
 10603:    297: 
 10604:    298:     called = {}
 10605:    299: 
 10606:    300:     def fake_get(url, params=None, timeout=None):
 10607:    301:         called["url"] = url
 10608:    302:         called["params"] = params
 10609:    303: 
 10610:    304:         class Resp:
 10611:    305:             def raise_for_status(self):
 10612:    306:                 pass
 10613:    307: 
 10614:    308:             def json(self):
 10615:    309:                 return {"data": []}
 10616:    310: 
 10617:    311:         return Resp()
 10618:    312: 
 10619:    313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
 10620:    314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
 10621:    315:     # even if missing so we can observe the call.
 10622:    316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10623:    317: 
 10624:    318:     client.get_kline("BTC_USDT", interval="Min1")
 10625:    319: 
 10626:    320:     assert called["url"].endswith("/api/v2/mix/market/candles")
 10627:    321:     assert called["params"] == {
 10628:    322:         "symbol": "BTCUSDT",
 10629:    323:         "productType": "USDT-FUTURES",
 10630:    324:         "granularity": "1m",
 10631:    325:     }
 10632:    326: 
 10633:    327: 
 10634:    328: def test_get_open_orders_endpoint(monkeypatch):
 10635:    329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10636:    330: 
 10637:    331:     called = {}
 10638:    332: 
 10639:    333:     def fake_private(self, method, path, params=None, body=None):
 10640:    334:         called["method"] = method
 10641:    335:         called["path"] = path
 10642:    336:         called["params"] = params
 10643:    337:         return {"success": True}
 10644:    338: 
 10645:    339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10646:    340: 
 10647:    341:     client.get_open_orders("BTCUSDT_UMCBL")
 10648:    342: 
 10649:    343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
 10650:    344:     assert called["params"] == {
 10651:    345:         "productType": "USDT-FUTURES",
 10652:    346:         "symbol": "BTCUSDT",
 10653:    347:     }
 10654:    348: 
 10655:    349: 
 10656:    350: def test_product_type_alias():
 10657:    351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
 10658:    352:     assert client.product_type == "USDT-FUTURES"
 10659:    353: 
 10660:    354: 
 10661:    355: def test_get_contract_detail_endpoint(monkeypatch):
 10662:    356:     client = BitgetFuturesClient("key", "secret", "https://test")
 10663:    357: 
 10664:    358:     called = {}
 10665:    359: 
 10666:    360:     def fake_get(url, params=None, timeout=None):
 10667:    361:         called["url"] = url
 10668:    362:         called["params"] = params
 10669:    363: 
 10670:    364:         class Resp:
 10671:    365:             status_code = 200
 10672:    366: 
 10673:    367:             def raise_for_status(self):
 10674:    368:                 pass
 10675:    369: 
 10676:    370:             def json(self):
 10677:    371:                 return {"data": []}
 10678:    372: 
 10679:    373:         return Resp()
 10680:    374: 
 10681:    375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10682:    376: 
 10683:    377:     client.get_contract_detail("BTCUSDT_UMCBL")
 10684:    378: 
 10685:    379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
 10686:    380:     assert called["params"] == {
 10687:    381:         "productType": "USDT-FUTURES",
 10688:    382:         "symbol": "BTCUSDT",
 10689:    383:     }
 10690:    384: 
 10691:    385: 
 10692:    386: def test_cancel_all_endpoint(monkeypatch):
 10693:    387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10694:    388: 
 10695:    389:     called = {}
 10696:    390: 
 10697:    391:     def fake_private(self, method, path, params=None, body=None):
 10698:    392:         called["method"] = method
 10699:    393:         called["path"] = path
 10700:    394:         called["params"] = params
 10701:    395:         called["body"] = body
 10702:    396:         return {"success": True}
 10703:    397: 
 10704:    398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10705:    399: 
 10706:    400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 10707:    401: 
 10708:    402:     assert called["method"] == "POST"
 10709:    403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
 10710:    404:     assert called["params"] is None
 10711:    405:     assert called["body"] == {
 10712:    406:         "productType": "USDT-FUTURES",
 10713:    407:         "symbol": "BTCUSDT",
 10714:    408:         "marginCoin": "USDT",
 10715:    409:     }
 10716:    410: 
 10717:    411: 
 10718:    412: def test_place_order_endpoint(monkeypatch):
 10719:    413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10720:    414: 
 10721:    415:     called = {}
 10722:    416: 
 10723:    417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 10724:    418: 
 10725:    419:     def fake_private(self, method, path, params=None, body=None):
 10726:    420:         called["method"] = method
 10727:    421:         called["path"] = path
 10728:    422:         called["body"] = body
 10729:    423:         return {"success": True}
 10730:    424: 
 10731:    425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10732:    426: 
 10733:    427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
 10734:    428: 
 10735:    429:     assert resp["success"] is True
 10736:    430:     assert called["method"] == "POST"
 10737:    431:     assert called["path"] == "/api/v2/mix/order/place-order"
 10738:    432:     body = called["body"]
 10739:    433:     assert body["symbol"] == "BTCUSDT"
 10740:    434:     assert body["marginCoin"] == "USDT"
 10741:    435:     assert body["marginMode"] == "crossed"
 10742:    436:     assert body["side"] == "buy"
 10743:    437:     assert body["posSide"] == "long"
 10744:    438:     assert "reduceOnly" not in body
 10745:    439:     assert body["posMode"] == "hedge_mode"
 10746:    440: 
 10747:    441: 
 10748:    442: @pytest.mark.parametrize(
 10749:    443:     "code, side_str, pos_side",
 10750:    444:     [
 10751:    445:         (4, "sell", "long"),
 10752:    446:         (2, "buy", "short"),
 10753:    447:     ],
 10754:    448: )
 10755:    449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
 10756:    450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10757:    451: 
 10758:    452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 10759:    453: 
 10760:    454:     called = {}
 10761:    455: 
 10762:    456:     def fake_private(self, method, path, params=None, body=None):
 10763:    457:         called["body"] = body
 10764:    458:         return {"success": True}
 10765:    459: 
 10766:    460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10767:    461: 
 10768:    462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
 10769:    463: 
 10770:    464:     body = called["body"]
 10771:    465:     assert body["side"] == side_str
 10772:    466:     assert body["posSide"] == pos_side
 10773:    467:     assert "reduceOnly" not in body
 10774:    468: 
 10775:    469: 
 10776:    470: def test_place_order_precision(monkeypatch):
 10777:    471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10778:    472: 
 10779:    473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
 10780:    474: 
 10781:    475:     called = {}
 10782:    476: 
 10783:    477:     def fake_private(self, method, path, params=None, body=None):
 10784:    478:         called["body"] = body
 10785:    479:         return {"success": True}
 10786:    480: 
 10787:    481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10788:    482: 
 10789:    483:     client.place_order(
 10790:    484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
 10791:    485:     )
 10792:    486: 
 10793:    487:     assert called["body"]["price"] == 1234.57
 10794:    488:     assert called["body"]["size"] == 1.235
 10795:    489: 
 10796:    490: 
 10797:    491: def test_margin_cap_skips_order(monkeypatch):
 10798:    492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10799:    493:     called = {}
 10800:    494: 
 10801:    495:     def fake_private(method, path, **kwargs):
 10802:    496:         called["path"] = path
 10803:    497:         return {"code": "00000"}
 10804:    498: 
 10805:    499:     monkeypatch.setattr(client, "_private_request", fake_private)
 10806:    500:     contract_detail = {
 10807:    501:         "data": {
 10808:    502:             "symbol": "BTCUSDT_UMCBL",
 10809:    503:             "contractSize": 1,
 10810:    504:             "volUnit": 1,
 10811:    505:             "minVol": 1,
 10812:    506:             "minTradeUSDT": 5,
 10813:    507:         }
 10814:    508:     }
 10815:    509:     price = 100.0
 10816:    510:     available = 0.5
 10817:    511:     vol = bot.compute_position_size(
 10818:    512:         contract_detail,
 10819:    513:         equity_usdt=available,
 10820:    514:         price=price,
 10821:    515:         risk_pct=1.0,
 10822:    516:         leverage=10,
 10823:    517:         symbol="BTCUSDT_UMCBL",
 10824:    518:         available_usdt=available,
 10825:    519:     )
 10826:    520:     if vol > 0:
 10827:    521:         client.place_order(
 10828:    522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
 10829:    523:         )
 10830:    524:     assert called == {}
 10831:    525: 
 10832:    526: 
 10833:    527: def test_margin_cap_reduces_volume(monkeypatch):
 10834:    528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 10835:    529:     called = {}
 10836:    530: 
 10837:    531:     def fake_private(method, path, **kwargs):
 10838:    532:         called["body"] = kwargs.get("body")
 10839:    533:         return {"code": "00000"}
 10840:    534: 
 10841:    535:     monkeypatch.setattr(client, "_private_request", fake_private)
 10842:    536:     contract_detail = {
 10843:    537:         "data": {
 10844:    538:             "symbol": "BTCUSDT_UMCBL",
 10845:    539:             "contractSize": 1,
 10846:    540:             "volUnit": 1,
 10847:    541:             "minVol": 1,
 10848:    542:             "minTradeUSDT": 5,
 10849:    543:         }
 10850:    544:     }
 10851:    545:     price = 10.0
 10852:    546:     vol_theoretical = bot.compute_position_size(
 10853:    547:         contract_detail,
 10854:    548:         equity_usdt=100,
 10855:    549:         price=price,
 10856:    550:         risk_pct=1.0,
 10857:    551:         leverage=10,
 10858:    552:         symbol="BTCUSDT_UMCBL",
 10859:    553:     )
 10860:    554:     available = 20.0
 10861:    555:     vol_final = bot.compute_position_size(
 10862:    556:         contract_detail,
 10863:    557:         equity_usdt=available,
 10864:    558:         price=price,
 10865:    559:         risk_pct=1.0,
 10866:    560:         leverage=10,
 10867:    561:         symbol="BTCUSDT_UMCBL",
 10868:    562:         available_usdt=available,
 10869:    563:     )
 10870:    564:     assert vol_final < vol_theoretical
 10871:    565:     client.place_order(
 10872:    566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
 10873:    567:     )
 10874:    568:     assert called["body"]["size"] == vol_final
 10875:    569: 
 10876:    570: def test_get_open_orders_paper_trade(monkeypatch):
 10877:    571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 10878:    572: 
 10879:    573:     called = {"count": 0}
 10880:    574: 
 10881:    575:     def fake_private(*a, **k):
 10882:    576:         called["count"] += 1
 10883:    577:         return {"success": True}
 10884:    578: 
 10885:    579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10886:    580: 
 10887:    581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
 10888:    582: 
 10889:    583:     assert resp["success"] is True
 10890:    584:     assert resp["data"] == []
 10891:    585:     assert called["count"] == 0
 10892:    586: 
 10893:    587: 
 10894:    588: def test_cancel_all_paper_trade(monkeypatch):
 10895:    589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 10896:    590: 
 10897:    591:     called = {"count": 0}
 10898:    592: 
 10899:    593:     def fake_private(*a, **k):
 10900:    594:         called["count"] += 1
 10901:    595:         return {"success": True}
 10902:    596: 
 10903:    597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 10904:    598: 
 10905:    599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 10906:    600: 
 10907:    601:     assert resp["success"] is True
 10908:    602:     assert called["count"] == 0
 10909:    603: 
 10910:    604: 
 10911:    605: def test_get_kline_transforms_data(monkeypatch):
 10912:    606:     client = BitgetFuturesClient("key", "secret", "https://test")
 10913:    607: 
 10914:    608:     def fake_get(url, params=None, timeout=None):
 10915:    609:         class Resp:
 10916:    610:             def raise_for_status(self):
 10917:    611:                 pass
 10918:    612: 
 10919:    613:             def json(self):
 10920:    614:                 return {
 10921:    615:                     "data": [
 10922:    616:                         ["1", "2", "3", "1", "2", "10", "20"],
 10923:    617:                         ["2", "3", "4", "2", "3", "11", "21"],
 10924:    618:                     ]
 10925:    619:                 }
 10926:    620: 
 10927:    621:         return Resp()
 10928:    622: 
 10929:    623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 10930:    624: 
 10931:    625:     data = client.get_kline("BTC_USDT", interval="1m")
 10932:    626:     kdata = data["data"]
 10933:    627:     assert kdata["open"] == [2.0, 3.0]
 10934:    628:     assert kdata["high"] == [3.0, 4.0]
 10935:    629:     assert kdata["low"] == [1.0, 2.0]
 10936:    630:     assert kdata["close"] == [2.0, 3.0]
 10937:    631:     assert kdata["volume"] == [10.0, 11.0]
 10938:    632:     assert kdata["quoteVolume"] == [20.0, 21.0]
 10939: 
 10940: 
 10941: ## tests/test_compute_position_size.py (last modified: 2025-08-23 20:57:14)
 10942:      1: import os
 10943:      2: import sys
 10944:      3: import types
 10945:      4: import pytest
 10946:      5: 
 10947:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10948:      7: sys.modules["requests"] = types.ModuleType("requests")
 10949:      8: import bot  # noqa: E402
 10950:      9: from bot import compute_position_size  # noqa: E402
 10951:     10: 
 10952:     11: 
 10953:     12: def test_compute_position_size_basic():
 10954:     13:     contract_detail = {
 10955:     14:         "data": [
 10956:     15:             {
 10957:     16:                 "symbol": "BTC_USDT",
 10958:     17:                 "contractSize": 0.01,
 10959:     18:                 "volUnit": 1,
 10960:     19:                 "minVol": 1,
 10961:     20:             }
 10962:     21:         ]
 10963:     22:     }
 10964:     23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
 10965:     24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 10966:     25:     assert vol == 1
 10967:     26: 
 10968:     27: 
 10969:     28: def test_compute_position_size_symbol_not_found():
 10970:     29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
 10971:     30:     with pytest.raises(ValueError):
 10972:     31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
 10973:     32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 10974:     33: 
 10975:     34: 
 10976:     35: def test_compute_position_size_invalid_price():
 10977:     36:     contract_detail = {
 10978:     37:         "data": [
 10979:     38:             {
 10980:     39:                 "symbol": "BTC_USDT",
 10981:     40:                 "contractSize": 0.01,
 10982:     41:                 "volUnit": 1,
 10983:     42:                 "minVol": 1,
 10984:     43:             }
 10985:     44:         ]
 10986:     45:     }
 10987:     46:     vol = compute_position_size(
 10988:     47:         contract_detail,
 10989:     48:         equity_usdt=1000,
 10990:     49:         price=0,
 10991:     50:         risk_pct=0.01,
 10992:     51:         leverage=10,
 10993:     52:         symbol="BTC_USDT",
 10994:     53:     )
 10995:     54:     assert vol == 0
 10996:     55: 
 10997:     56: 
 10998:     57: def test_compute_position_size_respects_equity():
 10999:     58:     contract_detail = {
 11000:     59:         "data": [
 11001:     60:             {
 11002:     61:                 "symbol": "BTC_USDT",
 11003:     62:                 "contractSize": 1,
 11004:     63:                 "volUnit": 1,
 11005:     64:                 "minVol": 1,
 11006:     65:             }
 11007:     66:         ]
 11008:     67:     }
 11009:     68:     vol = compute_position_size(
 11010:     69:         contract_detail,
 11011:     70:         equity_usdt=5,
 11012:     71:         price=100,
 11013:     72:         risk_pct=0.01,
 11014:     73:         leverage=10,
 11015:     74:         symbol="BTC_USDT",
 11016:     75:     )
 11017:     76:     assert vol == 0
 11018:     77: 
 11019:     78: 
 11020:     79: def test_compute_position_size_leaves_fee_buffer():
 11021:     80:     contract_detail = {
 11022:     81:         "data": [
 11023:     82:             {
 11024:     83:                 "symbol": "BTC_USDT",
 11025:     84:                 "contractSize": 1,
 11026:     85:                 "volUnit": 1,
 11027:     86:                 "minVol": 1,
 11028:     87:             }
 11029:     88:         ]
 11030:     89:     }
 11031:     90:     vol = compute_position_size(
 11032:     91:         contract_detail,
 11033:     92:         equity_usdt=100,
 11034:     93:         price=100,
 11035:     94:         risk_pct=1.0,
 11036:     95:         leverage=1,
 11037:     96:         symbol="BTC_USDT",
 11038:     97:     )
 11039:     98:     assert vol == 0
 11040:     99: 
 11041:    100: 
 11042:    101: def test_compute_position_size_under_min_notional_returns_zero():
 11043:    102:     contract_detail = {
 11044:    103:         "data": [
 11045:    104:             {
 11046:    105:                 "symbol": "PI_USDT",
 11047:    106:                 "contractSize": 1,
 11048:    107:                 "volUnit": 1,
 11049:    108:                 "minVol": 1,
 11050:    109:                 "minTradeUSDT": 5,
 11051:    110:             }
 11052:    111:         ]
 11053:    112:     }
 11054:    113:     vol = compute_position_size(
 11055:    114:         contract_detail,
 11056:    115:         equity_usdt=100,
 11057:    116:         price=0.5,
 11058:    117:         risk_pct=0.0001,
 11059:    118:         leverage=20,
 11060:    119:         symbol="PI_USDT",
 11061:    120:     )
 11062:    121:     assert vol == 0
 11063:    122: 
 11064:    123: 
 11065:    124: def test_compute_position_size_cap_by_available():
 11066:    125:     contract_detail = {
 11067:    126:         "data": [
 11068:    127:             {
 11069:    128:                 "symbol": "BTC_USDT",
 11070:    129:                 "contractSize": 1,
 11071:    130:                 "volUnit": 2,
 11072:    131:                 "minVol": 2,
 11073:    132:                 "minTradeUSDT": 5,
 11074:    133:             }
 11075:    134:         ]
 11076:    135:     }
 11077:    136:     vol = compute_position_size(
 11078:    137:         contract_detail,
 11079:    138:         equity_usdt=100,
 11080:    139:         price=10,
 11081:    140:         risk_pct=0.5,
 11082:    141:         leverage=10,
 11083:    142:         symbol="BTC_USDT",
 11084:    143:         available_usdt=0.5,
 11085:    144:     )
 11086:    145:     assert vol == 0
 11087:    146:     vol = compute_position_size(
 11088:    147:         contract_detail,
 11089:    148:         equity_usdt=100,
 11090:    149:         price=10,
 11091:    150:         risk_pct=0.5,
 11092:    151:         leverage=10,
 11093:    152:         symbol="BTC_USDT",
 11094:    153:         available_usdt=10,
 11095:    154:     )
 11096:    155:     assert vol == 8
 11097:    156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
 11098:    157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
 11099:    158:     assert required <= 10
 11100: 
 11101: 
 11102: ## tests/test_compute_position_size_cap.py (last modified: 2025-08-23 20:57:14)
 11103:      1: import os
 11104:      2: import sys
 11105:      3: import types
 11106:      4: import pytest
 11107:      5: 
 11108:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11109:      7: sys.modules['requests'] = types.ModuleType('requests')
 11110:      8: 
 11111:      9: from bot import compute_position_size, CONFIG
 11112:     10: 
 11113:     11: 
 11114:     12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
 11115:     13:     return {
 11116:     14:         "data": [
 11117:     15:             {
 11118:     16:                 "symbol": "BTC_USDT",
 11119:     17:                 "contractSize": 0.001,
 11120:     18:                 "volUnit": vol_unit,
 11121:     19:                 "minVol": min_vol,
 11122:     20:                 "minTradeUSDT": min_trade,
 11123:     21:             }
 11124:     22:         ]
 11125:     23:     }
 11126:     24: 
 11127:     25: 
 11128:     26: def test_volume_zero_when_available_low():
 11129:     27:     detail = _detail()
 11130:     28:     vol = compute_position_size(
 11131:     29:         detail,
 11132:     30:         equity_usdt=1000,
 11133:     31:         price=10000,
 11134:     32:         risk_pct=0.01,
 11135:     33:         leverage=10,
 11136:     34:         symbol="BTC_USDT",
 11137:     35:         available_usdt=0.5,
 11138:     36:     )
 11139:     37:     assert vol == 0
 11140:     38: 
 11141:     39: 
 11142:     40: def test_margin_close_to_available():
 11143:     41:     detail = _detail()
 11144:     42:     CONFIG["FEE_RATE"] = 0.001
 11145:     43:     available = 1.05
 11146:     44:     vol = compute_position_size(
 11147:     45:         detail,
 11148:     46:         equity_usdt=1000,
 11149:     47:         price=10000,
 11150:     48:         risk_pct=1,
 11151:     49:         leverage=10,
 11152:     50:         symbol="BTC_USDT",
 11153:     51:         available_usdt=available,
 11154:     52:     )
 11155:     53:     assert vol == 1
 11156:     54:     notional = 10000 * 0.001 * vol
 11157:     55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
 11158:     56:     required = (notional / 10 + fee) * 1.03
 11159:     57:     assert required == pytest.approx(available, rel=0.05)
 11160:     58: 
 11161:     59: 
 11162:     60: def test_respects_units_and_minimums():
 11163:     61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
 11164:     62:     vol = compute_position_size(
 11165:     63:         detail,
 11166:     64:         equity_usdt=1000,
 11167:     65:         price=1000,
 11168:     66:         risk_pct=1,
 11169:     67:         leverage=5,
 11170:     68:         symbol="BTC_USDT",
 11171:     69:         available_usdt=1000,
 11172:     70:     )
 11173:     71:     assert vol % 2 == 0 and vol >= 2
 11174: 
 11175: 
 11176: ## tests/test_dynamic_allocation.py (last modified: 2025-08-23 20:57:14)
 11177:      1: import math
 11178:      2: from scalper.risk import adjust_risk_pct
 11179:      3: 
 11180:      4: 
 11181:      5: def test_adjust_risk_pct_increase_decrease():
 11182:      6:     base = 0.01
 11183:      7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
 11184:      8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
 11185:      9: 
 11186:     10: 
 11187:     11: def test_adjust_risk_pct_bounds():
 11188:     12:     assert math.isclose(
 11189:     13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
 11190:     14:     )
 11191:     15:     assert math.isclose(
 11192:     16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
 11193:     17:     )
 11194: 
 11195: 
 11196: ## tests/test_effective_leverage.py (last modified: 2025-08-23 20:57:14)
 11197:      1: import pytest
 11198:      2: from scalper.trade_utils import effective_leverage
 11199:      3: 
 11200:      4: 
 11201:      5: def test_effective_leverage_basic():
 11202:      6:     lev = effective_leverage(
 11203:      7:         entry_price=100.0,
 11204:      8:         liquidation_price=90.0,
 11205:      9:         position_margin=10.0,
 11206:     10:         position_size=1.0,
 11207:     11:     )
 11208:     12:     assert lev == pytest.approx(10.0)
 11209:     13: 
 11210:     14: 
 11211:     15: def test_effective_leverage_estimated_margin():
 11212:     16:     lev = effective_leverage(
 11213:     17:         entry_price=200.0,
 11214:     18:         liquidation_price=180.0,
 11215:     19:         position_margin=0.0,
 11216:     20:         position_size=2.0,
 11217:     21:     )
 11218:     22:     # price diff 20 * size 2 -> margin 40; notional 400
 11219:     23:     assert lev == pytest.approx(10.0)
 11220:     24: 
 11221:     25: 
 11222:     26: def test_effective_leverage_short_position():
 11223:     27:     lev = effective_leverage(
 11224:     28:         entry_price=100.0,
 11225:     29:         liquidation_price=110.0,
 11226:     30:         position_margin=10.0,
 11227:     31:         position_size=-1.5,
 11228:     32:     )
 11229:     33:     assert lev == pytest.approx(15.0)
 11230:     34: 
 11231:     35: 
 11232:     36: def test_effective_leverage_invalid():
 11233:     37:     assert effective_leverage(0, 0, 0, 0) == 0.0
 11234: 
 11235: 
 11236: ## tests/test_env_loading.py (last modified: 2025-08-23 20:57:14)
 11237:      1: """Tests for loading environment variables from ``notebook/.env``."""
 11238:      2: 
 11239:      3: from __future__ import annotations
 11240:      4: 
 11241:      5: import importlib
 11242:      6: import os
 11243:      7: import sys
 11244:      8: from pathlib import Path
 11245:      9: 
 11246:     10: 
 11247:     11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
 11248:     12:     """Module should load variables from ``notebook/.env`` if present."""
 11249:     13: 
 11250:     14:     notebook = tmp_path / "notebook"
 11251:     15:     spot = notebook / "spot"
 11252:     16:     spot.mkdir(parents=True)
 11253:     17:     bitget_bot = spot / "bitget_bot.py"
 11254:     18:     bitget_bot.write_text("")
 11255:     19:     env_file = notebook / ".env"
 11256:     20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
 11257:     21: 
 11258:     22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
 11259:     23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
 11260:     24:     import scalp
 11261:     25: 
 11262:     26:     importlib.reload(scalp)
 11263:     27: 
 11264:     28:     try:
 11265:     29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
 11266:     30:     finally:
 11267:     31:         env_file.unlink(missing_ok=True)
 11268:     32:         if old is None:
 11269:     33:             os.environ.pop("BITGET_ACCESS_KEY", None)
 11270:     34:         else:
 11271:     35:             os.environ["BITGET_ACCESS_KEY"] = old
 11272: 
 11273: 
 11274: ## tests/test_grid_search.py (last modified: 2025-08-23 20:57:14)
 11275:      1: import json
 11276:      2: import random
 11277:      3: 
 11278:      4: import pytest
 11279:      5: 
 11280:      6: from scalper.backtest import grid_search
 11281:      7: 
 11282:      8: 
 11283:      9: def test_build_grid_sampling():
 11284:     10:     param_lists = {
 11285:     11:         "timeframe": ["1m", "5m", "15m"],
 11286:     12:         "score_min": [50, 55, 60],
 11287:     13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
 11288:     14:     }
 11289:     15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
 11290:     16:     assert len(combos) == 6
 11291:     17:     tfs = {c["timeframe"] for c in combos}
 11292:     18:     assert {"1m", "5m", "15m"}.issubset(tfs)
 11293:     19: 
 11294:     20: 
 11295:     21: def test_run_grid_search_with_mock(tmp_path):
 11296:     22:     calls = []
 11297:     23: 
 11298:     24:     def fake_run_backtest_multi(**kwargs):
 11299:     25:         tf = kwargs.get("timeframe")
 11300:     26:         risk = kwargs.get("risk_pct")
 11301:     27:         # fabricate metrics based on params
 11302:     28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
 11303:     29:         pf += risk  # tiny variation
 11304:     30:         metrics = {
 11305:     31:             "symbol": "TOTAL",
 11306:     32:             "pnl_usdt": 100 * risk,
 11307:     33:             "profit_factor": pf,
 11308:     34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
 11309:     35:             "winrate_pct": 50.0,
 11310:     36:             "trades": 40 if tf == "1m" else 30,
 11311:     37:         }
 11312:     38:         calls.append((tf, risk))
 11313:     39:         return [metrics], []
 11314:     40: 
 11315:     41:     param_lists = {
 11316:     42:         "timeframe": ["1m", "5m"],
 11317:     43:         "risk_pct": [0.005, 0.01],
 11318:     44:     }
 11319:     45:     base_params = {
 11320:     46:         "timeframe": "1m",
 11321:     47:         "risk_pct": 0.005,
 11322:     48:     }
 11323:     49:     out_dir = tmp_path / "grid"
 11324:     50:     grid_search.run_grid_search(
 11325:     51:         symbols=["BTC/USDT"],
 11326:     52:         exchange="csv",
 11327:     53:         base_params=base_params,
 11328:     54:         param_lists=param_lists,
 11329:     55:         grid_max=4,
 11330:     56:         csv_dir="/dev/null",
 11331:     57:         out_dir=str(out_dir),
 11332:     58:         run_func=fake_run_backtest_multi,
 11333:     59:     )
 11334:     60:     best = json.loads((out_dir / "best_config.json").read_text())
 11335:     61:     # best PF should be timeframe 5m risk 0.01
 11336:     62:     assert best["params"]["timeframe"] == "5m"
 11337:     63:     assert best["params"]["risk_pct"] == 0.01
 11338:     64:     assert len(calls) == 4
 11339:     65: 
 11340:     66: 
 11341:     67: def test_parse_hours():
 11342:     68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
 11343:     69: 
 11344:     70: 
 11345:     71: def test_deterministic_results(tmp_path):
 11346:     72:     def fake_run_backtest_multi(**kwargs):
 11347:     73:         # metrics vary with global random state
 11348:     74:         pf = random.uniform(1.0, 3.0)
 11349:     75:         metrics = {
 11350:     76:             "symbol": "TOTAL",
 11351:     77:             "pnl_usdt": random.uniform(-10, 10),
 11352:     78:             "profit_factor": pf,
 11353:     79:             "max_drawdown_pct": random.uniform(1, 5),
 11354:     80:             "winrate_pct": 50.0,
 11355:     81:             "trades": random.randint(10, 50),
 11356:     82:         }
 11357:     83:         return [metrics], []
 11358:     84: 
 11359:     85:     param_lists = {"timeframe": ["1m", "5m"]}
 11360:     86:     base_params = {"timeframe": "1m"}
 11361:     87:     out_dir = tmp_path / "grid"
 11362:     88:     res1 = grid_search.run_grid_search(
 11363:     89:         symbols=["BTC/USDT"],
 11364:     90:         exchange="csv",
 11365:     91:         base_params=base_params,
 11366:     92:         param_lists=param_lists,
 11367:     93:         grid_max=2,
 11368:     94:         csv_dir="/dev/null",
 11369:     95:         out_dir=str(out_dir),
 11370:     96:         seed=42,
 11371:     97:         run_func=fake_run_backtest_multi,
 11372:     98:     )
 11373:     99:     best1 = json.loads((out_dir / "best_config.json").read_text())
 11374:    100:     # run again
 11375:    101:     out_dir2 = tmp_path / "grid2"
 11376:    102:     res2 = grid_search.run_grid_search(
 11377:    103:         symbols=["BTC/USDT"],
 11378:    104:         exchange="csv",
 11379:    105:         base_params=base_params,
 11380:    106:         param_lists=param_lists,
 11381:    107:         grid_max=2,
 11382:    108:         csv_dir="/dev/null",
 11383:    109:         out_dir=str(out_dir2),
 11384:    110:         seed=42,
 11385:    111:         run_func=fake_run_backtest_multi,
 11386:    112:     )
 11387:    113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
 11388:    114:     assert best1 == best2
 11389:    115:     # also ensure results object same best params
 11390:    116:     assert res1[0].params == res2[0].params
 11391: 
 11392: 
 11393: ## tests/test_heat_score.py (last modified: 2025-08-23 20:57:14)
 11394:      1: from scalper.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
 11395:      2: 
 11396:      3: 
 11397:      4: def test_heat_score_value():
 11398:      5:     assert heat_score(2.0, 100.0) == 200.0
 11399:      6:     assert heat_score(2.0, 100.0, news=True) == 400.0
 11400:      7: 
 11401:      8: 
 11402:      9: def test_select_and_decorrelate_pairs():
 11403:     10:     pairs = [
 11404:     11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
 11405:     12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
 11406:     13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
 11407:     14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
 11408:     15:     ]
 11409:     16:     top = select_top_heat_pairs(pairs, top_n=3)
 11410:     17:     assert len(top) == 3
 11411:     18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
 11412:     19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
 11413:     20:     syms = {p["symbol"] for p in selected}
 11414:     21:     assert not ("A" in syms and "B" in syms)
 11415: 
 11416: 
 11417: ## tests/test_indicators.py (last modified: 2025-08-23 20:57:14)
 11418:      1: 
 11419:      2: 
 11420:      3: import os
 11421:      4: import sys
 11422:      5: import pytest
 11423:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11424:      7: 
 11425:      8: 
 11426:      9: 
 11427:     10: 
 11428:     11: from scalper.metrics import calc_rsi, calc_atr, calc_macd
 11429:     12: 
 11430:     13: 
 11431:     14: def test_calc_rsi_uptrend():
 11432:     15:     prices = list(range(1, 16))  # strictly increasing
 11433:     16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
 11434:     17: 
 11435:     18: 
 11436:     19: def test_calc_rsi_downtrend():
 11437:     20:     prices = list(range(15, 0, -1))  # strictly decreasing
 11438:     21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
 11439:     22: 
 11440:     23: 
 11441:     24: 
 11442:     25: def test_calc_rsi_flat():
 11443:     26:     prices = [1.0] * 15  # no movement
 11444:     27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
 11445:     28: 
 11446:     29: 
 11447:     30: 
 11448:     31:     highs = [10, 11, 12, 13, 14]
 11449:     32:     lows = [9, 10, 11, 12, 13]
 11450:     33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
 11451:     34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
 11452:     35: 
 11453:     36: 
 11454:     37: def test_calc_macd_trend():
 11455:     38:     prices = list(range(1, 60))
 11456:     39:     macd, signal, hist = calc_macd(prices)
 11457:     40:     assert macd > signal
 11458:     41:     assert hist > 0
 11459:     42: 
 11460:     43: 
 11461:     44: def test_calc_macd_flat():
 11462:     45:     prices = [100.0] * 60
 11463:     46:     macd, signal, hist = calc_macd(prices)
 11464:     47:     assert macd == pytest.approx(0.0)
 11465:     48:     assert signal == pytest.approx(0.0)
 11466:     49:     assert hist == pytest.approx(0.0)
 11467:     50: 
 11468:     51: 
 11469:     52: 
 11470:     53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
 11471:     54: def test_calc_rsi_invalid_inputs(prices, period):
 11472:     55:     with pytest.raises(ValueError):
 11473:     56:         calc_rsi(prices, period=period)
 11474:     57: 
 11475:     58: 
 11476:     59: @pytest.mark.parametrize(
 11477:     60:     "highs, lows, closes, period",
 11478:     61:     [
 11479:     62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
 11480:     63:         ([1, 2], [1, 1], [1, 1], 3),
 11481:     64:     ],
 11482:     65: )
 11483:     66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
 11484:     67:     with pytest.raises(ValueError):
 11485:     68:         calc_atr(highs, lows, closes, period=period)
 11486:     69: 
 11487: 
 11488: 
 11489: ## tests/test_min_qty_rules.py (last modified: 2025-08-23 20:57:14)
 11490:      1: import os
 11491:      2: import sys
 11492:      3: import types
 11493:      4: 
 11494:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11495:      6: sys.modules['requests'] = types.ModuleType('requests')
 11496:      7: 
 11497:      8: from bot import _apply_contract_checks
 11498:      9: 
 11499:     10: 
 11500:     11: def _detail():
 11501:     12:     return {
 11502:     13:         "data": [
 11503:     14:             {
 11504:     15:                 "symbol": "BTC_USDT",
 11505:     16:                 "contractSize": 1,
 11506:     17:                 "volUnit": 5,
 11507:     18:                 "minVol": 10,
 11508:     19:                 "minTradeUSDT": 5,
 11509:     20:             }
 11510:     21:         ]
 11511:     22:     }
 11512:     23: 
 11513:     24: 
 11514:     25: def test_min_qty_floor_and_validation():
 11515:     26:     detail = _detail()
 11516:     27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
 11517:     28:     assert vol == 10
 11518:     29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
 11519:     30:     assert vol2 == 0
 11520: 
 11521: 
 11522: ## tests/test_notifier.py (last modified: 2025-08-23 20:57:14)
 11523:      1: import scalper.notifier as notifier
 11524:      2: 
 11525:      3: 
 11526:      4: def test_notify_skips_without_targets(monkeypatch):
 11527:      5:     called = False
 11528:      6: 
 11529:      7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
 11530:      8:         nonlocal called
 11531:      9:         called = True
 11532:     10: 
 11533:     11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 11534:     12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 11535:     13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 11536:     14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11537:     15:     notifier.notify("test", {"foo": 1})
 11538:     16:     assert called is False
 11539:     17: 
 11540:     18: 
 11541:     19: def test_notify_posts_http(monkeypatch):
 11542:     20:     payload = {}
 11543:     21: 
 11544:     22:     def fake_post(url, json=None, timeout=5):
 11545:     23:         payload["url"] = url
 11546:     24:         payload["json"] = json
 11547:     25:         payload["timeout"] = timeout
 11548:     26: 
 11549:     27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 11550:     28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 11551:     29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11552:     30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11553:     31:     notifier.notify("evt", {"bar": 2})
 11554:     32:     assert payload["url"] == "http://example.com"
 11555:     33:     assert payload["json"]["event"] == "evt"
 11556:     34:     assert payload["json"]["bar"] == 2
 11557:     35: 
 11558:     36: 
 11559:     37: def test_notify_posts_telegram(monkeypatch):
 11560:     38:     payload = {}
 11561:     39: 
 11562:     40:     def fake_post(url, json=None, timeout=5):
 11563:     41:         payload["url"] = url
 11564:     42:         payload["json"] = json
 11565:     43:         payload["timeout"] = timeout
 11566:     44: 
 11567:     45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 11568:     46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11569:     47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11570:     48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11571:     49: 
 11572:     50:     notifier.notify("evt", {"bar": 2})
 11573:     51: 
 11574:     52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
 11575:     53:     assert payload["json"]["chat_id"] == "123"
 11576:     54:     assert "evt" in payload["json"]["text"]
 11577:     55: 
 11578:     56: 
 11579:     57: def test_notify_posts_both(monkeypatch):
 11580:     58:     calls = []
 11581:     59: 
 11582:     60:     def fake_post(url, json=None, timeout=5):
 11583:     61:         calls.append({"url": url, "json": json, "timeout": timeout})
 11584:     62: 
 11585:     63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11586:     64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11587:     65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11588:     66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11589:     67: 
 11590:     68:     notifier.notify("evt", {"bar": 2})
 11591:     69: 
 11592:     70:     assert len(calls) == 2
 11593:     71:     urls = {c["url"] for c in calls}
 11594:     72:     assert "http://example.com" in urls
 11595:     73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
 11596:     74: 
 11597:     75: 
 11598:     76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
 11599:     77:     calls = []
 11600:     78: 
 11601:     79:     def fake_post(url, json=None, timeout=5):
 11602:     80:         calls.append(url)
 11603:     81: 
 11604:     82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 11605:     83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 11606:     84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 11607:     85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 11608:     86: 
 11609:     87:     notifier.notify("pair_list", {"pairs": "BTC"})
 11610:     88: 
 11611:     89:     # Only the generic webhook should be called, not Telegram
 11612:     90:     assert calls == ["http://example.com"]
 11613:     91: 
 11614:     92: 
 11615:     93: def test_format_text_open_position():
 11616:     94:     payload = {
 11617:     95:         "symbol": "BTCUSDT",
 11618:     96:         "side": "short",
 11619:     97:         "price": 18350,
 11620:     98:         "vol": 37,
 11621:     99:         "contract_size": 1,
 11622:    100:         "notional_usdt": 120.5,
 11623:    101:         "leverage": 5,
 11624:    102:         "required_margin_usdt": 25.3,
 11625:    103:         "available_usdt": 134,
 11626:    104:         "risk_level_user": 3,
 11627:    105:         "signal_level": 2,
 11628:    106:         "risk_color": "🟡",
 11629:    107:         "risk_pct_eff": 0.01,
 11630:    108:         "fee_rate": 0.001,
 11631:    109:     }
 11632:    110:     text = notifier._format_text("position_opened", payload)
 11633:    111:     lines = text.splitlines()
 11634:    112: 
 11635:    113:     assert lines[0] == "🟡 Ouvre short BTC"
 11636:    114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
 11637:    115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
 11638:    116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
 11639:    117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
 11640:    118: 
 11641:    119: 
 11642:    120: def test_format_text_closed_position():
 11643:    121:     payload = {
 11644:    122:         "symbol": "BTCUSDT",
 11645:    123:         "side": "short",
 11646:    124:         "entry_price": 18350,
 11647:    125:         "exit_price": 18328,
 11648:    126:         "vol": 37,
 11649:    127:         "contract_size": 1,
 11650:    128:         "notional_entry_usdt": 120.5,
 11651:    129:         "notional_exit_usdt": 120.3,
 11652:    130:         "fees_usdt": 0.03,
 11653:    131:         "pnl_usdt": 0.84,
 11654:    132:         "pnl_pct_on_margin": 3.25,
 11655:    133:         "leverage": 5,
 11656:    134:         "risk_color": "🟡",
 11657:    135:         "fee_rate": 0.001,
 11658:    136:     }
 11659:    137:     text = notifier._format_text("position_closed", payload)
 11660:    138:     lines = text.splitlines()
 11661:    139:     assert lines[0] == "Ferme short BTC 🟡"
 11662:    140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
 11663:    141:     assert lines[2] == "% sur marge: 3.25%"
 11664:    142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
 11665:    143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
 11666:    144: 
 11667:    145: 
 11668:    146: def test_format_text_pair_list_and_start():
 11669:    147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
 11670:    148:     text = notifier._format_text(
 11671:    149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
 11672:    150:     )
 11673:    151:     assert text == "Listing ok"
 11674:    152: 
 11675:    153: 
 11676:    154: def test_format_pair_list_helper():
 11677:    155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
 11678:    156:     text = notifier._format_pair_list(payload)
 11679:    157:     assert text == "Listing ok"
 11680:    158: 
 11681:    159: 
 11682:    160: def test_format_position_event_helper():
 11683:    161:     payload = {
 11684:    162:         "symbol": "BTCUSDT",
 11685:    163:         "side": "short",
 11686:    164:         "price": 18350,
 11687:    165:         "vol": 37,
 11688:    166:         "contract_size": 1,
 11689:    167:         "notional_usdt": 120.5,
 11690:    168:         "leverage": 5,
 11691:    169:         "required_margin_usdt": 25.3,
 11692:    170:         "available_usdt": 134,
 11693:    171:         "risk_level_user": 3,
 11694:    172:         "signal_level": 2,
 11695:    173:         "risk_color": "🟡",
 11696:    174:         "risk_pct_eff": 0.01,
 11697:    175:         "fee_rate": 0.001,
 11698:    176:     }
 11699:    177:     text = notifier._format_position_event("position_opened", payload)
 11700:    178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
 11701:    179: 
 11702:    180: 
 11703: 
 11704: 
 11705: ## tests/test_notional_and_pnl_units.py (last modified: 2025-08-23 20:57:14)
 11706:      1: import os, sys, types, pytest
 11707:      2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11708:      3: sys.modules['requests'] = types.ModuleType('requests')
 11709:      4: 
 11710:      5: from scalper.trade_utils import (
 11711:      6:     get_contract_size,
 11712:      7:     notional as calc_notional,
 11713:      8:     required_margin as calc_required_margin,
 11714:      9:     compute_pnl_usdt,
 11715:     10:     compute_pnl_with_fees,
 11716:     11: )
 11717:     12: 
 11718:     13: 
 11719:     14: def _detail():
 11720:     15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
 11721:     16: 
 11722:     17: 
 11723:     18: def test_notional_and_pnl_units():
 11724:     19:     detail = _detail()
 11725:     20:     cs = get_contract_size(detail, "BTC_USDT")
 11726:     21:     N = calc_notional(10000, 2, cs)
 11727:     22:     assert N == pytest.approx(10000 * 0.001 * 2)
 11728:     23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
 11729:     24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
 11730:     25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
 11731:     26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
 11732:     27:     pnl_net, pct = compute_pnl_with_fees(
 11733:     28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
 11734:     29:     )
 11735:     30:     gross = (10100 - 10000) * cs * 2
 11736:     31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
 11737:     32:     expected = gross - fees
 11738:     33:     expected_pct = expected / (N / 10) * 100
 11739:     34:     assert pnl_net == pytest.approx(expected)
 11740:     35:     assert pct == pytest.approx(expected_pct)
 11741: 
 11742: 
 11743: ## tests/test_pair_selection.py (last modified: 2025-08-23 20:57:14)
 11744:      1: import bot
 11745:      2: 
 11746:      3: 
 11747:      4: def test_get_trade_pairs():
 11748:      5:     class Client:
 11749:      6:         def get_ticker(self, symbol=None):
 11750:      7:             return {
 11751:      8:                 "success": True,
 11752:      9:                 "data": [
 11753:     10:                     {"symbol": "BTC_USDT"},
 11754:     11:                     {"symbol": "ETH_USDT"},
 11755:     12:                 ],
 11756:     13:             }
 11757:     14: 
 11758:     15:     pairs = bot.get_trade_pairs(Client())
 11759:     16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
 11760:     17: 
 11761:     18: 
 11762:     19: def test_select_top_pairs():
 11763:     20:     class Client:
 11764:     21:         def get_ticker(self, symbol=None):
 11765:     22:             return {
 11766:     23:                 "success": True,
 11767:     24:                 "data": [
 11768:     25:                     {"symbol": "A", "volume": "1"},
 11769:     26:                     {"symbol": "B", "volume": "3"},
 11770:     27:                     {"symbol": "C", "volume": "2"},
 11771:     28:                 ],
 11772:     29:             }
 11773:     30: 
 11774:     31:     top = bot.select_top_pairs(Client(), top_n=2)
 11775:     32:     assert [p["symbol"] for p in top] == ["B", "C"]
 11776:     33: 
 11777:     34: 
 11778:     35: def test_select_top_pairs_default_count():
 11779:     36:     class Client:
 11780:     37:         def get_ticker(self, symbol=None):
 11781:     38:             data = []
 11782:     39:             for i in range(100):
 11783:     40:                 data.append({"symbol": str(i), "volume": str(i)})
 11784:     41:             return {"success": True, "data": data}
 11785:     42: 
 11786:     43:     top = bot.select_top_pairs(Client())
 11787:     44:     assert len(top) == 40
 11788:     45: 
 11789:     46: 
 11790:     47: def test_filter_trade_pairs():
 11791:     48:     class Client:
 11792:     49:         def get_ticker(self, symbol=None):
 11793:     50:             return {
 11794:     51:                 "success": True,
 11795:     52:                 "data": [
 11796:     53:                     {
 11797:     54:                         "symbol": "AAA",
 11798:     55:                         "volume": "6000000",
 11799:     56:                         "bidPrice": "100",
 11800:     57:                         "askPrice": "100.03",
 11801:     58:                     },  # spread ~3 bps
 11802:     59:                     {
 11803:     60:                         "symbol": "BBB",
 11804:     61:                         "volume": "10000000",
 11805:     62:                         "bidPrice": "50",
 11806:     63:                         "askPrice": "50.1",
 11807:     64:                     },  # spread ~200 bps
 11808:     65:                     {
 11809:     66:                         "symbol": "CCC",
 11810:     67:                         "volume": "7000000",
 11811:     68:                         "bidPrice": "10",
 11812:     69:                         "askPrice": "10.01",
 11813:     70:                     },  # spread ~100 bps
 11814:     71:                     {
 11815:     72:                         "symbol": "DDD",
 11816:     73:                         "volume": "4000000",
 11817:     74:                         "bidPrice": "20",
 11818:     75:                         "askPrice": "20.01",
 11819:     76:                     },  # volume trop faible
 11820:     77:                 ],
 11821:     78:             }
 11822:     79: 
 11823:     80:     pairs = bot.filter_trade_pairs(
 11824:     81:         Client(),
 11825:     82:         volume_min=5_000_000,
 11826:     83:         max_spread_bps=5,
 11827:     84:     )
 11828:     85:     assert [p["symbol"] for p in pairs] == ["AAA"]
 11829:     86: 
 11830:     87: 
 11831:     88: def test_find_trade_positions(monkeypatch):
 11832:     89:     class Client:
 11833:     90:         def __init__(self):
 11834:     91:             self.data = {
 11835:     92:                 "AAA": {"data": {"close": [1, 2, 3]}},
 11836:     93:                 "BBB": {"data": {"close": [3, 2, 1]}},
 11837:     94:             }
 11838:     95: 
 11839:     96:         def get_kline(self, symbol, interval="1m"):
 11840:     97:             return self.data[symbol]
 11841:     98: 
 11842:     99:     pairs = [
 11843:    100:         {"symbol": "AAA", "lastPrice": "1"},
 11844:    101:         {"symbol": "BBB", "lastPrice": "1"},
 11845:    102:     ]
 11846:    103: 
 11847:    104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
 11848:    105: 
 11849:    106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
 11850:    107:         if last_fast > prev_fast:
 11851:    108:             return 1
 11852:    109:         if last_fast < prev_fast:
 11853:    110:             return -1
 11854:    111:         return 0
 11855:    112: 
 11856:    113:     monkeypatch.setattr(bot, "cross", fake_cross)
 11857:    114: 
 11858:    115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
 11859:    116:     assert signals == [
 11860:    117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
 11861:    118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
 11862:    119:     ]
 11863: 
 11864: 
 11865: ## tests/test_pairs.py (last modified: 2025-08-23 20:57:14)
 11866:      1: import bot
 11867:      2: 
 11868:      3: 
 11869:      4: def test_send_selected_pairs(monkeypatch):
 11870:      5:     sent = {}
 11871:      6: 
 11872:      7:     def fake_notify(event, payload=None):
 11873:      8:         sent["event"] = event
 11874:      9:         sent["payload"] = payload
 11875:     10: 
 11876:     11:     monkeypatch.setattr(bot, "notify", fake_notify)
 11877:     12:     monkeypatch.setattr(
 11878:     13:         bot,
 11879:     14:         "filter_trade_pairs",
 11880:     15:         lambda client, top_n=120: [
 11881:     16:             {"symbol": "WIFUSDT", "volume": 10},
 11882:     17:             {"symbol": "WIFUSDT", "volume": 9},
 11883:     18:             {"symbol": "BTCUSD", "volume": 8},
 11884:     19:             {"symbol": "BTCUSDT", "volume": 7},
 11885:     20:             {"symbol": "DOGEUSDT", "volume": 6},
 11886:     21:             {"symbol": "ETHUSDC", "volume": 5},
 11887:     22:             {"symbol": "ETHUSDT", "volume": 4},
 11888:     23:         ],
 11889:     24:     )
 11890:     25: 
 11891:     26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
 11892:     27: 
 11893:     28:     payload = bot.send_selected_pairs(object(), top_n=4)
 11894:     29: 
 11895:     30:     assert sent["event"] == "pair_list"
 11896:     31:     assert sent["payload"]["green"] == "BTC"
 11897:     32:     assert sent["payload"]["orange"] == "ETH"
 11898:     33:     assert "red" not in sent["payload"]
 11899:     34:     assert payload == sent["payload"]
 11900:     35: 
 11901:     36: 
 11902:     37: def test_send_selected_pairs_no_whitelist(monkeypatch):
 11903:     38:     sent = {}
 11904:     39: 
 11905:     40:     def fake_notify(event, payload=None):
 11906:     41:         sent["payload"] = payload
 11907:     42: 
 11908:     43:     monkeypatch.setattr(bot, "notify", fake_notify)
 11909:     44:     monkeypatch.setattr(
 11910:     45:         bot,
 11911:     46:         "filter_trade_pairs",
 11912:     47:         lambda client, top_n=120: [
 11913:     48:             {"symbol": "AAAUSDT", "volume": 10},
 11914:     49:             {"symbol": "BBBUSD", "volume": 9},
 11915:     50:             {"symbol": "CCCUSDC", "volume": 8},
 11916:     51:             {"symbol": "DDDUSDT", "volume": 7},
 11917:     52:         ],
 11918:     53:     )
 11919:     54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
 11920:     55: 
 11921:     56:     payload = bot.send_selected_pairs(object(), top_n=4)
 11922:     57: 
 11923:     58:     assert payload == sent["payload"]
 11924:     59:     assert payload["green"] == "AAA"
 11925:     60:     assert payload["orange"] == "BBB"
 11926:     61:     assert payload["red"] == "CCC, DDD"
 11927:     62: 
 11928:     63: 
 11929:     64: def test_filter_trade_pairs_all_pairs(monkeypatch):
 11930:     65:     class DummyClient:
 11931:     66:         def get_ticker(self):
 11932:     67:             return {
 11933:     68:                 "data": [
 11934:     69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
 11935:     70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
 11936:     71:                 ]
 11937:     72:             }
 11938:     73: 
 11939:     74:     client = DummyClient()
 11940:     75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
 11941:     76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
 11942:     77: 
 11943: 
 11944: 
 11945: ## tests/test_risk_manager.py (last modified: 2025-08-23 20:57:14)
 11946:      1: from scalp import RiskManager
 11947:      2: 
 11948:      3: 
 11949:      4: def test_kill_switch_triggered() -> None:
 11950:      5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
 11951:      6:     rm.record_trade(-1.0)
 11952:      7:     rm.record_trade(-1.5)
 11953:      8:     assert rm.kill_switch is True
 11954:      9: 
 11955:     10: 
 11956:     11: def test_profit_kill_switch_triggered() -> None:
 11957:     12:     rm = RiskManager(
 11958:     13:         max_daily_loss_pct=10.0,
 11959:     14:         max_daily_profit_pct=3.0,
 11960:     15:         max_positions=1,
 11961:     16:         risk_pct=0.01,
 11962:     17:     )
 11963:     18:     rm.record_trade(1.5)
 11964:     19:     rm.record_trade(1.6)
 11965:     20:     assert rm.kill_switch is True
 11966:     21: 
 11967:     22: 
 11968:     23: def test_pause_and_can_open() -> None:
 11969:     24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 11970:     25:     rm.record_trade(-0.5)
 11971:     26:     rm.record_trade(-0.6)
 11972:     27:     rm.record_trade(-0.7)
 11973:     28:     assert rm.pause_duration() == 15 * 60
 11974:     29:     rm.record_trade(-0.8)
 11975:     30:     rm.record_trade(-0.9)
 11976:     31:     assert rm.pause_duration() == 60 * 60
 11977:     32:     assert rm.can_open(0) is True
 11978:     33:     assert rm.can_open(1) is False
 11979:     34: 
 11980:     35: 
 11981:     36: def test_risk_pct_scaling() -> None:
 11982:     37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 11983:     38:     rm.record_trade(1.0)
 11984:     39:     rm.record_trade(1.0)
 11985:     40:     assert rm.risk_pct > 0.01
 11986:     41:     rm.record_trade(-1.0)
 11987:     42:     rm.record_trade(-1.0)
 11988:     43:     assert rm.risk_pct < 0.01
 11989: 
 11990: 
 11991: ## tests/test_risk_utils.py (last modified: 2025-08-23 20:57:14)
 11992:      1: import pytest
 11993:      2: 
 11994:      3: from scalper.risk import calc_risk_amount, calc_position_size
 11995:      4: 
 11996:      5: 
 11997:      6: def test_calc_risk_amount_basic():
 11998:      7:     assert calc_risk_amount(1000, 0.01) == 10.0
 11999:      8: 
 12000:      9: 
 12001:     10: def test_calc_position_size_basic():
 12002:     11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
 12003:     12:     assert calc_position_size(1000, 0.01, 50) == 0.2
 12004:     13: 
 12005:     14: 
 12006:     15: @pytest.mark.parametrize("equity,risk_pct", [
 12007:     16:     (0, 0.01),
 12008:     17:     (-100, 0.01),
 12009:     18:     (1000, 0),
 12010:     19:     (1000, -0.1),
 12011:     20:     (1000, 1.5),
 12012:     21: ])
 12013:     22: def test_calc_risk_amount_invalid(equity, risk_pct):
 12014:     23:     with pytest.raises(ValueError):
 12015:     24:         calc_risk_amount(equity, risk_pct)
 12016:     25: 
 12017:     26: 
 12018:     27: @pytest.mark.parametrize("stop_distance", [0, -1])
 12019:     28: def test_calc_position_size_invalid_stop(stop_distance):
 12020:     29:     with pytest.raises(ValueError):
 12021:     30:         calc_position_size(1000, 0.01, stop_distance)
 12022: 
 12023: 
 12024: ## tests/test_signal_risk.py (last modified: 2025-08-23 20:57:14)
 12025:      1: import types
 12026:      2: import os
 12027:      3: import sys
 12028:      4: 
 12029:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12030:      6: sys.modules['requests'] = types.ModuleType('requests')
 12031:      7: 
 12032:      8: from bot import (
 12033:      9:     map_score_to_sig_level,
 12034:     10:     compute_risk_params,
 12035:     11:     prepare_order,
 12036:     12:     Signal,
 12037:     13:     CONFIG,
 12038:     14: )
 12039:     15: 
 12040:     16: 
 12041:     17: class DummyRisk:
 12042:     18:     def __init__(self, pct: float) -> None:
 12043:     19:         self.risk_pct = pct
 12044:     20: 
 12045:     21: 
 12046:     22: def _contract_detail():
 12047:     23:     return {
 12048:     24:         "data": [
 12049:     25:             {
 12050:     26:                 "symbol": "BTC_USDT",
 12051:     27:                 "contractSize": 0.001,
 12052:     28:                 "volUnit": 1,
 12053:     29:                 "minVol": 1,
 12054:     30:                 "minTradeUSDT": 5,
 12055:     31:             }
 12056:     32:         ]
 12057:     33:     }
 12058:     34: 
 12059:     35: 
 12060:     36: def test_score_to_level_mapping():
 12061:     37:     assert map_score_to_sig_level(10) == 1
 12062:     38:     assert map_score_to_sig_level(35) == 2
 12063:     39:     assert map_score_to_sig_level(69.9) == 2
 12064:     40:     assert map_score_to_sig_level(70) == 3
 12065:     41: 
 12066:     42: 
 12067:     43: def test_risk_tables():
 12068:     44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
 12069:     45:     assert rp == 0.01 * 1.25
 12070:     46:     assert lev == int(20 * 0.75)
 12071:     47:     assert cap == 0.55
 12072:     48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
 12073:     49:     assert rp2 == 0.01 * 1.0
 12074:     50:     assert lev2 == int(20 * 0.5)
 12075:     51:     assert cap2 == 0.35
 12076:     52: 
 12077:     53: 
 12078:     54: def test_notional_cap():
 12079:     55:     rm = DummyRisk(0.05)
 12080:     56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 12081:     57:     available = 1000
 12082:     58:     params = prepare_order(
 12083:     59:         sig,
 12084:     60:         _contract_detail(),
 12085:     61:         equity_usdt=available,
 12086:     62:         available_usdt=available,
 12087:     63:         base_leverage=10,
 12088:     64:         risk_mgr=rm,
 12089:     65:         user_risk_level=2,
 12090:     66:     )
 12091:     67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6
 12092: 
 12093: 
 12094: ## tests/test_slippage.py (last modified: 2025-08-23 20:57:14)
 12095:      1: from scalper.trade_utils import marketable_limit_price
 12096:      2: 
 12097:      3: 
 12098:      4: def test_marketable_limit_price_buy_sell():
 12099:      5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
 12100:      6:     assert price_buy == 10.0 * 1.001
 12101:      7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
 12102:      8:     assert price_sell == 9.9 * (1 - 0.001)
 12103: 
 12104: 
 12105: ## tests/test_strategy_v2.py (last modified: 2025-08-23 20:57:14)
 12106:      1: import pytest
 12107:      2: 
 12108:      3: from scalp import strategy
 12109:      4: from scalper.trade_utils import trailing_stop, should_scale_in, timeout_exit
 12110:      5: 
 12111:      6: 
 12112:      7: def make_ohlcv(n=60, start=100, step=1):
 12113:      8:     closes = [start + i * step for i in range(n)]
 12114:      9:     highs = [c + 1 for c in closes]
 12115:     10:     lows = [c - 1 for c in closes]
 12116:     11:     vols = [1 for _ in closes]
 12117:     12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
 12118:     13: 
 12119:     14: 
 12120:     15: def test_generate_signal_atr_adaptation(monkeypatch):
 12121:     16:     base = make_ohlcv(step=2)
 12122:     17:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12123:     18:     ohlcv_1h = make_ohlcv(step=2)
 12124:     19: 
 12125:     20:     # patches for deterministic RSI values
 12126:     21:     rsi_vals = iter([60, 41, 39])
 12127:     22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12128:     23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12129:     24:     # low ATR -> signal disabled
 12130:     25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
 12131:     26:     sig = strategy.generate_signal(
 12132:     27:         "AAA",
 12133:     28:         base,
 12134:     29:         equity=1_000,
 12135:     30:         risk_pct=0.01,
 12136:     31:         ohlcv_15m=ohlcv_15,
 12137:     32:         ohlcv_1h=ohlcv_1h,
 12138:     33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12139:     34:         tick_ratio_buy=0.6,
 12140:     35:     )
 12141:     36:     assert sig is None
 12142:     37: 
 12143:     38:     # high ATR -> size reduced
 12144:     39:     rsi_vals = iter([60, 41, 39])
 12145:     40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12146:     41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
 12147:     42:     sig = strategy.generate_signal(
 12148:     43:         "AAA",
 12149:     44:         base,
 12150:     45:         equity=1_000,
 12151:     46:         risk_pct=0.01,
 12152:     47:         ohlcv_15m=ohlcv_15,
 12153:     48:         ohlcv_1h=ohlcv_1h,
 12154:     49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12155:     50:         tick_ratio_buy=0.6,
 12156:     51:     )
 12157:     52:     assert sig and sig.side == "long"
 12158:     53:     assert sig.qty == 50
 12159:     54: 
 12160:     55: 
 12161:     56: def test_generate_signal_short_with_filters(monkeypatch):
 12162:     57:     base = make_ohlcv(start=200, step=-2)
 12163:     58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
 12164:     59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
 12165:     60: 
 12166:     61:     rsi_vals = iter([40, 59, 61])
 12167:     62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12168:     63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12169:     64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12170:     65: 
 12171:     66:     sig = strategy.generate_signal(
 12172:     67:         "AAA",
 12173:     68:         base,
 12174:     69:         equity=1_000,
 12175:     70:         risk_pct=0.01,
 12176:     71:         ohlcv_15m=ohlcv_15,
 12177:     72:         ohlcv_1h=ohlcv_1h,
 12178:     73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
 12179:     74:         tick_ratio_buy=0.4,
 12180:     75:     )
 12181:     76:     assert sig and sig.side == "short"
 12182:     77:     assert sig.qty == 100
 12183:     78: 
 12184:     79: 
 12185:     80: def test_trailing_and_timeout():
 12186:     81:     # trailing stop
 12187:     82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
 12188:     83:     assert sl == pytest.approx(102.5)
 12189:     84:     # scaling
 12190:     85:     assert should_scale_in(100, 105, 100, 10, "long") is True
 12191:     86:     assert should_scale_in(100, 95, 100, 10, "short") is True
 12192:     87:     # timeout
 12193:     88:     # before the progress window no exit should be triggered
 12194:     89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 12195:     90:     # after ``progress_min`` minutes without favourable movement we close
 12196:     91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 12197:     92: 
 12198:     93: 
 12199:     94: def test_generate_signal_macd_filter(monkeypatch):
 12200:     95:     base = make_ohlcv(step=2)
 12201:     96:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12202:     97:     ohlcv_1h = make_ohlcv(step=2)
 12203:     98: 
 12204:     99:     rsi_vals = iter([60, 41, 39])
 12205:    100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12206:    101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12207:    102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12208:    103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
 12209:    104: 
 12210:    105:     sig = strategy.generate_signal(
 12211:    106:         "AAA",
 12212:    107:         base,
 12213:    108:         equity=1_000,
 12214:    109:         risk_pct=0.01,
 12215:    110:         ohlcv_15m=ohlcv_15,
 12216:    111:         ohlcv_1h=ohlcv_1h,
 12217:    112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12218:    113:         tick_ratio_buy=0.6,
 12219:    114:     )
 12220:    115:     assert sig is None
 12221:    116: 
 12222:    117: 
 12223:    118: 
 12224:    119: def test_generate_signal_trend_ema_filter(monkeypatch):
 12225:    120:     base = make_ohlcv(step=2)
 12226:    121:     ohlcv_15 = make_ohlcv(n=15, step=2)
 12227:    122:     ohlcv_1h = make_ohlcv(step=2)
 12228:    123: 
 12229:    124:     rsi_vals = iter([60, 41, 39])
 12230:    125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 12231:    126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 12232:    127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 12233:    128: 
 12234:    129:     orig_ema = strategy.ema
 12235:    130: 
 12236:    131:     def fake_ema(series, window):
 12237:    132:         if window == 200:
 12238:    133:             return [x + 1000 for x in orig_ema(series, window)]
 12239:    134:         return orig_ema(series, window)
 12240:    135: 
 12241:    136:     monkeypatch.setattr(strategy, "ema", fake_ema)
 12242:    137: 
 12243:    138:     sig = strategy.generate_signal(
 12244:    139:         "AAA",
 12245:    140:         base,
 12246:    141:         equity=1_000,
 12247:    142:         risk_pct=0.01,
 12248:    143:         ohlcv_15m=ohlcv_15,
 12249:    144:         ohlcv_1h=ohlcv_1h,
 12250:    145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 12251:    146:         tick_ratio_buy=0.6,
 12252:    147:         trend_ema_period=200,
 12253:    148:     )
 12254:    149:     assert sig is None
 12255:    150:     
 12256: 
 12257: ## tests/test_telegram_bot.py (last modified: 2025-08-23 20:57:14)
 12258:      1: from scalper.telegram_bot import TelegramBot
 12259:      2: 
 12260:      3: 
 12261:      4: class DummyClient:
 12262:      5: 
 12263:      6:     def __init__(self):
 12264:      7:         self.closed = []
 12265:      8:         self.closed_all = False
 12266:      9: 
 12267:     10: 
 12268:     11:     def get_assets(self):
 12269:     12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
 12270:     13: 
 12271:     14:     def get_positions(self):
 12272:     15:         return {
 12273:     16:             "data": [
 12274:     17:                 {
 12275:     18:                     "symbol": "BTC_USDT",
 12276:     19:                     "side": "long",
 12277:     20:                     "vol": 2,
 12278:     21:                     "pnl_usd": 1.0,
 12279:     22:                     "pnl_pct": 5.0,
 12280:     23:                 }
 12281:     24:             ]
 12282:     25:         }
 12283:     26: 
 12284:     27:     def close_position(self, sym):
 12285:     28:         self.closed.append(sym)
 12286:     29: 
 12287:     30:     def close_all_positions(self):
 12288:     31:         self.closed_all = True
 12289:     32: 
 12290:     33: 
 12291:     34: 
 12292:     35: class DummyRiskMgr:
 12293:     36: 
 12294:     37:     def __init__(self):
 12295:     38:         self.reset_called = False
 12296:     39:         self.max_positions = 1
 12297:     40:         self.risk_pct = 0.01
 12298:     41: 
 12299:     42:     def reset_day(self):
 12300:     43:         self.reset_called = True
 12301:     44: 
 12302:     45: 
 12303:     46: class DummyRequests:
 12304:     47:     def __init__(self):
 12305:     48:         self.posts = []
 12306:     49: 
 12307:     50:     def post(self, url, json=None, timeout=5):
 12308:     51:         self.posts.append((url, json))
 12309:     52: 
 12310:     53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
 12311:     54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
 12312:     55: 
 12313:     56: 
 12314:     57: def make_bot(config=None, requests_module=None):
 12315:     58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
 12316:     59:     if config:
 12317:     60:         cfg.update(config)
 12318:     61:     if requests_module is None:
 12319:     62:         requests_module = DummyRequests()
 12320:     63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
 12321:     64: 
 12322:     65: 
 12323:     66: def test_handle_balance():
 12324:     67:     bot = make_bot()
 12325:     68: 
 12326:     69:     resp, kb = bot.handle_callback("balance", 0.0)
 12327:     70:     assert "123.45" in resp
 12328:     71:     assert kb == bot.main_keyboard
 12329:     72: 
 12330:     73: 
 12331:     74: 
 12332:     75: def test_handle_positions():
 12333:     76:     bot = make_bot()
 12334:     77:     resp, _ = bot.handle_callback("positions", 0.0)
 12335:     78:     assert "BTC" in resp
 12336:     79:     assert "PnL" in resp
 12337:     80: 
 12338:     81: 
 12339:     82: def test_handle_positions_zero_pnl():
 12340:     83:     bot = make_bot()
 12341:     84: 
 12342:     85:     def zero_positions():
 12343:     86:         return {
 12344:     87:             "data": [
 12345:     88:                 {
 12346:     89:                     "symbol": "BTC_USDT",
 12347:     90:                     "side": "long",
 12348:     91:                     "vol": 1,
 12349:     92:                     "pnl_usd": 0.0,
 12350:     93:                     "pnl_pct": 0.0,
 12351:     94:                 }
 12352:     95:             ]
 12353:     96:         }
 12354:     97: 
 12355:     98:     bot.client.get_positions = zero_positions
 12356:     99:     resp, _ = bot.handle_callback("positions", 0.0)
 12357:    100:     assert "PnL: 0.00 USDT" in resp
 12358:    101: 
 12359:    102: 
 12360:    103: 
 12361:    104: def test_handle_pnl():
 12362:    105:     bot = make_bot()
 12363:    106:     resp, _ = bot.handle_callback("pnl", 5.0)
 12364:    107: 
 12365:    108:     assert "5.00" in resp
 12366:    109: 
 12367:    110: 
 12368:    111: def test_handle_risk_change():
 12369:    112:     bot = make_bot()
 12370:    113: 
 12371:    114:     resp, kb = bot.handle_callback("risk_red", 0.0)
 12372:    115:     assert "3" in resp
 12373:    116:     assert bot.config["RISK_LEVEL"] == 3
 12374:    117:     assert kb == bot.main_keyboard
 12375:    118: 
 12376:    119: 
 12377:    120: def test_risk_menu():
 12378:    121:     bot = make_bot()
 12379:    122:     resp, kb = bot.handle_callback("risk", 0.0)
 12380:    123:     assert "risque" in resp.lower()
 12381:    124:     assert kb == bot.risk_keyboard
 12382:    125: 
 12383:    126: 
 12384:    127: 
 12385:    128: def test_stop_menu_and_actions():
 12386:    129:     bot = make_bot()
 12387:    130:     resp, kb = bot.handle_callback("stop", 0.0)
 12388:    131:     assert any(
 12389:    132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
 12390:    133:     )
 12391:    134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
 12392:    135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
 12393:    136:     assert "fermée" in resp.lower()
 12394:    137:     assert bot.client.closed == ["BTC_USDT"]
 12395:    138:     resp, _ = bot.handle_callback("stop_all", 0.0)
 12396:    139:     assert bot.client.closed_all is True
 12397:    140: 
 12398:    141: 
 12399:    142: def test_handle_unknown():
 12400:    143:     bot = make_bot()
 12401:    144:     resp, kb = bot.handle_callback("foobar", 0.0)
 12402:    145:     assert resp is None
 12403:    146:     assert kb is None
 12404:    147: 
 12405:    148: 
 12406:    149: def test_reset_all():
 12407:    150:     bot = make_bot()
 12408:    151:     resp, kb = bot.handle_callback("reset_all", 0.0)
 12409:    152:     assert "réinitialisés" in resp.lower()
 12410:    153:     assert bot.risk_mgr.reset_called is True
 12411:    154:     assert bot.client.closed_all is True
 12412:    155:     assert kb == bot.settings_keyboard
 12413:    156: 
 12414:    157: 
 12415:    158: def test_shutdown_bot():
 12416:    159:     bot = make_bot()
 12417:    160:     resp, kb = bot.handle_callback("shutdown", 0.0)
 12418:    161:     assert "arrêt" in resp.lower()
 12419:    162:     assert bot.stop_requested is True
 12420:    163:     assert kb == bot.main_keyboard
 12421:    164: 
 12422:    165: 
 12423:    166: def test_start_sends_menu():
 12424:    167:     req = DummyRequests()
 12425:    168:     make_bot(requests_module=req)
 12426:    169:     assert req.posts
 12427:    170:     text = req.posts[0][1]["text"]
 12428:    171:     assert "Solde" in text and "PnL session" in text
 12429:    172:     assert "Positions max" in text
 12430:    173:     assert "Risque actuel" in text
 12431:    174: 
 12432:    175: 
 12433:    176: def test_settings_menu_and_reset_risk():
 12434:    177:     bot = make_bot()
 12435:    178:     resp, kb = bot.handle_callback("settings", 0.0)
 12436:    179:     assert "réglages" in resp.lower()
 12437:    180:     assert kb == bot.settings_keyboard
 12438:    181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
 12439:    182:     assert "risque" in resp.lower()
 12440:    183:     assert bot.risk_mgr.reset_called is True
 12441:    184:     assert kb == bot.settings_keyboard
 12442:    185: 
 12443:    186: 
 12444:    187: def test_update_button(monkeypatch):
 12445:    188:     bot = make_bot()
 12446:    189:     called = {}
 12447:    190: 
 12448:    191:     def fake_update():
 12449:    192:         called["called"] = True
 12450:    193: 
 12451:    194:     bot.update_pairs = fake_update
 12452:    195:     resp, kb = bot.handle_callback("update", 0.0)
 12453:    196:     assert called["called"] is True
 12454:    197:     assert "mise à jour" in resp.lower()
 12455:    198:     assert kb == bot.main_keyboard
 12456:    199: 
 12457:    200: 
 12458:    201: def test_maxpos_menu_and_change():
 12459:    202:     bot = make_bot()
 12460:    203:     resp, kb = bot.handle_callback("maxpos", 0.0)
 12461:    204:     assert "nombre" in resp.lower()
 12462:    205:     assert kb == bot.maxpos_keyboard
 12463:    206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
 12464:    207:     assert "3" in resp
 12465:    208:     assert bot.config["MAX_POSITIONS"] == 3
 12466:    209:     assert bot.risk_mgr.max_positions == 3
 12467:    210:     assert kb == bot.main_keyboard
 12468:    211: 
 12469:    212: 
 12470:    213: def test_stop_no_positions():
 12471:    214:     bot = make_bot()
 12472:    215:     bot.client.get_positions = lambda: {"data": []}
 12473:    216:     resp, kb = bot.handle_callback("stop", 0.0)
 12474:    217:     assert "aucune crypto" in resp.lower()
 12475:    218:     assert kb == bot.settings_keyboard
 12476:    219: 
 12477: 
 12478: 
 12479: ## tests/test_utils.py (last modified: 2025-08-23 20:57:14)
 12480:      1: import pytest
 12481:      2: from bot import ema, cross, compute_position_size, CONFIG
 12482:      3: from scalper.trade_utils import extract_available_balance
 12483:      4: 
 12484:      5: 
 12485:      6: def test_ema_basic():
 12486:      7:     data = [1, 2, 3, 4, 5]
 12487:      8:     result = ema(data, 3)
 12488:      9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
 12489:     10: 
 12490:     11: 
 12491:     12: def test_cross_up_down_none():
 12492:     13:     assert cross(3, 2, 1, 2) == 1  # up cross
 12493:     14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
 12494:     15:     assert cross(2, 2, 2, 2) == 0  # no cross
 12495:     16: 
 12496:     17: 
 12497:     18: def test_compute_position_size():
 12498:     19:     detail = {
 12499:     20:         "data": [
 12500:     21:             {
 12501:     22:                 "symbol": CONFIG["SYMBOL"],
 12502:     23:                 "contractSize": 0.001,
 12503:     24:                 "volUnit": 1,
 12504:     25:                 "minVol": 1,
 12505:     26:             }
 12506:     27:         ]
 12507:     28:     }
 12508:     29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
 12509:     30:                                 risk_pct=0.01, leverage=5)
 12510:     31:     assert vol == 1
 12511:     32: 
 12512:     33: 
 12513:     34: def test_compute_position_size_missing_symbol():
 12514:     35:     with pytest.raises(ValueError):
 12515:     36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
 12516:     37: 
 12517:     38: 
 12518:     39: def test_extract_available_balance_fallback():
 12519:     40:     assets = {
 12520:     41:         "data": [
 12521:     42:             {
 12522:     43:                 "currency": "USDT",
 12523:     44:                 "available": 0,
 12524:     45:                 "cashBalance": "150.5",
 12525:     46:                 "equity": "200",
 12526:     47:             }
 12527:     48:         ]
 12528:     49:     }
 12529:     50:     assert extract_available_balance(assets) == 150.5
 12530:     51: 
 12531:     52: 
 12532:     53: def test_extract_available_balance_equity_only():
 12533:     54:     assets = {
 12534:     55:         "data": [
 12535:     56:             {
 12536:     57:                 "currency": "USDT",
 12537:     58:                 "equity": "42",
 12538:     59:             }
 12539:     60:         ]
 12540:     61:     }
 12541:     62:     assert extract_available_balance(assets) == 42.0
 12542:     63: 
 12543:     64: 
 12544:     65: def test_extract_available_balance_zero_available_returns_zero():
 12545:     66:     assets = {
 12546:     67:         "data": [
 12547:     68:             {
 12548:     69:                 "currency": "USDT",
 12549:     70:                 "available": 0,
 12550:     71:                 "availableBalance": 0,
 12551:     72:                 "equity": "42",
 12552:     73:             }
 12553:     74:         ]
 12554:     75:     }
 12555:     76:     assert extract_available_balance(assets) == 0.0
 12556: 
 12557: 
 12558: ## tests/test_version.py (last modified: 2025-08-23 20:57:14)
 12559:      1: import pytest
 12560:      2: from scalp import version
 12561:      3: 
 12562:      4: 
 12563:      5: def test_get_version(monkeypatch, tmp_path):
 12564:      6:     vfile = tmp_path / "VERSION"
 12565:      7:     vfile.write_text("1.2.3")
 12566:      8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12567:      9:     assert version.get_version() == "1.2.3"
 12568:     10: 
 12569:     11: 
 12570:     12: def test_bump_version(monkeypatch, tmp_path):
 12571:     13:     vfile = tmp_path / "VERSION"
 12572:     14: 
 12573:     15:     vfile.write_text("0.1.2\n")
 12574:     16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12575:     17:     assert version.bump_version("minor") == "0.2.0"
 12576:     18:     assert vfile.read_text().strip() == "0.2.0"
 12577:     19: 
 12578:     20: 
 12579:     21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
 12580:     22:     vfile = tmp_path / "VERSION"
 12581:     23:     vfile.write_text("0.1.0\n")
 12582:     24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12583:     25:     with pytest.raises(ValueError):
 12584:     26:         version.bump_version("foo")
 12585:     27: 
 12586:     28: 
 12587:     29: def test_bump_from_message(monkeypatch, tmp_path):
 12588:     30:     vfile = tmp_path / "VERSION"
 12589:     31:     vfile.write_text("1.0.0\n")
 12590:     32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 12591:     33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
 12592:     34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
 12593:     35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
 12594:     36: 
 12595: 
 12596: 
 12597: ## tests/test_walk_forward.py (last modified: 2025-08-23 20:57:14)
 12598:      1: from scalper.backtest import walk_forward_windows
 12599:      2: 
 12600:      3: 
 12601:      4: def test_walk_forward_windows():
 12602:      5:     data = list(range(10))
 12603:      6:     windows = list(walk_forward_windows(data, train=4, test=2))
 12604:      7:     assert windows == [
 12605:      8:         ([0, 1, 2, 3], [4, 5]),
 12606:      9:         ([2, 3, 4, 5], [6, 7]),
 12607:     10:         ([4, 5, 6, 7], [8, 9]),
 12608:     11:     ]
 12609: 
 12610: 
 12611: ## tests/test_ws.py (last modified: 2025-08-23 20:57:14)
 12612:      1: import asyncio
 12613:      2: 
 12614:      3: from scalper.ws import WebsocketManager
 12615:      4: 
 12616:      5: 
 12617:      6: def test_websocket_manager_stop():
 12618:      7:     async def connect():
 12619:      8:         return None
 12620:      9: 
 12621:     10:     async def subscribe():
 12622:     11:         return None
 12623:     12: 
 12624:     13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
 12625:     14: 
 12626:     15:     async def run_and_stop():
 12627:     16:         await ws.run()
 12628:     17:         assert ws._heartbeat_task is not None
 12629:     18:         await ws.stop()
 12630:     19:         assert ws._heartbeat_task is None
 12631:     20: 
 12632:     21:     asyncio.run(run_and_stop())
 12633: 
 12634: 
 12635: ## tg_diag.py (last modified: 2025-08-23 20:57:14)
 12636:      1: # tg_diag.py
 12637:      2: import asyncio, os, aiohttp
 12638:      3: 
 12639:      4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
 12640:      5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
 12641:      6: 
 12642:      7: async def main():
 12643:      8:     if not TOKEN or not CHAT:
 12644:      9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
 12645:     10:         return
 12646:     11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
 12647:     12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
 12648:     13:     try:
 12649:     14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
 12650:     15:             async with s.post(url, json=payload) as r:
 12651:     16:                 body = await r.text()
 12652:     17:                 print("HTTP:", r.status)
 12653:     18:                 print("Body:", body[:500])
 12654:     19:     except Exception as e:
 12655:     20:         print("❌ Exception:", repr(e))
 12656:     21: 
 12657:     22: if __name__ == "__main__":
 12658:     23:     asyncio.run(main())
 12659: 

--------------------------------------------------------------------------------
FILE: dumps/DUMP_20250824-112618.txt  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # DUMP 20250824-112618
     2: Repo: /notebooks/scalp
     3: 
     4: ================================================================================
     5: ARBORESCENCE
     6: ================================================================================
     7: .gitignore
     8: CHANGELOG.md
     9: Makefile
    10: PROMPT.md
    11: README.md
    12: STRATEGY.md
    13: bot.py
    14: cli.py
    15: data/
    16: data/BTCUSDT-1m.csv
    17: data/__init__.py
    18: dump.txt
    19: dumps/
    20: dumps/DUMP_20250824-112618.txt
    21: init.py
    22: pytest.ini
    23: requirements-dev.txt
    24: requirements.txt
    25: resultat.log
    26: scalper/
    27: scalper/VERSION
    28: scalper/__init__.py
    29: scalper/adapters/
    30: scalper/adapters/__init__.py
    31: scalper/adapters/bitget.py
    32: scalper/adapters/bitget_fetch.py
    33: scalper/adapters/market_data.py
    34: scalper/backtest/
    35: scalper/backtest/__init__.py
    36: scalper/backtest/cache.py
    37: scalper/backtest/cli.py
    38: scalper/backtest/engine.py
    39: scalper/backtest/grid_search.py
    40: scalper/backtest/loader_csv.py
    41: scalper/backtest/market_data.py
    42: scalper/backtest/metrics.py
    43: scalper/backtest/optimize.py
    44: scalper/backtest/position_sizing.py
    45: scalper/backtest/run_multi.py
    46: scalper/backtest/runner.py
    47: scalper/backtest/walkforward.py
    48: scalper/bitget_client.py
    49: scalper/client.py
    50: scalper/config/
    51: scalper/config/__init__.py
    52: scalper/config/loader.py
    53: scalper/config/strategies.yml
    54: scalper/core/
    55: scalper/core/indicators.py
    56: scalper/core/signal.py
    57: scalper/exchange/
    58: scalper/exchange/__init__.py
    59: scalper/exchange/bitget.py
    60: scalper/exchange/bitget_ccxt.py
    61: scalper/exchange/fees.py
    62: scalper/hooks/
    63: scalper/hooks/prewarm_cache.py
    64: scalper/live/
    65: scalper/live/__init__.py
    66: scalper/live/backtest_telegram.py
    67: scalper/live/commands.py
    68: scalper/live/data_utils.py
    69: scalper/live/fetcher.py
    70: scalper/live/journal.py
    71: scalper/live/logs.py
    72: scalper/live/loops/
    73: scalper/live/loops/trade.py
    74: scalper/live/notify.py
    75: scalper/live/ohlcv_service.py
    76: scalper/live/orchestrator.py
    77: scalper/live/orders.py
    78: scalper/live/position_fsm.py
    79: scalper/live/runner.py
    80: scalper/live/setup_wizard.py
    81: scalper/live/state_store.py
    82: scalper/live/telegram_async.py
    83: scalper/live/watchlist.py
    84: scalper/logging_utils.py
    85: scalper/metrics.py
    86: scalper/pairs.py
    87: scalper/positions/
    88: scalper/positions/__init__.py
    89: scalper/positions/state.py
    90: scalper/risk/
    91: scalper/risk/__init__.py
    92: scalper/risk/manager.py
    93: scalper/selection/
    94: scalper/selection/__init__.py
    95: scalper/selection/momentum.py
    96: scalper/selection/scanner.py
    97: scalper/selfcheck.py
    98: scalper/services/
    99: scalper/services/__init__.py
   100: scalper/services/data_cache.py
   101: scalper/services/order_service.py
   102: scalper/services/utils.py
   103: scalper/signals/
   104: scalper/signals/__init__.py
   105: scalper/signals/current.py
   106: scalper/signals/factory.py
   107: scalper/signals/generator.py
   108: scalper/strategy/
   109: scalper/strategy/factory.py
   110: scalper/strategy.py
   111: scalper/trade_utils.py
   112: scalper/version.py
   113: scalper/ws.py
   114: sitecustomize.py
   115: tests/
   116: tests/conftest.py
   117: tests/test_analyse_risque.py
   118: tests/test_backtest.py
   119: tests/test_backtest_multi.py
   120: tests/test_backtest_position.py
   121: tests/test_bitget_futures_pairs.py
   122: tests/test_bot_place_order_caps.py
   123: tests/test_bot_update.py
   124: tests/test_break_even_stop.py
   125: tests/test_calc_pnl_pct.py
   126: tests/test_check_config.py
   127: tests/test_cli.py
   128: tests/test_client.py
   129: tests/test_compute_position_size.py
   130: tests/test_compute_position_size_cap.py
   131: tests/test_dynamic_allocation.py
   132: tests/test_effective_leverage.py
   133: tests/test_env_loading.py
   134: tests/test_grid_search.py
   135: tests/test_heat_score.py
   136: tests/test_indicators.py
   137: tests/test_min_qty_rules.py
   138: tests/test_notifier.py
   139: tests/test_notional_and_pnl_units.py
   140: tests/test_pair_selection.py
   141: tests/test_pairs.py
   142: tests/test_risk_manager.py
   143: tests/test_risk_utils.py
   144: tests/test_signal_risk.py
   145: tests/test_slippage.py
   146: tests/test_strategy_v2.py
   147: tests/test_telegram_bot.py
   148: tests/test_utils.py
   149: tests/test_version.py
   150: tests/test_walk_forward.py
   151: tests/test_ws.py
   152: tg_diag.py
   153: tools/
   154: tools/dump-repo.py
   155: tools/trashify.py
   156: 
   157: ================================================================================
   158: FICHIERS COMPLETS
   159: ================================================================================
   160: 
   161: --------------------------------------------------------------------------------
   162: FILE: .gitignore
   163: --------------------------------------------------------------------------------
   164: __pycache__/
   165: *.pyc
   166: .pytest_cache/
   167: logs/
   168: 
   169: 
   170: --------------------------------------------------------------------------------
   171: FILE: CHANGELOG.md
   172: --------------------------------------------------------------------------------
   173: # Changelog
   174: 
   175: ## Unreleased
   176: 
   177: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
   178:   signal levels.
   179: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
   180:   user risk level.
   181: - Notional and margin caps with available balance check to avoid Bitget error
   182:   `40762`.
   183: - Risk notifications with green/yellow/red indicators for terminal and
   184:   Telegram.
   185: 
   186: 
   187: --------------------------------------------------------------------------------
   188: FILE: Makefile
   189: --------------------------------------------------------------------------------
   190: .PHONY: test
   191: 
   192: test:
   193: 	pytest
   194: 
   195: 
   196: --------------------------------------------------------------------------------
   197: FILE: PROMPT.md
   198: --------------------------------------------------------------------------------
   199: # Prompt de re-création du bot Scalp (version spot)
   200: 
   201: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
   202: 
   203: ## Structure principale
   204: 
   205: ### bot.py
   206: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
   207: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
   208: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
   209: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
   210: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
   211: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
   212: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
   213: 
   214: ### cli.py
   215: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
   216: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
   217: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
   218: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
   219: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
   220: 
   221: ### init.py
   222: - `install_packages(*args)` : installe des paquets via `pip`.
   223: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
   224: 
   225: ## Modules `scalp`
   226: 
   227: ### bot_config.py
   228: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
   229: 
   230: ### metrics.py
   231: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
   232: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
   233: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
   234: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
   235: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
   236: 
   237: ### strategy.py
   238: - `ema(series, window)` : moyenne mobile exponentielle.
   239: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
   240: - `obv(closes, volumes)` : série On Balance Volume.
   241: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
   242: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
   243: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
   244: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
   245: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
   246: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
   247: 
   248: ### trade_utils.py
   249: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
   250: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
   251: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
   252: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
   253: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
   254: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
   255: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
   256: 
   257: ### risk
   258: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
   259: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
   260: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
   261: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
   262:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
   263: 
   264: ### notifier.py
   265: - `_pair_name(symbol)` : formatte le nom d’une paire.
   266: - `_format_text(event, payload=None)` : construit un message lisible.
   267: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
   268: 
   269: ### logging_utils.py
   270: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
   271: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
   272: 
   273: ### bitget_client.py
   274: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
   275:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
   276:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
   277:   - `get_account()`, `get_open_orders(symbol=None)`.
   278:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
   279:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
   280: 
   281: ### pairs.py
   282: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
   283: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
   284: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
   285: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
   286: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
   287: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
   288: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
   289: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
   290: 
   291: ### telegram_bot.py
   292: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
   293:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
   294:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
   295:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
   296: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
   297: 
   298: ## Utilisation
   299: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
   300: 2. Exécuter `init.py` pour installer les dépendances.
   301: 3. Lancer `bot.py` pour démarrer le trading.
   302: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
   303: 
   304: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
   305: 
   306: 
   307: 
   308: --------------------------------------------------------------------------------
   309: FILE: README.md
   310: --------------------------------------------------------------------------------
   311: # Scalp
   312: 
   313: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
   314: 
   315: ## Installation
   316: 
   317: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
   318: 
   319: ```bash
   320: pip install -r requirements.txt
   321: ```
   322: 
   323: Pour développer ou exécuter les tests :
   324: 
   325: ```bash
   326: pip install -r requirements-dev.txt
   327: pytest  # ou make test
   328: ```
   329: 
   330: ## Configuration
   331: 
   332: Le bot lit sa configuration via des variables d'environnement :
   333: 
   334: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
   335: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
   336: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
   337: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
   338: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
   339: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
   340: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
   341: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
   342: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
   343: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
   344: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
   345: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
   346: 
   347: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
   348: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
   349: 
   350: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
   351: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
   352: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
   353: au démarrage et toutes les variables qu'il contient seront disponibles pour le
   354: bot.
   355: 
   356: 
   357: Exemple :
   358: 
   359: ```bash
   360: export BITGET_ACCESS_KEY="votre_cle"
   361: export BITGET_SECRET_KEY="votre_secret"
   362: export PAPER_TRADE=true
   363: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
   364: export TELEGRAM_CHAT_ID="123456789"
   365: python bot.py
   366: ```
   367: 
   368: ## Lancement
   369: 
   370: Après configuration, lancez simplement :
   371: 
   372: ```bash
   373: python bot.py
   374: ```
   375: 
   376: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
   377: 
   378: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
   379: 
   380: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
   381: 
   382: 
   383: ## Stratégie
   384: 
   385: Scalp cherche à capter de courts mouvements de tendance tout en coupant
   386: rapidement les pertes.
   387: 
   388: Principes généraux :
   389: 
   390: - sélection de paires liquides au fort momentum ;
   391: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
   392: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
   393: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
   394:   calculée selon le risque ;
   395: - limites quotidiennes pour protéger le capital.
   396: 
   397: Les règles détaillées et l’algorithme complet sont décrits dans
   398: `STRATEGY.md`.
   399: 
   400: ## Version
   401: 
   402: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
   403: le code via la variable `scalp.__version__` :
   404: 
   405: ```python
   406: from scalp import __version__
   407: print(__version__)
   408: ```
   409: 
   410: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
   411: 
   412: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
   413: `scalp.version.bump_version_from_message` permet également de déterminer
   414: automatiquement l'incrément à appliquer à partir d'un message de commit
   415: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
   416: 
   417: Exemple d'incrément basé sur un message :
   418: 
   419: ```python
   420: from scalp.version import bump_version_from_message
   421: bump_version_from_message("feat: add new strategy")
   422: ```
   423: 
   424: Exécuté en tant que script, `python -m scalp.version` lit le dernier
   425: message de commit `git` et met à jour le fichier `VERSION` en
   426: conséquence.
   427: 
   428: La même opération peut être déclenchée depuis la ligne de commande via
   429: `cli.py` :
   430: 
   431: ```bash
   432: python cli.py bump-version
   433: ```
   434: 
   435: 
   436: ## Changelog
   437: 
   438: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
   439: 
   440: ## Avertissement
   441: 
   442: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.
   443: 
   444: 
   445: --------------------------------------------------------------------------------
   446: FILE: STRATEGY.md
   447: --------------------------------------------------------------------------------
   448: # Stratégie de trading
   449: 
   450: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
   451: 
   452: ## Principes généraux
   453: 
   454: - ne traiter que des actifs liquides à fort momentum ;
   455: - suivre la tendance dominante et éviter les marchés plats ;
   456: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
   457: - dimensionner chaque position selon un pourcentage fixe du capital ;
   458: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
   459: 
   460: ## Sélection des paires
   461: 
   462: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
   463: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
   464:    - croisement entre EMA20 et EMA50 ;
   465:    - ATR élevé pour privilégier les actifs volatils.
   466: 
   467: ## Génération du signal
   468: 
   469: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
   470: 
   471: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
   472: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
   473: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
   474: - hausse d’**OBV** ou volume supérieur à la moyenne ;
   475: - cassure du dernier **swing high/low** ;
   476: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
   477: 
   478: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
   479: 
   480: ## Gestion du risque
   481: 
   482: La classe `RiskManager` applique plusieurs garde‑fous :
   483: 
   484: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
   485: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
   486: - pause forcée en cas de pertes consécutives prolongées ;
   487: - contrôle du nombre maximal de positions ouvertes.
   488: 
   489: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.
   490: 
   491: 
   492: --------------------------------------------------------------------------------
   493: FILE: bot.py
   494: --------------------------------------------------------------------------------
   495: #!/usr/bin/env python3
   496: # -*- coding: utf-8 -*-
   497: """
   498: Point d'entrée unique (scan/orchestrate).
   499: 
   500: Modes d'accès:
   501: - --exchange wrapper (défaut) : passe par TON wrapper Bitget (get_ohlcv). Le bot
   502:   ajoute automatiquement le suffixe si absent:
   503:     --market umcbl -> _UMCBL (perp USDT)  [défaut]
   504:     --market spot  -> _SPBL
   505: - --exchange ccxt : client ccxt.bitget (fetch_ohlcv), pour debug rapide.
   506: - --csv / --csv_1h : scan offline.
   507: 
   508: Exemples:
   509:   python bot.py --symbols BTCUSDT --tf 5m                     # wrapper, auto -> BTCUSDT_UMCBL
   510:   python bot.py --symbols BTCUSDT --tf 5m --market spot       # wrapper, auto -> BTCUSDT_SPBL
   511:   python bot.py --symbols BTCUSDT --tf 5m --exchange ccxt     # ccxt (transforme en BTC/USDT:USDT)
   512:   python bot.py --csv data/BTCUSDT-5m.csv --csv_1h data/BTCUSDT-1h.csv
   513: """
   514: 
   515: from __future__ import annotations
   516: import os, sys, argparse
   517: from typing import Dict, List, Any, Optional, Tuple
   518: 
   519: # ---------- .env (facultatif) ----------
   520: def _load_dotenv_if_any() -> None:
   521:     try:
   522:         from dotenv import load_dotenv  # type: ignore
   523:         here = os.getcwd()
   524:         for p in (os.path.join(here, ".env"), os.path.join(os.path.dirname(here), ".env")):
   525:             if os.path.isfile(p):
   526:                 load_dotenv(p)
   527:                 break
   528:     except Exception:
   529:         pass
   530: _load_dotenv_if_any()
   531: 
   532: # ---------- Strategies ----------
   533: def _import_strategy_factory():
   534:     from scalper.signals.factory import load_strategies_cfg, resolve_signal_fn
   535:     return load_strategies_cfg, resolve_signal_fn
   536: 
   537: # ---------- Orchestrator ----------
   538: def _import_orchestrator():
   539:     from scalper.live.orchestrator import Orchestrator
   540:     return Orchestrator
   541: 
   542: # ---------- Exchange loader ----------
   543: def _import_wrapper_class() -> Optional[Any]:
   544:     for mod_name in (
   545:         "scalper.exchange.bitget",   # ton wrapper
   546:         "scalper.exchanges.bitget",
   547:     ):
   548:         try:
   549:             mod = __import__(mod_name, fromlist=["BitgetExchange"])
   550:             cls = getattr(mod, "BitgetExchange", None)
   551:             if cls is not None:
   552:                 return cls
   553:         except Exception:
   554:             continue
   555:     return None
   556: 
   557: def _build_ccxt_bitget():
   558:     try:
   559:         import ccxt  # type: ignore
   560:     except Exception:
   561:         return None
   562:     k = os.getenv("BITGET_API_KEY","")
   563:     s = os.getenv("BITGET_API_SECRET","")
   564:     p = os.getenv("BITGET_API_PASSPHRASE","")
   565:     default_type = os.getenv("BITGET_DEFAULT_TYPE","swap")
   566:     opts = {"options": {"defaultType": default_type}}
   567:     if any([k,s,p]):
   568:         return ccxt.bitget({"apiKey": k, "secret": s, "password": p, **opts})
   569:     return ccxt.bitget(opts)
   570: 
   571: def _resolve_exchange(mode: str) -> Tuple[Optional[Any], str, str]:
   572:     """Retourne (ExchangeCtorOrClient, message, detected_mode['wrapper'|'ccxt'])."""
   573:     if mode == "wrapper":
   574:         cls = _import_wrapper_class()
   575:         if cls is None:
   576:             return None, "Wrapper Bitget introuvable (scalper.exchange.bitget).", ""
   577:         return cls, "", "wrapper"
   578:     if mode == "ccxt":
   579:         client = _build_ccxt_bitget()
   580:         if client is None:
   581:             return None, "ccxt non installé (pip install ccxt).", ""
   582:         return client, "", "ccxt"
   583:     # auto
   584:     cls = _import_wrapper_class()
   585:     if cls is not None:
   586:         return cls, "", "wrapper"
   587:     client = _build_ccxt_bitget()
   588:     if client is not None:
   589:         return client, "", "ccxt"
   590:     return None, "Aucun exchange Bitget trouvé (wrapper ou ccxt).", ""
   591: 
   592: # ---------- Helpers symboles ----------
   593: def _ensure_suffix_for_wrapper(sym: str, market: str) -> str:
   594:     """Ajoute _UMCBL/_SPBL si manquant, pour le wrapper Bitget."""
   595:     up = sym.upper()
   596:     if "_" in up:   # suffixe déjà présent (ex: BTCUSDT_UMCBL / _SPBL)
   597:         return up
   598:     if market == "spot":
   599:         return up + "_SPBL"
   600:     return up + "_UMCBL"  # défaut: perp USDT
   601: 
   602: def _to_ccxt_symbol(sym: str) -> str:
   603:     """BTCUSDT -> BTC/USDT:USDT (defaultType=swap) ; si déjà au format ccxt, renvoie tel quel."""
   604:     if "/" in sym:
   605:         return sym
   606:     base, quote = sym[:-4], sym[-4:]
   607:     default_type = os.getenv("BITGET_DEFAULT_TYPE","swap")
   608:     if default_type == "swap":
   609:         return f"{base}/{quote}:{quote}"
   610:     return f"{base}/{quote}"
   611: 
   612: # ---------- Utils OHLCV offline ----------
   613: def _read_csv(path: str) -> Dict[str, List[float]]:
   614:     import csv
   615:     cols = ("timestamp","open","high","low","close","volume")
   616:     out = {k: [] for k in cols}
   617:     with open(path, "r", newline="", encoding="utf-8") as f:
   618:         r = csv.DictReader(f)
   619:         for row in r:
   620:             for k in cols:
   621:                 out[k].append(float(row[k]))
   622:     return out
   623: 
   624: def _ohlcv_to_dict(rows: List[List[float]]) -> Dict[str, List[float]]:
   625:     cols = ("timestamp","open","high","low","close","volume")
   626:     out = {k: [] for k in cols}
   627:     for r in rows:
   628:         if len(r) < 6:
   629:             raise ValueError("Ligne OHLCV invalide (6 colonnes attendues).")
   630:         out["timestamp"].append(float(r[0])); out["open"].append(float(r[1]))
   631:         out["high"].append(float(r[2])); out["low"].append(float(r[3]))
   632:         out["close"].append(float(r[4])); out["volume"].append(float(r[5]))
   633:     return out
   634: 
   635: # ---------- Modes ----------
   636: def mode_scan(
   637:     *, symbols: List[str], timeframe: str, cfg_path: str,
   638:     csv: Optional[str], csv_1h: Optional[str],
   639:     equity: float, risk: float, exchange_mode: str, market: str
   640: ) -> None:
   641:     load_strategies_cfg, resolve_signal_fn = _import_strategy_factory()
   642:     cfg = load_strategies_cfg(cfg_path)
   643: 
   644:     data_by_symbol: Dict[str, Dict[str, List[float]]] = {}
   645:     data_1h_by_symbol: Dict[str, Dict[str, List[float]]] = {}
   646: 
   647:     if csv:
   648:         data = _read_csv(csv)
   649:         for s in symbols:
   650:             data_by_symbol[s] = data
   651:         if csv_1h:
   652:             d1h = _read_csv(csv_1h)
   653:             for s in symbols:
   654:                 data_1h_by_symbol[s] = d1h
   655:     else:
   656:         ExCtorOrClient, msg, detected = _resolve_exchange(exchange_mode)
   657:         if ExCtorOrClient is None:
   658:             print(msg); return
   659: 
   660:         if detected == "wrapper":
   661:             client = ExCtorOrClient(
   662:                 api_key=os.getenv("BITGET_API_KEY",""),
   663:                 api_secret=os.getenv("BITGET_API_SECRET",""),
   664:                 api_passphrase=os.getenv("BITGET_API_PASSPHRASE",""),
   665:             )
   666:             fetch = getattr(client, "get_ohlcv")
   667:             for s in symbols:
   668:                 s_eff = _ensure_suffix_for_wrapper(s, market)  # << auto-suffix
   669:                 rows = fetch(symbol=s_eff, timeframe=timeframe, limit=1500)
   670:                 data_by_symbol[s] = _ohlcv_to_dict(rows)
   671:                 try:
   672:                     s_eff_1h = _ensure_suffix_for_wrapper(s, market)
   673:                     rows_1h = fetch(symbol=s_eff_1h, timeframe="1h", limit=1500)
   674:                     data_1h_by_symbol[s] = _ohlcv_to_dict(rows_1h)
   675:                 except Exception:
   676:                     pass
   677:         else:
   678:             client = ExCtorOrClient  # ccxt
   679:             for s in symbols:
   680:                 s_eff = _to_ccxt_symbol(s)
   681:                 rows = client.fetch_ohlcv(s_eff, timeframe=timeframe, limit=1500)
   682:                 data_by_symbol[s] = _ohlcv_to_dict(rows)
   683:                 try:
   684:                     rows_1h = client.fetch_ohlcv(s_eff, timeframe="1h", limit=1500)
   685:                     data_1h_by_symbol[s] = _ohlcv_to_dict(rows_1h)
   686:                 except Exception:
   687:                     pass
   688: 
   689:     for s in symbols:
   690:         fn = resolve_signal_fn(s, timeframe, cfg)
   691:         ohlcv = data_by_symbol.get(s)
   692:         print(f"\n=== {s} / {timeframe} ===")
   693:         if not ohlcv:
   694:             print("Pas de données OHLCV."); continue
   695:         sig = fn(symbol=s, timeframe=timeframe, ohlcv=ohlcv,
   696:                  equity=equity, risk_pct=risk, ohlcv_1h=data_1h_by_symbol.get(s))
   697:         if sig is None:
   698:             print("Aucun signal.")
   699:         else:
   700:             d = sig.as_dict()
   701:             print(f"Signal: side={d['side']} entry={d['entry']:.6f} sl={d['sl']:.6f} "
   702:                   f"tp1={d['tp1']:.6f} tp2={d['tp2']:.6f} score={d['score']} "
   703:                   f"quality={d['quality']:.2f}")
   704:             print("Reasons:", d.get("reasons",""))
   705: 
   706: def mode_orchestrate(
   707:     *, symbols: List[str], timeframe: str, cfg_path: str,
   708:     interval_sec: int, equity: float, risk: float, exchange_mode: str, market: str
   709: ) -> None:
   710:     Orchestrator = _import_orchestrator()
   711:     load_strategies_cfg, _ = _import_strategy_factory()
   712:     cfg = load_strategies_cfg(cfg_path)
   713: 
   714:     ExCtorOrClient, msg, detected = _resolve_exchange(exchange_mode)
   715:     if ExCtorOrClient is None:
   716:         print(msg); return
   717: 
   718:     if detected == "wrapper":
   719:         client = ExCtorOrClient(
   720:             api_key=os.getenv("BITGET_API_KEY",""),
   721:             api_secret=os.getenv("BITGET_API_SECRET",""),
   722:             api_passphrase=os.getenv("BITGET_API_PASSPHRASE",""),
   723:         )
   724:     else:
   725:         client = ExCtorOrClient  # ccxt
   726: 
   727:     jobs = [(s, timeframe) for s in symbols]
   728:     orch = Orchestrator(
   729:         exchange_client=client, strategies_cfg=cfg, jobs=jobs,
   730:         interval_sec=interval_sec, equity=equity, risk_pct=risk
   731:     )
   732:     try:
   733:         orch.loop()
   734:     except KeyboardInterrupt:
   735:         print("\nArrêt demandé (CTRL+C).")
   736: 
   737: # ---------- CLI ----------
   738: def parse_args() -> argparse.Namespace:
   739:     ap = argparse.ArgumentParser(description="Bot (scan/orchestrate)")
   740:     ap.add_argument("--symbols", default=os.getenv("DEFAULT_SYMBOLS","BTCUSDT"),
   741:                     help="Ex: BTCUSDT (suffixe auto en wrapper) ou BTC/USDT:USDT (ccxt).")
   742:     ap.add_argument("--tf", default=os.getenv("DEFAULT_TF","5m"), help="Ex: 1m, 5m, 15m, 1h")
   743:     ap.add_argument("--cfg", default="scalper/config/strategies.yml", help="Fichier stratégies (YAML/JSON)")
   744:     ap.add_argument("--equity", type=float, default=1000.0)
   745:     ap.add_argument("--risk", type=float, default=0.01)
   746:     ap.add_argument("--mode", choices=["scan","orchestrate"], default="scan")
   747:     ap.add_argument("--interval", type=int, default=60)
   748:     ap.add_argument("--exchange", choices=["auto","wrapper","ccxt"],
   749:                     default=os.getenv("EXCHANGE_MODE","wrapper"),
   750:                     help="wrapper = ton module (get_ohlcv) ; ccxt = client ccxt (fetch_ohlcv).")
   751:     ap.add_argument("--market", choices=["umcbl","spot"], default=os.getenv("BITGET_MARKET","umcbl"),
   752:                     help="Utilisé seulement en wrapper pour suffixe auto (_UMCBL/_SPBL).")
   753:     ap.add_argument("--csv", default="", help="CSV OHLCV principal (scan offline)")
   754:     ap.add_argument("--csv_1h", default="", help="CSV 1h (scan offline)")
   755:     return ap.parse_args()
   756: 
   757: def main():
   758:     args = parse_args()
   759:     symbols = [s.strip() for s in (args.symbols or "").split(",") if s.strip()]
   760:     if not symbols:
   761:         print("Aucun symbole fourni (utilise --symbols ou DEFAULT_SYMBOLS).")
   762:         return
   763: 
   764:     if args.mode == "scan":
   765:         mode_scan(
   766:             symbols=symbols, timeframe=args.tf, cfg_path=args.cfg,
   767:             csv=(args.csv or None), csv_1h=(args.csv_1h or None),
   768:             equity=args.equity, risk=args.risk,
   769:             exchange_mode=args.exchange, market=args.market
   770:         )
   771:     else:
   772:         mode_orchestrate(
   773:             symbols=symbols, timeframe=args.tf, cfg_path=args.cfg,
   774:             interval_sec=args.interval, equity=args.equity, risk=args.risk,
   775:             exchange_mode=args.exchange, market=args.market
   776:         )
   777: 
   778: if __name__ == "__main__":
   779:     main()
   780: 
   781: --------------------------------------------------------------------------------
   782: FILE: cli.py
   783: --------------------------------------------------------------------------------
   784: """Command line utilities for the Scalp project.
   785: 
   786: This module exposes a small command line interface used throughout the
   787: project.  The actual trading logic lives in other modules, however the CLI is
   788: responsible for parsing parameters and dispatching the appropriate routines.
   789: 
   790: The implementation intentionally keeps the invoked functions minimal so that
   791: tests can patch them easily.  In a real deployment these functions would
   792: perform optimisation, walk‑forward analysis or run the live pipeline.
   793: """
   794: 
   795: from __future__ import annotations
   796: 
   797: import argparse
   798: import asyncio
   799: from typing import Iterable, List
   800: 
   801: from scalper.version import bump_version_from_git
   802: 
   803: 
   804: # ---------------------------------------------------------------------------
   805: # Placeholder implementations
   806: # ---------------------------------------------------------------------------
   807: 
   808: 
   809: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
   810:     """Run a parallel parameter optimisation.
   811: 
   812:     The real project dispatches a potentially heavy optimisation routine.  The
   813:     function is kept trivial so unit tests can verify that the CLI wiring works
   814:     without actually performing the optimisation.
   815:     """
   816: 
   817:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
   818: 
   819: 
   820: def run_walkforward_analysis(
   821:     pair: str, timeframe: str, splits: int, train_ratio: float
   822: ) -> None:
   823:     """Execute a walk-forward analysis."""
   824: 
   825:     print(
   826:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
   827:     )
   828: 
   829: 
   830: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
   831:     """Run the live trading pipeline."""
   832: 
   833:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
   834: 
   835: 
   836: # ---------------------------------------------------------------------------
   837: # Argument parsing
   838: # ---------------------------------------------------------------------------
   839: 
   840: 
   841: def create_parser() -> argparse.ArgumentParser:
   842:     """Create the top-level argument parser."""
   843: 
   844:     parser = argparse.ArgumentParser(description="Scalp command line tools")
   845:     sub = parser.add_subparsers(dest="command")
   846: 
   847:     # --- ``opt`` command -------------------------------------------------
   848:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
   849:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
   850:     opt_p.add_argument("--tf", required=True, help="timeframe")
   851:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
   852:     opt_p.set_defaults(
   853:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
   854:     )
   855: 
   856:     # --- ``walkforward`` command ----------------------------------------
   857:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
   858:     wf_p.add_argument("--pair", required=True, help="trading pair")
   859:     wf_p.add_argument("--tf", required=True, help="timeframe")
   860:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
   861:     wf_p.add_argument(
   862:         "--train-ratio",
   863:         type=float,
   864:         default=0.7,
   865:         help="portion of data used for training",
   866:     )
   867:     wf_p.set_defaults(
   868:         func=lambda a: run_walkforward_analysis(
   869:             a.pair, a.tf, a.splits, a.train_ratio
   870:         )
   871:     )
   872: 
   873:     # --- ``live`` command -----------------------------------------------
   874:     live_p = sub.add_parser("live", help="run the live async pipeline")
   875:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
   876:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
   877:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
   878: 
   879:     # --- ``bump-version`` command -------------------------------------
   880:     bv_p = sub.add_parser(
   881:         "bump-version",
   882:         help="update the VERSION file based on the latest git commit",
   883:     )
   884:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
   885: 
   886:     return parser
   887: 
   888: 
   889: def main(argv: Iterable[str] | None = None) -> int:
   890:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
   891: 
   892:     parser = create_parser()
   893:     args = parser.parse_args(argv)
   894:     if not hasattr(args, "func"):
   895:         parser.print_help()
   896:         return 0
   897:     result = args.func(args)
   898:     return 0 if result is None else int(result)
   899: 
   900: 
   901: if __name__ == "__main__":  # pragma: no cover - manual invocation
   902:     raise SystemExit(main())
   903: 
   904: 
   905: 
   906: --------------------------------------------------------------------------------
   907: FILE: data/BTCUSDT-1m.csv
   908: --------------------------------------------------------------------------------
   909: ts,open,high,low,close,volume
   910: 1625097600000,34000,34100,33950,34050,123.4
   911: 1625097660000,34050,34200,34000,34150,150.7
   912: 1625097720000,34150,34300,34100,34250,180.3
   913: 1625097780000,34250,34400,34200,34350,200.1
   914: 1625097840000,34350,34500,34300,34450,220.8
   915: 
   916: --------------------------------------------------------------------------------
   917: FILE: data/__init__.py
   918: --------------------------------------------------------------------------------
   919: """Indicator computation helpers."""
   920: 
   921: from .indicators import compute_all
   922: 
   923: __all__ = ["compute_all"]
   924: 
   925: 
   926: --------------------------------------------------------------------------------
   927: FILE: dump.txt
   928: --------------------------------------------------------------------------------
   929: Dump created: 2025-08-24 03:12:35
   930: Repository tree:
   931: Scalp/
   932:     CHANGELOG.md
   933:     Makefile
   934:     PROMPT.md
   935:     README.md
   936:     STRATEGY.md
   937:     bot.py
   938:     cli.py
   939:     init.py
   940:     pytest.ini
   941:     requirements-dev.txt
   942:     requirements.txt
   943:     sitecustomize.py
   944:     tg_diag.py
   945:     scalper/
   946:         VERSION
   947:         __init__.py
   948:         bitget_client.py
   949:         client.py
   950:         logging_utils.py
   951:         metrics.py
   952:         pairs.py
   953:         selfcheck.py
   954:         strategy.py
   955:         trade_utils.py
   956:         version.py
   957:         ws.py
   958:         positions/
   959:             __init__.py
   960:             state.py
   961:         risk/
   962:             __init__.py
   963:             manager.py
   964:         hooks/
   965:             prewarm_cache.py
   966:         exchange/
   967:             __init__.py
   968:             bitget_ccxt.py
   969:             fees.py
   970:         selection/
   971:             __init__.py
   972:             momentum.py
   973:             scanner.py
   974:         config/
   975:             __init__.py
   976:             loader.py
   977:         backtest/
   978:             __init__.py
   979:             cache.py
   980:             cli.py
   981:             engine.py
   982:             grid_search.py
   983:             loader_csv.py
   984:             market_data.py
   985:             metrics.py
   986:             optimize.py
   987:             run_multi.py
   988:             runner.py
   989:             walkforward.py
   990:         services/
   991:             __init__.py
   992:             data_cache.py
   993:             order_service.py
   994:             utils.py
   995:         signals/
   996:             __init__.py
   997:             current.py
   998:             factory.py
   999:             generator.py
  1000:         adapters/
  1001:             __init__.py
  1002:             bitget.py
  1003:             bitget_fetch.py
  1004:             market_data.py
  1005:         live/
  1006:             __init__.py
  1007:             backtest_telegram.py
  1008:             commands.py
  1009:             journal.py
  1010:             logs.py
  1011:             notify.py
  1012:             ohlcv_service.py
  1013:             orchestrator.py
  1014:             orders.py
  1015:             position_fsm.py
  1016:             setup_wizard.py
  1017:             state_store.py
  1018:             telegram_async.py
  1019:             watchlist.py
  1020:             loops/
  1021:                 trade.py
  1022:     TRASH_20250823-124533/
  1023:         bitget_futures_pairs.py
  1024:         dashboard.py
  1025:         dump_repo.py
  1026:         quick_order.py
  1027:         rr.py
  1028:         run_backtest.py
  1029:         short_one_way.py
  1030:         notebooks/
  1031:             spot/
  1032:                 bitget_bot.py
  1033:         scalper/
  1034:             bot_config.py
  1035:             legacy_config.py
  1036:             notifier.py
  1037:             telegram_bot.py
  1038:         result/
  1039:     data/
  1040:         BTCUSDT-1m.csv
  1041:         __init__.py
  1042:         indicators.py
  1043:     tests/
  1044:         conftest.py
  1045:         test_analyse_risque.py
  1046:         test_backtest.py
  1047:         test_backtest_multi.py
  1048:         test_backtest_position.py
  1049:         test_bitget_futures_pairs.py
  1050:         test_bot_place_order_caps.py
  1051:         test_bot_update.py
  1052:         test_break_even_stop.py
  1053:         test_calc_pnl_pct.py
  1054:         test_check_config.py
  1055:         test_cli.py
  1056:         test_client.py
  1057:         test_compute_position_size.py
  1058:         test_compute_position_size_cap.py
  1059:         test_dynamic_allocation.py
  1060:         test_effective_leverage.py
  1061:         test_env_loading.py
  1062:         test_grid_search.py
  1063:         test_heat_score.py
  1064:         test_indicators.py
  1065:         test_min_qty_rules.py
  1066:         test_notifier.py
  1067:         test_notional_and_pnl_units.py
  1068:         test_pair_selection.py
  1069:         test_pairs.py
  1070:         test_risk_manager.py
  1071:         test_risk_utils.py
  1072:         test_signal_risk.py
  1073:         test_slippage.py
  1074:         test_strategy_v2.py
  1075:         test_telegram_bot.py
  1076:         test_utils.py
  1077:         test_version.py
  1078:         test_walk_forward.py
  1079:         test_ws.py
  1080: 
  1081: ## CHANGELOG.md (last modified: 2025-08-23 20:57:14)
  1082:      1: # Changelog
  1083:      2: 
  1084:      3: ## Unreleased
  1085:      4: 
  1086:      5: - Trigger trade entries via `strategy.generate_signal` with weighted scoring and
  1087:      6:   signal levels.
  1088:      7: - Dynamic risk management adapting `risk_pct` and leverage based on signal and
  1089:      8:   user risk level.
  1090:      9: - Notional and margin caps with available balance check to avoid Bitget error
  1091:     10:   `40762`.
  1092:     11: - Risk notifications with green/yellow/red indicators for terminal and
  1093:     12:   Telegram.
  1094: 
  1095: 
  1096: ## Makefile (last modified: 2025-08-23 20:57:14)
  1097:      1: .PHONY: test
  1098:      2: 
  1099:      3: test:
  1100:      4: 	pytest
  1101: 
  1102: 
  1103: ## PROMPT.md (last modified: 2025-08-23 20:57:14)
  1104:      1: # Prompt de re-création du bot Scalp (version spot)
  1105:      2: 
  1106:      3: Ce fichier résume les modules et fonctions essentiels afin de recréer le bot de trading **spot** Bitget (paires USDT) à partir de zéro. Chaque fonction liste son rôle principal et les paramètres indispensables. Le fichier `.env` contenant les clés API se trouve dans le dossier parent du bot.
  1107:      4: 
  1108:      5: ## Structure principale
  1109:      6: 
  1110:      7: ### bot.py
  1111:      8: - `_noop_event(*args, **kwargs)` : fonction vide pour le logging d'événements.
  1112:      9: - `check_config()` : vérifie la présence des clés API Bitget et journalise un avertissement si elles manquent.
  1113:     10: - `BitgetSpotClient` : sous-classe du client spot Bitget qui injecte `requests` et la fonction `log_event`.
  1114:     11: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None)` : applique la stratégie EMA sur une liste de paires et renvoie les signaux.
  1115:     12: - `send_selected_pairs(client, top_n=40, tg_bot=None)` : sélectionne et notifie les paires les plus actives.
  1116:     13: - `update(client, top_n=40, tg_bot=None)` : rafraîchit la liste des paires et renvoie la charge utile envoyée.
  1117:     14: - `main(argv=None)` : initialise la configuration, le client, le `RiskManager`, le bot Telegram et exécute la boucle de trading.
  1118:     15: 
  1119:     16: ### cli.py
  1120:     17: - `run_parallel_optimization(pairs, timeframe, jobs)` : lance une optimisation paramétrique (exemple minimal).
  1121:     18: - `run_walkforward_analysis(pair, timeframe, splits, train_ratio)` : exécute une analyse walk-forward.
  1122:     19: - `run_live_pipeline(pairs, tfs)` : exécute la pipeline live asynchrone.
  1123:     20: - `create_parser()` : construit l’analyseur d’arguments avec les sous-commandes `opt`, `walkforward`, `live` et `bump-version`.
  1124:     21: - `main(argv=None)` : point d'entrée qui déclenche la commande choisie.
  1125:     22: 
  1126:     23: ### init.py
  1127:     24: - `install_packages(*args)` : installe des paquets via `pip`.
  1128:     25: - `main()` : installe tous les fichiers `requirements*.txt` et `pytest`.
  1129:     26: 
  1130:     27: ## Modules `scalp`
  1131:     28: 
  1132:     29: ### bot_config.py
  1133:     30: - `CONFIG` : dictionnaire global des paramètres (clés API, symbole, EMA, ATR, risques, etc.).
  1134:     31: 
  1135:     32: ### metrics.py
  1136:     33: - `calc_pnl_pct(entry_price, exit_price, side, fee_rate=0)` : pourcentage de PnL net des frais.
  1137:     34: - `calc_rsi(prices, period=14)` : calcul du RSI (Wilder).
  1138:     35: - `calc_atr(highs, lows, closes, period=14)` : ATR avec lissage de Wilder.
  1139:     36: - `calc_macd(prices, fast=12, slow=26, signal=9)` : renvoie MACD, ligne signal et histogramme.
  1140:     37: - `backtest_position(prices, entry_idx, exit_idx, side)` : valide qu’une position est cohérente avec le mouvement des prix.
  1141:     38: 
  1142:     39: ### strategy.py
  1143:     40: - `ema(series, window)` : moyenne mobile exponentielle.
  1144:     41: - `vwap(highs, lows, closes, volumes)` : prix moyen pondéré par le volume.
  1145:     42: - `obv(closes, volumes)` : série On Balance Volume.
  1146:     43: - `cross(last_fast, last_slow, prev_fast, prev_slow)` : détecte les croisements EMA.
  1147:     44: - `order_book_imbalance(bid_vol, ask_vol)` : mesure le déséquilibre du carnet d'ordres.
  1148:     45: - `swing_levels(highs, lows, lookback)` : renvoie le dernier plus haut et plus bas.
  1149:     46: - `Signal` : dataclass contenant `symbol`, `side`, `price`, `sl`, `tp1`, `tp2`, `qty`.
  1150:     47: - `generate_signal(symbol, ohlcv, equity, risk_pct, ...)` : produit un `Signal` si toutes les conditions de stratégie sont réunies.
  1151:     48: - `scan_pairs` et `select_active_pairs` sont re-exportés pour la sélection des paires.
  1152:     49: 
  1153:     50: ### trade_utils.py
  1154:     51: - `compute_position_size(equity_usdt, price, risk_pct, symbol=None)` : calcule la quantité à acheter/vendre en fonction du risque et du prix.
  1155:     52: - `analyse_risque(open_positions, equity_usdt, price, risk_pct, symbol=None, side="long", risk_level=2)` : renvoie la taille de position conseillée selon l’exposition actuelle (sans effet de levier).
  1156:     53: - `trailing_stop(side, current_price, atr, sl, mult=0.75)` : met à jour le stop loss en fonction de l'ATR.
  1157:     54: - `break_even_stop(side, entry_price, current_price, atr, sl, mult=1.0)` : déplace le stop loss à break-even après un mouvement favorable.
  1158:     55: - `should_scale_in(entry_price, current_price, last_entry, atr, side, distance_mult=0.5)` : indique si la position doit être renforcée.
  1159:     56: - `timeout_exit(entry_time, now, entry_price, current_price, side, progress_min=15, timeout_min=30)` : ferme une position si aucune progression n’est constatée.
  1160:     57: - `marketable_limit_price(side, best_bid, best_ask, slippage=0.001)` : calcule un prix limite pour une exécution quasi immédiate.
  1161:     58: 
  1162:     59: ### risk
  1163:     60: - `calc_risk_amount(equity, risk_pct)` : montant d'argent risqué sur un trade.
  1164:     61: - `calc_position_size(equity, risk_pct, stop_distance)` : taille de position selon le stop.
  1165:     62: - `adjust_risk_pct(risk_pct, win_streak, loss_streak, increase=0.12, decrease=0.25, min_pct=0.001, max_pct=0.05)` : ajuste le pourcentage de risque selon les séries de gains/pertes.
  1166:     63: - `RiskManager` : classe gérant limites journalières, kill switch et ajustement de risque.
  1167:     64:   - `reset_day()`, `register_trade(pnl_pct)`/`record_trade`, `dynamic_risk_pct(signal_quality, score)`, `apply_trailing(direction, price, sl, atr, params)`, `pause_duration()`, `can_open(current_positions)`.
  1168:     65: 
  1169:     66: ### notifier.py
  1170:     67: - `_pair_name(symbol)` : formatte le nom d’une paire.
  1171:     68: - `_format_text(event, payload=None)` : construit un message lisible.
  1172:     69: - `notify(event, payload=None)` : envoie des notifications via webhook HTTP et/ou Telegram.
  1173:     70: 
  1174:     71: ### logging_utils.py
  1175:     72: - `get_jsonl_logger(path, max_bytes=0, backup_count=0)` : renvoie une fonction de logging JSONL avec rotation optionnelle.
  1176:     73: - `TradeLogger(csv_path, sqlite_path)` : enregistre chaque trade dans un CSV et une base SQLite (`log(data)`).
  1177:     74: 
  1178:     75: ### bitget_client.py
  1179:     76: - `BitgetSpotClient(access_key, secret_key, base_url, recv_window=30, paper_trade=True, requests_module=requests, log_event=None)` : client REST léger pour le marché spot.
  1180:     77:   - `get_symbol_info(symbol=None)`, `get_kline(symbol, interval="1m", start=None, end=None)`, `get_ticker(symbol=None)`.
  1181:     78:   - `_private_request(method, path, params=None, body=None)` : signe et exécute les requêtes privées.
  1182:     79:   - `get_account()`, `get_open_orders(symbol=None)`.
  1183:     80:   - `place_order(symbol, side, quantity, order_type, price=None, stop_loss=None, take_profit=None)`.
  1184:     81:   - `cancel_order(symbol, order_id)`, `cancel_all(symbol)`.
  1185:     82: 
  1186:     83: ### pairs.py
  1187:     84: - `get_trade_pairs(client)` : récupère toutes les paires via `get_ticker`.
  1188:     85: - `filter_trade_pairs(client, volume_min=5_000_000, max_spread_bps=5, top_n=40)` : filtre par volume/spread.
  1189:     86: - `select_top_pairs(client, top_n=40, key="volume")` : trie par volume ou autre clé.
  1190:     87: - `find_trade_positions(client, pairs, interval="1m", ema_fast_n=None, ema_slow_n=None, ema_func=ema, cross_func=cross)` : signaux EMA croisement.
  1191:     88: - `send_selected_pairs(client, top_n=40, select_fn=select_top_pairs, notify_fn=notify)` : déduplique USD/USDT/USDC et notifie la liste.
  1192:     89: - `heat_score(volatility, volume, news=False)` : score combinant volatilite et volume.
  1193:     90: - `select_top_heat_pairs(pairs, top_n=3)` : sélection des paires les plus "chaudes".
  1194:     91: - `decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)` : choisit des paires peu corrélées.
  1195:     92: 
  1196:     93: ### telegram_bot.py
  1197:     94: - `TelegramBot(token, chat_id, client, config, risk_mgr, requests_module=requests)` : mini bot Telegram.
  1198:     95:   - `send_main_menu(session_pnl)`, `update_pairs()`, `send(text, keyboard=None)`, `answer_callback(cb_id)`,
  1199:     96:   - `fetch_updates()`, `handle_updates(session_pnl)`, `handle_callback(data, session_pnl)`.
  1200:     97:   - Helpers privés `_base_symbol`, `_build_stop_keyboard`, `_menu_text`.
  1201:     98: - `init_telegram_bot(client, config, risk_mgr)` : instancie un `TelegramBot` si les variables d’environnement `TELEGRAM_BOT_TOKEN` et `TELEGRAM_CHAT_ID` sont définies.
  1202:     99: 
  1203:    100: ## Utilisation
  1204:    101: 1. Définir les variables d’environnement (clés Bitget, token Telegram, etc.).
  1205:    102: 2. Exécuter `init.py` pour installer les dépendances.
  1206:    103: 3. Lancer `bot.py` pour démarrer le trading.
  1207:    104: 4. Utiliser `cli.py` pour les outils d’optimisation ou de tests.
  1208:    105: 
  1209:    106: Ce résumé fournit les éléments nécessaires à la reconstruction du bot et à la compréhension de chaque fonction essentielle.
  1210:    107: 
  1211: 
  1212: 
  1213: ## README.md (last modified: 2025-08-23 20:57:14)
  1214:      1: # Scalp
  1215:      2: 
  1216:      3: Bot de trading pour les futures USDT-M de Bitget. Ce projet est **expérimental** et fourni à des fins éducatives.
  1217:      4: 
  1218:      5: ## Installation
  1219:      6: 
  1220:      7: Assurez-vous d'avoir Python 3.8 ou supérieur puis installez les dépendances :
  1221:      8: 
  1222:      9: ```bash
  1223:     10: pip install -r requirements.txt
  1224:     11: ```
  1225:     12: 
  1226:     13: Pour développer ou exécuter les tests :
  1227:     14: 
  1228:     15: ```bash
  1229:     16: pip install -r requirements-dev.txt
  1230:     17: pytest  # ou make test
  1231:     18: ```
  1232:     19: 
  1233:     20: ## Configuration
  1234:     21: 
  1235:     22: Le bot lit sa configuration via des variables d'environnement :
  1236:     23: 
  1237:     24: - `BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY` : clés API Bitget (laisser les valeurs par défaut pour rester en mode papier).
  1238:     25: - `PAPER_TRADE` (`true`/`false`) : par défaut `true`, n'envoie aucun ordre réel.
  1239:     26: - `SYMBOL` : symbole du contrat futures (par défaut, `BTCUSDT`).
  1240:     27: - `INTERVAL` : intervalle des chandeliers, ex. `1m`, `5m`.
  1241:     28: - `EMA_FAST`, `EMA_SLOW` : périodes des EMA utilisées par la stratégie.
  1242:     29: - `MACD_FAST`, `MACD_SLOW`, `MACD_SIGNAL` : paramètres du filtre de tendance MACD.
  1243:     30: - `EMA_TREND_PERIOD` : période de l'EMA longue utilisée comme filtre de tendance général.
  1244:     31: - `RISK_PCT_EQUITY`, `LEVERAGE`, `STOP_LOSS_PCT`, `TAKE_PROFIT_PCT` : paramètres de gestion du risque.
  1245:     32: - `ATR_PERIOD`, `TRAIL_ATR_MULT`, `SCALE_IN_ATR_MULT`, `PROGRESS_MIN`, `TIMEOUT_MIN` : réglages pour l'ATR, l'ajout à la position, le trailing stop et la sortie par timeout.
  1246:     33: - `MAX_DAILY_LOSS_PCT`, `MAX_DAILY_PROFIT_PCT`, `MAX_POSITIONS` (par défaut 3) : limites globales (kill switch après perte ou gain, nombre maximal de positions).
  1247:     34: - `LOG_DIR` : dossier où seront écrits les fichiers de log.
  1248:     35: - `ALLOWED_SYMBOLS` : liste de paires autorisées séparées par des virgules. Vide par défaut pour autoriser toutes les paires.
  1249:     36: 
  1250:     37: - `NOTIFY_URL` : URL d'un webhook HTTP pour recevoir les événements (optionnel, peut être utilisé en plus de Telegram).
  1251:     38: - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID` : pour envoyer les notifications sur Telegram (optionnel, peut être combiné avec le webhook).
  1252:     39: 
  1253:     40: Pour éviter de versionner vos clés sensibles, vous pouvez créer un fichier
  1254:     41: `.env` dans le dossier parent du dépôt (par exemple `Notebooks/.env` si le
  1255:     42: code se trouve dans `Notebooks/scalp`).  Ce fichier est automatiquement chargé
  1256:     43: au démarrage et toutes les variables qu'il contient seront disponibles pour le
  1257:     44: bot.
  1258:     45: 
  1259:     46: 
  1260:     47: Exemple :
  1261:     48: 
  1262:     49: ```bash
  1263:     50: export BITGET_ACCESS_KEY="votre_cle"
  1264:     51: export BITGET_SECRET_KEY="votre_secret"
  1265:     52: export PAPER_TRADE=true
  1266:     53: export TELEGRAM_BOT_TOKEN="123456:ABCDEF..."
  1267:     54: export TELEGRAM_CHAT_ID="123456789"
  1268:     55: python bot.py
  1269:     56: ```
  1270:     57: 
  1271:     58: ## Lancement
  1272:     59: 
  1273:     60: Après configuration, lancez simplement :
  1274:     61: 
  1275:     62: ```bash
  1276:     63: python bot.py
  1277:     64: ```
  1278:     65: 
  1279:     66: Le terminal reste silencieux au démarrage sauf en cas d'absence de variables critiques (`BITGET_ACCESS_KEY`, `BITGET_SECRET_KEY`). Les journaux sont écrits dans `logs/` et affichés sur la console. Le bot tourne jusqu'à `Ctrl+C`. Les ouvertures et fermetures de positions sont consignées dans `bot_events.jsonl`.
  1280:     67: 
  1281:     68: Lors du démarrage, deux notifications Telegram sont émises : la première affiche « Bot démarré » avec un logo, la seconde « Listing ok » sans détailler les paires sélectionnées.
  1282:     69: 
  1283:     70: Ensuite, un rappel du marché est envoyé chaque minute et l'interface Telegram propose un bouton « Fermer Bot » pour arrêter proprement l'exécution.
  1284:     71: 
  1285:     72: 
  1286:     73: ## Stratégie
  1287:     74: 
  1288:     75: Scalp cherche à capter de courts mouvements de tendance tout en coupant
  1289:     76: rapidement les pertes.
  1290:     77: 
  1291:     78: Principes généraux :
  1292:     79: 
  1293:     80: - sélection de paires liquides au fort momentum ;
  1294:     81: - trade uniquement dans le sens de la tendance dominante (MACD + EMA longue) ;
  1295:     82: - confirmation multi‑indicateurs (VWAP, volume/OBV, RSI multi‑UT) ;
  1296:     83: - stop‑loss et take‑profit dynamiques basés sur l’ATR avec taille de position
  1297:     84:   calculée selon le risque ;
  1298:     85: - limites quotidiennes pour protéger le capital.
  1299:     86: 
  1300:     87: Les règles détaillées et l’algorithme complet sont décrits dans
  1301:     88: `STRATEGY.md`.
  1302:     89: 
  1303:     90: ## Version
  1304:     91: 
  1305:     92: La version du bot est stockée dans le fichier `scalp/VERSION` et exposée dans
  1306:     93: le code via la variable `scalp.__version__` :
  1307:     94: 
  1308:     95: ```python
  1309:     96: from scalp import __version__
  1310:     97: print(__version__)
  1311:     98: ```
  1312:     99: 
  1313:    100: Pour incrémenter la version, utilisez `scalp.version.bump_version` avec
  1314:    101: 
  1315:    102: `"major"`, `"minor"` ou `"patch"` comme argument. La fonction
  1316:    103: `scalp.version.bump_version_from_message` permet également de déterminer
  1317:    104: automatiquement l'incrément à appliquer à partir d'un message de commit
  1318:    105: suivant la convention [Conventional Commits](https://www.conventionalcommits.org).
  1319:    106: 
  1320:    107: Exemple d'incrément basé sur un message :
  1321:    108: 
  1322:    109: ```python
  1323:    110: from scalp.version import bump_version_from_message
  1324:    111: bump_version_from_message("feat: add new strategy")
  1325:    112: ```
  1326:    113: 
  1327:    114: Exécuté en tant que script, `python -m scalp.version` lit le dernier
  1328:    115: message de commit `git` et met à jour le fichier `VERSION` en
  1329:    116: conséquence.
  1330:    117: 
  1331:    118: La même opération peut être déclenchée depuis la ligne de commande via
  1332:    119: `cli.py` :
  1333:    120: 
  1334:    121: ```bash
  1335:    122: python cli.py bump-version
  1336:    123: ```
  1337:    124: 
  1338:    125: 
  1339:    126: ## Changelog
  1340:    127: 
  1341:    128: - Ajout d'un contrôle de marge disponible avant chaque ordre afin d'éviter l'erreur Bitget « The order amount exceeds the balance » (code 40762).
  1342:    129: 
  1343:    130: ## Avertissement
  1344:    131: 
  1345:    132: © 2025 — Usage à vos risques. Ceci n'est pas un conseil financier.
  1346: 
  1347: 
  1348: ## STRATEGY.md (last modified: 2025-08-23 20:57:14)
  1349:      1: # Stratégie de trading
  1350:      2: 
  1351:      3: Ce document décrit la logique de trading utilisée par le bot **Scalp**. Elle vise un scalping court terme sur les futures USDT‑M de Bitget.
  1352:      4: 
  1353:      5: ## Principes généraux
  1354:      6: 
  1355:      7: - ne traiter que des actifs liquides à fort momentum ;
  1356:      8: - suivre la tendance dominante et éviter les marchés plats ;
  1357:      9: - utiliser des confirmations multi‑unités de temps pour limiter les faux signaux ;
  1358:     10: - dimensionner chaque position selon un pourcentage fixe du capital ;
  1359:     11: - couper rapidement les pertes et laisser courir les gains via un suivi dynamique.
  1360:     12: 
  1361:     13: ## Sélection des paires
  1362:     14: 
  1363:     15: 1. `scan_pairs` récupère les tickers Bitget et filtre ceux qui possèdent un volume quotidien suffisant et un spread réduit.
  1364:     16: 2. `select_active_pairs` affine la liste en conservant les paires présentant le plus de **momentum** :
  1365:     17:    - croisement entre EMA20 et EMA50 ;
  1366:     18:    - ATR élevé pour privilégier les actifs volatils.
  1367:     19: 
  1368:     20: ## Génération du signal
  1369:     21: 
  1370:     22: `generate_signal` produit un signal d’entrée long ou court lorsque les conditions suivantes sont réunies :
  1371:     23: 
  1372:     24: - prix au‑dessus ou en dessous du **VWAP** et des EMA20/50 selon la direction recherchée ;
  1373:     25: - **RSI(14)** traversant les niveaux 40/60 avec confirmation d’un **RSI 15 min** et de la pente de l’**EMA 1 h** ;
  1374:     26: - **MACD** alignée avec la tendance et **EMA** longue en filtrage global ;
  1375:     27: - hausse d’**OBV** ou volume supérieur à la moyenne ;
  1376:     28: - cassure du dernier **swing high/low** ;
  1377:     29: - éventuel filtre d’**order book imbalance** et de ratio de ticks.
  1378:     30: 
  1379:     31: Les distances de stop et de take profit sont calculées à partir de l’**ATR**, ce qui permet également de dimensionner la taille de position via `calc_position_size`.
  1380:     32: 
  1381:     33: ## Gestion du risque
  1382:     34: 
  1383:     35: La classe `RiskManager` applique plusieurs garde‑fous :
  1384:     36: 
  1385:     37: - limite de perte quotidienne (`max_daily_loss_pct`) et optionnellement de gain (`max_daily_profit_pct`) déclenchant un *kill switch* ;
  1386:     38: - suivi des séries de gains/pertes pour ajuster le pourcentage de risque par trade ;
  1387:     39: - pause forcée en cas de pertes consécutives prolongées ;
  1388:     40: - contrôle du nombre maximal de positions ouvertes.
  1389:     41: 
  1390:     42: Ces règles combinées visent à protéger le capital tout en conservant une exposition opportuniste au marché.
  1391: 
  1392: 
  1393: ## TRASH_20250823-124533/bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
  1394:      1: #!/usr/bin/env python3
  1395:      2: """Fetch the list of Bitget futures contracts.
  1396:      3: 
  1397:      4: This helper script queries the public Bitget REST API to retrieve futures
  1398:      5: trading pairs for the specified product types and saves them to CSV and JSON
  1399:      6: files. It mirrors the standalone example provided by the user but integrates
  1400:      7: with the repository's configuration system.
  1401:      8: 
  1402:      9: Usage examples::
  1403:     10: 
  1404:     11:     python bitget_futures_pairs.py
  1405:     12:     python bitget_futures_pairs.py --types USDT-FUTURES COIN-FUTURES
  1406:     13:     python bitget_futures_pairs.py --out pairs.csv --json-out pairs.json
  1407:     14: """
  1408:     15: from __future__ import annotations
  1409:     16: 
  1410:     17: import argparse
  1411:     18: import csv
  1412:     19: import json
  1413:     20: import sys
  1414:     21: import time
  1415:     22: from typing import Any, Dict, List
  1416:     23: 
  1417:     24: from scalper.bot_config import CONFIG
  1418:     25: 
  1419:     26: try:  # pragma: no cover - import guard
  1420:     27:     import requests
  1421:     28: except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
  1422:     29:     sys.stderr.write(
  1423:     30:         "This script requires the 'requests' package. Install it with:\n  pip install requests\n"
  1424:     31:     )
  1425:     32:     raise
  1426:     33: 
  1427:     34: BASE_URL = CONFIG.get("BASE_URL", "https://api.bitget.com")
  1428:     35: CONTRACTS_ENDPOINT = "/api/v2/mix/market/contracts"
  1429:     36: DEFAULT_PRODUCT_TYPES = ["USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES"]
  1430:     37: 
  1431:     38: 
  1432:     39: def fetch_contracts(product_type: str, timeout: float = 10.0) -> List[Dict[str, Any]]:
  1433:     40:     """Return contract metadata for ``product_type``."""
  1434:     41:     url = f"{BASE_URL}{CONTRACTS_ENDPOINT}"
  1435:     42:     params = {"productType": product_type}
  1436:     43:     resp = requests.get(url, params=params, timeout=timeout)
  1437:     44:     try:
  1438:     45:         data = resp.json()
  1439:     46:     except json.JSONDecodeError as exc:  # pragma: no cover - network failure
  1440:     47:         raise RuntimeError(
  1441:     48:             f"Non-JSON response from Bitget API for {product_type}: {resp.text[:200]}"
  1442:     49:         ) from exc
  1443:     50:     if resp.status_code != 200 or data.get("code") != "00000":
  1444:     51:         raise RuntimeError(f"Bitget API error for {product_type}: HTTP {resp.status_code} body={data}")
  1445:     52:     return data.get("data", [])
  1446:     53: 
  1447:     54: 
  1448:     55: def normalize_rows(product_type: str, contracts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
  1449:     56:     """Select and rename key fields for CSV/JSON output."""
  1450:     57:     rows: List[Dict[str, Any]] = []
  1451:     58:     for c in contracts:
  1452:     59:         row = {
  1453:     60:             "productType": product_type,
  1454:     61:             "symbol": c.get("symbol"),
  1455:     62:             "baseCoin": c.get("baseCoin"),
  1456:     63:             "quoteCoin": c.get("quoteCoin"),
  1457:     64:             "symbolType": c.get("symbolType"),
  1458:     65:             "symbolStatus": c.get("symbolStatus"),
  1459:     66:             "maxLever": c.get("maxLever"),
  1460:     67:             "minLever": c.get("minLever"),
  1461:     68:             "minTradeNum": c.get("minTradeNum"),
  1462:     69:             "sizeMultiplier": c.get("sizeMultiplier"),
  1463:     70:             "pricePlace": c.get("pricePlace"),
  1464:     71:             "volumePlace": c.get("volumePlace"),
  1465:     72:             "launchTime": c.get("launchTime"),
  1466:     73:             "deliveryTime": c.get("deliveryTime"),
  1467:     74:         }
  1468:     75:         rows.append(row)
  1469:     76:     return rows
  1470:     77: 
  1471:     78: 
  1472:     79: def write_csv(rows: List[Dict[str, Any]], path: str) -> None:
  1473:     80:     """Write ``rows`` to ``path`` in CSV format."""
  1474:     81:     headers = [
  1475:     82:         "productType",
  1476:     83:         "symbol",
  1477:     84:         "baseCoin",
  1478:     85:         "quoteCoin",
  1479:     86:         "symbolType",
  1480:     87:         "symbolStatus",
  1481:     88:         "maxLever",
  1482:     89:         "minLever",
  1483:     90:         "minTradeNum",
  1484:     91:         "sizeMultiplier",
  1485:     92:         "pricePlace",
  1486:     93:         "volumePlace",
  1487:     94:         "launchTime",
  1488:     95:         "deliveryTime",
  1489:     96:     ]
  1490:     97:     with open(path, "w", newline="", encoding="utf-8") as fh:
  1491:     98:         writer = csv.DictWriter(fh, fieldnames=headers)
  1492:     99:         writer.writeheader()
  1493:    100:         if rows:
  1494:    101:             writer.writerows(rows)
  1495:    102: 
  1496:    103: 
  1497:    104: def main(argv: List[str] | None = None) -> int:
  1498:    105:     parser = argparse.ArgumentParser(
  1499:    106:         description="Fetch Bitget futures pairs (contracts) and save to CSV/JSON."
  1500:    107:     )
  1501:    108:     parser.add_argument(
  1502:    109:         "--types",
  1503:    110:         nargs="+",
  1504:    111:         default=DEFAULT_PRODUCT_TYPES,
  1505:    112:         help="Product types to fetch. Choices: USDT-FUTURES, USDC-FUTURES, COIN-FUTURES",
  1506:    113:     )
  1507:    114:     parser.add_argument("--out", default="bitget_futures_pairs.csv", help="CSV output file path")
  1508:    115:     parser.add_argument(
  1509:    116:         "--json-out", default="bitget_futures_pairs.json", help="JSON output file path"
  1510:    117:     )
  1511:    118:     parser.add_argument("--sleep", type=float, default=0.2, help="Seconds to sleep between requests")
  1512:    119:     args = parser.parse_args(argv)
  1513:    120: 
  1514:    121:     all_rows: List[Dict[str, Any]] = []
  1515:    122:     merged_json: Dict[str, List[Dict[str, Any]]] = {}
  1516:    123: 
  1517:    124:     for i, pt in enumerate(args.types):
  1518:    125:         try:
  1519:    126:             contracts = fetch_contracts(pt)
  1520:    127:         except Exception as exc:  # pragma: no cover - network/runtime error
  1521:    128:             sys.stderr.write(f"[!] Failed to fetch {pt}: {exc}\n")
  1522:    129:             continue
  1523:    130:         rows = normalize_rows(pt, contracts)
  1524:    131:         all_rows.extend(rows)
  1525:    132:         merged_json[pt] = contracts
  1526:    133:         if i < len(args.types) - 1 and args.sleep > 0:
  1527:    134:             time.sleep(args.sleep)
  1528:    135: 
  1529:    136:     all_rows.sort(key=lambda r: (r.get("productType") or "", r.get("symbol") or ""))
  1530:    137: 
  1531:    138:     write_csv(all_rows, args.out)
  1532:    139:     with open(args.json_out, "w", encoding="utf-8") as fh:
  1533:    140:         json.dump(merged_json, fh, ensure_ascii=False, indent=2)
  1534:    141: 
  1535:    142:     counts = {pt: len(merged_json.get(pt, [])) for pt in args.types}
  1536:    143:     total = sum(counts.values())
  1537:    144:     print(
  1538:    145:         f"Saved {total} futures pairs across {len(args.types)} product types to '{args.out}' and '{args.json_out}'."
  1539:    146:     )
  1540:    147:     for pt, n in counts.items():
  1541:    148:         print(f"  - {pt}: {n} pairs")
  1542:    149:     return 0
  1543:    150: 
  1544:    151: 
  1545:    152: if __name__ == "__main__":  # pragma: no cover - CLI execution
  1546:    153:     raise SystemExit(main())
  1547: 
  1548: 
  1549: ## TRASH_20250823-124533/dashboard.py (last modified: 2025-08-23 20:57:14)
  1550:      1: # dashboard.py
  1551:      2: from __future__ import annotations
  1552:      3: 
  1553:      4: import os
  1554:      5: import time
  1555:      6: from pathlib import Path
  1556:      7: from typing import Dict, Tuple
  1557:      8: 
  1558:      9: import pandas as pd
  1559:     10: import streamlit as st
  1560:     11: 
  1561:     12: # ------------------------------------------------------------
  1562:     13: # Réglages
  1563:     14: # ------------------------------------------------------------
  1564:     15: LOG_DIR = Path("scalp/live/logs")  # emplacement des CSV créés par l'orchestrateur
  1565:     16: REFRESH_SECS = 5                   # auto-refresh UI
  1566:     17: MAX_ROWS_SHOW = 2000               # clamp mémoire
  1567:     18: 
  1568:     19: 
  1569:     20: # ------------------------------------------------------------
  1570:     21: # Utilitaires lecture robuste CSV
  1571:     22: # ------------------------------------------------------------
  1572:     23: def _safe_read_csv(path: Path) -> pd.DataFrame:
  1573:     24:     if not path.exists():
  1574:     25:         return pd.DataFrame()
  1575:     26:     try:
  1576:     27:         df = pd.read_csv(path)
  1577:     28:         # clamp pour éviter d’exploser en RAM si les logs deviennent énormes
  1578:     29:         if len(df) > MAX_ROWS_SHOW:
  1579:     30:             df = df.tail(MAX_ROWS_SHOW).reset_index(drop=True)
  1580:     31:         return df
  1581:     32:     except Exception:
  1582:     33:         # fichier en cours d’écriture → on réessaiera au prochain tick
  1583:     34:         return pd.DataFrame()
  1584:     35: 
  1585:     36: 
  1586:     37: def load_logs() -> Dict[str, pd.DataFrame]:
  1587:     38:     return {
  1588:     39:         "signals": _safe_read_csv(LOG_DIR / "signals.csv"),
  1589:     40:         "orders": _safe_read_csv(LOG_DIR / "orders.csv"),
  1590:     41:         "fills": _safe_read_csv(LOG_DIR / "fills.csv"),
  1591:     42:         "positions": _safe_read_csv(LOG_DIR / "positions.csv"),
  1592:     43:     }
  1593:     44: 
  1594:     45: 
  1595:     46: def _format_ts_ms_to_str(df: pd.DataFrame, col: str = "ts") -> pd.DataFrame:
  1596:     47:     if col in df.columns:
  1597:     48:         try:
  1598:     49:             df[col] = pd.to_datetime(df[col], unit="ms")
  1599:     50:         except Exception:
  1600:     51:             try:
  1601:     52:                 df[col] = pd.to_datetime(df[col])
  1602:     53:             except Exception:
  1603:     54:                 pass
  1604:     55:     return df
  1605:     56: 
  1606:     57: 
  1607:     58: # ------------------------------------------------------------
  1608:     59: # Métriques & agrégats simples
  1609:     60: # ------------------------------------------------------------
  1610:     61: def compute_activity_metrics(df_orders: pd.DataFrame, df_fills: pd.DataFrame) -> Tuple[float, float, int]:
  1611:     62:     """
  1612:     63:     Retourne: (volume notionnel approx, fees cumulés, nb fills)
  1613:     64:     - notionnel approx = somme(|price * qty|) sur les fills (indépendant du sens)
  1614:     65:     - fees = somme(fee) si dispo
  1615:     66:     """
  1616:     67:     notional = 0.0
  1617:     68:     fees = 0.0
  1618:     69:     n_fills = 0
  1619:     70: 
  1620:     71:     if not df_fills.empty:
  1621:     72:         # normalisation colonnes
  1622:     73:         price_col = next((c for c in ["price", "fillPrice", "fill_px"] if c in df_fills.columns), None)
  1623:     74:         qty_col = next((c for c in ["qty", "size", "fillQty", "fill_sz"] if c in df_fills.columns), None)
  1624:     75:         fee_col = next((c for c in ["fee", "fillFee"] if c in df_fills.columns), None)
  1625:     76: 
  1626:     77:         if price_col and qty_col:
  1627:     78:             notional = float((df_fills[price_col].abs() * df_fills[qty_col].abs()).sum())
  1628:     79:             n_fills = int(len(df_fills))
  1629:     80:         if fee_col:
  1630:     81:             fees = float(df_fills[fee_col].fillna(0).sum())
  1631:     82: 
  1632:     83:     return notional, fees, n_fills
  1633:     84: 
  1634:     85: 
  1635:     86: def last_positions_snapshot(df_positions: pd.DataFrame) -> pd.DataFrame:
  1636:     87:     """Dernier état par symbole (state/qty/entry)."""
  1637:     88:     if df_positions.empty:
  1638:     89:         return df_positions
  1639:     90:     df = df_positions.copy()
  1640:     91:     df = _format_ts_ms_to_str(df, "ts")
  1641:     92:     # on prend le dernier enregistrement par symbol
  1642:     93:     last = df.sort_values("ts").groupby("symbol", as_index=False).tail(1)
  1643:     94:     return last.sort_values("symbol").reset_index(drop=True)
  1644:     95: 
  1645:     96: 
  1646:     97: def recent_signals(df_signals: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
  1647:     98:     if df_signals.empty:
  1648:     99:         return df_signals
  1649:    100:     df = df_signals.copy()
  1650:    101:     df = _format_ts_ms_to_str(df, "ts")
  1651:    102:     df = df.sort_values("ts", ascending=False).head(limit)
  1652:    103:     return df.reset_index(drop=True)
  1653:    104: 
  1654:    105: 
  1655:    106: def recent_orders(df_orders: pd.DataFrame, limit: int = 30) -> pd.DataFrame:
  1656:    107:     if df_orders.empty:
  1657:    108:         return df_orders
  1658:    109:     df = df_orders.copy()
  1659:    110:     df = _format_ts_ms_to_str(df, "ts")
  1660:    111:     df = df.sort_values("ts", ascending=False).head(limit)
  1661:    112:     # petites colonnes utiles en premier
  1662:    113:     cols = [c for c in ["ts", "symbol", "side", "status", "price", "sl", "tp", "risk_pct", "order_id"] if c in df.columns]
  1663:    114:     other = [c for c in df.columns if c not in cols]
  1664:    115:     return df[cols + other]
  1665:    116: 
  1666:    117: 
  1667:    118: def recent_fills(df_fills: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
  1668:    119:     if df_fills.empty:
  1669:    120:         return df_fills
  1670:    121:     df = df_fills.copy()
  1671:    122:     df = _format_ts_ms_to_str(df, "ts")
  1672:    123:     df = df.sort_values("ts", ascending=False).head(limit)
  1673:    124:     cols = [c for c in ["ts", "symbol", "order_id", "trade_id", "price", "qty", "fee"] if c in df.columns]
  1674:    125:     other = [c for c in df.columns if c not in cols]
  1675:    126:     return df[cols + other]
  1676:    127: 
  1677:    128: 
  1678:    129: # ------------------------------------------------------------
  1679:    130: # UI
  1680:    131: # ------------------------------------------------------------
  1681:    132: st.set_page_config(page_title="ScalpBot Dashboard", layout="wide")
  1682:    133: st.title("📊 ScalpBot — Dashboard Live")
  1683:    134: 
  1684:    135: # auto-refresh
  1685:    136: st.caption("Auto-refresh toutes les {}s".format(REFRESH_SECS))
  1686:    137: st_autorefresh = st.experimental_rerun if False else None  # placeholder to keep code readable
  1687:    138: # Streamlit v1.32+ propose st.autorefresh :
  1688:    139: try:
  1689:    140:     st_autorefresh = st.experimental_rerun  # fallback compat
  1690:    141:     from streamlit.runtime.scriptrunner import add_script_run_ctx  # noqa: F401
  1691:    142:     st_autorefresh = None
  1692:    143: except Exception:
  1693:    144:     pass
  1694:    145: 
  1695:    146: try:
  1696:    147:     st_autorefresh = st.autorefresh(interval=REFRESH_SECS * 1000, key="autorf")
  1697:    148: except Exception:
  1698:    149:     pass
  1699:    150: 
  1700:    151: # Choix du dossier de logs (utile si on lance le dashboard depuis un autre cwd)
  1701:    152: default_dir = str(LOG_DIR.resolve())
  1702:    153: custom_dir = st.sidebar.text_input("Dossier de logs", value=default_dir)
  1703:    154: LOG_DIR = Path(custom_dir) if custom_dir else LOG_DIR
  1704:    155: 
  1705:    156: if not LOG_DIR.exists():
  1706:    157:     st.error(f"Dossier introuvable : {LOG_DIR}")
  1707:    158:     st.stop()
  1708:    159: 
  1709:    160: data = load_logs()
  1710:    161: df_sig, df_ord, df_fill, df_pos = data["signals"], data["orders"], data["fills"], data["positions"]
  1711:    162: 
  1712:    163: # KPIs rapides
  1713:    164: notional, fees, n_fills = compute_activity_metrics(df_ord, df_fill)
  1714:    165: col_a, col_b, col_c, col_d = st.columns(4)
  1715:    166: col_a.metric("Paires actives (Top 10)", "10")
  1716:    167: col_b.metric("Fills (total)", f"{n_fills}")
  1717:    168: col_c.metric("Notionnel cumulé (approx)", f"{notional:,.0f} USDT")
  1718:    169: col_d.metric("Frais cumulés", f"{fees:,.2f} USDT")
  1719:    170: 
  1720:    171: st.divider()
  1721:    172: 
  1722:    173: # 1) Positions snapshot
  1723:    174: st.subheader("📌 Positions (snapshot courant par symbole)")
  1724:    175: pos_snapshot = last_positions_snapshot(df_pos)
  1725:    176: if pos_snapshot.empty:
  1726:    177:     st.info("Aucune position pour l’instant.")
  1727:    178: else:
  1728:    179:     # Met un peu d'ordre dans les colonnes
  1729:    180:     order_cols = [c for c in ["symbol", "state", "qty", "entry", "ts"] if c in pos_snapshot.columns]
  1730:    181:     pos_snapshot = pos_snapshot[order_cols + [c for c in pos_snapshot.columns if c not in order_cols]]
  1731:    182:     st.dataframe(pos_snapshot, use_container_width=True, height=260)
  1732:    183: 
  1733:    184: # 2) Derniers signaux
  1734:    185: st.subheader("📣 Derniers signaux")
  1735:    186: sig_tbl = recent_signals(df_sig, limit=40)
  1736:    187: if sig_tbl.empty:
  1737:    188:     st.info("Pas encore de signaux.")
  1738:    189: else:
  1739:    190:     # comptage LONG/SHORT
  1740:    191:     try:
  1741:    192:         by_side = sig_tbl.assign(side_norm=sig_tbl["side"].astype(str).str.upper()).groupby("side_norm").size()
  1742:    193:         st.bar_chart(by_side)
  1743:    194:     except Exception:
  1744:    195:         pass
  1745:    196:     st.dataframe(sig_tbl, use_container_width=True, height=300)
  1746:    197: 
  1747:    198: # 3) Ordres récents
  1748:    199: st.subheader("🧾 Ordres récents")
  1749:    200: ord_tbl = recent_orders(df_ord, limit=40)
  1750:    201: if ord_tbl.empty:
  1751:    202:     st.info("Pas encore d’ordres.")
  1752:    203: else:
  1753:    204:     st.dataframe(ord_tbl, use_container_width=True, height=280)
  1754:    205: 
  1755:    206: # 4) Fills récents
  1756:    207: st.subheader("✅ Fills récents")
  1757:    208: fills_tbl = recent_fills(df_fill, limit=80)
  1758:    209: if fills_tbl.empty:
  1759:    210:     st.info("Pas encore d’exécutions (fills).")
  1760:    211: else:
  1761:    212:     st.dataframe(fills_tbl, use_container_width=True, height=320)
  1762:    213: 
  1763:    214: st.caption(f"Logs: {LOG_DIR}")
  1764: 
  1765: ## TRASH_20250823-124533/dump_repo.py (last modified: 2025-08-23 20:57:14)
  1766:      1: import os
  1767:      2: from datetime import datetime
  1768:      3: from pathlib import Path
  1769:      4: 
  1770:      5: IGNORE_EXTENSIONS = {'.log', '.pyc'}
  1771:      6: IGNORE_DIRS = {'__pycache__'}
  1772:      7: 
  1773:      8: 
  1774:      9: def _is_ignored(path: Path) -> bool:
  1775:     10:     """Return True if the path should be ignored."""
  1776:     11:     if any(part.startswith('.') for part in path.parts):
  1777:     12:         return True
  1778:     13:     if path.suffix in IGNORE_EXTENSIONS:
  1779:     14:         return True
  1780:     15:     if any(part in IGNORE_DIRS for part in path.parts):
  1781:     16:         return True
  1782:     17:     return False
  1783:     18: 
  1784:     19: 
  1785:     20: def _build_tree(root: Path, ignore_path: Path) -> str:
  1786:     21:     lines = []
  1787:     22:     for dirpath, dirnames, filenames in os.walk(root):
  1788:     23:         dirpath = Path(dirpath)
  1789:     24:         dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in IGNORE_DIRS]
  1790:     25:         depth = len(dirpath.relative_to(root).parts)
  1791:     26:         indent = '    ' * depth
  1792:     27:         lines.append(f"{indent}{dirpath.name}/")
  1793:     28:         for fname in sorted(filenames):
  1794:     29:             fpath = dirpath / fname
  1795:     30:             if fpath == ignore_path or _is_ignored(fpath):
  1796:     31:                 continue
  1797:     32:             lines.append(f"{indent}    {fname}")
  1798:     33:     return '\n'.join(lines)
  1799:     34: 
  1800:     35: 
  1801:     36: def _iter_files(root: Path):
  1802:     37:     for path in sorted(root.rglob('*')):
  1803:     38:         if path.is_file() and not _is_ignored(path):
  1804:     39:             yield path
  1805:     40: 
  1806:     41: 
  1807:     42: def create_dump_file(output_path: str = 'dump.txt', root: str = '.') -> None:
  1808:     43:     """Create a text dump of the repository tree and file contents."""
  1809:     44:     root_path = Path(root).resolve()
  1810:     45:     output_path = root_path / output_path
  1811:     46:     now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  1812:     47:     with output_path.open('w', encoding='utf-8') as dump:
  1813:     48:         dump.write(f"Dump created: {now}\n")
  1814:     49:         dump.write('Repository tree:\n')
  1815:     50:         dump.write(_build_tree(root_path, output_path))
  1816:     51:         dump.write('\n\n')
  1817:     52:         for file_path in _iter_files(root_path):
  1818:     53:             rel_path = file_path.relative_to(root_path)
  1819:     54:             if file_path == output_path:
  1820:     55:                 continue
  1821:     56:             mod_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')
  1822:     57:             dump.write(f"## {rel_path} (last modified: {mod_time})\n")
  1823:     58:             try:
  1824:     59:                 with file_path.open('r', encoding='utf-8') as f:
  1825:     60:                     for i, line in enumerate(f, 1):
  1826:     61:                         dump.write(f"{i:6}: {line}")
  1827:     62:             except Exception:
  1828:     63:                 dump.write('[unreadable file]\n')
  1829:     64:             dump.write('\n\n')
  1830:     65: 
  1831:     66: 
  1832:     67: if __name__ == '__main__':
  1833:     68:     create_dump_file()
  1834: 
  1835: 
  1836: ## TRASH_20250823-124533/notebooks/spot/bitget_bot.py (last modified: 2025-08-23 20:57:14)
  1837:      1: import os
  1838:      2: import time
  1839:      3: import hmac
  1840:      4: import hashlib
  1841:      5: import base64
  1842:      6: import logging
  1843:      7: from argparse import ArgumentParser
  1844:      8: from pathlib import Path
  1845:      9: from typing import Any, Dict, List
  1846:     10: from urllib.parse import urlencode
  1847:     11: 
  1848:     12: import requests
  1849:     13: from dotenv import load_dotenv
  1850:     14: 
  1851:     15: BASE_URL = "https://api.bitget.com"
  1852:     16: RECV_WINDOW = 5000
  1853:     17: 
  1854:     18: 
  1855:     19: def load_keys() -> Dict[str, str]:
  1856:     20:     parent = Path(__file__).resolve().parent.parent
  1857:     21:     load_dotenv(parent / ".env")
  1858:     22:     api_key = os.getenv("BITGET_API_KEY")
  1859:     23:     api_secret = os.getenv("BITGET_API_SECRET")
  1860:     24:     if not api_key or not api_secret:
  1861:     25:         raise RuntimeError("API keys not found in environment")
  1862:     26:     return {"key": api_key, "secret": api_secret}
  1863:     27: 
  1864:     28: 
  1865:     29: class BitgetClient:
  1866:     30:     def __init__(self) -> None:
  1867:     31:         creds = load_keys()
  1868:     32:         self.api_key = creds["key"]
  1869:     33:         self.api_secret = creds["secret"]
  1870:     34:         self.session = requests.Session()
  1871:     35:         self.session.headers.update({"X-BITGET-APIKEY": self.api_key})
  1872:     36:         self.time_offset = self._compute_time_offset()
  1873:     37: 
  1874:     38:     def _compute_time_offset(self) -> int:
  1875:     39:         server = self.server_time()
  1876:     40:         return int(server["serverTime"]) - int(time.time() * 1000)
  1877:     41: 
  1878:     42:     def _timestamp(self) -> int:
  1879:     43:         return int(time.time() * 1000) + self.time_offset
  1880:     44: 
  1881:     45:     def _request(
  1882:     46:         self, method: str, path: str, params: Dict[str, Any] | None = None, *, signed: bool = False
  1883:     47:     ) -> Any:
  1884:     48:         params = params or {}
  1885:     49:         if signed:
  1886:     50:             params["timestamp"] = self._timestamp()
  1887:     51:             params["recvWindow"] = RECV_WINDOW
  1888:     52:             query = urlencode(params)
  1889:     53:             signature = base64.b64encode(
  1890:     54:                 hmac.new(self.api_secret.encode(), query.encode(), hashlib.sha256).digest()
  1891:     55:             ).decode()
  1892:     56:             query += f"&signature={signature}"
  1893:     57:             headers = {"X-BITGET-APIKEY": self.api_key}
  1894:     58:             if method.upper() == "GET":
  1895:     59:                 url = f"{BASE_URL}{path}?{query}"
  1896:     60:                 resp = self.session.get(url, headers=headers)
  1897:     61:             else:
  1898:     62:                 url = f"{BASE_URL}{path}"
  1899:     63:                 headers["Content-Type"] = "application/x-www-form-urlencoded"
  1900:     64:                 resp = self.session.post(url, data=query, headers=headers)
  1901:     65:         else:
  1902:     66:             url = f"{BASE_URL}{path}"
  1903:     67:             resp = self.session.request(method, url, params=params)
  1904:     68: 
  1905:     69:         resp.raise_for_status()
  1906:     70:         if resp.text:
  1907:     71:             return resp.json()
  1908:     72:         return {}
  1909:     73: 
  1910:     74:     # Helpers
  1911:     75:     def server_time(self) -> Any:
  1912:     76:         return self._request("GET", "/api/v3/time")
  1913:     77: 
  1914:     78:     def ticker_price(self, symbol: str) -> Any:
  1915:     79:         return self._request("GET", "/api/v3/ticker/price", {"symbol": symbol})
  1916:     80: 
  1917:     81:     def klines(self, symbol: str, interval: str = "1m", limit: int = 100) -> Any:
  1918:     82:         return self._request(
  1919:     83:             "GET", "/api/v3/klines", {"symbol": symbol, "interval": interval, "limit": limit}
  1920:     84:         )
  1921:     85: 
  1922:     86:     def test_order(self, **params: Any) -> Any:
  1923:     87:         return self._request("POST", "/api/v3/order/test", params, signed=True)
  1924:     88: 
  1925:     89:     def place_order(self, **params: Any) -> Any:
  1926:     90:         return self._request("POST", "/api/v3/order", params, signed=True)
  1927:     91: 
  1928:     92:     def account_info(self) -> Any:
  1929:     93:         return self._request("GET", "/api/v3/account", signed=True)
  1930:     94: 
  1931:     95:     def book_ticker(self, symbol: str) -> Any:
  1932:     96:         return self._request("GET", "/api/v3/ticker/bookTicker", {"symbol": symbol})
  1933:     97: 
  1934:     98: 
  1935:     99: def sma(values: List[float], period: int) -> float:
  1936:    100:     if len(values) < period:
  1937:    101:         raise ValueError("Not enough data for SMA")
  1938:    102:     return sum(values[-period:]) / period
  1939:    103: 
  1940:    104: 
  1941:    105: def analyze(client: BitgetClient, symbol: str, quote_usdt: float, dry_run: bool) -> None:
  1942:    106:     kl = client.klines(symbol, limit=50)
  1943:    107:     closes = [float(k[4]) for k in kl]
  1944:    108:     sma9_prev = sma(closes[:-1], 9)
  1945:    109:     sma21_prev = sma(closes[:-1], 21)
  1946:    110:     sma9_curr = sma(closes, 9)
  1947:    111:     sma21_curr = sma(closes, 21)
  1948:    112: 
  1949:    113:     cross_up = sma9_prev <= sma21_prev and sma9_curr > sma21_curr
  1950:    114:     cross_down = sma9_prev >= sma21_prev and sma9_curr < sma21_curr
  1951:    115: 
  1952:    116:     log = logging.getLogger("bitget_bot")
  1953:    117: 
  1954:    118:     if cross_up:
  1955:    119:         book = client.book_ticker(symbol)
  1956:    120:         ask = float(book["askPrice"])
  1957:    121:         qty = quote_usdt / ask
  1958:    122:         params = {
  1959:    123:             "symbol": symbol,
  1960:    124:             "side": "BUY",
  1961:    125:             "type": "LIMIT",
  1962:    126:             "timeInForce": "IOC",
  1963:    127:             "quantity": f"{qty:.6f}",
  1964:    128:             "price": book["askPrice"],
  1965:    129:         }
  1966:    130:         log.info("BUY signal %s", params)
  1967:    131:         resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1968:    132:         log.info("response %s", resp)
  1969:    133:     elif cross_down:
  1970:    134:         account = client.account_info()
  1971:    135:         base = symbol.rstrip("USDT")
  1972:    136:         bal = next((b for b in account["balances"] if b["asset"] == base), {"free": "0"})
  1973:    137:         qty = float(bal["free"])
  1974:    138:         if qty > 0:
  1975:    139:             book = client.book_ticker(symbol)
  1976:    140:             params = {
  1977:    141:                 "symbol": symbol,
  1978:    142:                 "side": "SELL",
  1979:    143:                 "type": "LIMIT",
  1980:    144:                 "timeInForce": "IOC",
  1981:    145:                 "quantity": f"{qty:.6f}",
  1982:    146:                 "price": book["bidPrice"],
  1983:    147:             }
  1984:    148:             log.info("SELL signal %s", params)
  1985:    149:             resp = client.test_order(**params) if dry_run else client.place_order(**params)
  1986:    150:             log.info("response %s", resp)
  1987:    151:         else:
  1988:    152:             log.info("No balance to sell")
  1989:    153: 
  1990:    154: 
  1991:    155: def interval_seconds(interval: str) -> int:
  1992:    156:     unit = interval[-1]
  1993:    157:     qty = int(interval[:-1])
  1994:    158:     if unit == "m":
  1995:    159:         return qty * 60
  1996:    160:     if unit == "h":
  1997:    161:         return qty * 3600
  1998:    162:     if unit == "d":
  1999:    163:         return qty * 86400
  2000:    164:     return 60
  2001:    165: 
  2002:    166: 
  2003:    167: def main() -> None:
  2004:    168:     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
  2005:    169:     parser = ArgumentParser(description="Bitget SMA crossover bot")
  2006:    170:     parser.add_argument("--symbol", default="BTCUSDT")
  2007:    171:     parser.add_argument("--quote-usdt", type=float, default=10.0)
  2008:    172:     parser.add_argument("--interval", default="1m")
  2009:    173:     parser.add_argument("--loop", action="store_true")
  2010:    174:     parser.add_argument("--dry-run", dest="dry_run", action="store_true")
  2011:    175:     parser.add_argument("--live", dest="dry_run", action="store_false")
  2012:    176:     parser.set_defaults(dry_run=True)
  2013:    177:     args = parser.parse_args()
  2014:    178: 
  2015:    179:     client = BitgetClient()
  2016:    180:     delay = interval_seconds(args.interval)
  2017:    181: 
  2018:    182:     while True:
  2019:    183:         try:
  2020:    184:             analyze(client, args.symbol, args.quote_usdt, args.dry_run)
  2021:    185:         except Exception as exc:
  2022:    186:             logging.getLogger("bitget_bot").error("Error: %s", exc, exc_info=True)
  2023:    187:         if not args.loop:
  2024:    188:             break
  2025:    189:         time.sleep(delay)
  2026:    190: 
  2027:    191: 
  2028:    192: if __name__ == "__main__":
  2029:    193:     main()
  2030: 
  2031: 
  2032: ## TRASH_20250823-124533/quick_order.py (last modified: 2025-08-23 20:57:14)
  2033:      1: #!/usr/bin/env python3
  2034:      2: """Submit a simple market order on Bitget futures.
  2035:      3: 
  2036:      4: This helper reads API credentials and trade parameters from environment
  2037:      5: variables (optionally loaded from a `.env` file) and places a one-way
  2038:      6: market order.  Only the essential steps from the user's reference script
  2039:      7: are kept to minimise latency and redundant code.
  2040:      8: 
  2041:      9: Environment variables:
  2042:     10:     BITGET_API_KEY / BITGET_ACCESS_KEY
  2043:     11:     BITGET_API_SECRET / BITGET_SECRET_KEY
  2044:     12:     BITGET_API_PASSPHRASE
  2045:     13:     BITGET_BASE_URL (default https://api.bitget.com)
  2046:     14:     BITGET_PRODUCT_TYPE (default ``USDT-FUTURES``)
  2047:     15:     BITGET_MARGIN_COIN (default ``USDT``)
  2048:     16:     BITGET_SYMBOL (e.g. ``BTCUSDT``)
  2049:     17:     BITGET_TEST_NOTIONAL_USDT (default ``5``)
  2050:     18: 
  2051:     19: Usage:
  2052:     20:     python quick_order.py buy
  2053:     21:     python quick_order.py sell
  2054:     22: """
  2055:     23: 
  2056:     24: from __future__ import annotations
  2057:     25: 
  2058:     26: import os
  2059:     27: import sys
  2060:     28: from pathlib import Path
  2061:     29: 
  2062:     30: from dotenv import load_dotenv
  2063:     31: 
  2064:     32: from scalper.bitget_client import BitgetFuturesClient
  2065:     33: 
  2066:     34: # Load variables from `.env` if present
  2067:     35: load_dotenv(Path(__file__).resolve().parent / ".env")
  2068:     36: 
  2069:     37: side = sys.argv[1].lower() if len(sys.argv) > 1 else "buy"
  2070:     38: if side not in {"buy", "sell"}:
  2071:     39:     raise SystemExit("Usage: quick_order.py [buy|sell]")
  2072:     40: 
  2073:     41: base = os.getenv("BITGET_BASE_URL", "https://api.bitget.com")
  2074:     42: ak = os.getenv("BITGET_API_KEY") or os.getenv("BITGET_ACCESS_KEY")
  2075:     43: sk = os.getenv("BITGET_API_SECRET") or os.getenv("BITGET_SECRET_KEY")
  2076:     44: ph = os.getenv("BITGET_API_PASSPHRASE") or os.getenv("BITGET_PASSPHRASE")
  2077:     45: product_type = os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES").upper()
  2078:     46: margin_coin = os.getenv("BITGET_MARGIN_COIN", "USDT")
  2079:     47: symbol = (os.getenv("BITGET_SYMBOL", "BTCUSDT") or "BTCUSDT").replace("_", "").upper()
  2080:     48: notional = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5"))
  2081:     49: 
  2082:     50: if not (ak and sk and ph):
  2083:     51:     raise SystemExit("❌ BITGET_API_KEY/SECRET/PASSPHRASE manquants")
  2084:     52: 
  2085:     53: client = BitgetFuturesClient(
  2086:     54:     access_key=ak,
  2087:     55:     secret_key=sk,
  2088:     56:     base_url=base,
  2089:     57:     passphrase=ph,
  2090:     58:     paper_trade=False,
  2091:     59: )
  2092:     60: 
  2093:     61: tick = client.get_ticker(symbol)
  2094:     62: price = None
  2095:     63: try:
  2096:     64:     data = tick.get("data")
  2097:     65:     if isinstance(data, list) and data:
  2098:     66:         price_str = data[0].get("lastPr") or data[0].get("lastPrice")
  2099:     67:         if price_str is not None:
  2100:     68:             price = float(price_str)
  2101:     69:     elif isinstance(data, dict):
  2102:     70:         price_str = data.get("lastPr") or data.get("lastPrice")
  2103:     71:         if price_str is not None:
  2104:     72:             price = float(price_str)
  2105:     73: except Exception:
  2106:     74:     pass
  2107:     75: if price is None or price <= 0:
  2108:     76:     raise SystemExit("Prix introuvable pour le ticker")
  2109:     77: 
  2110:     78: size = round(notional / price, 6)
  2111:     79: client.set_position_mode_one_way(symbol, product_type)
  2112:     80: client.set_leverage(symbol, product_type, margin_coin, leverage=2)
  2113:     81: resp = client.place_market_order_one_way(
  2114:     82:     symbol, side, size, product_type, margin_coin
  2115:     83: )
  2116:     84: print(resp)
  2117: 
  2118: 
  2119: ## TRASH_20250823-124533/rr.py (last modified: 2025-08-23 20:57:14)
  2120:      1: #!/usr/bin/env python3
  2121:      2: from __future__ import annotations
  2122:      3: import argparse, shutil, re, os, datetime as dt
  2123:      4: from pathlib import Path
  2124:      5: 
  2125:      6: # ---------- helpers ----------
  2126:      7: def info(msg): print(f"[i] {msg}")
  2127:      8: def ok(msg):   print(f"[✓] {msg}")
  2128:      9: def warn(msg): print(f"[!] {msg}")
  2129:     10: 
  2130:     11: def backup_repo(repo: Path) -> Path:
  2131:     12:     ts = dt.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
  2132:     13:     dst = repo.parent / f".backup-refactor-{ts}"
  2133:     14:     shutil.copytree(repo, dst)
  2134:     15:     ok(f"Sauvegarde créée: {dst}")
  2135:     16:     return dst
  2136:     17: 
  2137:     18: def ensure_pkg_init(path: Path):
  2138:     19:     initp = path / "__init__.py"
  2139:     20:     if not initp.exists():
  2140:     21:         initp.write_text("# package\n", encoding="utf-8")
  2141:     22: 
  2142:     23: def move_dir(src: Path, dst: Path):
  2143:     24:     if not src.exists(): return
  2144:     25:     dst.mkdir(parents=True, exist_ok=True)
  2145:     26:     for child in src.iterdir():
  2146:     27:         shutil.move(str(child), str(dst / child.name))
  2147:     28:     # supprime le répertoire source s'il est vide
  2148:     29:     try: src.rmdir()
  2149:     30:     except Exception: pass
  2150:     31: 
  2151:     32: # règles initiales (rangement)
  2152:     33: IMPORT_RULES_STAGE1 = [
  2153:     34:     (re.compile(r"from\s+scalp\.config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  2154:     35:     (re.compile(r"from\s+config\.loader\s+import\s+load_settings"), "from scalper.config import load_settings"),
  2155:     36:     (re.compile(r"from\s+scalp\.config\s+import\s+load_settings"), "from scalper.config import load_settings"),
  2156:     37:     (re.compile(r"from\s+live(\.| import)"), r"from scalper.live\1"),
  2157:     38:     (re.compile(r"import\s+live(\s|$)"), r"import scalper.live\1"),
  2158:     39:     (re.compile(r"from\s+backtest(\.| import)"), r"from scalper.backtest\1"),
  2159:     40:     (re.compile(r"import\s+backtest(\s|$)"), r"import scalper.backtest\1"),
  2160:     41:     (re.compile(r"from\s+signals(\.| import)"), r"from scalper.signals\1"),
  2161:     42:     (re.compile(r"import\s+signals(\s|$)"), r"import scalper.signals\1"),
  2162:     43:     (re.compile(r"from\s+exchange(\.| import)"), r"from scalper.exchange\1"),
  2163:     44:     (re.compile(r"import\s+exchange(\s|$)"), r"import scalper.exchange\1"),
  2164:     45: ]
  2165:     46: 
  2166:     47: def rewrite_imports(root: Path, rules):
  2167:     48:     changed = 0
  2168:     49:     for py in root.rglob("*.py"):
  2169:     50:         if ".backup-" in str(py) or ".backup" in str(py):  # safety
  2170:     51:             continue
  2171:     52:         txt = py.read_text(encoding="utf-8")
  2172:     53:         new = txt
  2173:     54:         for pat, rep in rules:
  2174:     55:             new = pat.sub(rep, new)
  2175:     56:         if new != txt:
  2176:     57:             py.write_text(new, encoding="utf-8")
  2177:     58:             changed += 1
  2178:     59:     return changed
  2179:     60: 
  2180:     61: def ensure_config_package(scalp_pkg: Path):
  2181:     62:     """Transforme scalp/config.py en package scalp/config/loader.py et ajoute __init__.py exportant load_settings."""
  2182:     63:     flat = scalp_pkg / "config.py"
  2183:     64:     pkg = scalp_pkg / "config"
  2184:     65:     loader = pkg / "loader.py"
  2185:     66:     initp = pkg / "__init__.py"
  2186:     67: 
  2187:     68:     # si un config.py existe, le renommer pour archivage
  2188:     69:     if flat.exists():
  2189:     70:         legacy = scalp_pkg / "legacy_config.py"
  2190:     71:         if legacy.exists(): legacy.unlink()
  2191:     72:         shutil.move(str(flat), str(legacy))
  2192:     73:         info(f"renommé {flat} -> {legacy}")
  2193:     74: 
  2194:     75:     pkg.mkdir(parents=True, exist_ok=True)
  2195:     76:     ensure_pkg_init(pkg)
  2196:     77: 
  2197:     78:     # si pas de loader.py, créer un loader minimal (tu pourras le remplacer par ta version complète)
  2198:     79:     if not loader.exists():
  2199:     80:         loader.write_text(
  2200:     81:             'from __future__ import annotations\n'
  2201:     82:             'import os, json\n'
  2202:     83:             'from typing import Any, Dict, Tuple\n'
  2203:     84:             'try:\n'
  2204:     85:             '    import yaml\n'
  2205:     86:             'except Exception:\n'
  2206:     87:             '    yaml = None\n'
  2207:     88:             'try:\n'
  2208:     89:             '    from dotenv import load_dotenv\n'
  2209:     90:             'except Exception:\n'
  2210:     91:             '    load_dotenv = None\n'
  2211:     92:             '\n'
  2212:     93:             'def _read_yaml(path: str):\n'
  2213:     94:             '    if not os.path.exists(path): return {}\n'
  2214:     95:             '    with open(path, "r", encoding="utf-8") as f:\n'
  2215:     96:             '        if yaml: return yaml.safe_load(f) or {}\n'
  2216:     97:             '        return json.load(f)\n'
  2217:     98:             '\n'
  2218:     99:             'def load_settings(config_path: str="config.yml", config_local_path: str="config.local.yml"):\n'
  2219:    100:             '    if load_dotenv: load_dotenv(override=False)\n'
  2220:    101:             '    base = _read_yaml(config_path)\n'
  2221:    102:             '    local = _read_yaml(config_local_path)\n'
  2222:    103:             '    cfg = {**base, **local}\n'
  2223:    104:             '    runtime = {\n'
  2224:    105:             '        "quiet": bool(cfg.get("QUIET", 1)),\n'
  2225:    106:             '        "print_sample": bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)),\n'
  2226:    107:             '        "timeframe": str(cfg.get("TIMEFRAME", "5m")),\n'
  2227:    108:             '        "cash": float(cfg.get("CASH", 10000)),\n'
  2228:    109:             '        "risk_pct": float(cfg.get("RISK_PCT", 0.5)),\n'
  2229:    110:             '        "slippage_bps": float(cfg.get("SLIPPAGE_BPS", 2)),\n'
  2230:    111:             '        "watchlist_mode": str(cfg.get("WATCHLIST_MODE", "local")),\n'
  2231:    112:             '        "watchlist_local_conc": int(cfg.get("WATCHLIST_LOCAL_CONC", 5)),\n'
  2232:    113:             '        "top_symbols": cfg.get("TOP_SYMBOLS", []),\n'
  2233:    114:             '        "top_candidates": cfg.get("TOP_CANDIDATES", []),\n'
  2234:    115:             '        "caps": cfg.get("CAPS", {}),\n'
  2235:    116:             '        "fees_by_symbol": {},\n'
  2236:    117:             '    }\n'
  2237:    118:             '    secrets = {\n'
  2238:    119:             '        "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),\n'
  2239:    120:             '        "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),\n'
  2240:    121:             '        "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),\n'
  2241:    122:             '        "BITGET_USE_TESTNET": os.getenv("BITGET_USE_TESTNET", "1") in ("1","true","True"),\n'
  2242:    123:             '        "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),\n'
  2243:    124:             '        "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),\n'
  2244:    125:             '        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),\n'
  2245:    126:             '    }\n'
  2246:    127:             '    return runtime, secrets\n',
  2247:    128:             encoding="utf-8"
  2248:    129:         )
  2249:    130:     # __init__.py exporte load_settings
  2250:    131:     initp.write_text("from .loader import load_settings\n__all__ = ['load_settings']\n", encoding="utf-8")
  2251:    132: 
  2252:    133: def stage1_restructure(repo: Path):
  2253:    134:     """Range les modules à l’intérieur du package 'scalp/' + fix imports."""
  2254:    135:     scalp_pkg = repo / "scalp"
  2255:    136:     scalp_pkg.mkdir(exist_ok=True)
  2256:    137:     ensure_pkg_init(scalp_pkg)
  2257:    138: 
  2258:    139:     for mod in ("live", "backtest", "signals", "config", "exchange"):
  2259:    140:         src = repo / mod
  2260:    141:         if src.exists() and src.is_dir():
  2261:    142:             dst = scalp_pkg / mod
  2262:    143:             info(f"déplacement {src} -> {dst}")
  2263:    144:             move_dir(src, dst)
  2264:    145:             ensure_pkg_init(dst)
  2265:    146: 
  2266:    147:     # gérer config.py -> package config/loader.py
  2267:    148:     ensure_config_package(scalp_pkg)
  2268:    149: 
  2269:    150:     # réécriture imports vers scalper.*
  2270:    151:     changed = rewrite_imports(repo, IMPORT_RULES_STAGE1)
  2271:    152:     ok(f"imports stage1 réécrits dans {changed} fichier(s)")
  2272:    153: 
  2273:    154: def stage2_rename_package(repo: Path, old="scalp", new="scalper"):
  2274:    155:     """Renomme le package interne old -> new et réécrit tous les imports."""
  2275:    156:     pkg_old = repo / old
  2276:    157:     pkg_new = repo / new
  2277:    158:     if not pkg_old.exists():
  2278:    159:         warn(f"package {pkg_old} introuvable (déjà renommé ?)")
  2279:    160:     else:
  2280:    161:         shutil.move(str(pkg_old), str(pkg_new))
  2281:    162:         ok(f"package renommé {pkg_old.name} -> {pkg_new.name}")
  2282:    163: 
  2283:    164:     # réécriture imports 'old.' -> 'new.'
  2284:    165:     pat = re.compile(rf"\b{old}\.")
  2285:    166:     changed = 0
  2286:    167:     for py in repo.rglob("*.py"):
  2287:    168:         if ".backup" in str(py): continue
  2288:    169:         txt = py.read_text(encoding="utf-8")
  2289:    170:         new_txt = pat.sub(f"{new}.", txt)
  2290:    171:         if new_txt != txt:
  2291:    172:             py.write_text(new_txt, encoding="utf-8")
  2292:    173:             changed += 1
  2293:    174:     ok(f"imports stage2 réécrits dans {changed} fichier(s)")
  2294:    175: 
  2295:    176: def main():
  2296:    177:     ap = argparse.ArgumentParser(description="Restructure + rename Python package (scalp -> scalper).")
  2297:    178:     ap.add_argument("--repo", default="./", help="Chemin du repo (racine qui contient bot.py).")
  2298:    179:     args = ap.parse_args()
  2299:    180:     repo = Path(args.repo).resolve()
  2300:    181:     if not repo.exists(): raise SystemExit(f"Repo introuvable: {repo}")
  2301:    182: 
  2302:    183:     # 1) sauvegarde
  2303:    184:     backup_repo(repo)
  2304:    185: 
  2305:    186:     # 2) ranger les modules sous scalp/ (package) + fixer imports
  2306:    187:     stage1_restructure(repo)
  2307:    188: 
  2308:    189:     # 3) renommer le package interne scalp/ -> scalper/ + fixer imports
  2309:    190:     stage2_rename_package(repo, old="scalp", new="scalper")
  2310:    191: 
  2311:    192:     ok("Refactor complet terminé.")
  2312:    193:     print("\n➡️ Vérifie maintenant:\n"
  2313:    194:           "   python - <<'PY'\n"
  2314:    195:           "import importlib; m = importlib.import_module('scalper.config'); print('OK:', hasattr(m, 'load_settings'))\n"
  2315:    196:           "PY\n"
  2316:    197:           "\nPuis lance:\n"
  2317:    198:           "   python bot.py\n")
  2318:    199: 
  2319:    200: if __name__ == "__main__":
  2320:    201:     main()
  2321: 
  2322: ## TRASH_20250823-124533/run_backtest.py (last modified: 2025-08-23 20:57:14)
  2323:      1: #!/usr/bin/env python3
  2324:      2: import os
  2325:      3: from scalper.backtest.engine import BacktestEngine
  2326:      4: 
  2327:      5: def main():
  2328:      6:     print("[*] Lancement du backtest...")
  2329:      7:     
  2330:      8:     # ⚡ Tu pourras changer ces paramètres
  2331:      9:     pairs = ["BTCUSDT", "ETHUSDT"]  # pour commencer simple
  2332:     10:     start_date = "2024-01-01"
  2333:     11:     end_date = "2024-02-01"
  2334:     12: 
  2335:     13:     # Dossier résultat
  2336:     14:     result_dir = os.path.join(os.path.dirname(__file__), "result")
  2337:     15:     os.makedirs(result_dir, exist_ok=True)
  2338:     16: 
  2339:     17:     # Création du moteur
  2340:     18:     engine = BacktestEngine(
  2341:     19:         pairs=pairs,
  2342:     20:         start_date=start_date,
  2343:     21:         end_date=end_date,
  2344:     22:         result_dir=result_dir
  2345:     23:     )
  2346:     24: 
  2347:     25:     # Lancer le backtest
  2348:     26:     engine.run()
  2349:     27: 
  2350:     28:     print("[✅] Backtest terminé ! Résultats disponibles dans /result/")
  2351:     29: 
  2352:     30: if __name__ == "__main__":
  2353:     31:     main()
  2354: 
  2355: ## TRASH_20250823-124533/scalper/bot_config.py (last modified: 2025-08-23 20:57:14)
  2356:      1: import os
  2357:      2: 
  2358:      3: 
  2359:      4: DEFAULT_SYMBOL = os.getenv("SYMBOL") or "BTCUSDT"
  2360:      5: 
  2361:      6: CONFIG = {
  2362:      7:     "BITGET_ACCESS_KEY": os.getenv("BITGET_API_KEY")
  2363:      8:     or os.getenv("BITGET_ACCESS_KEY", "A_METTRE"),
  2364:      9:     "BITGET_SECRET_KEY": os.getenv("BITGET_API_SECRET")
  2365:     10:     or os.getenv("BITGET_SECRET_KEY", "B_METTRE"),
  2366:     11:     "BITGET_PASSPHRASE": os.getenv("BITGET_API_PASSPHRASE", ""),
  2367:     12:     "PAPER_TRADE": os.getenv("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "y"),
  2368:     13:     "SYMBOL": DEFAULT_SYMBOL,
  2369:     14:     "PRODUCT_TYPE": os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES"),
  2370:     15:     "MARGIN_COIN": os.getenv("BITGET_MARGIN_COIN", "USDT"),
  2371:     16:     "INTERVAL": os.getenv("INTERVAL", "1m"),
  2372:     17:     "EMA_FAST": int(os.getenv("EMA_FAST", "9")),
  2373:     18:     "EMA_SLOW": int(os.getenv("EMA_SLOW", "21")),
  2374:     19:     "MACD_FAST": int(os.getenv("MACD_FAST", "12")),
  2375:     20:     "MACD_SLOW": int(os.getenv("MACD_SLOW", "26")),
  2376:     21:     "MACD_SIGNAL": int(os.getenv("MACD_SIGNAL", "9")),
  2377:     22:     "EMA_TREND_PERIOD": int(os.getenv("EMA_TREND_PERIOD", "200")),
  2378:     23:     "RISK_PCT_EQUITY": float(os.getenv("RISK_PCT_EQUITY", "0.01")),
  2379:     24:     "LEVERAGE": int(os.getenv("LEVERAGE", "5")),
  2380:     25:     "RISK_LEVEL": int(os.getenv("RISK_LEVEL", "2")),
  2381:     26:     "OPEN_TYPE": int(os.getenv("OPEN_TYPE", "1")),
  2382:     27:     "STOP_LOSS_PCT": float(os.getenv("STOP_LOSS_PCT", "0.006")),
  2383:     28:     "TAKE_PROFIT_PCT": float(os.getenv("TAKE_PROFIT_PCT", "0.012")),
  2384:     29:     "ATR_PERIOD": int(os.getenv("ATR_PERIOD", "14")),
  2385:     30:     "TRAIL_ATR_MULT": float(os.getenv("TRAIL_ATR_MULT", "0.75")),
  2386:     31:     "SCALE_IN_ATR_MULT": float(os.getenv("SCALE_IN_ATR_MULT", "0.5")),
  2387:     32:     "PROGRESS_MIN": float(os.getenv("PROGRESS_MIN", "15")),
  2388:     33:     "TIMEOUT_MIN": float(os.getenv("TIMEOUT_MIN", "30")),
  2389:     34:     "MAX_KLINES": int(os.getenv("MAX_KLINES", "400")),
  2390:     35:     "LOOP_SLEEP_SECS": int(os.getenv("LOOP_SLEEP_SECS", "10")),
  2391:     36:     "RECV_WINDOW": int(os.getenv("RECV_WINDOW", "30")),
  2392:     37:     "LOG_DIR": os.getenv("LOG_DIR", "./logs"),
  2393:     38:     # --- Sécurité / Sizing -------------------------------------------------
  2394:     39:     "ALLOWED_SYMBOLS": [
  2395:     40:         s.strip().upper()
  2396:     41:         for s in os.getenv("ALLOWED_SYMBOLS", "").split(",")
  2397:     42:         if s.strip()
  2398:     43:     ],
  2399:     44:     "NOTIONAL_CAP_USDT": float(os.getenv("NOTIONAL_CAP_USDT", "100.0")),
  2400:     45:     "MARGIN_CAP_RATIO": float(os.getenv("MARGIN_CAP_RATIO", "0.9")),
  2401:     46:     "RISK_PCT_MIN": float(os.getenv("RISK_PCT_MIN", "0.0005")),
  2402:     47:     "RISK_PCT_MAX": float(os.getenv("RISK_PCT_MAX", "0.02")),
  2403:     48:     "BASE_URL": os.getenv("BITGET_CONTRACT_BASE_URL", "https://api.bitget.com"),
  2404:     49:     "FEE_RATE": float(os.getenv("FEE_RATE", "0.0")),
  2405:     50:     "MAX_DAILY_LOSS_PCT": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
  2406:     51:     "MAX_DAILY_PROFIT_PCT": float(os.getenv("MAX_DAILY_PROFIT_PCT", "5.0")),
  2407:     52:     "MAX_POSITIONS": int(os.getenv("MAX_POSITIONS", "3")),
  2408:     53: }
  2409:     54: 
  2410: 
  2411: 
  2412: ## TRASH_20250823-124533/scalper/legacy_config.py (last modified: 2025-08-23 20:57:14)
  2413:      1: # scalp/config.py
  2414:      2: from __future__ import annotations
  2415:      3: import os, sys
  2416:      4: from typing import Optional
  2417:      5: 
  2418:      6: # ---------------------------
  2419:      7: #  Chargement .env (sans dep)
  2420:      8: # ---------------------------
  2421:      9: def _load_dotenv_if_present(path: str = ".env") -> None:
  2422:     10:     try:
  2423:     11:         if not os.path.isfile(path):
  2424:     12:             return
  2425:     13:         with open(path, "r", encoding="utf-8") as f:
  2426:     14:             for line in f:
  2427:     15:                 s = line.strip()
  2428:     16:                 if not s or s.startswith("#") or "=" not in s:
  2429:     17:                     continue
  2430:     18:                 k, v = s.split("=", 1)
  2431:     19:                 k = k.strip()
  2432:     20:                 v = v.strip().strip('"').strip("'")
  2433:     21:                 # ne pas écraser une var déjà définie par l'env
  2434:     22:                 os.environ.setdefault(k, v)
  2435:     23:     except Exception:
  2436:     24:         pass
  2437:     25: 
  2438:     26: _load_dotenv_if_present()
  2439:     27: 
  2440:     28: # ---------------------------
  2441:     29: #  Aliases variables d'env
  2442:     30: # ---------------------------
  2443:     31: def _env_alias(name: str, *aliases: str) -> Optional[str]:
  2444:     32:     """Retourne la première valeur non nulle parmi name et ses alias."""
  2445:     33:     if name in os.environ and os.environ[name]:
  2446:     34:         return os.environ[name]
  2447:     35:     for a in aliases:
  2448:     36:         v = os.environ.get(a)
  2449:     37:         if v:
  2450:     38:             return v
  2451:     39:     return None
  2452:     40: 
  2453:     41: def _env_bool(name: str, default: bool) -> bool:
  2454:     42:     raw = os.environ.get(name)
  2455:     43:     if raw is None:
  2456:     44:         return default
  2457:     45:     return raw.lower() in ("1", "true", "yes", "on")
  2458:     46: 
  2459:     47: # ---------------------------
  2460:     48: #  Pydantic v1 si dispo
  2461:     49: # ---------------------------
  2462:     50: try:
  2463:     51:     from pydantic import BaseModel, Field, ValidationError  # type: ignore
  2464:     52:     _HAVE_PYDANTIC = True
  2465:     53: except Exception:
  2466:     54:     _HAVE_PYDANTIC = False
  2467:     55: 
  2468:     56: if _HAVE_PYDANTIC:
  2469:     57: 
  2470:     58:     class AppConfig(BaseModel):
  2471:     59:         # Clés Bitget
  2472:     60:         BITGET_API_KEY: str = Field(..., min_length=3)
  2473:     61:         BITGET_API_SECRET: str = Field(..., min_length=3)
  2474:     62:         BITGET_PASSPHRASE: str = Field(..., min_length=1)
  2475:     63: 
  2476:     64:         # Trading
  2477:     65:         RISK_PCT: float = Field(0.01, ge=0.0, le=0.2)
  2478:     66:         MIN_TRADE_USDT: float = Field(5.0, ge=0.0)
  2479:     67:         LEVERAGE: float = Field(1.0, ge=1.0, le=125.0)
  2480:     68:         PAPER_TRADE: bool = Field(True)
  2481:     69: 
  2482:     70:         # Telegram (facultatif)
  2483:     71:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  2484:     72:         TELEGRAM_CHAT_ID: Optional[str] = None
  2485:     73: 
  2486:     74:     def load_or_exit() -> "AppConfig":
  2487:     75:         try:
  2488:     76:             # supporte aussi ACCESS_KEY/SECRET_KEY (alias)
  2489:     77:             api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  2490:     78:             api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  2491:     79:             api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  2492:     80: 
  2493:     81:             return AppConfig(
  2494:     82:                 BITGET_API_KEY=api_key,
  2495:     83:                 BITGET_API_SECRET=api_sec,
  2496:     84:                 BITGET_PASSPHRASE=api_pass,
  2497:     85:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  2498:     86:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  2499:     87:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  2500:     88:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  2501:     89:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  2502:     90:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  2503:     91:             )
  2504:     92:         except ValidationError as e:
  2505:     93:             print("[CONFIG] Invalid configuration:", e, file=sys.stderr)
  2506:     94:             sys.exit(2)
  2507:     95: 
  2508:     96: else:
  2509:     97:     # ---------------------------
  2510:     98:     #  Fallback dataclass simple
  2511:     99:     # ---------------------------
  2512:    100:     from dataclasses import dataclass
  2513:    101: 
  2514:    102:     @dataclass
  2515:    103:     class AppConfig:
  2516:    104:         BITGET_API_KEY: str
  2517:    105:         BITGET_API_SECRET: str
  2518:    106:         BITGET_PASSPHRASE: str
  2519:    107: 
  2520:    108:         RISK_PCT: float = 0.01
  2521:    109:         MIN_TRADE_USDT: float = 5.0
  2522:    110:         LEVERAGE: float = 1.0
  2523:    111:         PAPER_TRADE: bool = True
  2524:    112: 
  2525:    113:         TELEGRAM_BOT_TOKEN: Optional[str] = None
  2526:    114:         TELEGRAM_CHAT_ID: Optional[str] = None
  2527:    115: 
  2528:    116:     def load_or_exit() -> "AppConfig":
  2529:    117:         api_key = _env_alias("BITGET_API_KEY", "BITGET_ACCESS_KEY")
  2530:    118:         api_sec = _env_alias("BITGET_API_SECRET", "BITGET_SECRET_KEY")
  2531:    119:         api_pass = _env_alias("BITGET_PASSPHRASE", "BITGET_PASSWORD", "API_PASSPHRASE")
  2532:    120: 
  2533:    121:         if not api_key or not api_sec or not api_pass:
  2534:    122:             print("[CONFIG] Missing Bitget credentials. Expected either:", file=sys.stderr)
  2535:    123:             print("        - BITGET_API_KEY / BITGET_API_SECRET / BITGET_PASSPHRASE", file=sys.stderr)
  2536:    124:             print("          or", file=sys.stderr)
  2537:    125:             print("        - BITGET_ACCESS_KEY / BITGET_SECRET_KEY / BITGET_PASSPHRASE", file=sys.stderr)
  2538:    126:             sys.exit(2)
  2539:    127: 
  2540:    128:         try:
  2541:    129:             return AppConfig(
  2542:    130:                 BITGET_API_KEY=api_key,
  2543:    131:                 BITGET_API_SECRET=api_sec,
  2544:    132:                 BITGET_PASSPHRASE=api_pass,
  2545:    133:                 RISK_PCT=float(os.environ.get("RISK_PCT", "0.01")),
  2546:    134:                 MIN_TRADE_USDT=float(os.environ.get("MIN_TRADE_USDT", "5")),
  2547:    135:                 LEVERAGE=float(os.environ.get("LEVERAGE", "1")),
  2548:    136:                 PAPER_TRADE=_env_bool("PAPER_TRADE", True),
  2549:    137:                 TELEGRAM_BOT_TOKEN=_env_alias("TELEGRAM_BOT_TOKEN"),
  2550:    138:                 TELEGRAM_CHAT_ID=_env_alias("TELEGRAM_CHAT_ID"),
  2551:    139:             )
  2552:    140:         except Exception as e:
  2553:    141:             print(f"[CONFIG] Invalid configuration values: {e!r}", file=sys.stderr)
  2554:    142:             sys.exit(2)
  2555: 
  2556: ## TRASH_20250823-124533/scalper/notifier.py (last modified: 2025-08-23 20:57:14)
  2557:      1: """Simple notifier for bot events."""
  2558:      2: 
  2559:      3: from __future__ import annotations
  2560:      4: 
  2561:      5: import logging
  2562:      6: import os
  2563:      7: from typing import Any, Dict
  2564:      8: 
  2565:      9: try:  # pragma: no cover - guarded import for optional dependency
  2566:     10:     import requests as _requests
  2567:     11: 
  2568:     12:     # ``requests`` may be provided as a stub during tests. Ensure it exposes a
  2569:     13:     # ``post`` attribute so callers can monkeypatch it reliably.
  2570:     14:     if not hasattr(_requests, "post"):
  2571:     15:         raise ImportError
  2572:     16:     requests = _requests
  2573:     17: except Exception:  # pragma: no cover - fallback when ``requests`` is missing
  2574:     18: 
  2575:     19:     class _Requests:
  2576:     20:         """Minimal stand‑in for :mod:`requests` when the real library is absent."""
  2577:     21: 
  2578:     22:         def post(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - safety
  2579:     23:             raise RuntimeError("requests.post unavailable")
  2580:     24: 
  2581:     25:     requests = _Requests()  # type: ignore[assignment]
  2582:     26: 
  2583:     27: 
  2584:     28: def _pair_name(symbol: str) -> str:
  2585:     29:     """Return a human friendly pair name without the base ``USDT``."""
  2586:     30:     if "_" in symbol:
  2587:     31:         base, quote = symbol.split("_", 1)
  2588:     32:     elif symbol.endswith("USDT"):
  2589:     33:         base, quote = symbol[:-4], "USDT"
  2590:     34:     else:
  2591:     35:         base, quote = symbol, ""
  2592:     36:     if not quote or quote == "USDT":
  2593:     37:         return base
  2594:     38:     return f"{base}/{quote}"
  2595:     39: 
  2596:     40: 
  2597:     41: def _format_position_event(event: str, payload: Dict[str, Any]) -> str:
  2598:     42:     """Format a position open/close payload."""
  2599:     43: 
  2600:     44:     side = payload.get("side")
  2601:     45:     symbol = payload.get("symbol")
  2602:     46:     if symbol:
  2603:     47:         symbol = _pair_name(symbol)
  2604:     48: 
  2605:     49:     if event == "position_opened":
  2606:     50:         rc = payload.get("risk_color", "")
  2607:     51:         head = f"{rc} Ouvre {side} {symbol}".strip()
  2608:     52:         lines = [head]
  2609:     53:         lines.append(
  2610:     54:             f"Notional: {payload.get('notional_usdt')} USDT   Levier: x{payload.get('leverage')}"
  2611:     55:         )
  2612:     56:         lines.append(
  2613:     57:             "Marge estimée: {} USDT (dispo: {} USDT)".format(
  2614:     58:                 payload.get("required_margin_usdt"), payload.get("available_usdt")
  2615:     59:             )
  2616:     60:         )
  2617:     61:         lines.append(
  2618:     62:             "Risque: lvl {}/{} (risk_pct={:.4f}%)".format(
  2619:     63:                 payload.get("signal_level"),
  2620:     64:                 payload.get("risk_level_user"),
  2621:     65:                 float(payload.get("risk_pct_eff", 0.0)) * 100,
  2622:     66:             )
  2623:     67:         )
  2624:     68:         lines.append(
  2625:     69:             "Prix: {}   Vol: {} (cs={})".format(
  2626:     70:                 payload.get("price"),
  2627:     71:                 payload.get("vol"),
  2628:     72:                 payload.get("contract_size"),
  2629:     73:             )
  2630:     74:         )
  2631:     75:         return "\n".join(lines)
  2632:     76: 
  2633:     77:     # position_closed
  2634:     78:     rc = payload.get("risk_color", "")
  2635:     79:     head = f"Ferme {side} {symbol} {rc}".strip()
  2636:     80:     lines = [head]
  2637:     81:     pnl_usdt = payload.get("pnl_usdt")
  2638:     82:     fees = payload.get("fees_usdt")
  2639:     83:     if pnl_usdt is not None and fees is not None:
  2640:     84:         lines.append(f"PnL net: {pnl_usdt:+.2f} USDT (frais: {fees:.2f})")
  2641:     85:     pct = payload.get("pnl_pct_on_margin")
  2642:     86:     if pct is not None:
  2643:     87:         lines.append(f"% sur marge: {pct:.2f}%")
  2644:     88:     lines.append(
  2645:     89:         "Entrée: {}  Sortie: {}".format(
  2646:     90:             payload.get("entry_price"), payload.get("exit_price")
  2647:     91:         )
  2648:     92:     )
  2649:     93:     lines.append(
  2650:     94:         "Vol: {}  Notional: in {} → out {} USDT".format(
  2651:     95:             payload.get("vol"),
  2652:     96:             payload.get("notional_entry_usdt"),
  2653:     97:             payload.get("notional_exit_usdt"),
  2654:     98:         )
  2655:     99:     )
  2656:    100:     return "\n".join(lines)
  2657:    101: 
  2658:    102: 
  2659:    103: def _format_pair_list(payload: Dict[str, Any]) -> str:
  2660:    104:     """Format the pair list payload.
  2661:    105: 
  2662:    106:     The detailed pair listing is intentionally hidden from terminal output to
  2663:    107:     reduce noise. Only an acknowledgement message is returned.
  2664:    108:     """
  2665:    109: 
  2666:    110:     return "Listing ok"
  2667:    111: 
  2668:    112: 
  2669:    113: def _format_generic(event: str, payload: Dict[str, Any]) -> str:
  2670:    114:     text = event
  2671:    115:     if payload:
  2672:    116:         items = "\n".join(f"{k}={v}" for k, v in payload.items())
  2673:    117:         text = f"{text}\n{items}"
  2674:    118:     return text
  2675:    119: 
  2676:    120: 
  2677:    121: def _format_text(event: str, payload: Dict[str, Any] | None = None) -> str:
  2678:    122:     """Return a human readable text describing the event payload."""
  2679:    123:     payload = payload or {}
  2680:    124:     if event in {"position_opened", "position_closed"}:
  2681:    125:         return _format_position_event(event, payload)
  2682:    126:     if event == "pair_list":
  2683:    127:         return _format_pair_list(payload)
  2684:    128:     if event == "bot_started":
  2685:    129:         return "🤖 Bot démarré"
  2686:    130:     return _format_generic(event, payload)
  2687:    131: 
  2688:    132: 
  2689:    133: def notify(event: str, payload: Dict[str, Any] | None = None) -> None:
  2690:    134:     """Send an event payload to configured endpoints.
  2691:    135: 
  2692:    136:     Notifications are delivered via a generic webhook defined by ``NOTIFY_URL``
  2693:    137:     and/or directly to Telegram when ``TELEGRAM_BOT_TOKEN`` and
  2694:    138:     ``TELEGRAM_CHAT_ID`` are provided. Network errors are logged but otherwise
  2695:    139:     ignored so they do not interrupt the bot's execution.
  2696:    140:     """
  2697:    141: 
  2698:    142:     data = {"event": event}
  2699:    143:     if payload:
  2700:    144:         data.update(payload)
  2701:    145: 
  2702:    146:     # Generic HTTP webhook
  2703:    147:     url = os.getenv("NOTIFY_URL")
  2704:    148:     if url:
  2705:    149:         try:
  2706:    150:             requests.post(url, json=data, timeout=5)
  2707:    151:         except Exception as exc:  # pragma: no cover - best effort only
  2708:    152:             logging.error("Notification error for %s: %s", event, exc)
  2709:    153: 
  2710:    154:     # Telegram notification
  2711:    155:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  2712:    156:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  2713:    157:     # ``pair_list`` notifications are intentionally not forwarded to Telegram
  2714:    158:     if token and chat_id and event != "pair_list":
  2715:    159:         text = _format_text(event, payload or {})
  2716:    160:         t_url = f"https://api.telegram.org/bot{token}/sendMessage"
  2717:    161:         t_payload = {"chat_id": chat_id, "text": text}
  2718:    162:         try:  # pragma: no cover - network
  2719:    163:             requests.post(t_url, json=t_payload, timeout=5)
  2720:    164:         except Exception as exc:  # pragma: no cover - best effort only
  2721:    165:             logging.error("Telegram notification error for %s: %s", event, exc)
  2722: 
  2723: 
  2724: ## TRASH_20250823-124533/scalper/telegram_bot.py (last modified: 2025-08-23 20:57:14)
  2725:      1: from __future__ import annotations
  2726:      2: 
  2727:      3: import logging
  2728:      4: import os
  2729:      5: from typing import Any, Dict, Optional
  2730:      6: 
  2731:      7: try:  # pragma: no cover - optional dependency
  2732:      8:     import requests as _requests
  2733:      9:     requests = _requests
  2734:     10: except Exception:  # pragma: no cover
  2735:     11:     class _Requests:
  2736:     12:         def get(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  2737:     13:             raise RuntimeError("requests.get unavailable")
  2738:     14: 
  2739:     15:         def post(self, *a: Any, **k: Any) -> Any:  # pragma: no cover - fallback
  2740:     16:             raise RuntimeError("requests.post unavailable")
  2741:     17: 
  2742:     18:     requests = _Requests()  # type: ignore[assignment]
  2743:     19: 
  2744:     20: 
  2745:     21: class TelegramBot:
  2746:     22:     """Minimal Telegram bot using the HTTP API.
  2747:     23: 
  2748:     24: 
  2749:     25:     The bot exposes a simple *menu* based interface with clickable buttons so
  2750:     26:     users do not have to remember text commands.  A sub-menu lets the user set
  2751:     27:     the risk level.
  2752:     28: 
  2753:     29:     """
  2754:     30: 
  2755:     31:     def __init__(
  2756:     32:         self,
  2757:     33:         token: str,
  2758:     34:         chat_id: str,
  2759:     35:         client: Any,
  2760:     36:         config: Dict[str, Any],
  2761:     37:         risk_mgr: Any,
  2762:     38:         *,
  2763:     39:         requests_module: Any = requests,
  2764:     40:     ) -> None:
  2765:     41:         self.token = token
  2766:     42:         self.chat_id = str(chat_id)
  2767:     43:         self.client = client
  2768:     44:         self.config = config
  2769:     45:         self.risk_mgr = risk_mgr
  2770:     46:         self.requests = requests_module
  2771:     47:         self.last_update_id: Optional[int] = None
  2772:     48:         self.stop_requested = False
  2773:     49: 
  2774:     50: 
  2775:     51:         self.main_keyboard = [
  2776:     52:             [{"text": "Positions ouvertes", "callback_data": "positions"}],
  2777:     53:             [{"text": "Update Cryptos", "callback_data": "update"}],
  2778:     54:             [{"text": "Réglages", "callback_data": "settings"}],
  2779:     55:             [{"text": "Arrêt bot", "callback_data": "shutdown"}],
  2780:     56:         ]
  2781:     57:         self.settings_keyboard = [
  2782:     58:             [{"text": "Stop trade", "callback_data": "stop"}],
  2783:     59:             [{"text": "Réglage risk", "callback_data": "risk"}],
  2784:     60:             [{"text": "Nb positions", "callback_data": "maxpos"}],
  2785:     61:             [{"text": "Reset risk", "callback_data": "reset_risk"}],
  2786:     62:             [{"text": "Reset total", "callback_data": "reset_all"}],
  2787:     63:             [{"text": "Retour", "callback_data": "back"}],
  2788:     64:         ]
  2789:     65:         self.risk_keyboard = [
  2790:     66:             [
  2791:     67:                 {"text": "🟢", "callback_data": "risk_green"},
  2792:     68:                 {"text": "🟠", "callback_data": "risk_orange"},
  2793:     69:                 {"text": "🔴", "callback_data": "risk_red"},
  2794:     70:             ],
  2795:     71:             [{"text": "Retour", "callback_data": "back"}],
  2796:     72:         ]
  2797:     73:         self.maxpos_keyboard = [
  2798:     74:             [
  2799:     75:                 {"text": "1", "callback_data": "maxpos_1"},
  2800:     76:                 {"text": "2", "callback_data": "maxpos_2"},
  2801:     77:                 {"text": "3", "callback_data": "maxpos_3"},
  2802:     78:             ],
  2803:     79:             [
  2804:     80:                 {"text": "4", "callback_data": "maxpos_4"},
  2805:     81:                 {"text": "5", "callback_data": "maxpos_5"},
  2806:     82:             ],
  2807:     83:             [{"text": "Retour", "callback_data": "back"}],
  2808:     84:         ]
  2809:     85: 
  2810:     86:         # Show menu on startup with zero PnL session
  2811:     87:         self.send_main_menu(0.0)
  2812:     88: 
  2813:     89: 
  2814:     90:     def _base_symbol(self, symbol: str) -> str:
  2815:     91:         sym = symbol.replace("_", "")
  2816:     92:         return sym[:-4] if sym.endswith("USDT") else sym
  2817:     93: 
  2818:     94:     def _build_stop_keyboard(self) -> list[list[Dict[str, str]]]:
  2819:     95:         pos = self.client.get_positions() or {}
  2820:     96:         buttons: list[list[Dict[str, str]]] = []
  2821:     97:         for p in pos.get("data") or []:
  2822:     98:             sym = p.get("symbol")
  2823:     99:             if not sym:
  2824:    100:                 continue
  2825:    101:             base = self._base_symbol(sym)
  2826:    102:             # Use the full symbol in the callback so we can properly
  2827:    103:             # identify the position to close.  Only the label shows the
  2828:    104:             # base asset to keep the interface concise.
  2829:    105:             buttons.append([{"text": base, "callback_data": f"stop_{sym}"}])
  2830:    106:         buttons.append([{"text": "Tous", "callback_data": "stop_all"}])
  2831:    107:         buttons.append([{"text": "Retour", "callback_data": "back"}])
  2832:    108:         return buttons
  2833:    109: 
  2834:    110: 
  2835:    111:     def _menu_text(self, session_pnl: float) -> str:
  2836:    112:         assets = self.client.get_assets() or {}
  2837:    113:         equity = 0.0
  2838:    114:         for row in assets.get("data") or []:
  2839:    115:             if row.get("currency") == "USDT":
  2840:    116:                 try:
  2841:    117:                     equity = float(row.get("equity", 0.0))
  2842:    118:                 except Exception:
  2843:    119:                     equity = 0.0
  2844:    120:                 break
  2845:    121:         return (
  2846:    122:             f"Solde: {equity:.2f} USDT\n"
  2847:    123:             f"PnL session: {session_pnl:.2f} USDT\n"
  2848:    124:             f"Positions max: {self.risk_mgr.max_positions}\n"
  2849:    125:             f"Risque actuel: {self.risk_mgr.risk_pct * 100:.2f}%\n"
  2850:    126:             "Choisissez une option:"
  2851:    127:         )
  2852:    128: 
  2853:    129:     def send_main_menu(self, session_pnl: float) -> None:
  2854:    130:         self.send(self._menu_text(session_pnl), self.main_keyboard)
  2855:    131: 
  2856:    132:     def update_pairs(self) -> None:
  2857:    133:         from bot import update as _update  # lazy import to avoid cycle
  2858:    134:         _update(self.client, top_n=40)
  2859:    135: 
  2860:    136:     # ------------------------------------------------------------------
  2861:    137:     def _api_url(self, method: str) -> str:
  2862:    138:         return f"https://api.telegram.org/bot{self.token}/{method}"
  2863:    139: 
  2864:    140: 
  2865:    141:     def send(self, text: str, keyboard: Optional[list[list[Dict[str, str]]]] = None) -> None:
  2866:    142:         payload: Dict[str, Any] = {"chat_id": self.chat_id, "text": text}
  2867:    143:         if keyboard:
  2868:    144:             payload["reply_markup"] = {"inline_keyboard": keyboard}
  2869:    145: 
  2870:    146:         try:  # pragma: no cover - network
  2871:    147:             self.requests.post(self._api_url("sendMessage"), json=payload, timeout=5)
  2872:    148:         except Exception as exc:  # pragma: no cover - best effort
  2873:    149:             logging.error("Telegram send error: %s", exc)
  2874:    150: 
  2875:    151:     def answer_callback(self, cb_id: str) -> None:
  2876:    152:         payload = {"callback_query_id": cb_id}
  2877:    153:         try:  # pragma: no cover - network
  2878:    154:             self.requests.post(
  2879:    155:                 self._api_url("answerCallbackQuery"), json=payload, timeout=5
  2880:    156:             )
  2881:    157:         except Exception as exc:  # pragma: no cover - best effort
  2882:    158:             logging.error("Telegram answerCallback error: %s", exc)
  2883:    159: 
  2884:    160: 
  2885:    161:     # ------------------------------------------------------------------
  2886:    162:     def fetch_updates(self) -> list[Dict[str, Any]]:
  2887:    163:         params: Dict[str, Any] = {}
  2888:    164:         if self.last_update_id is not None:
  2889:    165:             params["offset"] = self.last_update_id + 1
  2890:    166:         try:  # pragma: no cover - network
  2891:    167:             r = self.requests.get(self._api_url("getUpdates"), params=params, timeout=5)
  2892:    168:             r.raise_for_status()
  2893:    169:             data = r.json()
  2894:    170:         except Exception as exc:  # pragma: no cover - best effort
  2895:    171:             logging.error("Telegram getUpdates error: %s", exc)
  2896:    172:             return []
  2897:    173:         updates = data.get("result", [])
  2898:    174:         if updates:
  2899:    175:             self.last_update_id = updates[-1].get("update_id")
  2900:    176:         return updates
  2901:    177: 
  2902:    178:     # ------------------------------------------------------------------
  2903:    179:     def handle_updates(self, session_pnl: float) -> None:
  2904:    180:         for update in self.fetch_updates():
  2905:    181: 
  2906:    182:             callback = update.get("callback_query")
  2907:    183:             if callback:
  2908:    184:                 if str(callback.get("from", {}).get("id")) != self.chat_id:
  2909:    185:                     continue
  2910:    186:                 data = callback.get("data", "")
  2911:    187:                 reply, kb = self.handle_callback(data, session_pnl)
  2912:    188:                 if reply:
  2913:    189:                     self.send(reply, kb)
  2914:    190:                 cb_id = callback.get("id")
  2915:    191:                 if cb_id:
  2916:    192:                     self.answer_callback(cb_id)
  2917:    193:                 continue
  2918:    194: 
  2919:    195: 
  2920:    196:             msg = update.get("message") or {}
  2921:    197:             chat = msg.get("chat") or {}
  2922:    198:             if str(chat.get("id")) != self.chat_id:
  2923:    199:                 continue
  2924:    200: 
  2925:    201:             # Any text message triggers the main menu with balance and PnL
  2926:    202:             self.send_main_menu(session_pnl)
  2927:    203: 
  2928:    204:     # ------------------------------------------------------------------
  2929:    205:     def handle_callback(
  2930:    206:         self, data: str, session_pnl: float
  2931:    207:     ) -> tuple[Optional[str], Optional[list[list[Dict[str, str]]]]]:
  2932:    208:         if not data:
  2933:    209:             return None, None
  2934:    210:         if data == "balance":
  2935:    211:             assets = self.client.get_assets() or {}
  2936:    212:             equity = 0.0
  2937:    213:             for row in assets.get("data") or []:
  2938:    214:                 if row.get("currency") == "USDT":
  2939:    215:                     try:
  2940:    216:                         equity = float(row.get("equity", 0.0))
  2941:    217:                     except Exception:
  2942:    218:                         equity = 0.0
  2943:    219:                     break
  2944:    220: 
  2945:    221:             return f"Solde: {equity:.2f} USDT", self.main_keyboard
  2946:    222:         if data == "positions":
  2947:    223:             pos = self.client.get_positions() or {}
  2948:    224:             lines = []
  2949:    225:             for p in pos.get("data") or []:
  2950:    226:                 symbol = p.get("symbol", "")
  2951:    227:                 base = self._base_symbol(symbol)
  2952:    228:                 side = p.get("side")
  2953:    229:                 vol = p.get("vol")
  2954:    230:                 pnl = p.get("pnl_usdt")
  2955:    231:                 if pnl is None:
  2956:    232:                     pnl = p.get("pnl_usd")
  2957:    233:                 if pnl is None:
  2958:    234:                     pnl = p.get("pnl")
  2959:    235:                 pnl_pct = p.get("pnl_pct_on_margin")
  2960:    236:                 if pnl_pct is None:
  2961:    237:                     pnl_pct = p.get("pnl_pct")
  2962:    238:                 line = f"{base} {side} {vol}"
  2963:    239:                 if pnl is not None and pnl_pct is not None:
  2964:    240:                     line += f"\nPnL: {pnl:.2f} USDT ({pnl_pct:.2f}%)"
  2965:    241:                 lines.append(line)
  2966:    242:             if not lines:
  2967:    243: 
  2968:    244:                 return "Aucune position ouverte", self.main_keyboard
  2969:    245:             return "Positions:\n" + "\n".join(lines), self.main_keyboard
  2970:    246:         if data == "pnl":
  2971:    247:             return f"PnL session: {session_pnl:.2f} USDT", self.main_keyboard
  2972:    248:         if data == "risk":
  2973:    249:             return "Choisissez le niveau de risque:", self.risk_keyboard
  2974:    250:         if data == "settings":
  2975:    251:             return "Réglages:", self.settings_keyboard
  2976:    252:         if data == "maxpos":
  2977:    253:             return "Choisissez le nombre de positions:", self.maxpos_keyboard
  2978:    254:         if data == "reset_risk":
  2979:    255:             try:
  2980:    256:                 self.risk_mgr.reset_day()
  2981:    257:                 return "Risque réinitialisé", self.settings_keyboard
  2982:    258:             except Exception:
  2983:    259:                 return "Erreur reset risque", self.settings_keyboard
  2984:    260:         if data == "update":
  2985:    261:             try:
  2986:    262:                 self.update_pairs()
  2987:    263:                 return "Liste cryptos mise à jour", self.main_keyboard
  2988:    264:             except Exception:
  2989:    265:                 return "Erreur mise à jour", self.main_keyboard
  2990:    266:         if data.startswith("risk"):
  2991:    267:             mapping = {
  2992:    268:                 "risk_green": 1,
  2993:    269:                 "risk_orange": 2,
  2994:    270:                 "risk_red": 3,
  2995:    271:             }
  2996:    272:             lvl = mapping.get(data)
  2997:    273:             if lvl:
  2998:    274:                 self.config["RISK_LEVEL"] = lvl
  2999:    275:                 return f"Niveau de risque réglé sur {lvl}", self.main_keyboard
  3000:    276:             return "Niveau de risque inchangé", self.main_keyboard
  3001:    277: 
  3002:    278:         if data.startswith("maxpos_"):
  3003:    279:             try:
  3004:    280:                 lvl = int(data.split("_", 1)[1])
  3005:    281:             except Exception:
  3006:    282:                 lvl = None
  3007:    283:             if lvl:
  3008:    284:                 self.config["MAX_POSITIONS"] = lvl
  3009:    285:                 self.risk_mgr.max_positions = lvl
  3010:    286:                 return f"Nombre de positions réglé sur {lvl}", self.main_keyboard
  3011:    287:             return "Nombre de positions inchangé", self.main_keyboard
  3012:    288: 
  3013:    289:         if data == "reset_all":
  3014:    290:             try:
  3015:    291:                 self.client.close_all_positions()
  3016:    292:                 self.risk_mgr.reset_day()
  3017:    293:                 return "Positions et risque réinitialisés", self.settings_keyboard
  3018:    294:             except Exception:
  3019:    295:                 return "Erreur lors du reset total", self.settings_keyboard
  3020:    296: 
  3021:    297:         if data == "stop":
  3022:    298:             pos = self.client.get_positions() or {}
  3023:    299:             if not (pos.get("data") or []):
  3024:    300:                 return "Aucune crypto sélectionnée", self.settings_keyboard
  3025:    301:             return "Choisissez la position à fermer:", self._build_stop_keyboard()
  3026:    302:         if data == "stop_all":
  3027:    303:             try:
  3028:    304:                 self.client.close_all_positions()
  3029:    305:                 return "Toutes les positions fermées", self.settings_keyboard
  3030:    306:             except Exception:
  3031:    307:                 return "Erreur arrêt trade", self.settings_keyboard
  3032:    308:         if data.startswith("stop_"):
  3033:    309:             sym = data[5:]
  3034:    310:             try:
  3035:    311:                 self.client.close_position(sym)
  3036:    312:                 return f"Position {sym} fermée", self.settings_keyboard
  3037:    313:             except Exception:
  3038:    314:                 return f"Erreur arrêt trade {sym}", self.settings_keyboard
  3039:    315: 
  3040:    316:         if data == "shutdown":
  3041:    317:             self.stop_requested = True
  3042:    318:             return "Arrêt du bot demandé", self.main_keyboard
  3043:    319: 
  3044:    320:         if data == "back":
  3045:    321:             return self._menu_text(session_pnl), self.main_keyboard
  3046:    322:         return None, None
  3047:    323: 
  3048:    324: 
  3049:    325: def init_telegram_bot(client: Any, config: Dict[str, Any], risk_mgr: Any) -> Optional[TelegramBot]:
  3050:    326:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  3051:    327:     chat_id = os.getenv("TELEGRAM_CHAT_ID")
  3052:    328:     if token and chat_id:
  3053:    329:         return TelegramBot(token, chat_id, client, config, risk_mgr)
  3054:    330:     return None
  3055: 
  3056: 
  3057: ## TRASH_20250823-124533/short_one_way.py (last modified: 2025-08-23 20:57:14)
  3058:      1: #!/usr/bin/env python3
  3059:      2: # -*- coding: utf-8 -*-
  3060:      3: """Example script to open a one-way short on Bitget futures.
  3061:      4: 
  3062:      5: This standalone script signs and sends a market sell order using the
  3063:      6: Bitget REST API. Environment variables required (defined in a `.env`
  3064:      7: file alongside this script):
  3065:      8: 
  3066:      9: - ``BITGET_BASE_URL`` (optional, defaults to ``https://api.bitget.com``)
  3067:     10: - ``BITGET_API_KEY``
  3068:     11: - ``BITGET_API_SECRET``
  3069:     12: - ``BITGET_API_PASSPHRASE``
  3070:     13: - ``BITGET_PRODUCT_TYPE`` (e.g. ``USDT-FUTURES``)
  3071:     14: - ``BITGET_MARGIN_COIN`` (e.g. ``USDT``)
  3072:     15: - ``BITGET_SYMBOL`` (e.g. ``BTCUSDT``)
  3073:     16: - ``BITGET_TEST_NOTIONAL_USDT`` (trade notional for test order)
  3074:     17: 
  3075:     18: The script retrieves the current contract specification and price,
  3076:     19: ensures account settings (one-way mode & leverage) and finally places a
  3077:     20: market sell order sized to approximately ``BITGET_TEST_NOTIONAL_USDT``.
  3078:     21: 
  3079:     22: The intent is purely demonstrational; use at your own risk.
  3080:     23: """
  3081:     24: 
  3082:     25: import base64
  3083:     26: import hashlib
  3084:     27: import hmac
  3085:     28: import json
  3086:     29: import os
  3087:     30: import sys
  3088:     31: import time
  3089:     32: import uuid
  3090:     33: from pathlib import Path
  3091:     34: 
  3092:     35: import requests
  3093:     36: 
  3094:     37: try:  # lazy dependency import for dotenv
  3095:     38:     from dotenv import load_dotenv
  3096:     39: except ImportError:  # pragma: no cover - installation fallback
  3097:     40:     import subprocess
  3098:     41: 
  3099:     42:     subprocess.check_call([sys.executable, "-m", "pip", "install", "python-dotenv"])
  3100:     43:     from dotenv import load_dotenv
  3101:     44: 
  3102:     45: # load environment variables
  3103:     46: load_dotenv(Path(__file__).resolve().parent / ".env")
  3104:     47: 
  3105:     48: 
  3106:     49: def T(x):  # small helper used throughout configuration
  3107:     50:     return x.strip() if isinstance(x, str) else x
  3108:     51: 
  3109:     52: 
  3110:     53: BASE = T(os.getenv("BITGET_BASE_URL", "https://api.bitget.com"))
  3111:     54: AK = T(os.getenv("BITGET_API_KEY"))
  3112:     55: SK = T(os.getenv("BITGET_API_SECRET"))
  3113:     56: PH = T(os.getenv("BITGET_API_PASSPHRASE"))
  3114:     57: PT = T(os.getenv("BITGET_PRODUCT_TYPE", "USDT-FUTURES")).upper()
  3115:     58: MC = T(os.getenv("BITGET_MARGIN_COIN", "USDT"))
  3116:     59: SYMB = (T(os.getenv("BITGET_SYMBOL", "BTCUSDT")) or "BTCUSDT").replace("_", "").upper()
  3117:     60: NOTIONAL = float(os.getenv("BITGET_TEST_NOTIONAL_USDT", "5.0"))
  3118:     61: 
  3119:     62: if not (AK and SK and PH):
  3120:     63:     sys.exit("❌ .env incomplet (BITGET_API_KEY/SECRET/PASSPHRASE).")
  3121:     64: 
  3122:     65: print(f"Base={BASE}  PT={PT}  SYMB={SYMB}  MC={MC}  Notional≈{NOTIONAL}USDT")
  3123:     66: 
  3124:     67: 
  3125:     68: # ---------- signing helpers ----------
  3126:     69: def sign_get(ts, path, params):
  3127:     70:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  3128:     71:     pre = f"{ts}GET{path}" + (f"?{qs}" if qs else "")
  3129:     72:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  3130:     73:     return sig, qs
  3131:     74: 
  3132:     75: 
  3133:     76: def sign_post(ts, path, body, params=None):
  3134:     77:     qs = "&".join(f"{k}={v}" for k, v in sorted((params or {}).items()))
  3135:     78:     body_str = json.dumps(body or {}, separators=(",", ":"), sort_keys=True, ensure_ascii=False)
  3136:     79:     pre = f"{ts}POST{path}" + (f"?{qs}" if qs else "") + body_str
  3137:     80:     sig = base64.b64encode(hmac.new(SK.encode(), pre.encode(), hashlib.sha256).digest()).decode()
  3138:     81:     return sig, body_str, qs
  3139:     82: 
  3140:     83: 
  3141:     84: def headers(sig, ts):
  3142:     85:     return {
  3143:     86:         "ACCESS-KEY": AK,
  3144:     87:         "ACCESS-SIGN": sig,
  3145:     88:         "ACCESS-TIMESTAMP": str(ts),
  3146:     89:         "ACCESS-PASSPHRASE": PH,
  3147:     90:         "ACCESS-RECV-WINDOW": "60000",
  3148:     91:         "Content-Type": "application/json",
  3149:     92:     }
  3150:     93: 
  3151:     94: 
  3152:     95: def pick_price(d: dict):
  3153:     96:     for k in ("last", "price", "close", "bestAsk", "bestBid", "markPrice", "settlementPrice"):
  3154:     97:         try:
  3155:     98:             v = float(d.get(k))
  3156:     99:             if v > 0:
  3157:    100:                 return v
  3158:    101:         except Exception:
  3159:    102:             pass
  3160:    103:     return None
  3161:    104: 
  3162:    105: 
  3163:    106: # ---------- public endpoints ----------
  3164:    107: def get_contract_spec():
  3165:    108:     r = requests.get(
  3166:    109:         f"{BASE}/api/v2/mix/market/contracts",
  3167:    110:         params={"productType": PT, "symbol": SYMB},
  3168:    111:         timeout=12,
  3169:    112:     )
  3170:    113:     r.raise_for_status()
  3171:    114:     arr = r.json().get("data") or []
  3172:    115:     if not arr:
  3173:    116:         raise RuntimeError("Contrat introuvable")
  3174:    117:     return arr[0]
  3175:    118: 
  3176:    119: 
  3177:    120: def get_price():
  3178:    121:     # 1) ticker (obj/list) avec productType
  3179:    122:     try:
  3180:    123:         r = requests.get(
  3181:    124:             f"{BASE}/api/v2/mix/market/ticker",
  3182:    125:             params={"symbol": SYMB, "productType": PT},
  3183:    126:             timeout=10,
  3184:    127:         )
  3185:    128:         r.raise_for_status()
  3186:    129:         data = r.json().get("data")
  3187:    130:         if isinstance(data, dict):
  3188:    131:             p = pick_price(data)
  3189:    132:             if p:
  3190:    133:                 return p
  3191:    134:         if isinstance(data, list) and data:
  3192:    135:             p = pick_price(data[0])
  3193:    136:             if p:
  3194:    137:                 return p
  3195:    138:     except requests.HTTPError as e:
  3196:    139:         print("⚠️ ticker HTTP:", e.response.status_code, e.response.text[:140])
  3197:    140:     except Exception as e:
  3198:    141:         print("⚠️ ticker err:", e)
  3199:    142: 
  3200:    143:     # 2) tickers (liste entière)
  3201:    144:     try:
  3202:    145:         r = requests.get(
  3203:    146:             f"{BASE}/api/v2/mix/market/tickers",
  3204:    147:             params={"productType": PT},
  3205:    148:             timeout=10,
  3206:    149:         )
  3207:    150:         r.raise_for_status()
  3208:    151:         arr = r.json().get("data") or []
  3209:    152:         row = next((x for x in arr if (x.get("symbol") or "").upper() == SYMB), None)
  3210:    153:         p = pick_price(row or {})
  3211:    154:         if p:
  3212:    155:             return p
  3213:    156:     except requests.HTTPError as e:
  3214:    157:         print("⚠️ tickers HTTP:", e.response.status_code, e.response.text[:140])
  3215:    158:     except Exception as e:
  3216:    159:         print("⚠️ tickers err:", e)
  3217:    160: 
  3218:    161:     # 3) candles 1m (close)
  3219:    162:     try:
  3220:    163:         # ``symbol`` must be provided as a query parameter; placing it in the
  3221:    164:         # path triggers a 404 response from Bitget.
  3222:    165:         r = requests.get(
  3223:    166:             f"{BASE}/api/v2/mix/market/candles",
  3224:    167:             params={"symbol": SYMB, "granularity": "1m"},
  3225:    168:             timeout=10,
  3226:    169:         )
  3227:    170:         r.raise_for_status()
  3228:    171:         arr = r.json().get("data") or []
  3229:    172:         if arr:
  3230:    173:             return float(arr[0][4])
  3231:    174:     except requests.HTTPError as e:
  3232:    175:         print("⚠️ candles HTTP:", e.response.status_code, e.response.text[:140])
  3233:    176:     except Exception as e:
  3234:    177:         print("⚠️ candles err:", e)
  3235:    178: 
  3236:    179:     raise RuntimeError("prix indisponible")
  3237:    180: 
  3238:    181: 
  3239:    182: # ---------- private endpoints ----------
  3240:    183: def check_accounts():
  3241:    184:     path = "/api/v2/mix/account/accounts"
  3242:    185:     ts = int(time.time() * 1000)
  3243:    186:     params = {"productType": PT}
  3244:    187:     sig, qs = sign_get(ts, path, params)
  3245:    188:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  3246:    189:     r = requests.get(url, headers=headers(sig, ts), timeout=12)
  3247:    190:     print("accounts", r.status_code, r.text[:160])
  3248:    191:     r.raise_for_status()
  3249:    192:     j = r.json()
  3250:    193:     if str(j.get("code")) not in ("00000", "0"):
  3251:    194:         raise RuntimeError(j)
  3252:    195: 
  3253:    196: 
  3254:    197: def set_position_mode_one_way():
  3255:    198:     path = "/api/v2/mix/account/set-position-mode"
  3256:    199:     ts = int(time.time() * 1000)
  3257:    200:     body = {"productType": PT, "symbol": SYMB, "posMode": "one_way_mode"}
  3258:    201:     sig, b, qs = sign_post(ts, path, body)
  3259:    202:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  3260:    203:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  3261:    204:     print("set-position-mode(one-way)", r.status_code, r.text[:160])
  3262:    205:     r.raise_for_status()
  3263:    206: 
  3264:    207: 
  3265:    208: def set_leverage(lv: int = 2):
  3266:    209:     path = "/api/v2/mix/account/set-leverage"
  3267:    210:     ts = int(time.time() * 1000)
  3268:    211:     body = {"symbol": SYMB, "productType": PT, "marginCoin": MC, "leverage": int(lv)}
  3269:    212:     sig, b, qs = sign_post(ts, path, body)
  3270:    213:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  3271:    214:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=12)
  3272:    215:     print("set-leverage", r.status_code, r.text[:160])
  3273:    216:     r.raise_for_status()
  3274:    217: 
  3275:    218: 
  3276:    219: def place_one_way_sell(size_coin: float):
  3277:    220:     """Ouvre un SHORT en one_way_mode (market SELL)."""
  3278:    221:     path = "/api/v2/mix/order/place-order"
  3279:    222:     ts = int(time.time() * 1000)
  3280:    223:     body = {
  3281:    224:         "symbol": SYMB,
  3282:    225:         "productType": PT,
  3283:    226:         "marginCoin": MC,
  3284:    227:         "marginMode": "crossed",
  3285:    228:         "posMode": "one_way_mode",
  3286:    229:         "orderType": "market",
  3287:    230:         "side": "sell",  # <-- SHORT
  3288:    231:         "size": str(size_coin),
  3289:    232:         "timeInForceValue": "normal",
  3290:    233:         "clientOid": str(uuid.uuid4())[:32],
  3291:    234:     }
  3292:    235:     sig, b, qs = sign_post(ts, path, body)
  3293:    236:     url = f"{BASE}{path}" + (f"?{qs}" if qs else "")
  3294:    237:     r = requests.post(url, headers=headers(sig, ts), data=b.encode(), timeout=15)
  3295:    238:     print("place-order(one-way SELL)", r.status_code, r.text[:220])
  3296:    239:     r.raise_for_status()
  3297:    240:     j = r.json()
  3298:    241:     if str(j.get("code")) not in ("00000", "0"):
  3299:    242:         raise RuntimeError(j)
  3300:    243:     return j
  3301:    244: 
  3302:    245: 
  3303:    246: # ---------- main ----------
  3304:    247: def main():
  3305:    248:     spec = get_contract_spec()
  3306:    249:     min_usdt = float(spec.get("minTradeUSDT") or 5)
  3307:    250:     min_num = float(spec.get("minTradeNum") or 0)
  3308:    251:     size_place = int(spec.get("sizePlace") or 6)
  3309:    252:     print(f"Spec OK | minUSDT={min_usdt} minNum={min_num} sizePlace={size_place}")
  3310:    253: 
  3311:    254:     px = get_price()
  3312:    255:     print(f"Prix OK ≈ {px}")
  3313:    256: 
  3314:    257:     check_accounts()
  3315:    258:     set_position_mode_one_way()
  3316:    259:     set_leverage(2)
  3317:    260: 
  3318:    261:     target = max(NOTIONAL, min_usdt)
  3319:    262:     size = max(target / px, min_num)
  3320:    263:     size = float(f"{size:.{size_place}f}")
  3321:    264:     print(f"Taille={size} (target≈{target}USDT)")
  3322:    265: 
  3323:    266:     j = place_one_way_sell(size)
  3324:    267:     print("✅ SHORT OK")
  3325:    268:     print(json.dumps(j, indent=2, ensure_ascii=False))
  3326:    269: 
  3327:    270: 
  3328:    271: if __name__ == "__main__":  # pragma: no cover - script entrypoint
  3329:    272:     main()
  3330: 
  3331: 
  3332: ## bot.py (last modified: 2025-08-24 03:12:00)
  3333:      1: # bot.py
  3334:      2: from __future__ import annotations
  3335:      3: 
  3336:      4: import asyncio
  3337:      5: import os
  3338:      6: import sys
  3339:      7: import json
  3340:      8: from dataclasses import dataclass
  3341:      9: from pathlib import Path
  3342:     10: from typing import Sequence, Optional
  3343:     11: 
  3344:     12: # --- utils ---
  3345:     13: 
  3346:     14: def ensure_ccxt() -> None:
  3347:     15:     try:
  3348:     16:         import ccxt  # noqa: F401
  3349:     17:     except ImportError:
  3350:     18:         import subprocess
  3351:     19:         print("[setup] ccxt manquant, installation…")
  3352:     20:         subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "ccxt"])
  3353:     21:         import ccxt  # noqa: F401
  3354:     22: 
  3355:     23: def getenv(name: str, default: str = "") -> str:
  3356:     24:     """Lit d’abord les variables d’environnement, sinon .env local s’il existe."""
  3357:     25:     val = os.environ.get(name)
  3358:     26:     if val is not None:
  3359:     27:         return val
  3360:     28:     dot = Path(".env")
  3361:     29:     if dot.exists():
  3362:     30:         for line in dot.read_text().splitlines():
  3363:     31:             line = line.strip()
  3364:     32:             if not line or line.startswith("#") or "=" not in line:
  3365:     33:                 continue
  3366:     34:             k, v = line.split("=", 1)
  3367:     35:             if k == name:
  3368:     36:                 return v
  3369:     37:     return default
  3370:     38: 
  3371:     39: # --- config ---
  3372:     40: 
  3373:     41: @dataclass
  3374:     42: class RunConfig:
  3375:     43:     symbols: Sequence[str]
  3376:     44:     live_tf: str
  3377:     45:     data_dir: Path
  3378:     46:     csv_min_rows: int = 200           # seuil minimal d’un CSV “ok”
  3379:     47:     ready_flag: Path = Path("scalp/.ready.json")
  3380:     48: 
  3381:     49: # --- notifier (Telegram ou Null) ---
  3382:     50: 
  3383:     51: class NullNotifier:
  3384:     52:     async def send(self, msg: str) -> None:
  3385:     53:         print(f"[notify:null] {msg}")
  3386:     54: 
  3387:     55: async def build_notifier_and_commands() -> tuple[object, object]:
  3388:     56:     """Retourne (notifier, command_stream). Ici soit Telegram, soit Null."""
  3389:     57:     bot_token = getenv("TELEGRAM_BOT_TOKEN")
  3390:     58:     chat_id   = getenv("TELEGRAM_CHAT_ID")
  3391:     59:     if bot_token and chat_id:
  3392:     60:         # Implémentation simple via httpx/aiohttp → pour garder le fichier autonome, on renvoie un proxy minimal.
  3393:     61:         class TelegramNotifier:
  3394:     62:             def __init__(self, token: str, chat: str):
  3395:     63:                 self.token = token
  3396:     64:                 self.chat  = chat
  3397:     65:             async def send(self, msg: str) -> None:
  3398:     66:                 # en mode simple: on n’échoue pas si Telegram refuse le markdown
  3399:     67:                 import aiohttp
  3400:     68:                 url = f"https://api.telegram.org/bot{self.token}/sendMessage"
  3401:     69:                 payload = {"chat_id": self.chat, "text": msg, "disable_web_page_preview": True, "parse_mode": "Markdown"}
  3402:     70:                 try:
  3403:     71:                     async with aiohttp.ClientSession() as sess:
  3404:     72:                         async with sess.post(url, json=payload, timeout=15) as r:
  3405:     73:                             if r.status >= 400:
  3406:     74:                                 txt = await r.text()
  3407:     75:                                 print(f"[notify:telegram] send fail {r.status}: {txt[:180]}")
  3408:     76:                 except Exception as e:
  3409:     77:                     print(f"[notify:telegram] send error: {e}")
  3410:     78: 
  3411:     79:         notifier = TelegramNotifier(bot_token, chat_id)
  3412:     80:         # Pas de commandes interactives dans cette version : on renvoie un stream “nul”
  3413:     81:         return notifier, None
  3414:     82:     else:
  3415:     83:         print("[notify] TELEGRAM non configuré → Null notifier.")
  3416:     84:         return NullNotifier(), None
  3417:     85: 
  3418:     86: # --- préchauffage cache CSV ---
  3419:     87: 
  3420:     88: def csv_ok(p: Path, min_rows: int) -> bool:
  3421:     89:     if not p.exists():
  3422:     90:         return False
  3423:     91:     try:
  3424:     92:         # compte rapide des lignes
  3425:     93:         n = sum(1 for _ in p.open("r", encoding="utf-8", errors="ignore"))
  3426:     94:         return n >= min_rows
  3427:     95:     except Exception:
  3428:     96:         return False
  3429:     97: 
  3430:     98: async def prewarm_cache(cfg: RunConfig) -> None:
  3431:     99:     cfg.data_dir.mkdir(parents=True, exist_ok=True)
  3432:    100:     ok = True
  3433:    101:     for sym in cfg.symbols:
  3434:    102:         csv = cfg.data_dir / f"{sym}-{cfg.live_tf}.csv"
  3435:    103:         if csv_ok(csv, cfg.csv_min_rows):
  3436:    104:             print(f"[cache] ready -> {csv.relative_to(Path.cwd())}")
  3437:    105:         else:
  3438:    106:             ok = False
  3439:    107:             print(f"[cache] MISSING for {sym} -> {csv.relative_to(Path.cwd())}")
  3440:    108:     # ici on ne fetch pas pour rester autonome ; tu as déjà so.py si besoin
  3441:    109: 
  3442:    110: # --- orchestrateur glue ---
  3443:    111: 
  3444:    112: # ⛔️ ADAPTE CE CHEMIN SI TON WRAPPER N’EST PAS ICI
  3445:    113: # ex: from scalper.services.market import BitgetExchange
  3446:    114: from scalper.exchanges.bitget import BitgetExchange  # <-- ajuste ce chemin si besoin
  3447:    115: 
  3448:    116: async def run_orchestrator(exchange, cfg: RunConfig, notifier, command_stream=None):
  3449:    117:     """
  3450:    118:     Adapte-toi à la signature de ton vrai orchestrateur si tu en utilises un.
  3451:    119:     Ici on illustre une boucle “heartbeat + ticks_total” minimale.
  3452:    120:     """
  3453:    121:     ticks_total = 0
  3454:    122:     await notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  3455:    123:     try:
  3456:    124:         while True:
  3457:    125:             await asyncio.sleep(30)
  3458:    126:             await notifier.send(f"[stats] ticks_total={ticks_total} (+0 /30s) | pairs={','.join(cfg.symbols)}")
  3459:    127:     except asyncio.CancelledError:
  3460:    128:         await notifier.send("🛑 Arrêt orchestrateur.")
  3461:    129:         raise
  3462:    130: 
  3463:    131: # --- setup + ready flag ---
  3464:    132: 
  3465:    133: def write_ready_flag(cfg: RunConfig, reason: str = "ok") -> None:
  3466:    134:     cfg.ready_flag.parent.mkdir(parents=True, exist_ok=True)
  3467:    135:     cfg.ready_flag.write_text(json.dumps({"status": "ok", "reason": reason}, ensure_ascii=False, indent=2))
  3468:    136: 
  3469:    137: def is_ready(cfg: RunConfig) -> bool:
  3470:    138:     return cfg.ready_flag.exists()
  3471:    139: 
  3472:    140: async def setup_once(cfg: RunConfig, notifier) -> None:
  3473:    141:     await prewarm_cache(cfg)
  3474:    142:     await notifier.send("Setup wizard terminé (cache vérifié).")
  3475:    143:     write_ready_flag(cfg, "cache verified")
  3476:    144: 
  3477:    145: # --- lance l’orchestrateur avec shim .symbols/.timeframe ---
  3478:    146: 
  3479:    147: async def launch_orchestrator(cfg: RunConfig):
  3480:    148:     notifier, command_stream = await build_notifier_and_commands()
  3481:    149: 
  3482:    150:     # Setup si nécessaire
  3483:    151:     if not is_ready(cfg):
  3484:    152:         await notifier.send("Setup requis → exécution…")
  3485:    153:         await setup_once(cfg, notifier)
  3486:    154:         await notifier.send(f"[setup] flag écrit -> {cfg.ready_flag}")
  3487:    155: 
  3488:    156:     # Crée l’exchange
  3489:    157:     ex = BitgetExchange(
  3490:    158:         api_key=getenv("BITGET_ACCESS"),
  3491:    159:         secret=getenv("BITGET_SECRET"),
  3492:    160:         password=getenv("BITGET_PASSPHRASE"),
  3493:    161:         data_dir=str(cfg.data_dir),
  3494:    162:         use_cache=True,
  3495:    163:         spot=True,
  3496:    164:     )
  3497:    165: 
  3498:    166:     # --- SHIM IMPORTANT : certains orchestrateurs lisent exchange.symbols / exchange.timeframe
  3499:    167:     if not hasattr(ex, "symbols"):
  3500:    168:         setattr(ex, "symbols", tuple(cfg.symbols))
  3501:    169:     if not hasattr(ex, "timeframe"):
  3502:    170:         setattr(ex, "timeframe", cfg.live_tf)
  3503:    171: 
  3504:    172:     # Démarre l’orchestrateur (remplace par ton vrai import/runner si tu en as un)
  3505:    173:     await run_orchestrator(ex, cfg, notifier, command_stream)
  3506:    174: 
  3507:    175: # --- main ---
  3508:    176: 
  3509:    177: async def main():
  3510:    178:     ensure_ccxt()
  3511:    179:     symbols = (
  3512:    180:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  3513:    181:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  3514:    182:     )
  3515:    183:     cfg = RunConfig(
  3516:    184:         symbols=symbols,
  3517:    185:         live_tf="5m",
  3518:    186:         data_dir=Path("scalp/data"),
  3519:    187:     )
  3520:    188:     await launch_orchestrator(cfg)
  3521:    189: 
  3522:    190: if __name__ == "__main__":
  3523:    191:     try:
  3524:    192:         asyncio.run(main())
  3525:    193:     except KeyboardInterrupt:
  3526:    194:         pass
  3527: 
  3528: ## cli.py (last modified: 2025-08-23 20:57:14)
  3529:      1: """Command line utilities for the Scalp project.
  3530:      2: 
  3531:      3: This module exposes a small command line interface used throughout the
  3532:      4: project.  The actual trading logic lives in other modules, however the CLI is
  3533:      5: responsible for parsing parameters and dispatching the appropriate routines.
  3534:      6: 
  3535:      7: The implementation intentionally keeps the invoked functions minimal so that
  3536:      8: tests can patch them easily.  In a real deployment these functions would
  3537:      9: perform optimisation, walk‑forward analysis or run the live pipeline.
  3538:     10: """
  3539:     11: 
  3540:     12: from __future__ import annotations
  3541:     13: 
  3542:     14: import argparse
  3543:     15: import asyncio
  3544:     16: from typing import Iterable, List
  3545:     17: 
  3546:     18: from scalper.version import bump_version_from_git
  3547:     19: 
  3548:     20: 
  3549:     21: # ---------------------------------------------------------------------------
  3550:     22: # Placeholder implementations
  3551:     23: # ---------------------------------------------------------------------------
  3552:     24: 
  3553:     25: 
  3554:     26: def run_parallel_optimization(pairs: List[str], timeframe: str, jobs: int) -> None:
  3555:     27:     """Run a parallel parameter optimisation.
  3556:     28: 
  3557:     29:     The real project dispatches a potentially heavy optimisation routine.  The
  3558:     30:     function is kept trivial so unit tests can verify that the CLI wiring works
  3559:     31:     without actually performing the optimisation.
  3560:     32:     """
  3561:     33: 
  3562:     34:     print(f"Optimising {pairs} on {timeframe} with {jobs} jobs")
  3563:     35: 
  3564:     36: 
  3565:     37: def run_walkforward_analysis(
  3566:     38:     pair: str, timeframe: str, splits: int, train_ratio: float
  3567:     39: ) -> None:
  3568:     40:     """Execute a walk-forward analysis."""
  3569:     41: 
  3570:     42:     print(
  3571:     43:         f"Walk-forward on {pair} ({timeframe}), splits={splits}, train_ratio={train_ratio}"
  3572:     44:     )
  3573:     45: 
  3574:     46: 
  3575:     47: async def run_live_pipeline(pairs: List[str], tfs: Iterable[str]) -> None:
  3576:     48:     """Run the live trading pipeline."""
  3577:     49: 
  3578:     50:     print(f"Running live pipeline for pairs={pairs} on tfs={list(tfs)}")
  3579:     51: 
  3580:     52: 
  3581:     53: # ---------------------------------------------------------------------------
  3582:     54: # Argument parsing
  3583:     55: # ---------------------------------------------------------------------------
  3584:     56: 
  3585:     57: 
  3586:     58: def create_parser() -> argparse.ArgumentParser:
  3587:     59:     """Create the top-level argument parser."""
  3588:     60: 
  3589:     61:     parser = argparse.ArgumentParser(description="Scalp command line tools")
  3590:     62:     sub = parser.add_subparsers(dest="command")
  3591:     63: 
  3592:     64:     # --- ``opt`` command -------------------------------------------------
  3593:     65:     opt_p = sub.add_parser("opt", help="run optimisation in parallel")
  3594:     66:     opt_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  3595:     67:     opt_p.add_argument("--tf", required=True, help="timeframe")
  3596:     68:     opt_p.add_argument("--jobs", type=int, default=1, help="number of workers")
  3597:     69:     opt_p.set_defaults(
  3598:     70:         func=lambda a: run_parallel_optimization(a.pairs, a.tf, a.jobs)
  3599:     71:     )
  3600:     72: 
  3601:     73:     # --- ``walkforward`` command ----------------------------------------
  3602:     74:     wf_p = sub.add_parser("walkforward", help="perform walk-forward analysis")
  3603:     75:     wf_p.add_argument("--pair", required=True, help="trading pair")
  3604:     76:     wf_p.add_argument("--tf", required=True, help="timeframe")
  3605:     77:     wf_p.add_argument("--splits", type=int, default=1, help="number of splits")
  3606:     78:     wf_p.add_argument(
  3607:     79:         "--train-ratio",
  3608:     80:         type=float,
  3609:     81:         default=0.7,
  3610:     82:         help="portion of data used for training",
  3611:     83:     )
  3612:     84:     wf_p.set_defaults(
  3613:     85:         func=lambda a: run_walkforward_analysis(
  3614:     86:             a.pair, a.tf, a.splits, a.train_ratio
  3615:     87:         )
  3616:     88:     )
  3617:     89: 
  3618:     90:     # --- ``live`` command -----------------------------------------------
  3619:     91:     live_p = sub.add_parser("live", help="run the live async pipeline")
  3620:     92:     live_p.add_argument("--pairs", nargs="+", required=True, help="trading pairs")
  3621:     93:     live_p.add_argument("--tfs", nargs="+", required=True, help="timeframes")
  3622:     94:     live_p.set_defaults(func=lambda a: asyncio.run(run_live_pipeline(a.pairs, a.tfs)))
  3623:     95: 
  3624:     96:     # --- ``bump-version`` command -------------------------------------
  3625:     97:     bv_p = sub.add_parser(
  3626:     98:         "bump-version",
  3627:     99:         help="update the VERSION file based on the latest git commit",
  3628:    100:     )
  3629:    101:     bv_p.set_defaults(func=lambda a: print(bump_version_from_git()))
  3630:    102: 
  3631:    103:     return parser
  3632:    104: 
  3633:    105: 
  3634:    106: def main(argv: Iterable[str] | None = None) -> int:
  3635:    107:     """Entry point used by tests and ``if __name__ == '__main__'`` block."""
  3636:    108: 
  3637:    109:     parser = create_parser()
  3638:    110:     args = parser.parse_args(argv)
  3639:    111:     if not hasattr(args, "func"):
  3640:    112:         parser.print_help()
  3641:    113:         return 0
  3642:    114:     result = args.func(args)
  3643:    115:     return 0 if result is None else int(result)
  3644:    116: 
  3645:    117: 
  3646:    118: if __name__ == "__main__":  # pragma: no cover - manual invocation
  3647:    119:     raise SystemExit(main())
  3648:    120: 
  3649: 
  3650: 
  3651: ## data/BTCUSDT-1m.csv (last modified: 2025-08-23 20:57:14)
  3652:      1: ts,open,high,low,close,volume
  3653:      2: 1625097600000,34000,34100,33950,34050,123.4
  3654:      3: 1625097660000,34050,34200,34000,34150,150.7
  3655:      4: 1625097720000,34150,34300,34100,34250,180.3
  3656:      5: 1625097780000,34250,34400,34200,34350,200.1
  3657:      6: 1625097840000,34350,34500,34300,34450,220.8
  3658: 
  3659: ## data/__init__.py (last modified: 2025-08-23 20:57:14)
  3660:      1: """Indicator computation helpers."""
  3661:      2: 
  3662:      3: from .indicators import compute_all
  3663:      4: 
  3664:      5: __all__ = ["compute_all"]
  3665: 
  3666: 
  3667: ## data/indicators.py (last modified: 2025-08-23 20:57:14)
  3668:      1: import pandas as pd
  3669:      2: 
  3670:      3: __all__ = ["compute_all"]
  3671:      4: 
  3672:      5: def compute_all(
  3673:      6:     df: pd.DataFrame,
  3674:      7:     *,
  3675:      8:     ema_fast: int = 20,
  3676:      9:     ema_slow: int = 50,
  3677:     10:     rsi_period: int = 14,
  3678:     11:     macd_fast: int = 12,
  3679:     12:     macd_slow: int = 26,
  3680:     13:     macd_signal: int = 9,
  3681:     14:     atr_period: int = 14,
  3682:     15:     swing_lookback: int = 5,
  3683:     16: ) -> pd.DataFrame:
  3684:     17:     """Compute common indicators and return enriched DataFrame.
  3685:     18: 
  3686:     19:     Parameters
  3687:     20:     ----------
  3688:     21:     df : pd.DataFrame
  3689:     22:         DataFrame containing at least ``open``, ``high``, ``low``, ``close`` and
  3690:     23:         ``volume`` columns ordered chronologically.
  3691:     24: 
  3692:     25:     Returns
  3693:     26:     -------
  3694:     27:     pd.DataFrame
  3695:     28:         New DataFrame with additional indicator columns.
  3696:     29:     """
  3697:     30: 
  3698:     31:     if df.empty:
  3699:     32:         return df.copy()
  3700:     33: 
  3701:     34:     df = df.copy()
  3702:     35: 
  3703:     36:     # --- VWAP ---------------------------------------------------------------
  3704:     37:     typical = (df["high"] + df["low"] + df["close"]) / 3.0
  3705:     38:     vwap = (typical * df["volume"]).cumsum() / df["volume"].cumsum()
  3706:     39:     df["vwap"] = vwap
  3707:     40: 
  3708:     41:     # --- EMAs ---------------------------------------------------------------
  3709:     42:     df["ema20"] = df["close"].ewm(span=ema_fast, adjust=False).mean()
  3710:     43:     df["ema50"] = df["close"].ewm(span=ema_slow, adjust=False).mean()
  3711:     44: 
  3712:     45:     # --- RSI ----------------------------------------------------------------
  3713:     46:     delta = df["close"].diff()
  3714:     47:     gain = delta.where(delta > 0, 0.0)
  3715:     48:     loss = -delta.where(delta < 0, 0.0)
  3716:     49:     avg_gain = gain.rolling(rsi_period).mean()
  3717:     50:     avg_loss = loss.rolling(rsi_period).mean()
  3718:     51:     rs = avg_gain / avg_loss
  3719:     52:     rsi = 100 - (100 / (1 + rs))
  3720:     53:     df["rsi"] = rsi.fillna(50.0)
  3721:     54: 
  3722:     55:     # --- MACD ---------------------------------------------------------------
  3723:     56:     ema_fast_series = df["close"].ewm(span=macd_fast, adjust=False).mean()
  3724:     57:     ema_slow_series = df["close"].ewm(span=macd_slow, adjust=False).mean()
  3725:     58:     macd = ema_fast_series - ema_slow_series
  3726:     59:     signal = macd.ewm(span=macd_signal, adjust=False).mean()
  3727:     60:     df["macd"] = macd
  3728:     61:     df["macd_signal"] = signal
  3729:     62:     df["macd_hist"] = macd - signal
  3730:     63: 
  3731:     64:     # --- OBV ----------------------------------------------------------------
  3732:     65:     obv = [0.0]
  3733:     66:     closes = df["close"].tolist()
  3734:     67:     vols = df["volume"].tolist()
  3735:     68:     for i in range(1, len(df)):
  3736:     69:         if closes[i] > closes[i - 1]:
  3737:     70:             obv.append(obv[-1] + vols[i])
  3738:     71:         elif closes[i] < closes[i - 1]:
  3739:     72:             obv.append(obv[-1] - vols[i])
  3740:     73:         else:
  3741:     74:             obv.append(obv[-1])
  3742:     75:     df["obv"] = obv
  3743:     76: 
  3744:     77:     # --- ATR ----------------------------------------------------------------
  3745:     78:     high_low = df["high"] - df["low"]
  3746:     79:     high_close = (df["high"] - df["close"].shift()).abs()
  3747:     80:     low_close = (df["low"] - df["close"].shift()).abs()
  3748:     81:     tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
  3749:     82:     df["atr"] = tr.rolling(atr_period).mean()
  3750:     83: 
  3751:     84:     # --- Swing highs/lows ---------------------------------------------------
  3752:     85:     df["swing_high"] = df["high"].rolling(window=swing_lookback).max()
  3753:     86:     df["swing_low"] = df["low"].rolling(window=swing_lookback).min()
  3754:     87: 
  3755:     88:     return df
  3756: 
  3757: 
  3758: ## init.py (last modified: 2025-08-23 20:57:14)
  3759:      1: #!/usr/bin/env python3
  3760:      2: """Install all project dependencies.
  3761:      3: 
  3762:      4: Run this script once to install every ``requirements*.txt`` file found in the
  3763:      5: repository as well as the packages needed for the test suite.  All subsequent
  3764:      6: invocations of the bot or its submodules will then share the same Python
  3765:      7: environment with the required dependencies available.
  3766:      8: """
  3767:      9: 
  3768:     10: from __future__ import annotations
  3769:     11: 
  3770:     12: import subprocess
  3771:     13: import sys
  3772:     14: from pathlib import Path
  3773:     15: 
  3774:     16: 
  3775:     17: def install_packages(*args: str) -> None:
  3776:     18:     """Install packages using pip for the current Python interpreter."""
  3777:     19:     cmd = [sys.executable, "-m", "pip", "install", *args]
  3778:     20:     subprocess.check_call(cmd)
  3779:     21: 
  3780:     22: 
  3781:     23: def main() -> None:
  3782:     24:     repo_root = Path(__file__).resolve().parent
  3783:     25: 
  3784:     26:     # Install from any requirements*.txt file across the repository so that
  3785:     27:     # sub-packages with their own dependency lists are also covered.
  3786:     28:     for req in sorted(repo_root.rglob("requirements*.txt")):
  3787:     29:         install_packages("-r", str(req))
  3788:     30: 
  3789:     31:     # Ensure test dependencies are available
  3790:     32:     install_packages("pytest")
  3791:     33: 
  3792:     34: 
  3793:     35: if __name__ == "__main__":
  3794:     36:     main()
  3795: 
  3796: 
  3797: ## pytest.ini (last modified: 2025-08-23 20:57:14)
  3798:      1: [pytest]
  3799:      2: addopts = -q
  3800: 
  3801: 
  3802: ## requirements-dev.txt (last modified: 2025-08-23 20:57:14)
  3803:      1: pytest
  3804: 
  3805: 
  3806: ## requirements.txt (last modified: 2025-08-23 20:57:14)
  3807:      1: requests
  3808:      2: python-dotenv
  3809:      3: pydantic==1.10.15 ; python_version < "3.11"
  3810:      4: 
  3811:      5: # pydantic v1 déjà pin si environnement ancien
  3812:      6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)
  3813: 
  3814: 
  3815: ## scalper/VERSION (last modified: 2025-08-23 20:57:14)
  3816:      1: 0.3.0
  3817:      2: 
  3818: 
  3819: 
  3820: ## scalper/__init__.py (last modified: 2025-08-23 20:57:14)
  3821:      1: """Utilities and helpers for Scalp bot.
  3822:      2: 
  3823:      3: When the bot is executed from ``notebook/spot/bitget_bot.py`` it expects secret
  3824:      4: keys to live in ``notebook/.env``.  On import this module attempts to load the
  3825:      5: variables from that file so that API keys can remain outside of the repository
  3826:      6: yet still be available at runtime.
  3827:      7: """
  3828:      8: 
  3829:      9: from __future__ import annotations
  3830:     10: 
  3831:     11: import os
  3832:     12: from pathlib import Path
  3833:     13: import sys
  3834:     14: 
  3835:     15: 
  3836:     16: def _load_parent_env() -> None:
  3837:     17:     """Load environment variables from ``../.env`` relative to the entry script.
  3838:     18: 
  3839:     19:     The bot is typically launched from ``notebook/spot/bitget_bot.py`` and keys
  3840:     20:     are expected to be stored one directory above (``notebook/.env``).  If that
  3841:     21:     file is not found the function falls back to the historical behaviour of
  3842:     22:     checking ``../.env`` relative to the package itself.
  3843:     23:     """
  3844:     24: 
  3845:     25:     script_path = Path(sys.argv[0]).resolve()
  3846:     26:     env_file = script_path.parent.parent / ".env"
  3847:     27:     if not env_file.exists():
  3848:     28:         env_file = Path(__file__).resolve().parents[2] / ".env"
  3849:     29:         if not env_file.exists():
  3850:     30:             return
  3851:     31: 
  3852:     32:     try:
  3853:     33:         from dotenv import load_dotenv
  3854:     34: 
  3855:     35:         load_dotenv(env_file)
  3856:     36:     except Exception:  # pragma: no cover - optional dependency
  3857:     37:         for line in env_file.read_text().splitlines():
  3858:     38:             line = line.strip()
  3859:     39:             if not line or line.startswith("#") or "=" not in line:
  3860:     40:                 continue
  3861:     41:             key, value = line.split("=", 1)
  3862:     42:             os.environ.setdefault(key.strip(), value.strip().strip("'\""))
  3863:     43: 
  3864:     44: 
  3865:     45: _load_parent_env()
  3866:     46: 
  3867:     47: from .version import get_version, bump_version_from_message  # noqa: E402
  3868:     48: from .strategy import (  # noqa: E402
  3869:     49:     Signal,
  3870:     50:     scan_pairs,
  3871:     51:     select_active_pairs,
  3872:     52:     generate_signal,
  3873:     53:     backtest,
  3874:     54: )
  3875:     55: from .risk.manager import RiskManager  # noqa: E402
  3876:     56: 
  3877:     57: __all__ = [
  3878:     58:     "get_version",
  3879:     59:     "bump_version_from_message",
  3880:     60:     "__version__",
  3881:     61:     "Signal",
  3882:     62:     "scan_pairs",
  3883:     63:     "select_active_pairs",
  3884:     64:     "generate_signal",
  3885:     65:     "RiskManager",
  3886:     66:     "backtest",
  3887:     67: ]
  3888:     68: 
  3889:     69: __version__ = get_version()
  3890: 
  3891: 
  3892: ## scalper/adapters/__init__.py (last modified: 2025-08-23 20:57:14)
  3893: 
  3894: 
  3895: ## scalper/adapters/bitget.py (last modified: 2025-08-23 20:57:14)
  3896:      1: # scalp/adapters/bitget.py
  3897:      2: from __future__ import annotations
  3898:      3: from typing import Any, Dict, List, Optional
  3899:      4: import inspect, os
  3900:      5: import requests
  3901:      6: 
  3902:      7: # Client bas-niveau fourni par le repo
  3903:      8: from scalper.bitget_client import BitgetFuturesClient as _Base
  3904:      9: 
  3905:     10: 
  3906:     11: def _to_float(x, default: float = 0.0) -> float:
  3907:     12:     try:
  3908:     13:         return float(x)
  3909:     14:     except Exception:
  3910:     15:         return default
  3911:     16: 
  3912:     17: 
  3913:     18: def _select_base_url() -> str:
  3914:     19:     env = os.environ.get("BITGET_BASE_URL")
  3915:     20:     if env:
  3916:     21:         return env
  3917:     22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
  3918:     23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
  3919:     24: 
  3920:     25: 
  3921:     26: class BitgetFuturesClient(_Base):
  3922:     27:     """
  3923:     28:     Adaptateur Bitget:
  3924:     29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
  3925:     30:       - Normalisations robustes: assets, ticker(s), positions, fills
  3926:     31:     """
  3927:     32: 
  3928:     33:     # --------------------- INIT dynamique ---------------------
  3929:     34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
  3930:     35:         """
  3931:     36:         Accepte indifféremment:
  3932:     37:           api_key/apiKey/access_key/accessKey/key
  3933:     38:           api_secret/apiSecret/secret/secret_key/secretKey
  3934:     39:           passphrase/password/api_passphrase/apiPassphrase
  3935:     40:           base_url/baseUrl/host/endpoint (ou auto)
  3936:     41:         On n'envoie au client de base que les noms présents dans sa signature.
  3937:     42:         """
  3938:     43:         user_kwargs = dict(kwargs)
  3939:     44: 
  3940:     45:         # Collecte des valeurs possibles (tous alias)
  3941:     46:         incoming_key = (
  3942:     47:             user_kwargs.pop("api_key", None)
  3943:     48:             or user_kwargs.pop("apiKey", None)
  3944:     49:             or user_kwargs.pop("access_key", None)
  3945:     50:             or user_kwargs.pop("accessKey", None)
  3946:     51:             or user_kwargs.pop("key", None)
  3947:     52:             or user_kwargs.pop("API_KEY", None)
  3948:     53:         )
  3949:     54:         incoming_secret = (
  3950:     55:             user_kwargs.pop("api_secret", None)
  3951:     56:             or user_kwargs.pop("apiSecret", None)
  3952:     57:             or user_kwargs.pop("secret_key", None)
  3953:     58:             or user_kwargs.pop("secretKey", None)
  3954:     59:             or user_kwargs.pop("secret", None)
  3955:     60:             or user_kwargs.pop("API_SECRET", None)
  3956:     61:         )
  3957:     62:         incoming_pass = (
  3958:     63:             user_kwargs.pop("passphrase", None)
  3959:     64:             or user_kwargs.pop("password", None)
  3960:     65:             or user_kwargs.pop("api_passphrase", None)
  3961:     66:             or user_kwargs.pop("apiPassphrase", None)
  3962:     67:         )
  3963:     68:         incoming_base = (
  3964:     69:             user_kwargs.pop("base_url", None)
  3965:     70:             or user_kwargs.pop("baseUrl", None)
  3966:     71:             or user_kwargs.pop("host", None)
  3967:     72:             or user_kwargs.pop("endpoint", None)
  3968:     73:             or _select_base_url()
  3969:     74:         )
  3970:     75: 
  3971:     76:         # Signature réelle du client bas-niveau
  3972:     77:         sig = inspect.signature(_Base.__init__)
  3973:     78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
  3974:     79: 
  3975:     80:         def pick_name(cands: List[str]) -> Optional[str]:
  3976:     81:             for c in cands:
  3977:     82:                 if c in param_names:
  3978:     83:                     return c
  3979:     84:             return None
  3980:     85: 
  3981:     86:         # Noms réellement supportés
  3982:     87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
  3983:     88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
  3984:     89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
  3985:     90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
  3986:     91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
  3987:     92: 
  3988:     93:         # Construire kwargs à transmettre (une seule fois par nom)
  3989:     94:         base_kwargs: Dict[str, Any] = {}
  3990:     95:         if key_name and incoming_key is not None:
  3991:     96:             base_kwargs[key_name] = incoming_key
  3992:     97:         if sec_name and incoming_secret is not None:
  3993:     98:             base_kwargs[sec_name] = incoming_secret
  3994:     99:         if pas_name and incoming_pass is not None:
  3995:    100:             base_kwargs[pas_name] = incoming_pass
  3996:    101:         if base_name:
  3997:    102:             base_kwargs[base_name] = incoming_base
  3998:    103:         if req_mod_name:
  3999:    104:             base_kwargs[req_mod_name] = requests
  4000:    105: 
  4001:    106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
  4002:    107:         # qui n'a pas été défini ci-dessus, on le relaie.
  4003:    108:         for k, v in list(user_kwargs.items()):
  4004:    109:             if k in param_names and k not in base_kwargs:
  4005:    110:                 base_kwargs[k] = v
  4006:    111: 
  4007:    112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
  4008:    113:         super().__init__(**base_kwargs)
  4009:    114: 
  4010:    115:     # --------------------- COMPTES / ASSETS ---------------------
  4011:    116:     def get_assets(self) -> Dict[str, Any]:
  4012:    117:         raw = super().get_assets()
  4013:    118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
  4014:    119:         norm: List[Dict[str, Any]] = []
  4015:    120:         for a in data:
  4016:    121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
  4017:    122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
  4018:    123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
  4019:    124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
  4020:    125:         return {"success": True, "data": norm}
  4021:    126: 
  4022:    127:     # ------------------------ TICKER(S) -------------------------
  4023:    128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  4024:    129:         """
  4025:    130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
  4026:    131:         Tolère top-level dict/list et items dict/list.
  4027:    132:         """
  4028:    133:         try:
  4029:    134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
  4030:    135:         except Exception as e:
  4031:    136:             return {"success": False, "error": repr(e), "data": []}
  4032:    137: 
  4033:    138:         items: List[Any] = []
  4034:    139:         if isinstance(raw, dict):
  4035:    140:             d = raw.get("data")
  4036:    141:             if symbol and isinstance(d, dict):
  4037:    142:                 items = [d]
  4038:    143:             else:
  4039:    144:                 items = d or raw.get("result") or raw.get("tickers") or []
  4040:    145:         elif isinstance(raw, (list, tuple)):
  4041:    146:             items = list(raw)
  4042:    147: 
  4043:    148:         norm: List[Dict[str, Any]] = []
  4044:    149:         for t in items:
  4045:    150:             if isinstance(t, dict):
  4046:    151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
  4047:    152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
  4048:    153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
  4049:    154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
  4050:    155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
  4051:    156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
  4052:    157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
  4053:    158:                 norm.append({
  4054:    159:                     "symbol": s,
  4055:    160:                     "lastPrice": _to_float(last_),
  4056:    161:                     "bidPrice": _to_float(bid_),
  4057:    162:                     "askPrice": _to_float(ask_),
  4058:    163:                     "volume": volume
  4059:    164:                 })
  4060:    165:             else:
  4061:    166:                 seq = list(t)
  4062:    167:                 if len(seq) >= 5:
  4063:    168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
  4064:    169:                     if first_ts:
  4065:    170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
  4066:    171:                     else:
  4067:    172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
  4068:    173:                 else:
  4069:    174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
  4070:    175:                 s = (symbol or "").replace("_", "")
  4071:    176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
  4072:    177: 
  4073:    178:         return {"success": True, "data": norm}
  4074:    179: 
  4075:    180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
  4076:    181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  4077:    182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
  4078:    183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
  4079:    184:         out: List[Dict[str, Any]] = []
  4080:    185:         for p in items:
  4081:    186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
  4082:    187:             if symbol and s != symbol:
  4083:    188:                 continue
  4084:    189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
  4085:    190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
  4086:    191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
  4087:    192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
  4088:    193:         return {"success": True, "data": out}
  4089:    194: 
  4090:    195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
  4091:    196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
  4092:    197:         items = raw.get("data") or raw.get("result") or []
  4093:    198:         out: List[Dict[str, Any]] = []
  4094:    199:         for f in items[:limit]:
  4095:    200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
  4096:    201:             if s != symbol:
  4097:    202:                 continue
  4098:    203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
  4099:    204:                 continue
  4100:    205:             out.append({
  4101:    206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
  4102:    207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
  4103:    208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
  4104:    209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
  4105:    210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
  4106:    211:                 "ts": int(f.get("ts", f.get("time", 0))),
  4107:    212:             })
  4108:    213:         return {"success": True, "data": out}
  4109:    214: 
  4110:    215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
  4111:    216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
  4112:    217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
  4113:    218:         return {"success": ok, "data": {"orderId": order_id}}
  4114: 
  4115: ## scalper/adapters/bitget_fetch.py (last modified: 2025-08-23 20:57:14)
  4116:      1: # scalper/adapters/bitget_fetch.py
  4117:      2: from __future__ import annotations
  4118:      3: 
  4119:      4: import asyncio
  4120:      5: import inspect
  4121:      6: import os
  4122:      7: from typing import Any, Optional
  4123:      8: 
  4124:      9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  4125:     10: 
  4126:     11: def _log(msg: str) -> None:
  4127:     12:     if BT_DEBUG:
  4128:     13:         print(f"[bt.debug] {msg}", flush=True)
  4129:     14: 
  4130:     15: _TF_TO_SECS = {
  4131:     16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  4132:     17:     "1h": 3600, "4h": 14400, "1d": 86400,
  4133:     18: }
  4134:     19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
  4135:     20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  4136:     21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
  4137:     22: }
  4138:     23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
  4139:     24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
  4140:     25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
  4141:     26: }
  4142:     27: 
  4143:     28: def _await_if_needed(val: Any) -> Any:
  4144:     29:     if inspect.isawaitable(val):
  4145:     30:         try:
  4146:     31:             asyncio.get_running_loop()
  4147:     32:         except RuntimeError:
  4148:     33:             return asyncio.run(val)
  4149:     34:         else:
  4150:     35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
  4151:     36:             return fut.result()
  4152:     37:     return val
  4153:     38: 
  4154:     39: class BitgetFetchAdapter:
  4155:     40:     """
  4156:     41:     Adaptateur qui fournit une méthode CCXT-like:
  4157:     42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
  4158:     43:     au-dessus d'un client Bitget existant (sync ou async).
  4159:     44:     """
  4160:     45:     def __init__(self, client: Any, *, market_hint: str | None = None):
  4161:     46:         self.client = client
  4162:     47:         self.market_hint = (market_hint or "").lower() or None
  4163:     48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
  4164:     49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
  4165:     50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
  4166:     51: 
  4167:     52:     @staticmethod
  4168:     53:     def _possible_methods(client: Any) -> list[str]:
  4169:     54:         names = dir(client)
  4170:     55:         base = [
  4171:     56:             "fetch_ohlcv",
  4172:     57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
  4173:     58:             "klines", "get_klines", "kline",
  4174:     59:             "mix_get_candles", "mix_candles",
  4175:     60:             "spot_get_candles", "spot_candles",
  4176:     61:             "market_candles", "public_candles",
  4177:     62:         ]
  4178:     63:         # + heuristique: tout ce qui contient candle/kline
  4179:     64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
  4180:     65:         out = []
  4181:     66:         for n in base + extra:
  4182:     67:             if n in names and callable(getattr(client, n)) and n not in out:
  4183:     68:                 out.append(n)
  4184:     69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
  4185:     70:         return out
  4186:     71: 
  4187:     72:     @staticmethod
  4188:     73:     def _sym_variants(sym: str) -> list[str]:
  4189:     74:         s = sym.upper()
  4190:     75:         out = [s]
  4191:     76:         if not s.endswith("_UMCBL"):
  4192:     77:             out.append(f"{s}_UMCBL")
  4193:     78:         if not s.endswith("_SPBL"):
  4194:     79:             out.append(f"{s}_SPBL")
  4195:     80:         _log(f"Variantes symbole testées: {out}")
  4196:     81:         return out
  4197:     82: 
  4198:     83:     @staticmethod
  4199:     84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
  4200:     85:         secs = _TF_TO_SECS.get(timeframe, 300)
  4201:     86:         mix = _TF_TO_MIX.get(timeframe, "5min")
  4202:     87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
  4203:     88:         variants = []
  4204:     89:         if market_hint == "mix":
  4205:     90:             variants.append({"granularity": mix})
  4206:     91:         if market_hint == "spot":
  4207:     92:             variants.append({"period": spot})
  4208:     93:         variants += [
  4209:     94:             {"timeframe": timeframe},
  4210:     95:             {"interval": timeframe},
  4211:     96:             {"k": secs},
  4212:     97:             {"granularity": mix},
  4213:     98:             {"period": spot},
  4214:     99:         ]
  4215:    100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
  4216:    101:         return variants
  4217:    102: 
  4218:    103:     @staticmethod
  4219:    104:     def _normalize_rows(raw: Any) -> list[list[float]]:
  4220:    105:         import pandas as pd  # local import
  4221:    106:         if raw is None:
  4222:    107:             raise ValueError("OHLCV vide")
  4223:    108:         if isinstance(raw, dict) and "data" in raw:
  4224:    109:             raw = raw["data"]
  4225:    110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
  4226:    111:             out = []
  4227:    112:             for r in raw:
  4228:    113:                 ts = int(str(r[0]))
  4229:    114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
  4230:    115:                 out.append([ts, o, h, l, c, v])
  4231:    116:             return out
  4232:    117:         if "pandas" in str(type(raw)):
  4233:    118:             df = raw
  4234:    119:             if "timestamp" in df.columns:
  4235:    120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  4236:    121:                 df = df.set_index("timestamp").sort_index()
  4237:    122:             df = df[["open", "high", "low", "close", "volume"]]
  4238:    123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
  4239:    124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
  4240:    125: 
  4241:    126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
  4242:    127:         methods = self._possible_methods(self.client)
  4243:    128:         if not methods:
  4244:    129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
  4245:    130: 
  4246:    131:         last_err: Exception | None = None
  4247:    132:         for mname in methods:
  4248:    133:             fn = getattr(self.client, mname)
  4249:    134:             for sym in self._sym_variants(symbol):
  4250:    135:                 for par in self._param_variants(timeframe, self.market_hint):
  4251:    136:                     kwargs = dict(par)
  4252:    137:                     kwargs.setdefault("symbol", sym)
  4253:    138:                     kwargs.setdefault("limit", limit)
  4254:    139:                     if since is not None:
  4255:    140:                         kwargs.setdefault("since", since)
  4256:    141:                     try:
  4257:    142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
  4258:    143:                         res = _await_if_needed(fn(**kwargs))
  4259:    144:                         rows = self._normalize_rows(res)
  4260:    145:                         if rows:
  4261:    146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
  4262:    147:                             first = rows[0][0]; last = rows[-1][0]
  4263:    148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
  4264:    149:                                  f"t0={first} {unit}, t1={last} {unit}")
  4265:    150:                             return rows
  4266:    151:                     except TypeError as e:
  4267:    152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
  4268:    153:                         last_err = e
  4269:    154:                     except Exception as e:
  4270:    155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
  4271:    156:                         last_err = e
  4272:    157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
  4273:    158: 
  4274:    159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
  4275:    160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
  4276:    161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
  4277:    162:         _log("exchange.fetch_ohlcv() déjà présent.")
  4278:    163:         return exchange
  4279:    164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
  4280:    165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)
  4281: 
  4282: ## scalper/adapters/market_data.py (last modified: 2025-08-23 20:57:14)
  4283:      1: # scalper/backtest/market_data.py
  4284:      2: from __future__ import annotations
  4285:      3: 
  4286:      4: import os
  4287:      5: from pathlib import Path
  4288:      6: from typing import Any
  4289:      7: 
  4290:      8: import pandas as pd
  4291:      9: 
  4292:     10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  4293:     11: 
  4294:     12: def _log(msg: str) -> None:
  4295:     13:     if BT_DEBUG:
  4296:     14:         print(f"[bt.debug] {msg}", flush=True)
  4297:     15: 
  4298:     16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
  4299:     17:     root = Path(data_dir)
  4300:     18:     root.mkdir(parents=True, exist_ok=True)
  4301:     19:     tf = timeframe.replace(":", "")
  4302:     20:     return root / f"{symbol}-{tf}.csv"
  4303:     21: 
  4304:     22: def _read_csv(path: Path) -> pd.DataFrame:
  4305:     23:     _log(f"lecture CSV: {path}")
  4306:     24:     df = pd.read_csv(path)
  4307:     25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
  4308:     26:     if ts_col is None:
  4309:     27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
  4310:     28:     df = df.rename(columns={ts_col: "timestamp"})
  4311:     29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  4312:     30:     df = df.set_index("timestamp").sort_index()
  4313:     31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  4314:     32:     return df
  4315:     33: 
  4316:     34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  4317:     35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
  4318:     36:     if "timestamp" not in tmp.columns:
  4319:     37:         tmp = tmp.rename(columns={"index": "timestamp"})
  4320:     38:     tmp.to_csv(path, index=False)
  4321:     39:     _log(f"écrit CSV: {path} (n={len(df)})")
  4322:     40: 
  4323:     41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  4324:     42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
  4325:     43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
  4326:     44:     # Normalisation minimaliste (liste de listes)
  4327:     45:     rows = []
  4328:     46:     for r in raw:
  4329:     47:         ts = int(r[0])
  4330:     48:         unit = "ms" if ts > 10_000_000_000 else "s"
  4331:     49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
  4332:     50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
  4333:     51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
  4334:     52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
  4335:     53:     return df
  4336:     54: 
  4337:     55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
  4338:     56:     """
  4339:     57:     Loader hybride:
  4340:     58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
  4341:     59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
  4342:     60:     """
  4343:     61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  4344:     62:         path = _csv_path(data_dir, symbol, timeframe)
  4345:     63:         if path.exists():
  4346:     64:             df = _read_csv(path)
  4347:     65:             src = "csv"
  4348:     66:         else:
  4349:     67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
  4350:     68:             _write_csv(path, df)
  4351:     69:             src = "exchange"
  4352:     70:         if start:
  4353:     71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  4354:     72:         if end:
  4355:     73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  4356:     74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
  4357:     75:              f"range=[{df.index.min()} .. {df.index.max()}]")
  4358:     76:         return df
  4359:     77:     return load
  4360: 
  4361: ## scalper/backtest/__init__.py (last modified: 2025-08-23 20:57:14)
  4362:      1: # scalper/backtest/__init__.py
  4363:      2: from .runner import (
  4364:      3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
  4365:      4:     run_multi, run_single,  # mêmes signatures async
  4366:      5:     save_results,           # no-op compat
  4367:      6: )
  4368:      7: from .cache import (
  4369:      8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
  4370:      9:     tf_to_seconds,
  4371:     10: )
  4372: 
  4373: ## scalper/backtest/cache.py (last modified: 2025-08-23 20:57:14)
  4374:      1: # scalper/backtest/cache.py
  4375:      2: from __future__ import annotations
  4376:      3: 
  4377:      4: import csv
  4378:      5: import json
  4379:      6: import os
  4380:      7: import time
  4381:      8: from dataclasses import dataclass
  4382:      9: from pathlib import Path
  4383:     10: from typing import Dict, List, Tuple, Iterable, Optional
  4384:     11: 
  4385:     12: # ---------------- Timeframe utils ----------------
  4386:     13: 
  4387:     14: _TF_SECONDS = {
  4388:     15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  4389:     16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
  4390:     17:     "1d": 86400, "3d": 259200, "1w": 604800,
  4391:     18: }
  4392:     19: 
  4393:     20: def tf_to_seconds(tf: str) -> int:
  4394:     21:     tf = tf.strip().lower()
  4395:     22:     if tf not in _TF_SECONDS:
  4396:     23:         raise ValueError(f"Timeframe inconnu: {tf}")
  4397:     24:     return _TF_SECONDS[tf]
  4398:     25: 
  4399:     26: # ---------------- Fraîcheur cible par TF ----------------
  4400:     27: 
  4401:     28: _DEFAULT_MAX_AGE = {
  4402:     29:     # règle empirique (peut être surchargée par ENV)
  4403:     30:     "1m": 2 * 3600,        # 2h
  4404:     31:     "3m": 4 * 3600,        # 4h
  4405:     32:     "5m": 12 * 3600,       # 12h
  4406:     33:     "15m": 24 * 3600,      # 24h
  4407:     34:     "30m": 36 * 3600,      # 36h
  4408:     35:     "1h": 3 * 86400,       # 3 jours
  4409:     36:     "2h": 5 * 86400,       # 5 jours
  4410:     37:     "4h": 10 * 86400,      # 10 jours
  4411:     38:     "6h": 15 * 86400,      # 15 jours
  4412:     39:     "12h": 20 * 86400,     # 20 jours
  4413:     40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
  4414:     41:     "3d": 10 * 86400,
  4415:     42:     "1w": 30 * 86400,
  4416:     43: }
  4417:     44: 
  4418:     45: def max_age_for_tf(tf: str) -> int:
  4419:     46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
  4420:     47:     tf = tf.lower()
  4421:     48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
  4422:     49:     if env_key in os.environ:
  4423:     50:         try:
  4424:     51:             return int(os.environ[env_key])
  4425:     52:         except Exception:
  4426:     53:             pass
  4427:     54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
  4428:     55: 
  4429:     56: # ---------------- CSV I/O ----------------
  4430:     57: 
  4431:     58: def data_dir() -> Path:
  4432:     59:     d = Path(os.getenv("DATA_DIR", "data"))
  4433:     60:     d.mkdir(parents=True, exist_ok=True)
  4434:     61:     return d
  4435:     62: 
  4436:     63: def csv_path(symbol: str, tf: str) -> Path:
  4437:     64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
  4438:     65: 
  4439:     66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
  4440:     67:     out: List[List[float]] = []
  4441:     68:     if not path.exists():
  4442:     69:         return out
  4443:     70:     with path.open("r", newline="") as f:
  4444:     71:         r = csv.reader(f)
  4445:     72:         header = next(r, None)
  4446:     73:         for row in r:
  4447:     74:             # columns: timestamp,open,high,low,close,volume
  4448:     75:             try:
  4449:     76:                 ts, o, h, l, c, v = row[:6]
  4450:     77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
  4451:     78:             except Exception:
  4452:     79:                 continue
  4453:     80:     return out
  4454:     81: 
  4455:     82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
  4456:     83:     new_file = not path.exists()
  4457:     84:     with path.open("w", newline="") as f:
  4458:     85:         w = csv.writer(f)
  4459:     86:         w.writerow(["timestamp","open","high","low","close","volume"])
  4460:     87:         for r in rows:
  4461:     88:             w.writerow(r)
  4462:     89: 
  4463:     90: # ---------------- Validation / Chargement / Fetch ----------------
  4464:     91: 
  4465:     92: @dataclass
  4466:     93: class CacheInfo:
  4467:     94:     symbol: str
  4468:     95:     tf: str
  4469:     96:     path: Path
  4470:     97:     exists: bool
  4471:     98:     fresh: bool
  4472:     99:     last_ts: Optional[int] = None
  4473:    100:     rows: int = 0
  4474:    101: 
  4475:    102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
  4476:    103:     if not last_ts:
  4477:    104:         return False
  4478:    105:     age = int(time.time()) - int(last_ts / 1000)
  4479:    106:     return age <= max_age_for_tf(tf)
  4480:    107: 
  4481:    108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
  4482:    109:     p = csv_path(symbol, tf)
  4483:    110:     if not p.exists():
  4484:    111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
  4485:    112:     rows = read_csv_ohlcv(p)
  4486:    113:     last_ts = rows[-1][0] if rows else None
  4487:    114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
  4488:    115: 
  4489:    116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
  4490:    117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
  4491:    118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
  4492:    119: 
  4493:    120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
  4494:    121:     info = inspect_csv(symbol, tf)
  4495:    122:     if info.exists and info.fresh:
  4496:    123:         data = read_csv_ohlcv(info.path)
  4497:    124:         return info, data
  4498:    125: 
  4499:    126:     # fetch & persist
  4500:    127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
  4501:    128:     if data:
  4502:    129:         write_csv_ohlcv(info.path, data)
  4503:    130:         info = inspect_csv(symbol, tf)  # refresh stats
  4504:    131:     return info, data
  4505:    132: 
  4506:    133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
  4507:    134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
  4508:    135:     out: Dict[str, List[List[float]]] = {}
  4509:    136:     for s in symbols:
  4510:    137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
  4511:    138:         out[s] = rows
  4512:    139:     return out
  4513:    140: 
  4514:    141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
  4515:    142:     report = []
  4516:    143:     for s in symbols:
  4517:    144:         info = inspect_csv(s, tf)
  4518:    145:         report.append({
  4519:    146:             "symbol": s,
  4520:    147:             "tf": tf,
  4521:    148:             "path": str(info.path),
  4522:    149:             "exists": info.exists,
  4523:    150:             "fresh": info.fresh,
  4524:    151:             "last_ts": info.last_ts,
  4525:    152:             "rows": info.rows,
  4526:    153:             "max_age": max_age_for_tf(tf),
  4527:    154:         })
  4528:    155:     out_path.parent.mkdir(parents=True, exist_ok=True)
  4529:    156:     out_path.write_text(json.dumps(report, indent=2))
  4530: 
  4531: ## scalper/backtest/cli.py (last modified: 2025-08-23 20:57:14)
  4532:      1: from __future__ import annotations
  4533:      2: 
  4534:      3: import argparse
  4535:      4: from scalper.backtest.runner import run_multi, csv_loader_factory
  4536:      5: 
  4537:      6: def create_parser() -> argparse.ArgumentParser:
  4538:      7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
  4539:      8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
  4540:      9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
  4541:     10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
  4542:     11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
  4543:     12:     p.add_argument("--cash", type=float, default=10_000.0)
  4544:     13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
  4545:     14:     p.add_argument("--slippage-bps", type=float, default=1.5)
  4546:     15:     return p
  4547:     16: 
  4548:     17: def main(argv: list[str] | None = None) -> int:
  4549:     18:     p = create_parser()
  4550:     19:     a = p.parse_args(argv)
  4551:     20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
  4552:     21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
  4553:     22:     loader = csv_loader_factory(a.data_dir)
  4554:     23:     run_multi(
  4555:     24:         symbols=symbols,
  4556:     25:         timeframes=tfs,
  4557:     26:         loader=loader,
  4558:     27:         out_dir=a.out_dir,
  4559:     28:         initial_cash=a.cash,
  4560:     29:         risk_pct=a.risk,
  4561:     30:         slippage_bps=a.slippage_bps,
  4562:     31:     )
  4563:     32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
  4564:     33:     return 0
  4565:     34: 
  4566:     35: if __name__ == "__main__":
  4567:     36:     raise SystemExit(main())
  4568: 
  4569: ## scalper/backtest/engine.py (last modified: 2025-08-23 20:57:14)
  4570:      1: # scalper/backtest/engine.py
  4571:      2: from __future__ import annotations
  4572:      3: 
  4573:      4: import math
  4574:      5: from dataclasses import dataclass, asdict
  4575:      6: from typing import Callable, Dict, List, Optional, Tuple
  4576:      7: 
  4577:      8: import pandas as pd
  4578:      9: 
  4579:     10: from scalper.strategy import generate_signal
  4580:     11: from scalper.trade_utils import compute_position_size
  4581:     12: from scalper.exchange.fees import get_fee
  4582:     13: 
  4583:     14: OHLCVLoader = Callable[[str, str, Optional[str], Optional[str]], pd.DataFrame]
  4584:     15: 
  4585:     16: 
  4586:     17: @dataclass
  4587:     18: class Fill:
  4588:     19:     ts: pd.Timestamp
  4589:     20:     symbol: str
  4590:     21:     side: str       # "long" | "short" | "flat"
  4591:     22:     price: float
  4592:     23:     qty: float
  4593:     24:     fee: float
  4594:     25:     reason: str     # "entry"|"tp"|"sl"|"exit"|"reverse"|"final_exit"
  4595:     26: 
  4596:     27: 
  4597:     28: @dataclass
  4598:     29: class Trade:
  4599:     30:     symbol: str
  4600:     31:     side: str
  4601:     32:     entry_ts: pd.Timestamp
  4602:     33:     entry_px: float
  4603:     34:     qty: float
  4604:     35:     exit_ts: pd.Timestamp
  4605:     36:     exit_px: float
  4606:     37:     fee_entry: float
  4607:     38:     fee_exit: float
  4608:     39:     pnl: float
  4609:     40:     pnl_pct: float
  4610:     41: 
  4611:     42: 
  4612:     43: @dataclass
  4613:     44: class EquityPoint:
  4614:     45:     ts: pd.Timestamp
  4615:     46:     equity: float
  4616:     47: 
  4617:     48: 
  4618:     49: def _apply_slippage(price: float, side: str, slippage_bps: float) -> float:
  4619:     50:     if slippage_bps <= 0:
  4620:     51:         return price
  4621:     52:     mult = 1.0 + (slippage_bps / 10_000.0)
  4622:     53:     return price * (mult if side in ("buy", "long") else 1.0 / mult)
  4623:     54: 
  4624:     55: 
  4625:     56: def _hit_tp_sl(row: pd.Series, side: str, tp: float, sl: float) -> Tuple[bool, str, float]:
  4626:     57:     high, low, close = float(row.high), float(row.low), float(row.close)
  4627:     58:     if side == "long":
  4628:     59:         if low <= sl <= high:
  4629:     60:             return True, "sl", sl
  4630:     61:         if low <= tp <= high:
  4631:     62:             return True, "tp", tp
  4632:     63:         return False, "", close
  4633:     64:     else:
  4634:     65:         if low <= tp <= high:
  4635:     66:             return True, "tp", tp
  4636:     67:         if low <= sl <= high:
  4637:     68:             return True, "sl", sl
  4638:     69:         return False, "", close
  4639:     70: 
  4640:     71: 
  4641:     72: def run_single(
  4642:     73:     *,
  4643:     74:     symbol: str,
  4644:     75:     timeframe: str,
  4645:     76:     loader: OHLCVLoader,
  4646:     77:     start: str | None = None,
  4647:     78:     end: str | None = None,
  4648:     79:     initial_cash: float = 10_000.0,
  4649:     80:     risk_pct: float = 0.005,
  4650:     81:     slippage_bps: float = 1.5,
  4651:     82:     taker: bool = True,
  4652:     83:     quiet: bool = True,
  4653:     84: ) -> Dict[str, object]:
  4654:     85:     df = loader(symbol, timeframe, start, end).copy()
  4655:     86:     if df.empty:
  4656:     87:         raise ValueError(f"Pas de données pour {symbol} {timeframe}")
  4657:     88:     df.columns = [c.lower() for c in df.columns]
  4658:     89:     for c in ("open", "high", "low", "close", "volume"):
  4659:     90:         if c not in df.columns:
  4660:     91:             raise ValueError(f"OHLCV invalide: colonne {c} manquante")
  4661:     92: 
  4662:     93:     fee_rate = get_fee(symbol, "taker" if taker else "maker")
  4663:     94: 
  4664:     95:     equity = float(initial_cash)
  4665:     96:     pos_side: str = "flat"
  4666:     97:     pos_qty: float = 0.0
  4667:     98:     entry_px: float = 0.0
  4668:     99:     fee_entry: float = 0.0
  4669:    100:     sl: float = math.nan
  4670:    101:     tp: float = math.nan
  4671:    102: 
  4672:    103:     eq: List[EquityPoint] = []
  4673:    104:     fills: List[Fill] = []
  4674:    105:     closed: List[Trade] = []
  4675:    106: 
  4676:    107:     for ts, row in df.iterrows():
  4677:    108:         ts = pd.Timestamp(ts)
  4678:    109: 
  4679:    110:         # gérer SL/TP quand en position
  4680:    111:         if pos_side in ("long", "short"):
  4681:    112:             hit, reason, exec_px = _hit_tp_sl(row, pos_side, tp, sl)
  4682:    113:             if hit:
  4683:    114:                 px = _apply_slippage(exec_px, "sell" if pos_side == "long" else "buy", slippage_bps)
  4684:    115:                 fee = abs(px * pos_qty) * fee_rate
  4685:    116:                 pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  4686:    117:                 equity += pnl - fee
  4687:    118:                 fills.append(Fill(ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, reason))
  4688:    119:                 closed.append(
  4689:    120:                     Trade(
  4690:    121:                         symbol=symbol, side=pos_side, entry_ts=ts, entry_px=entry_px, qty=pos_qty,
  4691:    122:                         exit_ts=ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  4692:    123:                         pnl=pnl - fee_entry - fee,
  4693:    124:                         pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  4694:    125:                     )
  4695:    126:                 )
  4696:    127:                 pos_side, pos_qty, entry_px, sl, tp, fee_entry = "flat", 0.0, 0.0, math.nan, math.nan, 0.0
  4697:    128: 
  4698:    129:         # signal de la stratégie live
  4699:    130:         sig = generate_signal(
  4700:    131:             symbol=symbol,
  4701:    132:             ohlcv=df.loc[:ts].tail(300),
  4702:    133:             equity=equity,
  4703:    134:             risk_pct=risk_pct,
  4704:    135:         )
  4705:    136:         if sig and getattr(sig, "side", None) and pos_side == "flat":
  4706:    137:             side = sig.side  # "long"|"short"
  4707:    138:             px = _apply_slippage(float(sig.price), "buy" if side == "long" else "sell", slippage_bps)
  4708:    139:             qty = float(getattr(sig, "qty", 0.0)) or compute_position_size(equity, px, risk_pct, symbol=symbol)
  4709:    140:             if qty > 0:
  4710:    141:                 fee = abs(px * qty) * fee_rate
  4711:    142:                 pos_side, pos_qty, entry_px = side, qty, px
  4712:    143:                 sl = float(getattr(sig, "sl", px * (0.995 if side == "long" else 1.005)))
  4713:    144:                 tp = float(getattr(sig, "tp", getattr(sig, "tp1", px * (1.005 if side == "long" else 0.995))))
  4714:    145:                 fee_entry = fee
  4715:    146:                 equity -= fee
  4716:    147:                 fills.append(Fill(ts, symbol, side, px, qty if side == "long" else -qty, fee, "entry"))
  4717:    148: 
  4718:    149:         eq.append(EquityPoint(ts, equity))
  4719:    150: 
  4720:    151:     # sortie forcée fin de série
  4721:    152:     if pos_side in ("long", "short"):
  4722:    153:         last_ts = pd.Timestamp(df.index[-1])
  4723:    154:         px = _apply_slippage(float(df["close"].iloc[-1]), "sell" if pos_side == "long" else "buy", slippage_bps)
  4724:    155:         fee = abs(px * pos_qty) * fee_rate
  4725:    156:         pnl = (px - entry_px) * pos_qty if pos_side == "long" else (entry_px - px) * pos_qty
  4726:    157:         equity += pnl - fee
  4727:    158:         fills.append(Fill(last_ts, symbol, "flat", px, -pos_qty if pos_side == "long" else pos_qty, fee, "final_exit"))
  4728:    159:         closed.append(
  4729:    160:             Trade(
  4730:    161:                 symbol=symbol, side=pos_side, entry_ts=last_ts, entry_px=entry_px, qty=pos_qty,
  4731:    162:                 exit_ts=last_ts, exit_px=px, fee_entry=fee_entry, fee_exit=fee,
  4732:    163:                 pnl=pnl - fee_entry - fee, pnl_pct=((equity / initial_cash) - 1.0) * 100.0 if initial_cash else 0.0,
  4733:    164:             )
  4734:    165:         )
  4735:    166: 
  4736:    167:     eq_df = pd.DataFrame([asdict(e) for e in eq])
  4737:    168:     tr_df = pd.DataFrame([asdict(t) for t in closed])
  4738:    169:     fills_df = pd.DataFrame([asdict(f) for f in fills])
  4739:    170: 
  4740:    171:     metrics = {
  4741:    172:         "symbol": symbol,
  4742:    173:         "timeframe": timeframe,
  4743:    174:         "initial_cash": initial_cash,
  4744:    175:         "final_equity": float(eq_df["equity"].iloc[-1] if not eq_df.empty else initial_cash),
  4745:    176:         "return_pct": float(((eq_df["equity"].iloc[-1] / initial_cash) - 1.0) * 100.0 if initial_cash and not eq_df.empty else 0.0),
  4746:    177:         "n_trades": int(len(tr_df)),
  4747:    178:         "win_rate_pct": float((tr_df["pnl"] > 0).mean() * 100.0) if not tr_df.empty else 0.0,
  4748:    179:         "avg_trade_pnl": float(tr_df["pnl"].mean()) if not tr_df.empty else 0.0,
  4749:    180:         "max_dd_pct": float(((eq_df["equity"].cummax() - eq_df["equity"]) / eq_df["equity"].cummax()).max() * 100.0) if not eq_df.empty else 0.0,
  4750:    181:     }
  4751:    182: 
  4752:    183:     return {"equity_curve": eq_df, "trades": tr_df, "fills": fills_df, "metrics": metrics}
  4753: 
  4754: ## scalper/backtest/grid_search.py (last modified: 2025-08-23 20:57:14)
  4755:      1: """Grid-search express module to evaluate hyperparameter combinations.
  4756:      2: 
  4757:      3: This module builds combinations of strategy and engine parameters, runs the
  4758:      4: existing multi symbol backtester for each combination, collects key metrics and
  4759:      5: selects the best configuration according to:
  4760:      6: 
  4761:      7: 1. Profit factor (descending)
  4762:      8: 2. Maximum drawdown percentage (ascending)
  4763:      9: 3. Net PnL in USDT (descending)
  4764:     10: 4. Number of trades (ascending)
  4765:     11: 
  4766:     12: Results are written under ``result/grid`` by default and a short summary is
  4767:     13: printed to the console.
  4768:     14: """
  4769:     15: from __future__ import annotations
  4770:     16: 
  4771:     17: from dataclasses import dataclass
  4772:     18: import csv
  4773:     19: import json
  4774:     20: import os
  4775:     21: import random
  4776:     22: from itertools import product
  4777:     23: from typing import Any, Callable, Dict, Iterable, List, Sequence
  4778:     24: 
  4779:     25: # ---------------------------------------------------------------------------
  4780:     26: # Utilities
  4781:     27: # ---------------------------------------------------------------------------
  4782:     28: 
  4783:     29: 
  4784:     30: def parse_hours(hours: str) -> List[int]:
  4785:     31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
  4786:     32: 
  4787:     33:     Each comma separated element can either be a single hour (``"8"``) or a
  4788:     34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
  4789:     35:     """
  4790:     36: 
  4791:     37:     if not hours:
  4792:     38:         return []
  4793:     39:     result: List[int] = []
  4794:     40:     for part in hours.split(","):
  4795:     41:         part = part.strip()
  4796:     42:         if not part:
  4797:     43:             continue
  4798:     44:         if "-" in part:
  4799:     45:             start_s, end_s = part.split("-", 1)
  4800:     46:             start, end = int(start_s), int(end_s)
  4801:     47:             result.extend(range(start, end + 1))
  4802:     48:         else:
  4803:     49:             result.append(int(part))
  4804:     50:     return sorted(set(result))
  4805:     51: 
  4806:     52: 
  4807:     53: # Order of parameters used throughout the module and in CSV output
  4808:     54: PARAM_KEYS = [
  4809:     55:     "timeframe",
  4810:     56:     "score_min",
  4811:     57:     "atr_min_ratio",
  4812:     58:     "rr_min",
  4813:     59:     "risk_pct",
  4814:     60:     "slippage_bps",
  4815:     61:     "fee_rate",
  4816:     62:     "cooldown_secs",
  4817:     63:     "hours",
  4818:     64: ]
  4819:     65: 
  4820:     66: # Default values used if a parameter is not provided in the grid
  4821:     67: DEFAULTS = {
  4822:     68:     "score_min": 55,
  4823:     69:     "atr_min_ratio": 0.002,
  4824:     70:     "rr_min": 1.2,
  4825:     71:     "risk_pct": 0.01,
  4826:     72:     "slippage_bps": 2,
  4827:     73:     "fee_rate": 0.001,
  4828:     74:     "cooldown_secs": 300,
  4829:     75:     "hours": "7-11,13-17",
  4830:     76: }
  4831:     77: 
  4832:     78: 
  4833:     79: @dataclass
  4834:     80: class GridResult:
  4835:     81:     params: Dict[str, Any]
  4836:     82:     metrics: Dict[str, float]
  4837:     83: 
  4838:     84: 
  4839:     85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
  4840:     86:     if isinstance(val, (list, tuple, set)):
  4841:     87:         return list(val)
  4842:     88:     return [val]
  4843:     89: 
  4844:     90: 
  4845:     91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
  4846:     92:     """Return a list of parameter combinations.
  4847:     93: 
  4848:     94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
  4849:     95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
  4850:     96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
  4851:     97:     variety of timeframes and ``atr_min_ratio`` values.
  4852:     98:     """
  4853:     99: 
  4854:    100:     lists: Dict[str, List[Any]] = {}
  4855:    101:     for key in PARAM_KEYS:
  4856:    102:         if key == "timeframe":
  4857:    103:             # timeframe must be explicitly provided; default empty -> "1m"
  4858:    104:             vals = param_lists.get(key) or ["1m"]
  4859:    105:         else:
  4860:    106:             vals = param_lists.get(key)
  4861:    107:             if not vals:
  4862:    108:                 default = DEFAULTS[key]
  4863:    109:                 vals = [default]
  4864:    110:         lists[key] = _ensure_list(vals)
  4865:    111: 
  4866:    112:     combos: List[Dict[str, Any]] = [
  4867:    113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
  4868:    114:     ]
  4869:    115: 
  4870:    116:     # Uniform sampling if exceeding grid_max
  4871:    117:     if len(combos) > grid_max:
  4872:    118:         step = len(combos) / float(grid_max)
  4873:    119:         sampled = []
  4874:    120:         for i in range(grid_max):
  4875:    121:             idx = int(round(i * step))
  4876:    122:             if idx >= len(combos):
  4877:    123:                 idx = len(combos) - 1
  4878:    124:             sampled.append(combos[idx])
  4879:    125:         # ensure each timeframe appears at least once
  4880:    126:         wanted_tfs = set(lists["timeframe"])
  4881:    127:         present_tfs = {c["timeframe"] for c in sampled}
  4882:    128:         missing = list(wanted_tfs - present_tfs)
  4883:    129:         if missing:
  4884:    130:             for tf in missing:
  4885:    131:                 for c in combos:
  4886:    132:                     if c["timeframe"] == tf and c not in sampled:
  4887:    133:                         sampled.append(c)
  4888:    134:                         break
  4889:    135:             sampled = sampled[:grid_max]
  4890:    136:         combos = sampled
  4891:    137:     return combos
  4892:    138: 
  4893:    139: 
  4894:    140: # ---------------------------------------------------------------------------
  4895:    141: # Core runner
  4896:    142: # ---------------------------------------------------------------------------
  4897:    143: 
  4898:    144: 
  4899:    145: def run_grid_search(
  4900:    146:     *,
  4901:    147:     symbols: Sequence[str],
  4902:    148:     exchange: str,
  4903:    149:     base_params: Dict[str, Any],
  4904:    150:     param_lists: Dict[str, Sequence[Any]],
  4905:    151:     grid_max: int = 12,
  4906:    152:     csv_dir: str | None = None,
  4907:    153:     initial_equity: float = 1000.0,
  4908:    154:     leverage: float = 1.0,
  4909:    155:     paper_constraints: bool = True,
  4910:    156:     seed: int | None = None,
  4911:    157:     out_dir: str = "./result/grid",
  4912:    158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
  4913:    159:     run_func: Callable[..., Any] | None = None,
  4914:    160: ) -> List[GridResult]:
  4915:    161:     """Execute grid search across parameter combinations.
  4916:    162: 
  4917:    163:     ``base_params`` provides default single values for parameters. ``param_lists``
  4918:    164:     contains the grid specifications from CLI (already parsed into sequences).
  4919:    165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
  4920:    166:     """
  4921:    167: 
  4922:    168:     if seed is not None:
  4923:    169:         random.seed(seed)
  4924:    170: 
  4925:    171:     if run_func is None:  # avoid circular import at module load
  4926:    172:         from .run_multi import run_backtest_multi  # late import
  4927:    173: 
  4928:    174:         run_func = run_backtest_multi
  4929:    175: 
  4930:    176:     # merge lists with defaults
  4931:    177:     full_lists: Dict[str, Sequence[Any]] = {}
  4932:    178:     for k in PARAM_KEYS:
  4933:    179:         if k == "timeframe":
  4934:    180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
  4935:    181:         else:
  4936:    182:             if param_lists.get(k) is not None:
  4937:    183:                 full_lists[k] = param_lists[k]
  4938:    184:             else:
  4939:    185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
  4940:    186: 
  4941:    187:     combos = build_param_grid(full_lists, grid_max)
  4942:    188: 
  4943:    189:     results: List[GridResult] = []
  4944:    190:     os.makedirs(out_dir, exist_ok=True)
  4945:    191: 
  4946:    192:     for combo in combos:
  4947:    193:         # Build parameters for backtester
  4948:    194:         tf = combo["timeframe"]
  4949:    195:         fee = float(combo["fee_rate"])
  4950:    196:         slip = float(combo["slippage_bps"])
  4951:    197:         risk = float(combo["risk_pct"])
  4952:    198: 
  4953:    199:         summary, _trades = run_func(
  4954:    200:             symbols=list(symbols),
  4955:    201:             exchange=exchange,
  4956:    202:             timeframe=tf,
  4957:    203:             csv_dir=csv_dir,
  4958:    204:             fee_rate=fee,
  4959:    205:             slippage_bps=slip,
  4960:    206:             risk_pct=risk,
  4961:    207:             initial_equity=initial_equity,
  4962:    208:             leverage=leverage,
  4963:    209:             paper_constraints=paper_constraints,
  4964:    210:             seed=seed,
  4965:    211:             out_dir=os.path.join(out_dir, "tmp"),
  4966:    212:             plot=False,
  4967:    213:             dry_run=True,
  4968:    214:         )
  4969:    215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
  4970:    216:         metrics = {
  4971:    217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
  4972:    218:             "profit_factor": float(total.get("profit_factor", 0.0)),
  4973:    219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
  4974:    220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
  4975:    221:             "trades": float(total.get("trades", 0.0)),
  4976:    222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
  4977:    223:         }
  4978:    224:         results.append(GridResult(params=combo, metrics=metrics))
  4979:    225: 
  4980:    226:     # sort results
  4981:    227:     results.sort(
  4982:    228:         key=lambda r: (
  4983:    229:             -r.metrics["profit_factor"],
  4984:    230:             r.metrics["max_dd_pct"],
  4985:    231:             -r.metrics["pnl_usdt"],
  4986:    232:             r.metrics["trades"],
  4987:    233:         )
  4988:    234:     )
  4989:    235: 
  4990:    236:     # console output -------------------------------------------------------
  4991:    237:     print(
  4992:    238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
  4993:    239:     )
  4994:    240:     header = (
  4995:    241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
  4996:    242:     )
  4997:    243:     print(header)
  4998:    244:     for r in results[:10]:
  4999:    245:         m = r.metrics
  5000:    246:         print(
  5001:    247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
  5002:    248:         )
  5003:    249: 
  5004:    250:     # write csv ------------------------------------------------------------
  5005:    251:     csv_cols = PARAM_KEYS + [
  5006:    252:         "pnl_usdt",
  5007:    253:         "profit_factor",
  5008:    254:         "max_dd_pct",
  5009:    255:         "winrate_pct",
  5010:    256:         "trades",
  5011:    257:         "final_equity",
  5012:    258:     ]
  5013:    259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
  5014:    260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
  5015:    261:         writer.writeheader()
  5016:    262:         for r in results:
  5017:    263:             row = {**r.params, **r.metrics}
  5018:    264:             writer.writerow(row)
  5019:    265: 
  5020:    266:     best = results[0]
  5021:    267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
  5022:    268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
  5023:    269: 
  5024:    270:     # markdown summary -----------------------------------------------------
  5025:    271:     md_path = os.path.join(out_dir, "grid_summary.md")
  5026:    272:     with open(md_path, "w", encoding="utf8") as fh:
  5027:    273:         fh.write(
  5028:    274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
  5029:    275:         )
  5030:    276:         for r in results[:10]:
  5031:    277:             m = r.metrics
  5032:    278:             fh.write(
  5033:    279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
  5034:    280:             )
  5035:    281: 
  5036:    282:     # optional scatter plot ------------------------------------------------
  5037:    283:     try:  # pragma: no cover - optional dependency
  5038:    284:         import matplotlib.pyplot as plt
  5039:    285: 
  5040:    286:         pf = [r.metrics["profit_factor"] for r in results]
  5041:    287:         dd = [r.metrics["max_dd_pct"] for r in results]
  5042:    288:         trades = [r.metrics["trades"] for r in results]
  5043:    289:         tfs = [r.params["timeframe"] for r in results]
  5044:    290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
  5045:    291:         c = [colors[tf] for tf in tfs]
  5046:    292:         plt.figure(figsize=(6, 4))
  5047:    293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
  5048:    294:         plt.xlabel("MaxDD%")
  5049:    295:         plt.ylabel("Profit Factor")
  5050:    296:         plt.title("PF vs MaxDD")
  5051:    297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
  5052:    298:         plt.close()
  5053:    299:     except Exception:  # pragma: no cover
  5054:    300:         pass
  5055:    301: 
  5056:    302:     return results
  5057:    303: 
  5058:    304: 
  5059:    305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]
  5060: 
  5061: 
  5062: ## scalper/backtest/loader_csv.py (last modified: 2025-08-23 20:57:14)
  5063:      1: # scalper/backtest/loader_csv.py
  5064:      2: from __future__ import annotations
  5065:      3: 
  5066:      4: import csv
  5067:      5: from typing import Dict, List
  5068:      6: 
  5069:      7: from scalper.services.data_cache import csv_path
  5070:      8: 
  5071:      9: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
  5072:     10: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
  5073:     11:     path = csv_path(symbol, timeframe)
  5074:     12:     rows: List[List[float]] = []
  5075:     13:     with open(path, "r") as f:
  5076:     14:         r = csv.DictReader(f)
  5077:     15:         for row in r:
  5078:     16:             rows.append([
  5079:     17:                 int(row["timestamp"]),
  5080:     18:                 float(row["open"]),
  5081:     19:                 float(row["high"]),
  5082:     20:                 float(row["low"]),
  5083:     21:                 float(row["close"]),
  5084:     22:                 float(row["volume"]),
  5085:     23:             ])
  5086:     24:     rows.sort(key=lambda x: x[0])
  5087:     25:     return rows
  5088:     26: 
  5089:     27: 
  5090:     28: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
  5091:     29:     out: Dict[str, List[List[float]]] = {}
  5092:     30:     for s in symbols:
  5093:     31:         out[s] = load_ohlcv_csv(s, timeframe)
  5094:     32:     return out
  5095: 
  5096: ## scalper/backtest/market_data.py (last modified: 2025-08-23 20:57:14)
  5097:      1: from __future__ import annotations
  5098:      2: 
  5099:      3: import json
  5100:      4: import os
  5101:      5: import time
  5102:      6: from pathlib import Path
  5103:      7: from typing import Any, Iterable, Optional, Sequence, Tuple
  5104:      8: from urllib.request import Request, urlopen
  5105:      9: from urllib.error import URLError, HTTPError
  5106:     10: 
  5107:     11: import pandas as pd
  5108:     12: 
  5109:     13: # ============================================================================
  5110:     14: # Logs & utilitaires
  5111:     15: # ============================================================================
  5112:     16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
  5113:     17: def _log(msg: str) -> None:
  5114:     18:     if BT_DEBUG:
  5115:     19:         print(f"[bt.debug] {msg}", flush=True)
  5116:     20: 
  5117:     21: def _now_ms() -> int:
  5118:     22:     return int(time.time() * 1000)
  5119:     23: 
  5120:     24: def _tf_to_seconds(tf: str) -> int:
  5121:     25:     tf = tf.lower().strip()
  5122:     26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
  5123:     27:     if tf not in table:
  5124:     28:         raise ValueError(f"Timeframe non supporté: {tf}")
  5125:     29:     return table[tf]
  5126:     30: 
  5127:     31: def _parse_duration(s: str) -> int:
  5128:     32:     """
  5129:     33:     '90s','15m','2h','3d' -> secondes
  5130:     34:     """
  5131:     35:     s = s.strip().lower()
  5132:     36:     if s.endswith("s"): return int(float(s[:-1]))
  5133:     37:     if s.endswith("m"): return int(float(s[:-1])*60)
  5134:     38:     if s.endswith("h"): return int(float(s[:-1])*3600)
  5135:     39:     if s.endswith("d"): return int(float(s[:-1])*86400)
  5136:     40:     return int(float(s))  # secondes
  5137:     41: 
  5138:     42: # ============================================================================
  5139:     43: # Politique de fraîcheur (par défaut + overrides via ENV)
  5140:     44: # ============================================================================
  5141:     45: def _default_max_age_seconds(tf: str) -> int:
  5142:     46:     """
  5143:     47:     Règles par défaut (conservatrices) :
  5144:     48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
  5145:     49:       - 30m     : 1h
  5146:     50:       - 1h      : 6h
  5147:     51:       - 4h      : 24h
  5148:     52:       - 1d      : 3d
  5149:     53:     """
  5150:     54:     tf = tf.lower()
  5151:     55:     if tf in ("1m","3m","5m","15m"):
  5152:     56:         return 2 * _tf_to_seconds(tf)
  5153:     57:     if tf == "30m":
  5154:     58:         return 3600
  5155:     59:     if tf == "1h":
  5156:     60:         return 6*3600
  5157:     61:     if tf == "4h":
  5158:     62:         return 24*3600
  5159:     63:     if tf == "1d":
  5160:     64:         return 3*86400
  5161:     65:     raise ValueError(tf)
  5162:     66: 
  5163:     67: def _max_age_seconds(tf: str) -> int:
  5164:     68:     """
  5165:     69:     Overrides possibles (au choix) :
  5166:     70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
  5167:     71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
  5168:     72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
  5169:     73:     """
  5170:     74:     tfk = tf.lower().replace(":", "")
  5171:     75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
  5172:     76:     if env_spec:
  5173:     77:         return _parse_duration(env_spec)
  5174:     78:     mult = os.getenv("CSV_MAX_AGE_MULT")
  5175:     79:     if mult:
  5176:     80:         return int(float(mult) * _tf_to_seconds(tf))
  5177:     81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
  5178:     82:     if g:
  5179:     83:         return _parse_duration(g)
  5180:     84:     return _default_max_age_seconds(tf)
  5181:     85: 
  5182:     86: # ============================================================================
  5183:     87: # CSV helpers + validation
  5184:     88: # ============================================================================
  5185:     89: def _data_dir(default: str = "data") -> Path:
  5186:     90:     root = Path(os.getenv("DATA_DIR", default))
  5187:     91:     root.mkdir(parents=True, exist_ok=True)
  5188:     92:     return root
  5189:     93: 
  5190:     94: def _csv_path(symbol: str, timeframe: str) -> Path:
  5191:     95:     tf = timeframe.replace(":", "")
  5192:     96:     return _data_dir() / f"{symbol}-{tf}.csv"
  5193:     97: 
  5194:     98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
  5195:     99:     rows = list(rows)
  5196:    100:     if not rows:
  5197:    101:         raise ValueError("OHLCV vide")
  5198:    102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
  5199:    103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
  5200:    104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
  5201:    105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
  5202:    106: 
  5203:    107: def _read_csv(path: Path) -> pd.DataFrame:
  5204:    108:     df = pd.read_csv(path)
  5205:    109:     # tolère quelques variations de colonnes
  5206:    110:     cols = {c.lower(): c for c in df.columns}
  5207:    111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
  5208:    112:     if not ts_col:
  5209:    113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
  5210:    114:     rename = {ts_col: "timestamp"}
  5211:    115:     for c in ("open","high","low","close","volume"):
  5212:    116:         if c not in cols:
  5213:    117:             raise ValueError(f"Colonne manquante: {c}")
  5214:    118:         rename[cols[c]] = c
  5215:    119:     df = df.rename(columns=rename)
  5216:    120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
  5217:    121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
  5218:    122:     df = df.drop_duplicates("timestamp")
  5219:    123:     df = df.set_index("timestamp")
  5220:    124:     return df
  5221:    125: 
  5222:    126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
  5223:    127:     out = df.reset_index().rename(columns={"index": "timestamp"})
  5224:    128:     out.to_csv(path, index=False)
  5225:    129: 
  5226:    130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
  5227:    131:     """
  5228:    132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
  5229:    133:       - schéma valide
  5230:    134:       - assez de lignes
  5231:    135:       - fraîcheur < seuil selon TF
  5232:    136:     """
  5233:    137:     if not path.exists():
  5234:    138:         return False, "absent"
  5235:    139:     try:
  5236:    140:         df = _read_csv(path)
  5237:    141:     except Exception as e:
  5238:    142:         return False, f"invalid({e})"
  5239:    143:     if len(df) < min_rows:
  5240:    144:         return False, f"too_few_rows({len(df)}<{min_rows})"
  5241:    145:     # Fraîcheur
  5242:    146:     last_ts = int(df.index.max().timestamp())
  5243:    147:     age_s = int(time.time()) - last_ts
  5244:    148:     max_age = _max_age_seconds(timeframe)
  5245:    149:     if age_s > max_age:
  5246:    150:         return False, f"stale({age_s}s>{max_age}s)"
  5247:    151:     # Monotonicité (échantillon)
  5248:    152:     if not df.index.is_monotonic_increasing:
  5249:    153:         return False, "not_monotonic"
  5250:    154:     return True, "ok"
  5251:    155: 
  5252:    156: # ============================================================================
  5253:    157: # Fallback réseau (CCXT d'abord, HTTP sinon)
  5254:    158: # ============================================================================
  5255:    159: def _ensure_ccxt() -> Any | None:
  5256:    160:     try:
  5257:    161:         import ccxt  # type: ignore
  5258:    162:         return ccxt
  5259:    163:     except Exception:
  5260:    164:         return None
  5261:    165: 
  5262:    166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  5263:    167:     ccxt = _ensure_ccxt()
  5264:    168:     if not ccxt:
  5265:    169:         _log("ccxt indisponible")
  5266:    170:         return None
  5267:    171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
  5268:    172:     ex.load_markets()
  5269:    173:     base = symbol.upper()
  5270:    174:     if not base.endswith("USDT"):
  5271:    175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
  5272:    176:     coin = base[:-4]
  5273:    177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
  5274:    178:     for ccxt_sym in candidates:
  5275:    179:         try:
  5276:    180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
  5277:    181:             if rows:
  5278:    182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
  5279:    183:         except Exception as e:
  5280:    184:             _log(f"ccxt fail {ccxt_sym}: {e}")
  5281:    185:             continue
  5282:    186:     return None
  5283:    187: 
  5284:    188: # === (facultatif) HTTP Bitget v1 minimal ===
  5285:    189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
  5286:    190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
  5287:    191: 
  5288:    192: def _http_get(url: str, timeout: int = 20) -> dict | list:
  5289:    193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
  5290:    194:     with urlopen(req, timeout=timeout) as resp:
  5291:    195:         return json.loads(resp.read().decode("utf-8"))
  5292:    196: 
  5293:    197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
  5294:    198:     rows = payload.get("data") if isinstance(payload, dict) else payload
  5295:    199:     if not isinstance(rows, list):
  5296:    200:         raise ValueError(f"Réponse inattendue: {payload}")
  5297:    201:     out = []
  5298:    202:     for r in rows:
  5299:    203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
  5300:    204:         out.append([ts,o,h,l,c,v])
  5301:    205:     out.sort(key=lambda x:x[0])
  5302:    206:     return out
  5303:    207: 
  5304:    208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
  5305:    209:     tf = timeframe.lower()
  5306:    210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
  5307:    211:     if not (g and p):
  5308:    212:         return None
  5309:    213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
  5310:    214:     trials = [
  5311:    215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
  5312:    216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
  5313:    217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
  5314:    218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
  5315:    219:     ]
  5316:    220:     for url in trials:
  5317:    221:         try:
  5318:    222:             payload = _http_get(url)
  5319:    223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
  5320:    224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
  5321:    225:             rows = _normalize_http_rows(payload)
  5322:    226:             if rows:
  5323:    227:                 return _rows_to_df(rows)
  5324:    228:         except Exception as e:
  5325:    229:             _log(f"HTTP fail: {url} -> {e}")
  5326:    230:             continue
  5327:    231:     return None
  5328:    232: 
  5329:    233: # ============================================================================
  5330:    234: # API publique utilisée par l’orchestrateur/backtest
  5331:    235: # ============================================================================
  5332:    236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
  5333:    237:     """
  5334:    238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
  5335:    239:     """
  5336:    240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
  5337:    241:     if df is not None:
  5338:    242:         _log(f"source=ccxt  n={len(df)}")
  5339:    243:         return df
  5340:    244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
  5341:    245:     if df is not None:
  5342:    246:         _log(f"source=http  n={len(df)}")
  5343:    247:         return df
  5344:    248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
  5345:    249: 
  5346:    250: def hybrid_loader(
  5347:    251:     data_dir: str = "data",
  5348:    252:     *,
  5349:    253:     use_cache_first: bool = True,
  5350:    254:     min_rows: int = 100,
  5351:    255:     refill_if_stale: bool = True,
  5352:    256:     network_limit: int = 1000,
  5353:    257: ):
  5354:    258:     """
  5355:    259:     Loader smart :
  5356:    260:       1) si CSV présent ET frais/valide → le renvoie
  5357:    261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
  5358:    262:       3) sinon → lève
  5359:    263:     """
  5360:    264:     os.environ.setdefault("DATA_DIR", data_dir)
  5361:    265: 
  5362:    266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
  5363:    267:         path = _csv_path(symbol, timeframe)
  5364:    268: 
  5365:    269:         if use_cache_first:
  5366:    270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
  5367:    271:             if ok:
  5368:    272:                 _log(f"CSV OK: {path}")
  5369:    273:                 df = _read_csv(path)
  5370:    274:             else:
  5371:    275:                 _log(f"CSV non utilisable ({why}): {path}")
  5372:    276:                 if not refill_if_stale:
  5373:    277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
  5374:    278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  5375:    279:                 _write_csv(path, df)
  5376:    280:         else:
  5377:    281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
  5378:    282:             _write_csv(path, df)
  5379:    283: 
  5380:    284:         # Fenêtrage temporel si demandé (timestamps UTC)
  5381:    285:         if start:
  5382:    286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
  5383:    287:         if end:
  5384:    288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
  5385:    289:         return df
  5386:    290: 
  5387:    291:     return load
  5388: 
  5389: ## scalper/backtest/metrics.py (last modified: 2025-08-23 20:57:14)
  5390:      1: from __future__ import annotations
  5391:      2: import math
  5392:      3: from dataclasses import dataclass
  5393:      4: from typing import List, Dict
  5394:      5: 
  5395:      6: @dataclass
  5396:      7: class Trade:
  5397:      8:     ts: int
  5398:      9:     side: str
  5399:     10:     entry: float
  5400:     11:     exit: float
  5401:     12:     pnl_abs: float
  5402:     13:     pnl_pct: float
  5403:     14:     dur_min: float
  5404:     15: 
  5405:     16: def equity_to_drawdown(equity: List[float]) -> float:
  5406:     17:     peak = -1e18; maxdd = 0.0
  5407:     18:     for v in equity:
  5408:     19:         if v > peak: peak = v
  5409:     20:         dd = 0.0 if peak == 0 else (peak - v) / peak
  5410:     21:         if dd > maxdd: maxdd = dd
  5411:     22:     return maxdd
  5412:     23: 
  5413:     24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
  5414:     25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
  5415:     26:     if not returns: return 0.0
  5416:     27:     mean = sum(returns)/len(returns)
  5417:     28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
  5418:     29:     std = math.sqrt(var) if var>0 else 0.0
  5419:     30:     if std == 0: return 0.0
  5420:     31:     return (mean - rf) / std * math.sqrt(period_per_year)
  5421:     32: 
  5422:     33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
  5423:     34:     wins = [t for t in trades if t.pnl_abs > 0]
  5424:     35:     losses = [t for t in trades if t.pnl_abs < 0]
  5425:     36:     wr = len(wins)/len(trades) if trades else 0.0
  5426:     37:     gross_win = sum(t.pnl_abs for t in wins)
  5427:     38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
  5428:     39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
  5429:     40:     mdd = equity_to_drawdown(equity)
  5430:     41:     shp = sharpe(bar_returns)
  5431:     42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
  5432:     43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
  5433:     44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
  5434:     45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
  5435:     46:     return {
  5436:     47:         "trades": len(trades),
  5437:     48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
  5438:     49:         "expectancy": expectancy, "cagr": cagr, "score": score,
  5439:     50:         "equity_start": equity[0] if equity else None,
  5440:     51:         "equity_end": equity[-1] if equity else None,
  5441:     52:     }
  5442: 
  5443: ## scalper/backtest/optimize.py (last modified: 2025-08-23 20:57:14)
  5444:      1: from __future__ import annotations
  5445:      2: 
  5446:      3: """Parameter sweep utilities for strategy optimisation.
  5447:      4: 
  5448:      5: This module performs a grid search over a parameter space in parallel.  It
  5449:      6: tries to use :mod:`ray` for distributed execution when available and falls
  5450:      7: back to :mod:`multiprocessing` otherwise.
  5451:      8: """
  5452:      9: 
  5453:     10: import itertools
  5454:     11: import json
  5455:     12: import multiprocessing as mp
  5456:     13: import os
  5457:     14: from typing import Any, Dict, Iterable, List, Sequence
  5458:     15: 
  5459:     16: try:  # Optional dependency
  5460:     17:     import ray  # type: ignore
  5461:     18: except Exception:  # pragma: no cover - ray is optional
  5462:     19:     ray = None
  5463:     20: 
  5464:     21: from scalper.backtest import backtest_trades
  5465:     22: 
  5466:     23: 
  5467:     24: # ---------------------------------------------------------------------------
  5468:     25: # Parameter space
  5469:     26: # ---------------------------------------------------------------------------
  5470:     27: 
  5471:     28: def param_space_default() -> Dict[str, Sequence[Any]]:
  5472:     29:     """Return the default parameter search space.
  5473:     30: 
  5474:     31:     The keys correspond to strategy parameters while the values are iterables
  5475:     32:     of possible settings.  The defaults represent a small but representative
  5476:     33:     grid and can be overridden by callers.
  5477:     34:     """
  5478:     35: 
  5479:     36:     return {
  5480:     37:         "ema_fast": [10, 20, 30],
  5481:     38:         "ema_slow": [50, 100, 200],
  5482:     39:         "rsi_period": [14, 21],
  5483:     40:         "atr_period": [14, 21],
  5484:     41:     }
  5485:     42: 
  5486:     43: 
  5487:     44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
  5488:     45:     """Expand *space* into a list of parameter combinations."""
  5489:     46: 
  5490:     47:     keys = list(space)
  5491:     48:     values = [space[k] for k in keys]
  5492:     49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
  5493:     50: 
  5494:     51: 
  5495:     52: # ---------------------------------------------------------------------------
  5496:     53: # Evaluation
  5497:     54: # ---------------------------------------------------------------------------
  5498:     55: 
  5499:     56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
  5500:     57:     """Run a backtest for a single parameter combination.
  5501:     58: 
  5502:     59:     ``grid_item`` contains the parameter values along with optional ``trades``
  5503:     60:     to evaluate.  The function returns a copy of the parameters augmented with
  5504:     61:     the computed PnL under the key ``pnl``.
  5505:     62:     """
  5506:     63: 
  5507:     64:     params = dict(grid_item)
  5508:     65:     trades = params.pop("trades", [])
  5509:     66:     fee_rate = params.pop("fee_rate", None)
  5510:     67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
  5511:     68:     params["pnl"] = pnl
  5512:     69:     return params
  5513:     70: 
  5514:     71: 
  5515:     72: # ---------------------------------------------------------------------------
  5516:     73: # Orchestration
  5517:     74: # ---------------------------------------------------------------------------
  5518:     75: 
  5519:     76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
  5520:     77:     """Evaluate the full parameter grid in parallel and return results."""
  5521:     78: 
  5522:     79:     space = space or param_space_default()
  5523:     80:     grid = _param_grid(space)
  5524:     81: 
  5525:     82:     # Determine execution backend
  5526:     83:     use_ray = False
  5527:     84:     if ray is not None:
  5528:     85:         try:  # pragma: no cover - depends on ray
  5529:     86:             ray.init(ignore_reinit_error=True)
  5530:     87:             use_ray = True
  5531:     88:         except Exception:
  5532:     89:             use_ray = False
  5533:     90: 
  5534:     91:     if use_ray:
  5535:     92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
  5536:     93:         futures = [remote_eval.remote(g) for g in grid]
  5537:     94:         results = ray.get(futures)
  5538:     95:     else:
  5539:     96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
  5540:     97:         with mp.Pool(processes=jobs) as pool:
  5541:     98:             results = pool.map(eval_params_one, grid)
  5542:     99: 
  5543:    100:     return results
  5544:    101: 
  5545:    102: 
  5546:    103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
  5547:    104:     """High level helper executing the sweep and saving aggregated results."""
  5548:    105: 
  5549:    106:     results = run_param_sweep(space, jobs=jobs)
  5550:    107:     with open(outfile, "w", encoding="utf8") as fh:
  5551:    108:         json.dump(results, fh, indent=2, sort_keys=True)
  5552:    109:     return results
  5553:    110: 
  5554:    111: 
  5555:    112: def main() -> None:  # pragma: no cover - convenience CLI
  5556:    113:     optimize()
  5557:    114: 
  5558:    115: 
  5559:    116: if __name__ == "__main__":  # pragma: no cover
  5560:    117:     main()
  5561: 
  5562: 
  5563: ## scalper/backtest/run_multi.py (last modified: 2025-08-23 20:57:14)
  5564:      1: # annulé
  5565: 
  5566: ## scalper/backtest/runner.py (last modified: 2025-08-23 20:57:14)
  5567:      1: # scalper/backtest/runner.py
  5568:      2: from __future__ import annotations
  5569:      3: 
  5570:      4: import json
  5571:      5: import math
  5572:      6: import os
  5573:      7: import time
  5574:      8: from dataclasses import dataclass, replace
  5575:      9: from pathlib import Path
  5576:     10: from typing import Dict, List, Tuple, Callable
  5577:     11: 
  5578:     12: from .cache import ensure_csv_cache, read_csv_ohlcv, csv_path, tf_to_seconds, dump_validation_report
  5579:     13: 
  5580:     14: # --------- Chargement de la stratégie ---------
  5581:     15: def load_signal_fn() -> Callable[[str, List[List[float]], float, float], Tuple[str, float]]:
  5582:     16:     try:
  5583:     17:         from scalper.signals.factory import load_signal  # type: ignore
  5584:     18:         name = os.getenv("STRATEGY", "current")
  5585:     19:         return load_signal(name)
  5586:     20:     except Exception:
  5587:     21:         def _fallback(symbol: str, ohlcv: List[List[float]], cash: float, risk_pct: float) -> Tuple[str, float]:
  5588:     22:             closes = [r[4] for r in (ohlcv[-10:] if len(ohlcv) >= 10 else ohlcv)]
  5589:     23:             if not closes:
  5590:     24:                 return "HOLD", 0.0
  5591:     25:             avg = sum(closes) / len(closes)
  5592:     26:             last = closes[-1]
  5593:     27:             if last > avg * 1.002:
  5594:     28:                 return "BUY", 1.0
  5595:     29:             if last < avg * 0.998:
  5596:     30:                 return "SELL", 1.0
  5597:     31:             return "HOLD", 0.0
  5598:     32:         return _fallback
  5599:     33: 
  5600:     34: # --------- Config ---------
  5601:     35: @dataclass
  5602:     36: class BTCfg:
  5603:     37:     symbols: List[str]
  5604:     38:     timeframe: str = "5m"
  5605:     39:     limit: int = 1500
  5606:     40:     cash: float = 10_000.0
  5607:     41:     risk_pct: float = 0.05
  5608:     42:     slippage_bps: float = 0.0
  5609:     43:     fee_bps: float = 6.0
  5610:     44:     data_dir: str = "data"
  5611:     45:     strategy: str = os.getenv("STRATEGY", "current")
  5612:     46: 
  5613:     47: # --------- Petit moteur PnL ---------
  5614:     48: def _bps(x: float) -> float: return x / 10_000.0
  5615:     49: 
  5616:     50: def simulate_symbol(ohlcv: List[List[float]], cfg: BTCfg, signal_fn: Callable) -> Tuple[List[Tuple[int,float]], Dict]:
  5617:     51:     equity = cfg.cash
  5618:     52:     position = 0.0
  5619:     53:     entry_price = 0.0
  5620:     54:     equity_curve: List[Tuple[int, float]] = []
  5621:     55:     trades = 0
  5622:     56: 
  5623:     57:     fee = _bps(cfg.fee_bps)
  5624:     58:     slip = _bps(cfg.slippage_bps)
  5625:     59: 
  5626:     60:     for i in range(1, len(ohlcv)):
  5627:     61:         window = ohlcv[: i+1]
  5628:     62:         ts, _, _, _, price, _ = ohlcv[i]
  5629:     63:         signal, strength = signal_fn("SYMBOL", window, equity, cfg.risk_pct)
  5630:     64: 
  5631:     65:         if position != 0:
  5632:     66:             equity += position * (price - ohlcv[i-1][4])
  5633:     67: 
  5634:     68:         target_pos = 0.0
  5635:     69:         if signal == "BUY":
  5636:     70:             notional = equity * cfg.risk_pct * strength
  5637:     71:             target_pos = max(0.0, notional / price)
  5638:     72:         elif signal == "SELL":
  5639:     73:             notional = equity * cfg.risk_pct * strength
  5640:     74:             target_pos = - max(0.0, notional / price)
  5641:     75: 
  5642:     76:         if target_pos != position:
  5643:     77:             delta = target_pos - position
  5644:     78:             if delta != 0:
  5645:     79:                 trades += 1
  5646:     80:                 trade_price = price * (1 + slip * (1 if delta > 0 else -1))
  5647:     81:                 equity -= abs(delta) * trade_price * fee
  5648:     82:                 position = target_pos
  5649:     83:                 entry_price = trade_price if position != 0 else 0.0
  5650:     84: 
  5651:     85:         equity_curve.append((ts, equity))
  5652:     86: 
  5653:     87:     if position != 0 and ohlcv:
  5654:     88:         last_price = ohlcv[-1][4]
  5655:     89:         equity += position * (last_price - entry_price)
  5656:     90:         equity -= abs(position) * last_price * fee
  5657:     91:         position = 0
  5658:     92: 
  5659:     93:     eq = [e for _, e in equity_curve]
  5660:     94:     ret_tot = (eq[-1] / eq[0] - 1.0) if len(eq) >= 2 else 0.0
  5661:     95:     max_dd = 0.0
  5662:     96:     peak = -1.0
  5663:     97:     for v in eq:
  5664:     98:         if v > peak: peak = v
  5665:     99:         dd = (peak - v) / peak if peak > 0 else 0.0
  5666:    100:         max_dd = max(max_dd, dd)
  5667:    101: 
  5668:    102:     tf_sec = tf_to_seconds(cfg.timeframe)
  5669:    103:     bpy = int((365.0 * 86400.0) / tf_sec)
  5670:    104:     rets = []
  5671:    105:     for i in range(1, len(eq)):
  5672:    106:         r = (eq[i] / eq[i-1]) - 1.0
  5673:    107:         rets.append(r)
  5674:    108:     if len(rets) > 1:
  5675:    109:         mu = sum(rets) / len(rets)
  5676:    110:         var = sum((x - mu) ** 2 for x in rets) / (len(rets) - 1)
  5677:    111:         std = math.sqrt(var) if var > 0 else 0.0
  5678:    112:         sharpe = (mu * bpy) / (std * math.sqrt(bpy)) if std > 0 else 0.0
  5679:    113:     else:
  5680:    114:         sharpe = 0.0
  5681:    115: 
  5682:    116:     metrics = {
  5683:    117:         "final_equity": round(eq[-1], 4) if eq else cfg.cash,
  5684:    118:         "total_return_pct": round(ret_tot * 100, 4),
  5685:    119:         "max_drawdown_pct": round(max_dd * 100, 4),
  5686:    120:         "sharpe_like": round(sharpe, 4),
  5687:    121:         "trades": trades,
  5688:    122:     }
  5689:    123:     return equity_curve, metrics
  5690:    124: 
  5691:    125: # --------- Runner principal ---------
  5692:    126: async def run_multi(cfg: BTCfg, exchange) -> Dict:
  5693:    127:     data = await ensure_csv_cache(exchange, cfg.symbols, cfg.timeframe, cfg.limit)
  5694:    128: 
  5695:    129:     signal_fn = load_signal_fn()
  5696:    130:     per_symbol: Dict[str, Dict] = {}
  5697:    131:     aligned_ts: List[int] = []
  5698:    132: 
  5699:    133:     sets_ts = []
  5700:    134:     for s in cfg.symbols:
  5701:    135:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  5702:    136:         sets_ts.append({r[0] for r in rows})
  5703:    137:     if sets_ts:
  5704:    138:         aligned_ts = sorted(list(set.intersection(*sets_ts)))
  5705:    139: 
  5706:    140:     results_curves: Dict[str, List[Tuple[int, float]]] = {}
  5707:    141:     for s in cfg.symbols:
  5708:    142:         rows = data.get(s) or read_csv_ohlcv(csv_path(s, cfg.timeframe))
  5709:    143:         rows = [r for r in rows if r[0] in set(aligned_ts)]
  5710:    144:         curve, metr = simulate_symbol(rows, cfg, signal_fn)
  5711:    145:         results_curves[s] = curve
  5712:    146:         per_symbol[s] = metr
  5713:    147: 
  5714:    148:     fused: List[Tuple[int, float]] = []
  5715:    149:     for i in range(len(aligned_ts)):
  5716:    150:         ts = aligned_ts[i]
  5717:    151:         vals = []
  5718:    152:         for s in cfg.symbols:
  5719:    153:             cv = results_curves[s]
  5720:    154:             if i < len(cv) and cv[i][0] == ts:
  5721:    155:                 vals.append(cv[i][1])
  5722:    156:         if vals:
  5723:    157:             fused.append((ts, sum(vals) / len(vals)))
  5724:    158: 
  5725:    159:     glob_metrics = {}
  5726:    160:     if fused:
  5727:    161:         eq = [e for _, e in fused]
  5728:    162:         ret_tot = (eq[-1]/eq[0]-1.0) if len(eq)>=2 else 0.0
  5729:    163:         peak = -1.0; max_dd = 0.0
  5730:    164:         for v in eq:
  5731:    165:             if v > peak: peak = v
  5732:    166:             dd = (peak - v) / peak if peak > 0 else 0.0
  5733:    167:             max_dd = max(max_dd, dd)
  5734:    168:         tf_sec = tf_to_seconds(cfg.timeframe)
  5735:    169:         bpy = int((365.0*86400.0)/tf_sec)
  5736:    170:         rets = []
  5737:    171:         for i in range(1, len(eq)):
  5738:    172:             rets.append((eq[i]/eq[i-1]) - 1.0)
  5739:    173:         if len(rets) > 1:
  5740:    174:             mu = sum(rets)/len(rets)
  5741:    175:             var = sum((x-mu)**2 for x in rets)/(len(rets)-1)
  5742:    176:             std = math.sqrt(var) if var>0 else 0.0
  5743:    177:             sharpe = (mu*bpy)/(std*math.sqrt(bpy)) if std>0 else 0.0
  5744:    178:         else:
  5745:    179:             sharpe = 0.0
  5746:    180:         glob_metrics = {
  5747:    181:             "final_equity": round(eq[-1], 4),
  5748:    182:             "total_return_pct": round(ret_tot*100, 4),
  5749:    183:             "max_drawdown_pct": round(max_dd*100, 4),
  5750:    184:             "sharpe_like": round(sharpe, 4),
  5751:    185:         }
  5752:    186: 
  5753:    187:     stamp = time.strftime("%Y%m%d-%H%M%S")
  5754:    188:     out_dir = Path(os.getenv("BACKTEST_OUT", f"result/backtest-{stamp}"))
  5755:    189:     out_dir.mkdir(parents=True, exist_ok=True)
  5756:    190: 
  5757:    191:     (out_dir / "equity_curve.csv").write_text(
  5758:    192:         "timestamp,equity\n" + "\n".join(f"{ts},{eq:.6f}" for ts, eq in fused)
  5759:    193:     )
  5760:    194:     all_metrics = {"global": glob_metrics, "per_symbol": per_symbol}
  5761:    195:     (out_dir / "metrics.json").write_text(json.dumps(all_metrics, indent=2))
  5762:    196:     dump_validation_report(cfg.symbols, cfg.timeframe, out_dir / "csv_validation.json")
  5763:    197: 
  5764:    198:     return {
  5765:    199:         "out_dir": str(out_dir),
  5766:    200:         "equity_curve": str(out_dir / "equity_curve.csv"),
  5767:    201:         "metrics": str(out_dir / "metrics.json"),
  5768:    202:         "csv_validation": str(out_dir / "csv_validation.json"),
  5769:    203:     }
  5770:    204: 
  5771:    205: # --------- Alias rétro-compatibilité ---------
  5772:    206: # Certains fichiers live importaient: BTConfig, run_single, save_results
  5773:    207: BTConfig = BTCfg  # alias
  5774:    208: 
  5775:    209: async def run_single(cfg: BTCfg, exchange, symbol: str | None = None) -> Dict:
  5776:    210:     """Compat : lance un backtest mono-symbole en réutilisant run_multi."""
  5777:    211:     if symbol:
  5778:    212:         cfg = replace(cfg, symbols=[symbol])
  5779:    213:     return await run_multi(cfg, exchange)
  5780:    214: 
  5781:    215: def save_results(res: Dict) -> Dict:
  5782:    216:     """Compat no-op : les fichiers sont déjà écrits par run_multi."""
  5783:    217:     return res
  5784:    218: 
  5785:    219: # --------- CLI ---------
  5786:    220: if __name__ == "__main__":
  5787:    221:     import asyncio
  5788:    222:     try:
  5789:    223:         import ccxt.async_support as ccxt  # type: ignore
  5790:    224:     except Exception:
  5791:    225:         raise SystemExit("Installe ccxt: pip install ccxt")
  5792:    226: 
  5793:    227:     symbols = os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",")
  5794:    228:     cfg = BTCfg(
  5795:    229:         symbols=[s.strip().upper() for s in symbols if s.strip()],
  5796:    230:         timeframe=os.getenv("TF", "5m"),
  5797:    231:         limit=int(os.getenv("LIMIT", "1500")),
  5798:    232:         cash=float(os.getenv("CASH", "10000")),
  5799:    233:         risk_pct=float(os.getenv("RISK_PCT", "0.05")),
  5800:    234:         slippage_bps=float(os.getenv("SLIPPAGE_BPS", "0.0")),
  5801:    235:         fee_bps=float(os.getenv("FEE_BPS", "6.0")),
  5802:    236:     )
  5803:    237:     exchange = ccxt.bitget()
  5804:    238:     res = asyncio.run(run_multi(cfg, exchange))
  5805:    239:     print("Résultats écrits dans:", res["out_dir"])
  5806: 
  5807: ## scalper/backtest/walkforward.py (last modified: 2025-08-23 20:57:14)
  5808:      1: from __future__ import annotations
  5809:      2: 
  5810:      3: from itertools import product
  5811:      4: from statistics import mean, stdev
  5812:      5: from typing import Dict, Iterable, Optional
  5813:      6: 
  5814:      7: from ..strategy import max_drawdown
  5815:      8: 
  5816:      9: 
  5817:     10: def _sharpe(returns: Iterable[float]) -> float:
  5818:     11:     vals = list(returns)
  5819:     12:     if not vals:
  5820:     13:         return 0.0
  5821:     14:     mu = mean(vals)
  5822:     15:     if len(vals) > 1:
  5823:     16:         sd = stdev(vals)
  5824:     17:     else:
  5825:     18:         sd = 0.0
  5826:     19:     return mu / sd if sd > 0 else 0.0
  5827:     20: 
  5828:     21: 
  5829:     22: def _stability(equity: Iterable[float]) -> float:
  5830:     23:     curve = list(equity)
  5831:     24:     n = len(curve)
  5832:     25:     if n < 2:
  5833:     26:         return 0.0
  5834:     27:     x = list(range(n))
  5835:     28:     x_mean = sum(x) / n
  5836:     29:     y_mean = sum(curve) / n
  5837:     30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
  5838:     31:     denom = sum((xi - x_mean) ** 2 for xi in x)
  5839:     32:     if denom == 0 or ss_tot == 0:
  5840:     33:         return 0.0
  5841:     34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
  5842:     35:     a = y_mean - b * x_mean
  5843:     36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
  5844:     37:     return 1 - ss_res / ss_tot
  5845:     38: 
  5846:     39: 
  5847:     40: def walk_forward(
  5848:     41:     df,
  5849:     42:     splits: int = 5,
  5850:     43:     train_ratio: float = 0.7,
  5851:     44:     params: Optional[Dict[str, Iterable]] = None,
  5852:     45: ) -> Dict[str, float]:
  5853:     46:     """Perform walk-forward optimisation and evaluation.
  5854:     47: 
  5855:     48:     Parameters
  5856:     49:     ----------
  5857:     50:     df:
  5858:     51:         DataFrame containing per-period percentage returns. The first column is
  5859:     52:         used when a dedicated ``"returns"`` column is not found.
  5860:     53:     splits:
  5861:     54:         Number of walk-forward test windows.
  5862:     55:     train_ratio:
  5863:     56:         Proportion of the data used for training in the initial window.
  5864:     57:     params:
  5865:     58:         Optional parameter grid. If provided, columns in ``df`` matching each
  5866:     59:         parameter combination are evaluated and the best Sharpe ratio on the
  5867:     60:         training window is selected. When ``None``, the first column is used.
  5868:     61:     """
  5869:     62: 
  5870:     63:     if df.empty:
  5871:     64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
  5872:     65: 
  5873:     66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
  5874:     67:     data = df.copy()
  5875:     68: 
  5876:     69:     n = len(data)
  5877:     70:     train_len = max(1, int(n * train_ratio))
  5878:     71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
  5879:     72: 
  5880:     73:     sharpe_list = []
  5881:     74:     mdd_list = []
  5882:     75:     pnl_list = []
  5883:     76:     stability_list = []
  5884:     77: 
  5885:     78:     from . import walk_forward_windows
  5886:     79: 
  5887:     80:     indices = list(range(n))
  5888:     81: 
  5889:     82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
  5890:     83:         train_df = data.iloc[tr_idx]
  5891:     84:         test_df = data.iloc[te_idx]
  5892:     85: 
  5893:     86:         # Parameter optimisation based on Sharpe ratio
  5894:     87:         if params:
  5895:     88:             best_col = None
  5896:     89:             best_score = float("-inf")
  5897:     90:             keys, values = zip(*params.items()) if params else ([], [])
  5898:     91:             for combo in product(*values):
  5899:     92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
  5900:     93:                 if col_name not in data.columns:
  5901:     94:                     continue
  5902:     95:                 score = _sharpe(train_df[col_name])
  5903:     96:                 if score > best_score:
  5904:     97:                     best_score = score
  5905:     98:                     best_col = col_name
  5906:     99:             series = test_df[best_col] if best_col else test_df[returns_col]
  5907:    100:         else:
  5908:    101:             series = test_df[returns_col]
  5909:    102: 
  5910:    103:         sharpe_list.append(_sharpe(series))
  5911:    104:         equity = (1 + series / 100.0).cumprod()
  5912:    105:         mdd_list.append(max_drawdown(equity))
  5913:    106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
  5914:    107:         stability_list.append(_stability(equity))
  5915:    108: 
  5916:    109:     count = len(sharpe_list) or 1
  5917:    110:     mean_sharpe = sum(sharpe_list) / count
  5918:    111:     mean_mdd = sum(mdd_list) / count
  5919:    112:     mean_pnl = sum(pnl_list) / count
  5920:    113:     mean_stability = sum(stability_list) / count
  5921:    114: 
  5922:    115:     return {
  5923:    116:         "sharpe": mean_sharpe,
  5924:    117:         "mdd": mean_mdd,
  5925:    118:         "pnl": mean_pnl,
  5926:    119:         "stability": mean_stability,
  5927:    120:     }
  5928: 
  5929: 
  5930: ## scalper/bitget_client.py (last modified: 2025-08-23 20:57:14)
  5931:      1: import json
  5932:      2: import logging
  5933:      3: import time
  5934:      4: import hmac
  5935:      5: import hashlib
  5936:      6: import base64
  5937:      7: import uuid
  5938:      8: from typing import Any, Dict, List, Optional
  5939:      9: 
  5940:     10: import requests
  5941:     11: 
  5942:     12: 
  5943:     13: # Mapping of deprecated v1 product type identifiers to the new v2 names
  5944:     14: _PRODUCT_TYPE_ALIASES = {
  5945:     15:     "UMCBL": "USDT-FUTURES",
  5946:     16:     "DMCBL": "USDC-FUTURES",
  5947:     17:     "CMCBL": "COIN-FUTURES",
  5948:     18: }
  5949:     19: 
  5950:     20: # Granularity aliases from v1 to v2 nomenclature
  5951:     21: _GRANULARITY_ALIASES = {
  5952:     22:     "MIN1": "1m",
  5953:     23:     "MIN3": "3m",
  5954:     24:     "MIN5": "5m",
  5955:     25:     "MIN15": "15m",
  5956:     26:     "MIN30": "30m",
  5957:     27:     "HOUR1": "1H",
  5958:     28:     "HOUR4": "4H",
  5959:     29:     "HOUR12": "12H",
  5960:     30:     "DAY1": "1D",
  5961:     31:     "WEEK1": "1W",
  5962:     32: }
  5963:     33: 
  5964:     34: 
  5965:     35: # Default margin coin for each product type. Some authenticated endpoints
  5966:     36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
  5967:     37: # default avoids ``400 Bad Request`` responses when the caller does not provide
  5968:     38: # it explicitly.
  5969:     39: _DEFAULT_MARGIN_COIN = {
  5970:     40:     "USDT-FUTURES": "USDT",
  5971:     41:     "USDC-FUTURES": "USDC",
  5972:     42: }
  5973:     43: 
  5974:     44: 
  5975:     45: class BitgetFuturesClient:
  5976:     46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
  5977:     47: 
  5978:     48:     def __init__(
  5979:     49:         self,
  5980:     50:         access_key: str,
  5981:     51:         secret_key: str,
  5982:     52:         base_url: str,
  5983:     53:         *,
  5984:     54:         product_type: str = "USDT-FUTURES",
  5985:     55:         recv_window: int = 30,
  5986:     56:         paper_trade: bool = True,
  5987:     57:         requests_module: Any = requests,
  5988:     58:         log_event: Optional[Any] = None,
  5989:     59:         passphrase: Optional[str] = None,
  5990:     60:     ) -> None:
  5991:     61:         self.ak = access_key
  5992:     62:         self.sk = secret_key
  5993:     63:         self.base = base_url.rstrip("/")
  5994:     64:         pt = product_type.upper()
  5995:     65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
  5996:     66:         self.recv_window = recv_window
  5997:     67:         self.paper_trade = paper_trade
  5998:     68:         self.requests = requests_module
  5999:     69:         self.log_event = log_event or (lambda *a, **k: None)
  6000:     70:         self.passphrase = passphrase
  6001:     71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
  6002:     72:             logging.warning(
  6003:     73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
  6004:     74:             )
  6005:     75:         # Cache for contract precision details to avoid repeated network calls
  6006:     76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
  6007:     77: 
  6008:     78:     # ------------------------------------------------------------------
  6009:     79:     # Helpers
  6010:     80:     # ------------------------------------------------------------------
  6011:     81:     @staticmethod
  6012:     82:     def _ms() -> int:
  6013:     83:         return int(time.time() * 1000)
  6014:     84: 
  6015:     85:     @staticmethod
  6016:     86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
  6017:     87:         if not params:
  6018:     88:             return ""
  6019:     89:         items = []
  6020:     90:         for k in sorted(params.keys()):
  6021:     91:             v = "" if params[k] is None else str(params[k])
  6022:     92:             items.append(f"{k}={v}")
  6023:     93:         return "&".join(items)
  6024:     94: 
  6025:     95:     def _sign(self, prehash: str) -> str:
  6026:     96:         """Return a base64-encoded HMAC SHA256 signature."""
  6027:     97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
  6028:     98:         return base64.b64encode(digest).decode()
  6029:     99: 
  6030:    100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
  6031:    101:         headers = {
  6032:    102:             "ACCESS-KEY": self.ak,
  6033:    103:             "ACCESS-SIGN": signature,
  6034:    104:             "ACCESS-TIMESTAMP": str(timestamp),
  6035:    105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
  6036:    106:             "Content-Type": "application/json",
  6037:    107:         }
  6038:    108:         if self.passphrase:
  6039:    109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
  6040:    110:         return headers
  6041:    111: 
  6042:    112:     def _format_symbol(self, symbol: str) -> str:
  6043:    113:         """Return ``symbol`` formatted for Bitget API.
  6044:    114: 
  6045:    115:         The v2 endpoints expect the trading pair without any product type
  6046:    116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
  6047:    117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
  6048:    118:         separators and any trailing product type string (legacy or v2).
  6049:    119:         """
  6050:    120: 
  6051:    121:         if not symbol:
  6052:    122:             return symbol
  6053:    123: 
  6054:    124:         sym = symbol.replace("_", "").upper()
  6055:    125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
  6056:    126:         if sym.endswith(self.product_type):
  6057:    127:             sym = sym[: -len(self.product_type)]
  6058:    128:         else:
  6059:    129:             for old in _PRODUCT_TYPE_ALIASES.keys():
  6060:    130:                 if sym.endswith(old):
  6061:    131:                     sym = sym[: -len(old)]
  6062:    132:                     break
  6063:    133:         return sym
  6064:    134: 
  6065:    135:     def _product_type(self, pt: Optional[str] = None) -> str:
  6066:    136:         """Normalise ``pt`` to a valid v2 product type identifier."""
  6067:    137:         key = (pt or self.product_type or "").upper()
  6068:    138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
  6069:    139: 
  6070:    140:     # ------------------------------------------------------------------
  6071:    141:     # Public endpoints
  6072:    142:     # ------------------------------------------------------------------
  6073:    143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  6074:    144:         """Return futures contract information.
  6075:    145: 
  6076:    146:         The previous implementation queried ``/contract-detail`` which does not
  6077:    147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
  6078:    148:         endpoint is ``/contracts`` with the symbol supplied as a query
  6079:    149:         parameter."""
  6080:    150: 
  6081:    151:         url = f"{self.base}/api/v2/mix/market/contracts"
  6082:    152:         params: Dict[str, Any] = {"productType": self.product_type}
  6083:    153:         if symbol:
  6084:    154:             params["symbol"] = self._format_symbol(symbol)
  6085:    155:         r = self.requests.get(url, params=params, timeout=15)
  6086:    156:         if r.status_code == 404:  # pragma: no cover - depends on network
  6087:    157:             logging.error("Contract detail introuvable pour %s", symbol)
  6088:    158:             return {"success": False, "code": 404, "data": None}
  6089:    159:         r.raise_for_status()
  6090:    160:         return r.json()
  6091:    161: 
  6092:    162:     # ------------------------------------------------------------------
  6093:    163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
  6094:    164:         """Return price and volume precision for ``symbol``.
  6095:    165: 
  6096:    166:         Results are cached to minimise HTTP requests. If the contract
  6097:    167:         information cannot be retrieved, ``(0, 0)`` is returned.
  6098:    168:         """
  6099:    169:         sym = self._format_symbol(symbol)
  6100:    170:         info = self._contract_cache.get(sym)
  6101:    171:         if info is None:
  6102:    172:             detail = self.get_contract_detail(sym)
  6103:    173:             try:
  6104:    174:                 data = detail.get("data", [])
  6105:    175:                 if isinstance(data, list) and data:
  6106:    176:                     info = data[0]
  6107:    177:                 else:
  6108:    178:                     info = {}
  6109:    179:             except Exception:
  6110:    180:                 info = {}
  6111:    181:             self._contract_cache[sym] = info
  6112:    182:         price_place = int(info.get("pricePlace") or 0)
  6113:    183:         volume_place = int(info.get("volumePlace") or 0)
  6114:    184:         return price_place, volume_place
  6115:    185: 
  6116:    186:     def get_kline(
  6117:    187:         self,
  6118:    188:         symbol: str,
  6119:    189:         interval: str = "1m",
  6120:    190:         start: Optional[int] = None,
  6121:    191:         end: Optional[int] = None,
  6122:    192:     ) -> Dict[str, Any]:
  6123:    193:         # Endpoint expects the trading pair in query parameters rather than
  6124:    194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
  6125:    195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
  6126:    196:         url = f"{self.base}/api/v2/mix/market/candles"
  6127:    197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
  6128:    198:         params: Dict[str, Any] = {
  6129:    199:             "symbol": self._format_symbol(symbol),
  6130:    200:             "productType": self.product_type,
  6131:    201:             "granularity": interval_norm,
  6132:    202:         }
  6133:    203:         if start is not None:
  6134:    204:             params["startTime"] = int(start)
  6135:    205:         if end is not None:
  6136:    206:             params["endTime"] = int(end)
  6137:    207:         r = self.requests.get(url, params=params, timeout=15)
  6138:    208:         r.raise_for_status()
  6139:    209:         data = r.json()
  6140:    210: 
  6141:    211:         rows = data.get("data") if isinstance(data, dict) else None
  6142:    212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
  6143:    213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  6144:    214:             for row in rows:
  6145:    215:                 if len(row) < 7:
  6146:    216:                     continue
  6147:    217:                 try:
  6148:    218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
  6149:    219:                     cols["ts"].append(int(ts))
  6150:    220:                     cols["open"].append(float(op))
  6151:    221:                     cols["high"].append(float(hi))
  6152:    222:                     cols["low"].append(float(lo))
  6153:    223:                     cols["close"].append(float(cl))
  6154:    224:                     cols["volume"].append(float(vol))
  6155:    225:                     cols["quoteVolume"].append(float(qv))
  6156:    226:                 except (TypeError, ValueError):
  6157:    227:                     continue
  6158:    228:             data["data"] = cols
  6159:    229:         elif isinstance(rows, list):
  6160:    230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
  6161:    231:         return data
  6162:    232: 
  6163:    233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  6164:    234:         if symbol:
  6165:    235:             url = f"{self.base}/api/v2/mix/market/ticker"
  6166:    236:             params = {
  6167:    237:                 "symbol": self._format_symbol(symbol),
  6168:    238:                 "productType": self.product_type,
  6169:    239:             }
  6170:    240:         else:
  6171:    241:             url = f"{self.base}/api/v2/mix/market/tickers"
  6172:    242:             params = {"productType": self.product_type}
  6173:    243:         r = self.requests.get(url, params=params, timeout=15)
  6174:    244:         r.raise_for_status()
  6175:    245:         return r.json()
  6176:    246: 
  6177:    247:     # ------------------------------------------------------------------
  6178:    248:     # Private endpoints
  6179:    249:     # ------------------------------------------------------------------
  6180:    250:     def _private_request(
  6181:    251:         self,
  6182:    252:         method: str,
  6183:    253:         path: str,
  6184:    254:         *,
  6185:    255:         params: Optional[Dict[str, Any]] = None,
  6186:    256:         body: Optional[Dict[str, Any]] = None,
  6187:    257:     ) -> Dict[str, Any]:
  6188:    258:         method = method.upper()
  6189:    259:         ts = self._ms()
  6190:    260: 
  6191:    261:         if method in ("GET", "DELETE"):
  6192:    262:             qs = self._urlencode_sorted(params or {})
  6193:    263:             req_path = path + (f"?{qs}" if qs else "")
  6194:    264:             sig = self._sign(f"{ts}{method}{req_path}")
  6195:    265:             headers = self._headers(sig, ts)
  6196:    266:             url = f"{self.base}{req_path}"
  6197:    267:             r = self.requests.request(method, url, headers=headers, timeout=20)
  6198:    268:         elif method == "POST":
  6199:    269:             qs = self._urlencode_sorted(params or {})
  6200:    270:             req_path = path + (f"?{qs}" if qs else "")
  6201:    271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
  6202:    272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
  6203:    273:             headers = self._headers(sig, ts)
  6204:    274:             url = f"{self.base}{req_path}"
  6205:    275:             r = self.requests.post(
  6206:    276:                 url,
  6207:    277:                 data=body_str.encode("utf-8"),
  6208:    278:                 headers=headers,
  6209:    279:                 timeout=20,
  6210:    280:             )
  6211:    281:         else:
  6212:    282:             raise ValueError("M\u00e9thode non support\u00e9e")
  6213:    283: 
  6214:    284:         resp_text = getattr(r, "text", "")
  6215:    285:         try:
  6216:    286:             data = r.json()
  6217:    287:         except Exception:
  6218:    288:             data = {
  6219:    289:                 "success": False,
  6220:    290:                 "error": resp_text,
  6221:    291:                 "status_code": getattr(r, "status_code", None),
  6222:    292:             }
  6223:    293: 
  6224:    294:         status = getattr(r, "status_code", 0)
  6225:    295:         if status >= 400:
  6226:    296:             code = str(data.get("code")) if isinstance(data, dict) else ""
  6227:    297:             if code == "22001":
  6228:    298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
  6229:    299:             else:
  6230:    300:                 try:
  6231:    301:                     r.raise_for_status()
  6232:    302:                 except Exception as e:
  6233:    303:                     if not resp_text:
  6234:    304:                         resp_text = getattr(r, "text", "") or str(e)
  6235:    305:                 logging.error(
  6236:    306:                     "Erreur HTTP/JSON %s %s -> %s %s",
  6237:    307:                     method,
  6238:    308:                     path,
  6239:    309:                     status,
  6240:    310:                     resp_text,
  6241:    311:                 )
  6242:    312:                 if isinstance(data, dict):
  6243:    313:                     data.setdefault("success", False)
  6244:    314:                     data.setdefault("status_code", status)
  6245:    315:                     data.setdefault("error", resp_text)
  6246:    316: 
  6247:    317:         self.log_event(
  6248:    318:             "http_private",
  6249:    319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
  6250:    320:         )
  6251:    321:         return data
  6252:    322: 
  6253:    323:     # Accounts & positions -------------------------------------------------
  6254:    324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
  6255:    325:         if self.paper_trade:
  6256:    326:             return {
  6257:    327:                 "success": True,
  6258:    328:                 "code": 0,
  6259:    329:                 "data": [
  6260:    330:                     {
  6261:    331:                         "currency": "USDT",
  6262:    332:                         "equity": 100.0,
  6263:    333:                     }
  6264:    334:                 ],
  6265:    335:             }
  6266:    336: 
  6267:    337:         params = {"productType": self.product_type}
  6268:    338:         if margin_coin is None:
  6269:    339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  6270:    340:         if margin_coin:
  6271:    341:             params["marginCoin"] = margin_coin
  6272:    342:         data = self._private_request(
  6273:    343:             "GET", "/api/v2/mix/account/accounts", params=params
  6274:    344:         )
  6275:    345:         if isinstance(data, dict):
  6276:    346:             data.setdefault("success", str(data.get("code")) == "00000")
  6277:    347:         try:
  6278:    348:             for row in data.get("data", []):
  6279:    349:                 if "currency" not in row and row.get("marginCoin"):
  6280:    350:                     row["currency"] = str(row["marginCoin"]).upper()
  6281:    351:                 chosen = None
  6282:    352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
  6283:    353:                     val = row.get(key)
  6284:    354:                     if val is not None:
  6285:    355:                         chosen = val
  6286:    356:                         break
  6287:    357:                 if chosen is not None:
  6288:    358:                     row["equity"] = chosen
  6289:    359:                 try:
  6290:    360:                     row["equity"] = float(row["equity"])
  6291:    361:                 except Exception:
  6292:    362:                     pass
  6293:    363:         except Exception:  # pragma: no cover - best effort
  6294:    364:             pass
  6295:    365:         return data
  6296:    366: 
  6297:    367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  6298:    368:         if self.paper_trade:
  6299:    369:             return {"success": True, "code": 0, "data": []}
  6300:    370:         data = self._private_request(
  6301:    371:             "GET",
  6302:    372:             "/api/v2/mix/position/all-position",
  6303:    373:             params={"productType": self._product_type(product_type)},
  6304:    374:         )
  6305:    375:         try:
  6306:    376:             positions = data.get("data", [])
  6307:    377:             filtered = []
  6308:    378:             for pos in positions:
  6309:    379:                 vol = pos.get("vol")
  6310:    380:                 try:
  6311:    381:                     if vol is not None and float(vol) > 0:
  6312:    382:                         filtered.append(pos)
  6313:    383:                 except (TypeError, ValueError):
  6314:    384:                     continue
  6315:    385:             data["data"] = filtered
  6316:    386:         except Exception:  # pragma: no cover - best effort
  6317:    387:             pass
  6318:    388:         return data
  6319:    389: 
  6320:    390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
  6321:    391:         if self.paper_trade:
  6322:    392:             return {"success": True, "code": 0, "data": []}
  6323:    393:         params: Dict[str, Any] = {"productType": self.product_type}
  6324:    394:         if symbol:
  6325:    395:             params["symbol"] = self._format_symbol(symbol)
  6326:    396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
  6327:    397: 
  6328:    398:     # Account configuration -------------------------------------------------
  6329:    399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
  6330:    400:         body = {
  6331:    401:             "productType": self._product_type(product_type),
  6332:    402:             "symbol": self._format_symbol(symbol),
  6333:    403:             "posMode": "one_way_mode",
  6334:    404:         }
  6335:    405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
  6336:    406: 
  6337:    407:     def set_leverage(
  6338:    408:         self,
  6339:    409:         symbol: str,
  6340:    410:         product_type: Optional[str] = None,
  6341:    411:         margin_coin: str = "USDT",
  6342:    412:         leverage: int = 1,
  6343:    413:     ) -> Dict[str, Any]:
  6344:    414:         body = {
  6345:    415:             "symbol": self._format_symbol(symbol),
  6346:    416:             "productType": self._product_type(product_type),
  6347:    417:             "marginCoin": margin_coin,
  6348:    418:             "leverage": int(leverage),
  6349:    419:         }
  6350:    420:         return self._private_request(
  6351:    421:             "POST", "/api/v2/mix/account/set-leverage", body=body
  6352:    422:         )
  6353:    423: 
  6354:    424:     def place_market_order_one_way(
  6355:    425:         self,
  6356:    426:         symbol: str,
  6357:    427:         side: str,
  6358:    428:         size: float,
  6359:    429:         product_type: Optional[str] = None,
  6360:    430:         margin_coin: str = "USDT",
  6361:    431:         *,
  6362:    432:         time_in_force: str = "normal",
  6363:    433:     ) -> Dict[str, Any]:
  6364:    434:         side = side.lower()
  6365:    435:         if side not in {"buy", "sell"}:
  6366:    436:             raise ValueError("side must be 'buy' or 'sell'")
  6367:    437:         body = {
  6368:    438:             "symbol": self._format_symbol(symbol),
  6369:    439:             "productType": self._product_type(product_type),
  6370:    440:             "marginCoin": margin_coin,
  6371:    441:             "marginMode": "crossed",
  6372:    442:             "posMode": "one_way_mode",
  6373:    443:             "orderType": "market",
  6374:    444:             "side": side,
  6375:    445:             "size": str(size),
  6376:    446:             "timeInForceValue": time_in_force,
  6377:    447:             "clientOid": str(uuid.uuid4())[:32],
  6378:    448:         }
  6379:    449:         return self._private_request(
  6380:    450:             "POST", "/api/v2/mix/order/place-order", body=body
  6381:    451:         )
  6382:    452: 
  6383:    453:     # Orders ---------------------------------------------------------------
  6384:    454:     def place_order(
  6385:    455:         self,
  6386:    456:         symbol: str,
  6387:    457:         side: int,
  6388:    458:         vol: int,
  6389:    459:         order_type: int,
  6390:    460:         *,
  6391:    461:         price: Optional[float] = None,
  6392:    462:         open_type: int = 1,
  6393:    463:         leverage: Optional[int] = None,
  6394:    464:         position_id: Optional[int] = None,
  6395:    465:         external_oid: Optional[str] = None,
  6396:    466:         stop_loss: Optional[float] = None,
  6397:    467:         take_profit: Optional[float] = None,
  6398:    468:         position_mode: Optional[int] = None,
  6399:    469:         margin_coin: Optional[str] = None,
  6400:    470:         time_in_force: str = "normal",
  6401:    471:     ) -> Dict[str, Any]:
  6402:    472:         """Submit an order.
  6403:    473: 
  6404:    474:         This helper keeps backward compatibility with the older numeric
  6405:    475:         parameters used by the bot while translating them to the string based
  6406:    476:         fields required by Bitget's v2 API.
  6407:    477:         """
  6408:    478:         if self.paper_trade:
  6409:    479:             logging.info(
  6410:    480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
  6411:    481:                 side,
  6412:    482:                 vol,
  6413:    483:                 order_type,
  6414:    484:                 price,
  6415:    485:             )
  6416:    486:             return {
  6417:    487:                 "success": True,
  6418:    488:                 "paperTrade": True,
  6419:    489:                 "simulated": {
  6420:    490:                     "symbol": symbol,
  6421:    491:                     "side": side,
  6422:    492:                     "vol": vol,
  6423:    493:                     "type": order_type,
  6424:    494:                     "price": price,
  6425:    495:                     "openType": open_type,
  6426:    496:                     "leverage": leverage,
  6427:    497:                     "stopLossPrice": stop_loss,
  6428:    498:                     "takeProfitPrice": take_profit,
  6429:    499:                 },
  6430:    500:             }
  6431:    501: 
  6432:    502:         # ------------------------------------------------------------------
  6433:    503:         # Parameter mapping
  6434:    504:         # ------------------------------------------------------------------
  6435:    505:         side_map = {
  6436:    506:             1: ("buy", "long"),
  6437:    507:             2: ("buy", "short"),
  6438:    508:             3: ("sell", "short"),
  6439:    509:             4: ("sell", "long"),
  6440:    510:         }
  6441:    511:         if isinstance(side, int):
  6442:    512:             mapped = side_map.get(side)
  6443:    513:             if not mapped:
  6444:    514:                 raise ValueError(f"Invalid side value: {side}")
  6445:    515:             side_str, pos_side = mapped
  6446:    516:         else:
  6447:    517:             side_str = str(side)
  6448:    518:             pos_side = None
  6449:    519: 
  6450:    520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
  6451:    521:         if isinstance(order_type, int):
  6452:    522:             order_str = order_map.get(order_type)
  6453:    523:             if order_str is None:
  6454:    524:                 order_str = "limit" if price is not None else "market"
  6455:    525:         else:
  6456:    526:             order_str = str(order_type)
  6457:    527: 
  6458:    528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
  6459:    529: 
  6460:    530:         if margin_coin is None:
  6461:    531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  6462:    532: 
  6463:    533:         # ------------------------------------------------------------------
  6464:    534:         # Precision handling
  6465:    535:         # ------------------------------------------------------------------
  6466:    536:         try:
  6467:    537:             price_place, volume_place = self._get_contract_precision(symbol)
  6468:    538:         except Exception:  # pragma: no cover - best effort
  6469:    539:             price_place = volume_place = 0
  6470:    540:         if price is not None:
  6471:    541:             price = round(float(price), price_place)
  6472:    542:         if vol is not None:
  6473:    543:             vol = round(float(vol), volume_place)
  6474:    544: 
  6475:    545:         body = {
  6476:    546:             "symbol": self._format_symbol(symbol),
  6477:    547:             "productType": self.product_type,
  6478:    548:             "marginMode": margin_mode,
  6479:    549:             "orderType": order_str,
  6480:    550:             "side": side_str,
  6481:    551:             "size": vol,
  6482:    552:             "timeInForceValue": time_in_force,
  6483:    553:         }
  6484:    554:         if pos_side is not None:
  6485:    555:             body["posSide"] = pos_side
  6486:    556:         if margin_coin:
  6487:    557:             body["marginCoin"] = margin_coin
  6488:    558:         if price is not None:
  6489:    559:             body["price"] = float(price)
  6490:    560:         if leverage is not None:
  6491:    561:             body["leverage"] = int(leverage)
  6492:    562:         if position_id is not None:
  6493:    563:             body["positionId"] = int(position_id)
  6494:    564:         if external_oid:
  6495:    565:             body["clientOid"] = str(external_oid)[:32]
  6496:    566:         else:
  6497:    567:             body["clientOid"] = str(uuid.uuid4())[:32]
  6498:    568:         if stop_loss is not None:
  6499:    569:             body["stopLossPrice"] = float(stop_loss)
  6500:    570:         if take_profit is not None:
  6501:    571:             body["takeProfitPrice"] = float(take_profit)
  6502:    572:         if position_mode is not None:
  6503:    573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
  6504:    574:         elif pos_side is not None:
  6505:    575:             body["posMode"] = "hedge_mode"
  6506:    576: 
  6507:    577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
  6508:    578: 
  6509:    579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
  6510:    580:         if self.paper_trade:
  6511:    581:             logging.info(
  6512:    582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
  6513:    583:             )
  6514:    584:             return {"success": True, "code": 0}
  6515:    585:         return self._private_request(
  6516:    586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
  6517:    587:         )
  6518:    588: 
  6519:    589:     def cancel_all(
  6520:    590:         self,
  6521:    591:         symbol: Optional[str] = None,
  6522:    592:         margin_coin: Optional[str] = None,
  6523:    593:     ) -> Dict[str, Any]:
  6524:    594:         if self.paper_trade:
  6525:    595:             logging.info(
  6526:    596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
  6527:    597:             )
  6528:    598:             return {"success": True, "code": 0}
  6529:    599:         body = {"productType": self.product_type}
  6530:    600:         if symbol:
  6531:    601:             body["symbol"] = self._format_symbol(symbol)
  6532:    602:         if margin_coin is None:
  6533:    603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
  6534:    604:         if margin_coin:
  6535:    605:             body["marginCoin"] = margin_coin
  6536:    606:         return self._private_request(
  6537:    607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
  6538:    608:         )
  6539:    609: 
  6540:    610:     def close_position(
  6541:    611:         self,
  6542:    612:         symbol: str,
  6543:    613:         size: Optional[int] = None,
  6544:    614:         hold_side: Optional[str] = None,
  6545:    615:     ) -> Dict[str, Any]:
  6546:    616:         """Close an open position for ``symbol``.
  6547:    617: 
  6548:    618:         Parameters
  6549:    619:         ----------
  6550:    620:         symbol:
  6551:    621:             Trading symbol to close.
  6552:    622:         size:
  6553:    623:             Optional number of contracts to close. If omitted the entire
  6554:    624:             position is closed.
  6555:    625:         hold_side:
  6556:    626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
  6557:    627:             specified. If not provided the exchange will infer it.
  6558:    628:         """
  6559:    629: 
  6560:    630:         if self.paper_trade:
  6561:    631:             logging.info(
  6562:    632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
  6563:    633:             )
  6564:    634:             return {"success": True, "code": 0}
  6565:    635: 
  6566:    636:         body = {"symbol": self._format_symbol(symbol)}
  6567:    637:         if size is not None:
  6568:    638:             body["size"] = int(size)
  6569:    639:         if hold_side:
  6570:    640:             body["holdSide"] = hold_side
  6571:    641: 
  6572:    642:         body["productType"] = self.product_type
  6573:    643:         return self._private_request(
  6574:    644:             "POST", "/api/v2/mix/position/close-position", body=body
  6575:    645:         )
  6576:    646: 
  6577:    647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
  6578:    648:         """Close all open positions."""
  6579:    649:         results = []
  6580:    650:         try:
  6581:    651:             for pos in self.get_positions(product_type).get("data", []):
  6582:    652:                 sym = pos.get("symbol")
  6583:    653:                 if sym:
  6584:    654:                     results.append(self.close_position(sym))
  6585:    655:         except Exception as exc:  # pragma: no cover - best effort
  6586:    656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
  6587:    657:         return {"success": True, "data": results}
  6588: 
  6589: 
  6590: ## scalper/client.py (last modified: 2025-08-23 20:57:14)
  6591:      1: import logging
  6592:      2: from typing import Any, Dict, Optional
  6593:      3: 
  6594:      4: import requests
  6595:      5: from requests.adapters import HTTPAdapter
  6596:      6: from urllib3.util.retry import Retry
  6597:      7: 
  6598:      8: 
  6599:      9: class HTTPError(RuntimeError):
  6600:     10:     """Raised when an HTTP request fails"""
  6601:     11: 
  6602:     12: 
  6603:     13: class HttpClient:
  6604:     14:     """Simple HTTP client with persistent session and retry logic.
  6605:     15: 
  6606:     16:     The client exposes a :py:meth:`close` method and implements the context
  6607:     17:     manager protocol so it can be used with ``with`` statements to ensure
  6608:     18:     that the underlying :class:`requests.Session` is properly closed.
  6609:     19:     """
  6610:     20: 
  6611:     21:     def __init__(
  6612:     22:         self,
  6613:     23:         base_url: str,
  6614:     24:         *,
  6615:     25:         timeout: float = 10.0,
  6616:     26:         max_retries: int = 3,
  6617:     27:         backoff_factor: float = 0.3,
  6618:     28:         status_forcelist: Optional[list[int]] = None,
  6619:     29:     ) -> None:
  6620:     30:         self.base_url = base_url.rstrip("/")
  6621:     31:         self.timeout = timeout
  6622:     32:         self.session = requests.Session()
  6623:     33:         retry = Retry(
  6624:     34:             total=max_retries,
  6625:     35:             backoff_factor=backoff_factor,
  6626:     36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
  6627:     37:             allowed_methods=[
  6628:     38:                 "HEAD",
  6629:     39:                 "GET",
  6630:     40:                 "OPTIONS",
  6631:     41:                 "POST",
  6632:     42:                 "PUT",
  6633:     43:                 "DELETE",
  6634:     44:                 "PATCH",
  6635:     45:             ],
  6636:     46:         )
  6637:     47:         adapter = HTTPAdapter(max_retries=retry)
  6638:     48:         self.session.mount("http://", adapter)
  6639:     49:         self.session.mount("https://", adapter)
  6640:     50: 
  6641:     51:     def close(self) -> None:
  6642:     52:         """Close the underlying :class:`requests.Session`."""
  6643:     53:         self.session.close()
  6644:     54: 
  6645:     55:     # ------------------------------------------------------------------
  6646:     56:     # Context manager support
  6647:     57:     # ------------------------------------------------------------------
  6648:     58:     def __enter__(self) -> "HttpClient":
  6649:     59:         return self
  6650:     60: 
  6651:     61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
  6652:     62:         self.close()
  6653:     63: 
  6654:     64:     def request(
  6655:     65:         self,
  6656:     66:         method: str,
  6657:     67:         path: str,
  6658:     68:         *,
  6659:     69:         params: Optional[Dict[str, Any]] = None,
  6660:     70:         json: Optional[Dict[str, Any]] = None,
  6661:     71:         headers: Optional[Dict[str, str]] = None,
  6662:     72:     ) -> Dict[str, Any]:
  6663:     73:         """Perform an HTTP request and return JSON data.
  6664:     74: 
  6665:     75:         Errors during the request raise ``HTTPError``. If the response cannot
  6666:     76:         be decoded as JSON, a dictionary describing the issue is returned.
  6667:     77:         """
  6668:     78:         url = f"{self.base_url}{path}"
  6669:     79:         try:
  6670:     80:             resp = self.session.request(
  6671:     81:                 method,
  6672:     82:                 url,
  6673:     83:                 params=params,
  6674:     84:                 json=json,
  6675:     85:                 headers=headers,
  6676:     86:                 timeout=self.timeout,
  6677:     87:             )
  6678:     88:             resp.raise_for_status()
  6679:     89:         except requests.RequestException as exc:  # network or HTTP errors
  6680:     90:             msg = f"HTTP error calling {url}: {exc}"
  6681:     91:             logging.error(msg)
  6682:     92:             raise HTTPError(msg) from exc
  6683:     93: 
  6684:     94:         try:
  6685:     95:             return resp.json()
  6686:     96:         except ValueError:  # invalid JSON
  6687:     97:             msg = "Invalid JSON in response"
  6688:     98:             logging.error("%s for %s: %s", msg, url, resp.text)
  6689:     99:             return {"success": False, "error": msg, "text": resp.text}
  6690: 
  6691: 
  6692: ## scalper/config/__init__.py (last modified: 2025-08-23 20:57:14)
  6693:      1: from .loader import load_settings
  6694:      2: __all__ = ['load_settings']
  6695: 
  6696: 
  6697: ## scalper/config/loader.py (last modified: 2025-08-23 20:57:14)
  6698:      1: # scalp/config/loader.py
  6699:      2: from __future__ import annotations
  6700:      3: import os, json
  6701:      4: from typing import Any, Dict, Tuple
  6702:      5: 
  6703:      6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
  6704:      7: try:
  6705:      8:     import yaml  # type: ignore
  6706:      9: except Exception:
  6707:     10:     yaml = None  # fallback JSON si besoin
  6708:     11: 
  6709:     12: # dotenv (facultatif) pour charger un .env automatiquement
  6710:     13: try:
  6711:     14:     from dotenv import load_dotenv  # type: ignore
  6712:     15: except Exception:
  6713:     16:     load_dotenv = None
  6714:     17: 
  6715:     18: # ---------------- Utils ----------------
  6716:     19: 
  6717:     20: def _parse_bool(x: Any, default: bool = False) -> bool:
  6718:     21:     if isinstance(x, bool): return x
  6719:     22:     s = str(x).strip().lower()
  6720:     23:     if s in ("1","true","yes","y","on"): return True
  6721:     24:     if s in ("0","false","no","n","off",""): return False
  6722:     25:     return default
  6723:     26: 
  6724:     27: def _parse_float(x: Any, default: float | None = None) -> float | None:
  6725:     28:     try: return float(x)
  6726:     29:     except Exception: return default
  6727:     30: 
  6728:     31: def _parse_int(x: Any, default: int | None = None) -> int | None:
  6729:     32:     try: return int(str(x).strip())
  6730:     33:     except Exception: return default
  6731:     34: 
  6732:     35: def _parse_csv(x: Any) -> list[str]:
  6733:     36:     if x is None: return []
  6734:     37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
  6735:     38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
  6736:     39: 
  6737:     40: def _read_yaml(path: str) -> Dict[str, Any]:
  6738:     41:     if not os.path.exists(path): return {}
  6739:     42:     with open(path, "r", encoding="utf-8") as f:
  6740:     43:         if yaml:
  6741:     44:             return yaml.safe_load(f) or {}
  6742:     45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
  6743:     46:         try:
  6744:     47:             return json.load(f)
  6745:     48:         except Exception:
  6746:     49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
  6747:     50: 
  6748:     51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
  6749:     52:     # shallow merge suffisant ici (structure plate)
  6750:     53:     out = dict(a)
  6751:     54:     out.update({k: v for k, v in b.items() if v is not None})
  6752:     55:     return out
  6753:     56: 
  6754:     57: # ---------------- Public API ----------------
  6755:     58: 
  6756:     59: def load_settings(
  6757:     60:     config_path: str = "config.yml",
  6758:     61:     config_local_path: str = "config.local.yml",
  6759:     62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
  6760:     63:     """
  6761:     64:     Retourne (config_runtime, secrets) :
  6762:     65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
  6763:     66:       - secrets        : clés API & tokens (NE PAS versionner)
  6764:     67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
  6765:     68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
  6766:     69:     """
  6767:     70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
  6768:     71:     if load_dotenv is not None:
  6769:     72:         load_dotenv(override=False)
  6770:     73: 
  6771:     74:     # 2) Charge YAML (config.yml + override local)
  6772:     75:     base = _read_yaml(config_path)
  6773:     76:     local = _read_yaml(config_local_path)
  6774:     77:     cfg = _merge_dict(base, local)
  6775:     78: 
  6776:     79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
  6777:     80:     env_overlay: Dict[str, Any] = {}
  6778:     81:     # Verbosité
  6779:     82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
  6780:     83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
  6781:     84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
  6782:     85:     # Runtime / Stratégie
  6783:     86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
  6784:     87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
  6785:     88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
  6786:     89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
  6787:     90:     # Watchlist
  6788:     91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
  6789:     92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
  6790:     93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
  6791:     94:     )
  6792:     95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
  6793:     96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
  6794:     97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
  6795:     98:     caps_env = os.getenv("CAPS_JSON")
  6796:     99:     if caps_env:
  6797:    100:         try:
  6798:    101:             env_overlay["CAPS"] = json.loads(caps_env)
  6799:    102:         except Exception:
  6800:    103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
  6801:    104:     else:
  6802:    105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
  6803:    106: 
  6804:    107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
  6805:    108:     secrets = {
  6806:    109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
  6807:    110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
  6808:    111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
  6809:    112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
  6810:    113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
  6811:    114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
  6812:    115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
  6813:    116:     }
  6814:    117: 
  6815:    118:     # 5) Runtime normalisé pour l’orchestrateur
  6816:    119:     runtime = {
  6817:    120:         "quiet": bool(env_overlay["QUIET"]),
  6818:    121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
  6819:    122:         "timeframe": str(env_overlay["TIMEFRAME"]),
  6820:    123:         "cash": float(env_overlay["CASH"]),
  6821:    124:         "risk_pct": float(env_overlay["RISK_PCT"]),
  6822:    125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
  6823:    126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
  6824:    127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
  6825:    128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
  6826:    129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
  6827:    130:         "caps": env_overlay["CAPS"],                        # dict
  6828:    131:         # rempli au boot par les frais Bitget
  6829:    132:         "fees_by_symbol": {}, 
  6830:    133:     }
  6831:    134: 
  6832:    135:     return runtime, secrets
  6833:    136:     
  6834: 
  6835: ## scalper/exchange/__init__.py (last modified: 2025-08-23 20:57:14)
  6836:      1: # package
  6837: 
  6838: 
  6839: ## scalper/exchange/bitget_ccxt.py (last modified: 2025-08-23 20:57:14)
  6840:      1: # scalper/exchange/bitget_ccxt.py
  6841:      2: from __future__ import annotations
  6842:      3: 
  6843:      4: import asyncio
  6844:      5: import csv
  6845:      6: import os
  6846:      7: import time
  6847:      8: from typing import Any, List, Optional
  6848:      9: 
  6849:     10: # CCXT async
  6850:     11: try:
  6851:     12:     import ccxt.async_support as ccxt
  6852:     13: except Exception as e:  # noqa: BLE001
  6853:     14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
  6854:     15: 
  6855:     16: 
  6856:     17: def _now_ms() -> int:
  6857:     18:     return int(time.time() * 1000)
  6858:     19: 
  6859:     20: 
  6860:     21: class BitgetExchange:
  6861:     22:     """
  6862:     23:     Échange Bitget via CCXT (async) avec cache CSV local.
  6863:     24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
  6864:     25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
  6865:     26:         [[ts, open, high, low, close, volume], ...]
  6866:     27:     """
  6867:     28: 
  6868:     29:     def __init__(
  6869:     30:         self,
  6870:     31:         *,
  6871:     32:         api_key: Optional[str] = None,
  6872:     33:         secret: Optional[str] = None,
  6873:     34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
  6874:     35:         data_dir: str = "/notebooks/data",
  6875:     36:         use_cache: bool = True,
  6876:     37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
  6877:     38:         spot: bool = True,           # True = SPOT (recommandé ici)
  6878:     39:     ) -> None:
  6879:     40:         self.data_dir = data_dir
  6880:     41:         self.use_cache = use_cache
  6881:     42:         self.min_fresh = int(min_fresh_seconds)
  6882:     43:         self.spot = spot
  6883:     44: 
  6884:     45:         os.makedirs(self.data_dir, exist_ok=True)
  6885:     46: 
  6886:     47:         # Instance CCXT (async)
  6887:     48:         self.ex = ccxt.bitget({
  6888:     49:             "apiKey": api_key or "",
  6889:     50:             "secret": secret or "",
  6890:     51:             "password": password or "",
  6891:     52:             "enableRateLimit": True,
  6892:     53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
  6893:     54:         })
  6894:     55: 
  6895:     56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
  6896:     57:         self._markets_task: Optional[asyncio.Task[Any]] = None
  6897:     58: 
  6898:     59:     async def _ensure_markets(self) -> None:
  6899:     60:         if self._markets_task is None:
  6900:     61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
  6901:     62:         await self._markets_task
  6902:     63: 
  6903:     64:     # ---------- CSV cache ----------
  6904:     65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
  6905:     66:         safe = symbol.replace("/", "").replace(":", "")
  6906:     67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
  6907:     68: 
  6908:     69:     def _read_cache(self, path: str) -> List[List[float]]:
  6909:     70:         if not os.path.exists(path):
  6910:     71:             return []
  6911:     72:         rows: List[List[float]] = []
  6912:     73:         try:
  6913:     74:             with open(path, "r", newline="") as f:
  6914:     75:                 rd = csv.reader(f)
  6915:     76:                 for r in rd:
  6916:     77:                     if not r:
  6917:     78:                         continue
  6918:     79:                     # ts, o, h, l, c, v
  6919:     80:                     try:
  6920:     81:                         rows.append([
  6921:     82:                             int(r[0]),
  6922:     83:                             float(r[1]),
  6923:     84:                             float(r[2]),
  6924:     85:                             float(r[3]),
  6925:     86:                             float(r[4]),
  6926:     87:                             float(r[5]),
  6927:     88:                         ])
  6928:     89:                     except Exception:
  6929:     90:                         # on ignore les lignes corrompues
  6930:     91:                         continue
  6931:     92:         except Exception:
  6932:     93:             return []
  6933:     94:         return rows
  6934:     95: 
  6935:     96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
  6936:     97:         # On ré‑écrit intégralement (simple et sûr)
  6937:     98:         tmp = path + ".tmp"
  6938:     99:         with open(tmp, "w", newline="") as f:
  6939:    100:             wr = csv.writer(f)
  6940:    101:             wr.writerows(data)
  6941:    102:         os.replace(tmp, path)
  6942:    103: 
  6943:    104:     # ---------- API publique pour orchestrateur ----------
  6944:    105:     async def fetch_ohlcv(
  6945:    106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
  6946:    107:     ) -> List[List[float]]:
  6947:    108:         """
  6948:    109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
  6949:    110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
  6950:    111:         """
  6951:    112:         await self._ensure_markets()
  6952:    113: 
  6953:    114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
  6954:    115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
  6955:    116:         cache_path = self._csv_path(symbol, timeframe)
  6956:    117: 
  6957:    118:         # 1) Cache
  6958:    119:         if self.use_cache:
  6959:    120:             cached = self._read_cache(cache_path)
  6960:    121:             if cached:
  6961:    122:                 # fraicheur = diff entre maintenant et ts dernière bougie
  6962:    123:                 last_ts = int(cached[-1][0])
  6963:    124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
  6964:    125:                     # suffisant => on retourne la fin
  6965:    126:                     if len(cached) >= limit:
  6966:    127:                         return cached[-limit:]
  6967:    128:                     # pas assez, on essaiera de compléter via CCXT plus bas
  6968:    129:                 # sinon: on tentera de rafraîchir plus loin
  6969:    130: 
  6970:    131:         # 2) Remote via CCXT
  6971:    132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
  6972:    133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
  6973:    134:         params: dict[str, Any] = {}
  6974:    135:         if self.spot is True:
  6975:    136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
  6976:    137: 
  6977:    138:         try:
  6978:    139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
  6979:    140:         except Exception as e:  # noqa: BLE001
  6980:    141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
  6981:    142:             cached = self._read_cache(cache_path) if self.use_cache else []
  6982:    143:             if cached:
  6983:    144:                 return cached[-limit:]
  6984:    145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
  6985:    146: 
  6986:    147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
  6987:    148:         if self.use_cache:
  6988:    149:             base = self._read_cache(cache_path)
  6989:    150:             merged = _merge_ohlcv(base, ohlcv)
  6990:    151:             self._write_cache(cache_path, merged)
  6991:    152:             # retourne la fin
  6992:    153:             return merged[-limit:]
  6993:    154: 
  6994:    155:         return ohlcv[-limit:]
  6995:    156: 
  6996:    157:     async def close(self) -> None:
  6997:    158:         try:
  6998:    159:             await self.ex.close()
  6999:    160:         except Exception:
  7000:    161:             pass
  7001:    162: 
  7002:    163: 
  7003:    164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
  7004:    165:     """
  7005:    166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
  7006:    167:     """
  7007:    168:     if not a:
  7008:    169:         return list(b)
  7009:    170:     if not b:
  7010:    171:         return list(a)
  7011:    172: 
  7012:    173:     # index rapide par ts
  7013:    174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
  7014:    175:     for row in b:
  7015:    176:         by_ts[int(row[0])] = row
  7016:    177:     return [by_ts[k] for k in sorted(by_ts)]
  7017: 
  7018: ## scalper/exchange/fees.py (last modified: 2025-08-23 20:57:14)
  7019:      1: # scalper/exchange/fees.py
  7020:      2: from __future__ import annotations
  7021:      3: 
  7022:      4: from typing import Dict, Iterable
  7023:      5: 
  7024:      6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
  7025:      7: DEFAULT_TAKER_BPS = 6    # 0.06%
  7026:      8: DEFAULT_MAKER_BPS = 2    # 0.02%
  7027:      9: 
  7028:     10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
  7029:     11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
  7030:     12: 
  7031:     13: 
  7032:     14: def get_fee(symbol: str, kind: str = "taker") -> float:
  7033:     15:     """
  7034:     16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
  7035:     17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
  7036:     18:     """
  7037:     19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
  7038:     20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
  7039:     21:     return float(bps) / 10_000.0
  7040:     22: 
  7041:     23: 
  7042:     24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
  7043:     25:     """
  7044:     26:     Tente de charger les frais auprès de l'exchange (type ccxt):
  7045:     27:       - fetch_trading_fees(symbols) si dispo
  7046:     28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
  7047:     29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
  7048:     30:     """
  7049:     31:     symbols = list(symbols)
  7050:     32:     fees: Dict[str, Dict[str, float]] = {}
  7051:     33: 
  7052:     34:     try:
  7053:     35:         if hasattr(exchange, "fetch_trading_fees"):
  7054:     36:             data = await exchange.fetch_trading_fees(symbols)
  7055:     37:             for s in symbols:
  7056:     38:                 d = (data or {}).get(s, {}) or {}
  7057:     39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  7058:     40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  7059:     41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  7060:     42:         else:
  7061:     43:             for s in symbols:
  7062:     44:                 try:
  7063:     45:                     d = await exchange.fetch_trading_fee(s)
  7064:     46:                 except Exception:
  7065:     47:                     d = {}
  7066:     48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
  7067:     49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
  7068:     50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
  7069:     51:     except Exception:
  7070:     52:         # fallback: défauts
  7071:     53:         for s in symbols:
  7072:     54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
  7073:     55: 
  7074:     56:     # maj du cache
  7075:     57:     _FEES_BY_SYMBOL.update(fees)
  7076:     58:     return fees
  7077: 
  7078: ## scalper/hooks/prewarm_cache.py (last modified: 2025-08-24 03:12:00)
  7079:      1: # -*- coding: utf-8 -*-
  7080:      2: """
  7081:      3: Pré-chauffe léger du cache OHLCV.
  7082:      4: 
  7083:      5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
  7084:      6: pour chaque symbole, et on s'assure que le dossier data existe.
  7085:      7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
  7086:      8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
  7087:      9: signature.
  7088:     10: """
  7089:     11: from __future__ import annotations
  7090:     12: from pathlib import Path
  7091:     13: from typing import Iterable
  7092:     14: 
  7093:     15: 
  7094:     16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
  7095:     17:     out = Path(out_dir)
  7096:     18:     out.mkdir(parents=True, exist_ok=True)
  7097:     19:     for sym in symbols:
  7098:     20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
  7099:     21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
  7100:     22:         print(f"[cache] warmup OK for {sym}")
  7101: 
  7102: ## scalper/live/__init__.py (last modified: 2025-08-24 03:12:00)
  7103:      1: from .orchestrator import RunConfig, Orchestrator, run_orchestrator  # re‑exports
  7104:      2: from .notify import build_notifier_and_commands  # utile pour bot.py
  7105: 
  7106: ## scalper/live/backtest_telegram.py (last modified: 2025-08-23 20:57:14)
  7107:      1: # scalper/live/backtest_telegram.py
  7108:      2: from __future__ import annotations
  7109:      3: 
  7110:      4: import asyncio
  7111:      5: import os
  7112:      6: from typing import List
  7113:      7: 
  7114:      8: from scalper.backtest import BTCfg, run_multi
  7115:      9: from scalper.services.utils import safe_call
  7116:     10: 
  7117:     11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
  7118:     12: async def _get_exchange():
  7119:     13:     try:
  7120:     14:         import ccxt.async_support as ccxt  # type: ignore
  7121:     15:     except Exception:
  7122:     16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
  7123:     17:     return ccxt.bitget()
  7124:     18: 
  7125:     19: def _parse_symbols(defaults: List[str]) -> List[str]:
  7126:     20:     env = os.getenv("BACKTEST_SYMBOLS", "")
  7127:     21:     if env.strip():
  7128:     22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
  7129:     23:     return defaults
  7130:     24: 
  7131:     25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
  7132:     26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
  7133:     27:     symbols = _parse_symbols(defaults)
  7134:     28:     cash = float(os.getenv("BT_CASH", "10000"))
  7135:     29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
  7136:     30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
  7137:     31:     limit = int(os.getenv("BT_LIMIT", "1500"))
  7138:     32: 
  7139:     33:     await notifier.send(
  7140:     34:         "🧪 Backtest en cours...\n"
  7141:     35:         f"• Symbols: {', '.join(symbols)}\n"
  7142:     36:         f"• TF: {timeframe}\n"
  7143:     37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
  7144:     38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
  7145:     39:     )
  7146:     40: 
  7147:     41:     async def _run():
  7148:     42:         exchange = await _get_exchange()
  7149:     43:         try:
  7150:     44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
  7151:     45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
  7152:     46:             res = await run_multi(cfg, exchange)
  7153:     47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
  7154:     48:         finally:
  7155:     49:             try:
  7156:     50:                 await exchange.close()
  7157:     51:             except Exception:
  7158:     52:                 pass
  7159:     53: 
  7160:     54:     try:
  7161:     55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
  7162:     56:     except Exception as e:
  7163:     57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")
  7164: 
  7165: ## scalper/live/commands.py (last modified: 2025-08-23 20:57:14)
  7166:      1: # scalper/live/commands.py
  7167:      2: from __future__ import annotations
  7168:      3: 
  7169:      4: import asyncio
  7170:      5: from typing import Awaitable, Callable
  7171:      6: 
  7172:      7: 
  7173:      8: class CommandHandler:
  7174:      9:     """
  7175:     10:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
  7176:     11:     Chaque commande est routée vers un callback approprié.
  7177:     12:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
  7178:     13:     """
  7179:     14: 
  7180:     15:     def __init__(self, notifier, command_stream, status_getter, status_sender):
  7181:     16:         self.notifier = notifier
  7182:     17:         self.stream = command_stream
  7183:     18:         self.status_getter = status_getter
  7184:     19:         self.status_sender = status_sender
  7185:     20: 
  7186:     21:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
  7187:     22:         try:
  7188:     23:             await coro
  7189:     24:         except Exception as e:
  7190:     25:             try:
  7191:     26:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
  7192:     27:             except Exception:
  7193:     28:                 pass  # on ne propage jamais
  7194:     29: 
  7195:     30:     async def run(
  7196:     31:         self,
  7197:     32:         on_pause: Callable[[], None],
  7198:     33:         on_resume: Callable[[], None],
  7199:     34:         on_stop: Callable[[], Awaitable[None]] | None,
  7200:     35:         on_setup_apply: Callable[[dict], None],
  7201:     36:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
  7202:     37:     ):
  7203:     38:         """
  7204:     39:         Boucle asynchrone qui lit les lignes du CommandStream
  7205:     40:         et exécute le callback approprié.
  7206:     41:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
  7207:     42:         """
  7208:     43:         async for line in self.stream:
  7209:     44:             txt = (line or "").strip()
  7210:     45:             if not txt:
  7211:     46:                 continue
  7212:     47: 
  7213:     48:             try:
  7214:     49:                 if txt.startswith("/pause"):
  7215:     50:                     on_pause()
  7216:     51:                     await self.notifier.send("⏸️ Pause.")
  7217:     52: 
  7218:     53:                 elif txt.startswith("/resume"):
  7219:     54:                     on_resume()
  7220:     55:                     await self.notifier.send("▶️ Resume.")
  7221:     56: 
  7222:     57:                 elif txt.startswith("/stop"):
  7223:     58:                     if on_stop:
  7224:     59:                         await self._safe_call(on_stop(), "Arrêt échoué")
  7225:     60: 
  7226:     61:                 elif txt.startswith("/status"):
  7227:     62:                     snap = self.status_getter()
  7228:     63:                     await self.notifier.send(f"ℹ️ {snap}")
  7229:     64: 
  7230:     65:                 elif txt.startswith("/setup"):
  7231:     66:                     await self.notifier.send("🧩 Setup wizard à compléter.")
  7232:     67: 
  7233:     68:                 elif txt.startswith("/backtest"):
  7234:     69:                     if on_backtest:
  7235:     70:                         tail = txt[len("/backtest"):].strip()
  7236:     71:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
  7237:     72:                         asyncio.create_task(self._safe_call(
  7238:     73:                             on_backtest(tail), "Backtest échoué"
  7239:     74:                         ))
  7240:     75:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
  7241:     76:                     else:
  7242:     77:                         await self.notifier.send("⚠️ Backtest non disponible.")
  7243:     78: 
  7244:     79:                 else:
  7245:     80:                     await self.notifier.send(
  7246:     81:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
  7247:     82:                     )
  7248:     83: 
  7249:     84:             except Exception as e:
  7250:     85:                 # On protège la boucle quoi qu'il arrive
  7251:     86:                 try:
  7252:     87:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
  7253:     88:                 except Exception:
  7254:     89:                     pass
  7255: 
  7256: ## scalper/live/journal.py (last modified: 2025-08-23 20:57:14)
  7257:      1: from __future__ import annotations
  7258:      2: import os, csv
  7259:      3: from typing import Any, Dict, List
  7260:      4: 
  7261:      5: class LogWriter:
  7262:      6:     """Gestion simple des CSV (création à la volée + append)."""
  7263:      7:     def __init__(self, dirpath: str) -> None:
  7264:      8:         self.dir = dirpath
  7265:      9:         os.makedirs(self.dir, exist_ok=True)
  7266:     10: 
  7267:     11:     def init(self, fname: str, headers: List[str]) -> None:
  7268:     12:         p = os.path.join(self.dir, fname)
  7269:     13:         if not os.path.exists(p):
  7270:     14:             with open(p, "w", newline="", encoding="utf-8") as f:
  7271:     15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
  7272:     16: 
  7273:     17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
  7274:     18:         p = os.path.join(self.dir, fname)
  7275:     19:         with open(p, "a", newline="", encoding="utf-8") as f:
  7276:     20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)
  7277: 
  7278: ## scalper/live/logs.py (last modified: 2025-08-23 20:57:14)
  7279:      1: # scalp/live/logs.py
  7280:      2: from __future__ import annotations
  7281:      3: import os, csv
  7282:      4: from typing import Any, List, Dict
  7283:      5: 
  7284:      6: class CsvLog:
  7285:      7:     def __init__(self, path: str, headers: List[str]):
  7286:      8:         self.path = path
  7287:      9:         self.headers = headers
  7288:     10:         self._ensure_header()
  7289:     11: 
  7290:     12:     def _ensure_header(self):
  7291:     13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
  7292:     14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
  7293:     15:         if must_write:
  7294:     16:             with open(self.path, "w", newline="") as f:
  7295:     17:                 csv.writer(f).writerow(self.headers)
  7296:     18: 
  7297:     19:     def write_row(self, row: Dict[str, Any]):
  7298:     20:         with open(self.path, "a", newline="") as f:
  7299:     21:             w = csv.DictWriter(f, fieldnames=self.headers)
  7300:     22:             w.writerow({k: row.get(k, "") for k in self.headers})
  7301: 
  7302: ## scalper/live/loops/trade.py (last modified: 2025-08-23 20:57:14)
  7303:      1: # scalp/live/loops/trade.py
  7304:      2: from __future__ import annotations
  7305:      3: import asyncio, os
  7306:      4: from dataclasses import dataclass, field
  7307:      5: from typing import Any, Dict, List, Callable
  7308:      6: 
  7309:      7: from ...services.utils import safe_call
  7310:      8: from ...risk.manager import compute_size
  7311:      9: 
  7312:     10: QUIET = int(os.getenv("QUIET", "0") or "0")
  7313:     11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
  7314:     12: 
  7315:     13: class PositionFSM:
  7316:     14:     def __init__(self):
  7317:     15:         self.state = "FLAT"
  7318:     16:         self.side = "flat"
  7319:     17:         self.entry = 0.0
  7320:     18:         self.qty = 0.0
  7321:     19:     def can_open(self): return self.state == "FLAT"
  7322:     20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
  7323:     21:     def can_close(self): return self.state == "OPEN"
  7324:     22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
  7325:     23: 
  7326:     24: @dataclass
  7327:     25: class SymbolContext:
  7328:     26:     symbol: str
  7329:     27:     timeframe: str
  7330:     28:     ohlcv: List[List[float]] = field(default_factory=list)
  7331:     29:     ticks: int = 0
  7332:     30:     fsm: PositionFSM = field(default_factory=PositionFSM)
  7333:     31: 
  7334:     32: class TradeLoop:
  7335:     33:     """
  7336:     34:     Boucle par symbole, indépendante de l'orchestrateur.
  7337:     35:     """
  7338:     36:     def __init__(
  7339:     37:         self,
  7340:     38:         symbol: str,
  7341:     39:         timeframe: str,
  7342:     40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
  7343:     41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
  7344:     42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
  7345:     43:         config: Dict[str, Any],
  7346:     44:         mode_getter: Callable[[], str],
  7347:     45:         log_signals, log_orders, log_fills,
  7348:     46:         tick_counter_add: Callable[[int], None],
  7349:     47:     ):
  7350:     48:         self.symbol = symbol
  7351:     49:         self.timeframe = timeframe
  7352:     50:         self.fetch = ohlcv_fetch
  7353:     51:         self.order_market = order_market
  7354:     52:         self.generate_signal = generate_signal
  7355:     53:         self.config = config
  7356:     54:         self.get_mode = mode_getter
  7357:     55:         self.log_signals = log_signals
  7358:     56:         self.log_orders = log_orders
  7359:     57:         self.log_fills = log_fills
  7360:     58:         self.ctx = SymbolContext(symbol, timeframe)
  7361:     59:         self._tick_add = tick_counter_add
  7362:     60: 
  7363:     61:         # Risk/frais
  7364:     62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
  7365:     63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
  7366:     64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
  7367:     65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
  7368:     66: 
  7369:     67:     def _bps_for(self, order_type: str = "market") -> float:
  7370:     68:         # market -> taker; limit post-only -> maker
  7371:     69:         per = self.fees_map.get(self.symbol, {})
  7372:     70:         if order_type == "limit":
  7373:     71:             return float(per.get("maker_bps", 0.0))
  7374:     72:         return float(per.get("taker_bps", 0.0))
  7375:     73: 
  7376:     74:     async def run(self, running: Callable[[], bool]):
  7377:     75:         lookback = 200
  7378:     76:         while running():
  7379:     77:             if self.get_mode() != "RUNNING":
  7380:     78:                 await asyncio.sleep(0.5); continue
  7381:     79: 
  7382:     80:             async def _fetch():
  7383:     81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
  7384:     82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
  7385:     83:             if not ohlcv or len(ohlcv) < lookback+1:
  7386:     84:                 await asyncio.sleep(1.0); continue
  7387:     85: 
  7388:     86:             self.ctx.ohlcv = ohlcv
  7389:     87:             self.ctx.ticks += 1
  7390:     88:             self._tick_add(1)
  7391:     89: 
  7392:     90:             window = ohlcv[-(lookback+1):]
  7393:     91:             ts, _o, _h, _l, c, _v = window[-1]
  7394:     92: 
  7395:     93:             try:
  7396:     94:                 sig = self.generate_signal(window, self.config) or {}
  7397:     95:             except Exception as e:
  7398:     96:                 if not QUIET:
  7399:     97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
  7400:     98:                 await asyncio.sleep(0.5); continue
  7401:     99: 
  7402:    100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
  7403:    101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
  7404:    102: 
  7405:    103:             # --- Entrée (market -> taker)
  7406:    104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
  7407:    105:                 balance = float(self.config.get("cash", 10_000.0))
  7408:    106:                 qty = compute_size(
  7409:    107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
  7410:    108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  7411:    109:                 )
  7412:    110:                 if qty > 0:
  7413:    111:                     async def _place():
  7414:    112:                         return await self.order_market(self.symbol, side, qty)
  7415:    113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
  7416:    114:                     self.ctx.fsm.on_open(side, entry or c, qty)
  7417:    115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
  7418:    116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
  7419:    117: 
  7420:    118:             # --- Sortie (market -> taker)
  7421:    119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
  7422:    120:                 qty = self.ctx.fsm.qty
  7423:    121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
  7424:    122:                 async def _close():
  7425:    123:                     return await self.order_market(self.symbol, exit_side, qty)
  7426:    124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
  7427:    125: 
  7428:    126:                 # fill avec slippage + frais (taker)
  7429:    127:                 price_fill = float(c)
  7430:    128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
  7431:    129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
  7432:    130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
  7433:    131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
  7434:    132:                                           "order_id": (order or {}).get("id","")})
  7435:    133:                 self.ctx.fsm.on_close()
  7436:    134: 
  7437:    135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
  7438:    136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
  7439:    137: 
  7440:    138:             await asyncio.sleep(0.1 if QUIET else 0.01)
  7441: 
  7442: ## scalper/live/notify.py (last modified: 2025-08-24 03:12:00)
  7443:      1: # -*- coding: utf-8 -*-
  7444:      2: from __future__ import annotations
  7445:      3: import os
  7446:      4: import asyncio
  7447:      5: from dataclasses import dataclass
  7448:      6: from typing import AsyncIterator, Optional
  7449:      7: 
  7450:      8: 
  7451:      9: @dataclass
  7452:     10: class BaseNotifier:
  7453:     11:     async def send(self, text: str) -> None:  # pragma: no cover
  7454:     12:         print(text)
  7455:     13: 
  7456:     14: 
  7457:     15: class NullNotifier(BaseNotifier):
  7458:     16:     pass
  7459:     17: 
  7460:     18: 
  7461:     19: class TelegramNotifier(BaseNotifier):
  7462:     20:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
  7463:     21:         import aiohttp  # lazy
  7464:     22:         self._token = token
  7465:     23:         self._chat = chat_id
  7466:     24:         self._session: aiohttp.ClientSession | None = None
  7467:     25: 
  7468:     26:     async def _ensure(self):
  7469:     27:         import aiohttp
  7470:     28:         if self._session is None or self._session.closed:
  7471:     29:             self._session = aiohttp.ClientSession()
  7472:     30: 
  7473:     31:     async def send(self, text: str) -> None:
  7474:     32:         import aiohttp
  7475:     33:         await self._ensure()
  7476:     34:         # pas de markdown pour éviter les erreurs 400 de parsing
  7477:     35:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
  7478:     36:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
  7479:     37:         try:
  7480:     38:             async with self._session.post(url, json=payload, timeout=20) as r:
  7481:     39:                 await r.text()  # on ignore la réponse pour rester simple
  7482:     40:         except Exception:
  7483:     41:             # on fait un fallback silencieux pour ne pas casser le bot
  7484:     42:             print("[notify:telegram] send fail (ignored)")
  7485:     43: 
  7486:     44:     async def close(self):
  7487:     45:         if self._session and not self._session.closed:
  7488:     46:             await self._session.close()
  7489:     47: 
  7490:     48: 
  7491:     49: class _NullCommands:
  7492:     50:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
  7493:     51:     def __aiter__(self) -> AsyncIterator[str]:
  7494:     52:         return self
  7495:     53:     async def __anext__(self) -> str:
  7496:     54:         await asyncio.sleep(3600)  # jamais
  7497:     55:         raise StopAsyncIteration
  7498:     56: 
  7499:     57: 
  7500:     58: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
  7501:     59:     """
  7502:     60:     Retourne (notifier, command_stream).
  7503:     61: 
  7504:     62:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
  7505:     63:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
  7506:     64:       commandes interactives plus tard.
  7507:     65:     - Sinon: NullNotifier + flux vide.
  7508:     66:     """
  7509:     67:     token = os.getenv("TELEGRAM_BOT_TOKEN")
  7510:     68:     chat = os.getenv("TELEGRAM_CHAT_ID")
  7511:     69:     if token and chat:
  7512:     70:         print("[notify] TELEGRAM configured.")
  7513:     71:         return TelegramNotifier(token, chat), _NullCommands()
  7514:     72:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
  7515:     73:     return NullNotifier(), _NullCommands()
  7516: 
  7517: ## scalper/live/ohlcv_service.py (last modified: 2025-08-23 20:57:14)
  7518:      1: from __future__ import annotations
  7519:      2: import time
  7520:      3: from typing import Any, Dict, List, Optional
  7521:      4: 
  7522:      5: try:
  7523:      6:     from scalper.adapters.market_data import MarketData
  7524:      7: except Exception:
  7525:      8:     MarketData = None  # type: ignore
  7526:      9: 
  7527:     10: class OhlcvService:
  7528:     11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
  7529:     12:     def __init__(self, exchange) -> None:
  7530:     13:         self.exchange = exchange
  7531:     14:         self.md = MarketData(exchange) if MarketData is not None else None
  7532:     15: 
  7533:     16:     @staticmethod
  7534:     17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
  7535:     18:         out: List[Dict[str, float]] = []
  7536:     19:         if not rows: return out
  7537:     20:         for r in rows:
  7538:     21:             if isinstance(r, dict):
  7539:     22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
  7540:     23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
  7541:     24:                 v = float(r.get("volume", r.get("vol", 0.0)))
  7542:     25:             else:
  7543:     26:                 rr = list(r)
  7544:     27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
  7545:     28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
  7546:     29:                 else:
  7547:     30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
  7548:     31:                     h = float(rr[1]) if len(rr) > 1 else o
  7549:     32:                     l = float(rr[2]) if len(rr) > 2 else o
  7550:     33:                     c = float(rr[3]) if len(rr) > 3 else o
  7551:     34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
  7552:     35:                     ts = int(rr[5]) if len(rr) > 5 else 0
  7553:     36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
  7554:     37:         return out
  7555:     38: 
  7556:     39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
  7557:     40:         # 1) MarketData (si dispo)
  7558:     41:         if self.md is not None:
  7559:     42:             try:
  7560:     43:                 d = self.md.get_ohlcv(symbol, interval, limit)
  7561:     44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
  7562:     45:                     return self.normalize_rows(d["data"])
  7563:     46:             except Exception:
  7564:     47:                 pass
  7565:     48: 
  7566:     49:         # 2) Exchange natif
  7567:     50:         rows: List[Any] = []
  7568:     51:         try:
  7569:     52:             data = self.exchange.get_kline(symbol, interval=interval)
  7570:     53:         except Exception:
  7571:     54:             data = None
  7572:     55: 
  7573:     56:         if isinstance(data, dict):
  7574:     57:             rows = (
  7575:     58:                 data.get("data") or data.get("result") or data.get("records") or
  7576:     59:                 data.get("list") or data.get("items") or data.get("candles") or []
  7577:     60:             )
  7578:     61:             guard = 0
  7579:     62:             while isinstance(rows, dict) and guard < 3:
  7580:     63:                 rows = (
  7581:     64:                     rows.get("data") or rows.get("result") or rows.get("records") or
  7582:     65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
  7583:     66:                 )
  7584:     67:                 guard += 1
  7585:     68:         elif isinstance(data, (list, tuple)):
  7586:     69:             rows = list(data)
  7587:     70: 
  7588:     71:         out = self.normalize_rows(rows)[-limit:]
  7589:     72:         if out: return out
  7590:     73: 
  7591:     74:         # 3) Fallback strict via ticker -> bougie synthétique
  7592:     75:         try:
  7593:     76:             tkr = self.exchange.get_ticker(symbol)
  7594:     77:             items = []
  7595:     78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
  7596:     79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
  7597:     80:             if items:
  7598:     81:                 last = items[0]
  7599:     82:                 if isinstance(last, dict):
  7600:     83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
  7601:     84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
  7602:     85:                 else:
  7603:     86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
  7604:     87:                 ts = int(time.time()*1000)
  7605:     88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
  7606:     89:         except Exception:
  7607:     90:             pass
  7608:     91:         return []
  7609: 
  7610: ## scalper/live/orchestrator.py (last modified: 2025-08-24 03:12:00)
  7611:      1: # -*- coding: utf-8 -*-
  7612:      2: from __future__ import annotations
  7613:      3: import asyncio
  7614:      4: from dataclasses import dataclass, field
  7615:      5: from typing import Callable, Iterable, List, Optional, AsyncIterator
  7616:      6: 
  7617:      7: from scalper.hooks.prewarm_cache import prewarm_cache
  7618:      8: 
  7619:      9: 
  7620:     10: @dataclass
  7621:     11: class RunConfig:
  7622:     12:     symbols: List[str] = field(default_factory=lambda: [
  7623:     13:         "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  7624:     14:         "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  7625:     15:     ])
  7626:     16:     timeframe: str = "5m"
  7627:     17:     refresh_secs: float = 30.0
  7628:     18:     cache_dir: str = "/notebooks/data"
  7629:     19:     # Tu peux ajouter d'autres paramètres ici (risques, stratégie, etc.)
  7630:     20: 
  7631:     21: 
  7632:     22: class Orchestrator:
  7633:     23:     def __init__(self, cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None):
  7634:     24:         self.cfg = cfg
  7635:     25:         self.notifier = notifier
  7636:     26:         self._cache_dir_factory = cache_dir_factory
  7637:     27:         self._bg_tasks: list[asyncio.Task] = []
  7638:     28:         self._ticks_total: int = 0
  7639:     29:         self._running: bool = False
  7640:     30: 
  7641:     31:     # --- getters exposés aux tâches de log/heartbeat
  7642:     32:     def ticks_total(self) -> int:
  7643:     33:         return self._ticks_total
  7644:     34: 
  7645:     35:     def symbols(self) -> List[str]:
  7646:     36:         return list(self.cfg.symbols)
  7647:     37: 
  7648:     38:     async def _heartbeat_task(self) -> None:
  7649:     39:         while self._running:
  7650:     40:             try:
  7651:     41:                 await self.notifier.send("heartbeat alive")
  7652:     42:             finally:
  7653:     43:                 await asyncio.sleep(30)
  7654:     44: 
  7655:     45:     async def _log_stats_task(self) -> None:
  7656:     46:         # log toutes les 30s
  7657:     47:         while self._running:
  7658:     48:             try:
  7659:     49:                 msg = f"[stats] ticks_total={self._ticks_total} (+0 /30s) | pairs={','.join(self.cfg.symbols) if self.cfg.symbols else ''}"
  7660:     50:                 await self.notifier.send(msg)
  7661:     51:             finally:
  7662:     52:                 await asyncio.sleep(30)
  7663:     53: 
  7664:     54:     async def _main_loop(self) -> None:
  7665:     55:         """Boucle principale ultra‑simple qui incrémente un compteur."""
  7666:     56:         refresh = max(2.0, float(self.cfg.refresh_secs))
  7667:     57:         while self._running:
  7668:     58:             # Ici tu brancheras fetch_ohlcv / signaux / stratégies
  7669:     59:             self._ticks_total += len(self.cfg.symbols)
  7670:     60:             await asyncio.sleep(refresh)
  7671:     61: 
  7672:     62:     async def start(self) -> None:
  7673:     63:         # Pré‑chauffe cache (non bloquant et robuste)
  7674:     64:         prewarm_cache(
  7675:     65:             cfg={},  # placeholder
  7676:     66:             symbols=self.cfg.symbols,
  7677:     67:             timeframe=self.cfg.timeframe,
  7678:     68:             out_dir=(self._cache_dir_factory() if self._cache_dir_factory else self.cfg.cache_dir),
  7679:     69:         )
  7680:     70:         await self.notifier.send("🟢 Orchestrator PRELAUNCH. Utilise /setup ou /backtest. /resume pour démarrer le live.")
  7681:     71: 
  7682:     72:         self._running = True
  7683:     73:         self._bg_tasks.append(asyncio.create_task(self._heartbeat_task()))
  7684:     74:         self._bg_tasks.append(asyncio.create_task(self._log_stats_task()))
  7685:     75:         try:
  7686:     76:             await self._main_loop()
  7687:     77:         finally:
  7688:     78:             # arrêt propre
  7689:     79:             self._running = False
  7690:     80:             for t in self._bg_tasks:
  7691:     81:                 t.cancel()
  7692:     82:             self._bg_tasks.clear()
  7693:     83: 
  7694:     84:     async def run(self) -> None:
  7695:     85:         await self.start()
  7696:     86: 
  7697:     87: 
  7698:     88: async def run_orchestrator(cfg: RunConfig, notifier, cache_dir_factory: Optional[Callable[[], str]] = None) -> None:
  7699:     89:     """Entrée unique utilisée par bot.py"""
  7700:     90:     orch = Orchestrator(cfg, notifier, cache_dir_factory)
  7701:     91:     await orch.run()
  7702: 
  7703: ## scalper/live/orders.py (last modified: 2025-08-23 20:57:14)
  7704:      1: # live/orders.py
  7705:      2: from __future__ import annotations
  7706:      3: from dataclasses import dataclass
  7707:      4: from typing import Any, Optional
  7708:      5: 
  7709:      6: from scalper.services.order_service import OrderService, OrderRequest
  7710:      7: 
  7711:      8: @dataclass
  7712:      9: class OrderResult:
  7713:     10:     accepted: bool
  7714:     11:     order_id: str | None = None
  7715:     12:     status: str | None = None
  7716:     13:     reason: str | None = None
  7717:     14: 
  7718:     15: class OrderExecutor:
  7719:     16:     """
  7720:     17:     Fine couche autour d'OrderService + exchange :
  7721:     18:       - calcule l'équité USDT
  7722:     19:       - place une entrée (risk_pct)
  7723:     20:       - récupère les fills (normalisés)
  7724:     21:     L'orchestrateur n’appelle plus OrderService directement.
  7725:     22:     """
  7726:     23: 
  7727:     24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
  7728:     25:         self.order_service = order_service
  7729:     26:         self.exchange = exchange
  7730:     27:         self.config = config
  7731:     28: 
  7732:     29:     # ---------- Equity ----------
  7733:     30:     def get_equity_usdt(self) -> float:
  7734:     31:         equity = 0.0
  7735:     32:         try:
  7736:     33:             assets = self.exchange.get_assets()
  7737:     34:             if isinstance(assets, dict):
  7738:     35:                 for a in (assets.get("data") or []):
  7739:     36:                     if str(a.get("currency")).upper() == "USDT":
  7740:     37:                         equity = float(a.get("equity", 0.0))
  7741:     38:                         break
  7742:     39:         except Exception:
  7743:     40:             pass
  7744:     41:         return equity
  7745:     42: 
  7746:     43:     # ---------- Entrée ----------
  7747:     44:     def place_entry(self, *, symbol: str, side: str, price: float,
  7748:     45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
  7749:     46:         """
  7750:     47:         side: 'long' | 'short'
  7751:     48:         Retourne OrderResult(accepted, order_id, status, reason)
  7752:     49:         """
  7753:     50:         equity = self.get_equity_usdt()
  7754:     51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
  7755:     52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
  7756:     53:                            risk_pct=float(risk_pct))
  7757:     54:         try:
  7758:     55:             res = self.order_service.prepare_and_place(equity, req)
  7759:     56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
  7760:     57:                                order_id=getattr(res, "order_id", None),
  7761:     58:                                status=getattr(res, "status", None),
  7762:     59:                                reason=getattr(res, "reason", None))
  7763:     60:         except Exception as e:
  7764:     61:             return OrderResult(accepted=False, reason=str(e))
  7765:     62: 
  7766:     63:     # ---------- Fills ----------
  7767:     64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
  7768:     65:         """
  7769:     66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
  7770:     67:         """
  7771:     68:         try:
  7772:     69:             raw = self.exchange.get_fills(symbol, order_id, limit)
  7773:     70:         except Exception:
  7774:     71:             return []
  7775:     72: 
  7776:     73:         items: list = []
  7777:     74:         if isinstance(raw, dict):
  7778:     75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
  7779:     76:         elif isinstance(raw, (list, tuple)):
  7780:     77:             items = list(raw)
  7781:     78: 
  7782:     79:         out: list[dict] = []
  7783:     80:         for f in items:
  7784:     81:             if isinstance(f, dict):
  7785:     82:                 out.append({
  7786:     83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
  7787:     84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
  7788:     85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
  7789:     86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
  7790:     87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
  7791:     88:                 })
  7792:     89:             else:
  7793:     90:                 try:
  7794:     91:                     seq = list(f)
  7795:     92:                     out.append({
  7796:     93:                         "orderId": str(seq[0]) if seq else "",
  7797:     94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
  7798:     95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
  7799:     96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
  7800:     97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
  7801:     98:                     })
  7802:     99:                 except Exception:
  7803:    100:                     continue
  7804:    101:         return out
  7805: 
  7806: ## scalper/live/position_fsm.py (last modified: 2025-08-23 20:57:14)
  7807:      1: # live/position_fsm.py
  7808:      2: from __future__ import annotations
  7809:      3: from dataclasses import dataclass
  7810:      4: from typing import Optional, Dict, Any, List
  7811:      5: 
  7812:      6: 
  7813:      7: STATE_FLAT = "FLAT"
  7814:      8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
  7815:      9: STATE_OPEN = "OPEN"
  7816:     10: STATE_PENDING_EXIT = "PENDING_EXIT"
  7817:     11: 
  7818:     12: 
  7819:     13: @dataclass
  7820:     14: class PositionState:
  7821:     15:     symbol: str
  7822:     16:     state: str = STATE_FLAT
  7823:     17:     order_id: Optional[str] = None
  7824:     18:     side: Optional[str] = None   # "long" | "short"
  7825:     19:     qty: float = 0.0
  7826:     20:     entry: float = 0.0
  7827:     21: 
  7828:     22: 
  7829:     23: class PositionFSM:
  7830:     24:     """
  7831:     25:     FSM ultra-simple par symbole.
  7832:     26:     - set_pending_entry(order_id, side)
  7833:     27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
  7834:     28:     """
  7835:     29: 
  7836:     30:     def __init__(self, symbols: List[str]) -> None:
  7837:     31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
  7838:     32: 
  7839:     33:     # -------- API utilisateur --------
  7840:     34:     def ensure_symbol(self, symbol: str) -> None:
  7841:     35:         if symbol not in self._by_symbol:
  7842:     36:             self._by_symbol[symbol] = PositionState(symbol)
  7843:     37: 
  7844:     38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
  7845:     39:         self.ensure_symbol(symbol)
  7846:     40:         st = self._by_symbol[symbol]
  7847:     41:         st.state = STATE_PENDING_ENTRY
  7848:     42:         st.order_id = order_id
  7849:     43:         st.side = side
  7850:     44: 
  7851:     45:     def mark_pending_exit(self, symbol: str) -> None:
  7852:     46:         self.ensure_symbol(symbol)
  7853:     47:         st = self._by_symbol[symbol]
  7854:     48:         st.state = STATE_PENDING_EXIT
  7855:     49: 
  7856:     50:     def force_flat(self, symbol: str) -> None:
  7857:     51:         self._by_symbol[symbol] = PositionState(symbol)
  7858:     52: 
  7859:     53:     # -------- Lecture --------
  7860:     54:     def get(self, symbol: str) -> PositionState:
  7861:     55:         self.ensure_symbol(symbol)
  7862:     56:         return self._by_symbol[symbol]
  7863:     57: 
  7864:     58:     def all(self) -> Dict[str, PositionState]:
  7865:     59:         return self._by_symbol
  7866:     60: 
  7867:     61:     # -------- Réconciliation --------
  7868:     62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
  7869:     63:         """
  7870:     64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
  7871:     65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
  7872:     66:         """
  7873:     67:         # indexer positions ouvertes
  7874:     68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
  7875:     69: 
  7876:     70:         for sym, st in self._by_symbol.items():
  7877:     71:             p = idx_open.get(sym)
  7878:     72: 
  7879:     73:             if st.state == STATE_PENDING_ENTRY:
  7880:     74:                 # si on voit des fills de l'ordre en attente -> OPEN
  7881:     75:                 f_list = fills.get(sym) or []
  7882:     76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
  7883:     77:                 if qty_filled > 0.0 or p:
  7884:     78:                     st.state = STATE_OPEN
  7885:     79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
  7886:     80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
  7887:     81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
  7888:     82:             elif st.state == STATE_OPEN:
  7889:     83:                 # si plus de position ouverte -> FLAT
  7890:     84:                 if not p:
  7891:     85:                     st.state = STATE_FLAT
  7892:     86:                     st.order_id = None
  7893:     87:                     st.side = None
  7894:     88:                     st.qty = 0.0
  7895:     89:                     st.entry = 0.0
  7896:     90:                 else:
  7897:     91:                     st.qty = float(p.get("qty", st.qty))
  7898:     92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
  7899:     93:             elif st.state == STATE_PENDING_EXIT:
  7900:     94:                 # si plus de position -> FLAT ; sinon reste OPEN
  7901:     95:                 if not p:
  7902:     96:                     st.state = STATE_FLAT
  7903:     97:                     st.order_id = None
  7904:     98:                     st.side = None
  7905:     99:                     st.qty = 0.0
  7906:    100:                     st.entry = 0.0
  7907:    101:                 else:
  7908:    102:                     st.state = STATE_OPEN  # pas encore clos
  7909:    103:             else:
  7910:    104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
  7911:    105:                 if p:
  7912:    106:                     st.state = STATE_OPEN
  7913:    107:                     st.qty = float(p.get("qty", 0.0))
  7914:    108:                     st.entry = float(p.get("avgEntryPrice", 0.0))
  7915: 
  7916: ## scalper/live/setup_wizard.py (last modified: 2025-08-23 20:57:14)
  7917:      1: from __future__ import annotations
  7918:      2: import asyncio, os
  7919:      3: from dataclasses import dataclass
  7920:      4: from typing import List, Dict, Optional, Callable
  7921:      5: from ..signals.factory import load_signal
  7922:      6: from ..backtest.runner import BacktestRunner
  7923:      7: from .notify import Notifier, CommandStream
  7924:      8: 
  7925:      9: @dataclass
  7926:     10: class SetupResult:
  7927:     11:     strategy: str
  7928:     12:     symbols: List[str]
  7929:     13:     timeframes: List[str]
  7930:     14:     risk_pct: float
  7931:     15:     accepted: bool
  7932:     16:     summary_path: str
  7933:     17: 
  7934:     18: class SetupWizard:
  7935:     19:     """
  7936:     20:     Wizard interactif Telegram avant lancement des trades.
  7937:     21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
  7938:     22:     """
  7939:     23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
  7940:     24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
  7941:     25:                  admin_chat_id: Optional[int]=None):
  7942:     26:         self.notifier = notifier
  7943:     27:         self.cmd_stream = cmd_stream
  7944:     28:         self.loader = ohlcv_loader_sync
  7945:     29:         self.out_dir = out_dir
  7946:     30:         self.admin_chat_id = admin_chat_id
  7947:     31: 
  7948:     32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
  7949:     33:         await self.notifier.send_menu(prompt, choices)
  7950:     34:         async for msg in self.cmd_stream:
  7951:     35:             txt = msg.strip()
  7952:     36:             if allow_multi and ("," in txt or " " in txt):
  7953:     37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
  7954:     38:                 return sel
  7955:     39:             if txt.isdigit():
  7956:     40:                 i = int(txt)-1
  7957:     41:                 if 0 <= i < len(choices):
  7958:     42:                     return [choices[i]]
  7959:     43:             if txt in choices:
  7960:     44:                 return [txt]
  7961:     45:             await self.notifier.send("Entrée invalide. Réessaie.")
  7962:     46: 
  7963:     47:     async def _ask_value(self, prompt: str, cast: Callable, default):
  7964:     48:         await self.notifier.send(f"{prompt} (défaut: {default})")
  7965:     49:         async for msg in self.cmd_stream:
  7966:     50:             txt = msg.strip()
  7967:     51:             if txt == "" or txt.lower() in ("d","defaut","default"):
  7968:     52:                 return default
  7969:     53:             try:
  7970:     54:                 return cast(txt)
  7971:     55:             except Exception:
  7972:     56:                 await self.notifier.send("Entrée invalide. Réessaie.")
  7973:     57: 
  7974:     58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
  7975:     59:                   default_strategy: str="current") -> SetupResult:
  7976:     60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
  7977:     61:         # 1) stratégie
  7978:     62:         strategies = ["current","ema_cross","vwap_break"]
  7979:     63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
  7980:     64: 
  7981:     65:         # 2) symboles
  7982:     66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
  7983:     67: 
  7984:     68:         # 3) timeframes
  7985:     69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
  7986:     70: 
  7987:     71:         # 4) risk %
  7988:     72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
  7989:     73: 
  7990:     74:         # 5) période backtest
  7991:     75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
  7992:     76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
  7993:     77: 
  7994:     78:         # 6) run backtest
  7995:     79:         from ..backtest.cli import parse_ts
  7996:     80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
  7997:     81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
  7998:     82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
  7999:     83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
  8000:     84: 
  8001:     85:         # 7) résumé
  8002:     86:         sum_path = os.path.join(self.out_dir, "metrics.json")
  8003:     87:         prop = res["proposal"]
  8004:     88:         lines = ["**Proposition** :"]
  8005:     89:         for sym, best in prop["per_symbol_best"].items():
  8006:     90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
  8007:     91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
  8008:     92: 
  8009:     93:         # 8) décision
  8010:     94:         async for msg in self.cmd_stream:
  8011:     95:             t = msg.strip().lower()
  8012:     96:             if t in ("accepter","accept","ok","go","start"):
  8013:     97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
  8014:     98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
  8015:     99:             if t in ("modifier","again","repeat"):
  8016:    100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
  8017:    101:             if t in ("annuler","cancel","stop"):
  8018:    102:                 await self.notifier.send("❌ Annulé.")
  8019:    103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)
  8020: 
  8021: ## scalper/live/state_store.py (last modified: 2025-08-23 20:57:14)
  8022:      1: # live/state_store.py
  8023:      2: from __future__ import annotations
  8024:      3: import json, os, time, asyncio
  8025:      4: from typing import Callable, Dict, Any
  8026:      5: 
  8027:      6: class StateStore:
  8028:      7:     """
  8029:      8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
  8030:      9:     - save_state(snapshot: dict) -> écrit sur disque
  8031:     10:     - load_state() -> dict
  8032:     11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
  8033:     12:     """
  8034:     13: 
  8035:     14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
  8036:     15:         self.filepath = filepath
  8037:     16:         self.period_s = period_s
  8038:     17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
  8039:     18:         self._running = False
  8040:     19: 
  8041:     20:     # -------- I/O --------
  8042:     21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
  8043:     22:         tmp = self.filepath + ".tmp"
  8044:     23:         with open(tmp, "w", encoding="utf-8") as f:
  8045:     24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
  8046:     25:         os.replace(tmp, self.filepath)
  8047:     26: 
  8048:     27:     def load_state(self) -> Dict[str, Any]:
  8049:     28:         if not os.path.exists(self.filepath):
  8050:     29:             return {}
  8051:     30:         try:
  8052:     31:             with open(self.filepath, "r", encoding="utf-8") as f:
  8053:     32:                 return json.load(f)
  8054:     33:         except Exception:
  8055:     34:             return {}
  8056:     35: 
  8057:     36:     # -------- Autosave --------
  8058:     37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
  8059:     38:         self._running = True
  8060:     39:         while self._running:
  8061:     40:             try:
  8062:     41:                 snap = get_snapshot()
  8063:     42:                 snap["saved_at"] = int(time.time() * 1000)
  8064:     43:                 self.save_state(snap)
  8065:     44:             except Exception:
  8066:     45:                 pass
  8067:     46:             await asyncio.sleep(self.period_s)
  8068:     47: 
  8069:     48:     def stop(self): self._running = False
  8070: 
  8071: ## scalper/live/telegram_async.py (last modified: 2025-08-23 20:57:14)
  8072:      1: from __future__ import annotations
  8073:      2: import time
  8074:      3: import requests
  8075:      4: import asyncio
  8076:      5: from typing import Optional, Dict, Any, List
  8077:      6: 
  8078:      7: 
  8079:      8: class TelegramAsync:
  8080:      9:     """
  8081:     10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
  8082:     11:     Sans nouvelle dépendance.
  8083:     12:     """
  8084:     13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
  8085:     14:         self.token = token
  8086:     15:         self.chat_id = chat_id
  8087:     16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
  8088:     17:         self._offset = 0
  8089:     18:         self._enabled = bool(token and chat_id)
  8090:     19: 
  8091:     20:     def enabled(self) -> bool:
  8092:     21:         return self._enabled
  8093:     22: 
  8094:     23:     # ---------- sync I/O (appelées via to_thread) ----------
  8095:     24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
  8096:     25:         if not self._enabled:
  8097:     26:             return {"ok": False, "reason": "disabled"}
  8098:     27:         url = f"{self.base}/sendMessage"
  8099:     28:         payload = {"chat_id": self.chat_id, "text": text}
  8100:     29:         try:
  8101:     30:             r = requests.post(url, json=payload, timeout=10)
  8102:     31:             return r.json()
  8103:     32:         except Exception as e:
  8104:     33:             return {"ok": False, "error": repr(e)}
  8105:     34: 
  8106:     35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
  8107:     36:         if not self._enabled:
  8108:     37:             return {"ok": True, "result": []}
  8109:     38:         url = f"{self.base}/getUpdates"
  8110:     39:         params = {"timeout": timeout_s, "offset": self._offset}
  8111:     40:         try:
  8112:     41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
  8113:     42:             return r.json()
  8114:     43:         except Exception as e:
  8115:     44:             return {"ok": False, "error": repr(e), "result": []}
  8116:     45: 
  8117:     46:     # ---------- async wrappers ----------
  8118:     47:     async def send_message(self, text: str) -> None:
  8119:     48:         await asyncio.to_thread(self._send_message_sync, text)
  8120:     49: 
  8121:     50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
  8122:     51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
  8123:     52:         if not data.get("ok"):
  8124:     53:             return []
  8125:     54:         out = []
  8126:     55:         for upd in data.get("result", []):
  8127:     56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
  8128:     57:             msg = upd.get("message") or {}
  8129:     58:             text = (msg.get("text") or "").strip()
  8130:     59:             if not text:
  8131:     60:                 continue
  8132:     61:             out.append({
  8133:     62:                 "date": msg.get("date"),
  8134:     63:                 "chat": str((msg.get("chat") or {}).get("id")),
  8135:     64:                 "text": text,
  8136:     65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
  8137:     66:             })
  8138:     67:         return out
  8139: 
  8140: 
  8141: ## scalper/live/watchlist.py (last modified: 2025-08-24 03:12:00)
  8142:      1: # -*- coding: utf-8 -*-
  8143:      2: from __future__ import annotations
  8144:      3: from dataclasses import dataclass
  8145:      4: from typing import List
  8146:      5: 
  8147:      6: 
  8148:      7: @dataclass
  8149:      8: class WatchlistManager:
  8150:      9:     symbols: List[str]
  8151:     10: 
  8152:     11:     @classmethod
  8153:     12:     def from_env_or_default(cls) -> "WatchlistManager":
  8154:     13:         # Tu peux lire une variable d'env ici si tu veux surcharger
  8155:     14:         default = [
  8156:     15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
  8157:     16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
  8158:     17:         ]
  8159:     18:         return cls(default)
  8160: 
  8161: ## scalper/logging_utils.py (last modified: 2025-08-23 20:57:14)
  8162:      1: """Logging helpers for the Scalp bot."""
  8163:      2: 
  8164:      3: from __future__ import annotations
  8165:      4: 
  8166:      5: import atexit
  8167:      6: import csv
  8168:      7: import json
  8169:      8: import os
  8170:      9: import sqlite3
  8171:     10: import time
  8172:     11: from pathlib import Path
  8173:     12: from typing import Any, Dict, List
  8174:     13: 
  8175:     14: 
  8176:     15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
  8177:     16:     """Return a callable that logs events as JSON lines.
  8178:     17: 
  8179:     18:     Parameters
  8180:     19:     ----------
  8181:     20:     path: str
  8182:     21:         Target file path for JSON lines.
  8183:     22:     max_bytes: int, optional
  8184:     23:         If >0, rotate the file when its size exceeds this value.
  8185:     24:     backup_count: int, optional
  8186:     25:         Number of rotated files to keep when ``max_bytes`` is set.
  8187:     26:     """
  8188:     27:     os.makedirs(os.path.dirname(path), exist_ok=True)
  8189:     28:     log_file = open(path, "a", encoding="utf-8")
  8190:     29: 
  8191:     30:     def _close_file() -> None:
  8192:     31:         try:
  8193:     32:             log_file.close()
  8194:     33:         except Exception:
  8195:     34:             pass
  8196:     35: 
  8197:     36:     atexit.register(_close_file)
  8198:     37: 
  8199:     38:     def _rotate() -> None:
  8200:     39:         nonlocal log_file
  8201:     40:         log_file.close()
  8202:     41:         for i in range(backup_count - 1, 0, -1):
  8203:     42:             src = f"{path}.{i}"
  8204:     43:             dst = f"{path}.{i + 1}"
  8205:     44:             if os.path.exists(src):
  8206:     45:                 os.replace(src, dst)
  8207:     46:         os.replace(path, f"{path}.1")
  8208:     47:         log_file = open(path, "a", encoding="utf-8")
  8209:     48: 
  8210:     49:     def _log(event: str, payload: Dict[str, Any]) -> None:
  8211:     50:         nonlocal log_file
  8212:     51:         payload = dict(payload or {})
  8213:     52:         payload["event"] = event
  8214:     53:         payload["ts"] = int(time.time() * 1000)
  8215:     54:         line = json.dumps(payload, ensure_ascii=False)
  8216:     55:         if max_bytes and backup_count > 0:
  8217:     56:             if log_file.tell() + len(line) + 1 > max_bytes:
  8218:     57:                 _rotate()
  8219:     58:         log_file.write(line + "\n")
  8220:     59:         log_file.flush()
  8221:     60: 
  8222:     61:     return _log
  8223:     62: 
  8224:     63: 
  8225:     64: class TradeLogger:
  8226:     65:     """Helper writing trade information to CSV and SQLite files."""
  8227:     66: 
  8228:     67:     fields = [
  8229:     68:         "pair",
  8230:     69:         "tf",
  8231:     70:         "dir",
  8232:     71:         "entry",
  8233:     72:         "sl",
  8234:     73:         "tp",
  8235:     74:         "score",
  8236:     75:         "reasons",
  8237:     76:         "pnl",
  8238:     77:     ]
  8239:     78: 
  8240:     79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
  8241:     80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
  8242:     81:         self.csv_path = csv_path
  8243:     82:         self.sqlite_path = sqlite_path
  8244:     83: 
  8245:     84:         # Ensure CSV has header
  8246:     85:         if not os.path.exists(csv_path):
  8247:     86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
  8248:     87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
  8249:     88:                 writer.writeheader()
  8250:     89: 
  8251:     90:         # Setup SQLite store
  8252:     91:         self.conn = sqlite3.connect(sqlite_path)
  8253:     92:         cur = self.conn.cursor()
  8254:     93:         cur.execute(
  8255:     94:             """
  8256:     95:             CREATE TABLE IF NOT EXISTS trades (
  8257:     96:                 pair TEXT,
  8258:     97:                 tf TEXT,
  8259:     98:                 dir TEXT,
  8260:     99:                 entry REAL,
  8261:    100:                 sl REAL,
  8262:    101:                 tp REAL,
  8263:    102:                 score REAL,
  8264:    103:                 reasons TEXT,
  8265:    104:                 pnl REAL
  8266:    105:             )
  8267:    106:             """
  8268:    107:         )
  8269:    108:         self.conn.commit()
  8270:    109:         atexit.register(self.conn.close)
  8271:    110: 
  8272:    111:     def log(self, data: Dict[str, Any]) -> None:
  8273:    112:         row = {k: data.get(k) for k in self.fields}
  8274:    113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
  8275:    114:             writer = csv.DictWriter(f, fieldnames=self.fields)
  8276:    115:             writer.writerow(row)
  8277:    116:         cur = self.conn.cursor()
  8278:    117:         cur.execute(
  8279:    118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
  8280:    119:             (
  8281:    120:                 row["pair"],
  8282:    121:                 row["tf"],
  8283:    122:                 row["dir"],
  8284:    123:                 row["entry"],
  8285:    124:                 row["sl"],
  8286:    125:                 row["tp"],
  8287:    126:                 row["score"],
  8288:    127:                 row["reasons"],
  8289:    128:                 row["pnl"],
  8290:    129:             ),
  8291:    130:         )
  8292:    131:         self.conn.commit()
  8293:    132: 
  8294:    133: 
  8295:    134: BASE_DIR = Path(__file__).resolve().parents[2]
  8296:    135: 
  8297:    136: 
  8298:    137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
  8299:    138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
  8300:    139:     path.parent.mkdir(parents=True, exist_ok=True)
  8301:    140:     file_exists = path.exists()
  8302:    141:     with path.open("a", newline="", encoding="utf-8") as f:
  8303:    142:         writer = csv.DictWriter(f, fieldnames=fields)
  8304:    143:         if not file_exists:
  8305:    144:             writer.writeheader()
  8306:    145:         writer.writerow({k: row.get(k) for k in fields})
  8307:    146: 
  8308:    147: 
  8309:    148: def log_position(data: Dict[str, Any]) -> None:
  8310:    149:     """Log a closed position to ``../positions.csv``."""
  8311:    150:     fields = [
  8312:    151:         "timestamp",
  8313:    152:         "pair",
  8314:    153:         "direction",
  8315:    154:         "entry",
  8316:    155:         "exit",
  8317:    156:         "pnl_pct",
  8318:    157:         "fee_rate",
  8319:    158:         "notes",
  8320:    159:     ]
  8321:    160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
  8322:    161: 
  8323:    162: 
  8324:    163: def log_operation_memo(data: Dict[str, Any]) -> None:
  8325:    164:     """Log operation details to ``../operations_memo.csv``."""
  8326:    165:     fields = ["timestamp", "pair", "details"]
  8327:    166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)
  8328: 
  8329: 
  8330: ## scalper/metrics.py (last modified: 2025-08-23 20:57:14)
  8331:      1: """Utility metrics for trading calculations."""
  8332:      2: 
  8333:      3: from __future__ import annotations
  8334:      4: 
  8335:      5: 
  8336:      6: from typing import Iterable
  8337:      7: 
  8338:      8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
  8339:      9: 
  8340:     10: 
  8341:     11: def calc_pnl_pct(
  8342:     12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
  8343:     13: ) -> float:
  8344:     14:     """Return percentage PnL between entry and exit prices minus fees.
  8345:     15: 
  8346:     16: 
  8347:     17:     Parameters
  8348:     18:     ----------
  8349:     19:     entry_price: float
  8350:     20:         Trade entry price (>0).
  8351:     21:     exit_price: float
  8352:     22:         Trade exit price (>0).
  8353:     23:     side: int
  8354:     24:         +1 for long, -1 for short.
  8355:     25:     fee_rate: float, optional
  8356:     26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
  8357:     27:         applied twice (entry + exit).
  8358:     28:     """
  8359:     29:     if entry_price <= 0 or exit_price <= 0:
  8360:     30:         raise ValueError("Prices must be positive")
  8361:     31:     if side not in (1, -1):
  8362:     32:         raise ValueError("side must be +1 (long) or -1 (short)")
  8363:     33: 
  8364:     34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
  8365:     35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
  8366:     36:     return pnl - fee_pct
  8367:     37: 
  8368:     38: 
  8369:     39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
  8370:     40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
  8371:     41: 
  8372:     42: 
  8373:     43:     Parameters
  8374:     44:     ----------
  8375:     45:     prices:
  8376:     46:         Ordered sequence of closing prices.
  8377:     47:     period:
  8378:     48:         Number of periods to use for the calculation. Must be positive and the
  8379:     49:         length of ``prices`` must be at least ``period + 1``.
  8380:     50:     """
  8381:     51: 
  8382:     52:     prices_list = [float(p) for p in prices]
  8383:     53: 
  8384:     54:     if period <= 0:
  8385:     55:         raise ValueError("period must be positive")
  8386:     56:     if len(prices_list) < period + 1:
  8387:     57: 
  8388:     58:         raise ValueError("len(prices) must be >= period + 1")
  8389:     59: 
  8390:     60:     gains: list[float] = []
  8391:     61:     losses: list[float] = []
  8392:     62:     for i in range(1, period + 1):
  8393:     63: 
  8394:     64:         diff = prices_list[i] - prices_list[i - 1]
  8395:     65: 
  8396:     66:         if diff >= 0:
  8397:     67:             gains.append(diff)
  8398:     68:             losses.append(0.0)
  8399:     69:         else:
  8400:     70:             gains.append(0.0)
  8401:     71:             losses.append(-diff)
  8402:     72: 
  8403:     73:     avg_gain = sum(gains) / period
  8404:     74:     avg_loss = sum(losses) / period
  8405:     75: 
  8406:     76:     for i in range(period + 1, len(prices_list)):
  8407:     77:         diff = prices_list[i] - prices_list[i - 1]
  8408:     78: 
  8409:     79:         gain = max(diff, 0.0)
  8410:     80:         loss = max(-diff, 0.0)
  8411:     81:         avg_gain = (avg_gain * (period - 1) + gain) / period
  8412:     82:         avg_loss = (avg_loss * (period - 1) + loss) / period
  8413:     83: 
  8414:     84:     if avg_gain == 0 and avg_loss == 0:
  8415:     85:         return 50.0
  8416:     86:     if avg_loss == 0:
  8417:     87:         return 100.0
  8418:     88:     if avg_gain == 0:
  8419:     89:         return 0.0
  8420:     90:     rs = avg_gain / avg_loss
  8421:     91:     return 100.0 - (100.0 / (1.0 + rs))
  8422:     92: 
  8423:     93: 
  8424:     94: def calc_atr(
  8425:     95:     highs: Iterable[float],
  8426:     96:     lows: Iterable[float],
  8427:     97:     closes: Iterable[float],
  8428:     98:     period: int = 14,
  8429:     99: ) -> float:
  8430:    100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
  8431:    101: 
  8432:    102: 
  8433:    103:     Parameters
  8434:    104:     ----------
  8435:    105:     highs, lows, closes:
  8436:    106:         Ordered sequences of high, low and close prices. All sequences must
  8437:    107:         have the same length and contain at least ``period + 1`` elements.
  8438:    108:     period:
  8439:    109:         Number of periods to use for the calculation. Must be positive.
  8440:    110:     """
  8441:    111: 
  8442:    112:     highs_list = [float(h) for h in highs]
  8443:    113:     lows_list = [float(low) for low in lows]
  8444:    114:     closes_list = [float(c) for c in closes]
  8445:    115: 
  8446:    116:     length = len(highs_list)
  8447:    117:     if length != len(lows_list) or length != len(closes_list):
  8448:    118: 
  8449:    119:         raise ValueError("Input sequences must have the same length")
  8450:    120:     if period <= 0:
  8451:    121:         raise ValueError("period must be positive")
  8452:    122:     if length < period + 1:
  8453:    123:         raise ValueError("Input sequences must have at least period + 1 elements")
  8454:    124: 
  8455:    125:     trs: list[float] = []
  8456:    126:     for i in range(1, len(highs_list)):
  8457:    127:         tr = max(
  8458:    128:             highs_list[i] - lows_list[i],
  8459:    129:             abs(highs_list[i] - closes_list[i - 1]),
  8460:    130:             abs(lows_list[i] - closes_list[i - 1]),
  8461:    131:         )
  8462:    132:         trs.append(tr)
  8463:    133: 
  8464:    134:     atr = sum(trs[:period]) / period
  8465:    135:     for tr in trs[period:]:
  8466:    136:         atr = (atr * (period - 1) + tr) / period
  8467:    137:     return atr
  8468:    138: 
  8469:    139: 
  8470:    140: def calc_macd(
  8471:    141:     prices: Sequence[float],
  8472:    142:     fast: int = 12,
  8473:    143:     slow: int = 26,
  8474:    144:     signal: int = 9,
  8475:    145: ) -> tuple[float, float, float]:
  8476:    146:     """Return MACD, signal line and histogram values.
  8477:    147: 
  8478:    148:     The implementation computes exponential moving averages using Wilder's
  8479:    149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
  8480:    150:     """
  8481:    151: 
  8482:    152:     prices_list = [float(p) for p in prices]
  8483:    153:     if fast <= 0 or slow <= 0 or signal <= 0:
  8484:    154:         raise ValueError("periods must be positive")
  8485:    155:     min_len = max(fast, slow) + signal
  8486:    156:     if len(prices_list) < min_len:
  8487:    157:         raise ValueError("len(prices) must be >= slow + signal")
  8488:    158: 
  8489:    159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
  8490:    160:         k = 2.0 / (window + 1.0)
  8491:    161:         out = [float(series[0])]
  8492:    162:         for x in series[1:]:
  8493:    163:             out.append(float(x) * k + out[-1] * (1.0 - k))
  8494:    164:         return out
  8495:    165: 
  8496:    166:     fast_ema = _ema_series(prices_list, fast)
  8497:    167:     slow_ema = _ema_series(prices_list, slow)
  8498:    168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
  8499:    169:     signal_series = _ema_series(macd_series, signal)
  8500:    170:     macd_val = macd_series[-1]
  8501:    171:     signal_val = signal_series[-1]
  8502:    172:     hist = macd_val - signal_val
  8503:    173:     return macd_val, signal_val, hist
  8504:    174: 
  8505:    175: 
  8506:    176: def backtest_position(
  8507:    177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
  8508:    178: ) -> bool:
  8509:    179:     """Run a basic backtest to verify a position's coherence.
  8510:    180: 
  8511:    181:     Parameters
  8512:    182:     ----------
  8513:    183:     prices: list[float]
  8514:    184:         Sequential list of prices to evaluate.
  8515:    185:     entry_idx: int
  8516:    186:         Index in ``prices`` where the position is opened.
  8517:    187:     exit_idx: int
  8518:    188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
  8519:    189:     side: int
  8520:    190:         +1 for long, -1 for short.
  8521:    191: 
  8522:    192:     Returns
  8523:    193:     -------
  8524:    194:     bool
  8525:    195:         ``True`` if the resulting PnL is non-negative, meaning the position is
  8526:    196:         coherent with the direction of price movement. ``False`` otherwise.
  8527:    197:     """
  8528:    198:     if side not in (1, -1):
  8529:    199:         raise ValueError("side must be +1 (long) or -1 (short)")
  8530:    200:     if not (0 <= entry_idx < exit_idx < len(prices)):
  8531:    201:         raise ValueError(
  8532:    202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
  8533:    203:         )
  8534:    204: 
  8535:    205:     entry_price = float(prices[entry_idx])
  8536:    206:     exit_price = float(prices[exit_idx])
  8537:    207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
  8538:    208:     return pnl >= 0.0
  8539: 
  8540: 
  8541: ## scalper/pairs.py (last modified: 2025-08-23 20:57:14)
  8542:      1: """Utilities to select trading pairs and detect signals."""
  8543:      2: from __future__ import annotations
  8544:      3: from typing import Any, Dict, List, Optional, Callable
  8545:      4: from scalper.strategy import Signal
  8546:      5: 
  8547:      6: from scalper.bot_config import CONFIG
  8548:      7: from scalper.strategy import ema as default_ema, cross as default_cross
  8549:      8: from scalper.notifier import notify
  8550:      9: 
  8551:     10: 
  8552:     11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
  8553:     12:     """Return all trading pairs using the client's ``get_ticker`` method."""
  8554:     13:     tick = client.get_ticker()
  8555:     14:     data = tick.get("data") if isinstance(tick, dict) else []
  8556:     15:     if not data:
  8557:     16:         return []
  8558:     17:     return data if isinstance(data, list) else [data]
  8559:     18: 
  8560:     19: 
  8561:     20: def filter_trade_pairs(
  8562:     21:     client: Any,
  8563:     22:     *,
  8564:     23:     volume_min: float = 5_000_000,
  8565:     24:     max_spread_bps: float = 5.0,
  8566:     25:     top_n: int = 40,
  8567:     26: ) -> List[Dict[str, Any]]:
  8568:     27:     """Filter pairs by volume and spread."""
  8569:     28:     pairs = get_trade_pairs(client)
  8570:     29:     eligible: List[Dict[str, Any]] = []
  8571:     30: 
  8572:     31:     for info in pairs:
  8573:     32:         sym = info.get("symbol")
  8574:     33:         if not sym:
  8575:     34:             continue
  8576:     35:         try:
  8577:     36:             vol = float(info.get("volume", 0))
  8578:     37:         except (TypeError, ValueError):
  8579:     38:             continue
  8580:     39:         if vol < volume_min:
  8581:     40:             continue
  8582:     41:         try:
  8583:     42:             bid = float(info.get("bidPrice", 0))
  8584:     43:             ask = float(info.get("askPrice", 0))
  8585:     44:         except (TypeError, ValueError):
  8586:     45:             continue
  8587:     46:         if bid <= 0 or ask <= 0:
  8588:     47:             continue
  8589:     48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
  8590:     49:         if spread_bps >= max_spread_bps:
  8591:     50:             continue
  8592:     51:         eligible.append(info)
  8593:     52: 
  8594:     53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
  8595:     54:     return eligible[:top_n]
  8596:     55: 
  8597:     56: 
  8598:     57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
  8599:     58:     """Return ``top_n`` pairs sorted by ``key``."""
  8600:     59:     pairs = get_trade_pairs(client)
  8601:     60: 
  8602:     61:     def volume(row: Dict[str, Any]) -> float:
  8603:     62:         try:
  8604:     63:             return float(row.get(key, 0))
  8605:     64:         except (TypeError, ValueError):
  8606:     65:             return 0.0
  8607:     66: 
  8608:     67:     pairs.sort(key=volume, reverse=True)
  8609:     68:     return pairs[:top_n]
  8610:     69: 
  8611:     70: 
  8612:     71: def _ancienne_impl(
  8613:     72:     client: Any,
  8614:     73:     pairs: List[Dict[str, Any]],
  8615:     74:     *,
  8616:     75:     interval: str = "1m",
  8617:     76:     ema_fast_n: Optional[int] = None,
  8618:     77:     ema_slow_n: Optional[int] = None,
  8619:     78:     ema_func=default_ema,
  8620:     79:     cross_func=default_cross,
  8621:     80: ) -> List[Dict[str, Any]]:
  8622:     81:     """Original implementation returning dicts."""
  8623:     82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
  8624:     83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
  8625:     84:     results: List[Dict[str, Any]] = []
  8626:     85: 
  8627:     86:     for info in pairs:
  8628:     87:         symbol = info.get("symbol")
  8629:     88:         if not symbol:
  8630:     89:             continue
  8631:     90:         k = client.get_kline(symbol, interval=interval)
  8632:     91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
  8633:     92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
  8634:     93:             continue
  8635:     94:         efull = ema_func(closes, ema_fast_n)
  8636:     95:         eslow = ema_func(closes, ema_slow_n)
  8637:     96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
  8638:     97:         if signal == 1:
  8639:     98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  8640:     99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
  8641:    100:         elif signal == -1:
  8642:    101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
  8643:    102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
  8644:    103:     return results
  8645:    104: 
  8646:    105: 
  8647:    106: def _to_signal(d: dict) -> Signal:
  8648:    107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
  8649:    108:     return Signal(
  8650:    109:         symbol=d.get("symbol"),
  8651:    110:         side=side,
  8652:    111:         entry=float(d.get("price", d.get("entry", 0))),
  8653:    112:         sl=float(d.get("sl", 0)),
  8654:    113:         tp1=float(d.get("tp1", 0)) or None,
  8655:    114:         tp2=float(d.get("tp2", 0)) or None,
  8656:    115:         score=d.get("score"),
  8657:    116:         quality=d.get("quality"),
  8658:    117:         reasons=d.get("reasons", []),
  8659:    118:     )
  8660:    119: 
  8661:    120: 
  8662:    121: def find_trade_positions(
  8663:    122:     client: Any,
  8664:    123:     pairs: List[Dict[str, Any]],
  8665:    124:     *,
  8666:    125:     interval: str = "1m",
  8667:    126:     ema_fast_n: Optional[int] = None,
  8668:    127:     ema_slow_n: Optional[int] = None,
  8669:    128:     ema_func=default_ema,
  8670:    129:     cross_func=default_cross,
  8671:    130: ) -> List[Signal]:
  8672:    131:     raw = _ancienne_impl(
  8673:    132:         client,
  8674:    133:         pairs,
  8675:    134:         interval=interval,
  8676:    135:         ema_fast_n=ema_fast_n,
  8677:    136:         ema_slow_n=ema_slow_n,
  8678:    137:         ema_func=ema_func,
  8679:    138:         cross_func=cross_func,
  8680:    139:     )
  8681:    140:     return [_to_signal(x) for x in raw]
  8682:    141: 
  8683:    142: 
  8684:    143: def send_selected_pairs(
  8685:    144:     client: Any,
  8686:    145:     top_n: int = 40,
  8687:    146:     *,
  8688:    147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
  8689:    148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
  8690:    149: ) -> Dict[str, str]:
  8691:    150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
  8692:    151: 
  8693:    152:     Returns the payload sent to ``notify_fn``. The mapping contains the
  8694:    153:     comma-separated symbols for each color group (``green``, ``orange`` and
  8695:    154:     ``red``) or an empty dictionary when no pairs are available.
  8696:    155:     """
  8697:    156: 
  8698:    157:     def split_symbol(sym: str) -> tuple[str, str]:
  8699:    158:         if "_" in sym:
  8700:    159:             left, right = sym.split("_", 1)
  8701:    160:             # Legacy style: BTC_USDT
  8702:    161:             if len(right) <= 4:
  8703:    162:                 return left, right
  8704:    163:             # Bitget futures style: BTCUSDT_UMCBL
  8705:    164:             main = left
  8706:    165:             if main.endswith("USDT"):
  8707:    166:                 return main[:-4], "USDT"
  8708:    167:             if main.endswith("USDC"):
  8709:    168:                 return main[:-4], "USDC"
  8710:    169:             if main.endswith("USD"):
  8711:    170:                 return main[:-3], "USD"
  8712:    171:             return main, ""
  8713:    172:         if sym.endswith("USDT"):
  8714:    173:             return sym[:-4], "USDT"
  8715:    174:         if sym.endswith("USDC"):
  8716:    175:             return sym[:-4], "USDC"
  8717:    176:         if sym.endswith("USD"):
  8718:    177:             return sym[:-3], "USD"
  8719:    178:         return sym, ""
  8720:    179: 
  8721:    180:     pairs = select_fn(client, top_n=top_n * 3)
  8722:    181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
  8723:    182:     by_base: Dict[str, Dict[str, Any]] = {}
  8724:    183:     for info in pairs:
  8725:    184:         sym = info.get("symbol")
  8726:    185:         if not sym:
  8727:    186:             continue
  8728:    187:         norm_sym = sym.split("_")[0].upper()
  8729:    188:         if allowed and norm_sym not in allowed:
  8730:    189:             continue
  8731:    190:         base, quote = split_symbol(sym)
  8732:    191:         existing = by_base.get(base)
  8733:    192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
  8734:    193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
  8735:    194:             by_base[base] = {"data": info, "quote": quote}
  8736:    195: 
  8737:    196:     unique = sorted(
  8738:    197:         (v["data"] for v in by_base.values()),
  8739:    198:         key=lambda row: float(row.get("volume", 0)),
  8740:    199:         reverse=True,
  8741:    200:     )
  8742:    201:     symbols: list[str] = []
  8743:    202:     for row in unique[:top_n]:
  8744:    203:         sym = row.get("symbol")
  8745:    204:         if not sym:
  8746:    205:             continue
  8747:    206:         base, _ = split_symbol(sym)
  8748:    207:         symbols.append(base)
  8749:    208:     if symbols:
  8750:    209:         n = len(symbols)
  8751:    210:         third = max(n // 3, 1)
  8752:    211:         green = symbols[:third]
  8753:    212:         orange = symbols[third : 2 * third]
  8754:    213:         red = symbols[2 * third :]
  8755:    214:         payload: Dict[str, str] = {}
  8756:    215:         if green:
  8757:    216:             payload["green"] = ", ".join(green)
  8758:    217:         if orange:
  8759:    218:             payload["orange"] = ", ".join(orange)
  8760:    219:         if red:
  8761:    220:             payload["red"] = ", ".join(red)
  8762:    221:         notify_fn("pair_list", payload)
  8763:    222:         return payload
  8764:    223:     return {}
  8765:    224: 
  8766:    225: 
  8767:    226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
  8768:    227:     """Return a heat score combining volatility, volume and a news flag."""
  8769:    228:     mult = 2.0 if news else 1.0
  8770:    229:     return volatility * volume * mult
  8771:    230: 
  8772:    231: 
  8773:    232: def select_top_heat_pairs(
  8774:    233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
  8775:    234: ) -> List[Dict[str, Any]]:
  8776:    235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
  8777:    236: 
  8778:    237:     scored: List[Dict[str, Any]] = []
  8779:    238:     for info in pairs:
  8780:    239:         try:
  8781:    240:             vol = float(info.get("volatility", 0))
  8782:    241:             volume = float(info.get("volume", 0))
  8783:    242:         except (TypeError, ValueError):
  8784:    243:             continue
  8785:    244:         score = heat_score(vol, volume, bool(info.get("news")))
  8786:    245:         row = dict(info)
  8787:    246:         row["heat_score"] = score
  8788:    247:         scored.append(row)
  8789:    248: 
  8790:    249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
  8791:    250:     return scored[:top_n]
  8792:    251: 
  8793:    252: 
  8794:    253: def decorrelate_pairs(
  8795:    254:     pairs: List[Dict[str, Any]],
  8796:    255:     corr: Dict[str, Dict[str, float]],
  8797:    256:     *,
  8798:    257:     threshold: float = 0.8,
  8799:    258:     top_n: int = 3,
  8800:    259: ) -> List[Dict[str, Any]]:
  8801:    260:     """Return top pairs while avoiding highly correlated symbols.
  8802:    261: 
  8803:    262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
  8804:    263:     pairs are considered too correlated when the absolute value of the
  8805:    264:     correlation exceeds ``threshold``.
  8806:    265:     """
  8807:    266: 
  8808:    267:     selected: List[Dict[str, Any]] = []
  8809:    268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
  8810:    269:         sym = info.get("symbol")
  8811:    270:         if not sym:
  8812:    271:             continue
  8813:    272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
  8814:    273:             selected.append(info)
  8815:    274:         if len(selected) >= top_n:
  8816:    275:             break
  8817:    276:     return selected
  8818: 
  8819: 
  8820: ## scalper/positions/__init__.py (last modified: 2025-08-23 20:57:14)
  8821: 
  8822: 
  8823: ## scalper/positions/state.py (last modified: 2025-08-23 20:57:14)
  8824:      1: from __future__ import annotations
  8825:      2: from dataclasses import dataclass, field
  8826:      3: from enum import Enum, auto
  8827:      4: from typing import List, Optional
  8828:      5: import time
  8829:      6: 
  8830:      7: class PositionStatus(Enum):
  8831:      8:     IDLE = auto()
  8832:      9:     PENDING_ENTRY = auto()
  8833:     10:     OPEN = auto()
  8834:     11:     PENDING_EXIT = auto()
  8835:     12:     CLOSED = auto()
  8836:     13: 
  8837:     14: class PositionSide(Enum):
  8838:     15:     LONG = 1
  8839:     16:     SHORT = -1
  8840:     17: 
  8841:     18: @dataclass
  8842:     19: class Fill:
  8843:     20:     order_id: str
  8844:     21:     trade_id: str
  8845:     22:     price: float
  8846:     23:     qty: float
  8847:     24:     fee: float
  8848:     25:     ts: int
  8849:     26: 
  8850:     27: @dataclass
  8851:     28: class PositionState:
  8852:     29:     symbol: str
  8853:     30:     side: PositionSide
  8854:     31:     status: PositionStatus = PositionStatus.IDLE
  8855:     32:     entry_order_id: Optional[str] = None
  8856:     33:     exit_order_id: Optional[str] = None
  8857:     34:     req_qty: float = 0.0
  8858:     35:     filled_qty: float = 0.0
  8859:     36:     avg_entry_price: float = 0.0
  8860:     37:     avg_exit_price: float = 0.0
  8861:     38:     sl: Optional[float] = None
  8862:     39:     tp: Optional[float] = None
  8863:     40:     realized_pnl: float = 0.0
  8864:     41:     fees: float = 0.0
  8865:     42:     opened_ts: Optional[int] = None
  8866:     43:     closed_ts: Optional[int] = None
  8867:     44:     fills: List[Fill] = field(default_factory=list)
  8868:     45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
  8869:     46: 
  8870:     47:     def apply_fill_entry(self, f: Fill) -> None:
  8871:     48:         self.fills.append(f)
  8872:     49:         self.filled_qty += f.qty
  8873:     50:         # moyenne pondérée
  8874:     51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
  8875:     52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
  8876:     53:         self.fees += abs(f.fee)
  8877:     54:         if self.opened_ts is None:
  8878:     55:             self.opened_ts = f.ts
  8879:     56:         if self.filled_qty > 1e-12:
  8880:     57:             self.status = PositionStatus.OPEN
  8881:     58: 
  8882:     59:     def apply_fill_exit(self, f: Fill) -> None:
  8883:     60:         self.fills.append(f)
  8884:     61:         qty = min(self.filled_qty, f.qty)
  8885:     62:         # realized pnl sur la quantité fermée
  8886:     63:         if self.side == PositionSide.LONG:
  8887:     64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
  8888:     65:         else:
  8889:     66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
  8890:     67:         self.fees += abs(f.fee)
  8891:     68:         self.filled_qty = max(0.0, self.filled_qty - qty)
  8892:     69:         # moyenne de sortie indicative
  8893:     70:         closed_q = (self.req_qty - self.filled_qty)
  8894:     71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
  8895:     72:         if self.filled_qty <= 1e-12:
  8896:     73:             self.status = PositionStatus.CLOSED
  8897:     74:             self.closed_ts = f.ts
  8898:     75: 
  8899: 
  8900: 
  8901: ## scalper/risk/__init__.py (last modified: 2025-08-23 20:57:14)
  8902:      1: # scalp/risk/__init__.py
  8903:      2: from .manager import (
  8904:      3:     Caps,
  8905:      4:     compute_size,
  8906:      5:     calc_position_size,  # alias legacy
  8907:      6:     RiskManager,         # shim legacy
  8908:      7: )
  8909:      8: 
  8910:      9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]
  8911: 
  8912: ## scalper/risk/manager.py (last modified: 2025-08-23 20:57:14)
  8913:      1: # scalp/risk/manager.py
  8914:      2: from __future__ import annotations
  8915:      3: from dataclasses import dataclass
  8916:      4: from typing import Optional, Dict, Any
  8917:      5: 
  8918:      6: @dataclass
  8919:      7: class Caps:
  8920:      8:     min_qty: float = 0.0
  8921:      9:     min_notional: float = 0.0
  8922:     10:     max_leverage: float = 20.0
  8923:     11: 
  8924:     12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
  8925:     13:     if not caps_by_symbol:
  8926:     14:         return Caps()
  8927:     15:     c = caps_by_symbol.get(symbol, {})
  8928:     16:     return Caps(
  8929:     17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
  8930:     18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
  8931:     19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
  8932:     20:     )
  8933:     21: 
  8934:     22: def compute_size(
  8935:     23:     *,
  8936:     24:     symbol: str,
  8937:     25:     price: float,
  8938:     26:     balance_cash: float,
  8939:     27:     risk_pct: float = 0.5,
  8940:     28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
  8941:     29: ) -> float:
  8942:     30:     """Sizing robuste avec gardes min_notional / min_qty."""
  8943:     31:     price = max(1e-9, float(price))
  8944:     32:     balance_cash = max(0.0, float(balance_cash))
  8945:     33:     risk_pct = max(0.0, float(risk_pct))
  8946:     34: 
  8947:     35:     notionnel = balance_cash * risk_pct
  8948:     36:     qty = notionnel / price
  8949:     37: 
  8950:     38:     caps = _get_caps(caps_by_symbol, symbol)
  8951:     39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
  8952:     40:         qty = caps.min_notional / price
  8953:     41:     if caps.min_qty > 0 and qty < caps.min_qty:
  8954:     42:         qty = caps.min_qty
  8955:     43:     return max(0.0, qty)
  8956:     44: 
  8957:     45: # --- Shims pour compatibilité ancienne API -----------------------------------
  8958:     46: 
  8959:     47: def calc_position_size(symbol: str, price: float, balance_cash: float,
  8960:     48:                        risk_pct: float = 0.5,
  8961:     49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
  8962:     50:     """Alias legacy → compute_size."""
  8963:     51:     return compute_size(
  8964:     52:         symbol=symbol, price=price, balance_cash=balance_cash,
  8965:     53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
  8966:     54:     )
  8967:     55: 
  8968:     56: class RiskManager:
  8969:     57:     """
  8970:     58:     Shim minimal compatible avec l'ancien code:
  8971:     59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
  8972:     60:       qty = rm.size(symbol, price, balance_cash)
  8973:     61:     """
  8974:     62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
  8975:     63:         self.risk_pct = float(risk_pct)
  8976:     64:         self.caps_by_symbol = caps_by_symbol or {}
  8977:     65: 
  8978:     66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
  8979:     67:         return compute_size(
  8980:     68:             symbol=symbol, price=price, balance_cash=balance_cash,
  8981:     69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
  8982:     70:         )
  8983: 
  8984: ## scalper/selection/__init__.py (last modified: 2025-08-23 20:57:14)
  8985:      1: """Pair selection helpers for the Scalp bot.
  8986:      2: 
  8987:      3: This package exposes two utilities used during the preparation phase of the
  8988:      4: trading strategy:
  8989:      5: 
  8990:      6: ``scan_pairs``
  8991:      7:     Performs the first level market scan by filtering pairs based on volume,
  8992:      8:     spread and hourly volatility.
  8993:      9: 
  8994:     10: ``select_active_pairs``
  8995:     11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
  8996:     12:     crossover and a sufficiently high ATR.
  8997:     13: """
  8998:     14: 
  8999:     15: from .scanner import scan_pairs
  9000:     16: from .momentum import select_active_pairs
  9001:     17: 
  9002:     18: __all__ = ["scan_pairs", "select_active_pairs"]
  9003:     19: 
  9004: 
  9005: 
  9006: ## scalper/selection/momentum.py (last modified: 2025-08-23 20:57:14)
  9007:      1: """Utilities to select pairs exhibiting strong momentum."""
  9008:      2: 
  9009:      3: from __future__ import annotations
  9010:      4: 
  9011:      5: from typing import Any, Dict, List, Sequence
  9012:      6: 
  9013:      7: from ..metrics import calc_atr
  9014:      8: 
  9015:      9: 
  9016:     10: def ema(series: Sequence[float], window: int) -> List[float]:
  9017:     11:     """Simple exponential moving average implementation."""
  9018:     12: 
  9019:     13:     if window <= 1 or not series:
  9020:     14:         return list(series)
  9021:     15:     k = 2.0 / (window + 1.0)
  9022:     16:     out: List[float] = [float(series[0])]
  9023:     17:     prev = out[0]
  9024:     18:     for x in series[1:]:
  9025:     19:         prev = float(x) * k + prev * (1.0 - k)
  9026:     20:         out.append(prev)
  9027:     21:     return out
  9028:     22: 
  9029:     23: 
  9030:     24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  9031:     25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
  9032:     26: 
  9033:     27:     if prev_fast <= prev_slow and last_fast > last_slow:
  9034:     28:         return 1
  9035:     29:     if prev_fast >= prev_slow and last_fast < last_slow:
  9036:     30:         return -1
  9037:     31:     return 0
  9038:     32: 
  9039:     33: 
  9040:     34: def _quantile(values: Sequence[float], q: float) -> float:
  9041:     35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
  9042:     36: 
  9043:     37:     if not values:
  9044:     38:         return 0.0
  9045:     39:     q = min(max(q, 0.0), 1.0)
  9046:     40:     vals = sorted(values)
  9047:     41:     idx = int((len(vals) - 1) * q)
  9048:     42:     return vals[idx]
  9049:     43: 
  9050:     44: 
  9051:     45: def select_active_pairs(
  9052:     46:     client: Any,
  9053:     47:     pairs: Sequence[Dict[str, Any]],
  9054:     48:     *,
  9055:     49:     interval: str = "Min5",
  9056:     50:     ema_fast: int = 20,
  9057:     51:     ema_slow: int = 50,
  9058:     52:     atr_period: int = 14,
  9059:     53:     atr_quantile: float = 0.5,
  9060:     54:     top_n: int = 5,
  9061:     55: ) -> List[Dict[str, Any]]:
  9062:     56:     """Return pairs with an EMA crossover and high ATR.
  9063:     57: 
  9064:     58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
  9065:     59:     Among those candidates, the Average True Range is computed and only pairs
  9066:     60:     whose ATR is above the provided quantile are returned.  The resulting
  9067:     61:     dictionaries include an ``atr`` key for convenience.
  9068:     62:     """
  9069:     63: 
  9070:     64:     candidates: List[Dict[str, Any]] = []
  9071:     65:     atrs: List[float] = []
  9072:     66: 
  9073:     67:     for info in pairs:
  9074:     68:         sym = info.get("symbol")
  9075:     69:         if not sym:
  9076:     70:             continue
  9077:     71:         k = client.get_kline(sym, interval=interval)
  9078:     72:         kdata = k.get("data") if isinstance(k, dict) else {}
  9079:     73:         closes = kdata.get("close", [])
  9080:     74:         highs = kdata.get("high", [])
  9081:     75:         lows = kdata.get("low", [])
  9082:     76:         if len(closes) < max(ema_slow, atr_period) + 2:
  9083:     77:             continue
  9084:     78:         efast = ema(closes, ema_fast)
  9085:     79:         eslow = ema(closes, ema_slow)
  9086:     80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
  9087:     81:             continue
  9088:     82:         atr_val = calc_atr(highs, lows, closes, atr_period)
  9089:     83:         row = dict(info)
  9090:     84:         row["atr"] = atr_val
  9091:     85:         candidates.append(row)
  9092:     86:         atrs.append(atr_val)
  9093:     87: 
  9094:     88:     if not candidates:
  9095:     89:         return []
  9096:     90: 
  9097:     91:     threshold = _quantile(atrs, atr_quantile)
  9098:     92:     selected = [row for row in candidates if row["atr"] >= threshold]
  9099:     93:     selected.sort(key=lambda r: r["atr"], reverse=True)
  9100:     94:     return selected[:top_n]
  9101:     95: 
  9102:     96: 
  9103:     97: __all__ = ["select_active_pairs"]
  9104:     98: 
  9105: 
  9106: 
  9107: ## scalper/selection/scanner.py (last modified: 2025-08-23 20:57:14)
  9108:      1: """Utilities for scanning tradable pairs on the exchange."""
  9109:      2: 
  9110:      3: from __future__ import annotations
  9111:      4: 
  9112:      5: from typing import Any, Dict, List
  9113:      6: 
  9114:      7: 
  9115:      8: def scan_pairs(
  9116:      9:     client: Any,
  9117:     10:     *,
  9118:     11:     volume_min: float = 5_000_000,
  9119:     12:     max_spread_bps: float = 5.0,
  9120:     13:     min_hourly_vol: float = 0.0,
  9121:     14:     top_n: int = 40,
  9122:     15: ) -> List[Dict[str, Any]]:
  9123:     16:     """Return pairs satisfying basic liquidity and volatility filters.
  9124:     17: 
  9125:     18:     Parameters
  9126:     19:     ----------
  9127:     20:     client: Any
  9128:     21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
  9129:     22:     volume_min: float, optional
  9130:     23:         Minimum 24h volume required to keep a pair.
  9131:     24:     max_spread_bps: float, optional
  9132:     25:         Maximum allowed bid/ask spread expressed in basis points.
  9133:     26:     min_hourly_vol: float, optional
  9134:     27:         Minimum volatility over the last hour expressed as ``(high - low) /
  9135:     28:         close``.  When set to ``0`` the filter is disabled.
  9136:     29:     top_n: int, optional
  9137:     30:         Limit the number of returned pairs.
  9138:     31:     """
  9139:     32: 
  9140:     33:     tick = client.get_ticker()
  9141:     34:     data = tick.get("data") if isinstance(tick, dict) else []
  9142:     35:     if not isinstance(data, list):
  9143:     36:         data = [data]
  9144:     37: 
  9145:     38:     eligible: List[Dict[str, Any]] = []
  9146:     39: 
  9147:     40:     for row in data:
  9148:     41:         sym = row.get("symbol")
  9149:     42:         if not sym:
  9150:     43:             continue
  9151:     44:         try:
  9152:     45:             vol = float(row.get("volume", 0))
  9153:     46:             bid = float(row.get("bidPrice", 0))
  9154:     47:             ask = float(row.get("askPrice", 0))
  9155:     48:         except (TypeError, ValueError):
  9156:     49:             continue
  9157:     50:         if vol < volume_min or bid <= 0 or ask <= 0:
  9158:     51:             continue
  9159:     52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
  9160:     53:         if spread_bps >= max_spread_bps:
  9161:     54:             continue
  9162:     55: 
  9163:     56:         if min_hourly_vol > 0:
  9164:     57:             k = client.get_kline(sym, interval="Min60")
  9165:     58:             kdata = k.get("data") if isinstance(k, dict) else {}
  9166:     59:             highs = kdata.get("high", [])
  9167:     60:             lows = kdata.get("low", [])
  9168:     61:             closes = kdata.get("close", [])
  9169:     62:             if not highs or not lows or not closes:
  9170:     63:                 continue
  9171:     64:             try:
  9172:     65:                 h = float(highs[-1])
  9173:     66:                 l = float(lows[-1])
  9174:     67:                 c = float(closes[-1])
  9175:     68:             except (TypeError, ValueError):
  9176:     69:                 continue
  9177:     70:             hourly_vol = (h - l) / c if c else 0.0
  9178:     71:             if hourly_vol < min_hourly_vol:
  9179:     72:                 continue
  9180:     73: 
  9181:     74:         eligible.append(row)
  9182:     75: 
  9183:     76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
  9184:     77:     return eligible[:top_n]
  9185:     78: 
  9186:     79: 
  9187:     80: __all__ = ["scan_pairs"]
  9188:     81: 
  9189: 
  9190: 
  9191: ## scalper/selfcheck.py (last modified: 2025-08-23 20:57:14)
  9192:      1: # scalper/selfcheck.py
  9193:      2: from __future__ import annotations
  9194:      3: import os, sys, importlib, traceback
  9195:      4: from pathlib import Path
  9196:      5: 
  9197:      6: NOTEBOOKS = Path("/notebooks")
  9198:      7: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
  9199:      8: 
  9200:      9: def _mask(val: str) -> str:
  9201:     10:     if not val: return ""
  9202:     11:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
  9203:     12: 
  9204:     13: def _try_import(modname: str):
  9205:     14:     try:
  9206:     15:         m = importlib.import_module(modname)
  9207:     16:         return True, m
  9208:     17:     except Exception:
  9209:     18:         return False, traceback.format_exc()
  9210:     19: 
  9211:     20: def preflight(verbose: bool = False) -> list[str]:
  9212:     21:     """
  9213:     22:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
  9214:     23:     Ne lève pas d'exception. N'écrit que de l'info lisible.
  9215:     24:     """
  9216:     25:     issues: list[str] = []
  9217:     26:     # s'assurer que le repo est bien dans sys.path
  9218:     27:     if str(REPO) not in sys.path:
  9219:     28:         sys.path.insert(0, str(REPO))
  9220:     29: 
  9221:     30:     print("=== SCALPER PREFLIGHT ===")
  9222:     31:     print(f"[i] Repo: {REPO}")
  9223:     32:     print(f"[i] Python: {sys.version.split()[0]}")
  9224:     33: 
  9225:     34:     # backtest API
  9226:     35:     ok, mod = _try_import("scalper.backtest")
  9227:     36:     if not ok:
  9228:     37:         print("[✗] Import scalper.backtest KO")
  9229:     38:         if verbose: print(mod)  # ici 'mod' contient la trace
  9230:     39:         issues.append("backtest import")
  9231:     40:     else:
  9232:     41:         has_single = hasattr(mod, "run_single")
  9233:     42:         has_multi  = hasattr(mod, "run_multi")
  9234:     43:         print(f"[✓] scalper.backtest: run_single={has_single} run_multi={has_multi}")
  9235:     44:         if not (has_single and has_multi):
  9236:     45:             issues.append("backtest API incomplète")
  9237:     46: 
  9238:     47:     # trade_utils
  9239:     48:     ok, mod = _try_import("scalper.trade_utils")
  9240:     49:     if not ok:
  9241:     50:         print("[✗] Import scalper.trade_utils KO")
  9242:     51:         if verbose: print(mod)
  9243:     52:         issues.append("trade_utils import")
  9244:     53:     else:
  9245:     54:         print(f"[✓] scalper.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
  9246:     55: 
  9247:     56:     # fees
  9248:     57:     ok, mod = _try_import("scalper.exchange.fees")
  9249:     58:     if not ok:
  9250:     59:         print("[✗] Import scalper.exchange.fees KO")
  9251:     60:         if verbose: print(mod)
  9252:     61:         issues.append("fees import")
  9253:     62:     else:
  9254:     63:         need = {"get_fee", "load_bitget_fees"}
  9255:     64:         miss = [n for n in need if not hasattr(mod, n)]
  9256:     65:         if miss: issues.append("fees API manquante: " + ",".join(miss))
  9257:     66:         print("[✓] scalper.exchange.fees OK")
  9258:     67: 
  9259:     68:     # notify/commands/backtest_telegram/orchestrator
  9260:     69:     for name, required in [
  9261:     70:         ("scalper.live.notify", ("build_notifier_and_stream",)),
  9262:     71:         ("scalper.live.commands", ("CommandHandler",)),
  9263:     72:         ("scalper.live.backtest_telegram", ("handle_backtest_command",)),
  9264:     73:         ("scalper.live.orchestrator", ("run_orchestrator", "Orchestrator")),
  9265:     74:     ]:
  9266:     75:         ok, mod = _try_import(name)
  9267:     76:         if not ok:
  9268:     77:             print(f"[✗] Import {name} KO")
  9269:     78:             if verbose: print(mod)
  9270:     79:             issues.append(f"{name} import")
  9271:     80:         else:
  9272:     81:             miss = [a for a in required if not hasattr(mod, a)]
  9273:     82:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
  9274:     83:             print(f"[✓] {name} OK")
  9275:     84: 
  9276:     85:     # ENV (masqué)
  9277:     86:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
  9278:     87:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
  9279:     88:     gu   = os.getenv("GIT_USER", "")
  9280:     89:     gt   = os.getenv("GIT_TOKEN", "")
  9281:     90:     print("\n-- ENV --")
  9282:     91:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
  9283:     92:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
  9284:     93:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
  9285:     94:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
  9286:     95: 
  9287:     96:     # Data
  9288:     97:     data_dir = (REPO / "data")
  9289:     98:     print("\n-- DATA --")
  9290:     99:     if data_dir.exists():
  9291:    100:         csvs = list(data_dir.glob("*.csv"))
  9292:    101:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
  9293:    102:     else:
  9294:    103:         print("  data/ absent (OK si loader API)")
  9295:    104: 
  9296:    105:     return issues
  9297:    106: 
  9298:    107: def preflight_or_die(verbose: bool = False) -> None:
  9299:    108:     issues = preflight(verbose=verbose)
  9300:    109:     if issues:
  9301:    110:         print("\n[✗] Préflight a détecté des problèmes :")
  9302:    111:         for it in issues: print("   -", it)
  9303:    112:         print("\nConseils :")
  9304:    113:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
  9305:    114:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
  9306:    115:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
  9307:    116:         raise SystemExit(1)
  9308:    117:     print("\n[✓] Préflight OK — démarrage du bot.")
  9309: 
  9310: ## scalper/services/__init__.py (last modified: 2025-08-23 20:57:14)
  9311: 
  9312: 
  9313: ## scalper/services/data_cache.py (last modified: 2025-08-23 20:57:14)
  9314:      1: # scalper/services/data_cache.py
  9315:      2: from __future__ import annotations
  9316:      3: 
  9317:      4: import asyncio
  9318:      5: import csv
  9319:      6: import os
  9320:      7: import time
  9321:      8: from typing import Iterable, List, Optional, Tuple, Dict
  9322:      9: 
  9323:     10: # ---------------------------------------------------------------------
  9324:     11: # Réglages via env (valeurs sûres par défaut)
  9325:     12: # ---------------------------------------------------------------------
  9326:     13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
  9327:     14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
  9328:     15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
  9329:     16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
  9330:     17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
  9331:     18: 
  9332:     19: os.makedirs(DATA_DIR, exist_ok=True)
  9333:     20: 
  9334:     21: 
  9335:     22: # ---------------------------------------------------------------------
  9336:     23: # Helpers
  9337:     24: # ---------------------------------------------------------------------
  9338:     25: def parse_timeframe_to_seconds(tf: str) -> int:
  9339:     26:     tf = tf.strip().lower()
  9340:     27:     unit = tf[-1]
  9341:     28:     try:
  9342:     29:         n = int(tf[:-1])
  9343:     30:     except Exception as e:
  9344:     31:         raise ValueError(f"timeframe invalide: {tf}") from e
  9345:     32:     if unit == "m":
  9346:     33:         return n * 60
  9347:     34:     if unit == "h":
  9348:     35:         return n * 3600
  9349:     36:     if unit == "d":
  9350:     37:         return n * 86400
  9351:     38:     raise ValueError(f"timeframe invalide: {tf}")
  9352:     39: 
  9353:     40: 
  9354:     41: def csv_path(symbol: str, timeframe: str) -> str:
  9355:     42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
  9356:     43: 
  9357:     44: 
  9358:     45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
  9359:     46:     rows: List[Tuple[int, float, float, float, float, float]] = []
  9360:     47:     if not os.path.exists(path):
  9361:     48:         return rows
  9362:     49:     with open(path, "r", newline="") as f:
  9363:     50:         r = csv.reader(f)
  9364:     51:         header = next(r, None)  # accepte avec ou sans header
  9365:     52:         for line in r:
  9366:     53:             if not line:
  9367:     54:                 continue
  9368:     55:             ts, o, h, l, c, v = line[:6]
  9369:     56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  9370:     57:     return rows
  9371:     58: 
  9372:     59: 
  9373:     60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
  9374:     61:     first = not os.path.exists(path)
  9375:     62:     os.makedirs(os.path.dirname(path), exist_ok=True)
  9376:     63:     with open(path, "a", newline="") as f:
  9377:     64:         w = csv.writer(f)
  9378:     65:         if first:
  9379:     66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
  9380:     67:         for row in data:
  9381:     68:             w.writerow(row)
  9382:     69: 
  9383:     70: 
  9384:     71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
  9385:     72:     return rows[-1][0] if rows else None
  9386:     73: 
  9387:     74: 
  9388:     75: # ---------------------------------------------------------------------
  9389:     76: # Fetch CCXT paginé
  9390:     77: # ---------------------------------------------------------------------
  9391:     78: async def ccxt_fetch_ohlcv_all(
  9392:     79:     exchange,
  9393:     80:     symbol: str,
  9394:     81:     timeframe: str,
  9395:     82:     since_ms: Optional[int],
  9396:     83:     limit: int = 1000,
  9397:     84: ) -> List[Tuple[int, float, float, float, float, float]]:
  9398:     85:     """
  9399:     86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
  9400:     87:     Retourne une liste triée/dédupliquée.
  9401:     88:     """
  9402:     89:     out: List[Tuple[int, float, float, float, float, float]] = []
  9403:     90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
  9404:     91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
  9405:     92: 
  9406:     93:     cursor = since_ms or (now_ms - 200 * tf_ms)
  9407:     94:     while True:
  9408:     95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
  9409:     96:         if not batch:
  9410:     97:             break
  9411:     98:         for ts, o, h, l, c, v in batch:
  9412:     99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
  9413:    100:         next_cursor = batch[-1][0] + tf_ms
  9414:    101:         if next_cursor <= cursor:
  9415:    102:             break
  9416:    103:         cursor = next_cursor
  9417:    104:         if cursor >= now_ms + (2 * tf_ms):
  9418:    105:             break
  9419:    106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
  9420:    107: 
  9421:    108:     out.sort(key=lambda x: x[0])
  9422:    109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
  9423:    110:     seen = set()
  9424:    111:     for row in out:
  9425:    112:         if row[0] in seen:
  9426:    113:             continue
  9427:    114:         seen.add(row[0])
  9428:    115:         dedup.append(row)
  9429:    116:     return dedup
  9430:    117: 
  9431:    118: 
  9432:    119: # ---------------------------------------------------------------------
  9433:    120: # Cache manager
  9434:    121: # ---------------------------------------------------------------------
  9435:    122: async def ensure_symbol_csv_cache(
  9436:    123:     exchange,
  9437:    124:     symbol: str,
  9438:    125:     timeframe: str,
  9439:    126:     min_rows: int = CSV_MIN_ROWS,
  9440:    127: ) -> str:
  9441:    128:     """
  9442:    129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
  9443:    130:     Crée/append si nécessaire. Retourne le chemin.
  9444:    131:     """
  9445:    132:     path = csv_path(symbol, timeframe)
  9446:    133:     rows = read_csv_ohlcv(path)
  9447:    134:     tf_sec = parse_timeframe_to_seconds(timeframe)
  9448:    135:     tf_ms = tf_sec * 1000
  9449:    136:     now_ms = int(time.time() * 1000)
  9450:    137: 
  9451:    138:     # âge max
  9452:    139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
  9453:    140: 
  9454:    141:     need_full = False
  9455:    142:     need_append = False
  9456:    143: 
  9457:    144:     if not rows:
  9458:    145:         need_full = True
  9459:    146:     else:
  9460:    147:         last = last_ts(rows) or 0
  9461:    148:         age_sec = max(0, (now_ms - last) // 1000)
  9462:    149:         if age_sec > max_age or len(rows) < min_rows:
  9463:    150:             need_append = True
  9464:    151: 
  9465:    152:     if need_full:
  9466:    153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
  9467:    154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  9468:    155:         if len(fresh) < min_rows:
  9469:    156:             since = now_ms - (tf_ms * 5000)
  9470:    157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  9471:    158:         if os.path.exists(path):
  9472:    159:             os.remove(path)
  9473:    160:         write_csv_ohlcv(path, fresh)
  9474:    161:         return path
  9475:    162: 
  9476:    163:     if need_append:
  9477:    164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
  9478:    165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
  9479:    166:         if fresh:
  9480:    167:             write_csv_ohlcv(path, fresh)
  9481:    168: 
  9482:    169:     return path
  9483:    170: 
  9484:    171: 
  9485:    172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
  9486:    173:     """
  9487:    174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
  9488:    175:     Retourne {symbol: path}.
  9489:    176:     """
  9490:    177:     sem = asyncio.Semaphore(PREFETCH_CONC)
  9491:    178:     result: Dict[str, str] = {}
  9492:    179: 
  9493:    180:     async def _one(sym: str):
  9494:    181:         async with sem:
  9495:    182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
  9496:    183:             result[sym] = p
  9497:    184: 
  9498:    185:     await asyncio.gather(*[_one(s) for s in symbols])
  9499:    186:     return result
  9500: 
  9501: ## scalper/services/order_service.py (last modified: 2025-08-23 20:57:14)
  9502:      1: from __future__ import annotations
  9503:      2: from dataclasses import dataclass
  9504:      3: from typing import Any, Dict, Optional, Protocol
  9505:      4: from scalper.trade_utils import extract_available_balance
  9506:      5: 
  9507:      6: 
  9508:      7: @dataclass
  9509:      8: class OrderCaps:
  9510:      9:     min_trade_usdt: float = 5.0
  9511:     10:     leverage: float = 1.0
  9512:     11: 
  9513:     12: 
  9514:     13: @dataclass
  9515:     14: class OrderRequest:
  9516:     15:     symbol: str
  9517:     16:     side: str
  9518:     17:     price: float
  9519:     18:     sl: float
  9520:     19:     tp: Optional[float]
  9521:     20:     risk_pct: float
  9522:     21: 
  9523:     22: 
  9524:     23: @dataclass
  9525:     24: class OrderResult:
  9526:     25:     accepted: bool
  9527:     26:     reason: str = ""
  9528:     27:     payload: Dict[str, Any] = None
  9529:     28:     order_id: Optional[str] = None
  9530:     29:     status: Optional[str] = None
  9531:     30:     avg_price: Optional[float] = None
  9532:     31:     filled_qty: Optional[float] = None
  9533:     32: 
  9534:     33: 
  9535:     34: class Exchange(Protocol):
  9536:     35:     def get_assets(self) -> Dict[str, Any]: ...
  9537:     36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
  9538:     37:     def place_order(
  9539:     38:         self,
  9540:     39:         symbol: str,
  9541:     40:         side: str,
  9542:     41:         quantity: float,
  9543:     42:         order_type: str,
  9544:     43:         price: Optional[float] = None,
  9545:     44:         stop_loss: Optional[float] = None,
  9546:     45:         take_profit: Optional[float] = None,
  9547:     46:     ) -> Dict[str, Any]: ...
  9548:     47: 
  9549:     48: 
  9550:     49: class OrderService:
  9551:     50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
  9552:     51:         self.exchange = exchange
  9553:     52:         self.caps = caps
  9554:     53: 
  9555:     54:     @staticmethod
  9556:     55:     def _abs(x: float) -> float:
  9557:     56:         return -x if x < 0 else x
  9558:     57: 
  9559:     58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
  9560:     59:         dist = self._abs(price - sl)
  9561:     60:         if dist <= 0:
  9562:     61:             return 0.0
  9563:     62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
  9564:     63:         return 0.0 if price <= 0 else (risk_usdt / dist)
  9565:     64: 
  9566:     65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
  9567:     66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
  9568:     67:         if qty <= 0:
  9569:     68:             return OrderResult(False, "invalid_size")
  9570:     69:         notional = qty * req.price
  9571:     70:         if notional < self.caps.min_trade_usdt:
  9572:     71:             return OrderResult(False, "under_min_notional")
  9573:     72:         assets = self.exchange.get_assets()
  9574:     73:         available = extract_available_balance(assets)
  9575:     74:         required_margin = notional / max(1.0, self.caps.leverage)
  9576:     75:         if available < required_margin:
  9577:     76:             return OrderResult(False, "insufficient_margin")
  9578:     77:         side = "BUY" if req.side == "long" else "SELL"
  9579:     78:         out = self.exchange.place_order(
  9580:     79:             symbol=req.symbol, side=side, quantity=qty,
  9581:     80:             order_type="limit", price=req.price,
  9582:     81:             stop_loss=req.sl, take_profit=req.tp
  9583:     82:         )
  9584:     83:         # extraire infos utiles
  9585:     84:         oid = None; status = None; avg = None; filled = None
  9586:     85:         try:
  9587:     86:             data = out.get("data") if isinstance(out, dict) else out
  9588:     87:             if isinstance(data, dict):
  9589:     88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
  9590:     89:                 status = (data.get("status") or data.get("state") or "new").lower()
  9591:     90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
  9592:     91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
  9593:     92:         except Exception:
  9594:     93:             pass
  9595:     94:         return OrderResult(True, "", out, oid, status, avg, filled)
  9596: 
  9597: 
  9598: ## scalper/services/utils.py (last modified: 2025-08-23 20:57:14)
  9599:      1: # scalper/services/utils.py
  9600:      2: from __future__ import annotations
  9601:      3: import asyncio
  9602:      4: from typing import Callable, Any
  9603:      5: 
  9604:      6: 
  9605:      7: class NullNotifier:
  9606:      8:     async def send(self, _msg: str) -> None:
  9607:      9:         return
  9608:     10: 
  9609:     11: 
  9610:     12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
  9611:     13:     if notifier is None:
  9612:     14:         notifier = NullNotifier()
  9613:     15:     try:
  9614:     16:         while running_getter():
  9615:     17:             await notifier.send("heartbeat alive")
  9616:     18:             await asyncio.sleep(period)
  9617:     19:     except asyncio.CancelledError:
  9618:     20:         pass
  9619:     21: 
  9620:     22: 
  9621:     23: async def log_stats_task(
  9622:     24:     notifier: Any,
  9623:     25:     ticks_getter: Callable[[], int],
  9624:     26:     symbols_getter: Callable[[], list[str]],
  9625:     27:     period: float = 30.0,
  9626:     28: ) -> None:
  9627:     29:     if notifier is None:
  9628:     30:         notifier = NullNotifier()
  9629:     31:     last = 0
  9630:     32:     try:
  9631:     33:         while True:
  9632:     34:             total = int(ticks_getter() or 0)
  9633:     35:             delta = total - last
  9634:     36:             last = total
  9635:     37:             syms = symbols_getter() or []
  9636:     38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
  9637:     39:             print(msg)
  9638:     40:             await notifier.send(msg)
  9639:     41:             await asyncio.sleep(period)
  9640:     42:     except asyncio.CancelledError:
  9641:     43:         pass
  9642: 
  9643: ## scalper/signals/__init__.py (last modified: 2025-08-23 20:57:14)
  9644:      1: # scalper/signals/__init__.py
  9645:      2: from .factory import load_signal, available_strategies
  9646:      3: 
  9647:      4: __all__ = ["load_signal", "available_strategies"]
  9648: 
  9649: ## scalper/signals/current.py (last modified: 2025-08-23 20:57:14)
  9650:      1: # scalper/signals/current.py
  9651:      2: from __future__ import annotations
  9652:      3: 
  9653:      4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
  9654:      5: from scalper.strategy import generate_signal as _generate_signal
  9655:      6: 
  9656:      7: def generate_signal(**kwargs):
  9657:      8:     """
  9658:      9:     Expose la même signature que scalper.strategy.generate_signal.
  9659:     10:     Sert d’adaptateur pour la factory.
  9660:     11:     """
  9661:     12:     return _generate_signal(**kwargs)
  9662: 
  9663: ## scalper/signals/factory.py (last modified: 2025-08-23 20:57:14)
  9664:      1: # scalper/signals/factory.py
  9665:      2: from __future__ import annotations
  9666:      3: 
  9667:      4: import importlib
  9668:      5: import importlib.util
  9669:      6: from typing import Callable, Dict, Optional
  9670:      7: 
  9671:      8: SignalFn = Callable[..., object]
  9672:      9: 
  9673:     10: # Mapping symbolique -> module (tu peux en ajouter librement)
  9674:     11: _REGISTRY: Dict[str, str] = {
  9675:     12:     # Stratégie "actuelle" (renvoie scalper.strategy.generate_signal)
  9676:     13:     "current": "scalper.signals.current",
  9677:     14: 
  9678:     15:     # Exemples de plugins (crée les fichiers si tu veux les utiliser)
  9679:     16:     "ema_cross": "scalper.signals.ema_cross",
  9680:     17:     "vwap_break": "scalper.signals.vwap_break",
  9681:     18: }
  9682:     19: 
  9683:     20: def _module_exists(modname: str) -> bool:
  9684:     21:     return importlib.util.find_spec(modname) is not None
  9685:     22: 
  9686:     23: def load_signal(name: str, *, default: str = "current") -> SignalFn:
  9687:     24:     """
  9688:     25:     Charge et retourne une fonction `generate_signal` pour la stratégie `name`.
  9689:     26:     Si le module n'existe pas, on retombe sur `default` (courant: 'current').
  9690:     27:     """
  9691:     28:     target = _REGISTRY.get(name, _REGISTRY.get(default, "scalper.signals.current"))
  9692:     29:     if not _module_exists(target):
  9693:     30:         # fallback direct sur 'current'
  9694:     31:         target = _REGISTRY.get(default, "scalper.signals.current")
  9695:     32: 
  9696:     33:     mod = importlib.import_module(target)
  9697:     34:     fn = getattr(mod, "generate_signal", None)
  9698:     35:     if not callable(fn):
  9699:     36:         # dernier filet de sécurité : stratégie live directe
  9700:     37:         from scalper.strategy import generate_signal as live_generate
  9701:     38:         return live_generate
  9702:     39:     return fn
  9703:     40: 
  9704:     41: def available_strategies() -> Dict[str, str]:
  9705:     42:     """
  9706:     43:     Retourne {nom: 'ok'/'missing'} pour afficher ce qui est disponible.
  9707:     44:     """
  9708:     45:     out: Dict[str, str] = {}
  9709:     46:     for name, mod in _REGISTRY.items():
  9710:     47:         out[name] = "ok" if _module_exists(mod) else "missing"
  9711:     48:     return out
  9712: 
  9713: ## scalper/signals/generator.py (last modified: 2025-08-23 20:57:14)
  9714:      1: from __future__ import annotations
  9715:      2: 
  9716:      3: from typing import Any, Dict, List, Optional
  9717:      4: 
  9718:      5: import pandas as pd
  9719:      6: 
  9720:      7: from data.indicators import compute_all
  9721:      8: 
  9722:      9: __all__ = ["generate_signal"]
  9723:     10: 
  9724:     11: 
  9725:     12: def _quality_from_score(score: float) -> str:
  9726:     13:     if score >= 0.8:
  9727:     14:         return "A"
  9728:     15:     if score >= 0.5:
  9729:     16:         return "B"
  9730:     17:     return "C"
  9731:     18: 
  9732:     19: 
  9733:     20: def generate_signal(
  9734:     21:     df: pd.DataFrame,
  9735:     22:     *,
  9736:     23:     trend_tf: Optional[pd.DataFrame] = None,
  9737:     24:     confirm_tf: Optional[pd.DataFrame] = None,
  9738:     25:     atr_mult: float = 1.0,
  9739:     26:     trailing: bool = False,
  9740:     27:     **_: Any,
  9741:     28: ) -> Optional[Dict[str, Any]]:
  9742:     29:     """Generate a trading signal with confluence scoring.
  9743:     30: 
  9744:     31:     Parameters
  9745:     32:     ----------
  9746:     33:     df: pd.DataFrame
  9747:     34:         Primary timeframe OHLCV data.
  9748:     35:     trend_tf: pd.DataFrame, optional
  9749:     36:         Higher timeframe used for trend filtering.
  9750:     37:     confirm_tf: pd.DataFrame, optional
  9751:     38:         Lower timeframe used for confirmation.
  9752:     39:     atr_mult: float, optional
  9753:     40:         Multiplier applied to ATR for stop/target calculation.
  9754:     41:     trailing: bool, optional
  9755:     42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
  9756:     43: 
  9757:     44:     Returns
  9758:     45:     -------
  9759:     46:     dict | None
  9760:     47:         Dictionary describing the signal or ``None`` if no trade setup exists.
  9761:     48:     """
  9762:     49: 
  9763:     50:     if df is None or len(df) < 2:
  9764:     51:         return None
  9765:     52: 
  9766:     53:     df = compute_all(df)
  9767:     54:     last = df.iloc[-1]
  9768:     55: 
  9769:     56:     conditions: List[bool] = []
  9770:     57:     reasons: List[str] = []
  9771:     58:     direction: Optional[str] = None
  9772:     59: 
  9773:     60:     # --- Basic trend via EMAs ----------------------------------------------
  9774:     61:     if last["close"] > last["ema20"] > last["ema50"]:
  9775:     62:         direction = "long"
  9776:     63:         reasons.append("price_above_ema")
  9777:     64:         conditions.append(True)
  9778:     65:     elif last["close"] < last["ema20"] < last["ema50"]:
  9779:     66:         direction = "short"
  9780:     67:         reasons.append("price_below_ema")
  9781:     68:         conditions.append(True)
  9782:     69:     else:
  9783:     70:         conditions.append(False)
  9784:     71:         return None
  9785:     72: 
  9786:     73:     # --- RSI ---------------------------------------------------------------
  9787:     74:     if direction == "long":
  9788:     75:         cond = last["rsi"] > 55
  9789:     76:         if cond:
  9790:     77:             reasons.append("rsi_bullish")
  9791:     78:         conditions.append(cond)
  9792:     79:     else:
  9793:     80:         cond = last["rsi"] < 45
  9794:     81:         if cond:
  9795:     82:             reasons.append("rsi_bearish")
  9796:     83:         conditions.append(cond)
  9797:     84: 
  9798:     85:     # --- MACD --------------------------------------------------------------
  9799:     86:     if direction == "long":
  9800:     87:         cond = last["macd"] > last["macd_signal"]
  9801:     88:         if cond:
  9802:     89:             reasons.append("macd_bullish")
  9803:     90:         conditions.append(cond)
  9804:     91:     else:
  9805:     92:         cond = last["macd"] < last["macd_signal"]
  9806:     93:         if cond:
  9807:     94:             reasons.append("macd_bearish")
  9808:     95:         conditions.append(cond)
  9809:     96: 
  9810:     97:     # --- OBV momentum ------------------------------------------------------
  9811:     98:     if len(df) >= 2:
  9812:     99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
  9813:    100:         if obv_up:
  9814:    101:             reasons.append("obv_trending")
  9815:    102:         conditions.append(obv_up)
  9816:    103: 
  9817:    104:     # --- Trend timeframe filter -------------------------------------------
  9818:    105:     if trend_tf is not None and len(trend_tf) >= 2:
  9819:    106:         tdf = compute_all(trend_tf)
  9820:    107:         ema50 = tdf["ema50"]
  9821:    108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
  9822:    109:         if direction == "long":
  9823:    110:             cond = slope > 0
  9824:    111:             if cond:
  9825:    112:                 reasons.append("trend_up")
  9826:    113:             conditions.append(cond)
  9827:    114:         else:
  9828:    115:             cond = slope < 0
  9829:    116:             if cond:
  9830:    117:                 reasons.append("trend_down")
  9831:    118:             conditions.append(cond)
  9832:    119: 
  9833:    120:     # --- Confirmation timeframe filter ------------------------------------
  9834:    121:     if confirm_tf is not None and len(confirm_tf) > 0:
  9835:    122:         cdf = compute_all(confirm_tf)
  9836:    123:         rsi = cdf["rsi"].iloc[-1]
  9837:    124:         if direction == "long":
  9838:    125:             cond = rsi > 50
  9839:    126:             if cond:
  9840:    127:                 reasons.append("confirm_rsi_bullish")
  9841:    128:             conditions.append(cond)
  9842:    129:         else:
  9843:    130:             cond = rsi < 50
  9844:    131:             if cond:
  9845:    132:                 reasons.append("confirm_rsi_bearish")
  9846:    133:             conditions.append(cond)
  9847:    134: 
  9848:    135:     score = (
  9849:    136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
  9850:    137:     )
  9851:    138:     quality = _quality_from_score(score)
  9852:    139: 
  9853:    140:     atr = last.get("atr")
  9854:    141:     if pd.isna(atr) or atr == 0:
  9855:    142:         return None
  9856:    143: 
  9857:    144:     entry = float(last["close"])
  9858:    145:     if direction == "long":
  9859:    146:         sl = entry - atr * atr_mult
  9860:    147:         tp = entry + atr * atr_mult * 2
  9861:    148:     else:
  9862:    149:         sl = entry + atr * atr_mult
  9863:    150:         tp = entry - atr * atr_mult * 2
  9864:    151: 
  9865:    152:     result: Dict[str, Any] = {
  9866:    153:         "direction": direction,
  9867:    154:         "entry": entry,
  9868:    155:         "sl": sl,
  9869:    156:         "tp": tp,
  9870:    157:         "score": round(score, 3),
  9871:    158:         "reasons": reasons,
  9872:    159:         "quality": quality,
  9873:    160:     }
  9874:    161: 
  9875:    162:     if trailing:
  9876:    163:         result["trail"] = atr * atr_mult
  9877:    164: 
  9878:    165:     return result
  9879: 
  9880: 
  9881: ## scalper/strategy.py (last modified: 2025-08-23 20:57:14)
  9882:      1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
  9883:      2: 
  9884:      3: This module implements a minimal but functional version of the strategy
  9885:      4: outlined in the project specification.  The focus is on pure Python
  9886:      5: implementations so the logic can easily be unit tested without requiring
  9887:      6: external services or heavy third‑party dependencies.
  9888:      7: 
  9889:      8: The strategy is deliberately stateless; functions operate on passed data and
  9890:      9: return simple data structures.  This makes it easy to plug the logic into
  9891:     10: real‑time trading loops or backtest engines.
  9892:     11: """
  9893:     12: 
  9894:     13: from __future__ import annotations
  9895:     14: 
  9896:     15: from dataclasses import dataclass
  9897:     16: from typing import Sequence, List, Dict, Optional, Tuple, Any
  9898:     17: 
  9899:     18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
  9900:     19: from .risk import calc_position_size
  9901:     20: 
  9902:     21: # ---------------------------------------------------------------------------
  9903:     22: # Helpers
  9904:     23: # ---------------------------------------------------------------------------
  9905:     24: 
  9906:     25: def ema(series: Sequence[float], window: int) -> List[float]:
  9907:     26:     """Return the exponential moving average of *series*.
  9908:     27: 
  9909:     28:     The first value is the raw input to remain consistent with most trading
  9910:     29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
  9911:     30:     returned unchanged.
  9912:     31:     """
  9913:     32: 
  9914:     33:     if window <= 1 or not series:
  9915:     34:         return list(series)
  9916:     35:     k = 2.0 / (window + 1.0)
  9917:     36:     out: List[float] = [float(series[0])]
  9918:     37:     prev = out[0]
  9919:     38:     for x in series[1:]:
  9920:     39:         prev = float(x) * k + prev * (1.0 - k)
  9921:     40:         out.append(prev)
  9922:     41:     return out
  9923:     42: 
  9924:     43: def vwap(highs: Sequence[float], lows: Sequence[float],
  9925:     44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
  9926:     45:     """Compute the volume weighted average price (VWAP).
  9927:     46: 
  9928:     47:     Parameters
  9929:     48:     ----------
  9930:     49:     highs, lows, closes, volumes: Sequence[float]
  9931:     50:         Matching sequences for the period considered.
  9932:     51:     """
  9933:     52: 
  9934:     53:     tp_vol = 0.0
  9935:     54:     vol_sum = 0.0
  9936:     55:     for h, low, c, v in zip(highs, lows, closes, volumes):
  9937:     56:         tp = (h + low + c) / 3.0
  9938:     57:         tp_vol += tp * v
  9939:     58:         vol_sum += v
  9940:     59:     return tp_vol / vol_sum if vol_sum else 0.0
  9941:     60: 
  9942:     61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
  9943:     62:     """Return the On Balance Volume (OBV) series."""
  9944:     63: 
  9945:     64:     if not closes:
  9946:     65:         return []
  9947:     66:     out: List[float] = [0.0]
  9948:     67:     for i in range(1, len(closes)):
  9949:     68:         if closes[i] > closes[i - 1]:
  9950:     69:             out.append(out[-1] + volumes[i])
  9951:     70:         elif closes[i] < closes[i - 1]:
  9952:     71:             out.append(out[-1] - volumes[i])
  9953:     72:         else:
  9954:     73:             out.append(out[-1])
  9955:     74:     return out
  9956:     75: 
  9957:     76: 
  9958:     77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
  9959:     78:     """Detect a crossing between two series.
  9960:     79: 
  9961:     80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
  9962:     81:     ``0`` otherwise.
  9963:     82:     """
  9964:     83: 
  9965:     84:     if prev_fast <= prev_slow and last_fast > last_slow:
  9966:     85:         return 1
  9967:     86:     if prev_fast >= prev_slow and last_fast < last_slow:
  9968:     87:         return -1
  9969:     88:     return 0
  9970:     89: 
  9971:     90: 
  9972:     91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
  9973:     92:     """Compute order book imbalance.
  9974:     93: 
  9975:     94:     The value is normalised between ``-1`` and ``1`` where positive numbers
  9976:     95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
  9977:     96:     """
  9978:     97: 
  9979:     98:     total = bid_vol + ask_vol
  9980:     99:     return (bid_vol - ask_vol) / total if total else 0.0
  9981:    100: 
  9982:    101: 
  9983:    102: def swing_levels(
  9984:    103:     highs: Sequence[float], lows: Sequence[float], lookback: int
  9985:    104: ) -> Tuple[float, float]:
  9986:    105:     """Return the most recent swing high and swing low.
  9987:    106: 
  9988:    107:     ``lookback`` defines how many completed candles are inspected.  The current
  9989:    108:     candle is excluded to avoid look‑ahead bias.
  9990:    109:     """
  9991:    110: 
  9992:    111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
  9993:    112:         return highs[-1], lows[-1]
  9994:    113:     high = max(highs[-lookback - 1 : -1])
  9995:    114:     low = min(lows[-lookback - 1 : -1])
  9996:    115:     return high, low
  9997:    116: 
  9998:    117: # ---------------------------------------------------------------------------
  9999:    118: # Pair selection
 10000:    119: # ---------------------------------------------------------------------------
 10001:    120: 
 10002:    121: # The first and second level pair selection helpers now live in
 10003:    122: # :mod:`scalper.selection`.  They are re-exported here for backward compatibility
 10004:    123: # and to keep the public API unchanged.
 10005:    124: from .selection.scanner import scan_pairs  # noqa: E402
 10006:    125: from .selection.momentum import select_active_pairs  # noqa: E402
 10007:    126: 
 10008:    127: # ---------------------------------------------------------------------------
 10009:    128: # Signal generation
 10010:    129: # ---------------------------------------------------------------------------
 10011:    130: 
 10012:    131: @dataclass
 10013:    132: class Signal:
 10014:    133:     """Trading signal with risk parameters."""
 10015:    134: 
 10016:    135:     symbol: str
 10017:    136:     side: int  # 1 for long, -1 for short
 10018:    137:     entry: float
 10019:    138:     sl: float
 10020:    139:     tp1: float
 10021:    140:     tp2: float
 10022:    141:     qty: float = 0.0
 10023:    142:     score: Optional[float] = None
 10024:    143:     quality: Optional[float] = None
 10025:    144:     reasons: Optional[List[str]] = None
 10026:    145: 
 10027:    146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
 10028:    147:         if isinstance(self.side, str):
 10029:    148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
 10030:    149: 
 10031:    150:     @property
 10032:    151:     def price(self) -> float:
 10033:    152:         return self.entry
 10034:    153: 
 10035:    154: 
 10036:    155: def _generate_signal(
 10037:    156:     symbol: str,
 10038:    157:     ohlcv: Dict[str, Sequence[float]],
 10039:    158:     *,
 10040:    159:     equity: float,
 10041:    160:     risk_pct: float,
 10042:    161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
 10043:    162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
 10044:    163:     order_book: Optional[Dict[str, float]] = None,
 10045:    164:     tick_ratio_buy: Optional[float] = None,
 10046:    165:     atr_disable_pct: float = 0.2,
 10047:    166:     atr_reduce_pct: float = 2.0,
 10048:    167:     swing_lookback: int = 5,
 10049:    168:     macd_fast: int = 12,
 10050:    169:     macd_slow: int = 26,
 10051:    170:     macd_signal: int = 9,
 10052:    171:     trend_ema_period: int = 200,
 10053:    172: ) -> Optional[Signal]:
 10054:    173:     """Return a trading :class:`Signal` if conditions are met.
 10055:    174: 
 10056:    175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
 10057:    176:     sequences ordered from oldest to newest.  The function checks the following
 10058:    177:     rules:
 10059:    178: 
 10060:    179:     * price positioned relative to VWAP and EMA20/EMA50 trend
 10061:    180:     * RSI(14) crossing key levels (40/60)
 10062:    181:     * OBV rising or high short‑term volume
 10063:    182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
 10064:    183:     * Micro‑structure breakout of last swing high/low
 10065:    184:     * MACD trend filter
 10066:    185:     * Long‑term trend via configurable EMA filter
 10067:    186:     * Order book imbalance and tape filters
 10068:    187:     * Dynamic ATR‑based stop‑loss and take‑profit
 10069:    188:     * Position sizing via ``calc_position_size``
 10070:    189:     """
 10071:    190: 
 10072:    191:     closes = [float(x) for x in ohlcv.get("close", [])]
 10073:    192:     highs = [float(x) for x in ohlcv.get("high", [])]
 10074:    193:     lows = [float(x) for x in ohlcv.get("low", [])]
 10075:    194:     vols = [float(x) for x in ohlcv.get("volume", [])]
 10076:    195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
 10077:    196:         return None
 10078:    197: 
 10079:    198:     price = closes[-1]
 10080:    199:     ema20 = ema(closes, 20)
 10081:    200:     ema50 = ema(closes, 50)
 10082:    201:     ema_trend = ema(closes, trend_ema_period)
 10083:    202:     v = vwap(highs, lows, closes, vols)
 10084:    203:     obv_series = obv(closes, vols)
 10085:    204:     obv_rising = obv_series[-1] > obv_series[-2]
 10086:    205:     vol_last3 = sum(vols[-3:])
 10087:    206:     vol_ma20 = sum(vols[-20:]) / 20.0
 10088:    207:     vol_rising = vol_last3 > vol_ma20
 10089:    208: 
 10090:    209:     macd_val, macd_sig, _ = calc_macd(
 10091:    210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
 10092:    211:     )
 10093:    212: 
 10094:    213:     # Multi timeframe filters -------------------------------------------------
 10095:    214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
 10096:    215:     if ohlcv_1h:
 10097:    216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
 10098:    217:         if len(h_closes) >= 52:
 10099:    218:             h_ema50 = ema(h_closes, 50)
 10100:    219:             if len(h_ema50) >= 2:
 10101:    220:                 slope = h_ema50[-1] - h_ema50[-2]
 10102:    221:                 if slope > 0:
 10103:    222:                     trend_dir = 1
 10104:    223:                 elif slope < 0:
 10105:    224:                     trend_dir = -1
 10106:    225: 
 10107:    226:     rsi_15 = None
 10108:    227:     if ohlcv_15m:
 10109:    228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
 10110:    229:         if len(m_closes) >= 15:
 10111:    230:             rsi_15 = calc_rsi(m_closes, 14)
 10112:    231: 
 10113:    232:     # RSI crossing logic (5m)
 10114:    233:     rsi_curr = calc_rsi(closes[-15:], 14)
 10115:    234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
 10116:    235: 
 10117:    236:     atr = calc_atr(highs, lows, closes, 14)
 10118:    237:     atr_pct = atr / price * 100.0 if price else 0.0
 10119:    238:     if atr_pct < atr_disable_pct:
 10120:    239:         return None
 10121:    240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
 10122:    241: 
 10123:    242:     sl_dist = 0.5 * atr
 10124:    243:     tp1_dist = 1.0 * atr
 10125:    244:     tp2_dist = 1.5 * atr
 10126:    245: 
 10127:    246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
 10128:    247: 
 10129:    248:     obi_ok_long = obi_ok_short = True
 10130:    249:     if order_book is not None:
 10131:    250:         bid = float(order_book.get("bid_vol_aggreg", 0))
 10132:    251:         ask = float(order_book.get("ask_vol_aggreg", 0))
 10133:    252:         obi = order_book_imbalance(bid, ask)
 10134:    253:         obi_ok_long = obi > 0.1
 10135:    254:         obi_ok_short = obi < -0.1
 10136:    255: 
 10137:    256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
 10138:    257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
 10139:    258: 
 10140:    259:     def _size(dist: float) -> float:
 10141:    260:         return calc_position_size(equity, risk_pct, dist) * size_mult
 10142:    261:     weights = {
 10143:    262:         "ema": 15.0,
 10144:    263:         "macd": 15.0,
 10145:    264:         "vwap": 15.0,
 10146:    265:         "rsi": 15.0,
 10147:    266:         "obv": 10.0,
 10148:    267:         "swing": 10.0,
 10149:    268:         "atr": 20.0,
 10150:    269:     }
 10151:    270: 
 10152:    271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
 10153:    272: 
 10154:    273:     long_score = atr_score
 10155:    274:     long_reasons: List[str] = []
 10156:    275:     if price > v:
 10157:    276:         long_score += weights["vwap"]
 10158:    277:         long_reasons.append("vwap")
 10159:    278:     if ema20[-1] > ema50[-1]:
 10160:    279:         long_score += weights["ema"]
 10161:    280:         long_reasons.append("ema")
 10162:    281:     if rsi_prev <= 40 < rsi_curr:
 10163:    282:         long_score += weights["rsi"]
 10164:    283:         long_reasons.append("rsi")
 10165:    284:     if macd_val > macd_sig:
 10166:    285:         long_score += weights["macd"]
 10167:    286:         long_reasons.append("macd")
 10168:    287:     if obv_rising or vol_rising:
 10169:    288:         long_score += weights["obv"]
 10170:    289:         long_reasons.append("obv")
 10171:    290:     if price > swing_high:
 10172:    291:         long_score += weights["swing"]
 10173:    292:         long_reasons.append("swing")
 10174:    293: 
 10175:    294:     short_score = atr_score
 10176:    295:     short_reasons: List[str] = []
 10177:    296:     if price < v:
 10178:    297:         short_score += weights["vwap"]
 10179:    298:         short_reasons.append("vwap")
 10180:    299:     if ema20[-1] < ema50[-1]:
 10181:    300:         short_score += weights["ema"]
 10182:    301:         short_reasons.append("ema")
 10183:    302:     if rsi_prev >= 60 > rsi_curr:
 10184:    303:         short_score += weights["rsi"]
 10185:    304:         short_reasons.append("rsi")
 10186:    305:     if macd_val < macd_sig:
 10187:    306:         short_score += weights["macd"]
 10188:    307:         short_reasons.append("macd")
 10189:    308:     if obv_series[-1] < obv_series[-2] or vol_rising:
 10190:    309:         short_score += weights["obv"]
 10191:    310:         short_reasons.append("obv")
 10192:    311:     if price < swing_low:
 10193:    312:         short_score += weights["swing"]
 10194:    313:         short_reasons.append("swing")
 10195:    314: 
 10196:    315:     side: Optional[str] = None
 10197:    316:     score: float = 0.0
 10198:    317:     reasons: List[str] = []
 10199:    318:     if (
 10200:    319:         long_score >= short_score
 10201:    320:         and long_score > 0
 10202:    321:         and macd_val > macd_sig
 10203:    322:         and obi_ok_long
 10204:    323:         and tick_ok_long
 10205:    324:         and trend_dir >= 0
 10206:    325:         and price > ema_trend[-1]
 10207:    326:     ):
 10208:    327:         side = "long"
 10209:    328:         score = long_score
 10210:    329:         reasons = long_reasons
 10211:    330:         sl = price - sl_dist
 10212:    331:         tp1 = price + tp1_dist
 10213:    332:         tp2 = price + tp2_dist
 10214:    333:     elif (
 10215:    334:         short_score > long_score
 10216:    335:         and short_score > 0
 10217:    336:         and macd_val < macd_sig
 10218:    337:         and obi_ok_short
 10219:    338:         and tick_ok_short
 10220:    339:         and trend_dir <= 0
 10221:    340:         and price < ema_trend[-1]
 10222:    341:     ):
 10223:    342:         side = "short"
 10224:    343:         score = short_score
 10225:    344:         reasons = short_reasons
 10226:    345:         sl = price + sl_dist
 10227:    346:         tp1 = price - tp1_dist
 10228:    347:         tp2 = price - tp2_dist
 10229:    348:     else:
 10230:    349:         return None
 10231:    350: 
 10232:    351:     qty = _size(sl_dist)
 10233:    352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
 10234:    353: 
 10235:    354: 
 10236:    355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
 10237:    356:     if "config" in kwargs:
 10238:    357:         config = kwargs.pop("config")
 10239:    358:         symbol = kwargs.pop("symbol", None)
 10240:    359:         ohlcv = kwargs.pop("ohlcv", None)
 10241:    360:         if ohlcv is None:
 10242:    361:             raise TypeError("ohlcv argument required")
 10243:    362:         return _generate_signal(
 10244:    363:             symbol or ohlcv.get("symbol", ""),
 10245:    364:             ohlcv,
 10246:    365:             equity=kwargs.pop("equity", 0.0),
 10247:    366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
 10248:    367:             **kwargs,
 10249:    368:         )
 10250:    369:     return _generate_signal(*args, **kwargs)
 10251:    370: 
 10252:    371: # ---------------------------------------------------------------------------
 10253:    372: # Backtesting utilities
 10254:    373: # ---------------------------------------------------------------------------
 10255:    374: 
 10256:    375: def max_drawdown(equity_curve: Sequence[float]) -> float:
 10257:    376:     peak = equity_curve[0]
 10258:    377:     mdd = 0.0
 10259:    378:     for x in equity_curve:
 10260:    379:         if x > peak:
 10261:    380:             peak = x
 10262:    381:         dd = (peak - x) / peak * 100.0
 10263:    382:         if dd > mdd:
 10264:    383:             mdd = dd
 10265:    384:     return mdd
 10266:    385: 
 10267:    386: def backtest(
 10268:    387:     trades: Sequence[Dict[str, Any]],
 10269:    388:     *,
 10270:    389:     equity_start: float = 1_000.0,
 10271:    390:     fee_rate: float = 0.0,
 10272:    391: ) -> Dict[str, float]:
 10273:    392:     """Evaluate a list of trade dictionaries.
 10274:    393: 
 10275:    394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
 10276:    395:     optionally include ``duration`` in minutes.  Results are aggregated into
 10277:    396:     common performance metrics to quickly evaluate the strategy.
 10278:    397:     """
 10279:    398: 
 10280:    399:     equity = equity_start
 10281:    400:     equity_curve = [equity]
 10282:    401:     pnl_pct_list: List[float] = []
 10283:    402:     wins = losses = 0
 10284:    403:     win_sum = loss_sum = 0.0
 10285:    404:     total_duration = 0.0
 10286:    405: 
 10287:    406:     for t in trades:
 10288:    407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
 10289:    408:         pnl_pct_list.append(pnl_pct)
 10290:    409:         if pnl_pct >= 0:
 10291:    410:             wins += 1
 10292:    411:             win_sum += pnl_pct
 10293:    412:         else:
 10294:    413:             losses += 1
 10295:    414:             loss_sum += pnl_pct
 10296:    415:         equity *= 1 + pnl_pct / 100.0
 10297:    416:         equity_curve.append(equity)
 10298:    417:         total_duration += float(t.get("duration", 0.0))
 10299:    418: 
 10300:    419:     pnl_pct_total = sum(pnl_pct_list)
 10301:    420:     pnl_usdt = equity - equity_start
 10302:    421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
 10303:    422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
 10304:    423:     mdd = max_drawdown(equity_curve)
 10305:    424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
 10306:    425:     exposure = total_duration  # in minutes, callers can normalise if desired
 10307:    426:     # Sharpe ratio based on per-trade returns
 10308:    427:     if len(pnl_pct_list) > 1:
 10309:    428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
 10310:    429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
 10311:    430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
 10312:    431:     else:
 10313:    432:         sharpe = 0.0
 10314:    433: 
 10315:    434:     return {
 10316:    435:         "pnl_usdt": pnl_usdt,
 10317:    436:         "pnl_pct": pnl_pct_total,
 10318:    437:         "profit_factor": profit_factor,
 10319:    438:         "winrate": winrate,
 10320:    439:         "max_drawdown": mdd,
 10321:    440:         "avg_trade_time": avg_trade_time,
 10322:    441:         "exposure": exposure,
 10323:    442:         "sharpe": sharpe,
 10324:    443:     }
 10325: 
 10326: 
 10327: ## scalper/trade_utils.py (last modified: 2025-08-23 20:57:14)
 10328:      1: # scalper/trade_utils.py
 10329:      2: from __future__ import annotations
 10330:      3: 
 10331:      4: from typing import Optional
 10332:      5: 
 10333:      6: 
 10334:      7: def compute_position_size(
 10335:      8:     equity: float,
 10336:      9:     price: float,
 10337:     10:     risk_pct: float,
 10338:     11:     *,
 10339:     12:     symbol: Optional[str] = None,
 10340:     13:     min_qty: float = 0.0,
 10341:     14:     max_leverage: float = 1.0,
 10342:     15: ) -> float:
 10343:     16:     """
 10344:     17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
 10345:     18:     qty = notionnel / price
 10346:     19:     - min_qty : borne basse éventuelle (0 pour ignorer)
 10347:     20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
 10348:     21:     """
 10349:     22:     equity = float(max(0.0, equity))
 10350:     23:     price = float(max(1e-12, price))
 10351:     24:     risk_pct = float(max(0.0, risk_pct))
 10352:     25:     notionnel = equity * risk_pct * max_leverage
 10353:     26:     qty = notionnel / price
 10354:     27:     if min_qty > 0 and qty < min_qty:
 10355:     28:         return 0.0
 10356:     29:     return float(qty)
 10357: 
 10358: ## scalper/version.py (last modified: 2025-08-23 20:57:14)
 10359:      1: """Utilities for managing the Scalp bot version."""
 10360:      2: 
 10361:      3: from __future__ import annotations
 10362:      4: 
 10363:      5: from pathlib import Path
 10364:      6: import re
 10365:      7: 
 10366:      8: import subprocess
 10367:      9: 
 10368:     10: 
 10369:     11: # Path to the VERSION file within the package
 10370:     12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
 10371:     13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
 10372:     14: 
 10373:     15: 
 10374:     16: def get_version() -> str:
 10375:     17:     """Return the current version of the bot.
 10376:     18: 
 10377:     19:     If the VERSION file does not exist the default version ``0.0.0`` is
 10378:     20:     returned.
 10379:     21:     """
 10380:     22:     if not _VERSION_FILE.exists():
 10381:     23:         return "0.0.0"
 10382:     24:     return _VERSION_FILE.read_text().strip()
 10383:     25: 
 10384:     26: 
 10385:     27: def _parse(version: str) -> tuple[int, int, int]:
 10386:     28:     match = _VERSION_RE.match(version)
 10387:     29:     if not match:
 10388:     30:         raise ValueError(f"Invalid version: {version!r}")
 10389:     31:     return tuple(int(x) for x in match.groups())
 10390:     32: 
 10391:     33: 
 10392:     34: def bump_version(part: str = "patch") -> str:
 10393:     35:     """Bump the version stored in the VERSION file.
 10394:     36: 
 10395:     37:     Parameters
 10396:     38:     ----------
 10397:     39:     part:
 10398:     40:         Which component to increment. Accepted values are ``"major"``,
 10399:     41:         ``"minor"`` and ``"patch"`` (default).
 10400:     42:     """
 10401:     43:     major, minor, patch = _parse(get_version())
 10402:     44:     if part == "major":
 10403:     45:         major += 1
 10404:     46:         minor = 0
 10405:     47:         patch = 0
 10406:     48:     elif part == "minor":
 10407:     49:         minor += 1
 10408:     50:         patch = 0
 10409:     51: 
 10410:     52:     elif part == "patch":
 10411:     53:         patch += 1
 10412:     54:     else:
 10413:     55:         raise ValueError(f"Unknown part: {part}")
 10414:     56:     new_version = f"{major}.{minor}.{patch}"
 10415:     57:     _VERSION_FILE.write_text(f"{new_version}\n")
 10416:     58:     return new_version
 10417:     59: 
 10418:     60: 
 10419:     61: def bump_version_from_message(message: str) -> str:
 10420:     62:     """Bump the version according to a commit message.
 10421:     63: 
 10422:     64:     ``message`` is evaluated using a tiny subset of the Conventional
 10423:     65:     Commits spec. Messages starting with ``feat`` bump the *minor*
 10424:     66:     version, messages whose header ends with ``!`` or contain
 10425:     67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
 10426:     68:     bump the *patch* component.
 10427:     69:     """
 10428:     70: 
 10429:     71:     header = message.strip().splitlines()[0].lower()
 10430:     72:     lower = message.lower()
 10431:     73:     type_part = header.split(":")[0]
 10432:     74:     if "!" in type_part or "breaking change" in lower:
 10433:     75:         part = "major"
 10434:     76:     elif type_part.startswith("feat"):
 10435:     77:         part = "minor"
 10436:     78:     else:
 10437:     79:         part = "patch"
 10438:     80:     return bump_version(part)
 10439:     81: 
 10440:     82: 
 10441:     83: def bump_version_from_git() -> str:
 10442:     84:     """Read the latest git commit message and bump the version accordingly."""
 10443:     85:     try:
 10444:     86:         message = subprocess.check_output(
 10445:     87:             ["git", "log", "-1", "--pretty=%B"], text=True
 10446:     88:         ).strip()
 10447:     89:     except Exception:
 10448:     90:         message = ""
 10449:     91:     return bump_version_from_message(message)
 10450:     92: 
 10451:     93: 
 10452:     94: if __name__ == "__main__":
 10453:     95:     print(bump_version_from_git())
 10454: 
 10455: 
 10456: ## scalper/ws.py (last modified: 2025-08-23 20:57:14)
 10457:      1: """Minimal websocket manager with heartbeat and auto-resubscribe.
 10458:      2: 
 10459:      3: This module provides a light-weight framework to maintain a realtime
 10460:      4: connection to an exchange.  The actual network layer is expected to be
 10461:      5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
 10462:      6: manager handles retrying failed connections and periodically invoking the
 10463:      7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
 10464:      8: without opening real network sockets.
 10465:      9: """
 10466:     10: from __future__ import annotations
 10467:     11: 
 10468:     12: import asyncio
 10469:     13: import logging
 10470:     14: from typing import Awaitable, Callable, Optional
 10471:     15: 
 10472:     16: 
 10473:     17: class WebsocketManager:
 10474:     18:     """Maintain a websocket connection with heartbeat and retry."""
 10475:     19: 
 10476:     20:     def __init__(
 10477:     21:         self,
 10478:     22:         connect: Callable[[], Awaitable[None]],
 10479:     23:         subscribe: Callable[[], Awaitable[None]],
 10480:     24:         *,
 10481:     25:         heartbeat_interval: float = 30.0,
 10482:     26:         max_retries: int = 3,
 10483:     27:     ) -> None:
 10484:     28:         self._connect = connect
 10485:     29:         self._subscribe = subscribe
 10486:     30:         self.heartbeat_interval = heartbeat_interval
 10487:     31:         self.max_retries = max_retries
 10488:     32:         self._heartbeat_task: Optional[asyncio.Task] = None
 10489:     33: 
 10490:     34:     async def run(self) -> None:
 10491:     35:         """Open the connection retrying on failure."""
 10492:     36:         retries = 0
 10493:     37:         while True:
 10494:     38:             try:
 10495:     39:                 await self._connect()
 10496:     40:                 await self._subscribe()
 10497:     41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
 10498:     42:                 return
 10499:     43:             except Exception as exc:  # pragma: no cover - network errors
 10500:     44:                 logging.error("websocket connect failed: %s", exc)
 10501:     45:                 retries += 1
 10502:     46:                 if retries > self.max_retries:
 10503:     47:                     raise
 10504:     48:                 await asyncio.sleep(1)
 10505:     49: 
 10506:     50:     async def _heartbeat(self) -> None:
 10507:     51:         """Send periodic heartbeats and resubscribe on failure."""
 10508:     52:         while True:
 10509:     53:             await asyncio.sleep(self.heartbeat_interval)
 10510:     54:             try:
 10511:     55:                 await self._subscribe()
 10512:     56:             except Exception as exc:  # pragma: no cover - network errors
 10513:     57:                 logging.warning("websocket heartbeat failed: %s", exc)
 10514:     58:                 await self.run()
 10515:     59:                 break
 10516:     60: 
 10517:     61:     async def stop(self) -> None:
 10518:     62:         """Cancel the heartbeat task if it is running."""
 10519:     63:         task = self._heartbeat_task
 10520:     64:         if task and not task.done():
 10521:     65:             task.cancel()
 10522:     66:             try:
 10523:     67:                 await task
 10524:     68:             except BaseException:  # pragma: no cover - cancellation
 10525:     69:                 pass
 10526:     70:         self._heartbeat_task = None
 10527: 
 10528: 
 10529: ## sitecustomize.py (last modified: 2025-08-23 20:57:14)
 10530:      1: # sitecustomize.py
 10531:      2: """
 10532:      3: Ce fichier est importé automatiquement par Python au démarrage, si présent sur sys.path.
 10533:      4: On l'utilise pour lancer un préflight de 'scalper' avant l'exécution du bot,
 10534:      5: sans modifier bot.py. Désactivable via SKIP_PREFLIGHT=1.
 10535:      6: """
 10536:      7: 
 10537:      8: import os
 10538:      9: 
 10539:     10: if os.getenv("SKIP_PREFLIGHT", "0") not in ("1", "true", "yes"):
 10540:     11:     try:
 10541:     12:         # Optionnel: charger /notebooks/.env si présent
 10542:     13:         try:
 10543:     14:             from dotenv import load_dotenv  # pip install python-dotenv si besoin
 10544:     15:             load_dotenv("/notebooks/.env")
 10545:     16:         except Exception:
 10546:     17:             pass
 10547:     18: 
 10548:     19:     except Exception:
 10549:     20:         pass
 10550:     21: 
 10551:     22:     try:
 10552:     23:         from scalper.selfcheck import preflight_or_die
 10553:     24:         preflight_or_die(verbose=False)
 10554:     25:     except SystemExit:
 10555:     26:         # le préflight a signalé un problème -> on laisse l'arrêt se propager
 10556:     27:         raise
 10557:     28:     except Exception as e:
 10558:     29:         # On ne bloque pas le démarrage si le selfcheck lui-même plante,
 10559:     30:         # mais on affiche une alerte claire.
 10560:     31:         print(f"[sitecustomize] Avertissement: selfcheck non exécuté ({e})")
 10561: 
 10562: ## tests/conftest.py (last modified: 2025-08-23 20:57:14)
 10563:      1: """Test configuration and shared fixtures."""
 10564:      2: 
 10565:      3: import sys
 10566:      4: import types
 10567:      5: from pathlib import Path
 10568:      6: 
 10569:      7: 
 10570:      8: # Ensure the project root is importable so tests can ``import bot``.
 10571:      9: ROOT = Path(__file__).resolve().parents[1]
 10572:     10: sys.path.insert(0, str(ROOT))
 10573:     11: 
 10574:     12: 
 10575:     13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
 10576:     14: # the real dependency during test collection. Individual tests patch the
 10577:     15: # functions they need (``request``/``post``/``get``).
 10578:     16: sys.modules.setdefault(
 10579:     17:     "requests",
 10580:     18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
 10581:     19: )
 10582:     20: 
 10583: 
 10584: 
 10585: ## tests/test_analyse_risque.py (last modified: 2025-08-23 20:57:14)
 10586:      1: import os
 10587:      2: import sys
 10588:      3: import types
 10589:      4: 
 10590:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10591:      6: sys.modules['requests'] = types.SimpleNamespace(
 10592:      7:     request=lambda *a, **k: None,
 10593:      8:     post=lambda *a, **k: None,
 10594:      9:     HTTPError=Exception,
 10595:     10: )
 10596:     11: 
 10597:     12: from bot import analyse_risque  # noqa: E402
 10598:     13: 
 10599:     14: 
 10600:     15: def make_contract_detail():
 10601:     16:     return {
 10602:     17:         "data": [
 10603:     18:             {
 10604:     19:                 "symbol": "BTC_USDT",
 10605:     20:                 "contractSize": 0.01,
 10606:     21:                 "volUnit": 1,
 10607:     22:                 "minVol": 1,
 10608:     23:             }
 10609:     24:         ]
 10610:     25:     }
 10611:     26: 
 10612:     27: 
 10613:     28: def test_analyse_risque_limits_and_leverage():
 10614:     29:     contract_detail = make_contract_detail()
 10615:     30:     # Risk level 1: leverage halved, limit 1 position
 10616:     31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
 10617:     32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 10618:     33:                                symbol="BTC_USDT", side="long", risk_level=1)
 10619:     34:     assert lev == 5
 10620:     35:     assert vol == 0  # already one long position
 10621:     36: 
 10622:     37:     # Risk level 2: base leverage, limit 3 positions
 10623:     38:     open_pos = [
 10624:     39:         {"symbol": "BTC_USDT", "side": "long"},
 10625:     40:         {"symbol": "BTC_USDT", "side": "long"},
 10626:     41:         {"symbol": "BTC_USDT", "side": "long"},
 10627:     42:     ]
 10628:     43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 10629:     44:                                symbol="BTC_USDT", side="long", risk_level=2)
 10630:     45:     assert lev == 10
 10631:     46:     assert vol == 0
 10632:     47: 
 10633:     48:     # Risk level 3: leverage doubled, no existing position
 10634:     49:     open_pos = []
 10635:     50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 10636:     51:                                symbol="BTC_USDT", side="long", risk_level=3)
 10637:     52:     assert lev == 20
 10638:     53:     assert vol == 1
 10639: 
 10640: 
 10641: ## tests/test_backtest.py (last modified: 2025-08-23 20:57:14)
 10642:      1: import pytest
 10643:      2: 
 10644:      3: import bot
 10645:      4: 
 10646:      5: 
 10647:      6: def test_backtest_trades():
 10648:      7:     trades = [
 10649:      8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
 10650:      9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
 10651:     10:     ]
 10652:     11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
 10653:     12:     # Both trades: 10% - 0.2% fee = 9.8% each
 10654:     13:     assert pnl == pytest.approx(19.6)
 10655: 
 10656: 
 10657: ## tests/test_backtest_multi.py (last modified: 2025-08-23 20:57:14)
 10658:      1: import csv
 10659:      2: import random
 10660:      3: from datetime import datetime, timedelta, timezone
 10661:      4: from pathlib import Path
 10662:      5: 
 10663:      6: import pytest
 10664:      7: 
 10665:      8: from scalper.backtest.run_multi import run_backtest_multi
 10666:      9: from scalper.strategy import Signal
 10667:     10: 
 10668:     11: 
 10669:     12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
 10670:     13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
 10671:     14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
 10672:     15:     with open(filename, "w", newline="") as fh:
 10673:     16:         writer = csv.writer(fh)
 10674:     17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
 10675:     18:         for i in range(200):
 10676:     19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
 10677:     20:             price = 100 + i
 10678:     21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
 10679:     22: 
 10680:     23: 
 10681:     24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 10682:     25:     closes = ohlcv["close"]
 10683:     26:     if len(closes) < 10:
 10684:     27:         return None
 10685:     28:     price = closes[-1]
 10686:     29:     sl = price * 0.99
 10687:     30:     tp = price * 1.01
 10688:     31:     qty = equity * risk_pct / (price - sl)
 10689:     32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
 10690:     33: 
 10691:     34: 
 10692:     35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 10693:     36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
 10694:     37:         return None
 10695:     38:     price = ohlcv["close"][-1]
 10696:     39:     sl = price * 0.99
 10697:     40:     tp = price * 1.01
 10698:     41:     qty = equity * risk_pct / (price - sl)
 10699:     42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
 10700:     43: 
 10701:     44: 
 10702:     45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 10703:     46:     closes = ohlcv["close"]
 10704:     47:     if len(closes) < 10:
 10705:     48:         return None
 10706:     49:     price = closes[-1]
 10707:     50:     sl = price * 0.99
 10708:     51:     tp = price * 1.01
 10709:     52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
 10710:     53: 
 10711:     54: 
 10712:     55: def find_row(summary, symbol):
 10713:     56:     for row in summary:
 10714:     57:         if row["symbol"] == symbol:
 10715:     58:             return row
 10716:     59:     raise KeyError(symbol)
 10717:     60: 
 10718:     61: 
 10719:     62: def test_csv_multi_pairs(tmp_path, monkeypatch):
 10720:     63:     for sym in ["BTC/USDT", "ETH/USDT"]:
 10721:     64:         make_csv(tmp_path, sym)
 10722:     65:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
 10723:     66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
 10724:     67:     out = tmp_path / "out"
 10725:     68:     summary, trades = run_backtest_multi(
 10726:     69:         symbols=["BTC/USDT", "ETH/USDT"],
 10727:     70:         exchange="csv",
 10728:     71:         timeframe="1m",
 10729:     72:         csv_dir=str(tmp_path),
 10730:     73:         fee_rate=0.0,
 10731:     74:         slippage_bps=0.0,
 10732:     75:         risk_pct=0.01,
 10733:     76:         initial_equity=1000,
 10734:     77:         leverage=1.0,
 10735:     78:         paper_constraints=True,
 10736:     79:         seed=42,
 10737:     80:         out_dir=str(out),
 10738:     81:         plot=False,
 10739:     82:     )
 10740:     83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
 10741:     84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
 10742:     85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
 10743:     86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
 10744:     87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
 10745:     88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
 10746:     89:     # files
 10747:     90:     assert (out / "report_summary.csv").exists()
 10748:     91:     assert (out / "report_trades.csv").exists()
 10749:     92:     assert (out / "equity_curve_total.csv").exists()
 10750:     93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
 10751:     94:     # columns in trades
 10752:     95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
 10753:     96:         assert col in trades[0]
 10754:     97: 
 10755:     98: 
 10756:     99: def test_fee_slippage(tmp_path, monkeypatch):
 10757:    100:     make_csv(tmp_path, "BTC/USDT")
 10758:    101:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
 10759:    102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
 10760:    103:     summary1, _ = run_backtest_multi(
 10761:    104:         symbols=["BTC/USDT"],
 10762:    105:         exchange="csv",
 10763:    106:         timeframe="1m",
 10764:    107:         csv_dir=str(tmp_path),
 10765:    108:         fee_rate=0.0,
 10766:    109:         slippage_bps=0.0,
 10767:    110:         out_dir=str(tmp_path / "o1"),
 10768:    111:     )
 10769:    112:     summary2, _ = run_backtest_multi(
 10770:    113:         symbols=["BTC/USDT"],
 10771:    114:         exchange="csv",
 10772:    115:         timeframe="1m",
 10773:    116:         csv_dir=str(tmp_path),
 10774:    117:         fee_rate=0.01,
 10775:    118:         slippage_bps=100,
 10776:    119:         out_dir=str(tmp_path / "o2"),
 10777:    120:     )
 10778:    121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
 10779:    122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
 10780:    123:     assert pnl2 < pnl1
 10781:    124: 
 10782:    125: 
 10783:    126: def test_paper_constraints(tmp_path, monkeypatch):
 10784:    127:     make_csv(tmp_path, "BTC/USDT")
 10785:    128:     monkeypatch.setattr("scalper.strategy.generate_signal", tiny_qty_signal)
 10786:    129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
 10787:    130:     summary, trades = run_backtest_multi(
 10788:    131:         symbols=["BTC/USDT"],
 10789:    132:         exchange="csv",
 10790:    133:         timeframe="1m",
 10791:    134:         csv_dir=str(tmp_path),
 10792:    135:         paper_constraints=True,
 10793:    136:         out_dir=str(tmp_path / "o"),
 10794:    137:     )
 10795:    138:     assert all(t["qty"] >= 0.001 for t in trades)
 10796:    139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
 10797:    140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
 10798:    141: 
 10799:    142: 
 10800:    143: def test_seed_reproducible(tmp_path, monkeypatch):
 10801:    144:     make_csv(tmp_path, "BTC/USDT")
 10802:    145:     monkeypatch.setattr("scalper.strategy.generate_signal", random_signal)
 10803:    146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
 10804:    147:     s1, t1 = run_backtest_multi(
 10805:    148:         symbols=["BTC/USDT"],
 10806:    149:         exchange="csv",
 10807:    150:         timeframe="1m",
 10808:    151:         csv_dir=str(tmp_path),
 10809:    152:         seed=7,
 10810:    153:         out_dir=str(tmp_path / "o1"),
 10811:    154:     )
 10812:    155:     s2, t2 = run_backtest_multi(
 10813:    156:         symbols=["BTC/USDT"],
 10814:    157:         exchange="csv",
 10815:    158:         timeframe="1m",
 10816:    159:         csv_dir=str(tmp_path),
 10817:    160:         seed=7,
 10818:    161:         out_dir=str(tmp_path / "o2"),
 10819:    162:     )
 10820:    163:     assert t1 == t2
 10821:    164:     assert s1 == s2
 10822: 
 10823: 
 10824: ## tests/test_backtest_position.py (last modified: 2025-08-23 20:57:14)
 10825:      1: import os
 10826:      2: import sys
 10827:      3: import pytest
 10828:      4: 
 10829:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10830:      6: 
 10831:      7: from scalper.metrics import backtest_position
 10832:      8: 
 10833:      9: 
 10834:     10: def test_backtest_position_long():
 10835:     11:     prices = [100.0, 110.0, 120.0]
 10836:     12:     assert backtest_position(prices, 0, 2, 1) is True
 10837:     13: 
 10838:     14: 
 10839:     15: def test_backtest_position_short():
 10840:     16:     prices = [100.0, 90.0, 80.0]
 10841:     17:     assert backtest_position(prices, 0, 2, -1) is True
 10842:     18: 
 10843:     19: 
 10844:     20: def test_backtest_position_incoherent():
 10845:     21:     prices = [100.0, 110.0, 120.0]
 10846:     22:     assert backtest_position(prices, 0, 2, -1) is False
 10847:     23: 
 10848:     24: 
 10849:     25: def test_backtest_position_bad_indices():
 10850:     26:     prices = [100.0, 110.0]
 10851:     27:     with pytest.raises(ValueError):
 10852:     28:         backtest_position(prices, 1, 0, 1)
 10853: 
 10854: 
 10855: ## tests/test_bitget_futures_pairs.py (last modified: 2025-08-23 20:57:14)
 10856:      1: import json
 10857:      2: from pathlib import Path
 10858:      3: from typing import Any, Dict
 10859:      4: 
 10860:      5: import pytest
 10861:      6: 
 10862:      7: import bitget_futures_pairs as bfp
 10863:      8: 
 10864:      9: 
 10865:     10: class DummyResponse:
 10866:     11:     def __init__(self, status: int, payload: Dict[str, Any]):
 10867:     12:         self.status_code = status
 10868:     13:         self._payload = payload
 10869:     14:         self.text = json.dumps(payload)
 10870:     15: 
 10871:     16:     def json(self):
 10872:     17:         return self._payload
 10873:     18: 
 10874:     19: 
 10875:     20: def test_fetch_contracts_success(monkeypatch):
 10876:     21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
 10877:     22: 
 10878:     23:     def fake_get(url, params=None, timeout=0):
 10879:     24:         return DummyResponse(200, payload)
 10880:     25: 
 10881:     26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
 10882:     27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
 10883:     28:     assert contracts == payload["data"]
 10884:     29: 
 10885:     30: 
 10886:     31: def test_fetch_contracts_error(monkeypatch):
 10887:     32:     payload = {"code": "10001"}
 10888:     33: 
 10889:     34:     def fake_get(url, params=None, timeout=0):
 10890:     35:         return DummyResponse(200, payload)
 10891:     36: 
 10892:     37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
 10893:     38:     with pytest.raises(RuntimeError):
 10894:     39:         bfp.fetch_contracts("USDT-FUTURES")
 10895:     40: 
 10896:     41: 
 10897:     42: def test_normalize_rows():
 10898:     43:     contracts = [
 10899:     44:         {
 10900:     45:             "symbol": "BTCUSDT",
 10901:     46:             "baseCoin": "BTC",
 10902:     47:             "quoteCoin": "USDT",
 10903:     48:             "symbolType": "perpetual",
 10904:     49:             "symbolStatus": "normal",
 10905:     50:             "maxLever": "50",
 10906:     51:             "minLever": "1",
 10907:     52:             "minTradeNum": "0.001",
 10908:     53:             "sizeMultiplier": "1",
 10909:     54:             "pricePlace": "2",
 10910:     55:             "volumePlace": "3",
 10911:     56:             "launchTime": 0,
 10912:     57:             "deliveryTime": 0,
 10913:     58:         }
 10914:     59:     ]
 10915:     60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
 10916:     61:     assert rows[0]["symbol"] == "BTCUSDT"
 10917:     62:     assert rows[0]["productType"] == "USDT-FUTURES"
 10918:     63: 
 10919:     64: 
 10920:     65: def test_write_csv(tmp_path: Path):
 10921:     66:     path = tmp_path / "pairs.csv"
 10922:     67:     bfp.write_csv([], str(path))
 10923:     68:     assert path.exists()
 10924:     69:     content = path.read_text().splitlines()
 10925:     70:     assert content[0].startswith("productType,")
 10926: 
 10927: 
 10928: ## tests/test_bot_place_order_caps.py (last modified: 2025-08-23 20:57:14)
 10929:      1: import os
 10930:      2: import sys
 10931:      3: import types
 10932:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 10933:      5: sys.modules['requests'] = types.ModuleType('requests')
 10934:      6: 
 10935:      7: from bot import attempt_entry, Signal
 10936:      8: 
 10937:      9: 
 10938:     10: class DummyClient:
 10939:     11:     def __init__(self):
 10940:     12:         self.last_order = None
 10941:     13: 
 10942:     14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
 10943:     15:         self.last_order = (args, kwargs)
 10944:     16:         return {"code": "00000"}
 10945:     17: 
 10946:     18: 
 10947:     19: class DummyRisk:
 10948:     20:     def __init__(self, pct):
 10949:     21:         self.risk_pct = pct
 10950:     22: 
 10951:     23: 
 10952:     24: def _detail():
 10953:     25:     return {
 10954:     26:         "data": [
 10955:     27:             {
 10956:     28:                 "symbol": "BTC_USDT",
 10957:     29:                 "contractSize": 0.001,
 10958:     30:                 "volUnit": 1,
 10959:     31:                 "minVol": 1,
 10960:     32:                 "minTradeUSDT": 5,
 10961:     33:             }
 10962:     34:         ]
 10963:     35:     }
 10964:     36: 
 10965:     37: 
 10966:     38: def test_attempt_entry_respects_caps(monkeypatch):
 10967:     39:     captured = {}
 10968:     40: 
 10969:     41:     def fake_notify(event, payload):
 10970:     42:         captured[event] = payload
 10971:     43: 
 10972:     44:     monkeypatch.setattr("bot.notify", fake_notify)
 10973:     45:     client = DummyClient()
 10974:     46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 10975:     47:     rm = DummyRisk(0.02)
 10976:     48:     equity = 100
 10977:     49:     available = 2.2  # just enough for 1 contract with buffer
 10978:     50:     params = attempt_entry(
 10979:     51:         client,
 10980:     52:         _detail(),
 10981:     53:         sig,
 10982:     54:         equity_usdt=equity,
 10983:     55:         available_usdt=available,
 10984:     56:         cfg={"LEVERAGE": 10},
 10985:     57:         risk_mgr=rm,
 10986:     58:         user_risk_level=1,
 10987:     59:     )
 10988:     60:     assert client.last_order is not None
 10989:     61:     assert params["vol"] >= 1
 10990:     62:     opened = captured["position_opened"]
 10991:     63:     assert opened["notional_usdt"] >= 5
 10992:     64:     assert opened["vol"] >= 1
 10993:     65: 
 10994:     66: 
 10995:     67: def test_attempt_entry_insufficient_margin(monkeypatch):
 10996:     68:     captured = {}
 10997:     69: 
 10998:     70:     def fake_notify(event, payload):
 10999:     71:         captured[event] = payload
 11000:     72: 
 11001:     73:     monkeypatch.setattr("bot.notify", fake_notify)
 11002:     74:     client = DummyClient()
 11003:     75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 11004:     76:     rm = DummyRisk(0.02)
 11005:     77:     equity = 100
 11006:     78:     available = 1.0  # below required margin
 11007:     79:     params = attempt_entry(
 11008:     80:         client,
 11009:     81:         _detail(),
 11010:     82:         sig,
 11011:     83:         equity_usdt=equity,
 11012:     84:         available_usdt=available,
 11013:     85:         cfg={"LEVERAGE": 10},
 11014:     86:         risk_mgr=rm,
 11015:     87:         user_risk_level=1,
 11016:     88:     )
 11017:     89:     assert client.last_order is None
 11018:     90:     assert params["vol"] == 0
 11019:     91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 11020:     92: 
 11021:     93: 
 11022:     94: def test_attempt_entry_under_min_trade(monkeypatch):
 11023:     95:     captured = {}
 11024:     96: 
 11025:     97:     def fake_notify(event, payload):
 11026:     98:         captured[event] = payload
 11027:     99: 
 11028:    100:     monkeypatch.setattr("bot.notify", fake_notify)
 11029:    101:     client = DummyClient()
 11030:    102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 11031:    103:     rm = DummyRisk(0.02)
 11032:    104:     detail = {
 11033:    105:         "data": [
 11034:    106:             {
 11035:    107:                 "symbol": "BTC_USDT",
 11036:    108:                 "contractSize": 0.001,
 11037:    109:                 "volUnit": 1,
 11038:    110:                 "minVol": 1,
 11039:    111:                 "minTradeUSDT": 50,
 11040:    112:             }
 11041:    113:         ]
 11042:    114:     }
 11043:    115:     equity = 100
 11044:    116:     available = 100
 11045:    117:     params = attempt_entry(
 11046:    118:         client,
 11047:    119:         detail,
 11048:    120:         sig,
 11049:    121:         equity_usdt=equity,
 11050:    122:         available_usdt=available,
 11051:    123:         cfg={"LEVERAGE": 10},
 11052:    124:         risk_mgr=rm,
 11053:    125:         user_risk_level=1,
 11054:    126:     )
 11055:    127:     assert client.last_order is None
 11056:    128:     assert params["vol"] == 0
 11057:    129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 11058: 
 11059: 
 11060: ## tests/test_bot_update.py (last modified: 2025-08-23 20:57:14)
 11061:      1: import logging
 11062:      2: import bot
 11063:      3: 
 11064:      4: 
 11065:      5: def test_update_displays_pairs(monkeypatch, caplog):
 11066:      6:     def fake_send(client, top_n=40):
 11067:      7:         assert (client, top_n) == ("cli", 5)
 11068:      8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
 11069:      9: 
 11070:     10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
 11071:     11:     with caplog.at_level(logging.INFO):
 11072:     12:         payload = bot.update("cli", top_n=5)
 11073:     13:     assert payload["green"] == "BTC"
 11074:     14:     assert "Listing ok" in caplog.text
 11075:     15: 
 11076:     16: 
 11077:     17: def test_update_survives_errors(monkeypatch, caplog):
 11078:     18:     """``update`` should never raise even if pair selection fails."""
 11079:     19: 
 11080:     20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
 11081:     21:         raise RuntimeError("network down")
 11082:     22: 
 11083:     23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
 11084:     24:     with caplog.at_level(logging.INFO):
 11085:     25:         payload = bot.update("cli", top_n=5)
 11086:     26: 
 11087:     27:     # The function returns an empty payload and logs the error, but still logs
 11088:     28:     # the "Listing ok" acknowledgement so callers can proceed.
 11089:     29:     assert payload == {}
 11090:     30:     assert "network down" in caplog.text
 11091:     31:     assert "Listing ok" in caplog.text
 11092:     32: 
 11093: 
 11094: 
 11095: ## tests/test_break_even_stop.py (last modified: 2025-08-23 20:57:14)
 11096:      1: from scalper.trade_utils import break_even_stop
 11097:      2: 
 11098:      3: 
 11099:      4: def test_break_even_stop_long() -> None:
 11100:      5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
 11101:      6:     assert sl == 100
 11102:      7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
 11103:      8:     assert sl == 95
 11104:      9: 
 11105:     10: 
 11106:     11: def test_break_even_stop_short() -> None:
 11107:     12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
 11108:     13:     assert sl == 100
 11109:     14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
 11110:     15:     assert sl == 105
 11111: 
 11112: 
 11113: ## tests/test_calc_pnl_pct.py (last modified: 2025-08-23 20:57:14)
 11114:      1: import os
 11115:      2: import sys
 11116:      3: import pytest
 11117:      4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11118:      5: 
 11119:      6: from scalper.metrics import calc_pnl_pct
 11120:      7: 
 11121:      8: 
 11122:      9: def test_calc_pnl_pct_long():
 11123:     10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
 11124:     11: 
 11125:     12: def test_calc_pnl_pct_short():
 11126:     13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
 11127:     14: 
 11128:     15: 
 11129:     16: def test_calc_pnl_pct_with_fee():
 11130:     17:     # 10% move minus 0.1%*2 fees = 9.8%
 11131:     18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)
 11132: 
 11133: 
 11134: ## tests/test_check_config.py (last modified: 2025-08-23 20:57:14)
 11135:      1: import logging
 11136:      2: from bot import check_config
 11137:      3: 
 11138:      4: 
 11139:      5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
 11140:      6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
 11141:      7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
 11142:      8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 11143:      9:     with caplog.at_level(logging.INFO):
 11144:     10:         check_config()
 11145:     11:     messages = [r.getMessage() for r in caplog.records]
 11146:     12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
 11147:     13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
 11148:     14:     assert all("NOTIFY_URL" not in m for m in messages)
 11149:     15: 
 11150:     16: 
 11151:     17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
 11152:     18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
 11153:     19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
 11154:     20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
 11155:     21:     with caplog.at_level(logging.INFO):
 11156:     22:         check_config()
 11157:     23:     assert caplog.records == []
 11158: 
 11159: 
 11160: ## tests/test_cli.py (last modified: 2025-08-23 20:57:14)
 11161:      1: """Tests for the command line interface defined in :mod:`cli`."""
 11162:      2: 
 11163:      3: from __future__ import annotations
 11164:      4: 
 11165:      5: import cli
 11166:      6: 
 11167:      7: 
 11168:      8: def test_opt_invokes_parallel_optimization(monkeypatch):
 11169:      9:     """The ``opt`` command should call ``run_parallel_optimization``."""
 11170:     10: 
 11171:     11:     called = {}
 11172:     12: 
 11173:     13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
 11174:     14:         called["args"] = (pairs, tf, jobs)
 11175:     15: 
 11176:     16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
 11177:     17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
 11178:     18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
 11179:     19: 
 11180:     20: 
 11181:     21: def test_walkforward_invokes_analysis(monkeypatch):
 11182:     22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
 11183:     23: 
 11184:     24:     called = {}
 11185:     25: 
 11186:     26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
 11187:     27:         called["args"] = (pair, tf, splits, train_ratio)
 11188:     28: 
 11189:     29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
 11190:     30:     cli.main(
 11191:     31:         [
 11192:     32:             "walkforward",
 11193:     33:             "--pair",
 11194:     34:             "BTCUSDT",
 11195:     35:             "--tf",
 11196:     36:             "1m",
 11197:     37:             "--splits",
 11198:     38:             "3",
 11199:     39:             "--train-ratio",
 11200:     40:             "0.8",
 11201:     41:         ]
 11202:     42:     )
 11203:     43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
 11204:     44: 
 11205:     45: 
 11206:     46: def test_live_invokes_async_pipeline(monkeypatch):
 11207:     47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
 11208:     48: 
 11209:     49:     called = {}
 11210:     50: 
 11211:     51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
 11212:     52:         called["args"] = (pairs, list(tfs))
 11213:     53: 
 11214:     54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
 11215:     55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
 11216:     56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
 11217:     57: 
 11218:     58: 
 11219:     59: def test_bump_version_invokes_helper(monkeypatch):
 11220:     60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
 11221:     61: 
 11222:     62:     called = {}
 11223:     63: 
 11224:     64:     def fake_bump():  # pragma: no cover - executed via CLI
 11225:     65:         called["called"] = True
 11226:     66:         return "0.1.0"
 11227:     67: 
 11228:     68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
 11229:     69:     cli.main(["bump-version"])
 11230:     70:     assert called["called"] is True
 11231:     71: 
 11232: 
 11233: 
 11234: ## tests/test_client.py (last modified: 2025-08-23 20:57:14)
 11235:      1: import json
 11236:      2: import hmac
 11237:      3: import hashlib
 11238:      4: import base64
 11239:      5: import pytest
 11240:      6: import bot
 11241:      7: from bot import BitgetFuturesClient
 11242:      8: 
 11243:      9: 
 11244:     10: @pytest.fixture(autouse=True)
 11245:     11: def no_log_event(monkeypatch):
 11246:     12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
 11247:     13: 
 11248:     14: 
 11249:     15: def test_private_request_get_signature(monkeypatch):
 11250:     16:     client = BitgetFuturesClient("key", "secret", "https://test")
 11251:     17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 11252:     18: 
 11253:     19:     called = {}
 11254:     20: 
 11255:     21:     def fake_request(method, url, headers=None, timeout=None):
 11256:     22:         called["method"] = method
 11257:     23:         called["url"] = url
 11258:     24:         called["headers"] = headers
 11259:     25: 
 11260:     26:         class Resp:
 11261:     27:             def raise_for_status(self):
 11262:     28:                 pass
 11263:     29: 
 11264:     30:             def json(self):
 11265:     31:                 return {"success": True}
 11266:     32: 
 11267:     33:         return Resp()
 11268:     34: 
 11269:     35:     monkeypatch.setattr(bot.requests, "request", fake_request)
 11270:     36: 
 11271:     37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
 11272:     38:     assert resp["success"] is True
 11273:     39:     qs = "a=1&b=2"
 11274:     40:     prehash = f"1000GET/api/test?{qs}"
 11275:     41:     expected = base64.b64encode(
 11276:     42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 11277:     43:     ).decode()
 11278:     44:     assert called["headers"]["ACCESS-SIGN"] == expected
 11279:     45:     assert called["headers"]["ACCESS-KEY"] == "key"
 11280:     46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 11281:     47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 11282:     48:     assert called["url"] == "https://test/api/test?a=1&b=2"
 11283:     49: 
 11284:     50: 
 11285:     51: def test_private_request_post_signature(monkeypatch):
 11286:     52:     client = BitgetFuturesClient("key", "secret", "https://test")
 11287:     53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 11288:     54: 
 11289:     55:     called = {}
 11290:     56: 
 11291:     57:     def fake_post(url, data=None, headers=None, timeout=None):
 11292:     58:         called["url"] = url
 11293:     59:         called["data"] = data
 11294:     60:         called["headers"] = headers
 11295:     61: 
 11296:     62:         class Resp:
 11297:     63:             def raise_for_status(self):
 11298:     64:                 pass
 11299:     65: 
 11300:     66:             def json(self):
 11301:     67:                 return {"success": True}
 11302:     68: 
 11303:     69:         return Resp()
 11304:     70: 
 11305:     71:     monkeypatch.setattr(bot.requests, "post", fake_post)
 11306:     72: 
 11307:     73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
 11308:     74:     assert resp["success"] is True
 11309:     75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
 11310:     76:     prehash = f"1000POST/api/test{body}"
 11311:     77:     expected = base64.b64encode(
 11312:     78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 11313:     79:     ).decode()
 11314:     80:     assert called["headers"]["ACCESS-SIGN"] == expected
 11315:     81:     assert called["headers"]["ACCESS-KEY"] == "key"
 11316:     82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 11317:     83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 11318:     84:     assert called["data"].decode("utf-8") == body
 11319:     85:     assert called["url"] == "https://test/api/test"
 11320:     86: 
 11321:     87: 
 11322:     88: def test_private_request_http_error(monkeypatch):
 11323:     89:     client = BitgetFuturesClient("key", "secret", "https://test")
 11324:     90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 11325:     91: 
 11326:     92:     class Resp:
 11327:     93:         status_code = 418
 11328:     94: 
 11329:     95:         def raise_for_status(self):
 11330:     96:             raise bot.requests.HTTPError("teapot")
 11331:     97: 
 11332:     98:         def json(self):
 11333:     99:             return {"unused": True}
 11334:    100: 
 11335:    101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
 11336:    102: 
 11337:    103:     resp = client._private_request("GET", "/api/test")
 11338:    104:     assert resp["success"] is False
 11339:    105:     assert resp["status_code"] == 418
 11340:    106:     assert "teapot" in resp["error"]
 11341:    107: 
 11342:    108: 
 11343:    109: def test_get_assets_normalization(monkeypatch):
 11344:    110:     client = BitgetFuturesClient("key", "secret", "https://test")
 11345:    111: 
 11346:    112:     called = {}
 11347:    113: 
 11348:    114:     def fake_private(self, method, path, params=None, body=None):
 11349:    115:         called["method"] = method
 11350:    116:         called["path"] = path
 11351:    117:         called["params"] = params
 11352:    118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
 11353:    119: 
 11354:    120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11355:    121: 
 11356:    122:     assets = client.get_assets()
 11357:    123: 
 11358:    124:     assert assets["success"] is True
 11359:    125:     usdt = assets.get("data", [])[0]
 11360:    126:     assert usdt["currency"].upper() == "USDT"
 11361:    127:     assert usdt["equity"] == 1.0
 11362:    128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
 11363:    129: 
 11364:    130: 
 11365:    131: def test_get_assets_equity_fallback(monkeypatch):
 11366:    132:     client = BitgetFuturesClient("key", "secret", "https://test")
 11367:    133: 
 11368:    134:     def fake_private(self, method, path, params=None, body=None):
 11369:    135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
 11370:    136: 
 11371:    137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11372:    138: 
 11373:    139:     assets = client.get_assets()
 11374:    140:     usdt = assets.get("data", [])[0]
 11375:    141:     assert usdt["currency"] == "USDT"
 11376:    142:     assert usdt["equity"] == 2.0
 11377:    143: 
 11378:    144: 
 11379:    145: def test_get_assets_prefers_available(monkeypatch):
 11380:    146:     """When both equity and available are returned, available should win."""
 11381:    147:     client = BitgetFuturesClient("key", "secret", "https://test")
 11382:    148: 
 11383:    149:     def fake_private(self, method, path, params=None, body=None):
 11384:    150:         return {
 11385:    151:             "code": "00000",
 11386:    152:             "data": [
 11387:    153:                 {
 11388:    154:                     "marginCoin": "USDT",
 11389:    155:                     "equity": "5",
 11390:    156:                     "available": "1",
 11391:    157:                 }
 11392:    158:             ],
 11393:    159:         }
 11394:    160: 
 11395:    161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11396:    162: 
 11397:    163:     assets = client.get_assets()
 11398:    164:     usdt = assets.get("data", [])[0]
 11399:    165:     assert usdt["equity"] == 1.0
 11400:    166: 
 11401:    167: 
 11402:    168: 
 11403:    169: def test_get_assets_zero_available(monkeypatch):
 11404:    170:     """Zero available balance should propagate as zero equity."""
 11405:    171:     client = BitgetFuturesClient("key", "secret", "https://test")
 11406:    172: 
 11407:    173:     def fake_private(self, method, path, params=None, body=None):
 11408:    174:         return {
 11409:    175:             "code": "00000",
 11410:    176:             "data": [
 11411:    177:                 {
 11412:    178:                     "marginCoin": "USDT",
 11413:    179:                     "available": "0",
 11414:    180:                     "equity": "5",
 11415:    181:                 }
 11416:    182:             ],
 11417:    183:         }
 11418:    184: 
 11419:    185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11420:    186: 
 11421:    187:     assets = client.get_assets()
 11422:    188:     usdt = assets.get("data", [])[0]
 11423:    189:     assert usdt["equity"] == 0.0
 11424:    190: 
 11425:    191: 
 11426:    192: def test_get_assets_available_balance(monkeypatch):
 11427:    193:     """Support alternative ``availableBalance`` field name."""
 11428:    194:     client = BitgetFuturesClient("key", "secret", "https://test")
 11429:    195: 
 11430:    196:     def fake_private(self, method, path, params=None, body=None):
 11431:    197:         return {
 11432:    198:             "code": "00000",
 11433:    199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
 11434:    200:         }
 11435:    201: 
 11436:    202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11437:    203: 
 11438:    204:     assets = client.get_assets()
 11439:    205:     usdt = assets.get("data", [])[0]
 11440:    206:     assert usdt["equity"] == 3.5
 11441:    207: 
 11442:    208: 
 11443:    209: def test_get_ticker_normalization(monkeypatch):
 11444:    210:     client = BitgetFuturesClient("key", "secret", "https://test")
 11445:    211: 
 11446:    212:     called = {}
 11447:    213: 
 11448:    214:     def fake_get(url, params=None, timeout=None):
 11449:    215:         called["url"] = url
 11450:    216:         called["params"] = params
 11451:    217: 
 11452:    218:         class Resp:
 11453:    219:             def raise_for_status(self):
 11454:    220:                 pass
 11455:    221: 
 11456:    222:             def json(self):
 11457:    223:                 return {
 11458:    224:                     "data": {
 11459:    225:                         "instId": "BTCUSDT",
 11460:    226:                         "lastPr": "1",
 11461:    227:                         "bestBidPrice": "0.9",
 11462:    228:                         "bestAskPrice": "1.1",
 11463:    229:                         "usdtVolume": "100",
 11464:    230:                     }
 11465:    231:                 }
 11466:    232: 
 11467:    233:         return Resp()
 11468:    234: 
 11469:    235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 11470:    236: 
 11471:    237:     ticker = client.get_ticker("BTC_USDT")
 11472:    238: 
 11473:    239:     assert ticker["success"] is True
 11474:    240:     data = ticker["data"][0]
 11475:    241:     assert data["symbol"] == "BTCUSDT"
 11476:    242:     assert data["lastPrice"] == "1"
 11477:    243:     assert data["bidPrice"] == "0.9"
 11478:    244:     assert data["askPrice"] == "1.1"
 11479:    245:     assert data["volume"] == 100.0
 11480:    246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
 11481:    247: 
 11482:    248: 
 11483:    249: def test_http_client_context_manager(monkeypatch):
 11484:    250:     import sys
 11485:    251:     import importlib
 11486:    252:     sys.modules.pop('requests', None)
 11487:    253:     real_requests = importlib.import_module('requests')
 11488:    254:     sys.modules['requests'] = real_requests
 11489:    255:     import scalper.client as http_client
 11490:    256:     importlib.reload(http_client)
 11491:    257: 
 11492:    258:     closed = {"count": 0}
 11493:    259: 
 11494:    260:     class DummySession:
 11495:    261:         def mount(self, *a, **k):
 11496:    262:             pass
 11497:    263: 
 11498:    264:         def request(self, *a, **k):
 11499:    265:             class Resp:
 11500:    266:                 def raise_for_status(self):
 11501:    267:                     pass
 11502:    268: 
 11503:    269:                 def json(self):
 11504:    270:                     return {}
 11505:    271: 
 11506:    272:                 text = "{}"
 11507:    273: 
 11508:    274:             return Resp()
 11509:    275: 
 11510:    276:         def close(self):
 11511:    277:             closed["count"] += 1
 11512:    278: 
 11513:    279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
 11514:    280: 
 11515:    281:     http = http_client.HttpClient("http://example.com")
 11516:    282:     http.close()
 11517:    283:     assert closed["count"] == 1
 11518:    284: 
 11519:    285:     closed["count"] = 0
 11520:    286:     with http_client.HttpClient("http://example.com") as hc:
 11521:    287:         hc.request("GET", "/")
 11522:    288:     assert closed["count"] == 1
 11523:    289: 
 11524:    290: 
 11525:    291: def test_get_kline_query_params(monkeypatch):
 11526:    292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
 11527:    293:     query parameter. The previous implementation embedded the symbol in the
 11528:    294:     path which resulted in a 404 from Bitget."""
 11529:    295: 
 11530:    296:     client = BitgetFuturesClient("key", "secret", "https://test")
 11531:    297: 
 11532:    298:     called = {}
 11533:    299: 
 11534:    300:     def fake_get(url, params=None, timeout=None):
 11535:    301:         called["url"] = url
 11536:    302:         called["params"] = params
 11537:    303: 
 11538:    304:         class Resp:
 11539:    305:             def raise_for_status(self):
 11540:    306:                 pass
 11541:    307: 
 11542:    308:             def json(self):
 11543:    309:                 return {"data": []}
 11544:    310: 
 11545:    311:         return Resp()
 11546:    312: 
 11547:    313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
 11548:    314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
 11549:    315:     # even if missing so we can observe the call.
 11550:    316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 11551:    317: 
 11552:    318:     client.get_kline("BTC_USDT", interval="Min1")
 11553:    319: 
 11554:    320:     assert called["url"].endswith("/api/v2/mix/market/candles")
 11555:    321:     assert called["params"] == {
 11556:    322:         "symbol": "BTCUSDT",
 11557:    323:         "productType": "USDT-FUTURES",
 11558:    324:         "granularity": "1m",
 11559:    325:     }
 11560:    326: 
 11561:    327: 
 11562:    328: def test_get_open_orders_endpoint(monkeypatch):
 11563:    329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11564:    330: 
 11565:    331:     called = {}
 11566:    332: 
 11567:    333:     def fake_private(self, method, path, params=None, body=None):
 11568:    334:         called["method"] = method
 11569:    335:         called["path"] = path
 11570:    336:         called["params"] = params
 11571:    337:         return {"success": True}
 11572:    338: 
 11573:    339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11574:    340: 
 11575:    341:     client.get_open_orders("BTCUSDT_UMCBL")
 11576:    342: 
 11577:    343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
 11578:    344:     assert called["params"] == {
 11579:    345:         "productType": "USDT-FUTURES",
 11580:    346:         "symbol": "BTCUSDT",
 11581:    347:     }
 11582:    348: 
 11583:    349: 
 11584:    350: def test_product_type_alias():
 11585:    351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
 11586:    352:     assert client.product_type == "USDT-FUTURES"
 11587:    353: 
 11588:    354: 
 11589:    355: def test_get_contract_detail_endpoint(monkeypatch):
 11590:    356:     client = BitgetFuturesClient("key", "secret", "https://test")
 11591:    357: 
 11592:    358:     called = {}
 11593:    359: 
 11594:    360:     def fake_get(url, params=None, timeout=None):
 11595:    361:         called["url"] = url
 11596:    362:         called["params"] = params
 11597:    363: 
 11598:    364:         class Resp:
 11599:    365:             status_code = 200
 11600:    366: 
 11601:    367:             def raise_for_status(self):
 11602:    368:                 pass
 11603:    369: 
 11604:    370:             def json(self):
 11605:    371:                 return {"data": []}
 11606:    372: 
 11607:    373:         return Resp()
 11608:    374: 
 11609:    375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 11610:    376: 
 11611:    377:     client.get_contract_detail("BTCUSDT_UMCBL")
 11612:    378: 
 11613:    379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
 11614:    380:     assert called["params"] == {
 11615:    381:         "productType": "USDT-FUTURES",
 11616:    382:         "symbol": "BTCUSDT",
 11617:    383:     }
 11618:    384: 
 11619:    385: 
 11620:    386: def test_cancel_all_endpoint(monkeypatch):
 11621:    387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11622:    388: 
 11623:    389:     called = {}
 11624:    390: 
 11625:    391:     def fake_private(self, method, path, params=None, body=None):
 11626:    392:         called["method"] = method
 11627:    393:         called["path"] = path
 11628:    394:         called["params"] = params
 11629:    395:         called["body"] = body
 11630:    396:         return {"success": True}
 11631:    397: 
 11632:    398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11633:    399: 
 11634:    400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 11635:    401: 
 11636:    402:     assert called["method"] == "POST"
 11637:    403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
 11638:    404:     assert called["params"] is None
 11639:    405:     assert called["body"] == {
 11640:    406:         "productType": "USDT-FUTURES",
 11641:    407:         "symbol": "BTCUSDT",
 11642:    408:         "marginCoin": "USDT",
 11643:    409:     }
 11644:    410: 
 11645:    411: 
 11646:    412: def test_place_order_endpoint(monkeypatch):
 11647:    413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11648:    414: 
 11649:    415:     called = {}
 11650:    416: 
 11651:    417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 11652:    418: 
 11653:    419:     def fake_private(self, method, path, params=None, body=None):
 11654:    420:         called["method"] = method
 11655:    421:         called["path"] = path
 11656:    422:         called["body"] = body
 11657:    423:         return {"success": True}
 11658:    424: 
 11659:    425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11660:    426: 
 11661:    427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
 11662:    428: 
 11663:    429:     assert resp["success"] is True
 11664:    430:     assert called["method"] == "POST"
 11665:    431:     assert called["path"] == "/api/v2/mix/order/place-order"
 11666:    432:     body = called["body"]
 11667:    433:     assert body["symbol"] == "BTCUSDT"
 11668:    434:     assert body["marginCoin"] == "USDT"
 11669:    435:     assert body["marginMode"] == "crossed"
 11670:    436:     assert body["side"] == "buy"
 11671:    437:     assert body["posSide"] == "long"
 11672:    438:     assert "reduceOnly" not in body
 11673:    439:     assert body["posMode"] == "hedge_mode"
 11674:    440: 
 11675:    441: 
 11676:    442: @pytest.mark.parametrize(
 11677:    443:     "code, side_str, pos_side",
 11678:    444:     [
 11679:    445:         (4, "sell", "long"),
 11680:    446:         (2, "buy", "short"),
 11681:    447:     ],
 11682:    448: )
 11683:    449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
 11684:    450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11685:    451: 
 11686:    452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 11687:    453: 
 11688:    454:     called = {}
 11689:    455: 
 11690:    456:     def fake_private(self, method, path, params=None, body=None):
 11691:    457:         called["body"] = body
 11692:    458:         return {"success": True}
 11693:    459: 
 11694:    460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11695:    461: 
 11696:    462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
 11697:    463: 
 11698:    464:     body = called["body"]
 11699:    465:     assert body["side"] == side_str
 11700:    466:     assert body["posSide"] == pos_side
 11701:    467:     assert "reduceOnly" not in body
 11702:    468: 
 11703:    469: 
 11704:    470: def test_place_order_precision(monkeypatch):
 11705:    471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11706:    472: 
 11707:    473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
 11708:    474: 
 11709:    475:     called = {}
 11710:    476: 
 11711:    477:     def fake_private(self, method, path, params=None, body=None):
 11712:    478:         called["body"] = body
 11713:    479:         return {"success": True}
 11714:    480: 
 11715:    481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11716:    482: 
 11717:    483:     client.place_order(
 11718:    484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
 11719:    485:     )
 11720:    486: 
 11721:    487:     assert called["body"]["price"] == 1234.57
 11722:    488:     assert called["body"]["size"] == 1.235
 11723:    489: 
 11724:    490: 
 11725:    491: def test_margin_cap_skips_order(monkeypatch):
 11726:    492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11727:    493:     called = {}
 11728:    494: 
 11729:    495:     def fake_private(method, path, **kwargs):
 11730:    496:         called["path"] = path
 11731:    497:         return {"code": "00000"}
 11732:    498: 
 11733:    499:     monkeypatch.setattr(client, "_private_request", fake_private)
 11734:    500:     contract_detail = {
 11735:    501:         "data": {
 11736:    502:             "symbol": "BTCUSDT_UMCBL",
 11737:    503:             "contractSize": 1,
 11738:    504:             "volUnit": 1,
 11739:    505:             "minVol": 1,
 11740:    506:             "minTradeUSDT": 5,
 11741:    507:         }
 11742:    508:     }
 11743:    509:     price = 100.0
 11744:    510:     available = 0.5
 11745:    511:     vol = bot.compute_position_size(
 11746:    512:         contract_detail,
 11747:    513:         equity_usdt=available,
 11748:    514:         price=price,
 11749:    515:         risk_pct=1.0,
 11750:    516:         leverage=10,
 11751:    517:         symbol="BTCUSDT_UMCBL",
 11752:    518:         available_usdt=available,
 11753:    519:     )
 11754:    520:     if vol > 0:
 11755:    521:         client.place_order(
 11756:    522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
 11757:    523:         )
 11758:    524:     assert called == {}
 11759:    525: 
 11760:    526: 
 11761:    527: def test_margin_cap_reduces_volume(monkeypatch):
 11762:    528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 11763:    529:     called = {}
 11764:    530: 
 11765:    531:     def fake_private(method, path, **kwargs):
 11766:    532:         called["body"] = kwargs.get("body")
 11767:    533:         return {"code": "00000"}
 11768:    534: 
 11769:    535:     monkeypatch.setattr(client, "_private_request", fake_private)
 11770:    536:     contract_detail = {
 11771:    537:         "data": {
 11772:    538:             "symbol": "BTCUSDT_UMCBL",
 11773:    539:             "contractSize": 1,
 11774:    540:             "volUnit": 1,
 11775:    541:             "minVol": 1,
 11776:    542:             "minTradeUSDT": 5,
 11777:    543:         }
 11778:    544:     }
 11779:    545:     price = 10.0
 11780:    546:     vol_theoretical = bot.compute_position_size(
 11781:    547:         contract_detail,
 11782:    548:         equity_usdt=100,
 11783:    549:         price=price,
 11784:    550:         risk_pct=1.0,
 11785:    551:         leverage=10,
 11786:    552:         symbol="BTCUSDT_UMCBL",
 11787:    553:     )
 11788:    554:     available = 20.0
 11789:    555:     vol_final = bot.compute_position_size(
 11790:    556:         contract_detail,
 11791:    557:         equity_usdt=available,
 11792:    558:         price=price,
 11793:    559:         risk_pct=1.0,
 11794:    560:         leverage=10,
 11795:    561:         symbol="BTCUSDT_UMCBL",
 11796:    562:         available_usdt=available,
 11797:    563:     )
 11798:    564:     assert vol_final < vol_theoretical
 11799:    565:     client.place_order(
 11800:    566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
 11801:    567:     )
 11802:    568:     assert called["body"]["size"] == vol_final
 11803:    569: 
 11804:    570: def test_get_open_orders_paper_trade(monkeypatch):
 11805:    571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 11806:    572: 
 11807:    573:     called = {"count": 0}
 11808:    574: 
 11809:    575:     def fake_private(*a, **k):
 11810:    576:         called["count"] += 1
 11811:    577:         return {"success": True}
 11812:    578: 
 11813:    579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11814:    580: 
 11815:    581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
 11816:    582: 
 11817:    583:     assert resp["success"] is True
 11818:    584:     assert resp["data"] == []
 11819:    585:     assert called["count"] == 0
 11820:    586: 
 11821:    587: 
 11822:    588: def test_cancel_all_paper_trade(monkeypatch):
 11823:    589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 11824:    590: 
 11825:    591:     called = {"count": 0}
 11826:    592: 
 11827:    593:     def fake_private(*a, **k):
 11828:    594:         called["count"] += 1
 11829:    595:         return {"success": True}
 11830:    596: 
 11831:    597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 11832:    598: 
 11833:    599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 11834:    600: 
 11835:    601:     assert resp["success"] is True
 11836:    602:     assert called["count"] == 0
 11837:    603: 
 11838:    604: 
 11839:    605: def test_get_kline_transforms_data(monkeypatch):
 11840:    606:     client = BitgetFuturesClient("key", "secret", "https://test")
 11841:    607: 
 11842:    608:     def fake_get(url, params=None, timeout=None):
 11843:    609:         class Resp:
 11844:    610:             def raise_for_status(self):
 11845:    611:                 pass
 11846:    612: 
 11847:    613:             def json(self):
 11848:    614:                 return {
 11849:    615:                     "data": [
 11850:    616:                         ["1", "2", "3", "1", "2", "10", "20"],
 11851:    617:                         ["2", "3", "4", "2", "3", "11", "21"],
 11852:    618:                     ]
 11853:    619:                 }
 11854:    620: 
 11855:    621:         return Resp()
 11856:    622: 
 11857:    623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 11858:    624: 
 11859:    625:     data = client.get_kline("BTC_USDT", interval="1m")
 11860:    626:     kdata = data["data"]
 11861:    627:     assert kdata["open"] == [2.0, 3.0]
 11862:    628:     assert kdata["high"] == [3.0, 4.0]
 11863:    629:     assert kdata["low"] == [1.0, 2.0]
 11864:    630:     assert kdata["close"] == [2.0, 3.0]
 11865:    631:     assert kdata["volume"] == [10.0, 11.0]
 11866:    632:     assert kdata["quoteVolume"] == [20.0, 21.0]
 11867: 
 11868: 
 11869: ## tests/test_compute_position_size.py (last modified: 2025-08-23 20:57:14)
 11870:      1: import os
 11871:      2: import sys
 11872:      3: import types
 11873:      4: import pytest
 11874:      5: 
 11875:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 11876:      7: sys.modules["requests"] = types.ModuleType("requests")
 11877:      8: import bot  # noqa: E402
 11878:      9: from bot import compute_position_size  # noqa: E402
 11879:     10: 
 11880:     11: 
 11881:     12: def test_compute_position_size_basic():
 11882:     13:     contract_detail = {
 11883:     14:         "data": [
 11884:     15:             {
 11885:     16:                 "symbol": "BTC_USDT",
 11886:     17:                 "contractSize": 0.01,
 11887:     18:                 "volUnit": 1,
 11888:     19:                 "minVol": 1,
 11889:     20:             }
 11890:     21:         ]
 11891:     22:     }
 11892:     23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
 11893:     24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 11894:     25:     assert vol == 1
 11895:     26: 
 11896:     27: 
 11897:     28: def test_compute_position_size_symbol_not_found():
 11898:     29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
 11899:     30:     with pytest.raises(ValueError):
 11900:     31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
 11901:     32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 11902:     33: 
 11903:     34: 
 11904:     35: def test_compute_position_size_invalid_price():
 11905:     36:     contract_detail = {
 11906:     37:         "data": [
 11907:     38:             {
 11908:     39:                 "symbol": "BTC_USDT",
 11909:     40:                 "contractSize": 0.01,
 11910:     41:                 "volUnit": 1,
 11911:     42:                 "minVol": 1,
 11912:     43:             }
 11913:     44:         ]
 11914:     45:     }
 11915:     46:     vol = compute_position_size(
 11916:     47:         contract_detail,
 11917:     48:         equity_usdt=1000,
 11918:     49:         price=0,
 11919:     50:         risk_pct=0.01,
 11920:     51:         leverage=10,
 11921:     52:         symbol="BTC_USDT",
 11922:     53:     )
 11923:     54:     assert vol == 0
 11924:     55: 
 11925:     56: 
 11926:     57: def test_compute_position_size_respects_equity():
 11927:     58:     contract_detail = {
 11928:     59:         "data": [
 11929:     60:             {
 11930:     61:                 "symbol": "BTC_USDT",
 11931:     62:                 "contractSize": 1,
 11932:     63:                 "volUnit": 1,
 11933:     64:                 "minVol": 1,
 11934:     65:             }
 11935:     66:         ]
 11936:     67:     }
 11937:     68:     vol = compute_position_size(
 11938:     69:         contract_detail,
 11939:     70:         equity_usdt=5,
 11940:     71:         price=100,
 11941:     72:         risk_pct=0.01,
 11942:     73:         leverage=10,
 11943:     74:         symbol="BTC_USDT",
 11944:     75:     )
 11945:     76:     assert vol == 0
 11946:     77: 
 11947:     78: 
 11948:     79: def test_compute_position_size_leaves_fee_buffer():
 11949:     80:     contract_detail = {
 11950:     81:         "data": [
 11951:     82:             {
 11952:     83:                 "symbol": "BTC_USDT",
 11953:     84:                 "contractSize": 1,
 11954:     85:                 "volUnit": 1,
 11955:     86:                 "minVol": 1,
 11956:     87:             }
 11957:     88:         ]
 11958:     89:     }
 11959:     90:     vol = compute_position_size(
 11960:     91:         contract_detail,
 11961:     92:         equity_usdt=100,
 11962:     93:         price=100,
 11963:     94:         risk_pct=1.0,
 11964:     95:         leverage=1,
 11965:     96:         symbol="BTC_USDT",
 11966:     97:     )
 11967:     98:     assert vol == 0
 11968:     99: 
 11969:    100: 
 11970:    101: def test_compute_position_size_under_min_notional_returns_zero():
 11971:    102:     contract_detail = {
 11972:    103:         "data": [
 11973:    104:             {
 11974:    105:                 "symbol": "PI_USDT",
 11975:    106:                 "contractSize": 1,
 11976:    107:                 "volUnit": 1,
 11977:    108:                 "minVol": 1,
 11978:    109:                 "minTradeUSDT": 5,
 11979:    110:             }
 11980:    111:         ]
 11981:    112:     }
 11982:    113:     vol = compute_position_size(
 11983:    114:         contract_detail,
 11984:    115:         equity_usdt=100,
 11985:    116:         price=0.5,
 11986:    117:         risk_pct=0.0001,
 11987:    118:         leverage=20,
 11988:    119:         symbol="PI_USDT",
 11989:    120:     )
 11990:    121:     assert vol == 0
 11991:    122: 
 11992:    123: 
 11993:    124: def test_compute_position_size_cap_by_available():
 11994:    125:     contract_detail = {
 11995:    126:         "data": [
 11996:    127:             {
 11997:    128:                 "symbol": "BTC_USDT",
 11998:    129:                 "contractSize": 1,
 11999:    130:                 "volUnit": 2,
 12000:    131:                 "minVol": 2,
 12001:    132:                 "minTradeUSDT": 5,
 12002:    133:             }
 12003:    134:         ]
 12004:    135:     }
 12005:    136:     vol = compute_position_size(
 12006:    137:         contract_detail,
 12007:    138:         equity_usdt=100,
 12008:    139:         price=10,
 12009:    140:         risk_pct=0.5,
 12010:    141:         leverage=10,
 12011:    142:         symbol="BTC_USDT",
 12012:    143:         available_usdt=0.5,
 12013:    144:     )
 12014:    145:     assert vol == 0
 12015:    146:     vol = compute_position_size(
 12016:    147:         contract_detail,
 12017:    148:         equity_usdt=100,
 12018:    149:         price=10,
 12019:    150:         risk_pct=0.5,
 12020:    151:         leverage=10,
 12021:    152:         symbol="BTC_USDT",
 12022:    153:         available_usdt=10,
 12023:    154:     )
 12024:    155:     assert vol == 8
 12025:    156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
 12026:    157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
 12027:    158:     assert required <= 10
 12028: 
 12029: 
 12030: ## tests/test_compute_position_size_cap.py (last modified: 2025-08-23 20:57:14)
 12031:      1: import os
 12032:      2: import sys
 12033:      3: import types
 12034:      4: import pytest
 12035:      5: 
 12036:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12037:      7: sys.modules['requests'] = types.ModuleType('requests')
 12038:      8: 
 12039:      9: from bot import compute_position_size, CONFIG
 12040:     10: 
 12041:     11: 
 12042:     12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
 12043:     13:     return {
 12044:     14:         "data": [
 12045:     15:             {
 12046:     16:                 "symbol": "BTC_USDT",
 12047:     17:                 "contractSize": 0.001,
 12048:     18:                 "volUnit": vol_unit,
 12049:     19:                 "minVol": min_vol,
 12050:     20:                 "minTradeUSDT": min_trade,
 12051:     21:             }
 12052:     22:         ]
 12053:     23:     }
 12054:     24: 
 12055:     25: 
 12056:     26: def test_volume_zero_when_available_low():
 12057:     27:     detail = _detail()
 12058:     28:     vol = compute_position_size(
 12059:     29:         detail,
 12060:     30:         equity_usdt=1000,
 12061:     31:         price=10000,
 12062:     32:         risk_pct=0.01,
 12063:     33:         leverage=10,
 12064:     34:         symbol="BTC_USDT",
 12065:     35:         available_usdt=0.5,
 12066:     36:     )
 12067:     37:     assert vol == 0
 12068:     38: 
 12069:     39: 
 12070:     40: def test_margin_close_to_available():
 12071:     41:     detail = _detail()
 12072:     42:     CONFIG["FEE_RATE"] = 0.001
 12073:     43:     available = 1.05
 12074:     44:     vol = compute_position_size(
 12075:     45:         detail,
 12076:     46:         equity_usdt=1000,
 12077:     47:         price=10000,
 12078:     48:         risk_pct=1,
 12079:     49:         leverage=10,
 12080:     50:         symbol="BTC_USDT",
 12081:     51:         available_usdt=available,
 12082:     52:     )
 12083:     53:     assert vol == 1
 12084:     54:     notional = 10000 * 0.001 * vol
 12085:     55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
 12086:     56:     required = (notional / 10 + fee) * 1.03
 12087:     57:     assert required == pytest.approx(available, rel=0.05)
 12088:     58: 
 12089:     59: 
 12090:     60: def test_respects_units_and_minimums():
 12091:     61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
 12092:     62:     vol = compute_position_size(
 12093:     63:         detail,
 12094:     64:         equity_usdt=1000,
 12095:     65:         price=1000,
 12096:     66:         risk_pct=1,
 12097:     67:         leverage=5,
 12098:     68:         symbol="BTC_USDT",
 12099:     69:         available_usdt=1000,
 12100:     70:     )
 12101:     71:     assert vol % 2 == 0 and vol >= 2
 12102: 
 12103: 
 12104: ## tests/test_dynamic_allocation.py (last modified: 2025-08-23 20:57:14)
 12105:      1: import math
 12106:      2: from scalper.risk import adjust_risk_pct
 12107:      3: 
 12108:      4: 
 12109:      5: def test_adjust_risk_pct_increase_decrease():
 12110:      6:     base = 0.01
 12111:      7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
 12112:      8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
 12113:      9: 
 12114:     10: 
 12115:     11: def test_adjust_risk_pct_bounds():
 12116:     12:     assert math.isclose(
 12117:     13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
 12118:     14:     )
 12119:     15:     assert math.isclose(
 12120:     16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
 12121:     17:     )
 12122: 
 12123: 
 12124: ## tests/test_effective_leverage.py (last modified: 2025-08-23 20:57:14)
 12125:      1: import pytest
 12126:      2: from scalper.trade_utils import effective_leverage
 12127:      3: 
 12128:      4: 
 12129:      5: def test_effective_leverage_basic():
 12130:      6:     lev = effective_leverage(
 12131:      7:         entry_price=100.0,
 12132:      8:         liquidation_price=90.0,
 12133:      9:         position_margin=10.0,
 12134:     10:         position_size=1.0,
 12135:     11:     )
 12136:     12:     assert lev == pytest.approx(10.0)
 12137:     13: 
 12138:     14: 
 12139:     15: def test_effective_leverage_estimated_margin():
 12140:     16:     lev = effective_leverage(
 12141:     17:         entry_price=200.0,
 12142:     18:         liquidation_price=180.0,
 12143:     19:         position_margin=0.0,
 12144:     20:         position_size=2.0,
 12145:     21:     )
 12146:     22:     # price diff 20 * size 2 -> margin 40; notional 400
 12147:     23:     assert lev == pytest.approx(10.0)
 12148:     24: 
 12149:     25: 
 12150:     26: def test_effective_leverage_short_position():
 12151:     27:     lev = effective_leverage(
 12152:     28:         entry_price=100.0,
 12153:     29:         liquidation_price=110.0,
 12154:     30:         position_margin=10.0,
 12155:     31:         position_size=-1.5,
 12156:     32:     )
 12157:     33:     assert lev == pytest.approx(15.0)
 12158:     34: 
 12159:     35: 
 12160:     36: def test_effective_leverage_invalid():
 12161:     37:     assert effective_leverage(0, 0, 0, 0) == 0.0
 12162: 
 12163: 
 12164: ## tests/test_env_loading.py (last modified: 2025-08-23 20:57:14)
 12165:      1: """Tests for loading environment variables from ``notebook/.env``."""
 12166:      2: 
 12167:      3: from __future__ import annotations
 12168:      4: 
 12169:      5: import importlib
 12170:      6: import os
 12171:      7: import sys
 12172:      8: from pathlib import Path
 12173:      9: 
 12174:     10: 
 12175:     11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
 12176:     12:     """Module should load variables from ``notebook/.env`` if present."""
 12177:     13: 
 12178:     14:     notebook = tmp_path / "notebook"
 12179:     15:     spot = notebook / "spot"
 12180:     16:     spot.mkdir(parents=True)
 12181:     17:     bitget_bot = spot / "bitget_bot.py"
 12182:     18:     bitget_bot.write_text("")
 12183:     19:     env_file = notebook / ".env"
 12184:     20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
 12185:     21: 
 12186:     22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
 12187:     23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
 12188:     24:     import scalp
 12189:     25: 
 12190:     26:     importlib.reload(scalp)
 12191:     27: 
 12192:     28:     try:
 12193:     29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
 12194:     30:     finally:
 12195:     31:         env_file.unlink(missing_ok=True)
 12196:     32:         if old is None:
 12197:     33:             os.environ.pop("BITGET_ACCESS_KEY", None)
 12198:     34:         else:
 12199:     35:             os.environ["BITGET_ACCESS_KEY"] = old
 12200: 
 12201: 
 12202: ## tests/test_grid_search.py (last modified: 2025-08-23 20:57:14)
 12203:      1: import json
 12204:      2: import random
 12205:      3: 
 12206:      4: import pytest
 12207:      5: 
 12208:      6: from scalper.backtest import grid_search
 12209:      7: 
 12210:      8: 
 12211:      9: def test_build_grid_sampling():
 12212:     10:     param_lists = {
 12213:     11:         "timeframe": ["1m", "5m", "15m"],
 12214:     12:         "score_min": [50, 55, 60],
 12215:     13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
 12216:     14:     }
 12217:     15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
 12218:     16:     assert len(combos) == 6
 12219:     17:     tfs = {c["timeframe"] for c in combos}
 12220:     18:     assert {"1m", "5m", "15m"}.issubset(tfs)
 12221:     19: 
 12222:     20: 
 12223:     21: def test_run_grid_search_with_mock(tmp_path):
 12224:     22:     calls = []
 12225:     23: 
 12226:     24:     def fake_run_backtest_multi(**kwargs):
 12227:     25:         tf = kwargs.get("timeframe")
 12228:     26:         risk = kwargs.get("risk_pct")
 12229:     27:         # fabricate metrics based on params
 12230:     28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
 12231:     29:         pf += risk  # tiny variation
 12232:     30:         metrics = {
 12233:     31:             "symbol": "TOTAL",
 12234:     32:             "pnl_usdt": 100 * risk,
 12235:     33:             "profit_factor": pf,
 12236:     34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
 12237:     35:             "winrate_pct": 50.0,
 12238:     36:             "trades": 40 if tf == "1m" else 30,
 12239:     37:         }
 12240:     38:         calls.append((tf, risk))
 12241:     39:         return [metrics], []
 12242:     40: 
 12243:     41:     param_lists = {
 12244:     42:         "timeframe": ["1m", "5m"],
 12245:     43:         "risk_pct": [0.005, 0.01],
 12246:     44:     }
 12247:     45:     base_params = {
 12248:     46:         "timeframe": "1m",
 12249:     47:         "risk_pct": 0.005,
 12250:     48:     }
 12251:     49:     out_dir = tmp_path / "grid"
 12252:     50:     grid_search.run_grid_search(
 12253:     51:         symbols=["BTC/USDT"],
 12254:     52:         exchange="csv",
 12255:     53:         base_params=base_params,
 12256:     54:         param_lists=param_lists,
 12257:     55:         grid_max=4,
 12258:     56:         csv_dir="/dev/null",
 12259:     57:         out_dir=str(out_dir),
 12260:     58:         run_func=fake_run_backtest_multi,
 12261:     59:     )
 12262:     60:     best = json.loads((out_dir / "best_config.json").read_text())
 12263:     61:     # best PF should be timeframe 5m risk 0.01
 12264:     62:     assert best["params"]["timeframe"] == "5m"
 12265:     63:     assert best["params"]["risk_pct"] == 0.01
 12266:     64:     assert len(calls) == 4
 12267:     65: 
 12268:     66: 
 12269:     67: def test_parse_hours():
 12270:     68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
 12271:     69: 
 12272:     70: 
 12273:     71: def test_deterministic_results(tmp_path):
 12274:     72:     def fake_run_backtest_multi(**kwargs):
 12275:     73:         # metrics vary with global random state
 12276:     74:         pf = random.uniform(1.0, 3.0)
 12277:     75:         metrics = {
 12278:     76:             "symbol": "TOTAL",
 12279:     77:             "pnl_usdt": random.uniform(-10, 10),
 12280:     78:             "profit_factor": pf,
 12281:     79:             "max_drawdown_pct": random.uniform(1, 5),
 12282:     80:             "winrate_pct": 50.0,
 12283:     81:             "trades": random.randint(10, 50),
 12284:     82:         }
 12285:     83:         return [metrics], []
 12286:     84: 
 12287:     85:     param_lists = {"timeframe": ["1m", "5m"]}
 12288:     86:     base_params = {"timeframe": "1m"}
 12289:     87:     out_dir = tmp_path / "grid"
 12290:     88:     res1 = grid_search.run_grid_search(
 12291:     89:         symbols=["BTC/USDT"],
 12292:     90:         exchange="csv",
 12293:     91:         base_params=base_params,
 12294:     92:         param_lists=param_lists,
 12295:     93:         grid_max=2,
 12296:     94:         csv_dir="/dev/null",
 12297:     95:         out_dir=str(out_dir),
 12298:     96:         seed=42,
 12299:     97:         run_func=fake_run_backtest_multi,
 12300:     98:     )
 12301:     99:     best1 = json.loads((out_dir / "best_config.json").read_text())
 12302:    100:     # run again
 12303:    101:     out_dir2 = tmp_path / "grid2"
 12304:    102:     res2 = grid_search.run_grid_search(
 12305:    103:         symbols=["BTC/USDT"],
 12306:    104:         exchange="csv",
 12307:    105:         base_params=base_params,
 12308:    106:         param_lists=param_lists,
 12309:    107:         grid_max=2,
 12310:    108:         csv_dir="/dev/null",
 12311:    109:         out_dir=str(out_dir2),
 12312:    110:         seed=42,
 12313:    111:         run_func=fake_run_backtest_multi,
 12314:    112:     )
 12315:    113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
 12316:    114:     assert best1 == best2
 12317:    115:     # also ensure results object same best params
 12318:    116:     assert res1[0].params == res2[0].params
 12319: 
 12320: 
 12321: ## tests/test_heat_score.py (last modified: 2025-08-23 20:57:14)
 12322:      1: from scalper.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
 12323:      2: 
 12324:      3: 
 12325:      4: def test_heat_score_value():
 12326:      5:     assert heat_score(2.0, 100.0) == 200.0
 12327:      6:     assert heat_score(2.0, 100.0, news=True) == 400.0
 12328:      7: 
 12329:      8: 
 12330:      9: def test_select_and_decorrelate_pairs():
 12331:     10:     pairs = [
 12332:     11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
 12333:     12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
 12334:     13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
 12335:     14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
 12336:     15:     ]
 12337:     16:     top = select_top_heat_pairs(pairs, top_n=3)
 12338:     17:     assert len(top) == 3
 12339:     18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
 12340:     19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
 12341:     20:     syms = {p["symbol"] for p in selected}
 12342:     21:     assert not ("A" in syms and "B" in syms)
 12343: 
 12344: 
 12345: ## tests/test_indicators.py (last modified: 2025-08-23 20:57:14)
 12346:      1: 
 12347:      2: 
 12348:      3: import os
 12349:      4: import sys
 12350:      5: import pytest
 12351:      6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12352:      7: 
 12353:      8: 
 12354:      9: 
 12355:     10: 
 12356:     11: from scalper.metrics import calc_rsi, calc_atr, calc_macd
 12357:     12: 
 12358:     13: 
 12359:     14: def test_calc_rsi_uptrend():
 12360:     15:     prices = list(range(1, 16))  # strictly increasing
 12361:     16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
 12362:     17: 
 12363:     18: 
 12364:     19: def test_calc_rsi_downtrend():
 12365:     20:     prices = list(range(15, 0, -1))  # strictly decreasing
 12366:     21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
 12367:     22: 
 12368:     23: 
 12369:     24: 
 12370:     25: def test_calc_rsi_flat():
 12371:     26:     prices = [1.0] * 15  # no movement
 12372:     27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
 12373:     28: 
 12374:     29: 
 12375:     30: 
 12376:     31:     highs = [10, 11, 12, 13, 14]
 12377:     32:     lows = [9, 10, 11, 12, 13]
 12378:     33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
 12379:     34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
 12380:     35: 
 12381:     36: 
 12382:     37: def test_calc_macd_trend():
 12383:     38:     prices = list(range(1, 60))
 12384:     39:     macd, signal, hist = calc_macd(prices)
 12385:     40:     assert macd > signal
 12386:     41:     assert hist > 0
 12387:     42: 
 12388:     43: 
 12389:     44: def test_calc_macd_flat():
 12390:     45:     prices = [100.0] * 60
 12391:     46:     macd, signal, hist = calc_macd(prices)
 12392:     47:     assert macd == pytest.approx(0.0)
 12393:     48:     assert signal == pytest.approx(0.0)
 12394:     49:     assert hist == pytest.approx(0.0)
 12395:     50: 
 12396:     51: 
 12397:     52: 
 12398:     53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
 12399:     54: def test_calc_rsi_invalid_inputs(prices, period):
 12400:     55:     with pytest.raises(ValueError):
 12401:     56:         calc_rsi(prices, period=period)
 12402:     57: 
 12403:     58: 
 12404:     59: @pytest.mark.parametrize(
 12405:     60:     "highs, lows, closes, period",
 12406:     61:     [
 12407:     62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
 12408:     63:         ([1, 2], [1, 1], [1, 1], 3),
 12409:     64:     ],
 12410:     65: )
 12411:     66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
 12412:     67:     with pytest.raises(ValueError):
 12413:     68:         calc_atr(highs, lows, closes, period=period)
 12414:     69: 
 12415: 
 12416: 
 12417: ## tests/test_min_qty_rules.py (last modified: 2025-08-23 20:57:14)
 12418:      1: import os
 12419:      2: import sys
 12420:      3: import types
 12421:      4: 
 12422:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12423:      6: sys.modules['requests'] = types.ModuleType('requests')
 12424:      7: 
 12425:      8: from bot import _apply_contract_checks
 12426:      9: 
 12427:     10: 
 12428:     11: def _detail():
 12429:     12:     return {
 12430:     13:         "data": [
 12431:     14:             {
 12432:     15:                 "symbol": "BTC_USDT",
 12433:     16:                 "contractSize": 1,
 12434:     17:                 "volUnit": 5,
 12435:     18:                 "minVol": 10,
 12436:     19:                 "minTradeUSDT": 5,
 12437:     20:             }
 12438:     21:         ]
 12439:     22:     }
 12440:     23: 
 12441:     24: 
 12442:     25: def test_min_qty_floor_and_validation():
 12443:     26:     detail = _detail()
 12444:     27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
 12445:     28:     assert vol == 10
 12446:     29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
 12447:     30:     assert vol2 == 0
 12448: 
 12449: 
 12450: ## tests/test_notifier.py (last modified: 2025-08-23 20:57:14)
 12451:      1: import scalper.notifier as notifier
 12452:      2: 
 12453:      3: 
 12454:      4: def test_notify_skips_without_targets(monkeypatch):
 12455:      5:     called = False
 12456:      6: 
 12457:      7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
 12458:      8:         nonlocal called
 12459:      9:         called = True
 12460:     10: 
 12461:     11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 12462:     12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 12463:     13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 12464:     14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 12465:     15:     notifier.notify("test", {"foo": 1})
 12466:     16:     assert called is False
 12467:     17: 
 12468:     18: 
 12469:     19: def test_notify_posts_http(monkeypatch):
 12470:     20:     payload = {}
 12471:     21: 
 12472:     22:     def fake_post(url, json=None, timeout=5):
 12473:     23:         payload["url"] = url
 12474:     24:         payload["json"] = json
 12475:     25:         payload["timeout"] = timeout
 12476:     26: 
 12477:     27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 12478:     28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 12479:     29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 12480:     30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 12481:     31:     notifier.notify("evt", {"bar": 2})
 12482:     32:     assert payload["url"] == "http://example.com"
 12483:     33:     assert payload["json"]["event"] == "evt"
 12484:     34:     assert payload["json"]["bar"] == 2
 12485:     35: 
 12486:     36: 
 12487:     37: def test_notify_posts_telegram(monkeypatch):
 12488:     38:     payload = {}
 12489:     39: 
 12490:     40:     def fake_post(url, json=None, timeout=5):
 12491:     41:         payload["url"] = url
 12492:     42:         payload["json"] = json
 12493:     43:         payload["timeout"] = timeout
 12494:     44: 
 12495:     45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 12496:     46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 12497:     47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 12498:     48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 12499:     49: 
 12500:     50:     notifier.notify("evt", {"bar": 2})
 12501:     51: 
 12502:     52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
 12503:     53:     assert payload["json"]["chat_id"] == "123"
 12504:     54:     assert "evt" in payload["json"]["text"]
 12505:     55: 
 12506:     56: 
 12507:     57: def test_notify_posts_both(monkeypatch):
 12508:     58:     calls = []
 12509:     59: 
 12510:     60:     def fake_post(url, json=None, timeout=5):
 12511:     61:         calls.append({"url": url, "json": json, "timeout": timeout})
 12512:     62: 
 12513:     63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 12514:     64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 12515:     65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 12516:     66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 12517:     67: 
 12518:     68:     notifier.notify("evt", {"bar": 2})
 12519:     69: 
 12520:     70:     assert len(calls) == 2
 12521:     71:     urls = {c["url"] for c in calls}
 12522:     72:     assert "http://example.com" in urls
 12523:     73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
 12524:     74: 
 12525:     75: 
 12526:     76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
 12527:     77:     calls = []
 12528:     78: 
 12529:     79:     def fake_post(url, json=None, timeout=5):
 12530:     80:         calls.append(url)
 12531:     81: 
 12532:     82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 12533:     83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 12534:     84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 12535:     85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 12536:     86: 
 12537:     87:     notifier.notify("pair_list", {"pairs": "BTC"})
 12538:     88: 
 12539:     89:     # Only the generic webhook should be called, not Telegram
 12540:     90:     assert calls == ["http://example.com"]
 12541:     91: 
 12542:     92: 
 12543:     93: def test_format_text_open_position():
 12544:     94:     payload = {
 12545:     95:         "symbol": "BTCUSDT",
 12546:     96:         "side": "short",
 12547:     97:         "price": 18350,
 12548:     98:         "vol": 37,
 12549:     99:         "contract_size": 1,
 12550:    100:         "notional_usdt": 120.5,
 12551:    101:         "leverage": 5,
 12552:    102:         "required_margin_usdt": 25.3,
 12553:    103:         "available_usdt": 134,
 12554:    104:         "risk_level_user": 3,
 12555:    105:         "signal_level": 2,
 12556:    106:         "risk_color": "🟡",
 12557:    107:         "risk_pct_eff": 0.01,
 12558:    108:         "fee_rate": 0.001,
 12559:    109:     }
 12560:    110:     text = notifier._format_text("position_opened", payload)
 12561:    111:     lines = text.splitlines()
 12562:    112: 
 12563:    113:     assert lines[0] == "🟡 Ouvre short BTC"
 12564:    114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
 12565:    115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
 12566:    116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
 12567:    117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
 12568:    118: 
 12569:    119: 
 12570:    120: def test_format_text_closed_position():
 12571:    121:     payload = {
 12572:    122:         "symbol": "BTCUSDT",
 12573:    123:         "side": "short",
 12574:    124:         "entry_price": 18350,
 12575:    125:         "exit_price": 18328,
 12576:    126:         "vol": 37,
 12577:    127:         "contract_size": 1,
 12578:    128:         "notional_entry_usdt": 120.5,
 12579:    129:         "notional_exit_usdt": 120.3,
 12580:    130:         "fees_usdt": 0.03,
 12581:    131:         "pnl_usdt": 0.84,
 12582:    132:         "pnl_pct_on_margin": 3.25,
 12583:    133:         "leverage": 5,
 12584:    134:         "risk_color": "🟡",
 12585:    135:         "fee_rate": 0.001,
 12586:    136:     }
 12587:    137:     text = notifier._format_text("position_closed", payload)
 12588:    138:     lines = text.splitlines()
 12589:    139:     assert lines[0] == "Ferme short BTC 🟡"
 12590:    140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
 12591:    141:     assert lines[2] == "% sur marge: 3.25%"
 12592:    142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
 12593:    143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
 12594:    144: 
 12595:    145: 
 12596:    146: def test_format_text_pair_list_and_start():
 12597:    147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
 12598:    148:     text = notifier._format_text(
 12599:    149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
 12600:    150:     )
 12601:    151:     assert text == "Listing ok"
 12602:    152: 
 12603:    153: 
 12604:    154: def test_format_pair_list_helper():
 12605:    155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
 12606:    156:     text = notifier._format_pair_list(payload)
 12607:    157:     assert text == "Listing ok"
 12608:    158: 
 12609:    159: 
 12610:    160: def test_format_position_event_helper():
 12611:    161:     payload = {
 12612:    162:         "symbol": "BTCUSDT",
 12613:    163:         "side": "short",
 12614:    164:         "price": 18350,
 12615:    165:         "vol": 37,
 12616:    166:         "contract_size": 1,
 12617:    167:         "notional_usdt": 120.5,
 12618:    168:         "leverage": 5,
 12619:    169:         "required_margin_usdt": 25.3,
 12620:    170:         "available_usdt": 134,
 12621:    171:         "risk_level_user": 3,
 12622:    172:         "signal_level": 2,
 12623:    173:         "risk_color": "🟡",
 12624:    174:         "risk_pct_eff": 0.01,
 12625:    175:         "fee_rate": 0.001,
 12626:    176:     }
 12627:    177:     text = notifier._format_position_event("position_opened", payload)
 12628:    178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
 12629:    179: 
 12630:    180: 
 12631: 
 12632: 
 12633: ## tests/test_notional_and_pnl_units.py (last modified: 2025-08-23 20:57:14)
 12634:      1: import os, sys, types, pytest
 12635:      2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12636:      3: sys.modules['requests'] = types.ModuleType('requests')
 12637:      4: 
 12638:      5: from scalper.trade_utils import (
 12639:      6:     get_contract_size,
 12640:      7:     notional as calc_notional,
 12641:      8:     required_margin as calc_required_margin,
 12642:      9:     compute_pnl_usdt,
 12643:     10:     compute_pnl_with_fees,
 12644:     11: )
 12645:     12: 
 12646:     13: 
 12647:     14: def _detail():
 12648:     15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
 12649:     16: 
 12650:     17: 
 12651:     18: def test_notional_and_pnl_units():
 12652:     19:     detail = _detail()
 12653:     20:     cs = get_contract_size(detail, "BTC_USDT")
 12654:     21:     N = calc_notional(10000, 2, cs)
 12655:     22:     assert N == pytest.approx(10000 * 0.001 * 2)
 12656:     23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
 12657:     24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
 12658:     25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
 12659:     26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
 12660:     27:     pnl_net, pct = compute_pnl_with_fees(
 12661:     28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
 12662:     29:     )
 12663:     30:     gross = (10100 - 10000) * cs * 2
 12664:     31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
 12665:     32:     expected = gross - fees
 12666:     33:     expected_pct = expected / (N / 10) * 100
 12667:     34:     assert pnl_net == pytest.approx(expected)
 12668:     35:     assert pct == pytest.approx(expected_pct)
 12669: 
 12670: 
 12671: ## tests/test_pair_selection.py (last modified: 2025-08-23 20:57:14)
 12672:      1: import bot
 12673:      2: 
 12674:      3: 
 12675:      4: def test_get_trade_pairs():
 12676:      5:     class Client:
 12677:      6:         def get_ticker(self, symbol=None):
 12678:      7:             return {
 12679:      8:                 "success": True,
 12680:      9:                 "data": [
 12681:     10:                     {"symbol": "BTC_USDT"},
 12682:     11:                     {"symbol": "ETH_USDT"},
 12683:     12:                 ],
 12684:     13:             }
 12685:     14: 
 12686:     15:     pairs = bot.get_trade_pairs(Client())
 12687:     16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
 12688:     17: 
 12689:     18: 
 12690:     19: def test_select_top_pairs():
 12691:     20:     class Client:
 12692:     21:         def get_ticker(self, symbol=None):
 12693:     22:             return {
 12694:     23:                 "success": True,
 12695:     24:                 "data": [
 12696:     25:                     {"symbol": "A", "volume": "1"},
 12697:     26:                     {"symbol": "B", "volume": "3"},
 12698:     27:                     {"symbol": "C", "volume": "2"},
 12699:     28:                 ],
 12700:     29:             }
 12701:     30: 
 12702:     31:     top = bot.select_top_pairs(Client(), top_n=2)
 12703:     32:     assert [p["symbol"] for p in top] == ["B", "C"]
 12704:     33: 
 12705:     34: 
 12706:     35: def test_select_top_pairs_default_count():
 12707:     36:     class Client:
 12708:     37:         def get_ticker(self, symbol=None):
 12709:     38:             data = []
 12710:     39:             for i in range(100):
 12711:     40:                 data.append({"symbol": str(i), "volume": str(i)})
 12712:     41:             return {"success": True, "data": data}
 12713:     42: 
 12714:     43:     top = bot.select_top_pairs(Client())
 12715:     44:     assert len(top) == 40
 12716:     45: 
 12717:     46: 
 12718:     47: def test_filter_trade_pairs():
 12719:     48:     class Client:
 12720:     49:         def get_ticker(self, symbol=None):
 12721:     50:             return {
 12722:     51:                 "success": True,
 12723:     52:                 "data": [
 12724:     53:                     {
 12725:     54:                         "symbol": "AAA",
 12726:     55:                         "volume": "6000000",
 12727:     56:                         "bidPrice": "100",
 12728:     57:                         "askPrice": "100.03",
 12729:     58:                     },  # spread ~3 bps
 12730:     59:                     {
 12731:     60:                         "symbol": "BBB",
 12732:     61:                         "volume": "10000000",
 12733:     62:                         "bidPrice": "50",
 12734:     63:                         "askPrice": "50.1",
 12735:     64:                     },  # spread ~200 bps
 12736:     65:                     {
 12737:     66:                         "symbol": "CCC",
 12738:     67:                         "volume": "7000000",
 12739:     68:                         "bidPrice": "10",
 12740:     69:                         "askPrice": "10.01",
 12741:     70:                     },  # spread ~100 bps
 12742:     71:                     {
 12743:     72:                         "symbol": "DDD",
 12744:     73:                         "volume": "4000000",
 12745:     74:                         "bidPrice": "20",
 12746:     75:                         "askPrice": "20.01",
 12747:     76:                     },  # volume trop faible
 12748:     77:                 ],
 12749:     78:             }
 12750:     79: 
 12751:     80:     pairs = bot.filter_trade_pairs(
 12752:     81:         Client(),
 12753:     82:         volume_min=5_000_000,
 12754:     83:         max_spread_bps=5,
 12755:     84:     )
 12756:     85:     assert [p["symbol"] for p in pairs] == ["AAA"]
 12757:     86: 
 12758:     87: 
 12759:     88: def test_find_trade_positions(monkeypatch):
 12760:     89:     class Client:
 12761:     90:         def __init__(self):
 12762:     91:             self.data = {
 12763:     92:                 "AAA": {"data": {"close": [1, 2, 3]}},
 12764:     93:                 "BBB": {"data": {"close": [3, 2, 1]}},
 12765:     94:             }
 12766:     95: 
 12767:     96:         def get_kline(self, symbol, interval="1m"):
 12768:     97:             return self.data[symbol]
 12769:     98: 
 12770:     99:     pairs = [
 12771:    100:         {"symbol": "AAA", "lastPrice": "1"},
 12772:    101:         {"symbol": "BBB", "lastPrice": "1"},
 12773:    102:     ]
 12774:    103: 
 12775:    104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
 12776:    105: 
 12777:    106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
 12778:    107:         if last_fast > prev_fast:
 12779:    108:             return 1
 12780:    109:         if last_fast < prev_fast:
 12781:    110:             return -1
 12782:    111:         return 0
 12783:    112: 
 12784:    113:     monkeypatch.setattr(bot, "cross", fake_cross)
 12785:    114: 
 12786:    115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
 12787:    116:     assert signals == [
 12788:    117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
 12789:    118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
 12790:    119:     ]
 12791: 
 12792: 
 12793: ## tests/test_pairs.py (last modified: 2025-08-23 20:57:14)
 12794:      1: import bot
 12795:      2: 
 12796:      3: 
 12797:      4: def test_send_selected_pairs(monkeypatch):
 12798:      5:     sent = {}
 12799:      6: 
 12800:      7:     def fake_notify(event, payload=None):
 12801:      8:         sent["event"] = event
 12802:      9:         sent["payload"] = payload
 12803:     10: 
 12804:     11:     monkeypatch.setattr(bot, "notify", fake_notify)
 12805:     12:     monkeypatch.setattr(
 12806:     13:         bot,
 12807:     14:         "filter_trade_pairs",
 12808:     15:         lambda client, top_n=120: [
 12809:     16:             {"symbol": "WIFUSDT", "volume": 10},
 12810:     17:             {"symbol": "WIFUSDT", "volume": 9},
 12811:     18:             {"symbol": "BTCUSD", "volume": 8},
 12812:     19:             {"symbol": "BTCUSDT", "volume": 7},
 12813:     20:             {"symbol": "DOGEUSDT", "volume": 6},
 12814:     21:             {"symbol": "ETHUSDC", "volume": 5},
 12815:     22:             {"symbol": "ETHUSDT", "volume": 4},
 12816:     23:         ],
 12817:     24:     )
 12818:     25: 
 12819:     26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
 12820:     27: 
 12821:     28:     payload = bot.send_selected_pairs(object(), top_n=4)
 12822:     29: 
 12823:     30:     assert sent["event"] == "pair_list"
 12824:     31:     assert sent["payload"]["green"] == "BTC"
 12825:     32:     assert sent["payload"]["orange"] == "ETH"
 12826:     33:     assert "red" not in sent["payload"]
 12827:     34:     assert payload == sent["payload"]
 12828:     35: 
 12829:     36: 
 12830:     37: def test_send_selected_pairs_no_whitelist(monkeypatch):
 12831:     38:     sent = {}
 12832:     39: 
 12833:     40:     def fake_notify(event, payload=None):
 12834:     41:         sent["payload"] = payload
 12835:     42: 
 12836:     43:     monkeypatch.setattr(bot, "notify", fake_notify)
 12837:     44:     monkeypatch.setattr(
 12838:     45:         bot,
 12839:     46:         "filter_trade_pairs",
 12840:     47:         lambda client, top_n=120: [
 12841:     48:             {"symbol": "AAAUSDT", "volume": 10},
 12842:     49:             {"symbol": "BBBUSD", "volume": 9},
 12843:     50:             {"symbol": "CCCUSDC", "volume": 8},
 12844:     51:             {"symbol": "DDDUSDT", "volume": 7},
 12845:     52:         ],
 12846:     53:     )
 12847:     54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
 12848:     55: 
 12849:     56:     payload = bot.send_selected_pairs(object(), top_n=4)
 12850:     57: 
 12851:     58:     assert payload == sent["payload"]
 12852:     59:     assert payload["green"] == "AAA"
 12853:     60:     assert payload["orange"] == "BBB"
 12854:     61:     assert payload["red"] == "CCC, DDD"
 12855:     62: 
 12856:     63: 
 12857:     64: def test_filter_trade_pairs_all_pairs(monkeypatch):
 12858:     65:     class DummyClient:
 12859:     66:         def get_ticker(self):
 12860:     67:             return {
 12861:     68:                 "data": [
 12862:     69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
 12863:     70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
 12864:     71:                 ]
 12865:     72:             }
 12866:     73: 
 12867:     74:     client = DummyClient()
 12868:     75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
 12869:     76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
 12870:     77: 
 12871: 
 12872: 
 12873: ## tests/test_risk_manager.py (last modified: 2025-08-23 20:57:14)
 12874:      1: from scalp import RiskManager
 12875:      2: 
 12876:      3: 
 12877:      4: def test_kill_switch_triggered() -> None:
 12878:      5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
 12879:      6:     rm.record_trade(-1.0)
 12880:      7:     rm.record_trade(-1.5)
 12881:      8:     assert rm.kill_switch is True
 12882:      9: 
 12883:     10: 
 12884:     11: def test_profit_kill_switch_triggered() -> None:
 12885:     12:     rm = RiskManager(
 12886:     13:         max_daily_loss_pct=10.0,
 12887:     14:         max_daily_profit_pct=3.0,
 12888:     15:         max_positions=1,
 12889:     16:         risk_pct=0.01,
 12890:     17:     )
 12891:     18:     rm.record_trade(1.5)
 12892:     19:     rm.record_trade(1.6)
 12893:     20:     assert rm.kill_switch is True
 12894:     21: 
 12895:     22: 
 12896:     23: def test_pause_and_can_open() -> None:
 12897:     24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 12898:     25:     rm.record_trade(-0.5)
 12899:     26:     rm.record_trade(-0.6)
 12900:     27:     rm.record_trade(-0.7)
 12901:     28:     assert rm.pause_duration() == 15 * 60
 12902:     29:     rm.record_trade(-0.8)
 12903:     30:     rm.record_trade(-0.9)
 12904:     31:     assert rm.pause_duration() == 60 * 60
 12905:     32:     assert rm.can_open(0) is True
 12906:     33:     assert rm.can_open(1) is False
 12907:     34: 
 12908:     35: 
 12909:     36: def test_risk_pct_scaling() -> None:
 12910:     37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 12911:     38:     rm.record_trade(1.0)
 12912:     39:     rm.record_trade(1.0)
 12913:     40:     assert rm.risk_pct > 0.01
 12914:     41:     rm.record_trade(-1.0)
 12915:     42:     rm.record_trade(-1.0)
 12916:     43:     assert rm.risk_pct < 0.01
 12917: 
 12918: 
 12919: ## tests/test_risk_utils.py (last modified: 2025-08-23 20:57:14)
 12920:      1: import pytest
 12921:      2: 
 12922:      3: from scalper.risk import calc_risk_amount, calc_position_size
 12923:      4: 
 12924:      5: 
 12925:      6: def test_calc_risk_amount_basic():
 12926:      7:     assert calc_risk_amount(1000, 0.01) == 10.0
 12927:      8: 
 12928:      9: 
 12929:     10: def test_calc_position_size_basic():
 12930:     11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
 12931:     12:     assert calc_position_size(1000, 0.01, 50) == 0.2
 12932:     13: 
 12933:     14: 
 12934:     15: @pytest.mark.parametrize("equity,risk_pct", [
 12935:     16:     (0, 0.01),
 12936:     17:     (-100, 0.01),
 12937:     18:     (1000, 0),
 12938:     19:     (1000, -0.1),
 12939:     20:     (1000, 1.5),
 12940:     21: ])
 12941:     22: def test_calc_risk_amount_invalid(equity, risk_pct):
 12942:     23:     with pytest.raises(ValueError):
 12943:     24:         calc_risk_amount(equity, risk_pct)
 12944:     25: 
 12945:     26: 
 12946:     27: @pytest.mark.parametrize("stop_distance", [0, -1])
 12947:     28: def test_calc_position_size_invalid_stop(stop_distance):
 12948:     29:     with pytest.raises(ValueError):
 12949:     30:         calc_position_size(1000, 0.01, stop_distance)
 12950: 
 12951: 
 12952: ## tests/test_signal_risk.py (last modified: 2025-08-23 20:57:14)
 12953:      1: import types
 12954:      2: import os
 12955:      3: import sys
 12956:      4: 
 12957:      5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 12958:      6: sys.modules['requests'] = types.ModuleType('requests')
 12959:      7: 
 12960:      8: from bot import (
 12961:      9:     map_score_to_sig_level,
 12962:     10:     compute_risk_params,
 12963:     11:     prepare_order,
 12964:     12:     Signal,
 12965:     13:     CONFIG,
 12966:     14: )
 12967:     15: 
 12968:     16: 
 12969:     17: class DummyRisk:
 12970:     18:     def __init__(self, pct: float) -> None:
 12971:     19:         self.risk_pct = pct
 12972:     20: 
 12973:     21: 
 12974:     22: def _contract_detail():
 12975:     23:     return {
 12976:     24:         "data": [
 12977:     25:             {
 12978:     26:                 "symbol": "BTC_USDT",
 12979:     27:                 "contractSize": 0.001,
 12980:     28:                 "volUnit": 1,
 12981:     29:                 "minVol": 1,
 12982:     30:                 "minTradeUSDT": 5,
 12983:     31:             }
 12984:     32:         ]
 12985:     33:     }
 12986:     34: 
 12987:     35: 
 12988:     36: def test_score_to_level_mapping():
 12989:     37:     assert map_score_to_sig_level(10) == 1
 12990:     38:     assert map_score_to_sig_level(35) == 2
 12991:     39:     assert map_score_to_sig_level(69.9) == 2
 12992:     40:     assert map_score_to_sig_level(70) == 3
 12993:     41: 
 12994:     42: 
 12995:     43: def test_risk_tables():
 12996:     44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
 12997:     45:     assert rp == 0.01 * 1.25
 12998:     46:     assert lev == int(20 * 0.75)
 12999:     47:     assert cap == 0.55
 13000:     48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
 13001:     49:     assert rp2 == 0.01 * 1.0
 13002:     50:     assert lev2 == int(20 * 0.5)
 13003:     51:     assert cap2 == 0.35
 13004:     52: 
 13005:     53: 
 13006:     54: def test_notional_cap():
 13007:     55:     rm = DummyRisk(0.05)
 13008:     56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 13009:     57:     available = 1000
 13010:     58:     params = prepare_order(
 13011:     59:         sig,
 13012:     60:         _contract_detail(),
 13013:     61:         equity_usdt=available,
 13014:     62:         available_usdt=available,
 13015:     63:         base_leverage=10,
 13016:     64:         risk_mgr=rm,
 13017:     65:         user_risk_level=2,
 13018:     66:     )
 13019:     67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6
 13020: 
 13021: 
 13022: ## tests/test_slippage.py (last modified: 2025-08-23 20:57:14)
 13023:      1: from scalper.trade_utils import marketable_limit_price
 13024:      2: 
 13025:      3: 
 13026:      4: def test_marketable_limit_price_buy_sell():
 13027:      5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
 13028:      6:     assert price_buy == 10.0 * 1.001
 13029:      7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
 13030:      8:     assert price_sell == 9.9 * (1 - 0.001)
 13031: 
 13032: 
 13033: ## tests/test_strategy_v2.py (last modified: 2025-08-23 20:57:14)
 13034:      1: import pytest
 13035:      2: 
 13036:      3: from scalp import strategy
 13037:      4: from scalper.trade_utils import trailing_stop, should_scale_in, timeout_exit
 13038:      5: 
 13039:      6: 
 13040:      7: def make_ohlcv(n=60, start=100, step=1):
 13041:      8:     closes = [start + i * step for i in range(n)]
 13042:      9:     highs = [c + 1 for c in closes]
 13043:     10:     lows = [c - 1 for c in closes]
 13044:     11:     vols = [1 for _ in closes]
 13045:     12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
 13046:     13: 
 13047:     14: 
 13048:     15: def test_generate_signal_atr_adaptation(monkeypatch):
 13049:     16:     base = make_ohlcv(step=2)
 13050:     17:     ohlcv_15 = make_ohlcv(n=15, step=2)
 13051:     18:     ohlcv_1h = make_ohlcv(step=2)
 13052:     19: 
 13053:     20:     # patches for deterministic RSI values
 13054:     21:     rsi_vals = iter([60, 41, 39])
 13055:     22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 13056:     23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 13057:     24:     # low ATR -> signal disabled
 13058:     25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
 13059:     26:     sig = strategy.generate_signal(
 13060:     27:         "AAA",
 13061:     28:         base,
 13062:     29:         equity=1_000,
 13063:     30:         risk_pct=0.01,
 13064:     31:         ohlcv_15m=ohlcv_15,
 13065:     32:         ohlcv_1h=ohlcv_1h,
 13066:     33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 13067:     34:         tick_ratio_buy=0.6,
 13068:     35:     )
 13069:     36:     assert sig is None
 13070:     37: 
 13071:     38:     # high ATR -> size reduced
 13072:     39:     rsi_vals = iter([60, 41, 39])
 13073:     40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 13074:     41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
 13075:     42:     sig = strategy.generate_signal(
 13076:     43:         "AAA",
 13077:     44:         base,
 13078:     45:         equity=1_000,
 13079:     46:         risk_pct=0.01,
 13080:     47:         ohlcv_15m=ohlcv_15,
 13081:     48:         ohlcv_1h=ohlcv_1h,
 13082:     49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 13083:     50:         tick_ratio_buy=0.6,
 13084:     51:     )
 13085:     52:     assert sig and sig.side == "long"
 13086:     53:     assert sig.qty == 50
 13087:     54: 
 13088:     55: 
 13089:     56: def test_generate_signal_short_with_filters(monkeypatch):
 13090:     57:     base = make_ohlcv(start=200, step=-2)
 13091:     58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
 13092:     59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
 13093:     60: 
 13094:     61:     rsi_vals = iter([40, 59, 61])
 13095:     62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 13096:     63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 13097:     64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 13098:     65: 
 13099:     66:     sig = strategy.generate_signal(
 13100:     67:         "AAA",
 13101:     68:         base,
 13102:     69:         equity=1_000,
 13103:     70:         risk_pct=0.01,
 13104:     71:         ohlcv_15m=ohlcv_15,
 13105:     72:         ohlcv_1h=ohlcv_1h,
 13106:     73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
 13107:     74:         tick_ratio_buy=0.4,
 13108:     75:     )
 13109:     76:     assert sig and sig.side == "short"
 13110:     77:     assert sig.qty == 100
 13111:     78: 
 13112:     79: 
 13113:     80: def test_trailing_and_timeout():
 13114:     81:     # trailing stop
 13115:     82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
 13116:     83:     assert sl == pytest.approx(102.5)
 13117:     84:     # scaling
 13118:     85:     assert should_scale_in(100, 105, 100, 10, "long") is True
 13119:     86:     assert should_scale_in(100, 95, 100, 10, "short") is True
 13120:     87:     # timeout
 13121:     88:     # before the progress window no exit should be triggered
 13122:     89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 13123:     90:     # after ``progress_min`` minutes without favourable movement we close
 13124:     91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 13125:     92: 
 13126:     93: 
 13127:     94: def test_generate_signal_macd_filter(monkeypatch):
 13128:     95:     base = make_ohlcv(step=2)
 13129:     96:     ohlcv_15 = make_ohlcv(n=15, step=2)
 13130:     97:     ohlcv_1h = make_ohlcv(step=2)
 13131:     98: 
 13132:     99:     rsi_vals = iter([60, 41, 39])
 13133:    100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 13134:    101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 13135:    102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 13136:    103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
 13137:    104: 
 13138:    105:     sig = strategy.generate_signal(
 13139:    106:         "AAA",
 13140:    107:         base,
 13141:    108:         equity=1_000,
 13142:    109:         risk_pct=0.01,
 13143:    110:         ohlcv_15m=ohlcv_15,
 13144:    111:         ohlcv_1h=ohlcv_1h,
 13145:    112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 13146:    113:         tick_ratio_buy=0.6,
 13147:    114:     )
 13148:    115:     assert sig is None
 13149:    116: 
 13150:    117: 
 13151:    118: 
 13152:    119: def test_generate_signal_trend_ema_filter(monkeypatch):
 13153:    120:     base = make_ohlcv(step=2)
 13154:    121:     ohlcv_15 = make_ohlcv(n=15, step=2)
 13155:    122:     ohlcv_1h = make_ohlcv(step=2)
 13156:    123: 
 13157:    124:     rsi_vals = iter([60, 41, 39])
 13158:    125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 13159:    126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 13160:    127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 13161:    128: 
 13162:    129:     orig_ema = strategy.ema
 13163:    130: 
 13164:    131:     def fake_ema(series, window):
 13165:    132:         if window == 200:
 13166:    133:             return [x + 1000 for x in orig_ema(series, window)]
 13167:    134:         return orig_ema(series, window)
 13168:    135: 
 13169:    136:     monkeypatch.setattr(strategy, "ema", fake_ema)
 13170:    137: 
 13171:    138:     sig = strategy.generate_signal(
 13172:    139:         "AAA",
 13173:    140:         base,
 13174:    141:         equity=1_000,
 13175:    142:         risk_pct=0.01,
 13176:    143:         ohlcv_15m=ohlcv_15,
 13177:    144:         ohlcv_1h=ohlcv_1h,
 13178:    145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 13179:    146:         tick_ratio_buy=0.6,
 13180:    147:         trend_ema_period=200,
 13181:    148:     )
 13182:    149:     assert sig is None
 13183:    150:     
 13184: 
 13185: ## tests/test_telegram_bot.py (last modified: 2025-08-23 20:57:14)
 13186:      1: from scalper.telegram_bot import TelegramBot
 13187:      2: 
 13188:      3: 
 13189:      4: class DummyClient:
 13190:      5: 
 13191:      6:     def __init__(self):
 13192:      7:         self.closed = []
 13193:      8:         self.closed_all = False
 13194:      9: 
 13195:     10: 
 13196:     11:     def get_assets(self):
 13197:     12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
 13198:     13: 
 13199:     14:     def get_positions(self):
 13200:     15:         return {
 13201:     16:             "data": [
 13202:     17:                 {
 13203:     18:                     "symbol": "BTC_USDT",
 13204:     19:                     "side": "long",
 13205:     20:                     "vol": 2,
 13206:     21:                     "pnl_usd": 1.0,
 13207:     22:                     "pnl_pct": 5.0,
 13208:     23:                 }
 13209:     24:             ]
 13210:     25:         }
 13211:     26: 
 13212:     27:     def close_position(self, sym):
 13213:     28:         self.closed.append(sym)
 13214:     29: 
 13215:     30:     def close_all_positions(self):
 13216:     31:         self.closed_all = True
 13217:     32: 
 13218:     33: 
 13219:     34: 
 13220:     35: class DummyRiskMgr:
 13221:     36: 
 13222:     37:     def __init__(self):
 13223:     38:         self.reset_called = False
 13224:     39:         self.max_positions = 1
 13225:     40:         self.risk_pct = 0.01
 13226:     41: 
 13227:     42:     def reset_day(self):
 13228:     43:         self.reset_called = True
 13229:     44: 
 13230:     45: 
 13231:     46: class DummyRequests:
 13232:     47:     def __init__(self):
 13233:     48:         self.posts = []
 13234:     49: 
 13235:     50:     def post(self, url, json=None, timeout=5):
 13236:     51:         self.posts.append((url, json))
 13237:     52: 
 13238:     53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
 13239:     54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
 13240:     55: 
 13241:     56: 
 13242:     57: def make_bot(config=None, requests_module=None):
 13243:     58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
 13244:     59:     if config:
 13245:     60:         cfg.update(config)
 13246:     61:     if requests_module is None:
 13247:     62:         requests_module = DummyRequests()
 13248:     63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
 13249:     64: 
 13250:     65: 
 13251:     66: def test_handle_balance():
 13252:     67:     bot = make_bot()
 13253:     68: 
 13254:     69:     resp, kb = bot.handle_callback("balance", 0.0)
 13255:     70:     assert "123.45" in resp
 13256:     71:     assert kb == bot.main_keyboard
 13257:     72: 
 13258:     73: 
 13259:     74: 
 13260:     75: def test_handle_positions():
 13261:     76:     bot = make_bot()
 13262:     77:     resp, _ = bot.handle_callback("positions", 0.0)
 13263:     78:     assert "BTC" in resp
 13264:     79:     assert "PnL" in resp
 13265:     80: 
 13266:     81: 
 13267:     82: def test_handle_positions_zero_pnl():
 13268:     83:     bot = make_bot()
 13269:     84: 
 13270:     85:     def zero_positions():
 13271:     86:         return {
 13272:     87:             "data": [
 13273:     88:                 {
 13274:     89:                     "symbol": "BTC_USDT",
 13275:     90:                     "side": "long",
 13276:     91:                     "vol": 1,
 13277:     92:                     "pnl_usd": 0.0,
 13278:     93:                     "pnl_pct": 0.0,
 13279:     94:                 }
 13280:     95:             ]
 13281:     96:         }
 13282:     97: 
 13283:     98:     bot.client.get_positions = zero_positions
 13284:     99:     resp, _ = bot.handle_callback("positions", 0.0)
 13285:    100:     assert "PnL: 0.00 USDT" in resp
 13286:    101: 
 13287:    102: 
 13288:    103: 
 13289:    104: def test_handle_pnl():
 13290:    105:     bot = make_bot()
 13291:    106:     resp, _ = bot.handle_callback("pnl", 5.0)
 13292:    107: 
 13293:    108:     assert "5.00" in resp
 13294:    109: 
 13295:    110: 
 13296:    111: def test_handle_risk_change():
 13297:    112:     bot = make_bot()
 13298:    113: 
 13299:    114:     resp, kb = bot.handle_callback("risk_red", 0.0)
 13300:    115:     assert "3" in resp
 13301:    116:     assert bot.config["RISK_LEVEL"] == 3
 13302:    117:     assert kb == bot.main_keyboard
 13303:    118: 
 13304:    119: 
 13305:    120: def test_risk_menu():
 13306:    121:     bot = make_bot()
 13307:    122:     resp, kb = bot.handle_callback("risk", 0.0)
 13308:    123:     assert "risque" in resp.lower()
 13309:    124:     assert kb == bot.risk_keyboard
 13310:    125: 
 13311:    126: 
 13312:    127: 
 13313:    128: def test_stop_menu_and_actions():
 13314:    129:     bot = make_bot()
 13315:    130:     resp, kb = bot.handle_callback("stop", 0.0)
 13316:    131:     assert any(
 13317:    132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
 13318:    133:     )
 13319:    134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
 13320:    135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
 13321:    136:     assert "fermée" in resp.lower()
 13322:    137:     assert bot.client.closed == ["BTC_USDT"]
 13323:    138:     resp, _ = bot.handle_callback("stop_all", 0.0)
 13324:    139:     assert bot.client.closed_all is True
 13325:    140: 
 13326:    141: 
 13327:    142: def test_handle_unknown():
 13328:    143:     bot = make_bot()
 13329:    144:     resp, kb = bot.handle_callback("foobar", 0.0)
 13330:    145:     assert resp is None
 13331:    146:     assert kb is None
 13332:    147: 
 13333:    148: 
 13334:    149: def test_reset_all():
 13335:    150:     bot = make_bot()
 13336:    151:     resp, kb = bot.handle_callback("reset_all", 0.0)
 13337:    152:     assert "réinitialisés" in resp.lower()
 13338:    153:     assert bot.risk_mgr.reset_called is True
 13339:    154:     assert bot.client.closed_all is True
 13340:    155:     assert kb == bot.settings_keyboard
 13341:    156: 
 13342:    157: 
 13343:    158: def test_shutdown_bot():
 13344:    159:     bot = make_bot()
 13345:    160:     resp, kb = bot.handle_callback("shutdown", 0.0)
 13346:    161:     assert "arrêt" in resp.lower()
 13347:    162:     assert bot.stop_requested is True
 13348:    163:     assert kb == bot.main_keyboard
 13349:    164: 
 13350:    165: 
 13351:    166: def test_start_sends_menu():
 13352:    167:     req = DummyRequests()
 13353:    168:     make_bot(requests_module=req)
 13354:    169:     assert req.posts
 13355:    170:     text = req.posts[0][1]["text"]
 13356:    171:     assert "Solde" in text and "PnL session" in text
 13357:    172:     assert "Positions max" in text
 13358:    173:     assert "Risque actuel" in text
 13359:    174: 
 13360:    175: 
 13361:    176: def test_settings_menu_and_reset_risk():
 13362:    177:     bot = make_bot()
 13363:    178:     resp, kb = bot.handle_callback("settings", 0.0)
 13364:    179:     assert "réglages" in resp.lower()
 13365:    180:     assert kb == bot.settings_keyboard
 13366:    181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
 13367:    182:     assert "risque" in resp.lower()
 13368:    183:     assert bot.risk_mgr.reset_called is True
 13369:    184:     assert kb == bot.settings_keyboard
 13370:    185: 
 13371:    186: 
 13372:    187: def test_update_button(monkeypatch):
 13373:    188:     bot = make_bot()
 13374:    189:     called = {}
 13375:    190: 
 13376:    191:     def fake_update():
 13377:    192:         called["called"] = True
 13378:    193: 
 13379:    194:     bot.update_pairs = fake_update
 13380:    195:     resp, kb = bot.handle_callback("update", 0.0)
 13381:    196:     assert called["called"] is True
 13382:    197:     assert "mise à jour" in resp.lower()
 13383:    198:     assert kb == bot.main_keyboard
 13384:    199: 
 13385:    200: 
 13386:    201: def test_maxpos_menu_and_change():
 13387:    202:     bot = make_bot()
 13388:    203:     resp, kb = bot.handle_callback("maxpos", 0.0)
 13389:    204:     assert "nombre" in resp.lower()
 13390:    205:     assert kb == bot.maxpos_keyboard
 13391:    206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
 13392:    207:     assert "3" in resp
 13393:    208:     assert bot.config["MAX_POSITIONS"] == 3
 13394:    209:     assert bot.risk_mgr.max_positions == 3
 13395:    210:     assert kb == bot.main_keyboard
 13396:    211: 
 13397:    212: 
 13398:    213: def test_stop_no_positions():
 13399:    214:     bot = make_bot()
 13400:    215:     bot.client.get_positions = lambda: {"data": []}
 13401:    216:     resp, kb = bot.handle_callback("stop", 0.0)
 13402:    217:     assert "aucune crypto" in resp.lower()
 13403:    218:     assert kb == bot.settings_keyboard
 13404:    219: 
 13405: 
 13406: 
 13407: ## tests/test_utils.py (last modified: 2025-08-23 20:57:14)
 13408:      1: import pytest
 13409:      2: from bot import ema, cross, compute_position_size, CONFIG
 13410:      3: from scalper.trade_utils import extract_available_balance
 13411:      4: 
 13412:      5: 
 13413:      6: def test_ema_basic():
 13414:      7:     data = [1, 2, 3, 4, 5]
 13415:      8:     result = ema(data, 3)
 13416:      9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
 13417:     10: 
 13418:     11: 
 13419:     12: def test_cross_up_down_none():
 13420:     13:     assert cross(3, 2, 1, 2) == 1  # up cross
 13421:     14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
 13422:     15:     assert cross(2, 2, 2, 2) == 0  # no cross
 13423:     16: 
 13424:     17: 
 13425:     18: def test_compute_position_size():
 13426:     19:     detail = {
 13427:     20:         "data": [
 13428:     21:             {
 13429:     22:                 "symbol": CONFIG["SYMBOL"],
 13430:     23:                 "contractSize": 0.001,
 13431:     24:                 "volUnit": 1,
 13432:     25:                 "minVol": 1,
 13433:     26:             }
 13434:     27:         ]
 13435:     28:     }
 13436:     29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
 13437:     30:                                 risk_pct=0.01, leverage=5)
 13438:     31:     assert vol == 1
 13439:     32: 
 13440:     33: 
 13441:     34: def test_compute_position_size_missing_symbol():
 13442:     35:     with pytest.raises(ValueError):
 13443:     36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
 13444:     37: 
 13445:     38: 
 13446:     39: def test_extract_available_balance_fallback():
 13447:     40:     assets = {
 13448:     41:         "data": [
 13449:     42:             {
 13450:     43:                 "currency": "USDT",
 13451:     44:                 "available": 0,
 13452:     45:                 "cashBalance": "150.5",
 13453:     46:                 "equity": "200",
 13454:     47:             }
 13455:     48:         ]
 13456:     49:     }
 13457:     50:     assert extract_available_balance(assets) == 150.5
 13458:     51: 
 13459:     52: 
 13460:     53: def test_extract_available_balance_equity_only():
 13461:     54:     assets = {
 13462:     55:         "data": [
 13463:     56:             {
 13464:     57:                 "currency": "USDT",
 13465:     58:                 "equity": "42",
 13466:     59:             }
 13467:     60:         ]
 13468:     61:     }
 13469:     62:     assert extract_available_balance(assets) == 42.0
 13470:     63: 
 13471:     64: 
 13472:     65: def test_extract_available_balance_zero_available_returns_zero():
 13473:     66:     assets = {
 13474:     67:         "data": [
 13475:     68:             {
 13476:     69:                 "currency": "USDT",
 13477:     70:                 "available": 0,
 13478:     71:                 "availableBalance": 0,
 13479:     72:                 "equity": "42",
 13480:     73:             }
 13481:     74:         ]
 13482:     75:     }
 13483:     76:     assert extract_available_balance(assets) == 0.0
 13484: 
 13485: 
 13486: ## tests/test_version.py (last modified: 2025-08-23 20:57:14)
 13487:      1: import pytest
 13488:      2: from scalp import version
 13489:      3: 
 13490:      4: 
 13491:      5: def test_get_version(monkeypatch, tmp_path):
 13492:      6:     vfile = tmp_path / "VERSION"
 13493:      7:     vfile.write_text("1.2.3")
 13494:      8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 13495:      9:     assert version.get_version() == "1.2.3"
 13496:     10: 
 13497:     11: 
 13498:     12: def test_bump_version(monkeypatch, tmp_path):
 13499:     13:     vfile = tmp_path / "VERSION"
 13500:     14: 
 13501:     15:     vfile.write_text("0.1.2\n")
 13502:     16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 13503:     17:     assert version.bump_version("minor") == "0.2.0"
 13504:     18:     assert vfile.read_text().strip() == "0.2.0"
 13505:     19: 
 13506:     20: 
 13507:     21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
 13508:     22:     vfile = tmp_path / "VERSION"
 13509:     23:     vfile.write_text("0.1.0\n")
 13510:     24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 13511:     25:     with pytest.raises(ValueError):
 13512:     26:         version.bump_version("foo")
 13513:     27: 
 13514:     28: 
 13515:     29: def test_bump_from_message(monkeypatch, tmp_path):
 13516:     30:     vfile = tmp_path / "VERSION"
 13517:     31:     vfile.write_text("1.0.0\n")
 13518:     32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 13519:     33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
 13520:     34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
 13521:     35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
 13522:     36: 
 13523: 
 13524: 
 13525: ## tests/test_walk_forward.py (last modified: 2025-08-23 20:57:14)
 13526:      1: from scalper.backtest import walk_forward_windows
 13527:      2: 
 13528:      3: 
 13529:      4: def test_walk_forward_windows():
 13530:      5:     data = list(range(10))
 13531:      6:     windows = list(walk_forward_windows(data, train=4, test=2))
 13532:      7:     assert windows == [
 13533:      8:         ([0, 1, 2, 3], [4, 5]),
 13534:      9:         ([2, 3, 4, 5], [6, 7]),
 13535:     10:         ([4, 5, 6, 7], [8, 9]),
 13536:     11:     ]
 13537: 
 13538: 
 13539: ## tests/test_ws.py (last modified: 2025-08-23 20:57:14)
 13540:      1: import asyncio
 13541:      2: 
 13542:      3: from scalper.ws import WebsocketManager
 13543:      4: 
 13544:      5: 
 13545:      6: def test_websocket_manager_stop():
 13546:      7:     async def connect():
 13547:      8:         return None
 13548:      9: 
 13549:     10:     async def subscribe():
 13550:     11:         return None
 13551:     12: 
 13552:     13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
 13553:     14: 
 13554:     15:     async def run_and_stop():
 13555:     16:         await ws.run()
 13556:     17:         assert ws._heartbeat_task is not None
 13557:     18:         await ws.stop()
 13558:     19:         assert ws._heartbeat_task is None
 13559:     20: 
 13560:     21:     asyncio.run(run_and_stop())
 13561: 
 13562: 
 13563: ## tg_diag.py (last modified: 2025-08-23 20:57:14)
 13564:      1: # tg_diag.py
 13565:      2: import asyncio, os, aiohttp
 13566:      3: 
 13567:      4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
 13568:      5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
 13569:      6: 
 13570:      7: async def main():
 13571:      8:     if not TOKEN or not CHAT:
 13572:      9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
 13573:     10:         return
 13574:     11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
 13575:     12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
 13576:     13:     try:
 13577:     14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
 13578:     15:             async with s.post(url, json=payload) as r:
 13579:     16:                 body = await r.text()
 13580:     17:                 print("HTTP:", r.status)
 13581:     18:                 print("Body:", body[:500])
 13582:     19:     except Exception as e:
 13583:     20:         print("❌ Exception:", repr(e))
 13584:     21: 
 13585:     22: if __name__ == "__main__":
 13586:     23:     asyncio.run(main())
 13587: 
 13588: 
 13589: 
 13590: --------------------------------------------------------------------------------
 13591: FILE: dumps/DUMP_20250824-112618.txt
 13592: --------------------------------------------------------------------------------
 13593: 
 13594: 
 13595: --------------------------------------------------------------------------------
 13596: FILE: init.py
 13597: --------------------------------------------------------------------------------
 13598: #!/usr/bin/env python3
 13599: """Install all project dependencies.
 13600: 
 13601: Run this script once to install every ``requirements*.txt`` file found in the
 13602: repository as well as the packages needed for the test suite.  All subsequent
 13603: invocations of the bot or its submodules will then share the same Python
 13604: environment with the required dependencies available.
 13605: """
 13606: 
 13607: from __future__ import annotations
 13608: 
 13609: import subprocess
 13610: import sys
 13611: from pathlib import Path
 13612: 
 13613: 
 13614: def install_packages(*args: str) -> None:
 13615:     """Install packages using pip for the current Python interpreter."""
 13616:     cmd = [sys.executable, "-m", "pip", "install", *args]
 13617:     subprocess.check_call(cmd)
 13618: 
 13619: 
 13620: def main() -> None:
 13621:     repo_root = Path(__file__).resolve().parent
 13622: 
 13623:     # Install from any requirements*.txt file across the repository so that
 13624:     # sub-packages with their own dependency lists are also covered.
 13625:     for req in sorted(repo_root.rglob("requirements*.txt")):
 13626:         install_packages("-r", str(req))
 13627: 
 13628:     # Ensure test dependencies are available
 13629:     install_packages("pytest")
 13630: 
 13631: 
 13632: if __name__ == "__main__":
 13633:     main()
 13634: 
 13635: 
 13636: --------------------------------------------------------------------------------
 13637: FILE: pytest.ini
 13638: --------------------------------------------------------------------------------
 13639: [pytest]
 13640: addopts = -q
 13641: 
 13642: 
 13643: --------------------------------------------------------------------------------
 13644: FILE: requirements-dev.txt
 13645: --------------------------------------------------------------------------------
 13646: pytest
 13647: 
 13648: 
 13649: --------------------------------------------------------------------------------
 13650: FILE: requirements.txt
 13651: --------------------------------------------------------------------------------
 13652: requests
 13653: python-dotenv
 13654: pydantic==1.10.15 ; python_version < "3.11"
 13655: 
 13656: # pydantic v1 déjà pin si environnement ancien
 13657: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)
 13658: 
 13659: 
 13660: --------------------------------------------------------------------------------
 13661: FILE: resultat.log
 13662: --------------------------------------------------------------------------------
 13663: .................................................................................................                        [100%]
 13664: 97 passed in 0.42s
 13665: 
 13666: 
 13667: --------------------------------------------------------------------------------
 13668: FILE: scalper/VERSION
 13669: --------------------------------------------------------------------------------
 13670: 0.3.0
 13671: 
 13672: 
 13673: 
 13674: --------------------------------------------------------------------------------
 13675: FILE: scalper/__init__.py
 13676: --------------------------------------------------------------------------------
 13677: # Rend le dossier 'scalper' importable comme package.
 13678: __all__ = ["live", "signals", "core"]
 13679: 
 13680: --------------------------------------------------------------------------------
 13681: FILE: scalper/adapters/__init__.py
 13682: --------------------------------------------------------------------------------
 13683: 
 13684: 
 13685: --------------------------------------------------------------------------------
 13686: FILE: scalper/adapters/bitget.py
 13687: --------------------------------------------------------------------------------
 13688: # scalp/adapters/bitget.py
 13689: from __future__ import annotations
 13690: from typing import Any, Dict, List, Optional
 13691: import inspect, os
 13692: import requests
 13693: 
 13694: # Client bas-niveau fourni par le repo
 13695: from scalper.bitget_client import BitgetFuturesClient as _Base
 13696: 
 13697: 
 13698: def _to_float(x, default: float = 0.0) -> float:
 13699:     try:
 13700:         return float(x)
 13701:     except Exception:
 13702:         return default
 13703: 
 13704: 
 13705: def _select_base_url() -> str:
 13706:     env = os.environ.get("BITGET_BASE_URL")
 13707:     if env:
 13708:         return env
 13709:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
 13710:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
 13711: 
 13712: 
 13713: class BitgetFuturesClient(_Base):
 13714:     """
 13715:     Adaptateur Bitget:
 13716:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
 13717:       - Normalisations robustes: assets, ticker(s), positions, fills
 13718:     """
 13719: 
 13720:     # --------------------- INIT dynamique ---------------------
 13721:     def __init__(self, *args: Any, **kwargs: Any) -> None:
 13722:         """
 13723:         Accepte indifféremment:
 13724:           api_key/apiKey/access_key/accessKey/key
 13725:           api_secret/apiSecret/secret/secret_key/secretKey
 13726:           passphrase/password/api_passphrase/apiPassphrase
 13727:           base_url/baseUrl/host/endpoint (ou auto)
 13728:         On n'envoie au client de base que les noms présents dans sa signature.
 13729:         """
 13730:         user_kwargs = dict(kwargs)
 13731: 
 13732:         # Collecte des valeurs possibles (tous alias)
 13733:         incoming_key = (
 13734:             user_kwargs.pop("api_key", None)
 13735:             or user_kwargs.pop("apiKey", None)
 13736:             or user_kwargs.pop("access_key", None)
 13737:             or user_kwargs.pop("accessKey", None)
 13738:             or user_kwargs.pop("key", None)
 13739:             or user_kwargs.pop("API_KEY", None)
 13740:         )
 13741:         incoming_secret = (
 13742:             user_kwargs.pop("api_secret", None)
 13743:             or user_kwargs.pop("apiSecret", None)
 13744:             or user_kwargs.pop("secret_key", None)
 13745:             or user_kwargs.pop("secretKey", None)
 13746:             or user_kwargs.pop("secret", None)
 13747:             or user_kwargs.pop("API_SECRET", None)
 13748:         )
 13749:         incoming_pass = (
 13750:             user_kwargs.pop("passphrase", None)
 13751:             or user_kwargs.pop("password", None)
 13752:             or user_kwargs.pop("api_passphrase", None)
 13753:             or user_kwargs.pop("apiPassphrase", None)
 13754:         )
 13755:         incoming_base = (
 13756:             user_kwargs.pop("base_url", None)
 13757:             or user_kwargs.pop("baseUrl", None)
 13758:             or user_kwargs.pop("host", None)
 13759:             or user_kwargs.pop("endpoint", None)
 13760:             or _select_base_url()
 13761:         )
 13762: 
 13763:         # Signature réelle du client bas-niveau
 13764:         sig = inspect.signature(_Base.__init__)
 13765:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
 13766: 
 13767:         def pick_name(cands: List[str]) -> Optional[str]:
 13768:             for c in cands:
 13769:                 if c in param_names:
 13770:                     return c
 13771:             return None
 13772: 
 13773:         # Noms réellement supportés
 13774:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
 13775:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
 13776:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
 13777:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
 13778:         req_mod_name = "requests_module" if "requests_module" in param_names else None
 13779: 
 13780:         # Construire kwargs à transmettre (une seule fois par nom)
 13781:         base_kwargs: Dict[str, Any] = {}
 13782:         if key_name and incoming_key is not None:
 13783:             base_kwargs[key_name] = incoming_key
 13784:         if sec_name and incoming_secret is not None:
 13785:             base_kwargs[sec_name] = incoming_secret
 13786:         if pas_name and incoming_pass is not None:
 13787:             base_kwargs[pas_name] = incoming_pass
 13788:         if base_name:
 13789:             base_kwargs[base_name] = incoming_base
 13790:         if req_mod_name:
 13791:             base_kwargs[req_mod_name] = requests
 13792: 
 13793:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
 13794:         # qui n'a pas été défini ci-dessus, on le relaie.
 13795:         for k, v in list(user_kwargs.items()):
 13796:             if k in param_names and k not in base_kwargs:
 13797:                 base_kwargs[k] = v
 13798: 
 13799:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
 13800:         super().__init__(**base_kwargs)
 13801: 
 13802:     # --------------------- COMPTES / ASSETS ---------------------
 13803:     def get_assets(self) -> Dict[str, Any]:
 13804:         raw = super().get_assets()
 13805:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
 13806:         norm: List[Dict[str, Any]] = []
 13807:         for a in data:
 13808:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
 13809:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
 13810:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
 13811:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
 13812:         return {"success": True, "data": norm}
 13813: 
 13814:     # ------------------------ TICKER(S) -------------------------
 13815:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
 13816:         """
 13817:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
 13818:         Tolère top-level dict/list et items dict/list.
 13819:         """
 13820:         try:
 13821:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
 13822:         except Exception as e:
 13823:             return {"success": False, "error": repr(e), "data": []}
 13824: 
 13825:         items: List[Any] = []
 13826:         if isinstance(raw, dict):
 13827:             d = raw.get("data")
 13828:             if symbol and isinstance(d, dict):
 13829:                 items = [d]
 13830:             else:
 13831:                 items = d or raw.get("result") or raw.get("tickers") or []
 13832:         elif isinstance(raw, (list, tuple)):
 13833:             items = list(raw)
 13834: 
 13835:         norm: List[Dict[str, Any]] = []
 13836:         for t in items:
 13837:             if isinstance(t, dict):
 13838:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
 13839:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
 13840:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
 13841:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
 13842:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
 13843:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
 13844:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
 13845:                 norm.append({
 13846:                     "symbol": s,
 13847:                     "lastPrice": _to_float(last_),
 13848:                     "bidPrice": _to_float(bid_),
 13849:                     "askPrice": _to_float(ask_),
 13850:                     "volume": volume
 13851:                 })
 13852:             else:
 13853:                 seq = list(t)
 13854:                 if len(seq) >= 5:
 13855:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
 13856:                     if first_ts:
 13857:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
 13858:                     else:
 13859:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
 13860:                 else:
 13861:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
 13862:                 s = (symbol or "").replace("_", "")
 13863:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
 13864: 
 13865:         return {"success": True, "data": norm}
 13866: 
 13867:     # --------------- POSITIONS / ORDRES / FILLS -----------------
 13868:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
 13869:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
 13870:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
 13871:         out: List[Dict[str, Any]] = []
 13872:         for p in items:
 13873:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
 13874:             if symbol and s != symbol:
 13875:                 continue
 13876:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
 13877:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
 13878:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
 13879:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
 13880:         return {"success": True, "data": out}
 13881: 
 13882:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
 13883:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
 13884:         items = raw.get("data") or raw.get("result") or []
 13885:         out: List[Dict[str, Any]] = []
 13886:         for f in items[:limit]:
 13887:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
 13888:             if s != symbol:
 13889:                 continue
 13890:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
 13891:                 continue
 13892:             out.append({
 13893:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
 13894:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
 13895:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
 13896:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
 13897:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
 13898:                 "ts": int(f.get("ts", f.get("time", 0))),
 13899:             })
 13900:         return {"success": True, "data": out}
 13901: 
 13902:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
 13903:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
 13904:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
 13905:         return {"success": ok, "data": {"orderId": order_id}}
 13906: 
 13907: --------------------------------------------------------------------------------
 13908: FILE: scalper/adapters/bitget_fetch.py
 13909: --------------------------------------------------------------------------------
 13910: # scalper/adapters/bitget_fetch.py
 13911: from __future__ import annotations
 13912: 
 13913: import asyncio
 13914: import inspect
 13915: import os
 13916: from typing import Any, Optional
 13917: 
 13918: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
 13919: 
 13920: def _log(msg: str) -> None:
 13921:     if BT_DEBUG:
 13922:         print(f"[bt.debug] {msg}", flush=True)
 13923: 
 13924: _TF_TO_SECS = {
 13925:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
 13926:     "1h": 3600, "4h": 14400, "1d": 86400,
 13927: }
 13928: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
 13929:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
 13930:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
 13931: }
 13932: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
 13933:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
 13934:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
 13935: }
 13936: 
 13937: def _await_if_needed(val: Any) -> Any:
 13938:     if inspect.isawaitable(val):
 13939:         try:
 13940:             asyncio.get_running_loop()
 13941:         except RuntimeError:
 13942:             return asyncio.run(val)
 13943:         else:
 13944:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
 13945:             return fut.result()
 13946:     return val
 13947: 
 13948: class BitgetFetchAdapter:
 13949:     """
 13950:     Adaptateur qui fournit une méthode CCXT-like:
 13951:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
 13952:     au-dessus d'un client Bitget existant (sync ou async).
 13953:     """
 13954:     def __init__(self, client: Any, *, market_hint: str | None = None):
 13955:         self.client = client
 13956:         self.market_hint = (market_hint or "").lower() or None
 13957:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
 13958:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
 13959:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
 13960: 
 13961:     @staticmethod
 13962:     def _possible_methods(client: Any) -> list[str]:
 13963:         names = dir(client)
 13964:         base = [
 13965:             "fetch_ohlcv",
 13966:             "get_candlesticks", "candlesticks", "get_candles", "candles",
 13967:             "klines", "get_klines", "kline",
 13968:             "mix_get_candles", "mix_candles",
 13969:             "spot_get_candles", "spot_candles",
 13970:             "market_candles", "public_candles",
 13971:         ]
 13972:         # + heuristique: tout ce qui contient candle/kline
 13973:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
 13974:         out = []
 13975:         for n in base + extra:
 13976:             if n in names and callable(getattr(client, n)) and n not in out:
 13977:                 out.append(n)
 13978:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
 13979:         return out
 13980: 
 13981:     @staticmethod
 13982:     def _sym_variants(sym: str) -> list[str]:
 13983:         s = sym.upper()
 13984:         out = [s]
 13985:         if not s.endswith("_UMCBL"):
 13986:             out.append(f"{s}_UMCBL")
 13987:         if not s.endswith("_SPBL"):
 13988:             out.append(f"{s}_SPBL")
 13989:         _log(f"Variantes symbole testées: {out}")
 13990:         return out
 13991: 
 13992:     @staticmethod
 13993:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
 13994:         secs = _TF_TO_SECS.get(timeframe, 300)
 13995:         mix = _TF_TO_MIX.get(timeframe, "5min")
 13996:         spot = _TF_TO_SPOT.get(timeframe, "5min")
 13997:         variants = []
 13998:         if market_hint == "mix":
 13999:             variants.append({"granularity": mix})
 14000:         if market_hint == "spot":
 14001:             variants.append({"period": spot})
 14002:         variants += [
 14003:             {"timeframe": timeframe},
 14004:             {"interval": timeframe},
 14005:             {"k": secs},
 14006:             {"granularity": mix},
 14007:             {"period": spot},
 14008:         ]
 14009:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
 14010:         return variants
 14011: 
 14012:     @staticmethod
 14013:     def _normalize_rows(raw: Any) -> list[list[float]]:
 14014:         import pandas as pd  # local import
 14015:         if raw is None:
 14016:             raise ValueError("OHLCV vide")
 14017:         if isinstance(raw, dict) and "data" in raw:
 14018:             raw = raw["data"]
 14019:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
 14020:             out = []
 14021:             for r in raw:
 14022:                 ts = int(str(r[0]))
 14023:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
 14024:                 out.append([ts, o, h, l, c, v])
 14025:             return out
 14026:         if "pandas" in str(type(raw)):
 14027:             df = raw
 14028:             if "timestamp" in df.columns:
 14029:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
 14030:                 df = df.set_index("timestamp").sort_index()
 14031:             df = df[["open", "high", "low", "close", "volume"]]
 14032:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
 14033:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
 14034: 
 14035:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
 14036:         methods = self._possible_methods(self.client)
 14037:         if not methods:
 14038:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
 14039: 
 14040:         last_err: Exception | None = None
 14041:         for mname in methods:
 14042:             fn = getattr(self.client, mname)
 14043:             for sym in self._sym_variants(symbol):
 14044:                 for par in self._param_variants(timeframe, self.market_hint):
 14045:                     kwargs = dict(par)
 14046:                     kwargs.setdefault("symbol", sym)
 14047:                     kwargs.setdefault("limit", limit)
 14048:                     if since is not None:
 14049:                         kwargs.setdefault("since", since)
 14050:                     try:
 14051:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
 14052:                         res = _await_if_needed(fn(**kwargs))
 14053:                         rows = self._normalize_rows(res)
 14054:                         if rows:
 14055:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
 14056:                             first = rows[0][0]; last = rows[-1][0]
 14057:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
 14058:                                  f"t0={first} {unit}, t1={last} {unit}")
 14059:                             return rows
 14060:                     except TypeError as e:
 14061:                         _log(f"TypeError {mname} {sym} {par}: {e}")
 14062:                         last_err = e
 14063:                     except Exception as e:
 14064:                         _log(f"Erreur {mname} {sym} {par}: {e}")
 14065:                         last_err = e
 14066:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
 14067: 
 14068: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
 14069:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
 14070:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
 14071:         _log("exchange.fetch_ohlcv() déjà présent.")
 14072:         return exchange
 14073:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
 14074:     return BitgetFetchAdapter(exchange, market_hint=market_hint)
 14075: 
 14076: --------------------------------------------------------------------------------
 14077: FILE: scalper/adapters/market_data.py
 14078: --------------------------------------------------------------------------------
 14079: # scalper/backtest/market_data.py
 14080: from __future__ import annotations
 14081: 
 14082: import os
 14083: from pathlib import Path
 14084: from typing import Any
 14085: 
 14086: import pandas as pd
 14087: 
 14088: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
 14089: 
 14090: def _log(msg: str) -> None:
 14091:     if BT_DEBUG:
 14092:         print(f"[bt.debug] {msg}", flush=True)
 14093: 
 14094: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
 14095:     root = Path(data_dir)
 14096:     root.mkdir(parents=True, exist_ok=True)
 14097:     tf = timeframe.replace(":", "")
 14098:     return root / f"{symbol}-{tf}.csv"
 14099: 
 14100: def _read_csv(path: Path) -> pd.DataFrame:
 14101:     _log(f"lecture CSV: {path}")
 14102:     df = pd.read_csv(path)
 14103:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
 14104:     if ts_col is None:
 14105:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
 14106:     df = df.rename(columns={ts_col: "timestamp"})
 14107:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
 14108:     df = df.set_index("timestamp").sort_index()
 14109:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
 14110:     return df
 14111: 
 14112: def _write_csv(path: Path, df: pd.DataFrame) -> None:
 14113:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
 14114:     if "timestamp" not in tmp.columns:
 14115:         tmp = tmp.rename(columns={"index": "timestamp"})
 14116:     tmp.to_csv(path, index=False)
 14117:     _log(f"écrit CSV: {path} (n={len(df)})")
 14118: 
 14119: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
 14120:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
 14121:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
 14122:     # Normalisation minimaliste (liste de listes)
 14123:     rows = []
 14124:     for r in raw:
 14125:         ts = int(r[0])
 14126:         unit = "ms" if ts > 10_000_000_000 else "s"
 14127:         ts = pd.to_datetime(ts, unit=unit, utc=True)
 14128:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
 14129:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
 14130:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
 14131:     return df
 14132: 
 14133: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
 14134:     """
 14135:     Loader hybride:
 14136:       1) lit data/<SYMBOL>-<TF>.csv si présent,
 14137:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
 14138:     """
 14139:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
 14140:         path = _csv_path(data_dir, symbol, timeframe)
 14141:         if path.exists():
 14142:             df = _read_csv(path)
 14143:             src = "csv"
 14144:         else:
 14145:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
 14146:             _write_csv(path, df)
 14147:             src = "exchange"
 14148:         if start:
 14149:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
 14150:         if end:
 14151:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
 14152:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
 14153:              f"range=[{df.index.min()} .. {df.index.max()}]")
 14154:         return df
 14155:     return load
 14156: 
 14157: --------------------------------------------------------------------------------
 14158: FILE: scalper/backtest/__init__.py
 14159: --------------------------------------------------------------------------------
 14160: # scalper/backtest/__init__.py
 14161: from .runner import (
 14162:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
 14163:     run_multi, run_single,  # mêmes signatures async
 14164:     save_results,           # no-op compat
 14165: )
 14166: from .cache import (
 14167:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
 14168:     tf_to_seconds,
 14169: )
 14170: 
 14171: --------------------------------------------------------------------------------
 14172: FILE: scalper/backtest/cache.py
 14173: --------------------------------------------------------------------------------
 14174: # scalper/backtest/cache.py
 14175: from __future__ import annotations
 14176: 
 14177: import csv
 14178: import json
 14179: import os
 14180: import time
 14181: from dataclasses import dataclass
 14182: from pathlib import Path
 14183: from typing import Dict, List, Tuple, Iterable, Optional
 14184: 
 14185: # ---------------- Timeframe utils ----------------
 14186: 
 14187: _TF_SECONDS = {
 14188:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
 14189:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
 14190:     "1d": 86400, "3d": 259200, "1w": 604800,
 14191: }
 14192: 
 14193: def tf_to_seconds(tf: str) -> int:
 14194:     tf = tf.strip().lower()
 14195:     if tf not in _TF_SECONDS:
 14196:         raise ValueError(f"Timeframe inconnu: {tf}")
 14197:     return _TF_SECONDS[tf]
 14198: 
 14199: # ---------------- Fraîcheur cible par TF ----------------
 14200: 
 14201: _DEFAULT_MAX_AGE = {
 14202:     # règle empirique (peut être surchargée par ENV)
 14203:     "1m": 2 * 3600,        # 2h
 14204:     "3m": 4 * 3600,        # 4h
 14205:     "5m": 12 * 3600,       # 12h
 14206:     "15m": 24 * 3600,      # 24h
 14207:     "30m": 36 * 3600,      # 36h
 14208:     "1h": 3 * 86400,       # 3 jours
 14209:     "2h": 5 * 86400,       # 5 jours
 14210:     "4h": 10 * 86400,      # 10 jours
 14211:     "6h": 15 * 86400,      # 15 jours
 14212:     "12h": 20 * 86400,     # 20 jours
 14213:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
 14214:     "3d": 10 * 86400,
 14215:     "1w": 30 * 86400,
 14216: }
 14217: 
 14218: def max_age_for_tf(tf: str) -> int:
 14219:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
 14220:     tf = tf.lower()
 14221:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
 14222:     if env_key in os.environ:
 14223:         try:
 14224:             return int(os.environ[env_key])
 14225:         except Exception:
 14226:             pass
 14227:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
 14228: 
 14229: # ---------------- CSV I/O ----------------
 14230: 
 14231: def data_dir() -> Path:
 14232:     d = Path(os.getenv("DATA_DIR", "data"))
 14233:     d.mkdir(parents=True, exist_ok=True)
 14234:     return d
 14235: 
 14236: def csv_path(symbol: str, tf: str) -> Path:
 14237:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
 14238: 
 14239: def read_csv_ohlcv(path: Path) -> List[List[float]]:
 14240:     out: List[List[float]] = []
 14241:     if not path.exists():
 14242:         return out
 14243:     with path.open("r", newline="") as f:
 14244:         r = csv.reader(f)
 14245:         header = next(r, None)
 14246:         for row in r:
 14247:             # columns: timestamp,open,high,low,close,volume
 14248:             try:
 14249:                 ts, o, h, l, c, v = row[:6]
 14250:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
 14251:             except Exception:
 14252:                 continue
 14253:     return out
 14254: 
 14255: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
 14256:     new_file = not path.exists()
 14257:     with path.open("w", newline="") as f:
 14258:         w = csv.writer(f)
 14259:         w.writerow(["timestamp","open","high","low","close","volume"])
 14260:         for r in rows:
 14261:             w.writerow(r)
 14262: 
 14263: # ---------------- Validation / Chargement / Fetch ----------------
 14264: 
 14265: @dataclass
 14266: class CacheInfo:
 14267:     symbol: str
 14268:     tf: str
 14269:     path: Path
 14270:     exists: bool
 14271:     fresh: bool
 14272:     last_ts: Optional[int] = None
 14273:     rows: int = 0
 14274: 
 14275: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
 14276:     if not last_ts:
 14277:         return False
 14278:     age = int(time.time()) - int(last_ts / 1000)
 14279:     return age <= max_age_for_tf(tf)
 14280: 
 14281: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
 14282:     p = csv_path(symbol, tf)
 14283:     if not p.exists():
 14284:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
 14285:     rows = read_csv_ohlcv(p)
 14286:     last_ts = rows[-1][0] if rows else None
 14287:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
 14288: 
 14289: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
 14290:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
 14291:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
 14292: 
 14293: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
 14294:     info = inspect_csv(symbol, tf)
 14295:     if info.exists and info.fresh:
 14296:         data = read_csv_ohlcv(info.path)
 14297:         return info, data
 14298: 
 14299:     # fetch & persist
 14300:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
 14301:     if data:
 14302:         write_csv_ohlcv(info.path, data)
 14303:         info = inspect_csv(symbol, tf)  # refresh stats
 14304:     return info, data
 14305: 
 14306: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
 14307:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
 14308:     out: Dict[str, List[List[float]]] = {}
 14309:     for s in symbols:
 14310:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
 14311:         out[s] = rows
 14312:     return out
 14313: 
 14314: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
 14315:     report = []
 14316:     for s in symbols:
 14317:         info = inspect_csv(s, tf)
 14318:         report.append({
 14319:             "symbol": s,
 14320:             "tf": tf,
 14321:             "path": str(info.path),
 14322:             "exists": info.exists,
 14323:             "fresh": info.fresh,
 14324:             "last_ts": info.last_ts,
 14325:             "rows": info.rows,
 14326:             "max_age": max_age_for_tf(tf),
 14327:         })
 14328:     out_path.parent.mkdir(parents=True, exist_ok=True)
 14329:     out_path.write_text(json.dumps(report, indent=2))
 14330: 
 14331: --------------------------------------------------------------------------------
 14332: FILE: scalper/backtest/cli.py
 14333: --------------------------------------------------------------------------------
 14334: from __future__ import annotations
 14335: 
 14336: import argparse
 14337: from scalper.backtest.runner import run_multi, csv_loader_factory
 14338: 
 14339: def create_parser() -> argparse.ArgumentParser:
 14340:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
 14341:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
 14342:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
 14343:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
 14344:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
 14345:     p.add_argument("--cash", type=float, default=10_000.0)
 14346:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
 14347:     p.add_argument("--slippage-bps", type=float, default=1.5)
 14348:     return p
 14349: 
 14350: def main(argv: list[str] | None = None) -> int:
 14351:     p = create_parser()
 14352:     a = p.parse_args(argv)
 14353:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
 14354:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
 14355:     loader = csv_loader_factory(a.data_dir)
 14356:     run_multi(
 14357:         symbols=symbols,
 14358:         timeframes=tfs,
 14359:         loader=loader,
 14360:         out_dir=a.out_dir,
 14361:         initial_cash=a.cash,
 14362:         risk_pct=a.risk,
 14363:         slippage_bps=a.slippage_bps,
 14364:     )
 14365:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
 14366:     return 0
 14367: 
 14368: if __name__ == "__main__":
 14369:     raise SystemExit(main())
 14370: 
 14371: --------------------------------------------------------------------------------
 14372: FILE: scalper/backtest/engine.py
 14373: --------------------------------------------------------------------------------
 14374: # scalper/backtest/engine.py
 14375: from __future__ import annotations
 14376: from typing import Any, Dict, List, Optional, Tuple
 14377: import csv
 14378: import os
 14379: from dataclasses import dataclass
 14380: from scalper.strategy.factory import resolve_signal_fn
 14381: from scalper.core.signal import Signal
 14382: from scalper.backtest.position_sizing import position_size_from_signal, fees_cost
 14383: 
 14384: @dataclass
 14385: class Trade:
 14386:     symbol: str
 14387:     timeframe: str
 14388:     side: str
 14389:     entry_ts: int
 14390:     exit_ts: int
 14391:     entry: float
 14392:     exit: float
 14393:     qty: float
 14394:     pnl: float
 14395:     pnl_after_fees: float
 14396:     reasons: str
 14397: 
 14398: def _read_csv(path: str) -> Dict[str, List[float]]:
 14399:     cols = ("timestamp","open","high","low","close","volume")
 14400:     out = {k: [] for k in cols}
 14401:     with open(path, "r", newline="", encoding="utf-8") as f:
 14402:         r = csv.DictReader(f)
 14403:         for row in r:
 14404:             for k in cols:
 14405:                 out[k].append(float(row[k]))
 14406:     return out
 14407: 
 14408: def _slice(d: Dict[str, List[float]], end_idx: int) -> Dict[str, List[float]]:
 14409:     return {k: v[: end_idx + 1] for k, v in d.items()}
 14410: 
 14411: class BacktestEngine:
 14412:     def __init__(
 14413:         self,
 14414:         *,
 14415:         symbol: str,
 14416:         timeframe: str,
 14417:         data: Dict[str, List[float]],
 14418:         equity_start: float = 1_000.0,
 14419:         risk_pct: float = 0.01,
 14420:         fees_bps: float = 6.0,
 14421:         warmup: int = 230,
 14422:         strategies_cfg: Dict[str, Any],
 14423:         data_1h: Optional[Dict[str, List[float]]] = None,
 14424:     ):
 14425:         self.symbol = symbol.upper()
 14426:         self.tf = timeframe
 14427:         self.data = data
 14428:         self.data_1h = data_1h
 14429:         self.equity = float(equity_start)
 14430:         self.start_equity = float(equity_start)
 14431:         self.risk_pct = float(risk_pct)
 14432:         self.fees_bps = float(fees_bps)
 14433:         self.warmup = int(warmup)
 14434:         self.cfg = strategies_cfg
 14435:         self.trades: List[Trade] = []
 14436:         self.signals_rows: List[Dict[str, Any]] = []
 14437:         self.signal_fn = resolve_signal_fn(self.symbol, self.tf, self.cfg)
 14438: 
 14439:     def run(self) -> Tuple[float, List[Trade]]:
 14440:         n = len(self.data["close"])
 14441:         pos_open: Optional[Signal] = None
 14442:         pos_qty: float = 0.0
 14443:         entry_idx: int = -1
 14444: 
 14445:         for i in range(self.warmup, n):
 14446:             window = _slice(self.data, i)
 14447:             window_1h = _slice(self.data_1h, self._map_1h_index(i)) if self.data_1h else None
 14448: 
 14449:             sig = self.signal_fn(
 14450:                 symbol=self.symbol, timeframe=self.tf, ohlcv=window,
 14451:                 equity=self.equity, risk_pct=self.risk_pct, ohlcv_1h=window_1h,
 14452:             )
 14453:             if sig:
 14454:                 self.signals_rows.append(sig.as_dict())
 14455: 
 14456:             if pos_open is None and sig is not None:
 14457:                 qty = position_size_from_signal(self.equity, sig, self.risk_pct * max(0.25, sig.quality))
 14458:                 if qty <= 0:
 14459:                     continue
 14460:                 pos_open, pos_qty, entry_idx = sig, qty, i
 14461:                 continue
 14462: 
 14463:             if pos_open is not None:
 14464:                 hi = self.data["high"][i]
 14465:                 lo = self.data["low"][i]
 14466:                 exit_price: Optional[float] = None
 14467:                 tp1 = pos_open.tp1 or pos_open.entry
 14468:                 tp2 = pos_open.tp2 or pos_open.entry
 14469:                 half_closed = False
 14470:                 be = pos_open.entry
 14471: 
 14472:                 if pos_open.side == "long":
 14473:                     if lo <= pos_open.sl:
 14474:                         exit_price = pos_open.sl
 14475:                     elif hi >= tp1:
 14476:                         pnl_half = (tp1 - pos_open.entry) * (pos_qty * 0.5)
 14477:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
 14478:                         self.equity += pnl_half - fees
 14479:                         pos_qty *= 0.5
 14480:                         half_closed = True
 14481:                         pos_open.sl = be
 14482:                     if hi >= tp2:
 14483:                         exit_price = tp2
 14484:                 else:
 14485:                     if hi >= pos_open.sl:
 14486:                         exit_price = pos_open.sl
 14487:                     elif lo <= tp1:
 14488:                         pnl_half = (pos_open.entry - tp1) * (pos_qty * 0.5)
 14489:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
 14490:                         self.equity += pnl_half - fees
 14491:                         pos_qty *= 0.5
 14492:                         half_closed = True
 14493:                         pos_open.sl = be
 14494:                     if lo <= tp2:
 14495:                         exit_price = tp2
 14496: 
 14497:                 if exit_price is None and half_closed:
 14498:                     continue
 14499: 
 14500:                 if exit_price is not None:
 14501:                     pnl = (exit_price - pos_open.entry) * pos_qty if pos_open.side == "long" else (pos_open.entry - exit_price) * pos_qty
 14502:                     fees = fees_cost(exit_price * pos_qty, self.fees_bps)
 14503:                     pnl_after = pnl - fees
 14504:                     self.equity += pnl_after
 14505: 
 14506:                     tr = Trade(
 14507:                         symbol=self.symbol, timeframe=self.tf, side=pos_open.side,
 14508:                         entry_ts=int(self.data["timestamp"][entry_idx]), exit_ts=int(self.data["timestamp"][i]),
 14509:                         entry=pos_open.entry, exit=exit_price, qty=pos_qty,
 14510:                         pnl=pnl, pnl_after_fees=pnl_after, reasons="|".join(pos_open.reasons),
 14511:                     )
 14512:                     self.trades.append(tr)
 14513:                     pos_open, pos_qty, entry_idx = None, 0.0, -1
 14514: 
 14515:         return self.equity, self.trades
 14516: 
 14517:     def _map_1h_index(self, i_main: int) -> int:
 14518:         if not self.data_1h:
 14519:             return 0
 14520:         ts = self.data["timestamp"][i_main]
 14521:         arr = self.data_1h["timestamp"]
 14522:         j = 0
 14523:         while j + 1 < len(arr) and arr[j + 1] <= ts:
 14524:             j += 1
 14525:         return j
 14526: 
 14527:     # --- E/S helpers ---
 14528:     @staticmethod
 14529:     def load_csv(path: str) -> Dict[str, List[float]]:
 14530:         if not os.path.isfile(path):
 14531:             raise FileNotFoundError(f"CSV OHLCV introuvable: {path}")
 14532:         return _read_csv(path)
 14533: 
 14534:     def save_results(self, out_dir: str = "backtest_out") -> None:
 14535:         os.makedirs(out_dir, exist_ok=True)
 14536:         if self.signals_rows:
 14537:             sig_path = os.path.join(out_dir, f"signals_{self.symbol}_{self.tf}.csv")
 14538:             keys = sorted(self.signals_rows[0].keys())
 14539:             with open(sig_path, "w", newline="", encoding="utf-8") as f:
 14540:                 import csv
 14541:                 w = csv.DictWriter(f, fieldnames=keys)
 14542:                 w.writeheader()
 14543:                 for row in self.signals_rows:
 14544:                     w.writerow(row)
 14545:         if self.trades:
 14546:             tr_path = os.path.join(out_dir, f"trades_{self.symbol}_{self.tf}.csv")
 14547:             with open(tr_path, "w", newline="", encoding="utf-8") as f:
 14548:                 import csv
 14549:                 w = csv.writer(f)
 14550:                 w.writerow(["symbol","timeframe","side","entry_ts","exit_ts","entry","exit","qty","pnl","pnl_after_fees","reasons"])
 14551:                 for t in self.trades:
 14552:                     w.writerow([t.symbol,t.timeframe,t.side,t.entry_ts,t.exit_ts,t.entry,t.exit,t.qty,t.pnl,t.pnl_after_fees,t.reasons])
 14553: 
 14554:     def summary(self) -> Dict[str, float]:
 14555:         eq = self.equity
 14556:         ret = (eq / self.start_equity - 1.0) * 100.0
 14557:         n = len(self.trades)
 14558:         wins = sum(1 for t in self.trades if t.pnl_after_fees > 0)
 14559:         winrate = (wins / n * 100.0) if n else 0.0
 14560:         return {"equity_end": eq, "return_pct": ret, "trades": float(n), "winrate_pct": winrate}
 14561: 
 14562: --------------------------------------------------------------------------------
 14563: FILE: scalper/backtest/grid_search.py
 14564: --------------------------------------------------------------------------------
 14565: """Grid-search express module to evaluate hyperparameter combinations.
 14566: 
 14567: This module builds combinations of strategy and engine parameters, runs the
 14568: existing multi symbol backtester for each combination, collects key metrics and
 14569: selects the best configuration according to:
 14570: 
 14571: 1. Profit factor (descending)
 14572: 2. Maximum drawdown percentage (ascending)
 14573: 3. Net PnL in USDT (descending)
 14574: 4. Number of trades (ascending)
 14575: 
 14576: Results are written under ``result/grid`` by default and a short summary is
 14577: printed to the console.
 14578: """
 14579: from __future__ import annotations
 14580: 
 14581: from dataclasses import dataclass
 14582: import csv
 14583: import json
 14584: import os
 14585: import random
 14586: from itertools import product
 14587: from typing import Any, Callable, Dict, Iterable, List, Sequence
 14588: 
 14589: # ---------------------------------------------------------------------------
 14590: # Utilities
 14591: # ---------------------------------------------------------------------------
 14592: 
 14593: 
 14594: def parse_hours(hours: str) -> List[int]:
 14595:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
 14596: 
 14597:     Each comma separated element can either be a single hour (``"8"``) or a
 14598:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
 14599:     """
 14600: 
 14601:     if not hours:
 14602:         return []
 14603:     result: List[int] = []
 14604:     for part in hours.split(","):
 14605:         part = part.strip()
 14606:         if not part:
 14607:             continue
 14608:         if "-" in part:
 14609:             start_s, end_s = part.split("-", 1)
 14610:             start, end = int(start_s), int(end_s)
 14611:             result.extend(range(start, end + 1))
 14612:         else:
 14613:             result.append(int(part))
 14614:     return sorted(set(result))
 14615: 
 14616: 
 14617: # Order of parameters used throughout the module and in CSV output
 14618: PARAM_KEYS = [
 14619:     "timeframe",
 14620:     "score_min",
 14621:     "atr_min_ratio",
 14622:     "rr_min",
 14623:     "risk_pct",
 14624:     "slippage_bps",
 14625:     "fee_rate",
 14626:     "cooldown_secs",
 14627:     "hours",
 14628: ]
 14629: 
 14630: # Default values used if a parameter is not provided in the grid
 14631: DEFAULTS = {
 14632:     "score_min": 55,
 14633:     "atr_min_ratio": 0.002,
 14634:     "rr_min": 1.2,
 14635:     "risk_pct": 0.01,
 14636:     "slippage_bps": 2,
 14637:     "fee_rate": 0.001,
 14638:     "cooldown_secs": 300,
 14639:     "hours": "7-11,13-17",
 14640: }
 14641: 
 14642: 
 14643: @dataclass
 14644: class GridResult:
 14645:     params: Dict[str, Any]
 14646:     metrics: Dict[str, float]
 14647: 
 14648: 
 14649: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
 14650:     if isinstance(val, (list, tuple, set)):
 14651:         return list(val)
 14652:     return [val]
 14653: 
 14654: 
 14655: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
 14656:     """Return a list of parameter combinations.
 14657: 
 14658:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
 14659:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
 14660:     sampled to ``grid_max`` elements when necessary while trying to maintain a
 14661:     variety of timeframes and ``atr_min_ratio`` values.
 14662:     """
 14663: 
 14664:     lists: Dict[str, List[Any]] = {}
 14665:     for key in PARAM_KEYS:
 14666:         if key == "timeframe":
 14667:             # timeframe must be explicitly provided; default empty -> "1m"
 14668:             vals = param_lists.get(key) or ["1m"]
 14669:         else:
 14670:             vals = param_lists.get(key)
 14671:             if not vals:
 14672:                 default = DEFAULTS[key]
 14673:                 vals = [default]
 14674:         lists[key] = _ensure_list(vals)
 14675: 
 14676:     combos: List[Dict[str, Any]] = [
 14677:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
 14678:     ]
 14679: 
 14680:     # Uniform sampling if exceeding grid_max
 14681:     if len(combos) > grid_max:
 14682:         step = len(combos) / float(grid_max)
 14683:         sampled = []
 14684:         for i in range(grid_max):
 14685:             idx = int(round(i * step))
 14686:             if idx >= len(combos):
 14687:                 idx = len(combos) - 1
 14688:             sampled.append(combos[idx])
 14689:         # ensure each timeframe appears at least once
 14690:         wanted_tfs = set(lists["timeframe"])
 14691:         present_tfs = {c["timeframe"] for c in sampled}
 14692:         missing = list(wanted_tfs - present_tfs)
 14693:         if missing:
 14694:             for tf in missing:
 14695:                 for c in combos:
 14696:                     if c["timeframe"] == tf and c not in sampled:
 14697:                         sampled.append(c)
 14698:                         break
 14699:             sampled = sampled[:grid_max]
 14700:         combos = sampled
 14701:     return combos
 14702: 
 14703: 
 14704: # ---------------------------------------------------------------------------
 14705: # Core runner
 14706: # ---------------------------------------------------------------------------
 14707: 
 14708: 
 14709: def run_grid_search(
 14710:     *,
 14711:     symbols: Sequence[str],
 14712:     exchange: str,
 14713:     base_params: Dict[str, Any],
 14714:     param_lists: Dict[str, Sequence[Any]],
 14715:     grid_max: int = 12,
 14716:     csv_dir: str | None = None,
 14717:     initial_equity: float = 1000.0,
 14718:     leverage: float = 1.0,
 14719:     paper_constraints: bool = True,
 14720:     seed: int | None = None,
 14721:     out_dir: str = "./result/grid",
 14722:     match_exchange_semantics: bool = False,  # placeholder for compatibility
 14723:     run_func: Callable[..., Any] | None = None,
 14724: ) -> List[GridResult]:
 14725:     """Execute grid search across parameter combinations.
 14726: 
 14727:     ``base_params`` provides default single values for parameters. ``param_lists``
 14728:     contains the grid specifications from CLI (already parsed into sequences).
 14729:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
 14730:     """
 14731: 
 14732:     if seed is not None:
 14733:         random.seed(seed)
 14734: 
 14735:     if run_func is None:  # avoid circular import at module load
 14736:         from .run_multi import run_backtest_multi  # late import
 14737: 
 14738:         run_func = run_backtest_multi
 14739: 
 14740:     # merge lists with defaults
 14741:     full_lists: Dict[str, Sequence[Any]] = {}
 14742:     for k in PARAM_KEYS:
 14743:         if k == "timeframe":
 14744:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
 14745:         else:
 14746:             if param_lists.get(k) is not None:
 14747:                 full_lists[k] = param_lists[k]
 14748:             else:
 14749:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
 14750: 
 14751:     combos = build_param_grid(full_lists, grid_max)
 14752: 
 14753:     results: List[GridResult] = []
 14754:     os.makedirs(out_dir, exist_ok=True)
 14755: 
 14756:     for combo in combos:
 14757:         # Build parameters for backtester
 14758:         tf = combo["timeframe"]
 14759:         fee = float(combo["fee_rate"])
 14760:         slip = float(combo["slippage_bps"])
 14761:         risk = float(combo["risk_pct"])
 14762: 
 14763:         summary, _trades = run_func(
 14764:             symbols=list(symbols),
 14765:             exchange=exchange,
 14766:             timeframe=tf,
 14767:             csv_dir=csv_dir,
 14768:             fee_rate=fee,
 14769:             slippage_bps=slip,
 14770:             risk_pct=risk,
 14771:             initial_equity=initial_equity,
 14772:             leverage=leverage,
 14773:             paper_constraints=paper_constraints,
 14774:             seed=seed,
 14775:             out_dir=os.path.join(out_dir, "tmp"),
 14776:             plot=False,
 14777:             dry_run=True,
 14778:         )
 14779:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
 14780:         metrics = {
 14781:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
 14782:             "profit_factor": float(total.get("profit_factor", 0.0)),
 14783:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
 14784:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
 14785:             "trades": float(total.get("trades", 0.0)),
 14786:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
 14787:         }
 14788:         results.append(GridResult(params=combo, metrics=metrics))
 14789: 
 14790:     # sort results
 14791:     results.sort(
 14792:         key=lambda r: (
 14793:             -r.metrics["profit_factor"],
 14794:             r.metrics["max_dd_pct"],
 14795:             -r.metrics["pnl_usdt"],
 14796:             r.metrics["trades"],
 14797:         )
 14798:     )
 14799: 
 14800:     # console output -------------------------------------------------------
 14801:     print(
 14802:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
 14803:     )
 14804:     header = (
 14805:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
 14806:     )
 14807:     print(header)
 14808:     for r in results[:10]:
 14809:         m = r.metrics
 14810:         print(
 14811:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
 14812:         )
 14813: 
 14814:     # write csv ------------------------------------------------------------
 14815:     csv_cols = PARAM_KEYS + [
 14816:         "pnl_usdt",
 14817:         "profit_factor",
 14818:         "max_dd_pct",
 14819:         "winrate_pct",
 14820:         "trades",
 14821:         "final_equity",
 14822:     ]
 14823:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
 14824:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
 14825:         writer.writeheader()
 14826:         for r in results:
 14827:             row = {**r.params, **r.metrics}
 14828:             writer.writerow(row)
 14829: 
 14830:     best = results[0]
 14831:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
 14832:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
 14833: 
 14834:     # markdown summary -----------------------------------------------------
 14835:     md_path = os.path.join(out_dir, "grid_summary.md")
 14836:     with open(md_path, "w", encoding="utf8") as fh:
 14837:         fh.write(
 14838:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
 14839:         )
 14840:         for r in results[:10]:
 14841:             m = r.metrics
 14842:             fh.write(
 14843:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
 14844:             )
 14845: 
 14846:     # optional scatter plot ------------------------------------------------
 14847:     try:  # pragma: no cover - optional dependency
 14848:         import matplotlib.pyplot as plt
 14849: 
 14850:         pf = [r.metrics["profit_factor"] for r in results]
 14851:         dd = [r.metrics["max_dd_pct"] for r in results]
 14852:         trades = [r.metrics["trades"] for r in results]
 14853:         tfs = [r.params["timeframe"] for r in results]
 14854:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
 14855:         c = [colors[tf] for tf in tfs]
 14856:         plt.figure(figsize=(6, 4))
 14857:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
 14858:         plt.xlabel("MaxDD%")
 14859:         plt.ylabel("Profit Factor")
 14860:         plt.title("PF vs MaxDD")
 14861:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
 14862:         plt.close()
 14863:     except Exception:  # pragma: no cover
 14864:         pass
 14865: 
 14866:     return results
 14867: 
 14868: 
 14869: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]
 14870: 
 14871: 
 14872: --------------------------------------------------------------------------------
 14873: FILE: scalper/backtest/loader_csv.py
 14874: --------------------------------------------------------------------------------
 14875: # scalper/backtest/loader_csv.py
 14876: from __future__ import annotations
 14877: 
 14878: import csv
 14879: from typing import Dict, List
 14880: 
 14881: from scalper.services.data_cache import csv_path
 14882: 
 14883: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
 14884: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
 14885:     path = csv_path(symbol, timeframe)
 14886:     rows: List[List[float]] = []
 14887:     with open(path, "r") as f:
 14888:         r = csv.DictReader(f)
 14889:         for row in r:
 14890:             rows.append([
 14891:                 int(row["timestamp"]),
 14892:                 float(row["open"]),
 14893:                 float(row["high"]),
 14894:                 float(row["low"]),
 14895:                 float(row["close"]),
 14896:                 float(row["volume"]),
 14897:             ])
 14898:     rows.sort(key=lambda x: x[0])
 14899:     return rows
 14900: 
 14901: 
 14902: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
 14903:     out: Dict[str, List[List[float]]] = {}
 14904:     for s in symbols:
 14905:         out[s] = load_ohlcv_csv(s, timeframe)
 14906:     return out
 14907: 
 14908: --------------------------------------------------------------------------------
 14909: FILE: scalper/backtest/market_data.py
 14910: --------------------------------------------------------------------------------
 14911: from __future__ import annotations
 14912: 
 14913: import json
 14914: import os
 14915: import time
 14916: from pathlib import Path
 14917: from typing import Any, Iterable, Optional, Sequence, Tuple
 14918: from urllib.request import Request, urlopen
 14919: from urllib.error import URLError, HTTPError
 14920: 
 14921: import pandas as pd
 14922: 
 14923: # ============================================================================
 14924: # Logs & utilitaires
 14925: # ============================================================================
 14926: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
 14927: def _log(msg: str) -> None:
 14928:     if BT_DEBUG:
 14929:         print(f"[bt.debug] {msg}", flush=True)
 14930: 
 14931: def _now_ms() -> int:
 14932:     return int(time.time() * 1000)
 14933: 
 14934: def _tf_to_seconds(tf: str) -> int:
 14935:     tf = tf.lower().strip()
 14936:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
 14937:     if tf not in table:
 14938:         raise ValueError(f"Timeframe non supporté: {tf}")
 14939:     return table[tf]
 14940: 
 14941: def _parse_duration(s: str) -> int:
 14942:     """
 14943:     '90s','15m','2h','3d' -> secondes
 14944:     """
 14945:     s = s.strip().lower()
 14946:     if s.endswith("s"): return int(float(s[:-1]))
 14947:     if s.endswith("m"): return int(float(s[:-1])*60)
 14948:     if s.endswith("h"): return int(float(s[:-1])*3600)
 14949:     if s.endswith("d"): return int(float(s[:-1])*86400)
 14950:     return int(float(s))  # secondes
 14951: 
 14952: # ============================================================================
 14953: # Politique de fraîcheur (par défaut + overrides via ENV)
 14954: # ============================================================================
 14955: def _default_max_age_seconds(tf: str) -> int:
 14956:     """
 14957:     Règles par défaut (conservatrices) :
 14958:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
 14959:       - 30m     : 1h
 14960:       - 1h      : 6h
 14961:       - 4h      : 24h
 14962:       - 1d      : 3d
 14963:     """
 14964:     tf = tf.lower()
 14965:     if tf in ("1m","3m","5m","15m"):
 14966:         return 2 * _tf_to_seconds(tf)
 14967:     if tf == "30m":
 14968:         return 3600
 14969:     if tf == "1h":
 14970:         return 6*3600
 14971:     if tf == "4h":
 14972:         return 24*3600
 14973:     if tf == "1d":
 14974:         return 3*86400
 14975:     raise ValueError(tf)
 14976: 
 14977: def _max_age_seconds(tf: str) -> int:
 14978:     """
 14979:     Overrides possibles (au choix) :
 14980:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
 14981:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
 14982:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
 14983:     """
 14984:     tfk = tf.lower().replace(":", "")
 14985:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
 14986:     if env_spec:
 14987:         return _parse_duration(env_spec)
 14988:     mult = os.getenv("CSV_MAX_AGE_MULT")
 14989:     if mult:
 14990:         return int(float(mult) * _tf_to_seconds(tf))
 14991:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
 14992:     if g:
 14993:         return _parse_duration(g)
 14994:     return _default_max_age_seconds(tf)
 14995: 
 14996: # ============================================================================
 14997: # CSV helpers + validation
 14998: # ============================================================================
 14999: def _data_dir(default: str = "data") -> Path:
 15000:     root = Path(os.getenv("DATA_DIR", default))
 15001:     root.mkdir(parents=True, exist_ok=True)
 15002:     return root
 15003: 
 15004: def _csv_path(symbol: str, timeframe: str) -> Path:
 15005:     tf = timeframe.replace(":", "")
 15006:     return _data_dir() / f"{symbol}-{tf}.csv"
 15007: 
 15008: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
 15009:     rows = list(rows)
 15010:     if not rows:
 15011:         raise ValueError("OHLCV vide")
 15012:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
 15013:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
 15014:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
 15015:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
 15016: 
 15017: def _read_csv(path: Path) -> pd.DataFrame:
 15018:     df = pd.read_csv(path)
 15019:     # tolère quelques variations de colonnes
 15020:     cols = {c.lower(): c for c in df.columns}
 15021:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
 15022:     if not ts_col:
 15023:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
 15024:     rename = {ts_col: "timestamp"}
 15025:     for c in ("open","high","low","close","volume"):
 15026:         if c not in cols:
 15027:             raise ValueError(f"Colonne manquante: {c}")
 15028:         rename[cols[c]] = c
 15029:     df = df.rename(columns=rename)
 15030:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
 15031:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
 15032:     df = df.drop_duplicates("timestamp")
 15033:     df = df.set_index("timestamp")
 15034:     return df
 15035: 
 15036: def _write_csv(path: Path, df: pd.DataFrame) -> None:
 15037:     out = df.reset_index().rename(columns={"index": "timestamp"})
 15038:     out.to_csv(path, index=False)
 15039: 
 15040: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
 15041:     """
 15042:     Retourne (ok, reason). ok=True si le CSV est utilisable:
 15043:       - schéma valide
 15044:       - assez de lignes
 15045:       - fraîcheur < seuil selon TF
 15046:     """
 15047:     if not path.exists():
 15048:         return False, "absent"
 15049:     try:
 15050:         df = _read_csv(path)
 15051:     except Exception as e:
 15052:         return False, f"invalid({e})"
 15053:     if len(df) < min_rows:
 15054:         return False, f"too_few_rows({len(df)}<{min_rows})"
 15055:     # Fraîcheur
 15056:     last_ts = int(df.index.max().timestamp())
 15057:     age_s = int(time.time()) - last_ts
 15058:     max_age = _max_age_seconds(timeframe)
 15059:     if age_s > max_age:
 15060:         return False, f"stale({age_s}s>{max_age}s)"
 15061:     # Monotonicité (échantillon)
 15062:     if not df.index.is_monotonic_increasing:
 15063:         return False, "not_monotonic"
 15064:     return True, "ok"
 15065: 
 15066: # ============================================================================
 15067: # Fallback réseau (CCXT d'abord, HTTP sinon)
 15068: # ============================================================================
 15069: def _ensure_ccxt() -> Any | None:
 15070:     try:
 15071:         import ccxt  # type: ignore
 15072:         return ccxt
 15073:     except Exception:
 15074:         return None
 15075: 
 15076: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
 15077:     ccxt = _ensure_ccxt()
 15078:     if not ccxt:
 15079:         _log("ccxt indisponible")
 15080:         return None
 15081:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
 15082:     ex.load_markets()
 15083:     base = symbol.upper()
 15084:     if not base.endswith("USDT"):
 15085:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
 15086:     coin = base[:-4]
 15087:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
 15088:     for ccxt_sym in candidates:
 15089:         try:
 15090:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
 15091:             if rows:
 15092:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
 15093:         except Exception as e:
 15094:             _log(f"ccxt fail {ccxt_sym}: {e}")
 15095:             continue
 15096:     return None
 15097: 
 15098: # === (facultatif) HTTP Bitget v1 minimal ===
 15099: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
 15100: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
 15101: 
 15102: def _http_get(url: str, timeout: int = 20) -> dict | list:
 15103:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
 15104:     with urlopen(req, timeout=timeout) as resp:
 15105:         return json.loads(resp.read().decode("utf-8"))
 15106: 
 15107: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
 15108:     rows = payload.get("data") if isinstance(payload, dict) else payload
 15109:     if not isinstance(rows, list):
 15110:         raise ValueError(f"Réponse inattendue: {payload}")
 15111:     out = []
 15112:     for r in rows:
 15113:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
 15114:         out.append([ts,o,h,l,c,v])
 15115:     out.sort(key=lambda x:x[0])
 15116:     return out
 15117: 
 15118: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
 15119:     tf = timeframe.lower()
 15120:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
 15121:     if not (g and p):
 15122:         return None
 15123:     # mix umcbl puis spot spbl, paramètres minimum (v1)
 15124:     trials = [
 15125:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
 15126:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
 15127:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
 15128:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
 15129:     ]
 15130:     for url in trials:
 15131:         try:
 15132:             payload = _http_get(url)
 15133:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
 15134:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
 15135:             rows = _normalize_http_rows(payload)
 15136:             if rows:
 15137:                 return _rows_to_df(rows)
 15138:         except Exception as e:
 15139:             _log(f"HTTP fail: {url} -> {e}")
 15140:             continue
 15141:     return None
 15142: 
 15143: # ============================================================================
 15144: # API publique utilisée par l’orchestrateur/backtest
 15145: # ============================================================================
 15146: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
 15147:     """
 15148:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
 15149:     """
 15150:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
 15151:     if df is not None:
 15152:         _log(f"source=ccxt  n={len(df)}")
 15153:         return df
 15154:     df = _fetch_via_http(symbol, timeframe, limit=limit)
 15155:     if df is not None:
 15156:         _log(f"source=http  n={len(df)}")
 15157:         return df
 15158:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
 15159: 
 15160: def hybrid_loader(
 15161:     data_dir: str = "data",
 15162:     *,
 15163:     use_cache_first: bool = True,
 15164:     min_rows: int = 100,
 15165:     refill_if_stale: bool = True,
 15166:     network_limit: int = 1000,
 15167: ):
 15168:     """
 15169:     Loader smart :
 15170:       1) si CSV présent ET frais/valide → le renvoie
 15171:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
 15172:       3) sinon → lève
 15173:     """
 15174:     os.environ.setdefault("DATA_DIR", data_dir)
 15175: 
 15176:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
 15177:         path = _csv_path(symbol, timeframe)
 15178: 
 15179:         if use_cache_first:
 15180:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
 15181:             if ok:
 15182:                 _log(f"CSV OK: {path}")
 15183:                 df = _read_csv(path)
 15184:             else:
 15185:                 _log(f"CSV non utilisable ({why}): {path}")
 15186:                 if not refill_if_stale:
 15187:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
 15188:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
 15189:                 _write_csv(path, df)
 15190:         else:
 15191:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
 15192:             _write_csv(path, df)
 15193: 
 15194:         # Fenêtrage temporel si demandé (timestamps UTC)
 15195:         if start:
 15196:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
 15197:         if end:
 15198:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
 15199:         return df
 15200: 
 15201:     return load
 15202: 
 15203: --------------------------------------------------------------------------------
 15204: FILE: scalper/backtest/metrics.py
 15205: --------------------------------------------------------------------------------
 15206: from __future__ import annotations
 15207: import math
 15208: from dataclasses import dataclass
 15209: from typing import List, Dict
 15210: 
 15211: @dataclass
 15212: class Trade:
 15213:     ts: int
 15214:     side: str
 15215:     entry: float
 15216:     exit: float
 15217:     pnl_abs: float
 15218:     pnl_pct: float
 15219:     dur_min: float
 15220: 
 15221: def equity_to_drawdown(equity: List[float]) -> float:
 15222:     peak = -1e18; maxdd = 0.0
 15223:     for v in equity:
 15224:         if v > peak: peak = v
 15225:         dd = 0.0 if peak == 0 else (peak - v) / peak
 15226:         if dd > maxdd: maxdd = dd
 15227:     return maxdd
 15228: 
 15229: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
 15230:     # returns: per-bar (ex: par 5m) log or simple; ici simple
 15231:     if not returns: return 0.0
 15232:     mean = sum(returns)/len(returns)
 15233:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
 15234:     std = math.sqrt(var) if var>0 else 0.0
 15235:     if std == 0: return 0.0
 15236:     return (mean - rf) / std * math.sqrt(period_per_year)
 15237: 
 15238: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
 15239:     wins = [t for t in trades if t.pnl_abs > 0]
 15240:     losses = [t for t in trades if t.pnl_abs < 0]
 15241:     wr = len(wins)/len(trades) if trades else 0.0
 15242:     gross_win = sum(t.pnl_abs for t in wins)
 15243:     gross_loss = abs(sum(t.pnl_abs for t in losses))
 15244:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
 15245:     mdd = equity_to_drawdown(equity)
 15246:     shp = sharpe(bar_returns)
 15247:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
 15248:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
 15249:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
 15250:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
 15251:     return {
 15252:         "trades": len(trades),
 15253:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
 15254:         "expectancy": expectancy, "cagr": cagr, "score": score,
 15255:         "equity_start": equity[0] if equity else None,
 15256:         "equity_end": equity[-1] if equity else None,
 15257:     }
 15258: 
 15259: --------------------------------------------------------------------------------
 15260: FILE: scalper/backtest/optimize.py
 15261: --------------------------------------------------------------------------------
 15262: from __future__ import annotations
 15263: 
 15264: """Parameter sweep utilities for strategy optimisation.
 15265: 
 15266: This module performs a grid search over a parameter space in parallel.  It
 15267: tries to use :mod:`ray` for distributed execution when available and falls
 15268: back to :mod:`multiprocessing` otherwise.
 15269: """
 15270: 
 15271: import itertools
 15272: import json
 15273: import multiprocessing as mp
 15274: import os
 15275: from typing import Any, Dict, Iterable, List, Sequence
 15276: 
 15277: try:  # Optional dependency
 15278:     import ray  # type: ignore
 15279: except Exception:  # pragma: no cover - ray is optional
 15280:     ray = None
 15281: 
 15282: from scalper.backtest import backtest_trades
 15283: 
 15284: 
 15285: # ---------------------------------------------------------------------------
 15286: # Parameter space
 15287: # ---------------------------------------------------------------------------
 15288: 
 15289: def param_space_default() -> Dict[str, Sequence[Any]]:
 15290:     """Return the default parameter search space.
 15291: 
 15292:     The keys correspond to strategy parameters while the values are iterables
 15293:     of possible settings.  The defaults represent a small but representative
 15294:     grid and can be overridden by callers.
 15295:     """
 15296: 
 15297:     return {
 15298:         "ema_fast": [10, 20, 30],
 15299:         "ema_slow": [50, 100, 200],
 15300:         "rsi_period": [14, 21],
 15301:         "atr_period": [14, 21],
 15302:     }
 15303: 
 15304: 
 15305: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
 15306:     """Expand *space* into a list of parameter combinations."""
 15307: 
 15308:     keys = list(space)
 15309:     values = [space[k] for k in keys]
 15310:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
 15311: 
 15312: 
 15313: # ---------------------------------------------------------------------------
 15314: # Evaluation
 15315: # ---------------------------------------------------------------------------
 15316: 
 15317: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
 15318:     """Run a backtest for a single parameter combination.
 15319: 
 15320:     ``grid_item`` contains the parameter values along with optional ``trades``
 15321:     to evaluate.  The function returns a copy of the parameters augmented with
 15322:     the computed PnL under the key ``pnl``.
 15323:     """
 15324: 
 15325:     params = dict(grid_item)
 15326:     trades = params.pop("trades", [])
 15327:     fee_rate = params.pop("fee_rate", None)
 15328:     pnl = backtest_trades(trades, fee_rate=fee_rate)
 15329:     params["pnl"] = pnl
 15330:     return params
 15331: 
 15332: 
 15333: # ---------------------------------------------------------------------------
 15334: # Orchestration
 15335: # ---------------------------------------------------------------------------
 15336: 
 15337: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
 15338:     """Evaluate the full parameter grid in parallel and return results."""
 15339: 
 15340:     space = space or param_space_default()
 15341:     grid = _param_grid(space)
 15342: 
 15343:     # Determine execution backend
 15344:     use_ray = False
 15345:     if ray is not None:
 15346:         try:  # pragma: no cover - depends on ray
 15347:             ray.init(ignore_reinit_error=True)
 15348:             use_ray = True
 15349:         except Exception:
 15350:             use_ray = False
 15351: 
 15352:     if use_ray:
 15353:         remote_eval = ray.remote(eval_params_one)  # type: ignore
 15354:         futures = [remote_eval.remote(g) for g in grid]
 15355:         results = ray.get(futures)
 15356:     else:
 15357:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
 15358:         with mp.Pool(processes=jobs) as pool:
 15359:             results = pool.map(eval_params_one, grid)
 15360: 
 15361:     return results
 15362: 
 15363: 
 15364: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
 15365:     """High level helper executing the sweep and saving aggregated results."""
 15366: 
 15367:     results = run_param_sweep(space, jobs=jobs)
 15368:     with open(outfile, "w", encoding="utf8") as fh:
 15369:         json.dump(results, fh, indent=2, sort_keys=True)
 15370:     return results
 15371: 
 15372: 
 15373: def main() -> None:  # pragma: no cover - convenience CLI
 15374:     optimize()
 15375: 
 15376: 
 15377: if __name__ == "__main__":  # pragma: no cover
 15378:     main()
 15379: 
 15380: 
 15381: --------------------------------------------------------------------------------
 15382: FILE: scalper/backtest/position_sizing.py
 15383: --------------------------------------------------------------------------------
 15384: # scalper/backtest/position_sizing.py
 15385: from __future__ import annotations
 15386: from scalper.core.signal import Signal
 15387: 
 15388: def position_size_from_signal(equity: float, sig: Signal, risk_pct: float) -> float:
 15389:     """
 15390:     Taille = (equity * risk_pct) / |entry - sl|
 15391:     Retourne la QUANTITÉ (unités de la crypto).
 15392:     """
 15393:     risk = max(1e-12, abs(sig.entry - sig.sl))
 15394:     cash_at_risk = max(0.0, equity) * max(0.0, risk_pct)
 15395:     return max(0.0, cash_at_risk / risk)
 15396: 
 15397: def fees_cost(notional: float, bps: float) -> float:
 15398:     return abs(notional) * (bps / 10000.0)
 15399: 
 15400: --------------------------------------------------------------------------------
 15401: FILE: scalper/backtest/run_multi.py
 15402: --------------------------------------------------------------------------------
 15403: # annulé
 15404: 
 15405: --------------------------------------------------------------------------------
 15406: FILE: scalper/backtest/runner.py
 15407: --------------------------------------------------------------------------------
 15408: # scalper/backtest/runner.py
 15409: from __future__ import annotations
 15410: import argparse
 15411: import os
 15412: from typing import Dict, List
 15413: from scalper.strategy.factory import load_strategies_cfg
 15414: from scalper.backtest.engine import BacktestEngine
 15415: 
 15416: def run_once(
 15417:     symbol: str,
 15418:     timeframe: str,
 15419:     csv_path: str,
 15420:     strategies_cfg_path: str = "scalper/config/strategies.yml",
 15421:     csv_1h_path: str = "",
 15422:     equity: float = 1000.0,
 15423:     risk: float = 0.01,
 15424:     fees_bps: float = 6.0,
 15425: ) -> Dict[str, float]:
 15426:     cfg = load_strategies_cfg(strategies_cfg_path)
 15427:     data = BacktestEngine.load_csv(csv_path)
 15428:     data_1h = BacktestEngine.load_csv(csv_1h_path) if csv_1h_path and os.path.isfile(csv_1h_path) else None
 15429: 
 15430:     eng = BacktestEngine(
 15431:         symbol=symbol, timeframe=timeframe, data=data, data_1h=data_1h,
 15432:         equity_start=equity, risk_pct=risk, fees_bps=fees_bps, strategies_cfg=cfg,
 15433:     )
 15434:     eng.run()
 15435:     eng.save_results()
 15436:     return eng.summary()
 15437: 
 15438: def main():
 15439:     ap = argparse.ArgumentParser(description="Runner Backtest (point d'entrée unique)")
 15440:     ap.add_argument("--symbol", required=True, help="ex: BTCUSDT")
 15441:     ap.add_argument("--tf", required=True, help="ex: 5m, 1h")
 15442:     ap.add_argument("--csv", required=True, help="CSV OHLCV principal (timestamp,open,high,low,close,volume)")
 15443:     ap.add_argument("--csv_1h", default="", help="CSV 1h (optionnel) pour filtre MTF")
 15444:     ap.add_argument("--cfg", default="scalper/config/strategies.yml", help="config stratégies (YAML/JSON)")
 15445:     ap.add_argument("--equity", type=float, default=1000.0)
 15446:     ap.add_argument("--risk", type=float, default=0.01)
 15447:     ap.add_argument("--fees_bps", type=float, default=6.0)
 15448:     args = ap.parse_args()
 15449: 
 15450:     summary = run_once(
 15451:         symbol=args.symbol, timeframe=args.tf, csv_path=args.csv,
 15452:         strategies_cfg_path=args.cfg, csv_1h_path=args.csv_1h,
 15453:         equity=args.equity, risk=args.risk, fees_bps=args.fees_bps,
 15454:     )
 15455:     print("== Résumé ==")
 15456:     print(summary)
 15457: 
 15458: if __name__ == "__main__":
 15459:     main()
 15460: 
 15461: --------------------------------------------------------------------------------
 15462: FILE: scalper/backtest/walkforward.py
 15463: --------------------------------------------------------------------------------
 15464: from __future__ import annotations
 15465: 
 15466: from itertools import product
 15467: from statistics import mean, stdev
 15468: from typing import Dict, Iterable, Optional
 15469: 
 15470: from ..strategy import max_drawdown
 15471: 
 15472: 
 15473: def _sharpe(returns: Iterable[float]) -> float:
 15474:     vals = list(returns)
 15475:     if not vals:
 15476:         return 0.0
 15477:     mu = mean(vals)
 15478:     if len(vals) > 1:
 15479:         sd = stdev(vals)
 15480:     else:
 15481:         sd = 0.0
 15482:     return mu / sd if sd > 0 else 0.0
 15483: 
 15484: 
 15485: def _stability(equity: Iterable[float]) -> float:
 15486:     curve = list(equity)
 15487:     n = len(curve)
 15488:     if n < 2:
 15489:         return 0.0
 15490:     x = list(range(n))
 15491:     x_mean = sum(x) / n
 15492:     y_mean = sum(curve) / n
 15493:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
 15494:     denom = sum((xi - x_mean) ** 2 for xi in x)
 15495:     if denom == 0 or ss_tot == 0:
 15496:         return 0.0
 15497:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
 15498:     a = y_mean - b * x_mean
 15499:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
 15500:     return 1 - ss_res / ss_tot
 15501: 
 15502: 
 15503: def walk_forward(
 15504:     df,
 15505:     splits: int = 5,
 15506:     train_ratio: float = 0.7,
 15507:     params: Optional[Dict[str, Iterable]] = None,
 15508: ) -> Dict[str, float]:
 15509:     """Perform walk-forward optimisation and evaluation.
 15510: 
 15511:     Parameters
 15512:     ----------
 15513:     df:
 15514:         DataFrame containing per-period percentage returns. The first column is
 15515:         used when a dedicated ``"returns"`` column is not found.
 15516:     splits:
 15517:         Number of walk-forward test windows.
 15518:     train_ratio:
 15519:         Proportion of the data used for training in the initial window.
 15520:     params:
 15521:         Optional parameter grid. If provided, columns in ``df`` matching each
 15522:         parameter combination are evaluated and the best Sharpe ratio on the
 15523:         training window is selected. When ``None``, the first column is used.
 15524:     """
 15525: 
 15526:     if df.empty:
 15527:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
 15528: 
 15529:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
 15530:     data = df.copy()
 15531: 
 15532:     n = len(data)
 15533:     train_len = max(1, int(n * train_ratio))
 15534:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
 15535: 
 15536:     sharpe_list = []
 15537:     mdd_list = []
 15538:     pnl_list = []
 15539:     stability_list = []
 15540: 
 15541:     from . import walk_forward_windows
 15542: 
 15543:     indices = list(range(n))
 15544: 
 15545:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
 15546:         train_df = data.iloc[tr_idx]
 15547:         test_df = data.iloc[te_idx]
 15548: 
 15549:         # Parameter optimisation based on Sharpe ratio
 15550:         if params:
 15551:             best_col = None
 15552:             best_score = float("-inf")
 15553:             keys, values = zip(*params.items()) if params else ([], [])
 15554:             for combo in product(*values):
 15555:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
 15556:                 if col_name not in data.columns:
 15557:                     continue
 15558:                 score = _sharpe(train_df[col_name])
 15559:                 if score > best_score:
 15560:                     best_score = score
 15561:                     best_col = col_name
 15562:             series = test_df[best_col] if best_col else test_df[returns_col]
 15563:         else:
 15564:             series = test_df[returns_col]
 15565: 
 15566:         sharpe_list.append(_sharpe(series))
 15567:         equity = (1 + series / 100.0).cumprod()
 15568:         mdd_list.append(max_drawdown(equity))
 15569:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
 15570:         stability_list.append(_stability(equity))
 15571: 
 15572:     count = len(sharpe_list) or 1
 15573:     mean_sharpe = sum(sharpe_list) / count
 15574:     mean_mdd = sum(mdd_list) / count
 15575:     mean_pnl = sum(pnl_list) / count
 15576:     mean_stability = sum(stability_list) / count
 15577: 
 15578:     return {
 15579:         "sharpe": mean_sharpe,
 15580:         "mdd": mean_mdd,
 15581:         "pnl": mean_pnl,
 15582:         "stability": mean_stability,
 15583:     }
 15584: 
 15585: 
 15586: --------------------------------------------------------------------------------
 15587: FILE: scalper/bitget_client.py
 15588: --------------------------------------------------------------------------------
 15589: import json
 15590: import logging
 15591: import time
 15592: import hmac
 15593: import hashlib
 15594: import base64
 15595: import uuid
 15596: from typing import Any, Dict, List, Optional
 15597: 
 15598: import requests
 15599: 
 15600: 
 15601: # Mapping of deprecated v1 product type identifiers to the new v2 names
 15602: _PRODUCT_TYPE_ALIASES = {
 15603:     "UMCBL": "USDT-FUTURES",
 15604:     "DMCBL": "USDC-FUTURES",
 15605:     "CMCBL": "COIN-FUTURES",
 15606: }
 15607: 
 15608: # Granularity aliases from v1 to v2 nomenclature
 15609: _GRANULARITY_ALIASES = {
 15610:     "MIN1": "1m",
 15611:     "MIN3": "3m",
 15612:     "MIN5": "5m",
 15613:     "MIN15": "15m",
 15614:     "MIN30": "30m",
 15615:     "HOUR1": "1H",
 15616:     "HOUR4": "4H",
 15617:     "HOUR12": "12H",
 15618:     "DAY1": "1D",
 15619:     "WEEK1": "1W",
 15620: }
 15621: 
 15622: 
 15623: # Default margin coin for each product type. Some authenticated endpoints
 15624: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
 15625: # default avoids ``400 Bad Request`` responses when the caller does not provide
 15626: # it explicitly.
 15627: _DEFAULT_MARGIN_COIN = {
 15628:     "USDT-FUTURES": "USDT",
 15629:     "USDC-FUTURES": "USDC",
 15630: }
 15631: 
 15632: 
 15633: class BitgetFuturesClient:
 15634:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
 15635: 
 15636:     def __init__(
 15637:         self,
 15638:         access_key: str,
 15639:         secret_key: str,
 15640:         base_url: str,
 15641:         *,
 15642:         product_type: str = "USDT-FUTURES",
 15643:         recv_window: int = 30,
 15644:         paper_trade: bool = True,
 15645:         requests_module: Any = requests,
 15646:         log_event: Optional[Any] = None,
 15647:         passphrase: Optional[str] = None,
 15648:     ) -> None:
 15649:         self.ak = access_key
 15650:         self.sk = secret_key
 15651:         self.base = base_url.rstrip("/")
 15652:         pt = product_type.upper()
 15653:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
 15654:         self.recv_window = recv_window
 15655:         self.paper_trade = paper_trade
 15656:         self.requests = requests_module
 15657:         self.log_event = log_event or (lambda *a, **k: None)
 15658:         self.passphrase = passphrase
 15659:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
 15660:             logging.warning(
 15661:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
 15662:             )
 15663:         # Cache for contract precision details to avoid repeated network calls
 15664:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
 15665: 
 15666:     # ------------------------------------------------------------------
 15667:     # Helpers
 15668:     # ------------------------------------------------------------------
 15669:     @staticmethod
 15670:     def _ms() -> int:
 15671:         return int(time.time() * 1000)
 15672: 
 15673:     @staticmethod
 15674:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
 15675:         if not params:
 15676:             return ""
 15677:         items = []
 15678:         for k in sorted(params.keys()):
 15679:             v = "" if params[k] is None else str(params[k])
 15680:             items.append(f"{k}={v}")
 15681:         return "&".join(items)
 15682: 
 15683:     def _sign(self, prehash: str) -> str:
 15684:         """Return a base64-encoded HMAC SHA256 signature."""
 15685:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
 15686:         return base64.b64encode(digest).decode()
 15687: 
 15688:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
 15689:         headers = {
 15690:             "ACCESS-KEY": self.ak,
 15691:             "ACCESS-SIGN": signature,
 15692:             "ACCESS-TIMESTAMP": str(timestamp),
 15693:             "ACCESS-RECV-WINDOW": str(self.recv_window),
 15694:             "Content-Type": "application/json",
 15695:         }
 15696:         if self.passphrase:
 15697:             headers["ACCESS-PASSPHRASE"] = self.passphrase
 15698:         return headers
 15699: 
 15700:     def _format_symbol(self, symbol: str) -> str:
 15701:         """Return ``symbol`` formatted for Bitget API.
 15702: 
 15703:         The v2 endpoints expect the trading pair without any product type
 15704:         suffix (``BTCUSDT``). Older configurations may provide symbols like
 15705:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
 15706:         separators and any trailing product type string (legacy or v2).
 15707:         """
 15708: 
 15709:         if not symbol:
 15710:             return symbol
 15711: 
 15712:         sym = symbol.replace("_", "").upper()
 15713:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
 15714:         if sym.endswith(self.product_type):
 15715:             sym = sym[: -len(self.product_type)]
 15716:         else:
 15717:             for old in _PRODUCT_TYPE_ALIASES.keys():
 15718:                 if sym.endswith(old):
 15719:                     sym = sym[: -len(old)]
 15720:                     break
 15721:         return sym
 15722: 
 15723:     def _product_type(self, pt: Optional[str] = None) -> str:
 15724:         """Normalise ``pt`` to a valid v2 product type identifier."""
 15725:         key = (pt or self.product_type or "").upper()
 15726:         return _PRODUCT_TYPE_ALIASES.get(key, key)
 15727: 
 15728:     # ------------------------------------------------------------------
 15729:     # Public endpoints
 15730:     # ------------------------------------------------------------------
 15731:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
 15732:         """Return futures contract information.
 15733: 
 15734:         The previous implementation queried ``/contract-detail`` which does not
 15735:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
 15736:         endpoint is ``/contracts`` with the symbol supplied as a query
 15737:         parameter."""
 15738: 
 15739:         url = f"{self.base}/api/v2/mix/market/contracts"
 15740:         params: Dict[str, Any] = {"productType": self.product_type}
 15741:         if symbol:
 15742:             params["symbol"] = self._format_symbol(symbol)
 15743:         r = self.requests.get(url, params=params, timeout=15)
 15744:         if r.status_code == 404:  # pragma: no cover - depends on network
 15745:             logging.error("Contract detail introuvable pour %s", symbol)
 15746:             return {"success": False, "code": 404, "data": None}
 15747:         r.raise_for_status()
 15748:         return r.json()
 15749: 
 15750:     # ------------------------------------------------------------------
 15751:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
 15752:         """Return price and volume precision for ``symbol``.
 15753: 
 15754:         Results are cached to minimise HTTP requests. If the contract
 15755:         information cannot be retrieved, ``(0, 0)`` is returned.
 15756:         """
 15757:         sym = self._format_symbol(symbol)
 15758:         info = self._contract_cache.get(sym)
 15759:         if info is None:
 15760:             detail = self.get_contract_detail(sym)
 15761:             try:
 15762:                 data = detail.get("data", [])
 15763:                 if isinstance(data, list) and data:
 15764:                     info = data[0]
 15765:                 else:
 15766:                     info = {}
 15767:             except Exception:
 15768:                 info = {}
 15769:             self._contract_cache[sym] = info
 15770:         price_place = int(info.get("pricePlace") or 0)
 15771:         volume_place = int(info.get("volumePlace") or 0)
 15772:         return price_place, volume_place
 15773: 
 15774:     def get_kline(
 15775:         self,
 15776:         symbol: str,
 15777:         interval: str = "1m",
 15778:         start: Optional[int] = None,
 15779:         end: Optional[int] = None,
 15780:     ) -> Dict[str, Any]:
 15781:         # Endpoint expects the trading pair in query parameters rather than
 15782:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
 15783:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
 15784:         url = f"{self.base}/api/v2/mix/market/candles"
 15785:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
 15786:         params: Dict[str, Any] = {
 15787:             "symbol": self._format_symbol(symbol),
 15788:             "productType": self.product_type,
 15789:             "granularity": interval_norm,
 15790:         }
 15791:         if start is not None:
 15792:             params["startTime"] = int(start)
 15793:         if end is not None:
 15794:             params["endTime"] = int(end)
 15795:         r = self.requests.get(url, params=params, timeout=15)
 15796:         r.raise_for_status()
 15797:         data = r.json()
 15798: 
 15799:         rows = data.get("data") if isinstance(data, dict) else None
 15800:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
 15801:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
 15802:             for row in rows:
 15803:                 if len(row) < 7:
 15804:                     continue
 15805:                 try:
 15806:                     ts, op, hi, lo, cl, vol, qv = row[:7]
 15807:                     cols["ts"].append(int(ts))
 15808:                     cols["open"].append(float(op))
 15809:                     cols["high"].append(float(hi))
 15810:                     cols["low"].append(float(lo))
 15811:                     cols["close"].append(float(cl))
 15812:                     cols["volume"].append(float(vol))
 15813:                     cols["quoteVolume"].append(float(qv))
 15814:                 except (TypeError, ValueError):
 15815:                     continue
 15816:             data["data"] = cols
 15817:         elif isinstance(rows, list):
 15818:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
 15819:         return data
 15820: 
 15821:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
 15822:         if symbol:
 15823:             url = f"{self.base}/api/v2/mix/market/ticker"
 15824:             params = {
 15825:                 "symbol": self._format_symbol(symbol),
 15826:                 "productType": self.product_type,
 15827:             }
 15828:         else:
 15829:             url = f"{self.base}/api/v2/mix/market/tickers"
 15830:             params = {"productType": self.product_type}
 15831:         r = self.requests.get(url, params=params, timeout=15)
 15832:         r.raise_for_status()
 15833:         return r.json()
 15834: 
 15835:     # ------------------------------------------------------------------
 15836:     # Private endpoints
 15837:     # ------------------------------------------------------------------
 15838:     def _private_request(
 15839:         self,
 15840:         method: str,
 15841:         path: str,
 15842:         *,
 15843:         params: Optional[Dict[str, Any]] = None,
 15844:         body: Optional[Dict[str, Any]] = None,
 15845:     ) -> Dict[str, Any]:
 15846:         method = method.upper()
 15847:         ts = self._ms()
 15848: 
 15849:         if method in ("GET", "DELETE"):
 15850:             qs = self._urlencode_sorted(params or {})
 15851:             req_path = path + (f"?{qs}" if qs else "")
 15852:             sig = self._sign(f"{ts}{method}{req_path}")
 15853:             headers = self._headers(sig, ts)
 15854:             url = f"{self.base}{req_path}"
 15855:             r = self.requests.request(method, url, headers=headers, timeout=20)
 15856:         elif method == "POST":
 15857:             qs = self._urlencode_sorted(params or {})
 15858:             req_path = path + (f"?{qs}" if qs else "")
 15859:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
 15860:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
 15861:             headers = self._headers(sig, ts)
 15862:             url = f"{self.base}{req_path}"
 15863:             r = self.requests.post(
 15864:                 url,
 15865:                 data=body_str.encode("utf-8"),
 15866:                 headers=headers,
 15867:                 timeout=20,
 15868:             )
 15869:         else:
 15870:             raise ValueError("M\u00e9thode non support\u00e9e")
 15871: 
 15872:         resp_text = getattr(r, "text", "")
 15873:         try:
 15874:             data = r.json()
 15875:         except Exception:
 15876:             data = {
 15877:                 "success": False,
 15878:                 "error": resp_text,
 15879:                 "status_code": getattr(r, "status_code", None),
 15880:             }
 15881: 
 15882:         status = getattr(r, "status_code", 0)
 15883:         if status >= 400:
 15884:             code = str(data.get("code")) if isinstance(data, dict) else ""
 15885:             if code == "22001":
 15886:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
 15887:             else:
 15888:                 try:
 15889:                     r.raise_for_status()
 15890:                 except Exception as e:
 15891:                     if not resp_text:
 15892:                         resp_text = getattr(r, "text", "") or str(e)
 15893:                 logging.error(
 15894:                     "Erreur HTTP/JSON %s %s -> %s %s",
 15895:                     method,
 15896:                     path,
 15897:                     status,
 15898:                     resp_text,
 15899:                 )
 15900:                 if isinstance(data, dict):
 15901:                     data.setdefault("success", False)
 15902:                     data.setdefault("status_code", status)
 15903:                     data.setdefault("error", resp_text)
 15904: 
 15905:         self.log_event(
 15906:             "http_private",
 15907:             {"method": method, "path": path, "params": params, "body": body, "response": data},
 15908:         )
 15909:         return data
 15910: 
 15911:     # Accounts & positions -------------------------------------------------
 15912:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
 15913:         if self.paper_trade:
 15914:             return {
 15915:                 "success": True,
 15916:                 "code": 0,
 15917:                 "data": [
 15918:                     {
 15919:                         "currency": "USDT",
 15920:                         "equity": 100.0,
 15921:                     }
 15922:                 ],
 15923:             }
 15924: 
 15925:         params = {"productType": self.product_type}
 15926:         if margin_coin is None:
 15927:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
 15928:         if margin_coin:
 15929:             params["marginCoin"] = margin_coin
 15930:         data = self._private_request(
 15931:             "GET", "/api/v2/mix/account/accounts", params=params
 15932:         )
 15933:         if isinstance(data, dict):
 15934:             data.setdefault("success", str(data.get("code")) == "00000")
 15935:         try:
 15936:             for row in data.get("data", []):
 15937:                 if "currency" not in row and row.get("marginCoin"):
 15938:                     row["currency"] = str(row["marginCoin"]).upper()
 15939:                 chosen = None
 15940:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
 15941:                     val = row.get(key)
 15942:                     if val is not None:
 15943:                         chosen = val
 15944:                         break
 15945:                 if chosen is not None:
 15946:                     row["equity"] = chosen
 15947:                 try:
 15948:                     row["equity"] = float(row["equity"])
 15949:                 except Exception:
 15950:                     pass
 15951:         except Exception:  # pragma: no cover - best effort
 15952:             pass
 15953:         return data
 15954: 
 15955:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
 15956:         if self.paper_trade:
 15957:             return {"success": True, "code": 0, "data": []}
 15958:         data = self._private_request(
 15959:             "GET",
 15960:             "/api/v2/mix/position/all-position",
 15961:             params={"productType": self._product_type(product_type)},
 15962:         )
 15963:         try:
 15964:             positions = data.get("data", [])
 15965:             filtered = []
 15966:             for pos in positions:
 15967:                 vol = pos.get("vol")
 15968:                 try:
 15969:                     if vol is not None and float(vol) > 0:
 15970:                         filtered.append(pos)
 15971:                 except (TypeError, ValueError):
 15972:                     continue
 15973:             data["data"] = filtered
 15974:         except Exception:  # pragma: no cover - best effort
 15975:             pass
 15976:         return data
 15977: 
 15978:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
 15979:         if self.paper_trade:
 15980:             return {"success": True, "code": 0, "data": []}
 15981:         params: Dict[str, Any] = {"productType": self.product_type}
 15982:         if symbol:
 15983:             params["symbol"] = self._format_symbol(symbol)
 15984:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
 15985: 
 15986:     # Account configuration -------------------------------------------------
 15987:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
 15988:         body = {
 15989:             "productType": self._product_type(product_type),
 15990:             "symbol": self._format_symbol(symbol),
 15991:             "posMode": "one_way_mode",
 15992:         }
 15993:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
 15994: 
 15995:     def set_leverage(
 15996:         self,
 15997:         symbol: str,
 15998:         product_type: Optional[str] = None,
 15999:         margin_coin: str = "USDT",
 16000:         leverage: int = 1,
 16001:     ) -> Dict[str, Any]:
 16002:         body = {
 16003:             "symbol": self._format_symbol(symbol),
 16004:             "productType": self._product_type(product_type),
 16005:             "marginCoin": margin_coin,
 16006:             "leverage": int(leverage),
 16007:         }
 16008:         return self._private_request(
 16009:             "POST", "/api/v2/mix/account/set-leverage", body=body
 16010:         )
 16011: 
 16012:     def place_market_order_one_way(
 16013:         self,
 16014:         symbol: str,
 16015:         side: str,
 16016:         size: float,
 16017:         product_type: Optional[str] = None,
 16018:         margin_coin: str = "USDT",
 16019:         *,
 16020:         time_in_force: str = "normal",
 16021:     ) -> Dict[str, Any]:
 16022:         side = side.lower()
 16023:         if side not in {"buy", "sell"}:
 16024:             raise ValueError("side must be 'buy' or 'sell'")
 16025:         body = {
 16026:             "symbol": self._format_symbol(symbol),
 16027:             "productType": self._product_type(product_type),
 16028:             "marginCoin": margin_coin,
 16029:             "marginMode": "crossed",
 16030:             "posMode": "one_way_mode",
 16031:             "orderType": "market",
 16032:             "side": side,
 16033:             "size": str(size),
 16034:             "timeInForceValue": time_in_force,
 16035:             "clientOid": str(uuid.uuid4())[:32],
 16036:         }
 16037:         return self._private_request(
 16038:             "POST", "/api/v2/mix/order/place-order", body=body
 16039:         )
 16040: 
 16041:     # Orders ---------------------------------------------------------------
 16042:     def place_order(
 16043:         self,
 16044:         symbol: str,
 16045:         side: int,
 16046:         vol: int,
 16047:         order_type: int,
 16048:         *,
 16049:         price: Optional[float] = None,
 16050:         open_type: int = 1,
 16051:         leverage: Optional[int] = None,
 16052:         position_id: Optional[int] = None,
 16053:         external_oid: Optional[str] = None,
 16054:         stop_loss: Optional[float] = None,
 16055:         take_profit: Optional[float] = None,
 16056:         position_mode: Optional[int] = None,
 16057:         margin_coin: Optional[str] = None,
 16058:         time_in_force: str = "normal",
 16059:     ) -> Dict[str, Any]:
 16060:         """Submit an order.
 16061: 
 16062:         This helper keeps backward compatibility with the older numeric
 16063:         parameters used by the bot while translating them to the string based
 16064:         fields required by Bitget's v2 API.
 16065:         """
 16066:         if self.paper_trade:
 16067:             logging.info(
 16068:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
 16069:                 side,
 16070:                 vol,
 16071:                 order_type,
 16072:                 price,
 16073:             )
 16074:             return {
 16075:                 "success": True,
 16076:                 "paperTrade": True,
 16077:                 "simulated": {
 16078:                     "symbol": symbol,
 16079:                     "side": side,
 16080:                     "vol": vol,
 16081:                     "type": order_type,
 16082:                     "price": price,
 16083:                     "openType": open_type,
 16084:                     "leverage": leverage,
 16085:                     "stopLossPrice": stop_loss,
 16086:                     "takeProfitPrice": take_profit,
 16087:                 },
 16088:             }
 16089: 
 16090:         # ------------------------------------------------------------------
 16091:         # Parameter mapping
 16092:         # ------------------------------------------------------------------
 16093:         side_map = {
 16094:             1: ("buy", "long"),
 16095:             2: ("buy", "short"),
 16096:             3: ("sell", "short"),
 16097:             4: ("sell", "long"),
 16098:         }
 16099:         if isinstance(side, int):
 16100:             mapped = side_map.get(side)
 16101:             if not mapped:
 16102:                 raise ValueError(f"Invalid side value: {side}")
 16103:             side_str, pos_side = mapped
 16104:         else:
 16105:             side_str = str(side)
 16106:             pos_side = None
 16107: 
 16108:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
 16109:         if isinstance(order_type, int):
 16110:             order_str = order_map.get(order_type)
 16111:             if order_str is None:
 16112:                 order_str = "limit" if price is not None else "market"
 16113:         else:
 16114:             order_str = str(order_type)
 16115: 
 16116:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
 16117: 
 16118:         if margin_coin is None:
 16119:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
 16120: 
 16121:         # ------------------------------------------------------------------
 16122:         # Precision handling
 16123:         # ------------------------------------------------------------------
 16124:         try:
 16125:             price_place, volume_place = self._get_contract_precision(symbol)
 16126:         except Exception:  # pragma: no cover - best effort
 16127:             price_place = volume_place = 0
 16128:         if price is not None:
 16129:             price = round(float(price), price_place)
 16130:         if vol is not None:
 16131:             vol = round(float(vol), volume_place)
 16132: 
 16133:         body = {
 16134:             "symbol": self._format_symbol(symbol),
 16135:             "productType": self.product_type,
 16136:             "marginMode": margin_mode,
 16137:             "orderType": order_str,
 16138:             "side": side_str,
 16139:             "size": vol,
 16140:             "timeInForceValue": time_in_force,
 16141:         }
 16142:         if pos_side is not None:
 16143:             body["posSide"] = pos_side
 16144:         if margin_coin:
 16145:             body["marginCoin"] = margin_coin
 16146:         if price is not None:
 16147:             body["price"] = float(price)
 16148:         if leverage is not None:
 16149:             body["leverage"] = int(leverage)
 16150:         if position_id is not None:
 16151:             body["positionId"] = int(position_id)
 16152:         if external_oid:
 16153:             body["clientOid"] = str(external_oid)[:32]
 16154:         else:
 16155:             body["clientOid"] = str(uuid.uuid4())[:32]
 16156:         if stop_loss is not None:
 16157:             body["stopLossPrice"] = float(stop_loss)
 16158:         if take_profit is not None:
 16159:             body["takeProfitPrice"] = float(take_profit)
 16160:         if position_mode is not None:
 16161:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
 16162:         elif pos_side is not None:
 16163:             body["posMode"] = "hedge_mode"
 16164: 
 16165:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
 16166: 
 16167:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
 16168:         if self.paper_trade:
 16169:             logging.info(
 16170:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
 16171:             )
 16172:             return {"success": True, "code": 0}
 16173:         return self._private_request(
 16174:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
 16175:         )
 16176: 
 16177:     def cancel_all(
 16178:         self,
 16179:         symbol: Optional[str] = None,
 16180:         margin_coin: Optional[str] = None,
 16181:     ) -> Dict[str, Any]:
 16182:         if self.paper_trade:
 16183:             logging.info(
 16184:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
 16185:             )
 16186:             return {"success": True, "code": 0}
 16187:         body = {"productType": self.product_type}
 16188:         if symbol:
 16189:             body["symbol"] = self._format_symbol(symbol)
 16190:         if margin_coin is None:
 16191:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
 16192:         if margin_coin:
 16193:             body["marginCoin"] = margin_coin
 16194:         return self._private_request(
 16195:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
 16196:         )
 16197: 
 16198:     def close_position(
 16199:         self,
 16200:         symbol: str,
 16201:         size: Optional[int] = None,
 16202:         hold_side: Optional[str] = None,
 16203:     ) -> Dict[str, Any]:
 16204:         """Close an open position for ``symbol``.
 16205: 
 16206:         Parameters
 16207:         ----------
 16208:         symbol:
 16209:             Trading symbol to close.
 16210:         size:
 16211:             Optional number of contracts to close. If omitted the entire
 16212:             position is closed.
 16213:         hold_side:
 16214:             Optional side (``"long"``/``"short"``) to close when ``size`` is
 16215:             specified. If not provided the exchange will infer it.
 16216:         """
 16217: 
 16218:         if self.paper_trade:
 16219:             logging.info(
 16220:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
 16221:             )
 16222:             return {"success": True, "code": 0}
 16223: 
 16224:         body = {"symbol": self._format_symbol(symbol)}
 16225:         if size is not None:
 16226:             body["size"] = int(size)
 16227:         if hold_side:
 16228:             body["holdSide"] = hold_side
 16229: 
 16230:         body["productType"] = self.product_type
 16231:         return self._private_request(
 16232:             "POST", "/api/v2/mix/position/close-position", body=body
 16233:         )
 16234: 
 16235:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
 16236:         """Close all open positions."""
 16237:         results = []
 16238:         try:
 16239:             for pos in self.get_positions(product_type).get("data", []):
 16240:                 sym = pos.get("symbol")
 16241:                 if sym:
 16242:                     results.append(self.close_position(sym))
 16243:         except Exception as exc:  # pragma: no cover - best effort
 16244:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
 16245:         return {"success": True, "data": results}
 16246: 
 16247: 
 16248: --------------------------------------------------------------------------------
 16249: FILE: scalper/client.py
 16250: --------------------------------------------------------------------------------
 16251: import logging
 16252: from typing import Any, Dict, Optional
 16253: 
 16254: import requests
 16255: from requests.adapters import HTTPAdapter
 16256: from urllib3.util.retry import Retry
 16257: 
 16258: 
 16259: class HTTPError(RuntimeError):
 16260:     """Raised when an HTTP request fails"""
 16261: 
 16262: 
 16263: class HttpClient:
 16264:     """Simple HTTP client with persistent session and retry logic.
 16265: 
 16266:     The client exposes a :py:meth:`close` method and implements the context
 16267:     manager protocol so it can be used with ``with`` statements to ensure
 16268:     that the underlying :class:`requests.Session` is properly closed.
 16269:     """
 16270: 
 16271:     def __init__(
 16272:         self,
 16273:         base_url: str,
 16274:         *,
 16275:         timeout: float = 10.0,
 16276:         max_retries: int = 3,
 16277:         backoff_factor: float = 0.3,
 16278:         status_forcelist: Optional[list[int]] = None,
 16279:     ) -> None:
 16280:         self.base_url = base_url.rstrip("/")
 16281:         self.timeout = timeout
 16282:         self.session = requests.Session()
 16283:         retry = Retry(
 16284:             total=max_retries,
 16285:             backoff_factor=backoff_factor,
 16286:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
 16287:             allowed_methods=[
 16288:                 "HEAD",
 16289:                 "GET",
 16290:                 "OPTIONS",
 16291:                 "POST",
 16292:                 "PUT",
 16293:                 "DELETE",
 16294:                 "PATCH",
 16295:             ],
 16296:         )
 16297:         adapter = HTTPAdapter(max_retries=retry)
 16298:         self.session.mount("http://", adapter)
 16299:         self.session.mount("https://", adapter)
 16300: 
 16301:     def close(self) -> None:
 16302:         """Close the underlying :class:`requests.Session`."""
 16303:         self.session.close()
 16304: 
 16305:     # ------------------------------------------------------------------
 16306:     # Context manager support
 16307:     # ------------------------------------------------------------------
 16308:     def __enter__(self) -> "HttpClient":
 16309:         return self
 16310: 
 16311:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
 16312:         self.close()
 16313: 
 16314:     def request(
 16315:         self,
 16316:         method: str,
 16317:         path: str,
 16318:         *,
 16319:         params: Optional[Dict[str, Any]] = None,
 16320:         json: Optional[Dict[str, Any]] = None,
 16321:         headers: Optional[Dict[str, str]] = None,
 16322:     ) -> Dict[str, Any]:
 16323:         """Perform an HTTP request and return JSON data.
 16324: 
 16325:         Errors during the request raise ``HTTPError``. If the response cannot
 16326:         be decoded as JSON, a dictionary describing the issue is returned.
 16327:         """
 16328:         url = f"{self.base_url}{path}"
 16329:         try:
 16330:             resp = self.session.request(
 16331:                 method,
 16332:                 url,
 16333:                 params=params,
 16334:                 json=json,
 16335:                 headers=headers,
 16336:                 timeout=self.timeout,
 16337:             )
 16338:             resp.raise_for_status()
 16339:         except requests.RequestException as exc:  # network or HTTP errors
 16340:             msg = f"HTTP error calling {url}: {exc}"
 16341:             logging.error(msg)
 16342:             raise HTTPError(msg) from exc
 16343: 
 16344:         try:
 16345:             return resp.json()
 16346:         except ValueError:  # invalid JSON
 16347:             msg = "Invalid JSON in response"
 16348:             logging.error("%s for %s: %s", msg, url, resp.text)
 16349:             return {"success": False, "error": msg, "text": resp.text}
 16350: 
 16351: 
 16352: --------------------------------------------------------------------------------
 16353: FILE: scalper/config/__init__.py
 16354: --------------------------------------------------------------------------------
 16355: from .loader import load_settings
 16356: __all__ = ['load_settings']
 16357: 
 16358: 
 16359: --------------------------------------------------------------------------------
 16360: FILE: scalper/config/loader.py
 16361: --------------------------------------------------------------------------------
 16362: # scalp/config/loader.py
 16363: from __future__ import annotations
 16364: import os, json
 16365: from typing import Any, Dict, Tuple
 16366: 
 16367: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
 16368: try:
 16369:     import yaml  # type: ignore
 16370: except Exception:
 16371:     yaml = None  # fallback JSON si besoin
 16372: 
 16373: # dotenv (facultatif) pour charger un .env automatiquement
 16374: try:
 16375:     from dotenv import load_dotenv  # type: ignore
 16376: except Exception:
 16377:     load_dotenv = None
 16378: 
 16379: # ---------------- Utils ----------------
 16380: 
 16381: def _parse_bool(x: Any, default: bool = False) -> bool:
 16382:     if isinstance(x, bool): return x
 16383:     s = str(x).strip().lower()
 16384:     if s in ("1","true","yes","y","on"): return True
 16385:     if s in ("0","false","no","n","off",""): return False
 16386:     return default
 16387: 
 16388: def _parse_float(x: Any, default: float | None = None) -> float | None:
 16389:     try: return float(x)
 16390:     except Exception: return default
 16391: 
 16392: def _parse_int(x: Any, default: int | None = None) -> int | None:
 16393:     try: return int(str(x).strip())
 16394:     except Exception: return default
 16395: 
 16396: def _parse_csv(x: Any) -> list[str]:
 16397:     if x is None: return []
 16398:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
 16399:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
 16400: 
 16401: def _read_yaml(path: str) -> Dict[str, Any]:
 16402:     if not os.path.exists(path): return {}
 16403:     with open(path, "r", encoding="utf-8") as f:
 16404:         if yaml:
 16405:             return yaml.safe_load(f) or {}
 16406:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
 16407:         try:
 16408:             return json.load(f)
 16409:         except Exception:
 16410:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
 16411: 
 16412: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
 16413:     # shallow merge suffisant ici (structure plate)
 16414:     out = dict(a)
 16415:     out.update({k: v for k, v in b.items() if v is not None})
 16416:     return out
 16417: 
 16418: # ---------------- Public API ----------------
 16419: 
 16420: def load_settings(
 16421:     config_path: str = "config.yml",
 16422:     config_local_path: str = "config.local.yml",
 16423: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
 16424:     """
 16425:     Retourne (config_runtime, secrets) :
 16426:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
 16427:       - secrets        : clés API & tokens (NE PAS versionner)
 16428:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
 16429:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
 16430:     """
 16431:     # 1) .env (pour secrets & env non sensibles). Faculatif.
 16432:     if load_dotenv is not None:
 16433:         load_dotenv(override=False)
 16434: 
 16435:     # 2) Charge YAML (config.yml + override local)
 16436:     base = _read_yaml(config_path)
 16437:     local = _read_yaml(config_local_path)
 16438:     cfg = _merge_dict(base, local)
 16439: 
 16440:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
 16441:     env_overlay: Dict[str, Any] = {}
 16442:     # Verbosité
 16443:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
 16444:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
 16445:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
 16446:     # Runtime / Stratégie
 16447:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
 16448:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
 16449:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
 16450:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
 16451:     # Watchlist
 16452:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
 16453:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
 16454:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
 16455:     )
 16456:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
 16457:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
 16458:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
 16459:     caps_env = os.getenv("CAPS_JSON")
 16460:     if caps_env:
 16461:         try:
 16462:             env_overlay["CAPS"] = json.loads(caps_env)
 16463:         except Exception:
 16464:             env_overlay["CAPS"] = cfg.get("CAPS", {})
 16465:     else:
 16466:         env_overlay["CAPS"] = cfg.get("CAPS", {})
 16467: 
 16468:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
 16469:     secrets = {
 16470:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
 16471:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
 16472:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
 16473:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
 16474:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
 16475:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
 16476:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
 16477:     }
 16478: 
 16479:     # 5) Runtime normalisé pour l’orchestrateur
 16480:     runtime = {
 16481:         "quiet": bool(env_overlay["QUIET"]),
 16482:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
 16483:         "timeframe": str(env_overlay["TIMEFRAME"]),
 16484:         "cash": float(env_overlay["CASH"]),
 16485:         "risk_pct": float(env_overlay["RISK_PCT"]),
 16486:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
 16487:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
 16488:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
 16489:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
 16490:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
 16491:         "caps": env_overlay["CAPS"],                        # dict
 16492:         # rempli au boot par les frais Bitget
 16493:         "fees_by_symbol": {}, 
 16494:     }
 16495: 
 16496:     return runtime, secrets
 16497:     
 16498: 
 16499: --------------------------------------------------------------------------------
 16500: FILE: scalper/config/strategies.yml
 16501: --------------------------------------------------------------------------------
 16502: # scalper/config/strategies.yml
 16503: default: current
 16504: by_timeframe:
 16505:   "1m": current
 16506:   "5m": current
 16507:   "15m": current
 16508:   "1h": current
 16509: by_symbol:
 16510:   BTCUSDT:
 16511:     "1m": current
 16512:     "5m": current
 16513:   ETHUSDT:
 16514:     "5m": current
 16515: 
 16516: 
 16517: --------------------------------------------------------------------------------
 16518: FILE: scalper/core/indicators.py
 16519: --------------------------------------------------------------------------------
 16520: # scalper/core/indicators.py
 16521: from __future__ import annotations
 16522: from typing import Sequence, Tuple, List
 16523: 
 16524: def _to_list(x: Sequence[float]) -> List[float]:
 16525:     return list(map(float, x))
 16526: 
 16527: def ema(series: Sequence[float], period: int) -> List[float]:
 16528:     s = _to_list(series)
 16529:     if period <= 1 or len(s) == 0:
 16530:         return s[:]
 16531:     k = 2.0 / (period + 1.0)
 16532:     out = [s[0]]
 16533:     for i in range(1, len(s)):
 16534:         out.append(s[i] * k + out[-1] * (1.0 - k))
 16535:     return out
 16536: 
 16537: def sma(series: Sequence[float], period: int) -> List[float]:
 16538:     s = _to_list(series)
 16539:     out: List[float] = []
 16540:     acc = 0.0
 16541:     for i, v in enumerate(s):
 16542:         acc += v
 16543:         if i >= period:
 16544:             acc -= s[i - period]
 16545:         out.append(acc / min(i + 1, period))
 16546:     return out
 16547: 
 16548: def rsi(closes: Sequence[float], period: int = 14) -> List[float]:
 16549:     c = _to_list(closes)
 16550:     if len(c) < 2:
 16551:         return [50.0] * len(c)
 16552:     gains = [0.0]
 16553:     losses = [0.0]
 16554:     for i in range(1, len(c)):
 16555:         ch = c[i] - c[i - 1]
 16556:         gains.append(max(ch, 0.0))
 16557:         losses.append(max(-ch, 0.0))
 16558:     avg_gain = sma(gains, period)
 16559:     avg_loss = sma(losses, period)
 16560:     out = []
 16561:     for g, l in zip(avg_gain, avg_loss):
 16562:         if l == 0:
 16563:             out.append(100.0)
 16564:         else:
 16565:             rs = g / l
 16566:             out.append(100.0 - (100.0 / (1.0 + rs)))
 16567:     return out
 16568: 
 16569: def macd(closes: Sequence[float], fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[List[float], List[float], List[float]]:
 16570:     c = _to_list(closes)
 16571:     ema_fast = ema(c, fast)
 16572:     ema_slow = ema(c, slow)
 16573:     macd_line = [f - s for f, s in zip(ema_fast, ema_slow)]
 16574:     signal_line = ema(macd_line, signal)
 16575:     hist = [m - s for m, s in zip(macd_line, signal_line)]
 16576:     return macd_line, signal_line, hist
 16577: 
 16578: def atr(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], period: int = 14) -> List[float]:
 16579:     h, l, c = _to_list(highs), _to_list(lows), _to_list(closes)
 16580:     if not h:
 16581:         return []
 16582:     trs = [h[0] - l[0]]
 16583:     for i in range(1, len(h)):
 16584:         tr = max(h[i] - l[i], abs(h[i] - c[i - 1]), abs(l[i] - c[i - 1]))
 16585:         trs.append(tr)
 16586:     return ema(trs, period)
 16587: 
 16588: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
 16589:     c, v = _to_list(closes), _to_list(volumes)
 16590:     out = [0.0]
 16591:     for i in range(1, len(c)):
 16592:         if c[i] > c[i - 1]:
 16593:             out.append(out[-1] + v[i])
 16594:         elif c[i] < c[i - 1]:
 16595:             out.append(out[-1] - v[i])
 16596:         else:
 16597:             out.append(out[-1])
 16598:     return out
 16599: 
 16600: def vwap(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
 16601:     h, l, c, v = _to_list(highs), _to_list(lows), _to_list(closes), _to_list(volumes)
 16602:     out: List[float] = []
 16603:     cum_tp_vol = 0.0
 16604:     cum_vol = 0.0
 16605:     for hi, lo, cl, vol in zip(h, l, c, v):
 16606:         tp = (hi + lo + cl) / 3.0
 16607:         cum_tp_vol += tp * vol
 16608:         cum_vol += max(vol, 1e-12)
 16609:         out.append(cum_tp_vol / cum_vol)
 16610:     return out
 16611: 
 16612: def slope(series: Sequence[float], lookback: int = 5) -> List[float]:
 16613:     s = _to_list(series)
 16614:     out: List[float] = []
 16615:     for i in range(len(s)):
 16616:         if i < lookback:
 16617:             out.append(0.0)
 16618:         else:
 16619:             denom = abs(s[i - lookback]) if abs(s[i - lookback]) > 1e-12 else 1e-12
 16620:             out.append((s[i] - s[i - lookback]) / denom)
 16621:     return out
 16622: 
 16623: --------------------------------------------------------------------------------
 16624: FILE: scalper/core/signal.py
 16625: --------------------------------------------------------------------------------
 16626: # scalper/core/signal.py
 16627: from __future__ import annotations
 16628: from dataclasses import dataclass, field
 16629: from typing import List, Optional, Literal, Dict, Any
 16630: 
 16631: Side = Literal["long", "short"]
 16632: 
 16633: @dataclass
 16634: class Signal:
 16635:     symbol: str
 16636:     timeframe: str
 16637:     side: Side
 16638:     entry: float
 16639:     sl: float
 16640:     tp1: Optional[float] = None
 16641:     tp2: Optional[float] = None
 16642:     qty: Optional[float] = None
 16643:     score: float = 0.0          # 0..1 (ou entier, normalisé au besoin)
 16644:     quality: float = 0.0        # 0..1
 16645:     reasons: List[str] = field(default_factory=list)
 16646:     timestamp: Optional[int] = None  # ms epoch de la bougie de déclenchement
 16647:     extra: Dict[str, Any] = field(default_factory=dict)
 16648: 
 16649:     def risk_per_unit(self) -> float:
 16650:         return abs(self.entry - self.sl)
 16651: 
 16652:     def as_dict(self) -> Dict[str, Any]:
 16653:         d = {
 16654:             "symbol": self.symbol, "timeframe": self.timeframe, "side": self.side,
 16655:             "entry": self.entry, "sl": self.sl, "tp1": self.tp1, "tp2": self.tp2,
 16656:             "qty": self.qty, "score": self.score, "quality": self.quality,
 16657:             "timestamp": self.timestamp, "reasons": "|".join(self.reasons),
 16658:         }
 16659:         d.update(self.extra or {})
 16660:         return d
 16661: 
 16662: --------------------------------------------------------------------------------
 16663: FILE: scalper/exchange/__init__.py
 16664: --------------------------------------------------------------------------------
 16665: # Rend le sous-package exchanges importable
 16666: __all__ = ["bitget"]
 16667: 
 16668: --------------------------------------------------------------------------------
 16669: FILE: scalper/exchange/bitget.py
 16670: --------------------------------------------------------------------------------
 16671: # scalper/exchange/bitget.py
 16672: from __future__ import annotations
 16673: import os
 16674: import requests
 16675: from typing import List, Dict, Any
 16676: 
 16677: BASE_URL = "https://api.bitget.com"
 16678: 
 16679: # Spot: period strings
 16680: _SPOT_PERIOD = {
 16681:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min", "30m": "30min",
 16682:     "1h": "1hour", "4h": "4hour", "6h": "6hour", "12h": "12hour",
 16683:     "1d": "1day", "3d": "3day", "1w": "1week",
 16684: }
 16685: # Mix: granularity seconds
 16686: _MIX_GRAN = {
 16687:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
 16688:     "1h": 3600, "4h": 14400, "6h": 21600, "12h": 43200,
 16689:     "1d": 86400, "3d": 259200, "1w": 604800,
 16690: }
 16691: 
 16692: def _market_from_symbol(symbol: str) -> str:
 16693:     s = symbol.upper()
 16694:     if s.endswith("_SPBL"):
 16695:         return "spot"
 16696:     if s.endswith("_UMCBL"):
 16697:         return "umcbl"
 16698:     if s.endswith("_DMCBL"):
 16699:         return "dmcbl"
 16700:     if s.endswith("_CMCBL"):
 16701:         return "cmcbl"
 16702:     # fallback env / défaut umcbl
 16703:     return os.getenv("BITGET_MARKET", "umcbl").lower()
 16704: 
 16705: def _product_type(market: str) -> str:
 16706:     # valeur attendue par les endpoints mix (umcbl/dmcbl/cmcbl)
 16707:     if market in ("umcbl", "dmcbl", "cmcbl"):
 16708:         return market
 16709:     return "umcbl"
 16710: 
 16711: class BitgetExchange:
 16712:     """
 16713:     Wrapper simple: get_ohlcv(symbol, timeframe, limit) -> [[ts, o, h, l, c, v], ...]
 16714:     symbol spot ex: BTCUSDT_SPBL
 16715:     symbol perp ex: BTCUSDT_UMCBL / BTCUSD_DMCBL / BTCUSD_CMCBL
 16716:     """
 16717:     def __init__(self, api_key: str = "", api_secret: str = "", api_passphrase: str = "", timeout: int = 20) -> None:
 16718:         self.session = requests.Session()
 16719:         self.session.headers.update({"User-Agent": "scalp-bot/1.0"})
 16720:         self.timeout = timeout
 16721: 
 16722:     def _get(self, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
 16723:         url = BASE_URL + path
 16724:         r = self.session.get(url, params=params, timeout=self.timeout)
 16725:         r.raise_for_status()
 16726:         data = r.json()
 16727:         # Bitget: {"code":"00000","msg":"success","requestTime":..., "data":[...]}
 16728:         if not isinstance(data, dict) or str(data.get("code")) not in ("00000", "0", "200"):
 16729:             raise RuntimeError(f"Bitget error payload: {data}")
 16730:         return data
 16731: 
 16732:     def get_ohlcv(self, symbol: str, timeframe: str = "5m", limit: int = 500) -> List[List[float]]:
 16733:         timeframe = timeframe.lower()
 16734:         mkt = _market_from_symbol(symbol)
 16735: 
 16736:         if mkt == "spot":
 16737:             period = _SPOT_PERIOD.get(timeframe)
 16738:             if not period:
 16739:                 raise ValueError(f"timeframe spot non supporté: {timeframe}")
 16740:             # Bitget spot: limit max souvent 1000
 16741:             lim = max(1, min(int(limit), 1000))
 16742:             params = {"symbol": symbol, "period": period, "limit": lim}
 16743:             data = self._get("/api/spot/v1/market/candles", params=params)
 16744:             rows = data.get("data") or []
 16745:             out: List[List[float]] = []
 16746:             # Bitget renvoie décroissant -> on inverse
 16747:             for r in reversed(rows):
 16748:                 ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
 16749:                 out.append([ts, o, h, l, c, v])
 16750:             return out
 16751: 
 16752:         # MIX (umcbl/dmcbl/cmcbl)
 16753:         gran = _MIX_GRAN.get(timeframe)
 16754:         if not gran:
 16755:             raise ValueError(f"timeframe mix non supporté: {timeframe}")
 16756: 
 16757:         # Bitget mix: limit max souvent 200, granularity en secondes, productType parfois requis
 16758:         lim = max(1, min(int(limit), 200))
 16759:         params = {
 16760:             "symbol": symbol,
 16761:             "granularity": int(gran),
 16762:             "limit": lim,
 16763:             "productType": _product_type(mkt),
 16764:         }
 16765: 
 16766:         # essais: candles -> history-candles (certaines régions)
 16767:         try:
 16768:             data = self._get("/api/mix/v1/market/candles", params=params)
 16769:         except requests.HTTPError:
 16770:             data = self._get("/api/mix/v1/market/history-candles", params=params)
 16771: 
 16772:         rows = data.get("data") or []
 16773:         out: List[List[float]] = []
 16774:         for r in reversed(rows):
 16775:             ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
 16776:             out.append([ts, o, h, l, c, v])
 16777:         return out
 16778: 
 16779: --------------------------------------------------------------------------------
 16780: FILE: scalper/exchange/bitget_ccxt.py
 16781: --------------------------------------------------------------------------------
 16782: # scalper/exchange/bitget_ccxt.py
 16783: from __future__ import annotations
 16784: 
 16785: import asyncio
 16786: import csv
 16787: import os
 16788: import time
 16789: from typing import Any, List, Optional
 16790: 
 16791: # CCXT async
 16792: try:
 16793:     import ccxt.async_support as ccxt
 16794: except Exception as e:  # noqa: BLE001
 16795:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
 16796: 
 16797: 
 16798: def _now_ms() -> int:
 16799:     return int(time.time() * 1000)
 16800: 
 16801: 
 16802: class BitgetExchange:
 16803:     """
 16804:     Échange Bitget via CCXT (async) avec cache CSV local.
 16805:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
 16806:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
 16807:         [[ts, open, high, low, close, volume], ...]
 16808:     """
 16809: 
 16810:     def __init__(
 16811:         self,
 16812:         *,
 16813:         api_key: Optional[str] = None,
 16814:         secret: Optional[str] = None,
 16815:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
 16816:         data_dir: str = "/notebooks/data",
 16817:         use_cache: bool = True,
 16818:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
 16819:         spot: bool = True,           # True = SPOT (recommandé ici)
 16820:     ) -> None:
 16821:         self.data_dir = data_dir
 16822:         self.use_cache = use_cache
 16823:         self.min_fresh = int(min_fresh_seconds)
 16824:         self.spot = spot
 16825: 
 16826:         os.makedirs(self.data_dir, exist_ok=True)
 16827: 
 16828:         # Instance CCXT (async)
 16829:         self.ex = ccxt.bitget({
 16830:             "apiKey": api_key or "",
 16831:             "secret": secret or "",
 16832:             "password": password or "",
 16833:             "enableRateLimit": True,
 16834:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
 16835:         })
 16836: 
 16837:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
 16838:         self._markets_task: Optional[asyncio.Task[Any]] = None
 16839: 
 16840:     async def _ensure_markets(self) -> None:
 16841:         if self._markets_task is None:
 16842:             self._markets_task = asyncio.create_task(self.ex.load_markets())
 16843:         await self._markets_task
 16844: 
 16845:     # ---------- CSV cache ----------
 16846:     def _csv_path(self, symbol: str, timeframe: str) -> str:
 16847:         safe = symbol.replace("/", "").replace(":", "")
 16848:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
 16849: 
 16850:     def _read_cache(self, path: str) -> List[List[float]]:
 16851:         if not os.path.exists(path):
 16852:             return []
 16853:         rows: List[List[float]] = []
 16854:         try:
 16855:             with open(path, "r", newline="") as f:
 16856:                 rd = csv.reader(f)
 16857:                 for r in rd:
 16858:                     if not r:
 16859:                         continue
 16860:                     # ts, o, h, l, c, v
 16861:                     try:
 16862:                         rows.append([
 16863:                             int(r[0]),
 16864:                             float(r[1]),
 16865:                             float(r[2]),
 16866:                             float(r[3]),
 16867:                             float(r[4]),
 16868:                             float(r[5]),
 16869:                         ])
 16870:                     except Exception:
 16871:                         # on ignore les lignes corrompues
 16872:                         continue
 16873:         except Exception:
 16874:             return []
 16875:         return rows
 16876: 
 16877:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
 16878:         # On ré‑écrit intégralement (simple et sûr)
 16879:         tmp = path + ".tmp"
 16880:         with open(tmp, "w", newline="") as f:
 16881:             wr = csv.writer(f)
 16882:             wr.writerows(data)
 16883:         os.replace(tmp, path)
 16884: 
 16885:     # ---------- API publique pour orchestrateur ----------
 16886:     async def fetch_ohlcv(
 16887:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
 16888:     ) -> List[List[float]]:
 16889:         """
 16890:         Conformité orchestrateur : signature (symbol, timeframe, limit).
 16891:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
 16892:         """
 16893:         await self._ensure_markets()
 16894: 
 16895:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
 16896:         ccxt_symbol = symbol.replace("USDT", "/USDT")
 16897:         cache_path = self._csv_path(symbol, timeframe)
 16898: 
 16899:         # 1) Cache
 16900:         if self.use_cache:
 16901:             cached = self._read_cache(cache_path)
 16902:             if cached:
 16903:                 # fraicheur = diff entre maintenant et ts dernière bougie
 16904:                 last_ts = int(cached[-1][0])
 16905:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
 16906:                     # suffisant => on retourne la fin
 16907:                     if len(cached) >= limit:
 16908:                         return cached[-limit:]
 16909:                     # pas assez, on essaiera de compléter via CCXT plus bas
 16910:                 # sinon: on tentera de rafraîchir plus loin
 16911: 
 16912:         # 2) Remote via CCXT
 16913:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
 16914:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
 16915:         params: dict[str, Any] = {}
 16916:         if self.spot is True:
 16917:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
 16918: 
 16919:         try:
 16920:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
 16921:         except Exception as e:  # noqa: BLE001
 16922:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
 16923:             cached = self._read_cache(cache_path) if self.use_cache else []
 16924:             if cached:
 16925:                 return cached[-limit:]
 16926:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
 16927: 
 16928:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
 16929:         if self.use_cache:
 16930:             base = self._read_cache(cache_path)
 16931:             merged = _merge_ohlcv(base, ohlcv)
 16932:             self._write_cache(cache_path, merged)
 16933:             # retourne la fin
 16934:             return merged[-limit:]
 16935: 
 16936:         return ohlcv[-limit:]
 16937: 
 16938:     async def close(self) -> None:
 16939:         try:
 16940:             await self.ex.close()
 16941:         except Exception:
 16942:             pass
 16943: 
 16944: 
 16945: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
 16946:     """
 16947:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
 16948:     """
 16949:     if not a:
 16950:         return list(b)
 16951:     if not b:
 16952:         return list(a)
 16953: 
 16954:     # index rapide par ts
 16955:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
 16956:     for row in b:
 16957:         by_ts[int(row[0])] = row
 16958:     return [by_ts[k] for k in sorted(by_ts)]
 16959: 
 16960: --------------------------------------------------------------------------------
 16961: FILE: scalper/exchange/fees.py
 16962: --------------------------------------------------------------------------------
 16963: # scalper/exchange/fees.py
 16964: from __future__ import annotations
 16965: 
 16966: from typing import Dict, Iterable
 16967: 
 16968: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
 16969: DEFAULT_TAKER_BPS = 6    # 0.06%
 16970: DEFAULT_MAKER_BPS = 2    # 0.02%
 16971: 
 16972: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
 16973: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
 16974: 
 16975: 
 16976: def get_fee(symbol: str, kind: str = "taker") -> float:
 16977:     """
 16978:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
 16979:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
 16980:     """
 16981:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
 16982:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
 16983:     return float(bps) / 10_000.0
 16984: 
 16985: 
 16986: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
 16987:     """
 16988:     Tente de charger les frais auprès de l'exchange (type ccxt):
 16989:       - fetch_trading_fees(symbols) si dispo
 16990:       - sinon fetch_trading_fee(symbol) pour chaque symbole
 16991:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
 16992:     """
 16993:     symbols = list(symbols)
 16994:     fees: Dict[str, Dict[str, float]] = {}
 16995: 
 16996:     try:
 16997:         if hasattr(exchange, "fetch_trading_fees"):
 16998:             data = await exchange.fetch_trading_fees(symbols)
 16999:             for s in symbols:
 17000:                 d = (data or {}).get(s, {}) or {}
 17001:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
 17002:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
 17003:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
 17004:         else:
 17005:             for s in symbols:
 17006:                 try:
 17007:                     d = await exchange.fetch_trading_fee(s)
 17008:                 except Exception:
 17009:                     d = {}
 17010:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
 17011:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
 17012:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
 17013:     except Exception:
 17014:         # fallback: défauts
 17015:         for s in symbols:
 17016:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
 17017: 
 17018:     # maj du cache
 17019:     _FEES_BY_SYMBOL.update(fees)
 17020:     return fees
 17021: 
 17022: --------------------------------------------------------------------------------
 17023: FILE: scalper/hooks/prewarm_cache.py
 17024: --------------------------------------------------------------------------------
 17025: # -*- coding: utf-8 -*-
 17026: """
 17027: Pré-chauffe léger du cache OHLCV.
 17028: 
 17029: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
 17030: pour chaque symbole, et on s'assure que le dossier data existe.
 17031: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
 17032: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
 17033: signature.
 17034: """
 17035: from __future__ import annotations
 17036: from pathlib import Path
 17037: from typing import Iterable
 17038: 
 17039: 
 17040: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
 17041:     out = Path(out_dir)
 17042:     out.mkdir(parents=True, exist_ok=True)
 17043:     for sym in symbols:
 17044:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
 17045:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
 17046:         print(f"[cache] warmup OK for {sym}")
 17047: 
 17048: --------------------------------------------------------------------------------
 17049: FILE: scalper/live/__init__.py
 17050: --------------------------------------------------------------------------------
 17051: __all__ = ["orchestrator", "fetcher", "runner"]
 17052: 
 17053: --------------------------------------------------------------------------------
 17054: FILE: scalper/live/backtest_telegram.py
 17055: --------------------------------------------------------------------------------
 17056: # scalper/live/backtest_telegram.py
 17057: from __future__ import annotations
 17058: 
 17059: import asyncio
 17060: import os
 17061: from typing import List
 17062: 
 17063: from scalper.backtest import BTCfg, run_multi
 17064: from scalper.services.utils import safe_call
 17065: 
 17066: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
 17067: async def _get_exchange():
 17068:     try:
 17069:         import ccxt.async_support as ccxt  # type: ignore
 17070:     except Exception:
 17071:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
 17072:     return ccxt.bitget()
 17073: 
 17074: def _parse_symbols(defaults: List[str]) -> List[str]:
 17075:     env = os.getenv("BACKTEST_SYMBOLS", "")
 17076:     if env.strip():
 17077:         return [s.strip().upper() for s in env.split(",") if s.strip()]
 17078:     return defaults
 17079: 
 17080: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
 17081:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
 17082:     symbols = _parse_symbols(defaults)
 17083:     cash = float(os.getenv("BT_CASH", "10000"))
 17084:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
 17085:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
 17086:     limit = int(os.getenv("BT_LIMIT", "1500"))
 17087: 
 17088:     await notifier.send(
 17089:         "🧪 Backtest en cours...\n"
 17090:         f"• Symbols: {', '.join(symbols)}\n"
 17091:         f"• TF: {timeframe}\n"
 17092:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
 17093:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
 17094:     )
 17095: 
 17096:     async def _run():
 17097:         exchange = await _get_exchange()
 17098:         try:
 17099:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
 17100:                         risk_pct=risk, slippage_bps=slip, limit=limit)
 17101:             res = await run_multi(cfg, exchange)
 17102:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
 17103:         finally:
 17104:             try:
 17105:                 await exchange.close()
 17106:             except Exception:
 17107:                 pass
 17108: 
 17109:     try:
 17110:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
 17111:     except Exception as e:
 17112:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")
 17113: 
 17114: --------------------------------------------------------------------------------
 17115: FILE: scalper/live/commands.py
 17116: --------------------------------------------------------------------------------
 17117: # scalper/live/commands.py
 17118: from __future__ import annotations
 17119: 
 17120: import asyncio
 17121: from typing import Awaitable, Callable
 17122: 
 17123: 
 17124: class CommandHandler:
 17125:     """
 17126:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
 17127:     Chaque commande est routée vers un callback approprié.
 17128:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
 17129:     """
 17130: 
 17131:     def __init__(self, notifier, command_stream, status_getter, status_sender):
 17132:         self.notifier = notifier
 17133:         self.stream = command_stream
 17134:         self.status_getter = status_getter
 17135:         self.status_sender = status_sender
 17136: 
 17137:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
 17138:         try:
 17139:             await coro
 17140:         except Exception as e:
 17141:             try:
 17142:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
 17143:             except Exception:
 17144:                 pass  # on ne propage jamais
 17145: 
 17146:     async def run(
 17147:         self,
 17148:         on_pause: Callable[[], None],
 17149:         on_resume: Callable[[], None],
 17150:         on_stop: Callable[[], Awaitable[None]] | None,
 17151:         on_setup_apply: Callable[[dict], None],
 17152:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
 17153:     ):
 17154:         """
 17155:         Boucle asynchrone qui lit les lignes du CommandStream
 17156:         et exécute le callback approprié.
 17157:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
 17158:         """
 17159:         async for line in self.stream:
 17160:             txt = (line or "").strip()
 17161:             if not txt:
 17162:                 continue
 17163: 
 17164:             try:
 17165:                 if txt.startswith("/pause"):
 17166:                     on_pause()
 17167:                     await self.notifier.send("⏸️ Pause.")
 17168: 
 17169:                 elif txt.startswith("/resume"):
 17170:                     on_resume()
 17171:                     await self.notifier.send("▶️ Resume.")
 17172: 
 17173:                 elif txt.startswith("/stop"):
 17174:                     if on_stop:
 17175:                         await self._safe_call(on_stop(), "Arrêt échoué")
 17176: 
 17177:                 elif txt.startswith("/status"):
 17178:                     snap = self.status_getter()
 17179:                     await self.notifier.send(f"ℹ️ {snap}")
 17180: 
 17181:                 elif txt.startswith("/setup"):
 17182:                     await self.notifier.send("🧩 Setup wizard à compléter.")
 17183: 
 17184:                 elif txt.startswith("/backtest"):
 17185:                     if on_backtest:
 17186:                         tail = txt[len("/backtest"):].strip()
 17187:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
 17188:                         asyncio.create_task(self._safe_call(
 17189:                             on_backtest(tail), "Backtest échoué"
 17190:                         ))
 17191:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
 17192:                     else:
 17193:                         await self.notifier.send("⚠️ Backtest non disponible.")
 17194: 
 17195:                 else:
 17196:                     await self.notifier.send(
 17197:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
 17198:                     )
 17199: 
 17200:             except Exception as e:
 17201:                 # On protège la boucle quoi qu'il arrive
 17202:                 try:
 17203:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
 17204:                 except Exception:
 17205:                     pass
 17206: 
 17207: --------------------------------------------------------------------------------
 17208: FILE: scalper/live/data_utils.py
 17209: --------------------------------------------------------------------------------
 17210: # scalper/live/data_utils.py
 17211: from __future__ import annotations
 17212: from typing import Dict, List, Sequence
 17213: 
 17214: Cols = ("timestamp", "open", "high", "low", "close", "volume")
 17215: 
 17216: def ohlcv_rows_to_dict(rows: Sequence[Sequence[float]]) -> Dict[str, List[float]]:
 17217:     """
 17218:     Convertit [[ts,o,h,l,c,v], ...] -> dict de listes.
 17219:     Tolère float|int|str numériques.
 17220:     """
 17221:     out: Dict[str, List[float]] = {k: [] for k in Cols}
 17222:     for r in rows:
 17223:         if len(r) < 6:
 17224:             raise ValueError("Ligne OHLCV invalide (6 colonnes attendues).")
 17225:         out["timestamp"].append(float(r[0]))
 17226:         out["open"].append(float(r[1]))
 17227:         out["high"].append(float(r[2]))
 17228:         out["low"].append(float(r[3]))
 17229:         out["close"].append(float(r[4]))
 17230:         out["volume"].append(float(r[5]))
 17231:     return out
 17232: 
 17233: def ohlcv_df_or_dict_to_dict(obj) -> Dict[str, List[float]]:
 17234:     """
 17235:     Accepte:
 17236:       - pandas.DataFrame avec colonnes Cols
 17237:       - dict de listes
 17238:     """
 17239:     if hasattr(obj, "columns"):
 17240:         missing = [c for c in Cols if c not in obj.columns]
 17241:         if missing:
 17242:             raise ValueError(f"Colonnes OHLCV manquantes: {missing}")
 17243:         return {k: [float(x) for x in obj[k].tolist()] for k in Cols}
 17244:     if isinstance(obj, dict):
 17245:         missing = [c for c in Cols if c not in obj]
 17246:         if missing:
 17247:             raise ValueError(f"Clés OHLCV manquantes: {missing}")
 17248:         return {k: [float(x) for x in obj[k]] for k in Cols}
 17249:     raise TypeError("Format OHLCV non supporté (DataFrame ou dict attendu).")
 17250: 
 17251: def map_index_secondary(ts_main: float, ts_arr: List[float]) -> int:
 17252:     """
 17253:     Retourne l'index i du timestamp secondaire le plus proche
 17254:     inférieur/égal à ts_main. Recherche linéaire suffisante en live.
 17255:     """
 17256:     j = 0
 17257:     n = len(ts_arr)
 17258:     while j + 1 < n and ts_arr[j + 1] <= ts_main:
 17259:         j += 1
 17260:     return j
 17261: 
 17262: --------------------------------------------------------------------------------
 17263: FILE: scalper/live/fetcher.py
 17264: --------------------------------------------------------------------------------
 17265: # scalper/live/fetcher.py
 17266: from __future__ import annotations
 17267: from typing import Dict, List, Optional, Any
 17268: 
 17269: class DataFetcher:
 17270:     """
 17271:     Récupération OHLCV depuis un client d'exchange.
 17272:     Compatible:
 17273:       - Wrapper custom: client.get_ohlcv(symbol, timeframe, limit)
 17274:       - ccxt direct:    client.fetch_ohlcv(symbol, timeframe=..., limit=...)
 17275:     Retour standardisé: dict[str, list[float]] avec clés:
 17276:       timestamp, open, high, low, close, volume
 17277:     """
 17278:     def __init__(self, client: Any) -> None:
 17279:         self.client = client
 17280:         # Détection des méthodes disponibles
 17281:         self._has_get = hasattr(client, "get_ohlcv")
 17282:         self._has_fetch = hasattr(client, "fetch_ohlcv")
 17283: 
 17284:         if not (self._has_get or self._has_fetch):
 17285:             raise AttributeError(
 17286:                 "Le client exchange doit exposer get_ohlcv(...) ou fetch_ohlcv(...). "
 17287:                 "Ex: wrapper custom ou objet ccxt.bitget."
 17288:             )
 17289: 
 17290:     @staticmethod
 17291:     def _to_dict(rows: List[List[float]]) -> Dict[str, List[float]]:
 17292:         cols = ("timestamp", "open", "high", "low", "close", "volume")
 17293:         out = {k: [] for k in cols}
 17294:         for r in rows:
 17295:             # rows: [ts, open, high, low, close, volume]
 17296:             out["timestamp"].append(float(r[0]))
 17297:             out["open"].append(float(r[1]))
 17298:             out["high"].append(float(r[2]))
 17299:             out["low"].append(float(r[3]))
 17300:             out["close"].append(float(r[4]))
 17301:             out["volume"].append(float(r[5]))
 17302:         return out
 17303: 
 17304:     def fetch(self, symbol: str, timeframe: str, limit: int = 1500) -> Dict[str, List[float]]:
 17305:         if self._has_get:
 17306:             rows = self.client.get_ohlcv(symbol=symbol, timeframe=timeframe, limit=limit)
 17307:         else:
 17308:             # ccxt: fetch_ohlcv(symbol, timeframe=..., limit=...)
 17309:             rows = self.client.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
 17310:         return self._to_dict(rows)
 17311: 
 17312:     def try_fetch_1h(self, symbol: str, limit: int = 1500) -> Optional[Dict[str, List[float]]]:
 17313:         try:
 17314:             if self._has_get:
 17315:                 rows = self.client.get_ohlcv(symbol=symbol, timeframe="1h", limit=limit)
 17316:             else:
 17317:                 rows = self.client.fetch_ohlcv(symbol, timeframe="1h", limit=limit)
 17318:             return self._to_dict(rows)
 17319:         except Exception:
 17320:             return None
 17321: 
 17322: --------------------------------------------------------------------------------
 17323: FILE: scalper/live/journal.py
 17324: --------------------------------------------------------------------------------
 17325: from __future__ import annotations
 17326: import os, csv
 17327: from typing import Any, Dict, List
 17328: 
 17329: class LogWriter:
 17330:     """Gestion simple des CSV (création à la volée + append)."""
 17331:     def __init__(self, dirpath: str) -> None:
 17332:         self.dir = dirpath
 17333:         os.makedirs(self.dir, exist_ok=True)
 17334: 
 17335:     def init(self, fname: str, headers: List[str]) -> None:
 17336:         p = os.path.join(self.dir, fname)
 17337:         if not os.path.exists(p):
 17338:             with open(p, "w", newline="", encoding="utf-8") as f:
 17339:                 csv.DictWriter(f, fieldnames=headers).writeheader()
 17340: 
 17341:     def row(self, fname: str, row: Dict[str, Any]) -> None:
 17342:         p = os.path.join(self.dir, fname)
 17343:         with open(p, "a", newline="", encoding="utf-8") as f:
 17344:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)
 17345: 
 17346: --------------------------------------------------------------------------------
 17347: FILE: scalper/live/logs.py
 17348: --------------------------------------------------------------------------------
 17349: # scalp/live/logs.py
 17350: from __future__ import annotations
 17351: import os, csv
 17352: from typing import Any, List, Dict
 17353: 
 17354: class CsvLog:
 17355:     def __init__(self, path: str, headers: List[str]):
 17356:         self.path = path
 17357:         self.headers = headers
 17358:         self._ensure_header()
 17359: 
 17360:     def _ensure_header(self):
 17361:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
 17362:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
 17363:         if must_write:
 17364:             with open(self.path, "w", newline="") as f:
 17365:                 csv.writer(f).writerow(self.headers)
 17366: 
 17367:     def write_row(self, row: Dict[str, Any]):
 17368:         with open(self.path, "a", newline="") as f:
 17369:             w = csv.DictWriter(f, fieldnames=self.headers)
 17370:             w.writerow({k: row.get(k, "") for k in self.headers})
 17371: 
 17372: --------------------------------------------------------------------------------
 17373: FILE: scalper/live/loops/trade.py
 17374: --------------------------------------------------------------------------------
 17375: # scalp/live/loops/trade.py
 17376: from __future__ import annotations
 17377: import asyncio, os
 17378: from dataclasses import dataclass, field
 17379: from typing import Any, Dict, List, Callable
 17380: 
 17381: from ...services.utils import safe_call
 17382: from ...risk.manager import compute_size
 17383: 
 17384: QUIET = int(os.getenv("QUIET", "0") or "0")
 17385: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
 17386: 
 17387: class PositionFSM:
 17388:     def __init__(self):
 17389:         self.state = "FLAT"
 17390:         self.side = "flat"
 17391:         self.entry = 0.0
 17392:         self.qty = 0.0
 17393:     def can_open(self): return self.state == "FLAT"
 17394:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
 17395:     def can_close(self): return self.state == "OPEN"
 17396:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
 17397: 
 17398: @dataclass
 17399: class SymbolContext:
 17400:     symbol: str
 17401:     timeframe: str
 17402:     ohlcv: List[List[float]] = field(default_factory=list)
 17403:     ticks: int = 0
 17404:     fsm: PositionFSM = field(default_factory=PositionFSM)
 17405: 
 17406: class TradeLoop:
 17407:     """
 17408:     Boucle par symbole, indépendante de l'orchestrateur.
 17409:     """
 17410:     def __init__(
 17411:         self,
 17412:         symbol: str,
 17413:         timeframe: str,
 17414:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
 17415:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
 17416:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
 17417:         config: Dict[str, Any],
 17418:         mode_getter: Callable[[], str],
 17419:         log_signals, log_orders, log_fills,
 17420:         tick_counter_add: Callable[[int], None],
 17421:     ):
 17422:         self.symbol = symbol
 17423:         self.timeframe = timeframe
 17424:         self.fetch = ohlcv_fetch
 17425:         self.order_market = order_market
 17426:         self.generate_signal = generate_signal
 17427:         self.config = config
 17428:         self.get_mode = mode_getter
 17429:         self.log_signals = log_signals
 17430:         self.log_orders = log_orders
 17431:         self.log_fills = log_fills
 17432:         self.ctx = SymbolContext(symbol, timeframe)
 17433:         self._tick_add = tick_counter_add
 17434: 
 17435:         # Risk/frais
 17436:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
 17437:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
 17438:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
 17439:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
 17440: 
 17441:     def _bps_for(self, order_type: str = "market") -> float:
 17442:         # market -> taker; limit post-only -> maker
 17443:         per = self.fees_map.get(self.symbol, {})
 17444:         if order_type == "limit":
 17445:             return float(per.get("maker_bps", 0.0))
 17446:         return float(per.get("taker_bps", 0.0))
 17447: 
 17448:     async def run(self, running: Callable[[], bool]):
 17449:         lookback = 200
 17450:         while running():
 17451:             if self.get_mode() != "RUNNING":
 17452:                 await asyncio.sleep(0.5); continue
 17453: 
 17454:             async def _fetch():
 17455:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
 17456:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
 17457:             if not ohlcv or len(ohlcv) < lookback+1:
 17458:                 await asyncio.sleep(1.0); continue
 17459: 
 17460:             self.ctx.ohlcv = ohlcv
 17461:             self.ctx.ticks += 1
 17462:             self._tick_add(1)
 17463: 
 17464:             window = ohlcv[-(lookback+1):]
 17465:             ts, _o, _h, _l, c, _v = window[-1]
 17466: 
 17467:             try:
 17468:                 sig = self.generate_signal(window, self.config) or {}
 17469:             except Exception as e:
 17470:                 if not QUIET:
 17471:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
 17472:                 await asyncio.sleep(0.5); continue
 17473: 
 17474:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
 17475:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
 17476: 
 17477:             # --- Entrée (market -> taker)
 17478:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
 17479:                 balance = float(self.config.get("cash", 10_000.0))
 17480:                 qty = compute_size(
 17481:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
 17482:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
 17483:                 )
 17484:                 if qty > 0:
 17485:                     async def _place():
 17486:                         return await self.order_market(self.symbol, side, qty)
 17487:                     order = await safe_call(_place, label=f"order:{self.symbol}")
 17488:                     self.ctx.fsm.on_open(side, entry or c, qty)
 17489:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
 17490:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
 17491: 
 17492:             # --- Sortie (market -> taker)
 17493:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
 17494:                 qty = self.ctx.fsm.qty
 17495:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
 17496:                 async def _close():
 17497:                     return await self.order_market(self.symbol, exit_side, qty)
 17498:                 order = await safe_call(_close, label=f"close:{self.symbol}")
 17499: 
 17500:                 # fill avec slippage + frais (taker)
 17501:                 price_fill = float(c)
 17502:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
 17503:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
 17504:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
 17505:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
 17506:                                           "order_id": (order or {}).get("id","")})
 17507:                 self.ctx.fsm.on_close()
 17508: 
 17509:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
 17510:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
 17511: 
 17512:             await asyncio.sleep(0.1 if QUIET else 0.01)
 17513: 
 17514: --------------------------------------------------------------------------------
 17515: FILE: scalper/live/notify.py
 17516: --------------------------------------------------------------------------------
 17517: # -*- coding: utf-8 -*-
 17518: from __future__ import annotations
 17519: import os
 17520: import asyncio
 17521: from dataclasses import dataclass
 17522: from typing import AsyncIterator, Optional
 17523: 
 17524: 
 17525: @dataclass
 17526: class BaseNotifier:
 17527:     async def send(self, text: str) -> None:  # pragma: no cover
 17528:         print(text)
 17529: 
 17530: 
 17531: class NullNotifier(BaseNotifier):
 17532:     pass
 17533: 
 17534: 
 17535: class TelegramNotifier(BaseNotifier):
 17536:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
 17537:         import aiohttp  # lazy
 17538:         self._token = token
 17539:         self._chat = chat_id
 17540:         self._session: aiohttp.ClientSession | None = None
 17541: 
 17542:     async def _ensure(self):
 17543:         import aiohttp
 17544:         if self._session is None or self._session.closed:
 17545:             self._session = aiohttp.ClientSession()
 17546: 
 17547:     async def send(self, text: str) -> None:
 17548:         import aiohttp
 17549:         await self._ensure()
 17550:         # pas de markdown pour éviter les erreurs 400 de parsing
 17551:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
 17552:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
 17553:         try:
 17554:             async with self._session.post(url, json=payload, timeout=20) as r:
 17555:                 await r.text()  # on ignore la réponse pour rester simple
 17556:         except Exception:
 17557:             # on fait un fallback silencieux pour ne pas casser le bot
 17558:             print("[notify:telegram] send fail (ignored)")
 17559: 
 17560:     async def close(self):
 17561:         if self._session and not self._session.closed:
 17562:             await self._session.close()
 17563: 
 17564: 
 17565: class _NullCommands:
 17566:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
 17567:     def __aiter__(self) -> AsyncIterator[str]:
 17568:         return self
 17569:     async def __anext__(self) -> str:
 17570:         await asyncio.sleep(3600)  # jamais
 17571:         raise StopAsyncIteration
 17572: 
 17573: 
 17574: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
 17575:     """
 17576:     Retourne (notifier, command_stream).
 17577: 
 17578:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
 17579:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
 17580:       commandes interactives plus tard.
 17581:     - Sinon: NullNotifier + flux vide.
 17582:     """
 17583:     token = os.getenv("TELEGRAM_BOT_TOKEN")
 17584:     chat = os.getenv("TELEGRAM_CHAT_ID")
 17585:     if token and chat:
 17586:         print("[notify] TELEGRAM configured.")
 17587:         return TelegramNotifier(token, chat), _NullCommands()
 17588:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
 17589:     return NullNotifier(), _NullCommands()
 17590: 
 17591: --------------------------------------------------------------------------------
 17592: FILE: scalper/live/ohlcv_service.py
 17593: --------------------------------------------------------------------------------
 17594: from __future__ import annotations
 17595: import time
 17596: from typing import Any, Dict, List, Optional
 17597: 
 17598: try:
 17599:     from scalper.adapters.market_data import MarketData
 17600: except Exception:
 17601:     MarketData = None  # type: ignore
 17602: 
 17603: class OhlcvService:
 17604:     """Lecture/normalisation OHLCV avec fallback agressifs."""
 17605:     def __init__(self, exchange) -> None:
 17606:         self.exchange = exchange
 17607:         self.md = MarketData(exchange) if MarketData is not None else None
 17608: 
 17609:     @staticmethod
 17610:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
 17611:         out: List[Dict[str, float]] = []
 17612:         if not rows: return out
 17613:         for r in rows:
 17614:             if isinstance(r, dict):
 17615:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
 17616:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
 17617:                 v = float(r.get("volume", r.get("vol", 0.0)))
 17618:             else:
 17619:                 rr = list(r)
 17620:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
 17621:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
 17622:                 else:
 17623:                     o = float(rr[0]) if len(rr) > 0 else 0.0
 17624:                     h = float(rr[1]) if len(rr) > 1 else o
 17625:                     l = float(rr[2]) if len(rr) > 2 else o
 17626:                     c = float(rr[3]) if len(rr) > 3 else o
 17627:                     v = float(rr[4]) if len(rr) > 4 else 0.0
 17628:                     ts = int(rr[5]) if len(rr) > 5 else 0
 17629:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
 17630:         return out
 17631: 
 17632:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
 17633:         # 1) MarketData (si dispo)
 17634:         if self.md is not None:
 17635:             try:
 17636:                 d = self.md.get_ohlcv(symbol, interval, limit)
 17637:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
 17638:                     return self.normalize_rows(d["data"])
 17639:             except Exception:
 17640:                 pass
 17641: 
 17642:         # 2) Exchange natif
 17643:         rows: List[Any] = []
 17644:         try:
 17645:             data = self.exchange.get_kline(symbol, interval=interval)
 17646:         except Exception:
 17647:             data = None
 17648: 
 17649:         if isinstance(data, dict):
 17650:             rows = (
 17651:                 data.get("data") or data.get("result") or data.get("records") or
 17652:                 data.get("list") or data.get("items") or data.get("candles") or []
 17653:             )
 17654:             guard = 0
 17655:             while isinstance(rows, dict) and guard < 3:
 17656:                 rows = (
 17657:                     rows.get("data") or rows.get("result") or rows.get("records") or
 17658:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
 17659:                 )
 17660:                 guard += 1
 17661:         elif isinstance(data, (list, tuple)):
 17662:             rows = list(data)
 17663: 
 17664:         out = self.normalize_rows(rows)[-limit:]
 17665:         if out: return out
 17666: 
 17667:         # 3) Fallback strict via ticker -> bougie synthétique
 17668:         try:
 17669:             tkr = self.exchange.get_ticker(symbol)
 17670:             items = []
 17671:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
 17672:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
 17673:             if items:
 17674:                 last = items[0]
 17675:                 if isinstance(last, dict):
 17676:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
 17677:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
 17678:                 else:
 17679:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
 17680:                 ts = int(time.time()*1000)
 17681:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
 17682:         except Exception:
 17683:             pass
 17684:         return []
 17685: 
 17686: --------------------------------------------------------------------------------
 17687: FILE: scalper/live/orchestrator.py
 17688: --------------------------------------------------------------------------------
 17689: # scalper/live/orchestrator.py
 17690: from __future__ import annotations
 17691: import time
 17692: from typing import List, Tuple, Dict, Any
 17693: from scalper.live.fetcher import DataFetcher
 17694: from scalper.live.runner import JobRunner
 17695: 
 17696: class Orchestrator:
 17697:     def __init__(
 17698:         self,
 17699:         *,
 17700:         exchange_client: Any,
 17701:         strategies_cfg: Dict[str, Any],
 17702:         jobs: List[Tuple[str, str]],   # [(symbol, timeframe)]
 17703:         interval_sec: int = 60,
 17704:         equity: float = 1000.0,
 17705:         risk_pct: float = 0.01,
 17706:     ) -> None:
 17707:         self.fetcher = DataFetcher(exchange_client)
 17708:         self.runner = JobRunner(strategies_cfg, equity, risk_pct)
 17709:         self.jobs = [(s.upper(), tf) for s, tf in jobs]
 17710:         self.interval = max(5, int(interval_sec))
 17711: 
 17712:     def _tick(self) -> None:
 17713:         for symbol, tf in self.jobs:
 17714:             try:
 17715:                 data = self.fetcher.fetch(symbol, tf)
 17716:                 data_1h = self.fetcher.try_fetch_1h(symbol)
 17717:                 sig = self.runner.run_once(symbol=symbol, timeframe=tf, ohlcv=data, ohlcv_1h=data_1h)
 17718:                 if sig is None:
 17719:                     print(f"[{symbol}/{tf}] Aucun signal.")
 17720:                 else:
 17721:                     d = sig.as_dict()
 17722:                     print(f"[{symbol}/{tf}] side={d['side']} entry={d['entry']:.6f} "
 17723:                           f"sl={d['sl']:.6f} tp1={d['tp1']:.6f} tp2={d['tp2']:.6f} "
 17724:                           f"score={d['score']} q={d['quality']:.2f} :: {d.get('reasons','')}")
 17725:             except Exception as e:
 17726:                 print(f"[{symbol}/{tf}] ERREUR: {e}")
 17727: 
 17728:     def loop(self) -> None:
 17729:         print(f"[Orchestrator] jobs={self.jobs} interval={self.interval}s")
 17730:         while True:
 17731:             t0 = time.time()
 17732:             self._tick()
 17733:             dt = time.time() - t0
 17734:             time.sleep(max(0.0, self.interval - dt))
 17735: 
 17736: --------------------------------------------------------------------------------
 17737: FILE: scalper/live/orders.py
 17738: --------------------------------------------------------------------------------
 17739: # live/orders.py
 17740: from __future__ import annotations
 17741: from dataclasses import dataclass
 17742: from typing import Any, Optional
 17743: 
 17744: from scalper.services.order_service import OrderService, OrderRequest
 17745: 
 17746: @dataclass
 17747: class OrderResult:
 17748:     accepted: bool
 17749:     order_id: str | None = None
 17750:     status: str | None = None
 17751:     reason: str | None = None
 17752: 
 17753: class OrderExecutor:
 17754:     """
 17755:     Fine couche autour d'OrderService + exchange :
 17756:       - calcule l'équité USDT
 17757:       - place une entrée (risk_pct)
 17758:       - récupère les fills (normalisés)
 17759:     L'orchestrateur n’appelle plus OrderService directement.
 17760:     """
 17761: 
 17762:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
 17763:         self.order_service = order_service
 17764:         self.exchange = exchange
 17765:         self.config = config
 17766: 
 17767:     # ---------- Equity ----------
 17768:     def get_equity_usdt(self) -> float:
 17769:         equity = 0.0
 17770:         try:
 17771:             assets = self.exchange.get_assets()
 17772:             if isinstance(assets, dict):
 17773:                 for a in (assets.get("data") or []):
 17774:                     if str(a.get("currency")).upper() == "USDT":
 17775:                         equity = float(a.get("equity", 0.0))
 17776:                         break
 17777:         except Exception:
 17778:             pass
 17779:         return equity
 17780: 
 17781:     # ---------- Entrée ----------
 17782:     def place_entry(self, *, symbol: str, side: str, price: float,
 17783:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
 17784:         """
 17785:         side: 'long' | 'short'
 17786:         Retourne OrderResult(accepted, order_id, status, reason)
 17787:         """
 17788:         equity = self.get_equity_usdt()
 17789:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
 17790:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
 17791:                            risk_pct=float(risk_pct))
 17792:         try:
 17793:             res = self.order_service.prepare_and_place(equity, req)
 17794:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
 17795:                                order_id=getattr(res, "order_id", None),
 17796:                                status=getattr(res, "status", None),
 17797:                                reason=getattr(res, "reason", None))
 17798:         except Exception as e:
 17799:             return OrderResult(accepted=False, reason=str(e))
 17800: 
 17801:     # ---------- Fills ----------
 17802:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
 17803:         """
 17804:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
 17805:         """
 17806:         try:
 17807:             raw = self.exchange.get_fills(symbol, order_id, limit)
 17808:         except Exception:
 17809:             return []
 17810: 
 17811:         items: list = []
 17812:         if isinstance(raw, dict):
 17813:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
 17814:         elif isinstance(raw, (list, tuple)):
 17815:             items = list(raw)
 17816: 
 17817:         out: list[dict] = []
 17818:         for f in items:
 17819:             if isinstance(f, dict):
 17820:                 out.append({
 17821:                     "orderId": f.get("orderId") or f.get("order_id") or "",
 17822:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
 17823:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
 17824:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
 17825:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
 17826:                 })
 17827:             else:
 17828:                 try:
 17829:                     seq = list(f)
 17830:                     out.append({
 17831:                         "orderId": str(seq[0]) if seq else "",
 17832:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
 17833:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
 17834:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
 17835:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
 17836:                     })
 17837:                 except Exception:
 17838:                     continue
 17839:         return out
 17840: 
 17841: --------------------------------------------------------------------------------
 17842: FILE: scalper/live/position_fsm.py
 17843: --------------------------------------------------------------------------------
 17844: # live/position_fsm.py
 17845: from __future__ import annotations
 17846: from dataclasses import dataclass
 17847: from typing import Optional, Dict, Any, List
 17848: 
 17849: 
 17850: STATE_FLAT = "FLAT"
 17851: STATE_PENDING_ENTRY = "PENDING_ENTRY"
 17852: STATE_OPEN = "OPEN"
 17853: STATE_PENDING_EXIT = "PENDING_EXIT"
 17854: 
 17855: 
 17856: @dataclass
 17857: class PositionState:
 17858:     symbol: str
 17859:     state: str = STATE_FLAT
 17860:     order_id: Optional[str] = None
 17861:     side: Optional[str] = None   # "long" | "short"
 17862:     qty: float = 0.0
 17863:     entry: float = 0.0
 17864: 
 17865: 
 17866: class PositionFSM:
 17867:     """
 17868:     FSM ultra-simple par symbole.
 17869:     - set_pending_entry(order_id, side)
 17870:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
 17871:     """
 17872: 
 17873:     def __init__(self, symbols: List[str]) -> None:
 17874:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
 17875: 
 17876:     # -------- API utilisateur --------
 17877:     def ensure_symbol(self, symbol: str) -> None:
 17878:         if symbol not in self._by_symbol:
 17879:             self._by_symbol[symbol] = PositionState(symbol)
 17880: 
 17881:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
 17882:         self.ensure_symbol(symbol)
 17883:         st = self._by_symbol[symbol]
 17884:         st.state = STATE_PENDING_ENTRY
 17885:         st.order_id = order_id
 17886:         st.side = side
 17887: 
 17888:     def mark_pending_exit(self, symbol: str) -> None:
 17889:         self.ensure_symbol(symbol)
 17890:         st = self._by_symbol[symbol]
 17891:         st.state = STATE_PENDING_EXIT
 17892: 
 17893:     def force_flat(self, symbol: str) -> None:
 17894:         self._by_symbol[symbol] = PositionState(symbol)
 17895: 
 17896:     # -------- Lecture --------
 17897:     def get(self, symbol: str) -> PositionState:
 17898:         self.ensure_symbol(symbol)
 17899:         return self._by_symbol[symbol]
 17900: 
 17901:     def all(self) -> Dict[str, PositionState]:
 17902:         return self._by_symbol
 17903: 
 17904:     # -------- Réconciliation --------
 17905:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
 17906:         """
 17907:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
 17908:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
 17909:         """
 17910:         # indexer positions ouvertes
 17911:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
 17912: 
 17913:         for sym, st in self._by_symbol.items():
 17914:             p = idx_open.get(sym)
 17915: 
 17916:             if st.state == STATE_PENDING_ENTRY:
 17917:                 # si on voit des fills de l'ordre en attente -> OPEN
 17918:                 f_list = fills.get(sym) or []
 17919:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
 17920:                 if qty_filled > 0.0 or p:
 17921:                     st.state = STATE_OPEN
 17922:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
 17923:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
 17924:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
 17925:             elif st.state == STATE_OPEN:
 17926:                 # si plus de position ouverte -> FLAT
 17927:                 if not p:
 17928:                     st.state = STATE_FLAT
 17929:                     st.order_id = None
 17930:                     st.side = None
 17931:                     st.qty = 0.0
 17932:                     st.entry = 0.0
 17933:                 else:
 17934:                     st.qty = float(p.get("qty", st.qty))
 17935:                     st.entry = float(p.get("avgEntryPrice", st.entry))
 17936:             elif st.state == STATE_PENDING_EXIT:
 17937:                 # si plus de position -> FLAT ; sinon reste OPEN
 17938:                 if not p:
 17939:                     st.state = STATE_FLAT
 17940:                     st.order_id = None
 17941:                     st.side = None
 17942:                     st.qty = 0.0
 17943:                     st.entry = 0.0
 17944:                 else:
 17945:                     st.state = STATE_OPEN  # pas encore clos
 17946:             else:
 17947:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
 17948:                 if p:
 17949:                     st.state = STATE_OPEN
 17950:                     st.qty = float(p.get("qty", 0.0))
 17951:                     st.entry = float(p.get("avgEntryPrice", 0.0))
 17952: 
 17953: --------------------------------------------------------------------------------
 17954: FILE: scalper/live/runner.py
 17955: --------------------------------------------------------------------------------
 17956: # scalper/live/runner.py
 17957: from __future__ import annotations
 17958: from typing import Dict, List, Optional
 17959: from scalper.signals.factory import resolve_signal_fn
 17960: 
 17961: class JobRunner:
 17962:     def __init__(self, strategies_cfg: dict, equity: float, risk_pct: float) -> None:
 17963:         self.cfg = strategies_cfg
 17964:         self.equity = float(equity)
 17965:         self.risk = float(risk_pct)
 17966: 
 17967:     def run_once(
 17968:         self, *, symbol: str, timeframe: str,
 17969:         ohlcv: Dict[str, List[float]],
 17970:         ohlcv_1h: Optional[Dict[str, List[float]]] = None
 17971:     ):
 17972:         fn = resolve_signal_fn(symbol, timeframe, self.cfg)
 17973:         return fn(
 17974:             symbol=symbol, timeframe=timeframe, ohlcv=ohlcv,
 17975:             equity=self.equity, risk_pct=self.risk, ohlcv_1h=ohlcv_1h
 17976:         )
 17977: 
 17978: --------------------------------------------------------------------------------
 17979: FILE: scalper/live/setup_wizard.py
 17980: --------------------------------------------------------------------------------
 17981: from __future__ import annotations
 17982: import asyncio, os
 17983: from dataclasses import dataclass
 17984: from typing import List, Dict, Optional, Callable
 17985: from ..signals.factory import load_signal
 17986: from ..backtest.runner import BacktestRunner
 17987: from .notify import Notifier, CommandStream
 17988: 
 17989: @dataclass
 17990: class SetupResult:
 17991:     strategy: str
 17992:     symbols: List[str]
 17993:     timeframes: List[str]
 17994:     risk_pct: float
 17995:     accepted: bool
 17996:     summary_path: str
 17997: 
 17998: class SetupWizard:
 17999:     """
 18000:     Wizard interactif Telegram avant lancement des trades.
 18001:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
 18002:     """
 18003:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
 18004:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
 18005:                  admin_chat_id: Optional[int]=None):
 18006:         self.notifier = notifier
 18007:         self.cmd_stream = cmd_stream
 18008:         self.loader = ohlcv_loader_sync
 18009:         self.out_dir = out_dir
 18010:         self.admin_chat_id = admin_chat_id
 18011: 
 18012:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
 18013:         await self.notifier.send_menu(prompt, choices)
 18014:         async for msg in self.cmd_stream:
 18015:             txt = msg.strip()
 18016:             if allow_multi and ("," in txt or " " in txt):
 18017:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
 18018:                 return sel
 18019:             if txt.isdigit():
 18020:                 i = int(txt)-1
 18021:                 if 0 <= i < len(choices):
 18022:                     return [choices[i]]
 18023:             if txt in choices:
 18024:                 return [txt]
 18025:             await self.notifier.send("Entrée invalide. Réessaie.")
 18026: 
 18027:     async def _ask_value(self, prompt: str, cast: Callable, default):
 18028:         await self.notifier.send(f"{prompt} (défaut: {default})")
 18029:         async for msg in self.cmd_stream:
 18030:             txt = msg.strip()
 18031:             if txt == "" or txt.lower() in ("d","defaut","default"):
 18032:                 return default
 18033:             try:
 18034:                 return cast(txt)
 18035:             except Exception:
 18036:                 await self.notifier.send("Entrée invalide. Réessaie.")
 18037: 
 18038:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
 18039:                   default_strategy: str="current") -> SetupResult:
 18040:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
 18041:         # 1) stratégie
 18042:         strategies = ["current","ema_cross","vwap_break"]
 18043:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
 18044: 
 18045:         # 2) symboles
 18046:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
 18047: 
 18048:         # 3) timeframes
 18049:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
 18050: 
 18051:         # 4) risk %
 18052:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
 18053: 
 18054:         # 5) période backtest
 18055:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
 18056:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
 18057: 
 18058:         # 6) run backtest
 18059:         from ..backtest.cli import parse_ts
 18060:         start_ms, end_ms = parse_ts(start), parse_ts(end)
 18061:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
 18062:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
 18063:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
 18064: 
 18065:         # 7) résumé
 18066:         sum_path = os.path.join(self.out_dir, "metrics.json")
 18067:         prop = res["proposal"]
 18068:         lines = ["**Proposition** :"]
 18069:         for sym, best in prop["per_symbol_best"].items():
 18070:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
 18071:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
 18072: 
 18073:         # 8) décision
 18074:         async for msg in self.cmd_stream:
 18075:             t = msg.strip().lower()
 18076:             if t in ("accepter","accept","ok","go","start"):
 18077:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
 18078:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
 18079:             if t in ("modifier","again","repeat"):
 18080:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
 18081:             if t in ("annuler","cancel","stop"):
 18082:                 await self.notifier.send("❌ Annulé.")
 18083:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)
 18084: 
 18085: --------------------------------------------------------------------------------
 18086: FILE: scalper/live/state_store.py
 18087: --------------------------------------------------------------------------------
 18088: # live/state_store.py
 18089: from __future__ import annotations
 18090: import json, os, time, asyncio
 18091: from typing import Callable, Dict, Any
 18092: 
 18093: class StateStore:
 18094:     """
 18095:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
 18096:     - save_state(snapshot: dict) -> écrit sur disque
 18097:     - load_state() -> dict
 18098:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
 18099:     """
 18100: 
 18101:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
 18102:         self.filepath = filepath
 18103:         self.period_s = period_s
 18104:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
 18105:         self._running = False
 18106: 
 18107:     # -------- I/O --------
 18108:     def save_state(self, snapshot: Dict[str, Any]) -> None:
 18109:         tmp = self.filepath + ".tmp"
 18110:         with open(tmp, "w", encoding="utf-8") as f:
 18111:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
 18112:         os.replace(tmp, self.filepath)
 18113: 
 18114:     def load_state(self) -> Dict[str, Any]:
 18115:         if not os.path.exists(self.filepath):
 18116:             return {}
 18117:         try:
 18118:             with open(self.filepath, "r", encoding="utf-8") as f:
 18119:                 return json.load(f)
 18120:         except Exception:
 18121:             return {}
 18122: 
 18123:     # -------- Autosave --------
 18124:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
 18125:         self._running = True
 18126:         while self._running:
 18127:             try:
 18128:                 snap = get_snapshot()
 18129:                 snap["saved_at"] = int(time.time() * 1000)
 18130:                 self.save_state(snap)
 18131:             except Exception:
 18132:                 pass
 18133:             await asyncio.sleep(self.period_s)
 18134: 
 18135:     def stop(self): self._running = False
 18136: 
 18137: --------------------------------------------------------------------------------
 18138: FILE: scalper/live/telegram_async.py
 18139: --------------------------------------------------------------------------------
 18140: from __future__ import annotations
 18141: import time
 18142: import requests
 18143: import asyncio
 18144: from typing import Optional, Dict, Any, List
 18145: 
 18146: 
 18147: class TelegramAsync:
 18148:     """
 18149:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
 18150:     Sans nouvelle dépendance.
 18151:     """
 18152:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
 18153:         self.token = token
 18154:         self.chat_id = chat_id
 18155:         self.base = f"https://api.telegram.org/bot{token}" if token else None
 18156:         self._offset = 0
 18157:         self._enabled = bool(token and chat_id)
 18158: 
 18159:     def enabled(self) -> bool:
 18160:         return self._enabled
 18161: 
 18162:     # ---------- sync I/O (appelées via to_thread) ----------
 18163:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
 18164:         if not self._enabled:
 18165:             return {"ok": False, "reason": "disabled"}
 18166:         url = f"{self.base}/sendMessage"
 18167:         payload = {"chat_id": self.chat_id, "text": text}
 18168:         try:
 18169:             r = requests.post(url, json=payload, timeout=10)
 18170:             return r.json()
 18171:         except Exception as e:
 18172:             return {"ok": False, "error": repr(e)}
 18173: 
 18174:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
 18175:         if not self._enabled:
 18176:             return {"ok": True, "result": []}
 18177:         url = f"{self.base}/getUpdates"
 18178:         params = {"timeout": timeout_s, "offset": self._offset}
 18179:         try:
 18180:             r = requests.get(url, params=params, timeout=timeout_s + 5)
 18181:             return r.json()
 18182:         except Exception as e:
 18183:             return {"ok": False, "error": repr(e), "result": []}
 18184: 
 18185:     # ---------- async wrappers ----------
 18186:     async def send_message(self, text: str) -> None:
 18187:         await asyncio.to_thread(self._send_message_sync, text)
 18188: 
 18189:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
 18190:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
 18191:         if not data.get("ok"):
 18192:             return []
 18193:         out = []
 18194:         for upd in data.get("result", []):
 18195:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
 18196:             msg = upd.get("message") or {}
 18197:             text = (msg.get("text") or "").strip()
 18198:             if not text:
 18199:                 continue
 18200:             out.append({
 18201:                 "date": msg.get("date"),
 18202:                 "chat": str((msg.get("chat") or {}).get("id")),
 18203:                 "text": text,
 18204:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
 18205:             })
 18206:         return out
 18207: 
 18208: 
 18209: --------------------------------------------------------------------------------
 18210: FILE: scalper/live/watchlist.py
 18211: --------------------------------------------------------------------------------
 18212: # -*- coding: utf-8 -*-
 18213: from __future__ import annotations
 18214: from dataclasses import dataclass
 18215: from typing import List
 18216: 
 18217: 
 18218: @dataclass
 18219: class WatchlistManager:
 18220:     symbols: List[str]
 18221: 
 18222:     @classmethod
 18223:     def from_env_or_default(cls) -> "WatchlistManager":
 18224:         # Tu peux lire une variable d'env ici si tu veux surcharger
 18225:         default = [
 18226:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
 18227:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
 18228:         ]
 18229:         return cls(default)
 18230: 
 18231: --------------------------------------------------------------------------------
 18232: FILE: scalper/logging_utils.py
 18233: --------------------------------------------------------------------------------
 18234: """Logging helpers for the Scalp bot."""
 18235: 
 18236: from __future__ import annotations
 18237: 
 18238: import atexit
 18239: import csv
 18240: import json
 18241: import os
 18242: import sqlite3
 18243: import time
 18244: from pathlib import Path
 18245: from typing import Any, Dict, List
 18246: 
 18247: 
 18248: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
 18249:     """Return a callable that logs events as JSON lines.
 18250: 
 18251:     Parameters
 18252:     ----------
 18253:     path: str
 18254:         Target file path for JSON lines.
 18255:     max_bytes: int, optional
 18256:         If >0, rotate the file when its size exceeds this value.
 18257:     backup_count: int, optional
 18258:         Number of rotated files to keep when ``max_bytes`` is set.
 18259:     """
 18260:     os.makedirs(os.path.dirname(path), exist_ok=True)
 18261:     log_file = open(path, "a", encoding="utf-8")
 18262: 
 18263:     def _close_file() -> None:
 18264:         try:
 18265:             log_file.close()
 18266:         except Exception:
 18267:             pass
 18268: 
 18269:     atexit.register(_close_file)
 18270: 
 18271:     def _rotate() -> None:
 18272:         nonlocal log_file
 18273:         log_file.close()
 18274:         for i in range(backup_count - 1, 0, -1):
 18275:             src = f"{path}.{i}"
 18276:             dst = f"{path}.{i + 1}"
 18277:             if os.path.exists(src):
 18278:                 os.replace(src, dst)
 18279:         os.replace(path, f"{path}.1")
 18280:         log_file = open(path, "a", encoding="utf-8")
 18281: 
 18282:     def _log(event: str, payload: Dict[str, Any]) -> None:
 18283:         nonlocal log_file
 18284:         payload = dict(payload or {})
 18285:         payload["event"] = event
 18286:         payload["ts"] = int(time.time() * 1000)
 18287:         line = json.dumps(payload, ensure_ascii=False)
 18288:         if max_bytes and backup_count > 0:
 18289:             if log_file.tell() + len(line) + 1 > max_bytes:
 18290:                 _rotate()
 18291:         log_file.write(line + "\n")
 18292:         log_file.flush()
 18293: 
 18294:     return _log
 18295: 
 18296: 
 18297: class TradeLogger:
 18298:     """Helper writing trade information to CSV and SQLite files."""
 18299: 
 18300:     fields = [
 18301:         "pair",
 18302:         "tf",
 18303:         "dir",
 18304:         "entry",
 18305:         "sl",
 18306:         "tp",
 18307:         "score",
 18308:         "reasons",
 18309:         "pnl",
 18310:     ]
 18311: 
 18312:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
 18313:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
 18314:         self.csv_path = csv_path
 18315:         self.sqlite_path = sqlite_path
 18316: 
 18317:         # Ensure CSV has header
 18318:         if not os.path.exists(csv_path):
 18319:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
 18320:                 writer = csv.DictWriter(f, fieldnames=self.fields)
 18321:                 writer.writeheader()
 18322: 
 18323:         # Setup SQLite store
 18324:         self.conn = sqlite3.connect(sqlite_path)
 18325:         cur = self.conn.cursor()
 18326:         cur.execute(
 18327:             """
 18328:             CREATE TABLE IF NOT EXISTS trades (
 18329:                 pair TEXT,
 18330:                 tf TEXT,
 18331:                 dir TEXT,
 18332:                 entry REAL,
 18333:                 sl REAL,
 18334:                 tp REAL,
 18335:                 score REAL,
 18336:                 reasons TEXT,
 18337:                 pnl REAL
 18338:             )
 18339:             """
 18340:         )
 18341:         self.conn.commit()
 18342:         atexit.register(self.conn.close)
 18343: 
 18344:     def log(self, data: Dict[str, Any]) -> None:
 18345:         row = {k: data.get(k) for k in self.fields}
 18346:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
 18347:             writer = csv.DictWriter(f, fieldnames=self.fields)
 18348:             writer.writerow(row)
 18349:         cur = self.conn.cursor()
 18350:         cur.execute(
 18351:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
 18352:             (
 18353:                 row["pair"],
 18354:                 row["tf"],
 18355:                 row["dir"],
 18356:                 row["entry"],
 18357:                 row["sl"],
 18358:                 row["tp"],
 18359:                 row["score"],
 18360:                 row["reasons"],
 18361:                 row["pnl"],
 18362:             ),
 18363:         )
 18364:         self.conn.commit()
 18365: 
 18366: 
 18367: BASE_DIR = Path(__file__).resolve().parents[2]
 18368: 
 18369: 
 18370: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
 18371:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
 18372:     path.parent.mkdir(parents=True, exist_ok=True)
 18373:     file_exists = path.exists()
 18374:     with path.open("a", newline="", encoding="utf-8") as f:
 18375:         writer = csv.DictWriter(f, fieldnames=fields)
 18376:         if not file_exists:
 18377:             writer.writeheader()
 18378:         writer.writerow({k: row.get(k) for k in fields})
 18379: 
 18380: 
 18381: def log_position(data: Dict[str, Any]) -> None:
 18382:     """Log a closed position to ``../positions.csv``."""
 18383:     fields = [
 18384:         "timestamp",
 18385:         "pair",
 18386:         "direction",
 18387:         "entry",
 18388:         "exit",
 18389:         "pnl_pct",
 18390:         "fee_rate",
 18391:         "notes",
 18392:     ]
 18393:     _append_csv(BASE_DIR / "positions.csv", fields, data)
 18394: 
 18395: 
 18396: def log_operation_memo(data: Dict[str, Any]) -> None:
 18397:     """Log operation details to ``../operations_memo.csv``."""
 18398:     fields = ["timestamp", "pair", "details"]
 18399:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)
 18400: 
 18401: 
 18402: --------------------------------------------------------------------------------
 18403: FILE: scalper/metrics.py
 18404: --------------------------------------------------------------------------------
 18405: """Utility metrics for trading calculations."""
 18406: 
 18407: from __future__ import annotations
 18408: 
 18409: 
 18410: from typing import Iterable
 18411: 
 18412: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
 18413: 
 18414: 
 18415: def calc_pnl_pct(
 18416:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
 18417: ) -> float:
 18418:     """Return percentage PnL between entry and exit prices minus fees.
 18419: 
 18420: 
 18421:     Parameters
 18422:     ----------
 18423:     entry_price: float
 18424:         Trade entry price (>0).
 18425:     exit_price: float
 18426:         Trade exit price (>0).
 18427:     side: int
 18428:         +1 for long, -1 for short.
 18429:     fee_rate: float, optional
 18430:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
 18431:         applied twice (entry + exit).
 18432:     """
 18433:     if entry_price <= 0 or exit_price <= 0:
 18434:         raise ValueError("Prices must be positive")
 18435:     if side not in (1, -1):
 18436:         raise ValueError("side must be +1 (long) or -1 (short)")
 18437: 
 18438:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
 18439:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
 18440:     return pnl - fee_pct
 18441: 
 18442: 
 18443: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
 18444:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
 18445: 
 18446: 
 18447:     Parameters
 18448:     ----------
 18449:     prices:
 18450:         Ordered sequence of closing prices.
 18451:     period:
 18452:         Number of periods to use for the calculation. Must be positive and the
 18453:         length of ``prices`` must be at least ``period + 1``.
 18454:     """
 18455: 
 18456:     prices_list = [float(p) for p in prices]
 18457: 
 18458:     if period <= 0:
 18459:         raise ValueError("period must be positive")
 18460:     if len(prices_list) < period + 1:
 18461: 
 18462:         raise ValueError("len(prices) must be >= period + 1")
 18463: 
 18464:     gains: list[float] = []
 18465:     losses: list[float] = []
 18466:     for i in range(1, period + 1):
 18467: 
 18468:         diff = prices_list[i] - prices_list[i - 1]
 18469: 
 18470:         if diff >= 0:
 18471:             gains.append(diff)
 18472:             losses.append(0.0)
 18473:         else:
 18474:             gains.append(0.0)
 18475:             losses.append(-diff)
 18476: 
 18477:     avg_gain = sum(gains) / period
 18478:     avg_loss = sum(losses) / period
 18479: 
 18480:     for i in range(period + 1, len(prices_list)):
 18481:         diff = prices_list[i] - prices_list[i - 1]
 18482: 
 18483:         gain = max(diff, 0.0)
 18484:         loss = max(-diff, 0.0)
 18485:         avg_gain = (avg_gain * (period - 1) + gain) / period
 18486:         avg_loss = (avg_loss * (period - 1) + loss) / period
 18487: 
 18488:     if avg_gain == 0 and avg_loss == 0:
 18489:         return 50.0
 18490:     if avg_loss == 0:
 18491:         return 100.0
 18492:     if avg_gain == 0:
 18493:         return 0.0
 18494:     rs = avg_gain / avg_loss
 18495:     return 100.0 - (100.0 / (1.0 + rs))
 18496: 
 18497: 
 18498: def calc_atr(
 18499:     highs: Iterable[float],
 18500:     lows: Iterable[float],
 18501:     closes: Iterable[float],
 18502:     period: int = 14,
 18503: ) -> float:
 18504:     """Compute the Average True Range (ATR) using Wilder's smoothing.
 18505: 
 18506: 
 18507:     Parameters
 18508:     ----------
 18509:     highs, lows, closes:
 18510:         Ordered sequences of high, low and close prices. All sequences must
 18511:         have the same length and contain at least ``period + 1`` elements.
 18512:     period:
 18513:         Number of periods to use for the calculation. Must be positive.
 18514:     """
 18515: 
 18516:     highs_list = [float(h) for h in highs]
 18517:     lows_list = [float(low) for low in lows]
 18518:     closes_list = [float(c) for c in closes]
 18519: 
 18520:     length = len(highs_list)
 18521:     if length != len(lows_list) or length != len(closes_list):
 18522: 
 18523:         raise ValueError("Input sequences must have the same length")
 18524:     if period <= 0:
 18525:         raise ValueError("period must be positive")
 18526:     if length < period + 1:
 18527:         raise ValueError("Input sequences must have at least period + 1 elements")
 18528: 
 18529:     trs: list[float] = []
 18530:     for i in range(1, len(highs_list)):
 18531:         tr = max(
 18532:             highs_list[i] - lows_list[i],
 18533:             abs(highs_list[i] - closes_list[i - 1]),
 18534:             abs(lows_list[i] - closes_list[i - 1]),
 18535:         )
 18536:         trs.append(tr)
 18537: 
 18538:     atr = sum(trs[:period]) / period
 18539:     for tr in trs[period:]:
 18540:         atr = (atr * (period - 1) + tr) / period
 18541:     return atr
 18542: 
 18543: 
 18544: def calc_macd(
 18545:     prices: Sequence[float],
 18546:     fast: int = 12,
 18547:     slow: int = 26,
 18548:     signal: int = 9,
 18549: ) -> tuple[float, float, float]:
 18550:     """Return MACD, signal line and histogram values.
 18551: 
 18552:     The implementation computes exponential moving averages using Wilder's
 18553:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
 18554:     """
 18555: 
 18556:     prices_list = [float(p) for p in prices]
 18557:     if fast <= 0 or slow <= 0 or signal <= 0:
 18558:         raise ValueError("periods must be positive")
 18559:     min_len = max(fast, slow) + signal
 18560:     if len(prices_list) < min_len:
 18561:         raise ValueError("len(prices) must be >= slow + signal")
 18562: 
 18563:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
 18564:         k = 2.0 / (window + 1.0)
 18565:         out = [float(series[0])]
 18566:         for x in series[1:]:
 18567:             out.append(float(x) * k + out[-1] * (1.0 - k))
 18568:         return out
 18569: 
 18570:     fast_ema = _ema_series(prices_list, fast)
 18571:     slow_ema = _ema_series(prices_list, slow)
 18572:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
 18573:     signal_series = _ema_series(macd_series, signal)
 18574:     macd_val = macd_series[-1]
 18575:     signal_val = signal_series[-1]
 18576:     hist = macd_val - signal_val
 18577:     return macd_val, signal_val, hist
 18578: 
 18579: 
 18580: def backtest_position(
 18581:     prices: list[float], entry_idx: int, exit_idx: int, side: int
 18582: ) -> bool:
 18583:     """Run a basic backtest to verify a position's coherence.
 18584: 
 18585:     Parameters
 18586:     ----------
 18587:     prices: list[float]
 18588:         Sequential list of prices to evaluate.
 18589:     entry_idx: int
 18590:         Index in ``prices`` where the position is opened.
 18591:     exit_idx: int
 18592:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
 18593:     side: int
 18594:         +1 for long, -1 for short.
 18595: 
 18596:     Returns
 18597:     -------
 18598:     bool
 18599:         ``True`` if the resulting PnL is non-negative, meaning the position is
 18600:         coherent with the direction of price movement. ``False`` otherwise.
 18601:     """
 18602:     if side not in (1, -1):
 18603:         raise ValueError("side must be +1 (long) or -1 (short)")
 18604:     if not (0 <= entry_idx < exit_idx < len(prices)):
 18605:         raise ValueError(
 18606:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
 18607:         )
 18608: 
 18609:     entry_price = float(prices[entry_idx])
 18610:     exit_price = float(prices[exit_idx])
 18611:     pnl = calc_pnl_pct(entry_price, exit_price, side)
 18612:     return pnl >= 0.0
 18613: 
 18614: 
 18615: --------------------------------------------------------------------------------
 18616: FILE: scalper/pairs.py
 18617: --------------------------------------------------------------------------------
 18618: """Utilities to select trading pairs and detect signals."""
 18619: from __future__ import annotations
 18620: from typing import Any, Dict, List, Optional, Callable
 18621: from scalper.strategy import Signal
 18622: 
 18623: from scalper.bot_config import CONFIG
 18624: from scalper.strategy import ema as default_ema, cross as default_cross
 18625: from scalper.notifier import notify
 18626: 
 18627: 
 18628: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
 18629:     """Return all trading pairs using the client's ``get_ticker`` method."""
 18630:     tick = client.get_ticker()
 18631:     data = tick.get("data") if isinstance(tick, dict) else []
 18632:     if not data:
 18633:         return []
 18634:     return data if isinstance(data, list) else [data]
 18635: 
 18636: 
 18637: def filter_trade_pairs(
 18638:     client: Any,
 18639:     *,
 18640:     volume_min: float = 5_000_000,
 18641:     max_spread_bps: float = 5.0,
 18642:     top_n: int = 40,
 18643: ) -> List[Dict[str, Any]]:
 18644:     """Filter pairs by volume and spread."""
 18645:     pairs = get_trade_pairs(client)
 18646:     eligible: List[Dict[str, Any]] = []
 18647: 
 18648:     for info in pairs:
 18649:         sym = info.get("symbol")
 18650:         if not sym:
 18651:             continue
 18652:         try:
 18653:             vol = float(info.get("volume", 0))
 18654:         except (TypeError, ValueError):
 18655:             continue
 18656:         if vol < volume_min:
 18657:             continue
 18658:         try:
 18659:             bid = float(info.get("bidPrice", 0))
 18660:             ask = float(info.get("askPrice", 0))
 18661:         except (TypeError, ValueError):
 18662:             continue
 18663:         if bid <= 0 or ask <= 0:
 18664:             continue
 18665:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
 18666:         if spread_bps >= max_spread_bps:
 18667:             continue
 18668:         eligible.append(info)
 18669: 
 18670:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
 18671:     return eligible[:top_n]
 18672: 
 18673: 
 18674: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
 18675:     """Return ``top_n`` pairs sorted by ``key``."""
 18676:     pairs = get_trade_pairs(client)
 18677: 
 18678:     def volume(row: Dict[str, Any]) -> float:
 18679:         try:
 18680:             return float(row.get(key, 0))
 18681:         except (TypeError, ValueError):
 18682:             return 0.0
 18683: 
 18684:     pairs.sort(key=volume, reverse=True)
 18685:     return pairs[:top_n]
 18686: 
 18687: 
 18688: def _ancienne_impl(
 18689:     client: Any,
 18690:     pairs: List[Dict[str, Any]],
 18691:     *,
 18692:     interval: str = "1m",
 18693:     ema_fast_n: Optional[int] = None,
 18694:     ema_slow_n: Optional[int] = None,
 18695:     ema_func=default_ema,
 18696:     cross_func=default_cross,
 18697: ) -> List[Dict[str, Any]]:
 18698:     """Original implementation returning dicts."""
 18699:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
 18700:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
 18701:     results: List[Dict[str, Any]] = []
 18702: 
 18703:     for info in pairs:
 18704:         symbol = info.get("symbol")
 18705:         if not symbol:
 18706:             continue
 18707:         k = client.get_kline(symbol, interval=interval)
 18708:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
 18709:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
 18710:             continue
 18711:         efull = ema_func(closes, ema_fast_n)
 18712:         eslow = ema_func(closes, ema_slow_n)
 18713:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
 18714:         if signal == 1:
 18715:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
 18716:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
 18717:         elif signal == -1:
 18718:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
 18719:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
 18720:     return results
 18721: 
 18722: 
 18723: def _to_signal(d: dict) -> Signal:
 18724:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
 18725:     return Signal(
 18726:         symbol=d.get("symbol"),
 18727:         side=side,
 18728:         entry=float(d.get("price", d.get("entry", 0))),
 18729:         sl=float(d.get("sl", 0)),
 18730:         tp1=float(d.get("tp1", 0)) or None,
 18731:         tp2=float(d.get("tp2", 0)) or None,
 18732:         score=d.get("score"),
 18733:         quality=d.get("quality"),
 18734:         reasons=d.get("reasons", []),
 18735:     )
 18736: 
 18737: 
 18738: def find_trade_positions(
 18739:     client: Any,
 18740:     pairs: List[Dict[str, Any]],
 18741:     *,
 18742:     interval: str = "1m",
 18743:     ema_fast_n: Optional[int] = None,
 18744:     ema_slow_n: Optional[int] = None,
 18745:     ema_func=default_ema,
 18746:     cross_func=default_cross,
 18747: ) -> List[Signal]:
 18748:     raw = _ancienne_impl(
 18749:         client,
 18750:         pairs,
 18751:         interval=interval,
 18752:         ema_fast_n=ema_fast_n,
 18753:         ema_slow_n=ema_slow_n,
 18754:         ema_func=ema_func,
 18755:         cross_func=cross_func,
 18756:     )
 18757:     return [_to_signal(x) for x in raw]
 18758: 
 18759: 
 18760: def send_selected_pairs(
 18761:     client: Any,
 18762:     top_n: int = 40,
 18763:     *,
 18764:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
 18765:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
 18766: ) -> Dict[str, str]:
 18767:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
 18768: 
 18769:     Returns the payload sent to ``notify_fn``. The mapping contains the
 18770:     comma-separated symbols for each color group (``green``, ``orange`` and
 18771:     ``red``) or an empty dictionary when no pairs are available.
 18772:     """
 18773: 
 18774:     def split_symbol(sym: str) -> tuple[str, str]:
 18775:         if "_" in sym:
 18776:             left, right = sym.split("_", 1)
 18777:             # Legacy style: BTC_USDT
 18778:             if len(right) <= 4:
 18779:                 return left, right
 18780:             # Bitget futures style: BTCUSDT_UMCBL
 18781:             main = left
 18782:             if main.endswith("USDT"):
 18783:                 return main[:-4], "USDT"
 18784:             if main.endswith("USDC"):
 18785:                 return main[:-4], "USDC"
 18786:             if main.endswith("USD"):
 18787:                 return main[:-3], "USD"
 18788:             return main, ""
 18789:         if sym.endswith("USDT"):
 18790:             return sym[:-4], "USDT"
 18791:         if sym.endswith("USDC"):
 18792:             return sym[:-4], "USDC"
 18793:         if sym.endswith("USD"):
 18794:             return sym[:-3], "USD"
 18795:         return sym, ""
 18796: 
 18797:     pairs = select_fn(client, top_n=top_n * 3)
 18798:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
 18799:     by_base: Dict[str, Dict[str, Any]] = {}
 18800:     for info in pairs:
 18801:         sym = info.get("symbol")
 18802:         if not sym:
 18803:             continue
 18804:         norm_sym = sym.split("_")[0].upper()
 18805:         if allowed and norm_sym not in allowed:
 18806:             continue
 18807:         base, quote = split_symbol(sym)
 18808:         existing = by_base.get(base)
 18809:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
 18810:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
 18811:             by_base[base] = {"data": info, "quote": quote}
 18812: 
 18813:     unique = sorted(
 18814:         (v["data"] for v in by_base.values()),
 18815:         key=lambda row: float(row.get("volume", 0)),
 18816:         reverse=True,
 18817:     )
 18818:     symbols: list[str] = []
 18819:     for row in unique[:top_n]:
 18820:         sym = row.get("symbol")
 18821:         if not sym:
 18822:             continue
 18823:         base, _ = split_symbol(sym)
 18824:         symbols.append(base)
 18825:     if symbols:
 18826:         n = len(symbols)
 18827:         third = max(n // 3, 1)
 18828:         green = symbols[:third]
 18829:         orange = symbols[third : 2 * third]
 18830:         red = symbols[2 * third :]
 18831:         payload: Dict[str, str] = {}
 18832:         if green:
 18833:             payload["green"] = ", ".join(green)
 18834:         if orange:
 18835:             payload["orange"] = ", ".join(orange)
 18836:         if red:
 18837:             payload["red"] = ", ".join(red)
 18838:         notify_fn("pair_list", payload)
 18839:         return payload
 18840:     return {}
 18841: 
 18842: 
 18843: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
 18844:     """Return a heat score combining volatility, volume and a news flag."""
 18845:     mult = 2.0 if news else 1.0
 18846:     return volatility * volume * mult
 18847: 
 18848: 
 18849: def select_top_heat_pairs(
 18850:     pairs: List[Dict[str, Any]], *, top_n: int = 3
 18851: ) -> List[Dict[str, Any]]:
 18852:     """Return ``top_n`` pairs ranked by ``heat_score``."""
 18853: 
 18854:     scored: List[Dict[str, Any]] = []
 18855:     for info in pairs:
 18856:         try:
 18857:             vol = float(info.get("volatility", 0))
 18858:             volume = float(info.get("volume", 0))
 18859:         except (TypeError, ValueError):
 18860:             continue
 18861:         score = heat_score(vol, volume, bool(info.get("news")))
 18862:         row = dict(info)
 18863:         row["heat_score"] = score
 18864:         scored.append(row)
 18865: 
 18866:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
 18867:     return scored[:top_n]
 18868: 
 18869: 
 18870: def decorrelate_pairs(
 18871:     pairs: List[Dict[str, Any]],
 18872:     corr: Dict[str, Dict[str, float]],
 18873:     *,
 18874:     threshold: float = 0.8,
 18875:     top_n: int = 3,
 18876: ) -> List[Dict[str, Any]]:
 18877:     """Return top pairs while avoiding highly correlated symbols.
 18878: 
 18879:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
 18880:     pairs are considered too correlated when the absolute value of the
 18881:     correlation exceeds ``threshold``.
 18882:     """
 18883: 
 18884:     selected: List[Dict[str, Any]] = []
 18885:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
 18886:         sym = info.get("symbol")
 18887:         if not sym:
 18888:             continue
 18889:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
 18890:             selected.append(info)
 18891:         if len(selected) >= top_n:
 18892:             break
 18893:     return selected
 18894: 
 18895: 
 18896: --------------------------------------------------------------------------------
 18897: FILE: scalper/positions/__init__.py
 18898: --------------------------------------------------------------------------------
 18899: 
 18900: 
 18901: --------------------------------------------------------------------------------
 18902: FILE: scalper/positions/state.py
 18903: --------------------------------------------------------------------------------
 18904: from __future__ import annotations
 18905: from dataclasses import dataclass, field
 18906: from enum import Enum, auto
 18907: from typing import List, Optional
 18908: import time
 18909: 
 18910: class PositionStatus(Enum):
 18911:     IDLE = auto()
 18912:     PENDING_ENTRY = auto()
 18913:     OPEN = auto()
 18914:     PENDING_EXIT = auto()
 18915:     CLOSED = auto()
 18916: 
 18917: class PositionSide(Enum):
 18918:     LONG = 1
 18919:     SHORT = -1
 18920: 
 18921: @dataclass
 18922: class Fill:
 18923:     order_id: str
 18924:     trade_id: str
 18925:     price: float
 18926:     qty: float
 18927:     fee: float
 18928:     ts: int
 18929: 
 18930: @dataclass
 18931: class PositionState:
 18932:     symbol: str
 18933:     side: PositionSide
 18934:     status: PositionStatus = PositionStatus.IDLE
 18935:     entry_order_id: Optional[str] = None
 18936:     exit_order_id: Optional[str] = None
 18937:     req_qty: float = 0.0
 18938:     filled_qty: float = 0.0
 18939:     avg_entry_price: float = 0.0
 18940:     avg_exit_price: float = 0.0
 18941:     sl: Optional[float] = None
 18942:     tp: Optional[float] = None
 18943:     realized_pnl: float = 0.0
 18944:     fees: float = 0.0
 18945:     opened_ts: Optional[int] = None
 18946:     closed_ts: Optional[int] = None
 18947:     fills: List[Fill] = field(default_factory=list)
 18948:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
 18949: 
 18950:     def apply_fill_entry(self, f: Fill) -> None:
 18951:         self.fills.append(f)
 18952:         self.filled_qty += f.qty
 18953:         # moyenne pondérée
 18954:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
 18955:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
 18956:         self.fees += abs(f.fee)
 18957:         if self.opened_ts is None:
 18958:             self.opened_ts = f.ts
 18959:         if self.filled_qty > 1e-12:
 18960:             self.status = PositionStatus.OPEN
 18961: 
 18962:     def apply_fill_exit(self, f: Fill) -> None:
 18963:         self.fills.append(f)
 18964:         qty = min(self.filled_qty, f.qty)
 18965:         # realized pnl sur la quantité fermée
 18966:         if self.side == PositionSide.LONG:
 18967:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
 18968:         else:
 18969:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
 18970:         self.fees += abs(f.fee)
 18971:         self.filled_qty = max(0.0, self.filled_qty - qty)
 18972:         # moyenne de sortie indicative
 18973:         closed_q = (self.req_qty - self.filled_qty)
 18974:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
 18975:         if self.filled_qty <= 1e-12:
 18976:             self.status = PositionStatus.CLOSED
 18977:             self.closed_ts = f.ts
 18978: 
 18979: 
 18980: 
 18981: --------------------------------------------------------------------------------
 18982: FILE: scalper/risk/__init__.py
 18983: --------------------------------------------------------------------------------
 18984: # scalp/risk/__init__.py
 18985: from .manager import (
 18986:     Caps,
 18987:     compute_size,
 18988:     calc_position_size,  # alias legacy
 18989:     RiskManager,         # shim legacy
 18990: )
 18991: 
 18992: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]
 18993: 
 18994: --------------------------------------------------------------------------------
 18995: FILE: scalper/risk/manager.py
 18996: --------------------------------------------------------------------------------
 18997: # scalp/risk/manager.py
 18998: from __future__ import annotations
 18999: from dataclasses import dataclass
 19000: from typing import Optional, Dict, Any
 19001: 
 19002: @dataclass
 19003: class Caps:
 19004:     min_qty: float = 0.0
 19005:     min_notional: float = 0.0
 19006:     max_leverage: float = 20.0
 19007: 
 19008: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
 19009:     if not caps_by_symbol:
 19010:         return Caps()
 19011:     c = caps_by_symbol.get(symbol, {})
 19012:     return Caps(
 19013:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
 19014:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
 19015:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
 19016:     )
 19017: 
 19018: def compute_size(
 19019:     *,
 19020:     symbol: str,
 19021:     price: float,
 19022:     balance_cash: float,
 19023:     risk_pct: float = 0.5,
 19024:     caps_by_symbol: Optional[Dict[str, Any]] = None,
 19025: ) -> float:
 19026:     """Sizing robuste avec gardes min_notional / min_qty."""
 19027:     price = max(1e-9, float(price))
 19028:     balance_cash = max(0.0, float(balance_cash))
 19029:     risk_pct = max(0.0, float(risk_pct))
 19030: 
 19031:     notionnel = balance_cash * risk_pct
 19032:     qty = notionnel / price
 19033: 
 19034:     caps = _get_caps(caps_by_symbol, symbol)
 19035:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
 19036:         qty = caps.min_notional / price
 19037:     if caps.min_qty > 0 and qty < caps.min_qty:
 19038:         qty = caps.min_qty
 19039:     return max(0.0, qty)
 19040: 
 19041: # --- Shims pour compatibilité ancienne API -----------------------------------
 19042: 
 19043: def calc_position_size(symbol: str, price: float, balance_cash: float,
 19044:                        risk_pct: float = 0.5,
 19045:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
 19046:     """Alias legacy → compute_size."""
 19047:     return compute_size(
 19048:         symbol=symbol, price=price, balance_cash=balance_cash,
 19049:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
 19050:     )
 19051: 
 19052: class RiskManager:
 19053:     """
 19054:     Shim minimal compatible avec l'ancien code:
 19055:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
 19056:       qty = rm.size(symbol, price, balance_cash)
 19057:     """
 19058:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
 19059:         self.risk_pct = float(risk_pct)
 19060:         self.caps_by_symbol = caps_by_symbol or {}
 19061: 
 19062:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
 19063:         return compute_size(
 19064:             symbol=symbol, price=price, balance_cash=balance_cash,
 19065:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
 19066:         )
 19067: 
 19068: --------------------------------------------------------------------------------
 19069: FILE: scalper/selection/__init__.py
 19070: --------------------------------------------------------------------------------
 19071: """Pair selection helpers for the Scalp bot.
 19072: 
 19073: This package exposes two utilities used during the preparation phase of the
 19074: trading strategy:
 19075: 
 19076: ``scan_pairs``
 19077:     Performs the first level market scan by filtering pairs based on volume,
 19078:     spread and hourly volatility.
 19079: 
 19080: ``select_active_pairs``
 19081:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
 19082:     crossover and a sufficiently high ATR.
 19083: """
 19084: 
 19085: from .scanner import scan_pairs
 19086: from .momentum import select_active_pairs
 19087: 
 19088: __all__ = ["scan_pairs", "select_active_pairs"]
 19089: 
 19090: 
 19091: 
 19092: --------------------------------------------------------------------------------
 19093: FILE: scalper/selection/momentum.py
 19094: --------------------------------------------------------------------------------
 19095: """Utilities to select pairs exhibiting strong momentum."""
 19096: 
 19097: from __future__ import annotations
 19098: 
 19099: from typing import Any, Dict, List, Sequence
 19100: 
 19101: from ..metrics import calc_atr
 19102: 
 19103: 
 19104: def ema(series: Sequence[float], window: int) -> List[float]:
 19105:     """Simple exponential moving average implementation."""
 19106: 
 19107:     if window <= 1 or not series:
 19108:         return list(series)
 19109:     k = 2.0 / (window + 1.0)
 19110:     out: List[float] = [float(series[0])]
 19111:     prev = out[0]
 19112:     for x in series[1:]:
 19113:         prev = float(x) * k + prev * (1.0 - k)
 19114:         out.append(prev)
 19115:     return out
 19116: 
 19117: 
 19118: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
 19119:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
 19120: 
 19121:     if prev_fast <= prev_slow and last_fast > last_slow:
 19122:         return 1
 19123:     if prev_fast >= prev_slow and last_fast < last_slow:
 19124:         return -1
 19125:     return 0
 19126: 
 19127: 
 19128: def _quantile(values: Sequence[float], q: float) -> float:
 19129:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
 19130: 
 19131:     if not values:
 19132:         return 0.0
 19133:     q = min(max(q, 0.0), 1.0)
 19134:     vals = sorted(values)
 19135:     idx = int((len(vals) - 1) * q)
 19136:     return vals[idx]
 19137: 
 19138: 
 19139: def select_active_pairs(
 19140:     client: Any,
 19141:     pairs: Sequence[Dict[str, Any]],
 19142:     *,
 19143:     interval: str = "Min5",
 19144:     ema_fast: int = 20,
 19145:     ema_slow: int = 50,
 19146:     atr_period: int = 14,
 19147:     atr_quantile: float = 0.5,
 19148:     top_n: int = 5,
 19149: ) -> List[Dict[str, Any]]:
 19150:     """Return pairs with an EMA crossover and high ATR.
 19151: 
 19152:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
 19153:     Among those candidates, the Average True Range is computed and only pairs
 19154:     whose ATR is above the provided quantile are returned.  The resulting
 19155:     dictionaries include an ``atr`` key for convenience.
 19156:     """
 19157: 
 19158:     candidates: List[Dict[str, Any]] = []
 19159:     atrs: List[float] = []
 19160: 
 19161:     for info in pairs:
 19162:         sym = info.get("symbol")
 19163:         if not sym:
 19164:             continue
 19165:         k = client.get_kline(sym, interval=interval)
 19166:         kdata = k.get("data") if isinstance(k, dict) else {}
 19167:         closes = kdata.get("close", [])
 19168:         highs = kdata.get("high", [])
 19169:         lows = kdata.get("low", [])
 19170:         if len(closes) < max(ema_slow, atr_period) + 2:
 19171:             continue
 19172:         efast = ema(closes, ema_fast)
 19173:         eslow = ema(closes, ema_slow)
 19174:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
 19175:             continue
 19176:         atr_val = calc_atr(highs, lows, closes, atr_period)
 19177:         row = dict(info)
 19178:         row["atr"] = atr_val
 19179:         candidates.append(row)
 19180:         atrs.append(atr_val)
 19181: 
 19182:     if not candidates:
 19183:         return []
 19184: 
 19185:     threshold = _quantile(atrs, atr_quantile)
 19186:     selected = [row for row in candidates if row["atr"] >= threshold]
 19187:     selected.sort(key=lambda r: r["atr"], reverse=True)
 19188:     return selected[:top_n]
 19189: 
 19190: 
 19191: __all__ = ["select_active_pairs"]
 19192: 
 19193: 
 19194: 
 19195: --------------------------------------------------------------------------------
 19196: FILE: scalper/selection/scanner.py
 19197: --------------------------------------------------------------------------------
 19198: """Utilities for scanning tradable pairs on the exchange."""
 19199: 
 19200: from __future__ import annotations
 19201: 
 19202: from typing import Any, Dict, List
 19203: 
 19204: 
 19205: def scan_pairs(
 19206:     client: Any,
 19207:     *,
 19208:     volume_min: float = 5_000_000,
 19209:     max_spread_bps: float = 5.0,
 19210:     min_hourly_vol: float = 0.0,
 19211:     top_n: int = 40,
 19212: ) -> List[Dict[str, Any]]:
 19213:     """Return pairs satisfying basic liquidity and volatility filters.
 19214: 
 19215:     Parameters
 19216:     ----------
 19217:     client: Any
 19218:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
 19219:     volume_min: float, optional
 19220:         Minimum 24h volume required to keep a pair.
 19221:     max_spread_bps: float, optional
 19222:         Maximum allowed bid/ask spread expressed in basis points.
 19223:     min_hourly_vol: float, optional
 19224:         Minimum volatility over the last hour expressed as ``(high - low) /
 19225:         close``.  When set to ``0`` the filter is disabled.
 19226:     top_n: int, optional
 19227:         Limit the number of returned pairs.
 19228:     """
 19229: 
 19230:     tick = client.get_ticker()
 19231:     data = tick.get("data") if isinstance(tick, dict) else []
 19232:     if not isinstance(data, list):
 19233:         data = [data]
 19234: 
 19235:     eligible: List[Dict[str, Any]] = []
 19236: 
 19237:     for row in data:
 19238:         sym = row.get("symbol")
 19239:         if not sym:
 19240:             continue
 19241:         try:
 19242:             vol = float(row.get("volume", 0))
 19243:             bid = float(row.get("bidPrice", 0))
 19244:             ask = float(row.get("askPrice", 0))
 19245:         except (TypeError, ValueError):
 19246:             continue
 19247:         if vol < volume_min or bid <= 0 or ask <= 0:
 19248:             continue
 19249:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
 19250:         if spread_bps >= max_spread_bps:
 19251:             continue
 19252: 
 19253:         if min_hourly_vol > 0:
 19254:             k = client.get_kline(sym, interval="Min60")
 19255:             kdata = k.get("data") if isinstance(k, dict) else {}
 19256:             highs = kdata.get("high", [])
 19257:             lows = kdata.get("low", [])
 19258:             closes = kdata.get("close", [])
 19259:             if not highs or not lows or not closes:
 19260:                 continue
 19261:             try:
 19262:                 h = float(highs[-1])
 19263:                 l = float(lows[-1])
 19264:                 c = float(closes[-1])
 19265:             except (TypeError, ValueError):
 19266:                 continue
 19267:             hourly_vol = (h - l) / c if c else 0.0
 19268:             if hourly_vol < min_hourly_vol:
 19269:                 continue
 19270: 
 19271:         eligible.append(row)
 19272: 
 19273:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
 19274:     return eligible[:top_n]
 19275: 
 19276: 
 19277: __all__ = ["scan_pairs"]
 19278: 
 19279: 
 19280: 
 19281: --------------------------------------------------------------------------------
 19282: FILE: scalper/selfcheck.py
 19283: --------------------------------------------------------------------------------
 19284: # scalper/selfcheck.py
 19285: from __future__ import annotations
 19286: import os, sys, importlib, traceback
 19287: from pathlib import Path
 19288: 
 19289: NOTEBOOKS = Path("/notebooks")
 19290: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
 19291: 
 19292: def _mask(val: str) -> str:
 19293:     if not val: return ""
 19294:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
 19295: 
 19296: def _try_import(modname: str):
 19297:     try:
 19298:         m = importlib.import_module(modname)
 19299:         return True, m
 19300:     except Exception:
 19301:         return False, traceback.format_exc()
 19302: 
 19303: def preflight(verbose: bool = False) -> list[str]:
 19304:     """
 19305:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
 19306:     Ne lève pas d'exception. N'écrit que de l'info lisible.
 19307:     """
 19308:     issues: list[str] = []
 19309:     # s'assurer que le repo est bien dans sys.path
 19310:     if str(REPO) not in sys.path:
 19311:         sys.path.insert(0, str(REPO))
 19312: 
 19313:     print("=== SCALPER PREFLIGHT ===")
 19314:     print(f"[i] Repo: {REPO}")
 19315:     print(f"[i] Python: {sys.version.split()[0]}")
 19316: 
 19317:     # backtest API
 19318:     ok, mod = _try_import("scalper.backtest")
 19319:     if not ok:
 19320:         print("[✗] Import scalper.backtest KO")
 19321:         if verbose: print(mod)  # ici 'mod' contient la trace
 19322:         issues.append("backtest import")
 19323:     else:
 19324:         has_single = hasattr(mod, "run_single")
 19325:         has_multi  = hasattr(mod, "run_multi")
 19326:         print(f"[✓] scalper.backtest: run_single={has_single} run_multi={has_multi}")
 19327:         if not (has_single and has_multi):
 19328:             issues.append("backtest API incomplète")
 19329: 
 19330:     # trade_utils
 19331:     ok, mod = _try_import("scalper.trade_utils")
 19332:     if not ok:
 19333:         print("[✗] Import scalper.trade_utils KO")
 19334:         if verbose: print(mod)
 19335:         issues.append("trade_utils import")
 19336:     else:
 19337:         print(f"[✓] scalper.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
 19338: 
 19339:     # fees
 19340:     ok, mod = _try_import("scalper.exchange.fees")
 19341:     if not ok:
 19342:         print("[✗] Import scalper.exchange.fees KO")
 19343:         if verbose: print(mod)
 19344:         issues.append("fees import")
 19345:     else:
 19346:         need = {"get_fee", "load_bitget_fees"}
 19347:         miss = [n for n in need if not hasattr(mod, n)]
 19348:         if miss: issues.append("fees API manquante: " + ",".join(miss))
 19349:         print("[✓] scalper.exchange.fees OK")
 19350: 
 19351:     # notify/commands/backtest_telegram/orchestrator
 19352:     for name, required in [
 19353:         ("scalper.live.notify", ("build_notifier_and_stream",)),
 19354:         ("scalper.live.commands", ("CommandHandler",)),
 19355:         ("scalper.live.backtest_telegram", ("handle_backtest_command",)),
 19356:         ("scalper.live.orchestrator", ("run_orchestrator", "Orchestrator")),
 19357:     ]:
 19358:         ok, mod = _try_import(name)
 19359:         if not ok:
 19360:             print(f"[✗] Import {name} KO")
 19361:             if verbose: print(mod)
 19362:             issues.append(f"{name} import")
 19363:         else:
 19364:             miss = [a for a in required if not hasattr(mod, a)]
 19365:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
 19366:             print(f"[✓] {name} OK")
 19367: 
 19368:     # ENV (masqué)
 19369:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
 19370:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
 19371:     gu   = os.getenv("GIT_USER", "")
 19372:     gt   = os.getenv("GIT_TOKEN", "")
 19373:     print("\n-- ENV --")
 19374:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
 19375:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
 19376:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
 19377:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
 19378: 
 19379:     # Data
 19380:     data_dir = (REPO / "data")
 19381:     print("\n-- DATA --")
 19382:     if data_dir.exists():
 19383:         csvs = list(data_dir.glob("*.csv"))
 19384:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
 19385:     else:
 19386:         print("  data/ absent (OK si loader API)")
 19387: 
 19388:     return issues
 19389: 
 19390: def preflight_or_die(verbose: bool = False) -> None:
 19391:     issues = preflight(verbose=verbose)
 19392:     if issues:
 19393:         print("\n[✗] Préflight a détecté des problèmes :")
 19394:         for it in issues: print("   -", it)
 19395:         print("\nConseils :")
 19396:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
 19397:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
 19398:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
 19399:         raise SystemExit(1)
 19400:     print("\n[✓] Préflight OK — démarrage du bot.")
 19401: 
 19402: --------------------------------------------------------------------------------
 19403: FILE: scalper/services/__init__.py
 19404: --------------------------------------------------------------------------------
 19405: 
 19406: 
 19407: --------------------------------------------------------------------------------
 19408: FILE: scalper/services/data_cache.py
 19409: --------------------------------------------------------------------------------
 19410: # scalper/services/data_cache.py
 19411: from __future__ import annotations
 19412: 
 19413: import asyncio
 19414: import csv
 19415: import os
 19416: import time
 19417: from typing import Iterable, List, Optional, Tuple, Dict
 19418: 
 19419: # ---------------------------------------------------------------------
 19420: # Réglages via env (valeurs sûres par défaut)
 19421: # ---------------------------------------------------------------------
 19422: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
 19423: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
 19424: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
 19425: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
 19426: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
 19427: 
 19428: os.makedirs(DATA_DIR, exist_ok=True)
 19429: 
 19430: 
 19431: # ---------------------------------------------------------------------
 19432: # Helpers
 19433: # ---------------------------------------------------------------------
 19434: def parse_timeframe_to_seconds(tf: str) -> int:
 19435:     tf = tf.strip().lower()
 19436:     unit = tf[-1]
 19437:     try:
 19438:         n = int(tf[:-1])
 19439:     except Exception as e:
 19440:         raise ValueError(f"timeframe invalide: {tf}") from e
 19441:     if unit == "m":
 19442:         return n * 60
 19443:     if unit == "h":
 19444:         return n * 3600
 19445:     if unit == "d":
 19446:         return n * 86400
 19447:     raise ValueError(f"timeframe invalide: {tf}")
 19448: 
 19449: 
 19450: def csv_path(symbol: str, timeframe: str) -> str:
 19451:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
 19452: 
 19453: 
 19454: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
 19455:     rows: List[Tuple[int, float, float, float, float, float]] = []
 19456:     if not os.path.exists(path):
 19457:         return rows
 19458:     with open(path, "r", newline="") as f:
 19459:         r = csv.reader(f)
 19460:         header = next(r, None)  # accepte avec ou sans header
 19461:         for line in r:
 19462:             if not line:
 19463:                 continue
 19464:             ts, o, h, l, c, v = line[:6]
 19465:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
 19466:     return rows
 19467: 
 19468: 
 19469: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
 19470:     first = not os.path.exists(path)
 19471:     os.makedirs(os.path.dirname(path), exist_ok=True)
 19472:     with open(path, "a", newline="") as f:
 19473:         w = csv.writer(f)
 19474:         if first:
 19475:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
 19476:         for row in data:
 19477:             w.writerow(row)
 19478: 
 19479: 
 19480: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
 19481:     return rows[-1][0] if rows else None
 19482: 
 19483: 
 19484: # ---------------------------------------------------------------------
 19485: # Fetch CCXT paginé
 19486: # ---------------------------------------------------------------------
 19487: async def ccxt_fetch_ohlcv_all(
 19488:     exchange,
 19489:     symbol: str,
 19490:     timeframe: str,
 19491:     since_ms: Optional[int],
 19492:     limit: int = 1000,
 19493: ) -> List[Tuple[int, float, float, float, float, float]]:
 19494:     """
 19495:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
 19496:     Retourne une liste triée/dédupliquée.
 19497:     """
 19498:     out: List[Tuple[int, float, float, float, float, float]] = []
 19499:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
 19500:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
 19501: 
 19502:     cursor = since_ms or (now_ms - 200 * tf_ms)
 19503:     while True:
 19504:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
 19505:         if not batch:
 19506:             break
 19507:         for ts, o, h, l, c, v in batch:
 19508:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
 19509:         next_cursor = batch[-1][0] + tf_ms
 19510:         if next_cursor <= cursor:
 19511:             break
 19512:         cursor = next_cursor
 19513:         if cursor >= now_ms + (2 * tf_ms):
 19514:             break
 19515:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
 19516: 
 19517:     out.sort(key=lambda x: x[0])
 19518:     dedup: List[Tuple[int, float, float, float, float, float]] = []
 19519:     seen = set()
 19520:     for row in out:
 19521:         if row[0] in seen:
 19522:             continue
 19523:         seen.add(row[0])
 19524:         dedup.append(row)
 19525:     return dedup
 19526: 
 19527: 
 19528: # ---------------------------------------------------------------------
 19529: # Cache manager
 19530: # ---------------------------------------------------------------------
 19531: async def ensure_symbol_csv_cache(
 19532:     exchange,
 19533:     symbol: str,
 19534:     timeframe: str,
 19535:     min_rows: int = CSV_MIN_ROWS,
 19536: ) -> str:
 19537:     """
 19538:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
 19539:     Crée/append si nécessaire. Retourne le chemin.
 19540:     """
 19541:     path = csv_path(symbol, timeframe)
 19542:     rows = read_csv_ohlcv(path)
 19543:     tf_sec = parse_timeframe_to_seconds(timeframe)
 19544:     tf_ms = tf_sec * 1000
 19545:     now_ms = int(time.time() * 1000)
 19546: 
 19547:     # âge max
 19548:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
 19549: 
 19550:     need_full = False
 19551:     need_append = False
 19552: 
 19553:     if not rows:
 19554:         need_full = True
 19555:     else:
 19556:         last = last_ts(rows) or 0
 19557:         age_sec = max(0, (now_ms - last) // 1000)
 19558:         if age_sec > max_age or len(rows) < min_rows:
 19559:             need_append = True
 19560: 
 19561:     if need_full:
 19562:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
 19563:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
 19564:         if len(fresh) < min_rows:
 19565:             since = now_ms - (tf_ms * 5000)
 19566:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
 19567:         if os.path.exists(path):
 19568:             os.remove(path)
 19569:         write_csv_ohlcv(path, fresh)
 19570:         return path
 19571: 
 19572:     if need_append:
 19573:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
 19574:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
 19575:         if fresh:
 19576:             write_csv_ohlcv(path, fresh)
 19577: 
 19578:     return path
 19579: 
 19580: 
 19581: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
 19582:     """
 19583:     Prépare le cache pour plusieurs symboles (concurrence limitée).
 19584:     Retourne {symbol: path}.
 19585:     """
 19586:     sem = asyncio.Semaphore(PREFETCH_CONC)
 19587:     result: Dict[str, str] = {}
 19588: 
 19589:     async def _one(sym: str):
 19590:         async with sem:
 19591:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
 19592:             result[sym] = p
 19593: 
 19594:     await asyncio.gather(*[_one(s) for s in symbols])
 19595:     return result
 19596: 
 19597: --------------------------------------------------------------------------------
 19598: FILE: scalper/services/order_service.py
 19599: --------------------------------------------------------------------------------
 19600: from __future__ import annotations
 19601: from dataclasses import dataclass
 19602: from typing import Any, Dict, Optional, Protocol
 19603: from scalper.trade_utils import extract_available_balance
 19604: 
 19605: 
 19606: @dataclass
 19607: class OrderCaps:
 19608:     min_trade_usdt: float = 5.0
 19609:     leverage: float = 1.0
 19610: 
 19611: 
 19612: @dataclass
 19613: class OrderRequest:
 19614:     symbol: str
 19615:     side: str
 19616:     price: float
 19617:     sl: float
 19618:     tp: Optional[float]
 19619:     risk_pct: float
 19620: 
 19621: 
 19622: @dataclass
 19623: class OrderResult:
 19624:     accepted: bool
 19625:     reason: str = ""
 19626:     payload: Dict[str, Any] = None
 19627:     order_id: Optional[str] = None
 19628:     status: Optional[str] = None
 19629:     avg_price: Optional[float] = None
 19630:     filled_qty: Optional[float] = None
 19631: 
 19632: 
 19633: class Exchange(Protocol):
 19634:     def get_assets(self) -> Dict[str, Any]: ...
 19635:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
 19636:     def place_order(
 19637:         self,
 19638:         symbol: str,
 19639:         side: str,
 19640:         quantity: float,
 19641:         order_type: str,
 19642:         price: Optional[float] = None,
 19643:         stop_loss: Optional[float] = None,
 19644:         take_profit: Optional[float] = None,
 19645:     ) -> Dict[str, Any]: ...
 19646: 
 19647: 
 19648: class OrderService:
 19649:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
 19650:         self.exchange = exchange
 19651:         self.caps = caps
 19652: 
 19653:     @staticmethod
 19654:     def _abs(x: float) -> float:
 19655:         return -x if x < 0 else x
 19656: 
 19657:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
 19658:         dist = self._abs(price - sl)
 19659:         if dist <= 0:
 19660:             return 0.0
 19661:         risk_usdt = max(0.0, equity_usdt * risk_pct)
 19662:         return 0.0 if price <= 0 else (risk_usdt / dist)
 19663: 
 19664:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
 19665:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
 19666:         if qty <= 0:
 19667:             return OrderResult(False, "invalid_size")
 19668:         notional = qty * req.price
 19669:         if notional < self.caps.min_trade_usdt:
 19670:             return OrderResult(False, "under_min_notional")
 19671:         assets = self.exchange.get_assets()
 19672:         available = extract_available_balance(assets)
 19673:         required_margin = notional / max(1.0, self.caps.leverage)
 19674:         if available < required_margin:
 19675:             return OrderResult(False, "insufficient_margin")
 19676:         side = "BUY" if req.side == "long" else "SELL"
 19677:         out = self.exchange.place_order(
 19678:             symbol=req.symbol, side=side, quantity=qty,
 19679:             order_type="limit", price=req.price,
 19680:             stop_loss=req.sl, take_profit=req.tp
 19681:         )
 19682:         # extraire infos utiles
 19683:         oid = None; status = None; avg = None; filled = None
 19684:         try:
 19685:             data = out.get("data") if isinstance(out, dict) else out
 19686:             if isinstance(data, dict):
 19687:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
 19688:                 status = (data.get("status") or data.get("state") or "new").lower()
 19689:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
 19690:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
 19691:         except Exception:
 19692:             pass
 19693:         return OrderResult(True, "", out, oid, status, avg, filled)
 19694: 
 19695: 
 19696: --------------------------------------------------------------------------------
 19697: FILE: scalper/services/utils.py
 19698: --------------------------------------------------------------------------------
 19699: # scalper/services/utils.py
 19700: from __future__ import annotations
 19701: import asyncio
 19702: from typing import Callable, Any
 19703: 
 19704: 
 19705: class NullNotifier:
 19706:     async def send(self, _msg: str) -> None:
 19707:         return
 19708: 
 19709: 
 19710: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
 19711:     if notifier is None:
 19712:         notifier = NullNotifier()
 19713:     try:
 19714:         while running_getter():
 19715:             await notifier.send("heartbeat alive")
 19716:             await asyncio.sleep(period)
 19717:     except asyncio.CancelledError:
 19718:         pass
 19719: 
 19720: 
 19721: async def log_stats_task(
 19722:     notifier: Any,
 19723:     ticks_getter: Callable[[], int],
 19724:     symbols_getter: Callable[[], list[str]],
 19725:     period: float = 30.0,
 19726: ) -> None:
 19727:     if notifier is None:
 19728:         notifier = NullNotifier()
 19729:     last = 0
 19730:     try:
 19731:         while True:
 19732:             total = int(ticks_getter() or 0)
 19733:             delta = total - last
 19734:             last = total
 19735:             syms = symbols_getter() or []
 19736:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
 19737:             print(msg)
 19738:             await notifier.send(msg)
 19739:             await asyncio.sleep(period)
 19740:     except asyncio.CancelledError:
 19741:         pass
 19742: 
 19743: --------------------------------------------------------------------------------
 19744: FILE: scalper/signals/__init__.py
 19745: --------------------------------------------------------------------------------
 19746: __all__ = ["factory"]
 19747: 
 19748: --------------------------------------------------------------------------------
 19749: FILE: scalper/signals/current.py
 19750: --------------------------------------------------------------------------------
 19751: # scalper/signals/current.py
 19752: from __future__ import annotations
 19753: 
 19754: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
 19755: from scalper.strategy import generate_signal as _generate_signal
 19756: 
 19757: def generate_signal(**kwargs):
 19758:     """
 19759:     Expose la même signature que scalper.strategy.generate_signal.
 19760:     Sert d’adaptateur pour la factory.
 19761:     """
 19762:     return _generate_signal(**kwargs)
 19763: 
 19764: --------------------------------------------------------------------------------
 19765: FILE: scalper/signals/factory.py
 19766: --------------------------------------------------------------------------------
 19767: # scalper/signals/factory.py
 19768: from __future__ import annotations
 19769: from typing import Callable, Dict, Any
 19770: import importlib
 19771: import os
 19772: import json
 19773: 
 19774: try:
 19775:     import yaml  # type: ignore
 19776: except Exception:
 19777:     yaml = None  # type: ignore
 19778: 
 19779: SignalFn = Callable[..., Any]
 19780: 
 19781: # IMPORTANT : on pointe par défaut sur TA stratégie actuelle dans scalper/strategy.py
 19782: _REGISTRY: Dict[str, str] = {
 19783:     "current": "scalper.strategy:generate_signal",
 19784:     # Tu pourras ajouter d'autres stratégies ici, par ex :
 19785:     # "ema_cross": "scalper.strategies.ema_cross:generate_signal",
 19786: }
 19787: 
 19788: def _load_callable(path: str) -> SignalFn:
 19789:     if ":" not in path:
 19790:         raise ValueError(f"Chemin callable invalide: {path}")
 19791:     module_name, attr = path.split(":", 1)
 19792:     mod = importlib.import_module(module_name)
 19793:     fn = getattr(mod, attr, None)
 19794:     if not callable(fn):
 19795:         raise ValueError(f"{attr} n'est pas callable dans {module_name}")
 19796:     return fn  # type: ignore
 19797: 
 19798: def load_signal(name: str) -> SignalFn:
 19799:     key = (name or "").strip().lower()
 19800:     if key not in _REGISTRY:
 19801:         raise KeyError(f"Stratégie inconnue: '{name}'. Registre: {list(_REGISTRY)}")
 19802:     return _load_callable(_REGISTRY[key])
 19803: 
 19804: def _read_yaml(path: str) -> dict:
 19805:     if yaml is None:
 19806:         with open(path, "r", encoding="utf-8") as f:
 19807:             return json.load(f)
 19808:     with open(path, "r", encoding="utf-8") as f:
 19809:         return yaml.safe_load(f) or {}
 19810: 
 19811: def load_strategies_cfg(path: str | None) -> dict:
 19812:     """
 19813:     Charge le mapping (symbole, timeframe) -> nom de stratégie.
 19814:     Si le fichier n'existe pas, retourne une config par défaut fonctionnelle.
 19815:     """
 19816:     default_cfg = {"default": "current", "by_timeframe": {}, "by_symbol": {}}
 19817:     if not path:
 19818:         return default_cfg
 19819:     if not os.path.isfile(path):
 19820:         # Pas de fichier ? On continue avec les valeurs par défaut.
 19821:         return default_cfg
 19822:     cfg = _read_yaml(path)
 19823:     cfg.setdefault("default", "current")
 19824:     cfg.setdefault("by_timeframe", {})
 19825:     cfg.setdefault("by_symbol", {})
 19826:     return cfg
 19827: 
 19828: def resolve_strategy_name(symbol: str, timeframe: str, cfg: dict) -> str:
 19829:     symbol = (symbol or "").upper()
 19830:     timeframe = (timeframe or "").lower()
 19831:     return (
 19832:         cfg.get("by_symbol", {}).get(symbol, {}).get(timeframe)
 19833:         or cfg.get("by_timeframe", {}).get(timeframe)
 19834:         or cfg.get("default", "current")
 19835:     )
 19836: 
 19837: def resolve_signal_fn(symbol: str, timeframe: str, cfg: dict) -> SignalFn:
 19838:     return load_signal(resolve_strategy_name(symbol, timeframe, cfg))
 19839: 
 19840: --------------------------------------------------------------------------------
 19841: FILE: scalper/signals/generator.py
 19842: --------------------------------------------------------------------------------
 19843: from __future__ import annotations
 19844: 
 19845: from typing import Any, Dict, List, Optional
 19846: 
 19847: import pandas as pd
 19848: 
 19849: from data.indicators import compute_all
 19850: 
 19851: __all__ = ["generate_signal"]
 19852: 
 19853: 
 19854: def _quality_from_score(score: float) -> str:
 19855:     if score >= 0.8:
 19856:         return "A"
 19857:     if score >= 0.5:
 19858:         return "B"
 19859:     return "C"
 19860: 
 19861: 
 19862: def generate_signal(
 19863:     df: pd.DataFrame,
 19864:     *,
 19865:     trend_tf: Optional[pd.DataFrame] = None,
 19866:     confirm_tf: Optional[pd.DataFrame] = None,
 19867:     atr_mult: float = 1.0,
 19868:     trailing: bool = False,
 19869:     **_: Any,
 19870: ) -> Optional[Dict[str, Any]]:
 19871:     """Generate a trading signal with confluence scoring.
 19872: 
 19873:     Parameters
 19874:     ----------
 19875:     df: pd.DataFrame
 19876:         Primary timeframe OHLCV data.
 19877:     trend_tf: pd.DataFrame, optional
 19878:         Higher timeframe used for trend filtering.
 19879:     confirm_tf: pd.DataFrame, optional
 19880:         Lower timeframe used for confirmation.
 19881:     atr_mult: float, optional
 19882:         Multiplier applied to ATR for stop/target calculation.
 19883:     trailing: bool, optional
 19884:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
 19885: 
 19886:     Returns
 19887:     -------
 19888:     dict | None
 19889:         Dictionary describing the signal or ``None`` if no trade setup exists.
 19890:     """
 19891: 
 19892:     if df is None or len(df) < 2:
 19893:         return None
 19894: 
 19895:     df = compute_all(df)
 19896:     last = df.iloc[-1]
 19897: 
 19898:     conditions: List[bool] = []
 19899:     reasons: List[str] = []
 19900:     direction: Optional[str] = None
 19901: 
 19902:     # --- Basic trend via EMAs ----------------------------------------------
 19903:     if last["close"] > last["ema20"] > last["ema50"]:
 19904:         direction = "long"
 19905:         reasons.append("price_above_ema")
 19906:         conditions.append(True)
 19907:     elif last["close"] < last["ema20"] < last["ema50"]:
 19908:         direction = "short"
 19909:         reasons.append("price_below_ema")
 19910:         conditions.append(True)
 19911:     else:
 19912:         conditions.append(False)
 19913:         return None
 19914: 
 19915:     # --- RSI ---------------------------------------------------------------
 19916:     if direction == "long":
 19917:         cond = last["rsi"] > 55
 19918:         if cond:
 19919:             reasons.append("rsi_bullish")
 19920:         conditions.append(cond)
 19921:     else:
 19922:         cond = last["rsi"] < 45
 19923:         if cond:
 19924:             reasons.append("rsi_bearish")
 19925:         conditions.append(cond)
 19926: 
 19927:     # --- MACD --------------------------------------------------------------
 19928:     if direction == "long":
 19929:         cond = last["macd"] > last["macd_signal"]
 19930:         if cond:
 19931:             reasons.append("macd_bullish")
 19932:         conditions.append(cond)
 19933:     else:
 19934:         cond = last["macd"] < last["macd_signal"]
 19935:         if cond:
 19936:             reasons.append("macd_bearish")
 19937:         conditions.append(cond)
 19938: 
 19939:     # --- OBV momentum ------------------------------------------------------
 19940:     if len(df) >= 2:
 19941:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
 19942:         if obv_up:
 19943:             reasons.append("obv_trending")
 19944:         conditions.append(obv_up)
 19945: 
 19946:     # --- Trend timeframe filter -------------------------------------------
 19947:     if trend_tf is not None and len(trend_tf) >= 2:
 19948:         tdf = compute_all(trend_tf)
 19949:         ema50 = tdf["ema50"]
 19950:         slope = ema50.iloc[-1] - ema50.iloc[-2]
 19951:         if direction == "long":
 19952:             cond = slope > 0
 19953:             if cond:
 19954:                 reasons.append("trend_up")
 19955:             conditions.append(cond)
 19956:         else:
 19957:             cond = slope < 0
 19958:             if cond:
 19959:                 reasons.append("trend_down")
 19960:             conditions.append(cond)
 19961: 
 19962:     # --- Confirmation timeframe filter ------------------------------------
 19963:     if confirm_tf is not None and len(confirm_tf) > 0:
 19964:         cdf = compute_all(confirm_tf)
 19965:         rsi = cdf["rsi"].iloc[-1]
 19966:         if direction == "long":
 19967:             cond = rsi > 50
 19968:             if cond:
 19969:                 reasons.append("confirm_rsi_bullish")
 19970:             conditions.append(cond)
 19971:         else:
 19972:             cond = rsi < 50
 19973:             if cond:
 19974:                 reasons.append("confirm_rsi_bearish")
 19975:             conditions.append(cond)
 19976: 
 19977:     score = (
 19978:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
 19979:     )
 19980:     quality = _quality_from_score(score)
 19981: 
 19982:     atr = last.get("atr")
 19983:     if pd.isna(atr) or atr == 0:
 19984:         return None
 19985: 
 19986:     entry = float(last["close"])
 19987:     if direction == "long":
 19988:         sl = entry - atr * atr_mult
 19989:         tp = entry + atr * atr_mult * 2
 19990:     else:
 19991:         sl = entry + atr * atr_mult
 19992:         tp = entry - atr * atr_mult * 2
 19993: 
 19994:     result: Dict[str, Any] = {
 19995:         "direction": direction,
 19996:         "entry": entry,
 19997:         "sl": sl,
 19998:         "tp": tp,
 19999:         "score": round(score, 3),
 20000:         "reasons": reasons,
 20001:         "quality": quality,
 20002:     }
 20003: 
 20004:     if trailing:
 20005:         result["trail"] = atr * atr_mult
 20006: 
 20007:     return result
 20008: 
 20009: 
 20010: --------------------------------------------------------------------------------
 20011: FILE: scalper/strategy/factory.py
 20012: --------------------------------------------------------------------------------
 20013: annulé
 20014: 
 20015: --------------------------------------------------------------------------------
 20016: FILE: scalper/strategy.py
 20017: --------------------------------------------------------------------------------
 20018: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
 20019: 
 20020: This module implements a minimal but functional version of the strategy
 20021: outlined in the project specification.  The focus is on pure Python
 20022: implementations so the logic can easily be unit tested without requiring
 20023: external services or heavy third‑party dependencies.
 20024: 
 20025: The strategy is deliberately stateless; functions operate on passed data and
 20026: return simple data structures.  This makes it easy to plug the logic into
 20027: real‑time trading loops or backtest engines.
 20028: """
 20029: 
 20030: from __future__ import annotations
 20031: 
 20032: from dataclasses import dataclass
 20033: from typing import Sequence, List, Dict, Optional, Tuple, Any
 20034: 
 20035: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
 20036: from .risk import calc_position_size
 20037: 
 20038: # ---------------------------------------------------------------------------
 20039: # Helpers
 20040: # ---------------------------------------------------------------------------
 20041: 
 20042: def ema(series: Sequence[float], window: int) -> List[float]:
 20043:     """Return the exponential moving average of *series*.
 20044: 
 20045:     The first value is the raw input to remain consistent with most trading
 20046:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
 20047:     returned unchanged.
 20048:     """
 20049: 
 20050:     if window <= 1 or not series:
 20051:         return list(series)
 20052:     k = 2.0 / (window + 1.0)
 20053:     out: List[float] = [float(series[0])]
 20054:     prev = out[0]
 20055:     for x in series[1:]:
 20056:         prev = float(x) * k + prev * (1.0 - k)
 20057:         out.append(prev)
 20058:     return out
 20059: 
 20060: def vwap(highs: Sequence[float], lows: Sequence[float],
 20061:          closes: Sequence[float], volumes: Sequence[float]) -> float:
 20062:     """Compute the volume weighted average price (VWAP).
 20063: 
 20064:     Parameters
 20065:     ----------
 20066:     highs, lows, closes, volumes: Sequence[float]
 20067:         Matching sequences for the period considered.
 20068:     """
 20069: 
 20070:     tp_vol = 0.0
 20071:     vol_sum = 0.0
 20072:     for h, low, c, v in zip(highs, lows, closes, volumes):
 20073:         tp = (h + low + c) / 3.0
 20074:         tp_vol += tp * v
 20075:         vol_sum += v
 20076:     return tp_vol / vol_sum if vol_sum else 0.0
 20077: 
 20078: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
 20079:     """Return the On Balance Volume (OBV) series."""
 20080: 
 20081:     if not closes:
 20082:         return []
 20083:     out: List[float] = [0.0]
 20084:     for i in range(1, len(closes)):
 20085:         if closes[i] > closes[i - 1]:
 20086:             out.append(out[-1] + volumes[i])
 20087:         elif closes[i] < closes[i - 1]:
 20088:             out.append(out[-1] - volumes[i])
 20089:         else:
 20090:             out.append(out[-1])
 20091:     return out
 20092: 
 20093: 
 20094: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
 20095:     """Detect a crossing between two series.
 20096: 
 20097:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
 20098:     ``0`` otherwise.
 20099:     """
 20100: 
 20101:     if prev_fast <= prev_slow and last_fast > last_slow:
 20102:         return 1
 20103:     if prev_fast >= prev_slow and last_fast < last_slow:
 20104:         return -1
 20105:     return 0
 20106: 
 20107: 
 20108: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
 20109:     """Compute order book imbalance.
 20110: 
 20111:     The value is normalised between ``-1`` and ``1`` where positive numbers
 20112:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
 20113:     """
 20114: 
 20115:     total = bid_vol + ask_vol
 20116:     return (bid_vol - ask_vol) / total if total else 0.0
 20117: 
 20118: 
 20119: def swing_levels(
 20120:     highs: Sequence[float], lows: Sequence[float], lookback: int
 20121: ) -> Tuple[float, float]:
 20122:     """Return the most recent swing high and swing low.
 20123: 
 20124:     ``lookback`` defines how many completed candles are inspected.  The current
 20125:     candle is excluded to avoid look‑ahead bias.
 20126:     """
 20127: 
 20128:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
 20129:         return highs[-1], lows[-1]
 20130:     high = max(highs[-lookback - 1 : -1])
 20131:     low = min(lows[-lookback - 1 : -1])
 20132:     return high, low
 20133: 
 20134: # ---------------------------------------------------------------------------
 20135: # Pair selection
 20136: # ---------------------------------------------------------------------------
 20137: 
 20138: # The first and second level pair selection helpers now live in
 20139: # :mod:`scalper.selection`.  They are re-exported here for backward compatibility
 20140: # and to keep the public API unchanged.
 20141: from .selection.scanner import scan_pairs  # noqa: E402
 20142: from .selection.momentum import select_active_pairs  # noqa: E402
 20143: 
 20144: # ---------------------------------------------------------------------------
 20145: # Signal generation
 20146: # ---------------------------------------------------------------------------
 20147: 
 20148: @dataclass
 20149: class Signal:
 20150:     """Trading signal with risk parameters."""
 20151: 
 20152:     symbol: str
 20153:     side: int  # 1 for long, -1 for short
 20154:     entry: float
 20155:     sl: float
 20156:     tp1: float
 20157:     tp2: float
 20158:     qty: float = 0.0
 20159:     score: Optional[float] = None
 20160:     quality: Optional[float] = None
 20161:     reasons: Optional[List[str]] = None
 20162: 
 20163:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
 20164:         if isinstance(self.side, str):
 20165:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
 20166: 
 20167:     @property
 20168:     def price(self) -> float:
 20169:         return self.entry
 20170: 
 20171: 
 20172: def _generate_signal(
 20173:     symbol: str,
 20174:     ohlcv: Dict[str, Sequence[float]],
 20175:     *,
 20176:     equity: float,
 20177:     risk_pct: float,
 20178:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
 20179:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
 20180:     order_book: Optional[Dict[str, float]] = None,
 20181:     tick_ratio_buy: Optional[float] = None,
 20182:     atr_disable_pct: float = 0.2,
 20183:     atr_reduce_pct: float = 2.0,
 20184:     swing_lookback: int = 5,
 20185:     macd_fast: int = 12,
 20186:     macd_slow: int = 26,
 20187:     macd_signal: int = 9,
 20188:     trend_ema_period: int = 200,
 20189: ) -> Optional[Signal]:
 20190:     """Return a trading :class:`Signal` if conditions are met.
 20191: 
 20192:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
 20193:     sequences ordered from oldest to newest.  The function checks the following
 20194:     rules:
 20195: 
 20196:     * price positioned relative to VWAP and EMA20/EMA50 trend
 20197:     * RSI(14) crossing key levels (40/60)
 20198:     * OBV rising or high short‑term volume
 20199:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
 20200:     * Micro‑structure breakout of last swing high/low
 20201:     * MACD trend filter
 20202:     * Long‑term trend via configurable EMA filter
 20203:     * Order book imbalance and tape filters
 20204:     * Dynamic ATR‑based stop‑loss and take‑profit
 20205:     * Position sizing via ``calc_position_size``
 20206:     """
 20207: 
 20208:     closes = [float(x) for x in ohlcv.get("close", [])]
 20209:     highs = [float(x) for x in ohlcv.get("high", [])]
 20210:     lows = [float(x) for x in ohlcv.get("low", [])]
 20211:     vols = [float(x) for x in ohlcv.get("volume", [])]
 20212:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
 20213:         return None
 20214: 
 20215:     price = closes[-1]
 20216:     ema20 = ema(closes, 20)
 20217:     ema50 = ema(closes, 50)
 20218:     ema_trend = ema(closes, trend_ema_period)
 20219:     v = vwap(highs, lows, closes, vols)
 20220:     obv_series = obv(closes, vols)
 20221:     obv_rising = obv_series[-1] > obv_series[-2]
 20222:     vol_last3 = sum(vols[-3:])
 20223:     vol_ma20 = sum(vols[-20:]) / 20.0
 20224:     vol_rising = vol_last3 > vol_ma20
 20225: 
 20226:     macd_val, macd_sig, _ = calc_macd(
 20227:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
 20228:     )
 20229: 
 20230:     # Multi timeframe filters -------------------------------------------------
 20231:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
 20232:     if ohlcv_1h:
 20233:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
 20234:         if len(h_closes) >= 52:
 20235:             h_ema50 = ema(h_closes, 50)
 20236:             if len(h_ema50) >= 2:
 20237:                 slope = h_ema50[-1] - h_ema50[-2]
 20238:                 if slope > 0:
 20239:                     trend_dir = 1
 20240:                 elif slope < 0:
 20241:                     trend_dir = -1
 20242: 
 20243:     rsi_15 = None
 20244:     if ohlcv_15m:
 20245:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
 20246:         if len(m_closes) >= 15:
 20247:             rsi_15 = calc_rsi(m_closes, 14)
 20248: 
 20249:     # RSI crossing logic (5m)
 20250:     rsi_curr = calc_rsi(closes[-15:], 14)
 20251:     rsi_prev = calc_rsi(closes[-16:-1], 14)
 20252: 
 20253:     atr = calc_atr(highs, lows, closes, 14)
 20254:     atr_pct = atr / price * 100.0 if price else 0.0
 20255:     if atr_pct < atr_disable_pct:
 20256:         return None
 20257:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
 20258: 
 20259:     sl_dist = 0.5 * atr
 20260:     tp1_dist = 1.0 * atr
 20261:     tp2_dist = 1.5 * atr
 20262: 
 20263:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
 20264: 
 20265:     obi_ok_long = obi_ok_short = True
 20266:     if order_book is not None:
 20267:         bid = float(order_book.get("bid_vol_aggreg", 0))
 20268:         ask = float(order_book.get("ask_vol_aggreg", 0))
 20269:         obi = order_book_imbalance(bid, ask)
 20270:         obi_ok_long = obi > 0.1
 20271:         obi_ok_short = obi < -0.1
 20272: 
 20273:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
 20274:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
 20275: 
 20276:     def _size(dist: float) -> float:
 20277:         return calc_position_size(equity, risk_pct, dist) * size_mult
 20278:     weights = {
 20279:         "ema": 15.0,
 20280:         "macd": 15.0,
 20281:         "vwap": 15.0,
 20282:         "rsi": 15.0,
 20283:         "obv": 10.0,
 20284:         "swing": 10.0,
 20285:         "atr": 20.0,
 20286:     }
 20287: 
 20288:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
 20289: 
 20290:     long_score = atr_score
 20291:     long_reasons: List[str] = []
 20292:     if price > v:
 20293:         long_score += weights["vwap"]
 20294:         long_reasons.append("vwap")
 20295:     if ema20[-1] > ema50[-1]:
 20296:         long_score += weights["ema"]
 20297:         long_reasons.append("ema")
 20298:     if rsi_prev <= 40 < rsi_curr:
 20299:         long_score += weights["rsi"]
 20300:         long_reasons.append("rsi")
 20301:     if macd_val > macd_sig:
 20302:         long_score += weights["macd"]
 20303:         long_reasons.append("macd")
 20304:     if obv_rising or vol_rising:
 20305:         long_score += weights["obv"]
 20306:         long_reasons.append("obv")
 20307:     if price > swing_high:
 20308:         long_score += weights["swing"]
 20309:         long_reasons.append("swing")
 20310: 
 20311:     short_score = atr_score
 20312:     short_reasons: List[str] = []
 20313:     if price < v:
 20314:         short_score += weights["vwap"]
 20315:         short_reasons.append("vwap")
 20316:     if ema20[-1] < ema50[-1]:
 20317:         short_score += weights["ema"]
 20318:         short_reasons.append("ema")
 20319:     if rsi_prev >= 60 > rsi_curr:
 20320:         short_score += weights["rsi"]
 20321:         short_reasons.append("rsi")
 20322:     if macd_val < macd_sig:
 20323:         short_score += weights["macd"]
 20324:         short_reasons.append("macd")
 20325:     if obv_series[-1] < obv_series[-2] or vol_rising:
 20326:         short_score += weights["obv"]
 20327:         short_reasons.append("obv")
 20328:     if price < swing_low:
 20329:         short_score += weights["swing"]
 20330:         short_reasons.append("swing")
 20331: 
 20332:     side: Optional[str] = None
 20333:     score: float = 0.0
 20334:     reasons: List[str] = []
 20335:     if (
 20336:         long_score >= short_score
 20337:         and long_score > 0
 20338:         and macd_val > macd_sig
 20339:         and obi_ok_long
 20340:         and tick_ok_long
 20341:         and trend_dir >= 0
 20342:         and price > ema_trend[-1]
 20343:     ):
 20344:         side = "long"
 20345:         score = long_score
 20346:         reasons = long_reasons
 20347:         sl = price - sl_dist
 20348:         tp1 = price + tp1_dist
 20349:         tp2 = price + tp2_dist
 20350:     elif (
 20351:         short_score > long_score
 20352:         and short_score > 0
 20353:         and macd_val < macd_sig
 20354:         and obi_ok_short
 20355:         and tick_ok_short
 20356:         and trend_dir <= 0
 20357:         and price < ema_trend[-1]
 20358:     ):
 20359:         side = "short"
 20360:         score = short_score
 20361:         reasons = short_reasons
 20362:         sl = price + sl_dist
 20363:         tp1 = price - tp1_dist
 20364:         tp2 = price - tp2_dist
 20365:     else:
 20366:         return None
 20367: 
 20368:     qty = _size(sl_dist)
 20369:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
 20370: 
 20371: 
 20372: def generate_signal(*args, **kwargs) -> Optional[Signal]:
 20373:     if "config" in kwargs:
 20374:         config = kwargs.pop("config")
 20375:         symbol = kwargs.pop("symbol", None)
 20376:         ohlcv = kwargs.pop("ohlcv", None)
 20377:         if ohlcv is None:
 20378:             raise TypeError("ohlcv argument required")
 20379:         return _generate_signal(
 20380:             symbol or ohlcv.get("symbol", ""),
 20381:             ohlcv,
 20382:             equity=kwargs.pop("equity", 0.0),
 20383:             risk_pct=getattr(config, "RISK_PCT", 0.0),
 20384:             **kwargs,
 20385:         )
 20386:     return _generate_signal(*args, **kwargs)
 20387: 
 20388: # ---------------------------------------------------------------------------
 20389: # Backtesting utilities
 20390: # ---------------------------------------------------------------------------
 20391: 
 20392: def max_drawdown(equity_curve: Sequence[float]) -> float:
 20393:     peak = equity_curve[0]
 20394:     mdd = 0.0
 20395:     for x in equity_curve:
 20396:         if x > peak:
 20397:             peak = x
 20398:         dd = (peak - x) / peak * 100.0
 20399:         if dd > mdd:
 20400:             mdd = dd
 20401:     return mdd
 20402: 
 20403: def backtest(
 20404:     trades: Sequence[Dict[str, Any]],
 20405:     *,
 20406:     equity_start: float = 1_000.0,
 20407:     fee_rate: float = 0.0,
 20408: ) -> Dict[str, float]:
 20409:     """Evaluate a list of trade dictionaries.
 20410: 
 20411:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
 20412:     optionally include ``duration`` in minutes.  Results are aggregated into
 20413:     common performance metrics to quickly evaluate the strategy.
 20414:     """
 20415: 
 20416:     equity = equity_start
 20417:     equity_curve = [equity]
 20418:     pnl_pct_list: List[float] = []
 20419:     wins = losses = 0
 20420:     win_sum = loss_sum = 0.0
 20421:     total_duration = 0.0
 20422: 
 20423:     for t in trades:
 20424:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
 20425:         pnl_pct_list.append(pnl_pct)
 20426:         if pnl_pct >= 0:
 20427:             wins += 1
 20428:             win_sum += pnl_pct
 20429:         else:
 20430:             losses += 1
 20431:             loss_sum += pnl_pct
 20432:         equity *= 1 + pnl_pct / 100.0
 20433:         equity_curve.append(equity)
 20434:         total_duration += float(t.get("duration", 0.0))
 20435: 
 20436:     pnl_pct_total = sum(pnl_pct_list)
 20437:     pnl_usdt = equity - equity_start
 20438:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
 20439:     winrate = wins / len(trades) * 100.0 if trades else 0.0
 20440:     mdd = max_drawdown(equity_curve)
 20441:     avg_trade_time = total_duration / len(trades) if trades else 0.0
 20442:     exposure = total_duration  # in minutes, callers can normalise if desired
 20443:     # Sharpe ratio based on per-trade returns
 20444:     if len(pnl_pct_list) > 1:
 20445:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
 20446:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
 20447:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
 20448:     else:
 20449:         sharpe = 0.0
 20450: 
 20451:     return {
 20452:         "pnl_usdt": pnl_usdt,
 20453:         "pnl_pct": pnl_pct_total,
 20454:         "profit_factor": profit_factor,
 20455:         "winrate": winrate,
 20456:         "max_drawdown": mdd,
 20457:         "avg_trade_time": avg_trade_time,
 20458:         "exposure": exposure,
 20459:         "sharpe": sharpe,
 20460:     }
 20461: 
 20462: 
 20463: --------------------------------------------------------------------------------
 20464: FILE: scalper/trade_utils.py
 20465: --------------------------------------------------------------------------------
 20466: # scalper/trade_utils.py
 20467: from __future__ import annotations
 20468: 
 20469: from typing import Optional
 20470: 
 20471: 
 20472: def compute_position_size(
 20473:     equity: float,
 20474:     price: float,
 20475:     risk_pct: float,
 20476:     *,
 20477:     symbol: Optional[str] = None,
 20478:     min_qty: float = 0.0,
 20479:     max_leverage: float = 1.0,
 20480: ) -> float:
 20481:     """
 20482:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
 20483:     qty = notionnel / price
 20484:     - min_qty : borne basse éventuelle (0 pour ignorer)
 20485:     - max_leverage : si tu veux simuler un levier (1 par défaut)
 20486:     """
 20487:     equity = float(max(0.0, equity))
 20488:     price = float(max(1e-12, price))
 20489:     risk_pct = float(max(0.0, risk_pct))
 20490:     notionnel = equity * risk_pct * max_leverage
 20491:     qty = notionnel / price
 20492:     if min_qty > 0 and qty < min_qty:
 20493:         return 0.0
 20494:     return float(qty)
 20495: 
 20496: --------------------------------------------------------------------------------
 20497: FILE: scalper/version.py
 20498: --------------------------------------------------------------------------------
 20499: """Utilities for managing the Scalp bot version."""
 20500: 
 20501: from __future__ import annotations
 20502: 
 20503: from pathlib import Path
 20504: import re
 20505: 
 20506: import subprocess
 20507: 
 20508: 
 20509: # Path to the VERSION file within the package
 20510: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
 20511: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
 20512: 
 20513: 
 20514: def get_version() -> str:
 20515:     """Return the current version of the bot.
 20516: 
 20517:     If the VERSION file does not exist the default version ``0.0.0`` is
 20518:     returned.
 20519:     """
 20520:     if not _VERSION_FILE.exists():
 20521:         return "0.0.0"
 20522:     return _VERSION_FILE.read_text().strip()
 20523: 
 20524: 
 20525: def _parse(version: str) -> tuple[int, int, int]:
 20526:     match = _VERSION_RE.match(version)
 20527:     if not match:
 20528:         raise ValueError(f"Invalid version: {version!r}")
 20529:     return tuple(int(x) for x in match.groups())
 20530: 
 20531: 
 20532: def bump_version(part: str = "patch") -> str:
 20533:     """Bump the version stored in the VERSION file.
 20534: 
 20535:     Parameters
 20536:     ----------
 20537:     part:
 20538:         Which component to increment. Accepted values are ``"major"``,
 20539:         ``"minor"`` and ``"patch"`` (default).
 20540:     """
 20541:     major, minor, patch = _parse(get_version())
 20542:     if part == "major":
 20543:         major += 1
 20544:         minor = 0
 20545:         patch = 0
 20546:     elif part == "minor":
 20547:         minor += 1
 20548:         patch = 0
 20549: 
 20550:     elif part == "patch":
 20551:         patch += 1
 20552:     else:
 20553:         raise ValueError(f"Unknown part: {part}")
 20554:     new_version = f"{major}.{minor}.{patch}"
 20555:     _VERSION_FILE.write_text(f"{new_version}\n")
 20556:     return new_version
 20557: 
 20558: 
 20559: def bump_version_from_message(message: str) -> str:
 20560:     """Bump the version according to a commit message.
 20561: 
 20562:     ``message`` is evaluated using a tiny subset of the Conventional
 20563:     Commits spec. Messages starting with ``feat`` bump the *minor*
 20564:     version, messages whose header ends with ``!`` or contain
 20565:     ``BREAKING CHANGE`` bump the *major* version. All other messages
 20566:     bump the *patch* component.
 20567:     """
 20568: 
 20569:     header = message.strip().splitlines()[0].lower()
 20570:     lower = message.lower()
 20571:     type_part = header.split(":")[0]
 20572:     if "!" in type_part or "breaking change" in lower:
 20573:         part = "major"
 20574:     elif type_part.startswith("feat"):
 20575:         part = "minor"
 20576:     else:
 20577:         part = "patch"
 20578:     return bump_version(part)
 20579: 
 20580: 
 20581: def bump_version_from_git() -> str:
 20582:     """Read the latest git commit message and bump the version accordingly."""
 20583:     try:
 20584:         message = subprocess.check_output(
 20585:             ["git", "log", "-1", "--pretty=%B"], text=True
 20586:         ).strip()
 20587:     except Exception:
 20588:         message = ""
 20589:     return bump_version_from_message(message)
 20590: 
 20591: 
 20592: if __name__ == "__main__":
 20593:     print(bump_version_from_git())
 20594: 
 20595: 
 20596: --------------------------------------------------------------------------------
 20597: FILE: scalper/ws.py
 20598: --------------------------------------------------------------------------------
 20599: """Minimal websocket manager with heartbeat and auto-resubscribe.
 20600: 
 20601: This module provides a light-weight framework to maintain a realtime
 20602: connection to an exchange.  The actual network layer is expected to be
 20603: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
 20604: manager handles retrying failed connections and periodically invoking the
 20605: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
 20606: without opening real network sockets.
 20607: """
 20608: from __future__ import annotations
 20609: 
 20610: import asyncio
 20611: import logging
 20612: from typing import Awaitable, Callable, Optional
 20613: 
 20614: 
 20615: class WebsocketManager:
 20616:     """Maintain a websocket connection with heartbeat and retry."""
 20617: 
 20618:     def __init__(
 20619:         self,
 20620:         connect: Callable[[], Awaitable[None]],
 20621:         subscribe: Callable[[], Awaitable[None]],
 20622:         *,
 20623:         heartbeat_interval: float = 30.0,
 20624:         max_retries: int = 3,
 20625:     ) -> None:
 20626:         self._connect = connect
 20627:         self._subscribe = subscribe
 20628:         self.heartbeat_interval = heartbeat_interval
 20629:         self.max_retries = max_retries
 20630:         self._heartbeat_task: Optional[asyncio.Task] = None
 20631: 
 20632:     async def run(self) -> None:
 20633:         """Open the connection retrying on failure."""
 20634:         retries = 0
 20635:         while True:
 20636:             try:
 20637:                 await self._connect()
 20638:                 await self._subscribe()
 20639:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
 20640:                 return
 20641:             except Exception as exc:  # pragma: no cover - network errors
 20642:                 logging.error("websocket connect failed: %s", exc)
 20643:                 retries += 1
 20644:                 if retries > self.max_retries:
 20645:                     raise
 20646:                 await asyncio.sleep(1)
 20647: 
 20648:     async def _heartbeat(self) -> None:
 20649:         """Send periodic heartbeats and resubscribe on failure."""
 20650:         while True:
 20651:             await asyncio.sleep(self.heartbeat_interval)
 20652:             try:
 20653:                 await self._subscribe()
 20654:             except Exception as exc:  # pragma: no cover - network errors
 20655:                 logging.warning("websocket heartbeat failed: %s", exc)
 20656:                 await self.run()
 20657:                 break
 20658: 
 20659:     async def stop(self) -> None:
 20660:         """Cancel the heartbeat task if it is running."""
 20661:         task = self._heartbeat_task
 20662:         if task and not task.done():
 20663:             task.cancel()
 20664:             try:
 20665:                 await task
 20666:             except BaseException:  # pragma: no cover - cancellation
 20667:                 pass
 20668:         self._heartbeat_task = None
 20669: 
 20670: 
 20671: --------------------------------------------------------------------------------
 20672: FILE: sitecustomize.py
 20673: --------------------------------------------------------------------------------
 20674: # sitecustomize.py
 20675: """
 20676: Ce fichier est importé automatiquement par Python au démarrage, si présent sur sys.path.
 20677: On l'utilise pour lancer un préflight de 'scalper' avant l'exécution du bot,
 20678: sans modifier bot.py. Désactivable via SKIP_PREFLIGHT=1.
 20679: """
 20680: 
 20681: import os
 20682: 
 20683: if os.getenv("SKIP_PREFLIGHT", "0") not in ("1", "true", "yes"):
 20684:     try:
 20685:         # Optionnel: charger /notebooks/.env si présent
 20686:         try:
 20687:             from dotenv import load_dotenv  # pip install python-dotenv si besoin
 20688:             load_dotenv("/notebooks/.env")
 20689:         except Exception:
 20690:             pass
 20691: 
 20692:     except Exception:
 20693:         pass
 20694: 
 20695:     try:
 20696:         from scalper.selfcheck import preflight_or_die
 20697:         preflight_or_die(verbose=False)
 20698:     except SystemExit:
 20699:         # le préflight a signalé un problème -> on laisse l'arrêt se propager
 20700:         raise
 20701:     except Exception as e:
 20702:         # On ne bloque pas le démarrage si le selfcheck lui-même plante,
 20703:         # mais on affiche une alerte claire.
 20704:         print(f"[sitecustomize] Avertissement: selfcheck non exécuté ({e})")
 20705: 
 20706: --------------------------------------------------------------------------------
 20707: FILE: tests/conftest.py
 20708: --------------------------------------------------------------------------------
 20709: """Test configuration and shared fixtures."""
 20710: 
 20711: import sys
 20712: import types
 20713: from pathlib import Path
 20714: 
 20715: 
 20716: # Ensure the project root is importable so tests can ``import bot``.
 20717: ROOT = Path(__file__).resolve().parents[1]
 20718: sys.path.insert(0, str(ROOT))
 20719: 
 20720: 
 20721: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
 20722: # the real dependency during test collection. Individual tests patch the
 20723: # functions they need (``request``/``post``/``get``).
 20724: sys.modules.setdefault(
 20725:     "requests",
 20726:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
 20727: )
 20728: 
 20729: 
 20730: 
 20731: --------------------------------------------------------------------------------
 20732: FILE: tests/test_analyse_risque.py
 20733: --------------------------------------------------------------------------------
 20734: import os
 20735: import sys
 20736: import types
 20737: 
 20738: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 20739: sys.modules['requests'] = types.SimpleNamespace(
 20740:     request=lambda *a, **k: None,
 20741:     post=lambda *a, **k: None,
 20742:     HTTPError=Exception,
 20743: )
 20744: 
 20745: from bot import analyse_risque  # noqa: E402
 20746: 
 20747: 
 20748: def make_contract_detail():
 20749:     return {
 20750:         "data": [
 20751:             {
 20752:                 "symbol": "BTC_USDT",
 20753:                 "contractSize": 0.01,
 20754:                 "volUnit": 1,
 20755:                 "minVol": 1,
 20756:             }
 20757:         ]
 20758:     }
 20759: 
 20760: 
 20761: def test_analyse_risque_limits_and_leverage():
 20762:     contract_detail = make_contract_detail()
 20763:     # Risk level 1: leverage halved, limit 1 position
 20764:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
 20765:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 20766:                                symbol="BTC_USDT", side="long", risk_level=1)
 20767:     assert lev == 5
 20768:     assert vol == 0  # already one long position
 20769: 
 20770:     # Risk level 2: base leverage, limit 3 positions
 20771:     open_pos = [
 20772:         {"symbol": "BTC_USDT", "side": "long"},
 20773:         {"symbol": "BTC_USDT", "side": "long"},
 20774:         {"symbol": "BTC_USDT", "side": "long"},
 20775:     ]
 20776:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 20777:                                symbol="BTC_USDT", side="long", risk_level=2)
 20778:     assert lev == 10
 20779:     assert vol == 0
 20780: 
 20781:     # Risk level 3: leverage doubled, no existing position
 20782:     open_pos = []
 20783:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
 20784:                                symbol="BTC_USDT", side="long", risk_level=3)
 20785:     assert lev == 20
 20786:     assert vol == 1
 20787: 
 20788: 
 20789: --------------------------------------------------------------------------------
 20790: FILE: tests/test_backtest.py
 20791: --------------------------------------------------------------------------------
 20792: import pytest
 20793: 
 20794: import bot
 20795: 
 20796: 
 20797: def test_backtest_trades():
 20798:     trades = [
 20799:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
 20800:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
 20801:     ]
 20802:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
 20803:     # Both trades: 10% - 0.2% fee = 9.8% each
 20804:     assert pnl == pytest.approx(19.6)
 20805: 
 20806: 
 20807: --------------------------------------------------------------------------------
 20808: FILE: tests/test_backtest_multi.py
 20809: --------------------------------------------------------------------------------
 20810: import csv
 20811: import random
 20812: from datetime import datetime, timedelta, timezone
 20813: from pathlib import Path
 20814: 
 20815: import pytest
 20816: 
 20817: from scalper.backtest.run_multi import run_backtest_multi
 20818: from scalper.strategy import Signal
 20819: 
 20820: 
 20821: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
 20822:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
 20823:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
 20824:     with open(filename, "w", newline="") as fh:
 20825:         writer = csv.writer(fh)
 20826:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
 20827:         for i in range(200):
 20828:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
 20829:             price = 100 + i
 20830:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
 20831: 
 20832: 
 20833: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 20834:     closes = ohlcv["close"]
 20835:     if len(closes) < 10:
 20836:         return None
 20837:     price = closes[-1]
 20838:     sl = price * 0.99
 20839:     tp = price * 1.01
 20840:     qty = equity * risk_pct / (price - sl)
 20841:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
 20842: 
 20843: 
 20844: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 20845:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
 20846:         return None
 20847:     price = ohlcv["close"][-1]
 20848:     sl = price * 0.99
 20849:     tp = price * 1.01
 20850:     qty = equity * risk_pct / (price - sl)
 20851:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
 20852: 
 20853: 
 20854: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
 20855:     closes = ohlcv["close"]
 20856:     if len(closes) < 10:
 20857:         return None
 20858:     price = closes[-1]
 20859:     sl = price * 0.99
 20860:     tp = price * 1.01
 20861:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
 20862: 
 20863: 
 20864: def find_row(summary, symbol):
 20865:     for row in summary:
 20866:         if row["symbol"] == symbol:
 20867:             return row
 20868:     raise KeyError(symbol)
 20869: 
 20870: 
 20871: def test_csv_multi_pairs(tmp_path, monkeypatch):
 20872:     for sym in ["BTC/USDT", "ETH/USDT"]:
 20873:         make_csv(tmp_path, sym)
 20874:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
 20875:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
 20876:     out = tmp_path / "out"
 20877:     summary, trades = run_backtest_multi(
 20878:         symbols=["BTC/USDT", "ETH/USDT"],
 20879:         exchange="csv",
 20880:         timeframe="1m",
 20881:         csv_dir=str(tmp_path),
 20882:         fee_rate=0.0,
 20883:         slippage_bps=0.0,
 20884:         risk_pct=0.01,
 20885:         initial_equity=1000,
 20886:         leverage=1.0,
 20887:         paper_constraints=True,
 20888:         seed=42,
 20889:         out_dir=str(out),
 20890:         plot=False,
 20891:     )
 20892:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
 20893:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
 20894:     assert len(btc_trades) > 0 and len(eth_trades) > 0
 20895:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
 20896:     total = find_row(summary, "TOTAL")["pnl_usdt"]
 20897:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
 20898:     # files
 20899:     assert (out / "report_summary.csv").exists()
 20900:     assert (out / "report_trades.csv").exists()
 20901:     assert (out / "equity_curve_total.csv").exists()
 20902:     assert (out / "equity_curve_BTC_USDT.csv").exists()
 20903:     # columns in trades
 20904:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
 20905:         assert col in trades[0]
 20906: 
 20907: 
 20908: def test_fee_slippage(tmp_path, monkeypatch):
 20909:     make_csv(tmp_path, "BTC/USDT")
 20910:     monkeypatch.setattr("scalper.strategy.generate_signal", simple_signal)
 20911:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
 20912:     summary1, _ = run_backtest_multi(
 20913:         symbols=["BTC/USDT"],
 20914:         exchange="csv",
 20915:         timeframe="1m",
 20916:         csv_dir=str(tmp_path),
 20917:         fee_rate=0.0,
 20918:         slippage_bps=0.0,
 20919:         out_dir=str(tmp_path / "o1"),
 20920:     )
 20921:     summary2, _ = run_backtest_multi(
 20922:         symbols=["BTC/USDT"],
 20923:         exchange="csv",
 20924:         timeframe="1m",
 20925:         csv_dir=str(tmp_path),
 20926:         fee_rate=0.01,
 20927:         slippage_bps=100,
 20928:         out_dir=str(tmp_path / "o2"),
 20929:     )
 20930:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
 20931:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
 20932:     assert pnl2 < pnl1
 20933: 
 20934: 
 20935: def test_paper_constraints(tmp_path, monkeypatch):
 20936:     make_csv(tmp_path, "BTC/USDT")
 20937:     monkeypatch.setattr("scalper.strategy.generate_signal", tiny_qty_signal)
 20938:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
 20939:     summary, trades = run_backtest_multi(
 20940:         symbols=["BTC/USDT"],
 20941:         exchange="csv",
 20942:         timeframe="1m",
 20943:         csv_dir=str(tmp_path),
 20944:         paper_constraints=True,
 20945:         out_dir=str(tmp_path / "o"),
 20946:     )
 20947:     assert all(t["qty"] >= 0.001 for t in trades)
 20948:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
 20949:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
 20950: 
 20951: 
 20952: def test_seed_reproducible(tmp_path, monkeypatch):
 20953:     make_csv(tmp_path, "BTC/USDT")
 20954:     monkeypatch.setattr("scalper.strategy.generate_signal", random_signal)
 20955:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
 20956:     s1, t1 = run_backtest_multi(
 20957:         symbols=["BTC/USDT"],
 20958:         exchange="csv",
 20959:         timeframe="1m",
 20960:         csv_dir=str(tmp_path),
 20961:         seed=7,
 20962:         out_dir=str(tmp_path / "o1"),
 20963:     )
 20964:     s2, t2 = run_backtest_multi(
 20965:         symbols=["BTC/USDT"],
 20966:         exchange="csv",
 20967:         timeframe="1m",
 20968:         csv_dir=str(tmp_path),
 20969:         seed=7,
 20970:         out_dir=str(tmp_path / "o2"),
 20971:     )
 20972:     assert t1 == t2
 20973:     assert s1 == s2
 20974: 
 20975: 
 20976: --------------------------------------------------------------------------------
 20977: FILE: tests/test_backtest_position.py
 20978: --------------------------------------------------------------------------------
 20979: import os
 20980: import sys
 20981: import pytest
 20982: 
 20983: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 20984: 
 20985: from scalper.metrics import backtest_position
 20986: 
 20987: 
 20988: def test_backtest_position_long():
 20989:     prices = [100.0, 110.0, 120.0]
 20990:     assert backtest_position(prices, 0, 2, 1) is True
 20991: 
 20992: 
 20993: def test_backtest_position_short():
 20994:     prices = [100.0, 90.0, 80.0]
 20995:     assert backtest_position(prices, 0, 2, -1) is True
 20996: 
 20997: 
 20998: def test_backtest_position_incoherent():
 20999:     prices = [100.0, 110.0, 120.0]
 21000:     assert backtest_position(prices, 0, 2, -1) is False
 21001: 
 21002: 
 21003: def test_backtest_position_bad_indices():
 21004:     prices = [100.0, 110.0]
 21005:     with pytest.raises(ValueError):
 21006:         backtest_position(prices, 1, 0, 1)
 21007: 
 21008: 
 21009: --------------------------------------------------------------------------------
 21010: FILE: tests/test_bitget_futures_pairs.py
 21011: --------------------------------------------------------------------------------
 21012: import json
 21013: from pathlib import Path
 21014: from typing import Any, Dict
 21015: 
 21016: import pytest
 21017: 
 21018: import bitget_futures_pairs as bfp
 21019: 
 21020: 
 21021: class DummyResponse:
 21022:     def __init__(self, status: int, payload: Dict[str, Any]):
 21023:         self.status_code = status
 21024:         self._payload = payload
 21025:         self.text = json.dumps(payload)
 21026: 
 21027:     def json(self):
 21028:         return self._payload
 21029: 
 21030: 
 21031: def test_fetch_contracts_success(monkeypatch):
 21032:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
 21033: 
 21034:     def fake_get(url, params=None, timeout=0):
 21035:         return DummyResponse(200, payload)
 21036: 
 21037:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
 21038:     contracts = bfp.fetch_contracts("USDT-FUTURES")
 21039:     assert contracts == payload["data"]
 21040: 
 21041: 
 21042: def test_fetch_contracts_error(monkeypatch):
 21043:     payload = {"code": "10001"}
 21044: 
 21045:     def fake_get(url, params=None, timeout=0):
 21046:         return DummyResponse(200, payload)
 21047: 
 21048:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
 21049:     with pytest.raises(RuntimeError):
 21050:         bfp.fetch_contracts("USDT-FUTURES")
 21051: 
 21052: 
 21053: def test_normalize_rows():
 21054:     contracts = [
 21055:         {
 21056:             "symbol": "BTCUSDT",
 21057:             "baseCoin": "BTC",
 21058:             "quoteCoin": "USDT",
 21059:             "symbolType": "perpetual",
 21060:             "symbolStatus": "normal",
 21061:             "maxLever": "50",
 21062:             "minLever": "1",
 21063:             "minTradeNum": "0.001",
 21064:             "sizeMultiplier": "1",
 21065:             "pricePlace": "2",
 21066:             "volumePlace": "3",
 21067:             "launchTime": 0,
 21068:             "deliveryTime": 0,
 21069:         }
 21070:     ]
 21071:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
 21072:     assert rows[0]["symbol"] == "BTCUSDT"
 21073:     assert rows[0]["productType"] == "USDT-FUTURES"
 21074: 
 21075: 
 21076: def test_write_csv(tmp_path: Path):
 21077:     path = tmp_path / "pairs.csv"
 21078:     bfp.write_csv([], str(path))
 21079:     assert path.exists()
 21080:     content = path.read_text().splitlines()
 21081:     assert content[0].startswith("productType,")
 21082: 
 21083: 
 21084: --------------------------------------------------------------------------------
 21085: FILE: tests/test_bot_place_order_caps.py
 21086: --------------------------------------------------------------------------------
 21087: import os
 21088: import sys
 21089: import types
 21090: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 21091: sys.modules['requests'] = types.ModuleType('requests')
 21092: 
 21093: from bot import attempt_entry, Signal
 21094: 
 21095: 
 21096: class DummyClient:
 21097:     def __init__(self):
 21098:         self.last_order = None
 21099: 
 21100:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
 21101:         self.last_order = (args, kwargs)
 21102:         return {"code": "00000"}
 21103: 
 21104: 
 21105: class DummyRisk:
 21106:     def __init__(self, pct):
 21107:         self.risk_pct = pct
 21108: 
 21109: 
 21110: def _detail():
 21111:     return {
 21112:         "data": [
 21113:             {
 21114:                 "symbol": "BTC_USDT",
 21115:                 "contractSize": 0.001,
 21116:                 "volUnit": 1,
 21117:                 "minVol": 1,
 21118:                 "minTradeUSDT": 5,
 21119:             }
 21120:         ]
 21121:     }
 21122: 
 21123: 
 21124: def test_attempt_entry_respects_caps(monkeypatch):
 21125:     captured = {}
 21126: 
 21127:     def fake_notify(event, payload):
 21128:         captured[event] = payload
 21129: 
 21130:     monkeypatch.setattr("bot.notify", fake_notify)
 21131:     client = DummyClient()
 21132:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 21133:     rm = DummyRisk(0.02)
 21134:     equity = 100
 21135:     available = 2.2  # just enough for 1 contract with buffer
 21136:     params = attempt_entry(
 21137:         client,
 21138:         _detail(),
 21139:         sig,
 21140:         equity_usdt=equity,
 21141:         available_usdt=available,
 21142:         cfg={"LEVERAGE": 10},
 21143:         risk_mgr=rm,
 21144:         user_risk_level=1,
 21145:     )
 21146:     assert client.last_order is not None
 21147:     assert params["vol"] >= 1
 21148:     opened = captured["position_opened"]
 21149:     assert opened["notional_usdt"] >= 5
 21150:     assert opened["vol"] >= 1
 21151: 
 21152: 
 21153: def test_attempt_entry_insufficient_margin(monkeypatch):
 21154:     captured = {}
 21155: 
 21156:     def fake_notify(event, payload):
 21157:         captured[event] = payload
 21158: 
 21159:     monkeypatch.setattr("bot.notify", fake_notify)
 21160:     client = DummyClient()
 21161:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 21162:     rm = DummyRisk(0.02)
 21163:     equity = 100
 21164:     available = 1.0  # below required margin
 21165:     params = attempt_entry(
 21166:         client,
 21167:         _detail(),
 21168:         sig,
 21169:         equity_usdt=equity,
 21170:         available_usdt=available,
 21171:         cfg={"LEVERAGE": 10},
 21172:         risk_mgr=rm,
 21173:         user_risk_level=1,
 21174:     )
 21175:     assert client.last_order is None
 21176:     assert params["vol"] == 0
 21177:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 21178: 
 21179: 
 21180: def test_attempt_entry_under_min_trade(monkeypatch):
 21181:     captured = {}
 21182: 
 21183:     def fake_notify(event, payload):
 21184:         captured[event] = payload
 21185: 
 21186:     monkeypatch.setattr("bot.notify", fake_notify)
 21187:     client = DummyClient()
 21188:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 21189:     rm = DummyRisk(0.02)
 21190:     detail = {
 21191:         "data": [
 21192:             {
 21193:                 "symbol": "BTC_USDT",
 21194:                 "contractSize": 0.001,
 21195:                 "volUnit": 1,
 21196:                 "minVol": 1,
 21197:                 "minTradeUSDT": 50,
 21198:             }
 21199:         ]
 21200:     }
 21201:     equity = 100
 21202:     available = 100
 21203:     params = attempt_entry(
 21204:         client,
 21205:         detail,
 21206:         sig,
 21207:         equity_usdt=equity,
 21208:         available_usdt=available,
 21209:         cfg={"LEVERAGE": 10},
 21210:         risk_mgr=rm,
 21211:         user_risk_level=1,
 21212:     )
 21213:     assert client.last_order is None
 21214:     assert params["vol"] == 0
 21215:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
 21216: 
 21217: 
 21218: --------------------------------------------------------------------------------
 21219: FILE: tests/test_bot_update.py
 21220: --------------------------------------------------------------------------------
 21221: import logging
 21222: import bot
 21223: 
 21224: 
 21225: def test_update_displays_pairs(monkeypatch, caplog):
 21226:     def fake_send(client, top_n=40):
 21227:         assert (client, top_n) == ("cli", 5)
 21228:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
 21229: 
 21230:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
 21231:     with caplog.at_level(logging.INFO):
 21232:         payload = bot.update("cli", top_n=5)
 21233:     assert payload["green"] == "BTC"
 21234:     assert "Listing ok" in caplog.text
 21235: 
 21236: 
 21237: def test_update_survives_errors(monkeypatch, caplog):
 21238:     """``update`` should never raise even if pair selection fails."""
 21239: 
 21240:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
 21241:         raise RuntimeError("network down")
 21242: 
 21243:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
 21244:     with caplog.at_level(logging.INFO):
 21245:         payload = bot.update("cli", top_n=5)
 21246: 
 21247:     # The function returns an empty payload and logs the error, but still logs
 21248:     # the "Listing ok" acknowledgement so callers can proceed.
 21249:     assert payload == {}
 21250:     assert "network down" in caplog.text
 21251:     assert "Listing ok" in caplog.text
 21252: 
 21253: 
 21254: 
 21255: --------------------------------------------------------------------------------
 21256: FILE: tests/test_break_even_stop.py
 21257: --------------------------------------------------------------------------------
 21258: from scalper.trade_utils import break_even_stop
 21259: 
 21260: 
 21261: def test_break_even_stop_long() -> None:
 21262:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
 21263:     assert sl == 100
 21264:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
 21265:     assert sl == 95
 21266: 
 21267: 
 21268: def test_break_even_stop_short() -> None:
 21269:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
 21270:     assert sl == 100
 21271:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
 21272:     assert sl == 105
 21273: 
 21274: 
 21275: --------------------------------------------------------------------------------
 21276: FILE: tests/test_calc_pnl_pct.py
 21277: --------------------------------------------------------------------------------
 21278: import os
 21279: import sys
 21280: import pytest
 21281: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 21282: 
 21283: from scalper.metrics import calc_pnl_pct
 21284: 
 21285: 
 21286: def test_calc_pnl_pct_long():
 21287:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
 21288: 
 21289: def test_calc_pnl_pct_short():
 21290:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
 21291: 
 21292: 
 21293: def test_calc_pnl_pct_with_fee():
 21294:     # 10% move minus 0.1%*2 fees = 9.8%
 21295:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)
 21296: 
 21297: 
 21298: --------------------------------------------------------------------------------
 21299: FILE: tests/test_check_config.py
 21300: --------------------------------------------------------------------------------
 21301: import logging
 21302: from bot import check_config
 21303: 
 21304: 
 21305: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
 21306:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
 21307:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
 21308:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 21309:     with caplog.at_level(logging.INFO):
 21310:         check_config()
 21311:     messages = [r.getMessage() for r in caplog.records]
 21312:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
 21313:     assert any("BITGET_SECRET_KEY" in m for m in messages)
 21314:     assert all("NOTIFY_URL" not in m for m in messages)
 21315: 
 21316: 
 21317: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
 21318:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
 21319:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
 21320:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
 21321:     with caplog.at_level(logging.INFO):
 21322:         check_config()
 21323:     assert caplog.records == []
 21324: 
 21325: 
 21326: --------------------------------------------------------------------------------
 21327: FILE: tests/test_cli.py
 21328: --------------------------------------------------------------------------------
 21329: """Tests for the command line interface defined in :mod:`cli`."""
 21330: 
 21331: from __future__ import annotations
 21332: 
 21333: import cli
 21334: 
 21335: 
 21336: def test_opt_invokes_parallel_optimization(monkeypatch):
 21337:     """The ``opt`` command should call ``run_parallel_optimization``."""
 21338: 
 21339:     called = {}
 21340: 
 21341:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
 21342:         called["args"] = (pairs, tf, jobs)
 21343: 
 21344:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
 21345:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
 21346:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
 21347: 
 21348: 
 21349: def test_walkforward_invokes_analysis(monkeypatch):
 21350:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
 21351: 
 21352:     called = {}
 21353: 
 21354:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
 21355:         called["args"] = (pair, tf, splits, train_ratio)
 21356: 
 21357:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
 21358:     cli.main(
 21359:         [
 21360:             "walkforward",
 21361:             "--pair",
 21362:             "BTCUSDT",
 21363:             "--tf",
 21364:             "1m",
 21365:             "--splits",
 21366:             "3",
 21367:             "--train-ratio",
 21368:             "0.8",
 21369:         ]
 21370:     )
 21371:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
 21372: 
 21373: 
 21374: def test_live_invokes_async_pipeline(monkeypatch):
 21375:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
 21376: 
 21377:     called = {}
 21378: 
 21379:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
 21380:         called["args"] = (pairs, list(tfs))
 21381: 
 21382:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
 21383:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
 21384:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
 21385: 
 21386: 
 21387: def test_bump_version_invokes_helper(monkeypatch):
 21388:     """The ``bump-version`` command calls ``bump_version_from_git``."""
 21389: 
 21390:     called = {}
 21391: 
 21392:     def fake_bump():  # pragma: no cover - executed via CLI
 21393:         called["called"] = True
 21394:         return "0.1.0"
 21395: 
 21396:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
 21397:     cli.main(["bump-version"])
 21398:     assert called["called"] is True
 21399: 
 21400: 
 21401: 
 21402: --------------------------------------------------------------------------------
 21403: FILE: tests/test_client.py
 21404: --------------------------------------------------------------------------------
 21405: import json
 21406: import hmac
 21407: import hashlib
 21408: import base64
 21409: import pytest
 21410: import bot
 21411: from bot import BitgetFuturesClient
 21412: 
 21413: 
 21414: @pytest.fixture(autouse=True)
 21415: def no_log_event(monkeypatch):
 21416:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
 21417: 
 21418: 
 21419: def test_private_request_get_signature(monkeypatch):
 21420:     client = BitgetFuturesClient("key", "secret", "https://test")
 21421:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 21422: 
 21423:     called = {}
 21424: 
 21425:     def fake_request(method, url, headers=None, timeout=None):
 21426:         called["method"] = method
 21427:         called["url"] = url
 21428:         called["headers"] = headers
 21429: 
 21430:         class Resp:
 21431:             def raise_for_status(self):
 21432:                 pass
 21433: 
 21434:             def json(self):
 21435:                 return {"success": True}
 21436: 
 21437:         return Resp()
 21438: 
 21439:     monkeypatch.setattr(bot.requests, "request", fake_request)
 21440: 
 21441:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
 21442:     assert resp["success"] is True
 21443:     qs = "a=1&b=2"
 21444:     prehash = f"1000GET/api/test?{qs}"
 21445:     expected = base64.b64encode(
 21446:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 21447:     ).decode()
 21448:     assert called["headers"]["ACCESS-SIGN"] == expected
 21449:     assert called["headers"]["ACCESS-KEY"] == "key"
 21450:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 21451:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 21452:     assert called["url"] == "https://test/api/test?a=1&b=2"
 21453: 
 21454: 
 21455: def test_private_request_post_signature(monkeypatch):
 21456:     client = BitgetFuturesClient("key", "secret", "https://test")
 21457:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 21458: 
 21459:     called = {}
 21460: 
 21461:     def fake_post(url, data=None, headers=None, timeout=None):
 21462:         called["url"] = url
 21463:         called["data"] = data
 21464:         called["headers"] = headers
 21465: 
 21466:         class Resp:
 21467:             def raise_for_status(self):
 21468:                 pass
 21469: 
 21470:             def json(self):
 21471:                 return {"success": True}
 21472: 
 21473:         return Resp()
 21474: 
 21475:     monkeypatch.setattr(bot.requests, "post", fake_post)
 21476: 
 21477:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
 21478:     assert resp["success"] is True
 21479:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
 21480:     prehash = f"1000POST/api/test{body}"
 21481:     expected = base64.b64encode(
 21482:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
 21483:     ).decode()
 21484:     assert called["headers"]["ACCESS-SIGN"] == expected
 21485:     assert called["headers"]["ACCESS-KEY"] == "key"
 21486:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
 21487:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
 21488:     assert called["data"].decode("utf-8") == body
 21489:     assert called["url"] == "https://test/api/test"
 21490: 
 21491: 
 21492: def test_private_request_http_error(monkeypatch):
 21493:     client = BitgetFuturesClient("key", "secret", "https://test")
 21494:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
 21495: 
 21496:     class Resp:
 21497:         status_code = 418
 21498: 
 21499:         def raise_for_status(self):
 21500:             raise bot.requests.HTTPError("teapot")
 21501: 
 21502:         def json(self):
 21503:             return {"unused": True}
 21504: 
 21505:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
 21506: 
 21507:     resp = client._private_request("GET", "/api/test")
 21508:     assert resp["success"] is False
 21509:     assert resp["status_code"] == 418
 21510:     assert "teapot" in resp["error"]
 21511: 
 21512: 
 21513: def test_get_assets_normalization(monkeypatch):
 21514:     client = BitgetFuturesClient("key", "secret", "https://test")
 21515: 
 21516:     called = {}
 21517: 
 21518:     def fake_private(self, method, path, params=None, body=None):
 21519:         called["method"] = method
 21520:         called["path"] = path
 21521:         called["params"] = params
 21522:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
 21523: 
 21524:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21525: 
 21526:     assets = client.get_assets()
 21527: 
 21528:     assert assets["success"] is True
 21529:     usdt = assets.get("data", [])[0]
 21530:     assert usdt["currency"].upper() == "USDT"
 21531:     assert usdt["equity"] == 1.0
 21532:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
 21533: 
 21534: 
 21535: def test_get_assets_equity_fallback(monkeypatch):
 21536:     client = BitgetFuturesClient("key", "secret", "https://test")
 21537: 
 21538:     def fake_private(self, method, path, params=None, body=None):
 21539:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
 21540: 
 21541:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21542: 
 21543:     assets = client.get_assets()
 21544:     usdt = assets.get("data", [])[0]
 21545:     assert usdt["currency"] == "USDT"
 21546:     assert usdt["equity"] == 2.0
 21547: 
 21548: 
 21549: def test_get_assets_prefers_available(monkeypatch):
 21550:     """When both equity and available are returned, available should win."""
 21551:     client = BitgetFuturesClient("key", "secret", "https://test")
 21552: 
 21553:     def fake_private(self, method, path, params=None, body=None):
 21554:         return {
 21555:             "code": "00000",
 21556:             "data": [
 21557:                 {
 21558:                     "marginCoin": "USDT",
 21559:                     "equity": "5",
 21560:                     "available": "1",
 21561:                 }
 21562:             ],
 21563:         }
 21564: 
 21565:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21566: 
 21567:     assets = client.get_assets()
 21568:     usdt = assets.get("data", [])[0]
 21569:     assert usdt["equity"] == 1.0
 21570: 
 21571: 
 21572: 
 21573: def test_get_assets_zero_available(monkeypatch):
 21574:     """Zero available balance should propagate as zero equity."""
 21575:     client = BitgetFuturesClient("key", "secret", "https://test")
 21576: 
 21577:     def fake_private(self, method, path, params=None, body=None):
 21578:         return {
 21579:             "code": "00000",
 21580:             "data": [
 21581:                 {
 21582:                     "marginCoin": "USDT",
 21583:                     "available": "0",
 21584:                     "equity": "5",
 21585:                 }
 21586:             ],
 21587:         }
 21588: 
 21589:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21590: 
 21591:     assets = client.get_assets()
 21592:     usdt = assets.get("data", [])[0]
 21593:     assert usdt["equity"] == 0.0
 21594: 
 21595: 
 21596: def test_get_assets_available_balance(monkeypatch):
 21597:     """Support alternative ``availableBalance`` field name."""
 21598:     client = BitgetFuturesClient("key", "secret", "https://test")
 21599: 
 21600:     def fake_private(self, method, path, params=None, body=None):
 21601:         return {
 21602:             "code": "00000",
 21603:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
 21604:         }
 21605: 
 21606:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21607: 
 21608:     assets = client.get_assets()
 21609:     usdt = assets.get("data", [])[0]
 21610:     assert usdt["equity"] == 3.5
 21611: 
 21612: 
 21613: def test_get_ticker_normalization(monkeypatch):
 21614:     client = BitgetFuturesClient("key", "secret", "https://test")
 21615: 
 21616:     called = {}
 21617: 
 21618:     def fake_get(url, params=None, timeout=None):
 21619:         called["url"] = url
 21620:         called["params"] = params
 21621: 
 21622:         class Resp:
 21623:             def raise_for_status(self):
 21624:                 pass
 21625: 
 21626:             def json(self):
 21627:                 return {
 21628:                     "data": {
 21629:                         "instId": "BTCUSDT",
 21630:                         "lastPr": "1",
 21631:                         "bestBidPrice": "0.9",
 21632:                         "bestAskPrice": "1.1",
 21633:                         "usdtVolume": "100",
 21634:                     }
 21635:                 }
 21636: 
 21637:         return Resp()
 21638: 
 21639:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 21640: 
 21641:     ticker = client.get_ticker("BTC_USDT")
 21642: 
 21643:     assert ticker["success"] is True
 21644:     data = ticker["data"][0]
 21645:     assert data["symbol"] == "BTCUSDT"
 21646:     assert data["lastPrice"] == "1"
 21647:     assert data["bidPrice"] == "0.9"
 21648:     assert data["askPrice"] == "1.1"
 21649:     assert data["volume"] == 100.0
 21650:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
 21651: 
 21652: 
 21653: def test_http_client_context_manager(monkeypatch):
 21654:     import sys
 21655:     import importlib
 21656:     sys.modules.pop('requests', None)
 21657:     real_requests = importlib.import_module('requests')
 21658:     sys.modules['requests'] = real_requests
 21659:     import scalper.client as http_client
 21660:     importlib.reload(http_client)
 21661: 
 21662:     closed = {"count": 0}
 21663: 
 21664:     class DummySession:
 21665:         def mount(self, *a, **k):
 21666:             pass
 21667: 
 21668:         def request(self, *a, **k):
 21669:             class Resp:
 21670:                 def raise_for_status(self):
 21671:                     pass
 21672: 
 21673:                 def json(self):
 21674:                     return {}
 21675: 
 21676:                 text = "{}"
 21677: 
 21678:             return Resp()
 21679: 
 21680:         def close(self):
 21681:             closed["count"] += 1
 21682: 
 21683:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
 21684: 
 21685:     http = http_client.HttpClient("http://example.com")
 21686:     http.close()
 21687:     assert closed["count"] == 1
 21688: 
 21689:     closed["count"] = 0
 21690:     with http_client.HttpClient("http://example.com") as hc:
 21691:         hc.request("GET", "/")
 21692:     assert closed["count"] == 1
 21693: 
 21694: 
 21695: def test_get_kline_query_params(monkeypatch):
 21696:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
 21697:     query parameter. The previous implementation embedded the symbol in the
 21698:     path which resulted in a 404 from Bitget."""
 21699: 
 21700:     client = BitgetFuturesClient("key", "secret", "https://test")
 21701: 
 21702:     called = {}
 21703: 
 21704:     def fake_get(url, params=None, timeout=None):
 21705:         called["url"] = url
 21706:         called["params"] = params
 21707: 
 21708:         class Resp:
 21709:             def raise_for_status(self):
 21710:                 pass
 21711: 
 21712:             def json(self):
 21713:                 return {"data": []}
 21714: 
 21715:         return Resp()
 21716: 
 21717:     # Some tests replace ``bot.requests`` with a lightweight namespace that
 21718:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
 21719:     # even if missing so we can observe the call.
 21720:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 21721: 
 21722:     client.get_kline("BTC_USDT", interval="Min1")
 21723: 
 21724:     assert called["url"].endswith("/api/v2/mix/market/candles")
 21725:     assert called["params"] == {
 21726:         "symbol": "BTCUSDT",
 21727:         "productType": "USDT-FUTURES",
 21728:         "granularity": "1m",
 21729:     }
 21730: 
 21731: 
 21732: def test_get_open_orders_endpoint(monkeypatch):
 21733:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21734: 
 21735:     called = {}
 21736: 
 21737:     def fake_private(self, method, path, params=None, body=None):
 21738:         called["method"] = method
 21739:         called["path"] = path
 21740:         called["params"] = params
 21741:         return {"success": True}
 21742: 
 21743:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21744: 
 21745:     client.get_open_orders("BTCUSDT_UMCBL")
 21746: 
 21747:     assert called["path"] == "/api/v2/mix/order/orders-pending"
 21748:     assert called["params"] == {
 21749:         "productType": "USDT-FUTURES",
 21750:         "symbol": "BTCUSDT",
 21751:     }
 21752: 
 21753: 
 21754: def test_product_type_alias():
 21755:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
 21756:     assert client.product_type == "USDT-FUTURES"
 21757: 
 21758: 
 21759: def test_get_contract_detail_endpoint(monkeypatch):
 21760:     client = BitgetFuturesClient("key", "secret", "https://test")
 21761: 
 21762:     called = {}
 21763: 
 21764:     def fake_get(url, params=None, timeout=None):
 21765:         called["url"] = url
 21766:         called["params"] = params
 21767: 
 21768:         class Resp:
 21769:             status_code = 200
 21770: 
 21771:             def raise_for_status(self):
 21772:                 pass
 21773: 
 21774:             def json(self):
 21775:                 return {"data": []}
 21776: 
 21777:         return Resp()
 21778: 
 21779:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 21780: 
 21781:     client.get_contract_detail("BTCUSDT_UMCBL")
 21782: 
 21783:     assert called["url"].endswith("/api/v2/mix/market/contracts")
 21784:     assert called["params"] == {
 21785:         "productType": "USDT-FUTURES",
 21786:         "symbol": "BTCUSDT",
 21787:     }
 21788: 
 21789: 
 21790: def test_cancel_all_endpoint(monkeypatch):
 21791:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21792: 
 21793:     called = {}
 21794: 
 21795:     def fake_private(self, method, path, params=None, body=None):
 21796:         called["method"] = method
 21797:         called["path"] = path
 21798:         called["params"] = params
 21799:         called["body"] = body
 21800:         return {"success": True}
 21801: 
 21802:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21803: 
 21804:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 21805: 
 21806:     assert called["method"] == "POST"
 21807:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
 21808:     assert called["params"] is None
 21809:     assert called["body"] == {
 21810:         "productType": "USDT-FUTURES",
 21811:         "symbol": "BTCUSDT",
 21812:         "marginCoin": "USDT",
 21813:     }
 21814: 
 21815: 
 21816: def test_place_order_endpoint(monkeypatch):
 21817:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21818: 
 21819:     called = {}
 21820: 
 21821:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 21822: 
 21823:     def fake_private(self, method, path, params=None, body=None):
 21824:         called["method"] = method
 21825:         called["path"] = path
 21826:         called["body"] = body
 21827:         return {"success": True}
 21828: 
 21829:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21830: 
 21831:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
 21832: 
 21833:     assert resp["success"] is True
 21834:     assert called["method"] == "POST"
 21835:     assert called["path"] == "/api/v2/mix/order/place-order"
 21836:     body = called["body"]
 21837:     assert body["symbol"] == "BTCUSDT"
 21838:     assert body["marginCoin"] == "USDT"
 21839:     assert body["marginMode"] == "crossed"
 21840:     assert body["side"] == "buy"
 21841:     assert body["posSide"] == "long"
 21842:     assert "reduceOnly" not in body
 21843:     assert body["posMode"] == "hedge_mode"
 21844: 
 21845: 
 21846: @pytest.mark.parametrize(
 21847:     "code, side_str, pos_side",
 21848:     [
 21849:         (4, "sell", "long"),
 21850:         (2, "buy", "short"),
 21851:     ],
 21852: )
 21853: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
 21854:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21855: 
 21856:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
 21857: 
 21858:     called = {}
 21859: 
 21860:     def fake_private(self, method, path, params=None, body=None):
 21861:         called["body"] = body
 21862:         return {"success": True}
 21863: 
 21864:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21865: 
 21866:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
 21867: 
 21868:     body = called["body"]
 21869:     assert body["side"] == side_str
 21870:     assert body["posSide"] == pos_side
 21871:     assert "reduceOnly" not in body
 21872: 
 21873: 
 21874: def test_place_order_precision(monkeypatch):
 21875:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21876: 
 21877:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
 21878: 
 21879:     called = {}
 21880: 
 21881:     def fake_private(self, method, path, params=None, body=None):
 21882:         called["body"] = body
 21883:         return {"success": True}
 21884: 
 21885:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21886: 
 21887:     client.place_order(
 21888:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
 21889:     )
 21890: 
 21891:     assert called["body"]["price"] == 1234.57
 21892:     assert called["body"]["size"] == 1.235
 21893: 
 21894: 
 21895: def test_margin_cap_skips_order(monkeypatch):
 21896:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21897:     called = {}
 21898: 
 21899:     def fake_private(method, path, **kwargs):
 21900:         called["path"] = path
 21901:         return {"code": "00000"}
 21902: 
 21903:     monkeypatch.setattr(client, "_private_request", fake_private)
 21904:     contract_detail = {
 21905:         "data": {
 21906:             "symbol": "BTCUSDT_UMCBL",
 21907:             "contractSize": 1,
 21908:             "volUnit": 1,
 21909:             "minVol": 1,
 21910:             "minTradeUSDT": 5,
 21911:         }
 21912:     }
 21913:     price = 100.0
 21914:     available = 0.5
 21915:     vol = bot.compute_position_size(
 21916:         contract_detail,
 21917:         equity_usdt=available,
 21918:         price=price,
 21919:         risk_pct=1.0,
 21920:         leverage=10,
 21921:         symbol="BTCUSDT_UMCBL",
 21922:         available_usdt=available,
 21923:     )
 21924:     if vol > 0:
 21925:         client.place_order(
 21926:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
 21927:         )
 21928:     assert called == {}
 21929: 
 21930: 
 21931: def test_margin_cap_reduces_volume(monkeypatch):
 21932:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
 21933:     called = {}
 21934: 
 21935:     def fake_private(method, path, **kwargs):
 21936:         called["body"] = kwargs.get("body")
 21937:         return {"code": "00000"}
 21938: 
 21939:     monkeypatch.setattr(client, "_private_request", fake_private)
 21940:     contract_detail = {
 21941:         "data": {
 21942:             "symbol": "BTCUSDT_UMCBL",
 21943:             "contractSize": 1,
 21944:             "volUnit": 1,
 21945:             "minVol": 1,
 21946:             "minTradeUSDT": 5,
 21947:         }
 21948:     }
 21949:     price = 10.0
 21950:     vol_theoretical = bot.compute_position_size(
 21951:         contract_detail,
 21952:         equity_usdt=100,
 21953:         price=price,
 21954:         risk_pct=1.0,
 21955:         leverage=10,
 21956:         symbol="BTCUSDT_UMCBL",
 21957:     )
 21958:     available = 20.0
 21959:     vol_final = bot.compute_position_size(
 21960:         contract_detail,
 21961:         equity_usdt=available,
 21962:         price=price,
 21963:         risk_pct=1.0,
 21964:         leverage=10,
 21965:         symbol="BTCUSDT_UMCBL",
 21966:         available_usdt=available,
 21967:     )
 21968:     assert vol_final < vol_theoretical
 21969:     client.place_order(
 21970:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
 21971:     )
 21972:     assert called["body"]["size"] == vol_final
 21973: 
 21974: def test_get_open_orders_paper_trade(monkeypatch):
 21975:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 21976: 
 21977:     called = {"count": 0}
 21978: 
 21979:     def fake_private(*a, **k):
 21980:         called["count"] += 1
 21981:         return {"success": True}
 21982: 
 21983:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 21984: 
 21985:     resp = client.get_open_orders("BTCUSDT_UMCBL")
 21986: 
 21987:     assert resp["success"] is True
 21988:     assert resp["data"] == []
 21989:     assert called["count"] == 0
 21990: 
 21991: 
 21992: def test_cancel_all_paper_trade(monkeypatch):
 21993:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
 21994: 
 21995:     called = {"count": 0}
 21996: 
 21997:     def fake_private(*a, **k):
 21998:         called["count"] += 1
 21999:         return {"success": True}
 22000: 
 22001:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
 22002: 
 22003:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
 22004: 
 22005:     assert resp["success"] is True
 22006:     assert called["count"] == 0
 22007: 
 22008: 
 22009: def test_get_kline_transforms_data(monkeypatch):
 22010:     client = BitgetFuturesClient("key", "secret", "https://test")
 22011: 
 22012:     def fake_get(url, params=None, timeout=None):
 22013:         class Resp:
 22014:             def raise_for_status(self):
 22015:                 pass
 22016: 
 22017:             def json(self):
 22018:                 return {
 22019:                     "data": [
 22020:                         ["1", "2", "3", "1", "2", "10", "20"],
 22021:                         ["2", "3", "4", "2", "3", "11", "21"],
 22022:                     ]
 22023:                 }
 22024: 
 22025:         return Resp()
 22026: 
 22027:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
 22028: 
 22029:     data = client.get_kline("BTC_USDT", interval="1m")
 22030:     kdata = data["data"]
 22031:     assert kdata["open"] == [2.0, 3.0]
 22032:     assert kdata["high"] == [3.0, 4.0]
 22033:     assert kdata["low"] == [1.0, 2.0]
 22034:     assert kdata["close"] == [2.0, 3.0]
 22035:     assert kdata["volume"] == [10.0, 11.0]
 22036:     assert kdata["quoteVolume"] == [20.0, 21.0]
 22037: 
 22038: 
 22039: --------------------------------------------------------------------------------
 22040: FILE: tests/test_compute_position_size.py
 22041: --------------------------------------------------------------------------------
 22042: import os
 22043: import sys
 22044: import types
 22045: import pytest
 22046: 
 22047: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 22048: sys.modules["requests"] = types.ModuleType("requests")
 22049: import bot  # noqa: E402
 22050: from bot import compute_position_size  # noqa: E402
 22051: 
 22052: 
 22053: def test_compute_position_size_basic():
 22054:     contract_detail = {
 22055:         "data": [
 22056:             {
 22057:                 "symbol": "BTC_USDT",
 22058:                 "contractSize": 0.01,
 22059:                 "volUnit": 1,
 22060:                 "minVol": 1,
 22061:             }
 22062:         ]
 22063:     }
 22064:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
 22065:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 22066:     assert vol == 1
 22067: 
 22068: 
 22069: def test_compute_position_size_symbol_not_found():
 22070:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
 22071:     with pytest.raises(ValueError):
 22072:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
 22073:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
 22074: 
 22075: 
 22076: def test_compute_position_size_invalid_price():
 22077:     contract_detail = {
 22078:         "data": [
 22079:             {
 22080:                 "symbol": "BTC_USDT",
 22081:                 "contractSize": 0.01,
 22082:                 "volUnit": 1,
 22083:                 "minVol": 1,
 22084:             }
 22085:         ]
 22086:     }
 22087:     vol = compute_position_size(
 22088:         contract_detail,
 22089:         equity_usdt=1000,
 22090:         price=0,
 22091:         risk_pct=0.01,
 22092:         leverage=10,
 22093:         symbol="BTC_USDT",
 22094:     )
 22095:     assert vol == 0
 22096: 
 22097: 
 22098: def test_compute_position_size_respects_equity():
 22099:     contract_detail = {
 22100:         "data": [
 22101:             {
 22102:                 "symbol": "BTC_USDT",
 22103:                 "contractSize": 1,
 22104:                 "volUnit": 1,
 22105:                 "minVol": 1,
 22106:             }
 22107:         ]
 22108:     }
 22109:     vol = compute_position_size(
 22110:         contract_detail,
 22111:         equity_usdt=5,
 22112:         price=100,
 22113:         risk_pct=0.01,
 22114:         leverage=10,
 22115:         symbol="BTC_USDT",
 22116:     )
 22117:     assert vol == 0
 22118: 
 22119: 
 22120: def test_compute_position_size_leaves_fee_buffer():
 22121:     contract_detail = {
 22122:         "data": [
 22123:             {
 22124:                 "symbol": "BTC_USDT",
 22125:                 "contractSize": 1,
 22126:                 "volUnit": 1,
 22127:                 "minVol": 1,
 22128:             }
 22129:         ]
 22130:     }
 22131:     vol = compute_position_size(
 22132:         contract_detail,
 22133:         equity_usdt=100,
 22134:         price=100,
 22135:         risk_pct=1.0,
 22136:         leverage=1,
 22137:         symbol="BTC_USDT",
 22138:     )
 22139:     assert vol == 0
 22140: 
 22141: 
 22142: def test_compute_position_size_under_min_notional_returns_zero():
 22143:     contract_detail = {
 22144:         "data": [
 22145:             {
 22146:                 "symbol": "PI_USDT",
 22147:                 "contractSize": 1,
 22148:                 "volUnit": 1,
 22149:                 "minVol": 1,
 22150:                 "minTradeUSDT": 5,
 22151:             }
 22152:         ]
 22153:     }
 22154:     vol = compute_position_size(
 22155:         contract_detail,
 22156:         equity_usdt=100,
 22157:         price=0.5,
 22158:         risk_pct=0.0001,
 22159:         leverage=20,
 22160:         symbol="PI_USDT",
 22161:     )
 22162:     assert vol == 0
 22163: 
 22164: 
 22165: def test_compute_position_size_cap_by_available():
 22166:     contract_detail = {
 22167:         "data": [
 22168:             {
 22169:                 "symbol": "BTC_USDT",
 22170:                 "contractSize": 1,
 22171:                 "volUnit": 2,
 22172:                 "minVol": 2,
 22173:                 "minTradeUSDT": 5,
 22174:             }
 22175:         ]
 22176:     }
 22177:     vol = compute_position_size(
 22178:         contract_detail,
 22179:         equity_usdt=100,
 22180:         price=10,
 22181:         risk_pct=0.5,
 22182:         leverage=10,
 22183:         symbol="BTC_USDT",
 22184:         available_usdt=0.5,
 22185:     )
 22186:     assert vol == 0
 22187:     vol = compute_position_size(
 22188:         contract_detail,
 22189:         equity_usdt=100,
 22190:         price=10,
 22191:         risk_pct=0.5,
 22192:         leverage=10,
 22193:         symbol="BTC_USDT",
 22194:         available_usdt=10,
 22195:     )
 22196:     assert vol == 8
 22197:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
 22198:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
 22199:     assert required <= 10
 22200: 
 22201: 
 22202: --------------------------------------------------------------------------------
 22203: FILE: tests/test_compute_position_size_cap.py
 22204: --------------------------------------------------------------------------------
 22205: import os
 22206: import sys
 22207: import types
 22208: import pytest
 22209: 
 22210: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 22211: sys.modules['requests'] = types.ModuleType('requests')
 22212: 
 22213: from bot import compute_position_size, CONFIG
 22214: 
 22215: 
 22216: def _detail(vol_unit=1, min_vol=1, min_trade=5):
 22217:     return {
 22218:         "data": [
 22219:             {
 22220:                 "symbol": "BTC_USDT",
 22221:                 "contractSize": 0.001,
 22222:                 "volUnit": vol_unit,
 22223:                 "minVol": min_vol,
 22224:                 "minTradeUSDT": min_trade,
 22225:             }
 22226:         ]
 22227:     }
 22228: 
 22229: 
 22230: def test_volume_zero_when_available_low():
 22231:     detail = _detail()
 22232:     vol = compute_position_size(
 22233:         detail,
 22234:         equity_usdt=1000,
 22235:         price=10000,
 22236:         risk_pct=0.01,
 22237:         leverage=10,
 22238:         symbol="BTC_USDT",
 22239:         available_usdt=0.5,
 22240:     )
 22241:     assert vol == 0
 22242: 
 22243: 
 22244: def test_margin_close_to_available():
 22245:     detail = _detail()
 22246:     CONFIG["FEE_RATE"] = 0.001
 22247:     available = 1.05
 22248:     vol = compute_position_size(
 22249:         detail,
 22250:         equity_usdt=1000,
 22251:         price=10000,
 22252:         risk_pct=1,
 22253:         leverage=10,
 22254:         symbol="BTC_USDT",
 22255:         available_usdt=available,
 22256:     )
 22257:     assert vol == 1
 22258:     notional = 10000 * 0.001 * vol
 22259:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
 22260:     required = (notional / 10 + fee) * 1.03
 22261:     assert required == pytest.approx(available, rel=0.05)
 22262: 
 22263: 
 22264: def test_respects_units_and_minimums():
 22265:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
 22266:     vol = compute_position_size(
 22267:         detail,
 22268:         equity_usdt=1000,
 22269:         price=1000,
 22270:         risk_pct=1,
 22271:         leverage=5,
 22272:         symbol="BTC_USDT",
 22273:         available_usdt=1000,
 22274:     )
 22275:     assert vol % 2 == 0 and vol >= 2
 22276: 
 22277: 
 22278: --------------------------------------------------------------------------------
 22279: FILE: tests/test_dynamic_allocation.py
 22280: --------------------------------------------------------------------------------
 22281: import math
 22282: from scalper.risk import adjust_risk_pct
 22283: 
 22284: 
 22285: def test_adjust_risk_pct_increase_decrease():
 22286:     base = 0.01
 22287:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
 22288:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
 22289: 
 22290: 
 22291: def test_adjust_risk_pct_bounds():
 22292:     assert math.isclose(
 22293:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
 22294:     )
 22295:     assert math.isclose(
 22296:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
 22297:     )
 22298: 
 22299: 
 22300: --------------------------------------------------------------------------------
 22301: FILE: tests/test_effective_leverage.py
 22302: --------------------------------------------------------------------------------
 22303: import pytest
 22304: from scalper.trade_utils import effective_leverage
 22305: 
 22306: 
 22307: def test_effective_leverage_basic():
 22308:     lev = effective_leverage(
 22309:         entry_price=100.0,
 22310:         liquidation_price=90.0,
 22311:         position_margin=10.0,
 22312:         position_size=1.0,
 22313:     )
 22314:     assert lev == pytest.approx(10.0)
 22315: 
 22316: 
 22317: def test_effective_leverage_estimated_margin():
 22318:     lev = effective_leverage(
 22319:         entry_price=200.0,
 22320:         liquidation_price=180.0,
 22321:         position_margin=0.0,
 22322:         position_size=2.0,
 22323:     )
 22324:     # price diff 20 * size 2 -> margin 40; notional 400
 22325:     assert lev == pytest.approx(10.0)
 22326: 
 22327: 
 22328: def test_effective_leverage_short_position():
 22329:     lev = effective_leverage(
 22330:         entry_price=100.0,
 22331:         liquidation_price=110.0,
 22332:         position_margin=10.0,
 22333:         position_size=-1.5,
 22334:     )
 22335:     assert lev == pytest.approx(15.0)
 22336: 
 22337: 
 22338: def test_effective_leverage_invalid():
 22339:     assert effective_leverage(0, 0, 0, 0) == 0.0
 22340: 
 22341: 
 22342: --------------------------------------------------------------------------------
 22343: FILE: tests/test_env_loading.py
 22344: --------------------------------------------------------------------------------
 22345: """Tests for loading environment variables from ``notebook/.env``."""
 22346: 
 22347: from __future__ import annotations
 22348: 
 22349: import importlib
 22350: import os
 22351: import sys
 22352: from pathlib import Path
 22353: 
 22354: 
 22355: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
 22356:     """Module should load variables from ``notebook/.env`` if present."""
 22357: 
 22358:     notebook = tmp_path / "notebook"
 22359:     spot = notebook / "spot"
 22360:     spot.mkdir(parents=True)
 22361:     bitget_bot = spot / "bitget_bot.py"
 22362:     bitget_bot.write_text("")
 22363:     env_file = notebook / ".env"
 22364:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
 22365: 
 22366:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
 22367:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
 22368:     import scalp
 22369: 
 22370:     importlib.reload(scalp)
 22371: 
 22372:     try:
 22373:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
 22374:     finally:
 22375:         env_file.unlink(missing_ok=True)
 22376:         if old is None:
 22377:             os.environ.pop("BITGET_ACCESS_KEY", None)
 22378:         else:
 22379:             os.environ["BITGET_ACCESS_KEY"] = old
 22380: 
 22381: 
 22382: --------------------------------------------------------------------------------
 22383: FILE: tests/test_grid_search.py
 22384: --------------------------------------------------------------------------------
 22385: import json
 22386: import random
 22387: 
 22388: import pytest
 22389: 
 22390: from scalper.backtest import grid_search
 22391: 
 22392: 
 22393: def test_build_grid_sampling():
 22394:     param_lists = {
 22395:         "timeframe": ["1m", "5m", "15m"],
 22396:         "score_min": [50, 55, 60],
 22397:         "atr_min_ratio": [0.0015, 0.002, 0.003],
 22398:     }
 22399:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
 22400:     assert len(combos) == 6
 22401:     tfs = {c["timeframe"] for c in combos}
 22402:     assert {"1m", "5m", "15m"}.issubset(tfs)
 22403: 
 22404: 
 22405: def test_run_grid_search_with_mock(tmp_path):
 22406:     calls = []
 22407: 
 22408:     def fake_run_backtest_multi(**kwargs):
 22409:         tf = kwargs.get("timeframe")
 22410:         risk = kwargs.get("risk_pct")
 22411:         # fabricate metrics based on params
 22412:         pf = {"1m": 1.5, "5m": 3.0}[tf]
 22413:         pf += risk  # tiny variation
 22414:         metrics = {
 22415:             "symbol": "TOTAL",
 22416:             "pnl_usdt": 100 * risk,
 22417:             "profit_factor": pf,
 22418:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
 22419:             "winrate_pct": 50.0,
 22420:             "trades": 40 if tf == "1m" else 30,
 22421:         }
 22422:         calls.append((tf, risk))
 22423:         return [metrics], []
 22424: 
 22425:     param_lists = {
 22426:         "timeframe": ["1m", "5m"],
 22427:         "risk_pct": [0.005, 0.01],
 22428:     }
 22429:     base_params = {
 22430:         "timeframe": "1m",
 22431:         "risk_pct": 0.005,
 22432:     }
 22433:     out_dir = tmp_path / "grid"
 22434:     grid_search.run_grid_search(
 22435:         symbols=["BTC/USDT"],
 22436:         exchange="csv",
 22437:         base_params=base_params,
 22438:         param_lists=param_lists,
 22439:         grid_max=4,
 22440:         csv_dir="/dev/null",
 22441:         out_dir=str(out_dir),
 22442:         run_func=fake_run_backtest_multi,
 22443:     )
 22444:     best = json.loads((out_dir / "best_config.json").read_text())
 22445:     # best PF should be timeframe 5m risk 0.01
 22446:     assert best["params"]["timeframe"] == "5m"
 22447:     assert best["params"]["risk_pct"] == 0.01
 22448:     assert len(calls) == 4
 22449: 
 22450: 
 22451: def test_parse_hours():
 22452:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
 22453: 
 22454: 
 22455: def test_deterministic_results(tmp_path):
 22456:     def fake_run_backtest_multi(**kwargs):
 22457:         # metrics vary with global random state
 22458:         pf = random.uniform(1.0, 3.0)
 22459:         metrics = {
 22460:             "symbol": "TOTAL",
 22461:             "pnl_usdt": random.uniform(-10, 10),
 22462:             "profit_factor": pf,
 22463:             "max_drawdown_pct": random.uniform(1, 5),
 22464:             "winrate_pct": 50.0,
 22465:             "trades": random.randint(10, 50),
 22466:         }
 22467:         return [metrics], []
 22468: 
 22469:     param_lists = {"timeframe": ["1m", "5m"]}
 22470:     base_params = {"timeframe": "1m"}
 22471:     out_dir = tmp_path / "grid"
 22472:     res1 = grid_search.run_grid_search(
 22473:         symbols=["BTC/USDT"],
 22474:         exchange="csv",
 22475:         base_params=base_params,
 22476:         param_lists=param_lists,
 22477:         grid_max=2,
 22478:         csv_dir="/dev/null",
 22479:         out_dir=str(out_dir),
 22480:         seed=42,
 22481:         run_func=fake_run_backtest_multi,
 22482:     )
 22483:     best1 = json.loads((out_dir / "best_config.json").read_text())
 22484:     # run again
 22485:     out_dir2 = tmp_path / "grid2"
 22486:     res2 = grid_search.run_grid_search(
 22487:         symbols=["BTC/USDT"],
 22488:         exchange="csv",
 22489:         base_params=base_params,
 22490:         param_lists=param_lists,
 22491:         grid_max=2,
 22492:         csv_dir="/dev/null",
 22493:         out_dir=str(out_dir2),
 22494:         seed=42,
 22495:         run_func=fake_run_backtest_multi,
 22496:     )
 22497:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
 22498:     assert best1 == best2
 22499:     # also ensure results object same best params
 22500:     assert res1[0].params == res2[0].params
 22501: 
 22502: 
 22503: --------------------------------------------------------------------------------
 22504: FILE: tests/test_heat_score.py
 22505: --------------------------------------------------------------------------------
 22506: from scalper.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
 22507: 
 22508: 
 22509: def test_heat_score_value():
 22510:     assert heat_score(2.0, 100.0) == 200.0
 22511:     assert heat_score(2.0, 100.0, news=True) == 400.0
 22512: 
 22513: 
 22514: def test_select_and_decorrelate_pairs():
 22515:     pairs = [
 22516:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
 22517:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
 22518:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
 22519:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
 22520:     ]
 22521:     top = select_top_heat_pairs(pairs, top_n=3)
 22522:     assert len(top) == 3
 22523:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
 22524:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
 22525:     syms = {p["symbol"] for p in selected}
 22526:     assert not ("A" in syms and "B" in syms)
 22527: 
 22528: 
 22529: --------------------------------------------------------------------------------
 22530: FILE: tests/test_indicators.py
 22531: --------------------------------------------------------------------------------
 22532: 
 22533: 
 22534: import os
 22535: import sys
 22536: import pytest
 22537: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 22538: 
 22539: 
 22540: 
 22541: 
 22542: from scalper.metrics import calc_rsi, calc_atr, calc_macd
 22543: 
 22544: 
 22545: def test_calc_rsi_uptrend():
 22546:     prices = list(range(1, 16))  # strictly increasing
 22547:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
 22548: 
 22549: 
 22550: def test_calc_rsi_downtrend():
 22551:     prices = list(range(15, 0, -1))  # strictly decreasing
 22552:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
 22553: 
 22554: 
 22555: 
 22556: def test_calc_rsi_flat():
 22557:     prices = [1.0] * 15  # no movement
 22558:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
 22559: 
 22560: 
 22561: 
 22562:     highs = [10, 11, 12, 13, 14]
 22563:     lows = [9, 10, 11, 12, 13]
 22564:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
 22565:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
 22566: 
 22567: 
 22568: def test_calc_macd_trend():
 22569:     prices = list(range(1, 60))
 22570:     macd, signal, hist = calc_macd(prices)
 22571:     assert macd > signal
 22572:     assert hist > 0
 22573: 
 22574: 
 22575: def test_calc_macd_flat():
 22576:     prices = [100.0] * 60
 22577:     macd, signal, hist = calc_macd(prices)
 22578:     assert macd == pytest.approx(0.0)
 22579:     assert signal == pytest.approx(0.0)
 22580:     assert hist == pytest.approx(0.0)
 22581: 
 22582: 
 22583: 
 22584: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
 22585: def test_calc_rsi_invalid_inputs(prices, period):
 22586:     with pytest.raises(ValueError):
 22587:         calc_rsi(prices, period=period)
 22588: 
 22589: 
 22590: @pytest.mark.parametrize(
 22591:     "highs, lows, closes, period",
 22592:     [
 22593:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
 22594:         ([1, 2], [1, 1], [1, 1], 3),
 22595:     ],
 22596: )
 22597: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
 22598:     with pytest.raises(ValueError):
 22599:         calc_atr(highs, lows, closes, period=period)
 22600: 
 22601: 
 22602: 
 22603: --------------------------------------------------------------------------------
 22604: FILE: tests/test_min_qty_rules.py
 22605: --------------------------------------------------------------------------------
 22606: import os
 22607: import sys
 22608: import types
 22609: 
 22610: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 22611: sys.modules['requests'] = types.ModuleType('requests')
 22612: 
 22613: from bot import _apply_contract_checks
 22614: 
 22615: 
 22616: def _detail():
 22617:     return {
 22618:         "data": [
 22619:             {
 22620:                 "symbol": "BTC_USDT",
 22621:                 "contractSize": 1,
 22622:                 "volUnit": 5,
 22623:                 "minVol": 10,
 22624:                 "minTradeUSDT": 5,
 22625:             }
 22626:         ]
 22627:     }
 22628: 
 22629: 
 22630: def test_min_qty_floor_and_validation():
 22631:     detail = _detail()
 22632:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
 22633:     assert vol == 10
 22634:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
 22635:     assert vol2 == 0
 22636: 
 22637: 
 22638: --------------------------------------------------------------------------------
 22639: FILE: tests/test_notifier.py
 22640: --------------------------------------------------------------------------------
 22641: import scalper.notifier as notifier
 22642: 
 22643: 
 22644: def test_notify_skips_without_targets(monkeypatch):
 22645:     called = False
 22646: 
 22647:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
 22648:         nonlocal called
 22649:         called = True
 22650: 
 22651:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 22652:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 22653:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 22654:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 22655:     notifier.notify("test", {"foo": 1})
 22656:     assert called is False
 22657: 
 22658: 
 22659: def test_notify_posts_http(monkeypatch):
 22660:     payload = {}
 22661: 
 22662:     def fake_post(url, json=None, timeout=5):
 22663:         payload["url"] = url
 22664:         payload["json"] = json
 22665:         payload["timeout"] = timeout
 22666: 
 22667:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
 22668:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
 22669:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 22670:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 22671:     notifier.notify("evt", {"bar": 2})
 22672:     assert payload["url"] == "http://example.com"
 22673:     assert payload["json"]["event"] == "evt"
 22674:     assert payload["json"]["bar"] == 2
 22675: 
 22676: 
 22677: def test_notify_posts_telegram(monkeypatch):
 22678:     payload = {}
 22679: 
 22680:     def fake_post(url, json=None, timeout=5):
 22681:         payload["url"] = url
 22682:         payload["json"] = json
 22683:         payload["timeout"] = timeout
 22684: 
 22685:     monkeypatch.delenv("NOTIFY_URL", raising=False)
 22686:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 22687:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 22688:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 22689: 
 22690:     notifier.notify("evt", {"bar": 2})
 22691: 
 22692:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
 22693:     assert payload["json"]["chat_id"] == "123"
 22694:     assert "evt" in payload["json"]["text"]
 22695: 
 22696: 
 22697: def test_notify_posts_both(monkeypatch):
 22698:     calls = []
 22699: 
 22700:     def fake_post(url, json=None, timeout=5):
 22701:         calls.append({"url": url, "json": json, "timeout": timeout})
 22702: 
 22703:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 22704:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 22705:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 22706:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 22707: 
 22708:     notifier.notify("evt", {"bar": 2})
 22709: 
 22710:     assert len(calls) == 2
 22711:     urls = {c["url"] for c in calls}
 22712:     assert "http://example.com" in urls
 22713:     assert "https://api.telegram.org/botabc/sendMessage" in urls
 22714: 
 22715: 
 22716: def test_notify_skips_telegram_for_pair_list(monkeypatch):
 22717:     calls = []
 22718: 
 22719:     def fake_post(url, json=None, timeout=5):
 22720:         calls.append(url)
 22721: 
 22722:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
 22723:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
 22724:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
 22725:     monkeypatch.setattr(notifier.requests, "post", fake_post)
 22726: 
 22727:     notifier.notify("pair_list", {"pairs": "BTC"})
 22728: 
 22729:     # Only the generic webhook should be called, not Telegram
 22730:     assert calls == ["http://example.com"]
 22731: 
 22732: 
 22733: def test_format_text_open_position():
 22734:     payload = {
 22735:         "symbol": "BTCUSDT",
 22736:         "side": "short",
 22737:         "price": 18350,
 22738:         "vol": 37,
 22739:         "contract_size": 1,
 22740:         "notional_usdt": 120.5,
 22741:         "leverage": 5,
 22742:         "required_margin_usdt": 25.3,
 22743:         "available_usdt": 134,
 22744:         "risk_level_user": 3,
 22745:         "signal_level": 2,
 22746:         "risk_color": "🟡",
 22747:         "risk_pct_eff": 0.01,
 22748:         "fee_rate": 0.001,
 22749:     }
 22750:     text = notifier._format_text("position_opened", payload)
 22751:     lines = text.splitlines()
 22752: 
 22753:     assert lines[0] == "🟡 Ouvre short BTC"
 22754:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
 22755:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
 22756:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
 22757:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
 22758: 
 22759: 
 22760: def test_format_text_closed_position():
 22761:     payload = {
 22762:         "symbol": "BTCUSDT",
 22763:         "side": "short",
 22764:         "entry_price": 18350,
 22765:         "exit_price": 18328,
 22766:         "vol": 37,
 22767:         "contract_size": 1,
 22768:         "notional_entry_usdt": 120.5,
 22769:         "notional_exit_usdt": 120.3,
 22770:         "fees_usdt": 0.03,
 22771:         "pnl_usdt": 0.84,
 22772:         "pnl_pct_on_margin": 3.25,
 22773:         "leverage": 5,
 22774:         "risk_color": "🟡",
 22775:         "fee_rate": 0.001,
 22776:     }
 22777:     text = notifier._format_text("position_closed", payload)
 22778:     lines = text.splitlines()
 22779:     assert lines[0] == "Ferme short BTC 🟡"
 22780:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
 22781:     assert lines[2] == "% sur marge: 3.25%"
 22782:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
 22783:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
 22784: 
 22785: 
 22786: def test_format_text_pair_list_and_start():
 22787:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
 22788:     text = notifier._format_text(
 22789:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
 22790:     )
 22791:     assert text == "Listing ok"
 22792: 
 22793: 
 22794: def test_format_pair_list_helper():
 22795:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
 22796:     text = notifier._format_pair_list(payload)
 22797:     assert text == "Listing ok"
 22798: 
 22799: 
 22800: def test_format_position_event_helper():
 22801:     payload = {
 22802:         "symbol": "BTCUSDT",
 22803:         "side": "short",
 22804:         "price": 18350,
 22805:         "vol": 37,
 22806:         "contract_size": 1,
 22807:         "notional_usdt": 120.5,
 22808:         "leverage": 5,
 22809:         "required_margin_usdt": 25.3,
 22810:         "available_usdt": 134,
 22811:         "risk_level_user": 3,
 22812:         "signal_level": 2,
 22813:         "risk_color": "🟡",
 22814:         "risk_pct_eff": 0.01,
 22815:         "fee_rate": 0.001,
 22816:     }
 22817:     text = notifier._format_position_event("position_opened", payload)
 22818:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
 22819: 
 22820: 
 22821: 
 22822: 
 22823: --------------------------------------------------------------------------------
 22824: FILE: tests/test_notional_and_pnl_units.py
 22825: --------------------------------------------------------------------------------
 22826: import os, sys, types, pytest
 22827: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 22828: sys.modules['requests'] = types.ModuleType('requests')
 22829: 
 22830: from scalper.trade_utils import (
 22831:     get_contract_size,
 22832:     notional as calc_notional,
 22833:     required_margin as calc_required_margin,
 22834:     compute_pnl_usdt,
 22835:     compute_pnl_with_fees,
 22836: )
 22837: 
 22838: 
 22839: def _detail():
 22840:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
 22841: 
 22842: 
 22843: def test_notional_and_pnl_units():
 22844:     detail = _detail()
 22845:     cs = get_contract_size(detail, "BTC_USDT")
 22846:     N = calc_notional(10000, 2, cs)
 22847:     assert N == pytest.approx(10000 * 0.001 * 2)
 22848:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
 22849:     assert margin == pytest.approx(N / 10 + 0.001 * N)
 22850:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
 22851:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
 22852:     pnl_net, pct = compute_pnl_with_fees(
 22853:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
 22854:     )
 22855:     gross = (10100 - 10000) * cs * 2
 22856:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
 22857:     expected = gross - fees
 22858:     expected_pct = expected / (N / 10) * 100
 22859:     assert pnl_net == pytest.approx(expected)
 22860:     assert pct == pytest.approx(expected_pct)
 22861: 
 22862: 
 22863: --------------------------------------------------------------------------------
 22864: FILE: tests/test_pair_selection.py
 22865: --------------------------------------------------------------------------------
 22866: import bot
 22867: 
 22868: 
 22869: def test_get_trade_pairs():
 22870:     class Client:
 22871:         def get_ticker(self, symbol=None):
 22872:             return {
 22873:                 "success": True,
 22874:                 "data": [
 22875:                     {"symbol": "BTC_USDT"},
 22876:                     {"symbol": "ETH_USDT"},
 22877:                 ],
 22878:             }
 22879: 
 22880:     pairs = bot.get_trade_pairs(Client())
 22881:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
 22882: 
 22883: 
 22884: def test_select_top_pairs():
 22885:     class Client:
 22886:         def get_ticker(self, symbol=None):
 22887:             return {
 22888:                 "success": True,
 22889:                 "data": [
 22890:                     {"symbol": "A", "volume": "1"},
 22891:                     {"symbol": "B", "volume": "3"},
 22892:                     {"symbol": "C", "volume": "2"},
 22893:                 ],
 22894:             }
 22895: 
 22896:     top = bot.select_top_pairs(Client(), top_n=2)
 22897:     assert [p["symbol"] for p in top] == ["B", "C"]
 22898: 
 22899: 
 22900: def test_select_top_pairs_default_count():
 22901:     class Client:
 22902:         def get_ticker(self, symbol=None):
 22903:             data = []
 22904:             for i in range(100):
 22905:                 data.append({"symbol": str(i), "volume": str(i)})
 22906:             return {"success": True, "data": data}
 22907: 
 22908:     top = bot.select_top_pairs(Client())
 22909:     assert len(top) == 40
 22910: 
 22911: 
 22912: def test_filter_trade_pairs():
 22913:     class Client:
 22914:         def get_ticker(self, symbol=None):
 22915:             return {
 22916:                 "success": True,
 22917:                 "data": [
 22918:                     {
 22919:                         "symbol": "AAA",
 22920:                         "volume": "6000000",
 22921:                         "bidPrice": "100",
 22922:                         "askPrice": "100.03",
 22923:                     },  # spread ~3 bps
 22924:                     {
 22925:                         "symbol": "BBB",
 22926:                         "volume": "10000000",
 22927:                         "bidPrice": "50",
 22928:                         "askPrice": "50.1",
 22929:                     },  # spread ~200 bps
 22930:                     {
 22931:                         "symbol": "CCC",
 22932:                         "volume": "7000000",
 22933:                         "bidPrice": "10",
 22934:                         "askPrice": "10.01",
 22935:                     },  # spread ~100 bps
 22936:                     {
 22937:                         "symbol": "DDD",
 22938:                         "volume": "4000000",
 22939:                         "bidPrice": "20",
 22940:                         "askPrice": "20.01",
 22941:                     },  # volume trop faible
 22942:                 ],
 22943:             }
 22944: 
 22945:     pairs = bot.filter_trade_pairs(
 22946:         Client(),
 22947:         volume_min=5_000_000,
 22948:         max_spread_bps=5,
 22949:     )
 22950:     assert [p["symbol"] for p in pairs] == ["AAA"]
 22951: 
 22952: 
 22953: def test_find_trade_positions(monkeypatch):
 22954:     class Client:
 22955:         def __init__(self):
 22956:             self.data = {
 22957:                 "AAA": {"data": {"close": [1, 2, 3]}},
 22958:                 "BBB": {"data": {"close": [3, 2, 1]}},
 22959:             }
 22960: 
 22961:         def get_kline(self, symbol, interval="1m"):
 22962:             return self.data[symbol]
 22963: 
 22964:     pairs = [
 22965:         {"symbol": "AAA", "lastPrice": "1"},
 22966:         {"symbol": "BBB", "lastPrice": "1"},
 22967:     ]
 22968: 
 22969:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
 22970: 
 22971:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
 22972:         if last_fast > prev_fast:
 22973:             return 1
 22974:         if last_fast < prev_fast:
 22975:             return -1
 22976:         return 0
 22977: 
 22978:     monkeypatch.setattr(bot, "cross", fake_cross)
 22979: 
 22980:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
 22981:     assert signals == [
 22982:         {"symbol": "AAA", "signal": "long", "price": 1.0},
 22983:         {"symbol": "BBB", "signal": "short", "price": 1.0},
 22984:     ]
 22985: 
 22986: 
 22987: --------------------------------------------------------------------------------
 22988: FILE: tests/test_pairs.py
 22989: --------------------------------------------------------------------------------
 22990: import bot
 22991: 
 22992: 
 22993: def test_send_selected_pairs(monkeypatch):
 22994:     sent = {}
 22995: 
 22996:     def fake_notify(event, payload=None):
 22997:         sent["event"] = event
 22998:         sent["payload"] = payload
 22999: 
 23000:     monkeypatch.setattr(bot, "notify", fake_notify)
 23001:     monkeypatch.setattr(
 23002:         bot,
 23003:         "filter_trade_pairs",
 23004:         lambda client, top_n=120: [
 23005:             {"symbol": "WIFUSDT", "volume": 10},
 23006:             {"symbol": "WIFUSDT", "volume": 9},
 23007:             {"symbol": "BTCUSD", "volume": 8},
 23008:             {"symbol": "BTCUSDT", "volume": 7},
 23009:             {"symbol": "DOGEUSDT", "volume": 6},
 23010:             {"symbol": "ETHUSDC", "volume": 5},
 23011:             {"symbol": "ETHUSDT", "volume": 4},
 23012:         ],
 23013:     )
 23014: 
 23015:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
 23016: 
 23017:     payload = bot.send_selected_pairs(object(), top_n=4)
 23018: 
 23019:     assert sent["event"] == "pair_list"
 23020:     assert sent["payload"]["green"] == "BTC"
 23021:     assert sent["payload"]["orange"] == "ETH"
 23022:     assert "red" not in sent["payload"]
 23023:     assert payload == sent["payload"]
 23024: 
 23025: 
 23026: def test_send_selected_pairs_no_whitelist(monkeypatch):
 23027:     sent = {}
 23028: 
 23029:     def fake_notify(event, payload=None):
 23030:         sent["payload"] = payload
 23031: 
 23032:     monkeypatch.setattr(bot, "notify", fake_notify)
 23033:     monkeypatch.setattr(
 23034:         bot,
 23035:         "filter_trade_pairs",
 23036:         lambda client, top_n=120: [
 23037:             {"symbol": "AAAUSDT", "volume": 10},
 23038:             {"symbol": "BBBUSD", "volume": 9},
 23039:             {"symbol": "CCCUSDC", "volume": 8},
 23040:             {"symbol": "DDDUSDT", "volume": 7},
 23041:         ],
 23042:     )
 23043:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
 23044: 
 23045:     payload = bot.send_selected_pairs(object(), top_n=4)
 23046: 
 23047:     assert payload == sent["payload"]
 23048:     assert payload["green"] == "AAA"
 23049:     assert payload["orange"] == "BBB"
 23050:     assert payload["red"] == "CCC, DDD"
 23051: 
 23052: 
 23053: def test_filter_trade_pairs_all_pairs(monkeypatch):
 23054:     class DummyClient:
 23055:         def get_ticker(self):
 23056:             return {
 23057:                 "data": [
 23058:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
 23059:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
 23060:                 ]
 23061:             }
 23062: 
 23063:     client = DummyClient()
 23064:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
 23065:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
 23066: 
 23067: 
 23068: 
 23069: --------------------------------------------------------------------------------
 23070: FILE: tests/test_risk_manager.py
 23071: --------------------------------------------------------------------------------
 23072: from scalp import RiskManager
 23073: 
 23074: 
 23075: def test_kill_switch_triggered() -> None:
 23076:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
 23077:     rm.record_trade(-1.0)
 23078:     rm.record_trade(-1.5)
 23079:     assert rm.kill_switch is True
 23080: 
 23081: 
 23082: def test_profit_kill_switch_triggered() -> None:
 23083:     rm = RiskManager(
 23084:         max_daily_loss_pct=10.0,
 23085:         max_daily_profit_pct=3.0,
 23086:         max_positions=1,
 23087:         risk_pct=0.01,
 23088:     )
 23089:     rm.record_trade(1.5)
 23090:     rm.record_trade(1.6)
 23091:     assert rm.kill_switch is True
 23092: 
 23093: 
 23094: def test_pause_and_can_open() -> None:
 23095:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 23096:     rm.record_trade(-0.5)
 23097:     rm.record_trade(-0.6)
 23098:     rm.record_trade(-0.7)
 23099:     assert rm.pause_duration() == 15 * 60
 23100:     rm.record_trade(-0.8)
 23101:     rm.record_trade(-0.9)
 23102:     assert rm.pause_duration() == 60 * 60
 23103:     assert rm.can_open(0) is True
 23104:     assert rm.can_open(1) is False
 23105: 
 23106: 
 23107: def test_risk_pct_scaling() -> None:
 23108:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
 23109:     rm.record_trade(1.0)
 23110:     rm.record_trade(1.0)
 23111:     assert rm.risk_pct > 0.01
 23112:     rm.record_trade(-1.0)
 23113:     rm.record_trade(-1.0)
 23114:     assert rm.risk_pct < 0.01
 23115: 
 23116: 
 23117: --------------------------------------------------------------------------------
 23118: FILE: tests/test_risk_utils.py
 23119: --------------------------------------------------------------------------------
 23120: import pytest
 23121: 
 23122: from scalper.risk import calc_risk_amount, calc_position_size
 23123: 
 23124: 
 23125: def test_calc_risk_amount_basic():
 23126:     assert calc_risk_amount(1000, 0.01) == 10.0
 23127: 
 23128: 
 23129: def test_calc_position_size_basic():
 23130:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
 23131:     assert calc_position_size(1000, 0.01, 50) == 0.2
 23132: 
 23133: 
 23134: @pytest.mark.parametrize("equity,risk_pct", [
 23135:     (0, 0.01),
 23136:     (-100, 0.01),
 23137:     (1000, 0),
 23138:     (1000, -0.1),
 23139:     (1000, 1.5),
 23140: ])
 23141: def test_calc_risk_amount_invalid(equity, risk_pct):
 23142:     with pytest.raises(ValueError):
 23143:         calc_risk_amount(equity, risk_pct)
 23144: 
 23145: 
 23146: @pytest.mark.parametrize("stop_distance", [0, -1])
 23147: def test_calc_position_size_invalid_stop(stop_distance):
 23148:     with pytest.raises(ValueError):
 23149:         calc_position_size(1000, 0.01, stop_distance)
 23150: 
 23151: 
 23152: --------------------------------------------------------------------------------
 23153: FILE: tests/test_signal_risk.py
 23154: --------------------------------------------------------------------------------
 23155: import types
 23156: import os
 23157: import sys
 23158: 
 23159: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 23160: sys.modules['requests'] = types.ModuleType('requests')
 23161: 
 23162: from bot import (
 23163:     map_score_to_sig_level,
 23164:     compute_risk_params,
 23165:     prepare_order,
 23166:     Signal,
 23167:     CONFIG,
 23168: )
 23169: 
 23170: 
 23171: class DummyRisk:
 23172:     def __init__(self, pct: float) -> None:
 23173:         self.risk_pct = pct
 23174: 
 23175: 
 23176: def _contract_detail():
 23177:     return {
 23178:         "data": [
 23179:             {
 23180:                 "symbol": "BTC_USDT",
 23181:                 "contractSize": 0.001,
 23182:                 "volUnit": 1,
 23183:                 "minVol": 1,
 23184:                 "minTradeUSDT": 5,
 23185:             }
 23186:         ]
 23187:     }
 23188: 
 23189: 
 23190: def test_score_to_level_mapping():
 23191:     assert map_score_to_sig_level(10) == 1
 23192:     assert map_score_to_sig_level(35) == 2
 23193:     assert map_score_to_sig_level(69.9) == 2
 23194:     assert map_score_to_sig_level(70) == 3
 23195: 
 23196: 
 23197: def test_risk_tables():
 23198:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
 23199:     assert rp == 0.01 * 1.25
 23200:     assert lev == int(20 * 0.75)
 23201:     assert cap == 0.55
 23202:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
 23203:     assert rp2 == 0.01 * 1.0
 23204:     assert lev2 == int(20 * 0.5)
 23205:     assert cap2 == 0.35
 23206: 
 23207: 
 23208: def test_notional_cap():
 23209:     rm = DummyRisk(0.05)
 23210:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
 23211:     available = 1000
 23212:     params = prepare_order(
 23213:         sig,
 23214:         _contract_detail(),
 23215:         equity_usdt=available,
 23216:         available_usdt=available,
 23217:         base_leverage=10,
 23218:         risk_mgr=rm,
 23219:         user_risk_level=2,
 23220:     )
 23221:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6
 23222: 
 23223: 
 23224: --------------------------------------------------------------------------------
 23225: FILE: tests/test_slippage.py
 23226: --------------------------------------------------------------------------------
 23227: from scalper.trade_utils import marketable_limit_price
 23228: 
 23229: 
 23230: def test_marketable_limit_price_buy_sell():
 23231:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
 23232:     assert price_buy == 10.0 * 1.001
 23233:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
 23234:     assert price_sell == 9.9 * (1 - 0.001)
 23235: 
 23236: 
 23237: --------------------------------------------------------------------------------
 23238: FILE: tests/test_strategy_v2.py
 23239: --------------------------------------------------------------------------------
 23240: import pytest
 23241: 
 23242: from scalp import strategy
 23243: from scalper.trade_utils import trailing_stop, should_scale_in, timeout_exit
 23244: 
 23245: 
 23246: def make_ohlcv(n=60, start=100, step=1):
 23247:     closes = [start + i * step for i in range(n)]
 23248:     highs = [c + 1 for c in closes]
 23249:     lows = [c - 1 for c in closes]
 23250:     vols = [1 for _ in closes]
 23251:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
 23252: 
 23253: 
 23254: def test_generate_signal_atr_adaptation(monkeypatch):
 23255:     base = make_ohlcv(step=2)
 23256:     ohlcv_15 = make_ohlcv(n=15, step=2)
 23257:     ohlcv_1h = make_ohlcv(step=2)
 23258: 
 23259:     # patches for deterministic RSI values
 23260:     rsi_vals = iter([60, 41, 39])
 23261:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 23262:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 23263:     # low ATR -> signal disabled
 23264:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
 23265:     sig = strategy.generate_signal(
 23266:         "AAA",
 23267:         base,
 23268:         equity=1_000,
 23269:         risk_pct=0.01,
 23270:         ohlcv_15m=ohlcv_15,
 23271:         ohlcv_1h=ohlcv_1h,
 23272:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 23273:         tick_ratio_buy=0.6,
 23274:     )
 23275:     assert sig is None
 23276: 
 23277:     # high ATR -> size reduced
 23278:     rsi_vals = iter([60, 41, 39])
 23279:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 23280:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
 23281:     sig = strategy.generate_signal(
 23282:         "AAA",
 23283:         base,
 23284:         equity=1_000,
 23285:         risk_pct=0.01,
 23286:         ohlcv_15m=ohlcv_15,
 23287:         ohlcv_1h=ohlcv_1h,
 23288:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 23289:         tick_ratio_buy=0.6,
 23290:     )
 23291:     assert sig and sig.side == "long"
 23292:     assert sig.qty == 50
 23293: 
 23294: 
 23295: def test_generate_signal_short_with_filters(monkeypatch):
 23296:     base = make_ohlcv(start=200, step=-2)
 23297:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
 23298:     ohlcv_1h = make_ohlcv(start=200, step=-2)
 23299: 
 23300:     rsi_vals = iter([40, 59, 61])
 23301:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 23302:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 23303:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 23304: 
 23305:     sig = strategy.generate_signal(
 23306:         "AAA",
 23307:         base,
 23308:         equity=1_000,
 23309:         risk_pct=0.01,
 23310:         ohlcv_15m=ohlcv_15,
 23311:         ohlcv_1h=ohlcv_1h,
 23312:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
 23313:         tick_ratio_buy=0.4,
 23314:     )
 23315:     assert sig and sig.side == "short"
 23316:     assert sig.qty == 100
 23317: 
 23318: 
 23319: def test_trailing_and_timeout():
 23320:     # trailing stop
 23321:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
 23322:     assert sl == pytest.approx(102.5)
 23323:     # scaling
 23324:     assert should_scale_in(100, 105, 100, 10, "long") is True
 23325:     assert should_scale_in(100, 95, 100, 10, "short") is True
 23326:     # timeout
 23327:     # before the progress window no exit should be triggered
 23328:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 23329:     # after ``progress_min`` minutes without favourable movement we close
 23330:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
 23331: 
 23332: 
 23333: def test_generate_signal_macd_filter(monkeypatch):
 23334:     base = make_ohlcv(step=2)
 23335:     ohlcv_15 = make_ohlcv(n=15, step=2)
 23336:     ohlcv_1h = make_ohlcv(step=2)
 23337: 
 23338:     rsi_vals = iter([60, 41, 39])
 23339:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 23340:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 23341:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 23342:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
 23343: 
 23344:     sig = strategy.generate_signal(
 23345:         "AAA",
 23346:         base,
 23347:         equity=1_000,
 23348:         risk_pct=0.01,
 23349:         ohlcv_15m=ohlcv_15,
 23350:         ohlcv_1h=ohlcv_1h,
 23351:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 23352:         tick_ratio_buy=0.6,
 23353:     )
 23354:     assert sig is None
 23355: 
 23356: 
 23357: 
 23358: def test_generate_signal_trend_ema_filter(monkeypatch):
 23359:     base = make_ohlcv(step=2)
 23360:     ohlcv_15 = make_ohlcv(n=15, step=2)
 23361:     ohlcv_1h = make_ohlcv(step=2)
 23362: 
 23363:     rsi_vals = iter([60, 41, 39])
 23364:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
 23365:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
 23366:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
 23367: 
 23368:     orig_ema = strategy.ema
 23369: 
 23370:     def fake_ema(series, window):
 23371:         if window == 200:
 23372:             return [x + 1000 for x in orig_ema(series, window)]
 23373:         return orig_ema(series, window)
 23374: 
 23375:     monkeypatch.setattr(strategy, "ema", fake_ema)
 23376: 
 23377:     sig = strategy.generate_signal(
 23378:         "AAA",
 23379:         base,
 23380:         equity=1_000,
 23381:         risk_pct=0.01,
 23382:         ohlcv_15m=ohlcv_15,
 23383:         ohlcv_1h=ohlcv_1h,
 23384:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
 23385:         tick_ratio_buy=0.6,
 23386:         trend_ema_period=200,
 23387:     )
 23388:     assert sig is None
 23389:     
 23390: 
 23391: --------------------------------------------------------------------------------
 23392: FILE: tests/test_telegram_bot.py
 23393: --------------------------------------------------------------------------------
 23394: from scalper.telegram_bot import TelegramBot
 23395: 
 23396: 
 23397: class DummyClient:
 23398: 
 23399:     def __init__(self):
 23400:         self.closed = []
 23401:         self.closed_all = False
 23402: 
 23403: 
 23404:     def get_assets(self):
 23405:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
 23406: 
 23407:     def get_positions(self):
 23408:         return {
 23409:             "data": [
 23410:                 {
 23411:                     "symbol": "BTC_USDT",
 23412:                     "side": "long",
 23413:                     "vol": 2,
 23414:                     "pnl_usd": 1.0,
 23415:                     "pnl_pct": 5.0,
 23416:                 }
 23417:             ]
 23418:         }
 23419: 
 23420:     def close_position(self, sym):
 23421:         self.closed.append(sym)
 23422: 
 23423:     def close_all_positions(self):
 23424:         self.closed_all = True
 23425: 
 23426: 
 23427: 
 23428: class DummyRiskMgr:
 23429: 
 23430:     def __init__(self):
 23431:         self.reset_called = False
 23432:         self.max_positions = 1
 23433:         self.risk_pct = 0.01
 23434: 
 23435:     def reset_day(self):
 23436:         self.reset_called = True
 23437: 
 23438: 
 23439: class DummyRequests:
 23440:     def __init__(self):
 23441:         self.posts = []
 23442: 
 23443:     def post(self, url, json=None, timeout=5):
 23444:         self.posts.append((url, json))
 23445: 
 23446:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
 23447:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
 23448: 
 23449: 
 23450: def make_bot(config=None, requests_module=None):
 23451:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
 23452:     if config:
 23453:         cfg.update(config)
 23454:     if requests_module is None:
 23455:         requests_module = DummyRequests()
 23456:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
 23457: 
 23458: 
 23459: def test_handle_balance():
 23460:     bot = make_bot()
 23461: 
 23462:     resp, kb = bot.handle_callback("balance", 0.0)
 23463:     assert "123.45" in resp
 23464:     assert kb == bot.main_keyboard
 23465: 
 23466: 
 23467: 
 23468: def test_handle_positions():
 23469:     bot = make_bot()
 23470:     resp, _ = bot.handle_callback("positions", 0.0)
 23471:     assert "BTC" in resp
 23472:     assert "PnL" in resp
 23473: 
 23474: 
 23475: def test_handle_positions_zero_pnl():
 23476:     bot = make_bot()
 23477: 
 23478:     def zero_positions():
 23479:         return {
 23480:             "data": [
 23481:                 {
 23482:                     "symbol": "BTC_USDT",
 23483:                     "side": "long",
 23484:                     "vol": 1,
 23485:                     "pnl_usd": 0.0,
 23486:                     "pnl_pct": 0.0,
 23487:                 }
 23488:             ]
 23489:         }
 23490: 
 23491:     bot.client.get_positions = zero_positions
 23492:     resp, _ = bot.handle_callback("positions", 0.0)
 23493:     assert "PnL: 0.00 USDT" in resp
 23494: 
 23495: 
 23496: 
 23497: def test_handle_pnl():
 23498:     bot = make_bot()
 23499:     resp, _ = bot.handle_callback("pnl", 5.0)
 23500: 
 23501:     assert "5.00" in resp
 23502: 
 23503: 
 23504: def test_handle_risk_change():
 23505:     bot = make_bot()
 23506: 
 23507:     resp, kb = bot.handle_callback("risk_red", 0.0)
 23508:     assert "3" in resp
 23509:     assert bot.config["RISK_LEVEL"] == 3
 23510:     assert kb == bot.main_keyboard
 23511: 
 23512: 
 23513: def test_risk_menu():
 23514:     bot = make_bot()
 23515:     resp, kb = bot.handle_callback("risk", 0.0)
 23516:     assert "risque" in resp.lower()
 23517:     assert kb == bot.risk_keyboard
 23518: 
 23519: 
 23520: 
 23521: def test_stop_menu_and_actions():
 23522:     bot = make_bot()
 23523:     resp, kb = bot.handle_callback("stop", 0.0)
 23524:     assert any(
 23525:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
 23526:     )
 23527:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
 23528:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
 23529:     assert "fermée" in resp.lower()
 23530:     assert bot.client.closed == ["BTC_USDT"]
 23531:     resp, _ = bot.handle_callback("stop_all", 0.0)
 23532:     assert bot.client.closed_all is True
 23533: 
 23534: 
 23535: def test_handle_unknown():
 23536:     bot = make_bot()
 23537:     resp, kb = bot.handle_callback("foobar", 0.0)
 23538:     assert resp is None
 23539:     assert kb is None
 23540: 
 23541: 
 23542: def test_reset_all():
 23543:     bot = make_bot()
 23544:     resp, kb = bot.handle_callback("reset_all", 0.0)
 23545:     assert "réinitialisés" in resp.lower()
 23546:     assert bot.risk_mgr.reset_called is True
 23547:     assert bot.client.closed_all is True
 23548:     assert kb == bot.settings_keyboard
 23549: 
 23550: 
 23551: def test_shutdown_bot():
 23552:     bot = make_bot()
 23553:     resp, kb = bot.handle_callback("shutdown", 0.0)
 23554:     assert "arrêt" in resp.lower()
 23555:     assert bot.stop_requested is True
 23556:     assert kb == bot.main_keyboard
 23557: 
 23558: 
 23559: def test_start_sends_menu():
 23560:     req = DummyRequests()
 23561:     make_bot(requests_module=req)
 23562:     assert req.posts
 23563:     text = req.posts[0][1]["text"]
 23564:     assert "Solde" in text and "PnL session" in text
 23565:     assert "Positions max" in text
 23566:     assert "Risque actuel" in text
 23567: 
 23568: 
 23569: def test_settings_menu_and_reset_risk():
 23570:     bot = make_bot()
 23571:     resp, kb = bot.handle_callback("settings", 0.0)
 23572:     assert "réglages" in resp.lower()
 23573:     assert kb == bot.settings_keyboard
 23574:     resp, kb = bot.handle_callback("reset_risk", 0.0)
 23575:     assert "risque" in resp.lower()
 23576:     assert bot.risk_mgr.reset_called is True
 23577:     assert kb == bot.settings_keyboard
 23578: 
 23579: 
 23580: def test_update_button(monkeypatch):
 23581:     bot = make_bot()
 23582:     called = {}
 23583: 
 23584:     def fake_update():
 23585:         called["called"] = True
 23586: 
 23587:     bot.update_pairs = fake_update
 23588:     resp, kb = bot.handle_callback("update", 0.0)
 23589:     assert called["called"] is True
 23590:     assert "mise à jour" in resp.lower()
 23591:     assert kb == bot.main_keyboard
 23592: 
 23593: 
 23594: def test_maxpos_menu_and_change():
 23595:     bot = make_bot()
 23596:     resp, kb = bot.handle_callback("maxpos", 0.0)
 23597:     assert "nombre" in resp.lower()
 23598:     assert kb == bot.maxpos_keyboard
 23599:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
 23600:     assert "3" in resp
 23601:     assert bot.config["MAX_POSITIONS"] == 3
 23602:     assert bot.risk_mgr.max_positions == 3
 23603:     assert kb == bot.main_keyboard
 23604: 
 23605: 
 23606: def test_stop_no_positions():
 23607:     bot = make_bot()
 23608:     bot.client.get_positions = lambda: {"data": []}
 23609:     resp, kb = bot.handle_callback("stop", 0.0)
 23610:     assert "aucune crypto" in resp.lower()
 23611:     assert kb == bot.settings_keyboard
 23612: 
 23613: 
 23614: 
 23615: --------------------------------------------------------------------------------
 23616: FILE: tests/test_utils.py
 23617: --------------------------------------------------------------------------------
 23618: import pytest
 23619: from bot import ema, cross, compute_position_size, CONFIG
 23620: from scalper.trade_utils import extract_available_balance
 23621: 
 23622: 
 23623: def test_ema_basic():
 23624:     data = [1, 2, 3, 4, 5]
 23625:     result = ema(data, 3)
 23626:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
 23627: 
 23628: 
 23629: def test_cross_up_down_none():
 23630:     assert cross(3, 2, 1, 2) == 1  # up cross
 23631:     assert cross(0.5, 1, 2, 1) == -1  # down cross
 23632:     assert cross(2, 2, 2, 2) == 0  # no cross
 23633: 
 23634: 
 23635: def test_compute_position_size():
 23636:     detail = {
 23637:         "data": [
 23638:             {
 23639:                 "symbol": CONFIG["SYMBOL"],
 23640:                 "contractSize": 0.001,
 23641:                 "volUnit": 1,
 23642:                 "minVol": 1,
 23643:             }
 23644:         ]
 23645:     }
 23646:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
 23647:                                 risk_pct=0.01, leverage=5)
 23648:     assert vol == 1
 23649: 
 23650: 
 23651: def test_compute_position_size_missing_symbol():
 23652:     with pytest.raises(ValueError):
 23653:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
 23654: 
 23655: 
 23656: def test_extract_available_balance_fallback():
 23657:     assets = {
 23658:         "data": [
 23659:             {
 23660:                 "currency": "USDT",
 23661:                 "available": 0,
 23662:                 "cashBalance": "150.5",
 23663:                 "equity": "200",
 23664:             }
 23665:         ]
 23666:     }
 23667:     assert extract_available_balance(assets) == 150.5
 23668: 
 23669: 
 23670: def test_extract_available_balance_equity_only():
 23671:     assets = {
 23672:         "data": [
 23673:             {
 23674:                 "currency": "USDT",
 23675:                 "equity": "42",
 23676:             }
 23677:         ]
 23678:     }
 23679:     assert extract_available_balance(assets) == 42.0
 23680: 
 23681: 
 23682: def test_extract_available_balance_zero_available_returns_zero():
 23683:     assets = {
 23684:         "data": [
 23685:             {
 23686:                 "currency": "USDT",
 23687:                 "available": 0,
 23688:                 "availableBalance": 0,
 23689:                 "equity": "42",
 23690:             }
 23691:         ]
 23692:     }
 23693:     assert extract_available_balance(assets) == 0.0
 23694: 
 23695: 
 23696: --------------------------------------------------------------------------------
 23697: FILE: tests/test_version.py
 23698: --------------------------------------------------------------------------------
 23699: import pytest
 23700: from scalp import version
 23701: 
 23702: 
 23703: def test_get_version(monkeypatch, tmp_path):
 23704:     vfile = tmp_path / "VERSION"
 23705:     vfile.write_text("1.2.3")
 23706:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 23707:     assert version.get_version() == "1.2.3"
 23708: 
 23709: 
 23710: def test_bump_version(monkeypatch, tmp_path):
 23711:     vfile = tmp_path / "VERSION"
 23712: 
 23713:     vfile.write_text("0.1.2\n")
 23714:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 23715:     assert version.bump_version("minor") == "0.2.0"
 23716:     assert vfile.read_text().strip() == "0.2.0"
 23717: 
 23718: 
 23719: def test_bump_version_invalid_part(monkeypatch, tmp_path):
 23720:     vfile = tmp_path / "VERSION"
 23721:     vfile.write_text("0.1.0\n")
 23722:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 23723:     with pytest.raises(ValueError):
 23724:         version.bump_version("foo")
 23725: 
 23726: 
 23727: def test_bump_from_message(monkeypatch, tmp_path):
 23728:     vfile = tmp_path / "VERSION"
 23729:     vfile.write_text("1.0.0\n")
 23730:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
 23731:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
 23732:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
 23733:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
 23734: 
 23735: 
 23736: 
 23737: --------------------------------------------------------------------------------
 23738: FILE: tests/test_walk_forward.py
 23739: --------------------------------------------------------------------------------
 23740: from scalper.backtest import walk_forward_windows
 23741: 
 23742: 
 23743: def test_walk_forward_windows():
 23744:     data = list(range(10))
 23745:     windows = list(walk_forward_windows(data, train=4, test=2))
 23746:     assert windows == [
 23747:         ([0, 1, 2, 3], [4, 5]),
 23748:         ([2, 3, 4, 5], [6, 7]),
 23749:         ([4, 5, 6, 7], [8, 9]),
 23750:     ]
 23751: 
 23752: 
 23753: --------------------------------------------------------------------------------
 23754: FILE: tests/test_ws.py
 23755: --------------------------------------------------------------------------------
 23756: import asyncio
 23757: 
 23758: from scalper.ws import WebsocketManager
 23759: 
 23760: 
 23761: def test_websocket_manager_stop():
 23762:     async def connect():
 23763:         return None
 23764: 
 23765:     async def subscribe():
 23766:         return None
 23767: 
 23768:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
 23769: 
 23770:     async def run_and_stop():
 23771:         await ws.run()
 23772:         assert ws._heartbeat_task is not None
 23773:         await ws.stop()
 23774:         assert ws._heartbeat_task is None
 23775: 
 23776:     asyncio.run(run_and_stop())
 23777: 
 23778: 
 23779: --------------------------------------------------------------------------------
 23780: FILE: tg_diag.py
 23781: --------------------------------------------------------------------------------
 23782: # tg_diag.py
 23783: import asyncio, os, aiohttp
 23784: 
 23785: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
 23786: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
 23787: 
 23788: async def main():
 23789:     if not TOKEN or not CHAT:
 23790:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
 23791:         return
 23792:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
 23793:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
 23794:     try:
 23795:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
 23796:             async with s.post(url, json=payload) as r:
 23797:                 body = await r.text()
 23798:                 print("HTTP:", r.status)
 23799:                 print("Body:", body[:500])
 23800:     except Exception as e:
 23801:         print("❌ Exception:", repr(e))
 23802: 
 23803: if __name__ == "__main__":
 23804:     asyncio.run(main())
 23805: 
 23806: --------------------------------------------------------------------------------
 23807: FILE: tools/dump-repo.py
 23808: --------------------------------------------------------------------------------
 23809: #!/usr/bin/env python3
 23810: """
 23811: tools/dump_repo.py
 23812: 
 23813: Génère un dump complet du repo notebooks/scalp :
 23814: - timestamp dans le nom
 23815: - arborescence des fichiers
 23816: - contenu intégral des fichiers texte
 23817: - exclusion des fichiers binaires et dossiers inutiles (git, cache, trash…)
 23818: 
 23819: Usage :
 23820:     python notebooks/scalp/tools/dump_repo.py
 23821: """
 23822: 
 23823: from __future__ import annotations
 23824: 
 23825: import datetime as dt
 23826: import os
 23827: import sys
 23828: from pathlib import Path
 23829: 
 23830: # Racine du repo = notebooks/scalp/
 23831: REPO_ROOT = Path(__file__).resolve().parents[1]
 23832: DUMP_DIR = REPO_ROOT / "dumps"
 23833: DUMP_DIR.mkdir(parents=True, exist_ok=True)
 23834: 
 23835: TS = dt.datetime.now().strftime("%Y%m%d-%H%M%S")
 23836: OUT_PATH = DUMP_DIR / f"DUMP_{TS}.txt"
 23837: 
 23838: # Extensions/fichiers à ignorer (binaires ou inutiles)
 23839: IGNORE_EXT = {
 23840:     ".png", ".jpg", ".jpeg", ".gif", ".pdf",
 23841:     ".pkl", ".db", ".sqlite", ".zip", ".tar", ".gz",
 23842:     ".pyc", ".pyo",
 23843: }
 23844: IGNORE_DIRS = {".git", "__pycache__", ".ipynb_checkpoints"}
 23845: IGNORE_PREFIX = {"TRASH_"}
 23846: 
 23847: def is_text_file(path: Path) -> bool:
 23848:     if path.suffix.lower() in IGNORE_EXT:
 23849:         return False
 23850:     try:
 23851:         with open(path, "rb") as f:
 23852:             chunk = f.read(1024)
 23853:             if b"\x00" in chunk:
 23854:                 return False
 23855:         return True
 23856:     except Exception:
 23857:         return False
 23858: 
 23859: def write_header(f, title: str) -> None:
 23860:     f.write("\n" + "=" * 80 + "\n")
 23861:     f.write(f"{title}\n")
 23862:     f.write("=" * 80 + "\n")
 23863: 
 23864: def dump_tree(root: Path, f) -> None:
 23865:     write_header(f, "ARBORESCENCE")
 23866:     for p in sorted(root.rglob("*")):
 23867:         rel = p.relative_to(root)
 23868:         if any(part in IGNORE_DIRS for part in rel.parts):
 23869:             continue
 23870:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX):
 23871:             continue
 23872:         f.write(str(rel) + ("/" if p.is_dir() else "") + "\n")
 23873: 
 23874: def dump_files(root: Path, f) -> None:
 23875:     write_header(f, "FICHIERS COMPLETS")
 23876:     for p in sorted(root.rglob("*")):
 23877:         rel = p.relative_to(root)
 23878:         if p.is_dir():
 23879:             continue
 23880:         if any(part in IGNORE_DIRS for part in rel.parts):
 23881:             continue
 23882:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX):
 23883:             continue
 23884:         if not is_text_file(p):
 23885:             continue
 23886:         try:
 23887:             content = p.read_text(encoding="utf-8", errors="replace")
 23888:         except Exception as e:
 23889:             f.write(f"\n[!!] Impossible de lire {rel}: {e}\n")
 23890:             continue
 23891:         f.write("\n" + "-" * 80 + "\n")
 23892:         f.write(f"FILE: {rel}\n")
 23893:         f.write("-" * 80 + "\n")
 23894:         f.write(content)
 23895:         f.write("\n")
 23896: 
 23897: def main() -> int:
 23898:     with open(OUT_PATH, "w", encoding="utf-8") as f:
 23899:         f.write(f"# DUMP {TS}\nRepo: {REPO_ROOT}\n")
 23900:         dump_tree(REPO_ROOT, f)
 23901:         dump_files(REPO_ROOT, f)
 23902:     print(f"[✓] Dump écrit: {OUT_PATH}")
 23903:     return 0
 23904: 
 23905: if __name__ == "__main__":
 23906:     sys.exit(main())
 23907: 
 23908: --------------------------------------------------------------------------------
 23909: FILE: tools/trashify.py
 23910: --------------------------------------------------------------------------------
 23911: # tools/trashify.py
 23912: # Déplacement sécurisé des fichiers/dossiers "candidats" vers TRASH_YYYYMMDD-HHMMSS/
 23913: # Usage:
 23914: #   python tools/trashify.py            # dry-run (affiche seulement)
 23915: #   python tools/trashify.py --apply    # déplace réellement
 23916: # Options:
 23917: #   --trash-dir NAME   # nom personnalisé du dossier trash (sinon timestamp)
 23918: #   --no-git           # force l'utilisation de shutil.move au lieu de `git mv`
 23919: #
 23920: # Notes:
 23921: # - Détecte automatiquement un repo Git et utilise `git mv` si possible (meilleure traçabilité).
 23922: # - Écrit un manifeste: TRASH_.../TRASH_MANIFEST.txt avec la liste des éléments déplacés.
 23923: # - La liste des "candidats" ci-dessous est issue du dump fourni le 2025-08-24 (répertoire racine: Scalp/).  #  [oai_citation:1‡Vierge 19.txt](file-service://file-9QiWVhpqthb1XibRXMXmiu)
 23924: 
 23925: from __future__ import annotations
 23926: 
 23927: import argparse
 23928: import datetime as dt
 23929: import os
 23930: import shutil
 23931: import subprocess
 23932: from pathlib import Path
 23933: from typing import Iterable, List, Tuple
 23934: 
 23935: # --------------------------------------------------------------------------------------
 23936: # Candidats à déplacer (conservateur). Ajuste cette liste si besoin avant --apply.
 23937: # --------------------------------------------------------------------------------------
 23938: CANDIDATES: List[str] = [
 23939:     # 1) Ancienne corbeille entière (archives obsolètes) — doublons du code actuel
 23940:     "TRASH_20250823-124533",
 23941: 
 23942:     # 2) Duplication manifeste: indicateurs déjà présents sous scalper/core/indicators.py
 23943:     "data/indicators.py",
 23944: 
 23945:     # 3) Typo de dossier de stratégie (probablement un essai non concluant)
 23946:     "scalper/strategy/startegies",  # <- oui "startegies" (typo)
 23947: 
 23948:     # 4) Scripts ponctuels/démo non utilisés par bot.py
 23949:     # (laisse commentés par défaut; décommente si tu valides)
 23950:     # "tg_diag.py",
 23951:     # "TRASH_20250823-124533/quick_order.py",
 23952:     # "TRASH_20250823-124533/dashboard.py",
 23953:     # "TRASH_20250823-124533/notebooks",
 23954: 
 23955:     # 5) Anciennes configs/legacy dans TRASH (redondantes avec scalper/config/* actuels)
 23956:     # (déjà couvert par la ligne 1 déplaçant le dossier complet)
 23957: ]
 23958: 
 23959: # Racine du repo = dossier parent de CE fichier, puis deux niveaux si placé dans tools/
 23960: HERE = Path(__file__).resolve()
 23961: REPO_ROOT = HERE.parent.parent if HERE.parent.name == "tools" else HERE.parent
 23962: assert (REPO_ROOT / ".").exists(), f"Repo root introuvable: {REPO_ROOT}"
 23963: 
 23964: 
 23965: def _is_git_repo(root: Path) -> bool:
 23966:     return (root / ".git").exists()
 23967: 
 23968: 
 23969: def _git_mv(src: Path, dst: Path) -> Tuple[bool, str]:
 23970:     try:
 23971:         subprocess.run(["git", "mv", str(src), str(dst)], cwd=REPO_ROOT, check=True, capture_output=True)
 23972:         return True, "git mv"
 23973:     except Exception as e:
 23974:         return False, f"git mv failed: {e}"
 23975: 
 23976: 
 23977: def _shutil_mv(src: Path, dst: Path) -> Tuple[bool, str]:
 23978:     try:
 23979:         dst.parent.mkdir(parents=True, exist_ok=True)
 23980:         shutil.move(str(src), str(dst))
 23981:         return True, "shutil.move"
 23982:     except Exception as e:
 23983:         return False, f"move failed: {e}"
 23984: 
 23985: 
 23986: def _timestamp() -> str:
 23987:     return dt.datetime.now().strftime("%Y%m%d-%H%M%S")
 23988: 
 23989: 
 23990: def resolve_existing(paths: Iterable[str]) -> List[Path]:
 23991:     out: List[Path] = []
 23992:     for p in paths:
 23993:         rp = (REPO_ROOT / p).resolve()
 23994:         if rp.exists():
 23995:             out.append(rp)
 23996:     return out
 23997: 
 23998: 
 23999: def write_manifest(trash_dir: Path, moved: List[Path], skipped: List[Tuple[Path, str]]) -> None:
 24000:     manifest = trash_dir / "TRASH_MANIFEST.txt"
 24001:     lines: List[str] = []
 24002:     lines.append(f"Repo root: {REPO_ROOT}")
 24003:     lines.append(f"Trash dir: {trash_dir}")
 24004:     lines.append(f"Moved count: {len(moved)}")
 24005:     lines.append("Moved items:")
 24006:     for p in moved:
 24007:         rel = p.relative_to(trash_dir)
 24008:         lines.append(f"  - {rel}")
 24009:     if skipped:
 24010:         lines.append("")
 24011:         lines.append("Skipped/not moved (reason):")
 24012:         for p, reason in skipped:
 24013:             lines.append(f"  - {p.relative_to(REPO_ROOT)} :: {reason}")
 24014:     manifest.parent.mkdir(parents=True, exist_ok=True)
 24015:     manifest.write_text("\n".join(lines) + "\n", encoding="utf-8")
 24016: 
 24017: 
 24018: def main() -> int:
 24019:     ap = argparse.ArgumentParser(description="Déplacer des fichiers/dossiers vers un répertoire TRASH_*")
 24020:     ap.add_argument("--apply", action="store_true", help="Exécuter réellement les déplacements (sinon dry-run)")
 24021:     ap.add_argument("--trash-dir", default="", help="Nom personnalisé du répertoire trash (par défaut TRASH_<timestamp>)")
 24022:     ap.add_argument("--no-git", action="store_true", help="Ne pas utiliser git mv, forcer shutil.move")
 24023:     args = ap.parse_args()
 24024: 
 24025:     # Résolution des candidats présents
 24026:     existing = resolve_existing(CANDIDATES)
 24027:     missing = sorted(set(CANDIDATES) - {str(p.relative_to(REPO_ROOT)) for p in existing})
 24028:     if missing:
 24029:         print("[i] Éléments non trouvés (ignorés) :")
 24030:         for m in missing:
 24031:             print(f"    - {m}")
 24032: 
 24033:     if not existing:
 24034:         print("[✓] Rien à déplacer: aucun candidat présent.")
 24035:         return 0
 24036: 
 24037:     # Dossier TRASH cible
 24038:     trash_name = args.trash_dir.strip() or f"TRASH_{_timestamp()}"
 24039:     trash_dir = (REPO_ROOT / trash_name).resolve()
 24040: 
 24041:     print(f"[i] Repo: {REPO_ROOT}")
 24042:     print(f"[i] Trash: {trash_dir}")
 24043:     print("[i] Candidats résolus:")
 24044:     for p in existing:
 24045:         print(f"    - {p.relative_to(REPO_ROOT)}")
 24046: 
 24047:     if not args.apply:
 24048:         print("\n[DRY-RUN] Ajoute --apply pour exécuter réellement les déplacements.")
 24049:         return 0
 24050: 
 24051:     # Exécution
 24052:     moved: List[Path] = []
 24053:     skipped: List[Tuple[Path, str]] = []
 24054:     use_git = _is_git_repo(REPO_ROOT) and not args.no_git
 24055: 
 24056:     for src in existing:
 24057:         rel = src.relative_to(REPO_ROOT)
 24058:         dst = trash_dir / rel  # conserve la structure relative
 24059:         dst.parent.mkdir(parents=True, exist_ok=True)
 24060: 
 24061:         if use_git:
 24062:             ok, how = _git_mv(src, dst)
 24063:         else:
 24064:             ok, how = _shutil_mv(src, dst)
 24065: 
 24066:         if ok:
 24067:             print(f"[→] {rel}  ->  {dst.relative_to(REPO_ROOT)}  ({how})")
 24068:             moved.append(dst)
 24069:         else:
 24070:             print(f"[!] SKIP {rel} ({how})")
 24071:             skipped.append((src, how))
 24072: 
 24073:     # Manifeste
 24074:     write_manifest(trash_dir, moved, skipped)
 24075:     print(f"[✓] Manifeste écrit: {trash_dir / 'TRASH_MANIFEST.txt'}")
 24076:     print("[✓] Terminé.")
 24077:     return 0
 24078: 
 24079: 
 24080: if __name__ == "__main__":
 24081:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: dumps/DUMP_20250824-121628.txt  (last modified: 2025-08-24 12:16:28)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/VERSION  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: 0.3.0
     2: 

--------------------------------------------------------------------------------
FILE: engine/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Rend le dossier 'scalper' importable comme package.
     2: __all__ = ["live", "signals", "core"]

--------------------------------------------------------------------------------
FILE: engine/adapters/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/adapters/bitget.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalp/adapters/bitget.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional
     4: import inspect, os
     5: import requests
     6: 
     7: # Client bas-niveau fourni par le repo
     8: from engine.bitget_client import BitgetFuturesClient as _Base
     9: 
    10: 
    11: def _to_float(x, default: float = 0.0) -> float:
    12:     try:
    13:         return float(x)
    14:     except Exception:
    15:         return default
    16: 
    17: 
    18: def _select_base_url() -> str:
    19:     env = os.environ.get("BITGET_BASE_URL")
    20:     if env:
    21:         return env
    22:     paper = os.environ.get("PAPER_TRADE", "true").lower() in ("1", "true", "yes", "on")
    23:     return "https://api-testnet.bitget.com" if paper else "https://api.bitget.com"
    24: 
    25: 
    26: class BitgetFuturesClient(_Base):
    27:     """
    28:     Adaptateur Bitget:
    29:       - __init__ dynamique (passe seulement les kwargs que le client accepte)
    30:       - Normalisations robustes: assets, ticker(s), positions, fills
    31:     """
    32: 
    33:     # --------------------- INIT dynamique ---------------------
    34:     def __init__(self, *args: Any, **kwargs: Any) -> None:
    35:         """
    36:         Accepte indifféremment:
    37:           api_key/apiKey/access_key/accessKey/key
    38:           api_secret/apiSecret/secret/secret_key/secretKey
    39:           passphrase/password/api_passphrase/apiPassphrase
    40:           base_url/baseUrl/host/endpoint (ou auto)
    41:         On n'envoie au client de base que les noms présents dans sa signature.
    42:         """
    43:         user_kwargs = dict(kwargs)
    44: 
    45:         # Collecte des valeurs possibles (tous alias)
    46:         incoming_key = (
    47:             user_kwargs.pop("api_key", None)
    48:             or user_kwargs.pop("apiKey", None)
    49:             or user_kwargs.pop("access_key", None)
    50:             or user_kwargs.pop("accessKey", None)
    51:             or user_kwargs.pop("key", None)
    52:             or user_kwargs.pop("API_KEY", None)
    53:         )
    54:         incoming_secret = (
    55:             user_kwargs.pop("api_secret", None)
    56:             or user_kwargs.pop("apiSecret", None)
    57:             or user_kwargs.pop("secret_key", None)
    58:             or user_kwargs.pop("secretKey", None)
    59:             or user_kwargs.pop("secret", None)
    60:             or user_kwargs.pop("API_SECRET", None)
    61:         )
    62:         incoming_pass = (
    63:             user_kwargs.pop("passphrase", None)
    64:             or user_kwargs.pop("password", None)
    65:             or user_kwargs.pop("api_passphrase", None)
    66:             or user_kwargs.pop("apiPassphrase", None)
    67:         )
    68:         incoming_base = (
    69:             user_kwargs.pop("base_url", None)
    70:             or user_kwargs.pop("baseUrl", None)
    71:             or user_kwargs.pop("host", None)
    72:             or user_kwargs.pop("endpoint", None)
    73:             or _select_base_url()
    74:         )
    75: 
    76:         # Signature réelle du client bas-niveau
    77:         sig = inspect.signature(_Base.__init__)
    78:         param_names = set(sig.parameters.keys())  # ex: {'self','access_key','secret_key','passphrase','base_url',...}
    79: 
    80:         def pick_name(cands: List[str]) -> Optional[str]:
    81:             for c in cands:
    82:                 if c in param_names:
    83:                     return c
    84:             return None
    85: 
    86:         # Noms réellement supportés
    87:         key_name = pick_name(["api_key", "apiKey", "access_key", "accessKey", "key"])
    88:         sec_name = pick_name(["api_secret", "apiSecret", "secret_key", "secretKey", "secret"])
    89:         pas_name = pick_name(["passphrase", "password", "api_passphrase", "apiPassphrase"])
    90:         base_name = pick_name(["base_url", "baseUrl", "host", "endpoint"])
    91:         req_mod_name = "requests_module" if "requests_module" in param_names else None
    92: 
    93:         # Construire kwargs à transmettre (une seule fois par nom)
    94:         base_kwargs: Dict[str, Any] = {}
    95:         if key_name and incoming_key is not None:
    96:             base_kwargs[key_name] = incoming_key
    97:         if sec_name and incoming_secret is not None:
    98:             base_kwargs[sec_name] = incoming_secret
    99:         if pas_name and incoming_pass is not None:
   100:             base_kwargs[pas_name] = incoming_pass
   101:         if base_name:
   102:             base_kwargs[base_name] = incoming_base
   103:         if req_mod_name:
   104:             base_kwargs[req_mod_name] = requests
   105: 
   106:         # Ne transmettre aucun doublon : si user_kwargs contient un nom supporté
   107:         # qui n'a pas été défini ci-dessus, on le relaie.
   108:         for k, v in list(user_kwargs.items()):
   109:             if k in param_names and k not in base_kwargs:
   110:                 base_kwargs[k] = v
   111: 
   112:         # Appel propre, 100% mots-clés (évite “missing positional arg” et “multiple values”)
   113:         super().__init__(**base_kwargs)
   114: 
   115:     # --------------------- COMPTES / ASSETS ---------------------
   116:     def get_assets(self) -> Dict[str, Any]:
   117:         raw = super().get_assets()
   118:         data = raw.get("data") or raw.get("result") or raw.get("assets") or []
   119:         norm: List[Dict[str, Any]] = []
   120:         for a in data:
   121:             currency = a.get("currency") or a.get("marginCoin") or a.get("coin") or "USDT"
   122:             equity = _to_float(a.get("equity", a.get("usdtEquity", a.get("totalEquity", 0))))
   123:             available = _to_float(a.get("available", a.get("availableBalance", a.get("availableUSDT", 0))))
   124:             norm.append({"currency": currency, "equity": equity, "available": available, **a})
   125:         return {"success": True, "data": norm}
   126: 
   127:     # ------------------------ TICKER(S) -------------------------
   128:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   129:         """
   130:         Normalise vers liste d'objets: {symbol,lastPrice,bidPrice,askPrice,volume}
   131:         Tolère top-level dict/list et items dict/list.
   132:         """
   133:         try:
   134:             raw: Any = super().get_ticker(symbol) if symbol else super().get_tickers()
   135:         except Exception as e:
   136:             return {"success": False, "error": repr(e), "data": []}
   137: 
   138:         items: List[Any] = []
   139:         if isinstance(raw, dict):
   140:             d = raw.get("data")
   141:             if symbol and isinstance(d, dict):
   142:                 items = [d]
   143:             else:
   144:                 items = d or raw.get("result") or raw.get("tickers") or []
   145:         elif isinstance(raw, (list, tuple)):
   146:             items = list(raw)
   147: 
   148:         norm: List[Dict[str, Any]] = []
   149:         for t in items:
   150:             if isinstance(t, dict):
   151:                 s = (t.get("symbol") or t.get("instId") or t.get("instrumentId") or "").replace("_", "")
   152:                 last_ = t.get("lastPrice", t.get("last", t.get("close", t.get("markPrice", 0))))
   153:                 bid_ = t.get("bidPrice", t.get("bestBidPrice", t.get("bestBid", t.get("buyOne", last_))))
   154:                 ask_ = t.get("askPrice", t.get("bestAskPrice", t.get("bestAsk", t.get("sellOne", last_))))
   155:                 vol_usdt = t.get("usdtVolume", t.get("quoteVolume", t.get("turnover24h", None)))
   156:                 vol_base = t.get("baseVolume", t.get("volume", t.get("size24h", 0)))
   157:                 volume = _to_float(vol_usdt if vol_usdt is not None else vol_base)
   158:                 norm.append({
   159:                     "symbol": s,
   160:                     "lastPrice": _to_float(last_),
   161:                     "bidPrice": _to_float(bid_),
   162:                     "askPrice": _to_float(ask_),
   163:                     "volume": volume
   164:                 })
   165:             else:
   166:                 seq = list(t)
   167:                 if len(seq) >= 5:
   168:                     first_ts = isinstance(seq[0], (int, float)) and seq[0] > 10**10
   169:                     if first_ts:
   170:                         close = _to_float(seq[4]); vol = _to_float(seq[5] if len(seq) > 5 else 0.0)
   171:                     else:
   172:                         close = _to_float(seq[3]); vol = _to_float(seq[4] if len(seq) > 4 else 0.0)
   173:                 else:
   174:                     close = _to_float(seq[-1] if seq else 0.0); vol = 0.0
   175:                 s = (symbol or "").replace("_", "")
   176:                 norm.append({"symbol": s, "lastPrice": close, "bidPrice": close, "askPrice": close, "volume": vol})
   177: 
   178:         return {"success": True, "data": norm}
   179: 
   180:     # --------------- POSITIONS / ORDRES / FILLS -----------------
   181:     def get_open_positions(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   182:         raw: Dict[str, Any] = super().get_positions() if hasattr(super(), "get_positions") else {}
   183:         items = raw.get("data") or raw.get("result") or raw.get("positions") or []
   184:         out: List[Dict[str, Any]] = []
   185:         for p in items:
   186:             s = (p.get("symbol") or p.get("instId") or "").replace("_", "")
   187:             if symbol and s != symbol:
   188:                 continue
   189:             side = (p.get("holdSide") or p.get("posSide") or p.get("side") or "").lower()
   190:             qty = _to_float(p.get("size", p.get("holdAmount", p.get("total", 0))))
   191:             avg = _to_float(p.get("avgOpenPrice", p.get("avgPrice", p.get("entryPrice", 0))))
   192:             out.append({"symbol": s, "side": side, "qty": qty, "avgEntryPrice": avg})
   193:         return {"success": True, "data": out}
   194: 
   195:     def get_fills(self, symbol: str, order_id: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
   196:         raw: Dict[str, Any] = super().get_fills(symbol=symbol) if hasattr(super(), "get_fills") else {}
   197:         items = raw.get("data") or raw.get("result") or []
   198:         out: List[Dict[str, Any]] = []
   199:         for f in items[:limit]:
   200:             s = (f.get("symbol") or f.get("instId") or "").replace("_", "")
   201:             if s != symbol:
   202:                 continue
   203:             if order_id and str(f.get("orderId") or f.get("ordId") or "") != str(order_id):
   204:                 continue
   205:             out.append({
   206:                 "orderId": str(f.get("orderId") or f.get("ordId") or ""),
   207:                 "tradeId": str(f.get("tradeId") or f.get("fillId") or f.get("execId") or ""),
   208:                 "price": _to_float(f.get("price", f.get("fillPx", 0))),
   209:                 "qty": _to_float(f.get("size", f.get("fillSz", 0))),
   210:                 "fee": _to_float(f.get("fee", f.get("fillFee", 0))),
   211:                 "ts": int(f.get("ts", f.get("time", 0))),
   212:             })
   213:         return {"success": True, "data": out}
   214: 
   215:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   216:         raw = super().cancel_order(symbol=symbol, orderId=order_id) if hasattr(super(), "cancel_order") else {}
   217:         ok = bool(raw.get("success", True)) if isinstance(raw, dict) else True
   218:         return {"success": ok, "data": {"orderId": order_id}}

--------------------------------------------------------------------------------
FILE: engine/adapters/bitget_fetch.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/adapters/bitget_fetch.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import inspect
     6: import os
     7: from typing import Any, Optional
     8: 
     9: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    10: 
    11: def _log(msg: str) -> None:
    12:     if BT_DEBUG:
    13:         print(f"[bt.debug] {msg}", flush=True)
    14: 
    15: _TF_TO_SECS = {
    16:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    17:     "1h": 3600, "4h": 14400, "1d": 86400,
    18: }
    19: _TF_TO_MIX = {  # granularity pour mix (docs Bitget)
    20:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    21:     "30m": "30min", "1h": "1h", "4h": "4h", "1d": "1day",
    22: }
    23: _TF_TO_SPOT = {  # period pour spot (docs Bitget)
    24:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min",
    25:     "30m": "30min", "1h": "1hour", "4h": "4hour", "1d": "1day",
    26: }
    27: 
    28: def _await_if_needed(val: Any) -> Any:
    29:     if inspect.isawaitable(val):
    30:         try:
    31:             asyncio.get_running_loop()
    32:         except RuntimeError:
    33:             return asyncio.run(val)
    34:         else:
    35:             fut = asyncio.run_coroutine_threadsafe(val, asyncio.get_running_loop())
    36:             return fut.result()
    37:     return val
    38: 
    39: class BitgetFetchAdapter:
    40:     """
    41:     Adaptateur qui fournit une méthode CCXT-like:
    42:       fetch_ohlcv(symbol, timeframe='5m', since=None, limit=1000)
    43:     au-dessus d'un client Bitget existant (sync ou async).
    44:     """
    45:     def __init__(self, client: Any, *, market_hint: str | None = None):
    46:         self.client = client
    47:         self.market_hint = (market_hint or "").lower() or None
    48:         _log(f"BitgetFetchAdapter attaché sur {type(client).__name__} (market_hint={self.market_hint})")
    49:         if hasattr(client, "fetch_ohlcv") and callable(getattr(client, "fetch_ohlcv")):
    50:             _log("Client expose déjà fetch_ohlcv → adaptation inutile (utilisation directe).")
    51: 
    52:     @staticmethod
    53:     def _possible_methods(client: Any) -> list[str]:
    54:         names = dir(client)
    55:         base = [
    56:             "fetch_ohlcv",
    57:             "get_candlesticks", "candlesticks", "get_candles", "candles",
    58:             "klines", "get_klines", "kline",
    59:             "mix_get_candles", "mix_candles",
    60:             "spot_get_candles", "spot_candles",
    61:             "market_candles", "public_candles",
    62:         ]
    63:         # + heuristique: tout ce qui contient candle/kline
    64:         extra = [n for n in names if ("candle" in n.lower() or "kline" in n.lower()) and callable(getattr(client, n))]
    65:         out = []
    66:         for n in base + extra:
    67:             if n in names and callable(getattr(client, n)) and n not in out:
    68:                 out.append(n)
    69:         _log(f"Méthodes candidates détectées: {out or '(aucune)'}")
    70:         return out
    71: 
    72:     @staticmethod
    73:     def _sym_variants(sym: str) -> list[str]:
    74:         s = sym.upper()
    75:         out = [s]
    76:         if not s.endswith("_UMCBL"):
    77:             out.append(f"{s}_UMCBL")
    78:         if not s.endswith("_SPBL"):
    79:             out.append(f"{s}_SPBL")
    80:         _log(f"Variantes symbole testées: {out}")
    81:         return out
    82: 
    83:     @staticmethod
    84:     def _param_variants(timeframe: str, market_hint: Optional[str]) -> list[dict]:
    85:         secs = _TF_TO_SECS.get(timeframe, 300)
    86:         mix = _TF_TO_MIX.get(timeframe, "5min")
    87:         spot = _TF_TO_SPOT.get(timeframe, "5min")
    88:         variants = []
    89:         if market_hint == "mix":
    90:             variants.append({"granularity": mix})
    91:         if market_hint == "spot":
    92:             variants.append({"period": spot})
    93:         variants += [
    94:             {"timeframe": timeframe},
    95:             {"interval": timeframe},
    96:             {"k": secs},
    97:             {"granularity": mix},
    98:             {"period": spot},
    99:         ]
   100:         _log(f"Variantes params testées pour tf={timeframe}: {variants}")
   101:         return variants
   102: 
   103:     @staticmethod
   104:     def _normalize_rows(raw: Any) -> list[list[float]]:
   105:         import pandas as pd  # local import
   106:         if raw is None:
   107:             raise ValueError("OHLCV vide")
   108:         if isinstance(raw, dict) and "data" in raw:
   109:             raw = raw["data"]
   110:         if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
   111:             out = []
   112:             for r in raw:
   113:                 ts = int(str(r[0]))
   114:                 o, h, l, c, v = map(float, (r[1], r[2], r[3], r[4], r[5]))
   115:                 out.append([ts, o, h, l, c, v])
   116:             return out
   117:         if "pandas" in str(type(raw)):
   118:             df = raw
   119:             if "timestamp" in df.columns:
   120:                 df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:                 df = df.set_index("timestamp").sort_index()
   122:             df = df[["open", "high", "low", "close", "volume"]]
   123:             return [[int(ts.value // 10**6), *map(float, row)] for ts, row in df.itertuples()]
   124:         raise ValueError(f"Format OHLCV inattendu: {type(raw)}")
   125: 
   126:     def fetch_ohlcv(self, symbol: str, timeframe: str = "5m", since: Any | None = None, limit: int = 1000):
   127:         methods = self._possible_methods(self.client)
   128:         if not methods:
   129:             raise AttributeError("Aucune méthode OHLCV trouvée sur le client Bitget")
   130: 
   131:         last_err: Exception | None = None
   132:         for mname in methods:
   133:             fn = getattr(self.client, mname)
   134:             for sym in self._sym_variants(symbol):
   135:                 for par in self._param_variants(timeframe, self.market_hint):
   136:                     kwargs = dict(par)
   137:                     kwargs.setdefault("symbol", sym)
   138:                     kwargs.setdefault("limit", limit)
   139:                     if since is not None:
   140:                         kwargs.setdefault("since", since)
   141:                     try:
   142:                         _log(f"→ Essai {mname}(kwargs={kwargs})")
   143:                         res = _await_if_needed(fn(**kwargs))
   144:                         rows = self._normalize_rows(res)
   145:                         if rows:
   146:                             unit = "ms" if rows and rows[0][0] > 10_000_000_000 else "s"
   147:                             first = rows[0][0]; last = rows[-1][0]
   148:                             _log(f"✓ OK via {mname} {sym} {par} | n={len(rows)} | "
   149:                                  f"t0={first} {unit}, t1={last} {unit}")
   150:                             return rows
   151:                     except TypeError as e:
   152:                         _log(f"TypeError {mname} {sym} {par}: {e}")
   153:                         last_err = e
   154:                     except Exception as e:
   155:                         _log(f"Erreur {mname} {sym} {par}: {e}")
   156:                         last_err = e
   157:         raise last_err or RuntimeError("Impossible d'obtenir l'OHLCV via le client Bitget")
   158: 
   159: def ensure_bitget_fetch(exchange: Any, *, market_hint: str | None = None) -> Any:
   160:     """Renvoie l'exchange si fetch_ohlcv existe, sinon un wrapper qui l’implémente. Log debug si BT_DEBUG=1."""
   161:     if hasattr(exchange, "fetch_ohlcv") and callable(getattr(exchange, "fetch_ohlcv")):
   162:         _log("exchange.fetch_ohlcv() déjà présent.")
   163:         return exchange
   164:     _log("exchange.fetch_ohlcv() absent → usage BitgetFetchAdapter.")
   165:     return BitgetFetchAdapter(exchange, market_hint=market_hint)

--------------------------------------------------------------------------------
FILE: engine/adapters/market_data.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/backtest/market_data.py
     2: from __future__ import annotations
     3: 
     4: import os
     5: from pathlib import Path
     6: from typing import Any
     7: 
     8: import pandas as pd
     9: 
    10: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    11: 
    12: def _log(msg: str) -> None:
    13:     if BT_DEBUG:
    14:         print(f"[bt.debug] {msg}", flush=True)
    15: 
    16: def _csv_path(data_dir: str | Path, symbol: str, timeframe: str) -> Path:
    17:     root = Path(data_dir)
    18:     root.mkdir(parents=True, exist_ok=True)
    19:     tf = timeframe.replace(":", "")
    20:     return root / f"{symbol}-{tf}.csv"
    21: 
    22: def _read_csv(path: Path) -> pd.DataFrame:
    23:     _log(f"lecture CSV: {path}")
    24:     df = pd.read_csv(path)
    25:     ts_col = next((c for c in df.columns if c.lower() in ("ts", "timestamp", "time", "date")), None)
    26:     if ts_col is None:
    27:         raise ValueError("Colonne temps introuvable (timestamp/time/date)")
    28:     df = df.rename(columns={ts_col: "timestamp"})
    29:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
    30:     df = df.set_index("timestamp").sort_index()
    31:     _log(f"→ CSV ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    32:     return df
    33: 
    34: def _write_csv(path: Path, df: pd.DataFrame) -> None:
    35:     tmp = df.reset_index().rename(columns={"index": "timestamp"})
    36:     if "timestamp" not in tmp.columns:
    37:         tmp = tmp.rename(columns={"index": "timestamp"})
    38:     tmp.to_csv(path, index=False)
    39:     _log(f"écrit CSV: {path} (n={len(df)})")
    40: 
    41: def fetch_ohlcv_via_exchange(exchange: Any, symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
    42:     _log(f"fetch via exchange.fetch_ohlcv: symbol={symbol} tf={timeframe} limit={limit}")
    43:     raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)  # peut être sync ou adapté
    44:     # Normalisation minimaliste (liste de listes)
    45:     rows = []
    46:     for r in raw:
    47:         ts = int(r[0])
    48:         unit = "ms" if ts > 10_000_000_000 else "s"
    49:         ts = pd.to_datetime(ts, unit=unit, utc=True)
    50:         rows.append([ts, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])])
    51:     df = pd.DataFrame(rows, columns=["timestamp", "open", "high", "low", "close", "volume"]).set_index("timestamp").sort_index()
    52:     _log(f"→ exchange ok, n={len(df)}, t0={df.index.min()}, t1={df.index.max()}")
    53:     return df
    54: 
    55: def hybrid_loader_from_exchange(exchange: Any, data_dir: str = "data", *, api_limit: int = 1000):
    56:     """
    57:     Loader hybride:
    58:       1) lit data/<SYMBOL>-<TF>.csv si présent,
    59:       2) sinon fetch via exchange.fetch_ohlcv, puis écrit le CSV en cache.
    60:     """
    61:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
    62:         path = _csv_path(data_dir, symbol, timeframe)
    63:         if path.exists():
    64:             df = _read_csv(path)
    65:             src = "csv"
    66:         else:
    67:             df = fetch_ohlcv_via_exchange(exchange, symbol, timeframe, limit=api_limit)
    68:             _write_csv(path, df)
    69:             src = "exchange"
    70:         if start:
    71:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
    72:         if end:
    73:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
    74:         _log(f"loader -> {symbol} {timeframe} (src={src}) n={len(df)} "
    75:              f"range=[{df.index.min()} .. {df.index.max()}]")
    76:         return df
    77:     return load

--------------------------------------------------------------------------------
FILE: engine/backtest/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/backtest/__init__.py
     2: from .runner import (
     3:     BTCfg, BTConfig,        # BTConfig = alias rétro-compat
     4:     run_multi, run_single,  # mêmes signatures async
     5:     save_results,           # no-op compat
     6: )
     7: from .cache import (
     8:     ensure_csv_cache, csv_path, read_csv_ohlcv, dump_validation_report,
     9:     tf_to_seconds,
    10: )

--------------------------------------------------------------------------------
FILE: engine/backtest/cache.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/backtest/cache.py
     2: from __future__ import annotations
     3: 
     4: import csv
     5: import json
     6: import os
     7: import time
     8: from dataclasses import dataclass
     9: from pathlib import Path
    10: from typing import Dict, List, Tuple, Iterable, Optional
    11: 
    12: # ---------------- Timeframe utils ----------------
    13: 
    14: _TF_SECONDS = {
    15:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    16:     "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
    17:     "1d": 86400, "3d": 259200, "1w": 604800,
    18: }
    19: 
    20: def tf_to_seconds(tf: str) -> int:
    21:     tf = tf.strip().lower()
    22:     if tf not in _TF_SECONDS:
    23:         raise ValueError(f"Timeframe inconnu: {tf}")
    24:     return _TF_SECONDS[tf]
    25: 
    26: # ---------------- Fraîcheur cible par TF ----------------
    27: 
    28: _DEFAULT_MAX_AGE = {
    29:     # règle empirique (peut être surchargée par ENV)
    30:     "1m": 2 * 3600,        # 2h
    31:     "3m": 4 * 3600,        # 4h
    32:     "5m": 12 * 3600,       # 12h
    33:     "15m": 24 * 3600,      # 24h
    34:     "30m": 36 * 3600,      # 36h
    35:     "1h": 3 * 86400,       # 3 jours
    36:     "2h": 5 * 86400,       # 5 jours
    37:     "4h": 10 * 86400,      # 10 jours
    38:     "6h": 15 * 86400,      # 15 jours
    39:     "12h": 20 * 86400,     # 20 jours
    40:     "1d": 3 * 86400,       # 3 jours (ok si 2 jours comme tu voulais)
    41:     "3d": 10 * 86400,
    42:     "1w": 30 * 86400,
    43: }
    44: 
    45: def max_age_for_tf(tf: str) -> int:
    46:     """Autorise override ENV via BACKTEST_MAX_AGE_<TF> (en secondes)."""
    47:     tf = tf.lower()
    48:     env_key = f"BACKTEST_MAX_AGE_{tf.replace('m','M').replace('h','H').replace('d','D').replace('w','W')}"
    49:     if env_key in os.environ:
    50:         try:
    51:             return int(os.environ[env_key])
    52:         except Exception:
    53:             pass
    54:     return _DEFAULT_MAX_AGE.get(tf, 7 * 86400)
    55: 
    56: # ---------------- CSV I/O ----------------
    57: 
    58: def data_dir() -> Path:
    59:     d = Path(os.getenv("DATA_DIR", "data"))
    60:     d.mkdir(parents=True, exist_ok=True)
    61:     return d
    62: 
    63: def csv_path(symbol: str, tf: str) -> Path:
    64:     return data_dir() / f"{symbol.upper()}-{tf}.csv"
    65: 
    66: def read_csv_ohlcv(path: Path) -> List[List[float]]:
    67:     out: List[List[float]] = []
    68:     if not path.exists():
    69:         return out
    70:     with path.open("r", newline="") as f:
    71:         r = csv.reader(f)
    72:         header = next(r, None)
    73:         for row in r:
    74:             # columns: timestamp,open,high,low,close,volume
    75:             try:
    76:                 ts, o, h, l, c, v = row[:6]
    77:                 out.append([int(ts), float(o), float(h), float(l), float(c), float(v)])
    78:             except Exception:
    79:                 continue
    80:     return out
    81: 
    82: def write_csv_ohlcv(path: Path, rows: Iterable[Iterable[float]]) -> None:
    83:     new_file = not path.exists()
    84:     with path.open("w", newline="") as f:
    85:         w = csv.writer(f)
    86:         w.writerow(["timestamp","open","high","low","close","volume"])
    87:         for r in rows:
    88:             w.writerow(r)
    89: 
    90: # ---------------- Validation / Chargement / Fetch ----------------
    91: 
    92: @dataclass
    93: class CacheInfo:
    94:     symbol: str
    95:     tf: str
    96:     path: Path
    97:     exists: bool
    98:     fresh: bool
    99:     last_ts: Optional[int] = None
   100:     rows: int = 0
   101: 
   102: def _is_fresh(last_ts: Optional[int], tf: str) -> bool:
   103:     if not last_ts:
   104:         return False
   105:     age = int(time.time()) - int(last_ts / 1000)
   106:     return age <= max_age_for_tf(tf)
   107: 
   108: def inspect_csv(symbol: str, tf: str) -> CacheInfo:
   109:     p = csv_path(symbol, tf)
   110:     if not p.exists():
   111:         return CacheInfo(symbol, tf, p, exists=False, fresh=False)
   112:     rows = read_csv_ohlcv(p)
   113:     last_ts = rows[-1][0] if rows else None
   114:     return CacheInfo(symbol, tf, p, exists=True, fresh=_is_fresh(last_ts, tf), last_ts=last_ts, rows=len(rows))
   115: 
   116: async def fetch_ohlcv_via_exchange(exchange, symbol: str, tf: str, limit: int) -> List[List[float]]:
   117:     # exchange: objet CCXT-like fourni par le live (déjà configuré Bitget)
   118:     return await exchange.fetch_ohlcv(symbol=symbol, timeframe=tf, limit=limit)
   119: 
   120: async def ensure_csv_for_symbol(exchange, symbol: str, tf: str, limit: int) -> Tuple[CacheInfo, List[List[float]]]:
   121:     info = inspect_csv(symbol, tf)
   122:     if info.exists and info.fresh:
   123:         data = read_csv_ohlcv(info.path)
   124:         return info, data
   125: 
   126:     # fetch & persist
   127:     data = await fetch_ohlcv_via_exchange(exchange, symbol, tf, limit=limit)
   128:     if data:
   129:         write_csv_ohlcv(info.path, data)
   130:         info = inspect_csv(symbol, tf)  # refresh stats
   131:     return info, data
   132: 
   133: async def ensure_csv_cache(exchange, symbols: List[str], tf: str, limit: int) -> Dict[str, List[List[float]]]:
   134:     """Vérifie le cache CSV et (re)charge depuis l'exchange si nécessaire."""
   135:     out: Dict[str, List[List[float]]] = {}
   136:     for s in symbols:
   137:         info, rows = await ensure_csv_for_symbol(exchange, s, tf, limit)
   138:         out[s] = rows
   139:     return out
   140: 
   141: def dump_validation_report(symbols: List[str], tf: str, out_path: Path) -> None:
   142:     report = []
   143:     for s in symbols:
   144:         info = inspect_csv(s, tf)
   145:         report.append({
   146:             "symbol": s,
   147:             "tf": tf,
   148:             "path": str(info.path),
   149:             "exists": info.exists,
   150:             "fresh": info.fresh,
   151:             "last_ts": info.last_ts,
   152:             "rows": info.rows,
   153:             "max_age": max_age_for_tf(tf),
   154:         })
   155:     out_path.parent.mkdir(parents=True, exist_ok=True)
   156:     out_path.write_text(json.dumps(report, indent=2))

--------------------------------------------------------------------------------
FILE: engine/backtest/cli.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import argparse
     4: from engine.backtest.runner import run_multi, csv_loader_factory
     5: 
     6: def create_parser() -> argparse.ArgumentParser:
     7:     p = argparse.ArgumentParser(prog="backtest", description="Backtest multi symboles / multi timeframes")
     8:     p.add_argument("--symbols", required=True, help="Liste, ex: BTCUSDT,ETHUSDT,SOLUSDT")
     9:     p.add_argument("--timeframes", required=True, help="Liste, ex: 1m,5m,15m")
    10:     p.add_argument("--data-dir", default="data", help="Répertoire CSV OHLCV")
    11:     p.add_argument("--out-dir", default="result", help="Répertoire de sortie")
    12:     p.add_argument("--cash", type=float, default=10_000.0)
    13:     p.add_argument("--risk", type=float, default=0.005, help="risk_pct par trade (0.005 = 0.5%)")
    14:     p.add_argument("--slippage-bps", type=float, default=1.5)
    15:     return p
    16: 
    17: def main(argv: list[str] | None = None) -> int:
    18:     p = create_parser()
    19:     a = p.parse_args(argv)
    20:     symbols = [s.strip().upper() for s in a.symbols.split(",") if s.strip()]
    21:     tfs = [t.strip() for t in a.timeframes.split(",") if t.strip()]
    22:     loader = csv_loader_factory(a.data_dir)
    23:     run_multi(
    24:         symbols=symbols,
    25:         timeframes=tfs,
    26:         loader=loader,
    27:         out_dir=a.out_dir,
    28:         initial_cash=a.cash,
    29:         risk_pct=a.risk,
    30:         slippage_bps=a.slippage_bps,
    31:     )
    32:     print(f"✅ Backtests terminés → {a.out_dir}/ (equity_curve/trades/fills/metrics/summary)")
    33:     return 0
    34: 
    35: if __name__ == "__main__":
    36:     raise SystemExit(main())

--------------------------------------------------------------------------------
FILE: engine/backtest/engine.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/backtest/engine.py
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Tuple
     4: import csv
     5: import os
     6: from dataclasses import dataclass
     7: from engine.strategy.factory import resolve_signal_fn
     8: from engine.core.signal import Signal
     9: from engine.backtest.position_sizing import position_size_from_signal, fees_cost
    10: 
    11: @dataclass
    12: class Trade:
    13:     symbol: str
    14:     timeframe: str
    15:     side: str
    16:     entry_ts: int
    17:     exit_ts: int
    18:     entry: float
    19:     exit: float
    20:     qty: float
    21:     pnl: float
    22:     pnl_after_fees: float
    23:     reasons: str
    24: 
    25: def _read_csv(path: str) -> Dict[str, List[float]]:
    26:     cols = ("timestamp","open","high","low","close","volume")
    27:     out = {k: [] for k in cols}
    28:     with open(path, "r", newline="", encoding="utf-8") as f:
    29:         r = csv.DictReader(f)
    30:         for row in r:
    31:             for k in cols:
    32:                 out[k].append(float(row[k]))
    33:     return out
    34: 
    35: def _slice(d: Dict[str, List[float]], end_idx: int) -> Dict[str, List[float]]:
    36:     return {k: v[: end_idx + 1] for k, v in d.items()}
    37: 
    38: class BacktestEngine:
    39:     def __init__(
    40:         self,
    41:         *,
    42:         symbol: str,
    43:         timeframe: str,
    44:         data: Dict[str, List[float]],
    45:         equity_start: float = 1_000.0,
    46:         risk_pct: float = 0.01,
    47:         fees_bps: float = 6.0,
    48:         warmup: int = 230,
    49:         strategies_cfg: Dict[str, Any],
    50:         data_1h: Optional[Dict[str, List[float]]] = None,
    51:     ):
    52:         self.symbol = symbol.upper()
    53:         self.tf = timeframe
    54:         self.data = data
    55:         self.data_1h = data_1h
    56:         self.equity = float(equity_start)
    57:         self.start_equity = float(equity_start)
    58:         self.risk_pct = float(risk_pct)
    59:         self.fees_bps = float(fees_bps)
    60:         self.warmup = int(warmup)
    61:         self.cfg = strategies_cfg
    62:         self.trades: List[Trade] = []
    63:         self.signals_rows: List[Dict[str, Any]] = []
    64:         self.signal_fn = resolve_signal_fn(self.symbol, self.tf, self.cfg)
    65: 
    66:     def run(self) -> Tuple[float, List[Trade]]:
    67:         n = len(self.data["close"])
    68:         pos_open: Optional[Signal] = None
    69:         pos_qty: float = 0.0
    70:         entry_idx: int = -1
    71: 
    72:         for i in range(self.warmup, n):
    73:             window = _slice(self.data, i)
    74:             window_1h = _slice(self.data_1h, self._map_1h_index(i)) if self.data_1h else None
    75: 
    76:             sig = self.signal_fn(
    77:                 symbol=self.symbol, timeframe=self.tf, ohlcv=window,
    78:                 equity=self.equity, risk_pct=self.risk_pct, ohlcv_1h=window_1h,
    79:             )
    80:             if sig:
    81:                 self.signals_rows.append(sig.as_dict())
    82: 
    83:             if pos_open is None and sig is not None:
    84:                 qty = position_size_from_signal(self.equity, sig, self.risk_pct * max(0.25, sig.quality))
    85:                 if qty <= 0:
    86:                     continue
    87:                 pos_open, pos_qty, entry_idx = sig, qty, i
    88:                 continue
    89: 
    90:             if pos_open is not None:
    91:                 hi = self.data["high"][i]
    92:                 lo = self.data["low"][i]
    93:                 exit_price: Optional[float] = None
    94:                 tp1 = pos_open.tp1 or pos_open.entry
    95:                 tp2 = pos_open.tp2 or pos_open.entry
    96:                 half_closed = False
    97:                 be = pos_open.entry
    98: 
    99:                 if pos_open.side == "long":
   100:                     if lo <= pos_open.sl:
   101:                         exit_price = pos_open.sl
   102:                     elif hi >= tp1:
   103:                         pnl_half = (tp1 - pos_open.entry) * (pos_qty * 0.5)
   104:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
   105:                         self.equity += pnl_half - fees
   106:                         pos_qty *= 0.5
   107:                         half_closed = True
   108:                         pos_open.sl = be
   109:                     if hi >= tp2:
   110:                         exit_price = tp2
   111:                 else:
   112:                     if hi >= pos_open.sl:
   113:                         exit_price = pos_open.sl
   114:                     elif lo <= tp1:
   115:                         pnl_half = (pos_open.entry - tp1) * (pos_qty * 0.5)
   116:                         fees = fees_cost(tp1 * (pos_qty * 0.5), self.fees_bps)
   117:                         self.equity += pnl_half - fees
   118:                         pos_qty *= 0.5
   119:                         half_closed = True
   120:                         pos_open.sl = be
   121:                     if lo <= tp2:
   122:                         exit_price = tp2
   123: 
   124:                 if exit_price is None and half_closed:
   125:                     continue
   126: 
   127:                 if exit_price is not None:
   128:                     pnl = (exit_price - pos_open.entry) * pos_qty if pos_open.side == "long" else (pos_open.entry - exit_price) * pos_qty
   129:                     fees = fees_cost(exit_price * pos_qty, self.fees_bps)
   130:                     pnl_after = pnl - fees
   131:                     self.equity += pnl_after
   132: 
   133:                     tr = Trade(
   134:                         symbol=self.symbol, timeframe=self.tf, side=pos_open.side,
   135:                         entry_ts=int(self.data["timestamp"][entry_idx]), exit_ts=int(self.data["timestamp"][i]),
   136:                         entry=pos_open.entry, exit=exit_price, qty=pos_qty,
   137:                         pnl=pnl, pnl_after_fees=pnl_after, reasons="|".join(pos_open.reasons),
   138:                     )
   139:                     self.trades.append(tr)
   140:                     pos_open, pos_qty, entry_idx = None, 0.0, -1
   141: 
   142:         return self.equity, self.trades
   143: 
   144:     def _map_1h_index(self, i_main: int) -> int:
   145:         if not self.data_1h:
   146:             return 0
   147:         ts = self.data["timestamp"][i_main]
   148:         arr = self.data_1h["timestamp"]
   149:         j = 0
   150:         while j + 1 < len(arr) and arr[j + 1] <= ts:
   151:             j += 1
   152:         return j
   153: 
   154:     # --- E/S helpers ---
   155:     @staticmethod
   156:     def load_csv(path: str) -> Dict[str, List[float]]:
   157:         if not os.path.isfile(path):
   158:             raise FileNotFoundError(f"CSV OHLCV introuvable: {path}")
   159:         return _read_csv(path)
   160: 
   161:     def save_results(self, out_dir: str = "backtest_out") -> None:
   162:         os.makedirs(out_dir, exist_ok=True)
   163:         if self.signals_rows:
   164:             sig_path = os.path.join(out_dir, f"signals_{self.symbol}_{self.tf}.csv")
   165:             keys = sorted(self.signals_rows[0].keys())
   166:             with open(sig_path, "w", newline="", encoding="utf-8") as f:
   167:                 import csv
   168:                 w = csv.DictWriter(f, fieldnames=keys)
   169:                 w.writeheader()
   170:                 for row in self.signals_rows:
   171:                     w.writerow(row)
   172:         if self.trades:
   173:             tr_path = os.path.join(out_dir, f"trades_{self.symbol}_{self.tf}.csv")
   174:             with open(tr_path, "w", newline="", encoding="utf-8") as f:
   175:                 import csv
   176:                 w = csv.writer(f)
   177:                 w.writerow(["symbol","timeframe","side","entry_ts","exit_ts","entry","exit","qty","pnl","pnl_after_fees","reasons"])
   178:                 for t in self.trades:
   179:                     w.writerow([t.symbol,t.timeframe,t.side,t.entry_ts,t.exit_ts,t.entry,t.exit,t.qty,t.pnl,t.pnl_after_fees,t.reasons])
   180: 
   181:     def summary(self) -> Dict[str, float]:
   182:         eq = self.equity
   183:         ret = (eq / self.start_equity - 1.0) * 100.0
   184:         n = len(self.trades)
   185:         wins = sum(1 for t in self.trades if t.pnl_after_fees > 0)
   186:         winrate = (wins / n * 100.0) if n else 0.0
   187:         return {"equity_end": eq, "return_pct": ret, "trades": float(n), "winrate_pct": winrate}

--------------------------------------------------------------------------------
FILE: engine/backtest/grid_search.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Grid-search express module to evaluate hyperparameter combinations.
     2: 
     3: This module builds combinations of strategy and engine parameters, runs the
     4: existing multi symbol backtester for each combination, collects key metrics and
     5: selects the best configuration according to:
     6: 
     7: 1. Profit factor (descending)
     8: 2. Maximum drawdown percentage (ascending)
     9: 3. Net PnL in USDT (descending)
    10: 4. Number of trades (ascending)
    11: 
    12: Results are written under ``result/grid`` by default and a short summary is
    13: printed to the console.
    14: """
    15: from __future__ import annotations
    16: 
    17: from dataclasses import dataclass
    18: import csv
    19: import json
    20: import os
    21: import random
    22: from itertools import product
    23: from typing import Any, Callable, Dict, Iterable, List, Sequence
    24: 
    25: # ---------------------------------------------------------------------------
    26: # Utilities
    27: # ---------------------------------------------------------------------------
    28: 
    29: 
    30: def parse_hours(hours: str) -> List[int]:
    31:     """Parse hours specification like ``"7-11,13-17"`` into a list of ints.
    32: 
    33:     Each comma separated element can either be a single hour (``"8"``) or a
    34:     range ``"7-11"`` which is inclusive.  Returned hours are sorted and unique.
    35:     """
    36: 
    37:     if not hours:
    38:         return []
    39:     result: List[int] = []
    40:     for part in hours.split(","):
    41:         part = part.strip()
    42:         if not part:
    43:             continue
    44:         if "-" in part:
    45:             start_s, end_s = part.split("-", 1)
    46:             start, end = int(start_s), int(end_s)
    47:             result.extend(range(start, end + 1))
    48:         else:
    49:             result.append(int(part))
    50:     return sorted(set(result))
    51: 
    52: 
    53: # Order of parameters used throughout the module and in CSV output
    54: PARAM_KEYS = [
    55:     "timeframe",
    56:     "score_min",
    57:     "atr_min_ratio",
    58:     "rr_min",
    59:     "risk_pct",
    60:     "slippage_bps",
    61:     "fee_rate",
    62:     "cooldown_secs",
    63:     "hours",
    64: ]
    65: 
    66: # Default values used if a parameter is not provided in the grid
    67: DEFAULTS = {
    68:     "score_min": 55,
    69:     "atr_min_ratio": 0.002,
    70:     "rr_min": 1.2,
    71:     "risk_pct": 0.01,
    72:     "slippage_bps": 2,
    73:     "fee_rate": 0.001,
    74:     "cooldown_secs": 300,
    75:     "hours": "7-11,13-17",
    76: }
    77: 
    78: 
    79: @dataclass
    80: class GridResult:
    81:     params: Dict[str, Any]
    82:     metrics: Dict[str, float]
    83: 
    84: 
    85: def _ensure_list(val: Sequence[Any] | Any) -> List[Any]:
    86:     if isinstance(val, (list, tuple, set)):
    87:         return list(val)
    88:     return [val]
    89: 
    90: 
    91: def build_param_grid(param_lists: Dict[str, Sequence[Any]], grid_max: int) -> List[Dict[str, Any]]:
    92:     """Return a list of parameter combinations.
    93: 
    94:     ``param_lists`` maps parameter names to a sequence of values.  Missing keys
    95:     fall back to ``DEFAULTS``.  The resulting cartesian product is uniformly
    96:     sampled to ``grid_max`` elements when necessary while trying to maintain a
    97:     variety of timeframes and ``atr_min_ratio`` values.
    98:     """
    99: 
   100:     lists: Dict[str, List[Any]] = {}
   101:     for key in PARAM_KEYS:
   102:         if key == "timeframe":
   103:             # timeframe must be explicitly provided; default empty -> "1m"
   104:             vals = param_lists.get(key) or ["1m"]
   105:         else:
   106:             vals = param_lists.get(key)
   107:             if not vals:
   108:                 default = DEFAULTS[key]
   109:                 vals = [default]
   110:         lists[key] = _ensure_list(vals)
   111: 
   112:     combos: List[Dict[str, Any]] = [
   113:         dict(zip(PARAM_KEYS, values)) for values in product(*(lists[k] for k in PARAM_KEYS))
   114:     ]
   115: 
   116:     # Uniform sampling if exceeding grid_max
   117:     if len(combos) > grid_max:
   118:         step = len(combos) / float(grid_max)
   119:         sampled = []
   120:         for i in range(grid_max):
   121:             idx = int(round(i * step))
   122:             if idx >= len(combos):
   123:                 idx = len(combos) - 1
   124:             sampled.append(combos[idx])
   125:         # ensure each timeframe appears at least once
   126:         wanted_tfs = set(lists["timeframe"])
   127:         present_tfs = {c["timeframe"] for c in sampled}
   128:         missing = list(wanted_tfs - present_tfs)
   129:         if missing:
   130:             for tf in missing:
   131:                 for c in combos:
   132:                     if c["timeframe"] == tf and c not in sampled:
   133:                         sampled.append(c)
   134:                         break
   135:             sampled = sampled[:grid_max]
   136:         combos = sampled
   137:     return combos
   138: 
   139: 
   140: # ---------------------------------------------------------------------------
   141: # Core runner
   142: # ---------------------------------------------------------------------------
   143: 
   144: 
   145: def run_grid_search(
   146:     *,
   147:     symbols: Sequence[str],
   148:     exchange: str,
   149:     base_params: Dict[str, Any],
   150:     param_lists: Dict[str, Sequence[Any]],
   151:     grid_max: int = 12,
   152:     csv_dir: str | None = None,
   153:     initial_equity: float = 1000.0,
   154:     leverage: float = 1.0,
   155:     paper_constraints: bool = True,
   156:     seed: int | None = None,
   157:     out_dir: str = "./result/grid",
   158:     match_exchange_semantics: bool = False,  # placeholder for compatibility
   159:     run_func: Callable[..., Any] | None = None,
   160: ) -> List[GridResult]:
   161:     """Execute grid search across parameter combinations.
   162: 
   163:     ``base_params`` provides default single values for parameters. ``param_lists``
   164:     contains the grid specifications from CLI (already parsed into sequences).
   165:     ``run_func`` should have the same signature as :func:`run_backtest_multi`.
   166:     """
   167: 
   168:     if seed is not None:
   169:         random.seed(seed)
   170: 
   171:     if run_func is None:  # avoid circular import at module load
   172:         from .run_multi import run_backtest_multi  # late import
   173: 
   174:         run_func = run_backtest_multi
   175: 
   176:     # merge lists with defaults
   177:     full_lists: Dict[str, Sequence[Any]] = {}
   178:     for k in PARAM_KEYS:
   179:         if k == "timeframe":
   180:             full_lists[k] = param_lists.get(k) or [base_params.get("timeframe", "1m")]
   181:         else:
   182:             if param_lists.get(k) is not None:
   183:                 full_lists[k] = param_lists[k]
   184:             else:
   185:                 full_lists[k] = [base_params.get(k, DEFAULTS[k])]
   186: 
   187:     combos = build_param_grid(full_lists, grid_max)
   188: 
   189:     results: List[GridResult] = []
   190:     os.makedirs(out_dir, exist_ok=True)
   191: 
   192:     for combo in combos:
   193:         # Build parameters for backtester
   194:         tf = combo["timeframe"]
   195:         fee = float(combo["fee_rate"])
   196:         slip = float(combo["slippage_bps"])
   197:         risk = float(combo["risk_pct"])
   198: 
   199:         summary, _trades = run_func(
   200:             symbols=list(symbols),
   201:             exchange=exchange,
   202:             timeframe=tf,
   203:             csv_dir=csv_dir,
   204:             fee_rate=fee,
   205:             slippage_bps=slip,
   206:             risk_pct=risk,
   207:             initial_equity=initial_equity,
   208:             leverage=leverage,
   209:             paper_constraints=paper_constraints,
   210:             seed=seed,
   211:             out_dir=os.path.join(out_dir, "tmp"),
   212:             plot=False,
   213:             dry_run=True,
   214:         )
   215:         total = next((r for r in summary if r.get("symbol") == "TOTAL"), summary[-1])
   216:         metrics = {
   217:             "pnl_usdt": float(total.get("pnl_usdt", 0.0)),
   218:             "profit_factor": float(total.get("profit_factor", 0.0)),
   219:             "max_dd_pct": float(total.get("max_drawdown_pct", 0.0)),
   220:             "winrate_pct": float(total.get("winrate_pct", 0.0)),
   221:             "trades": float(total.get("trades", 0.0)),
   222:             "final_equity": initial_equity + float(total.get("pnl_usdt", 0.0)),
   223:         }
   224:         results.append(GridResult(params=combo, metrics=metrics))
   225: 
   226:     # sort results
   227:     results.sort(
   228:         key=lambda r: (
   229:             -r.metrics["profit_factor"],
   230:             r.metrics["max_dd_pct"],
   231:             -r.metrics["pnl_usdt"],
   232:             r.metrics["trades"],
   233:         )
   234:     )
   235: 
   236:     # console output -------------------------------------------------------
   237:     print(
   238:         f"Grid-search express ({len(results)} combinaisons testées, top trié par PF↓ puis MaxDD%↑)"
   239:     )
   240:     header = (
   241:         f"{'timeframe':<8} {'PF':>6} {'MaxDD%':>8} {'PnL':>8} {'Trades':>8}"
   242:     )
   243:     print(header)
   244:     for r in results[:10]:
   245:         m = r.metrics
   246:         print(
   247:             f"{r.params['timeframe']:<8} {m['profit_factor']:>6.2f} {m['max_dd_pct']:>8.2f} {m['pnl_usdt']:>8.2f} {int(m['trades']):>8}"
   248:         )
   249: 
   250:     # write csv ------------------------------------------------------------
   251:     csv_cols = PARAM_KEYS + [
   252:         "pnl_usdt",
   253:         "profit_factor",
   254:         "max_dd_pct",
   255:         "winrate_pct",
   256:         "trades",
   257:         "final_equity",
   258:     ]
   259:     with open(os.path.join(out_dir, "grid_results.csv"), "w", newline="") as fh:
   260:         writer = csv.DictWriter(fh, fieldnames=csv_cols)
   261:         writer.writeheader()
   262:         for r in results:
   263:             row = {**r.params, **r.metrics}
   264:             writer.writerow(row)
   265: 
   266:     best = results[0]
   267:     with open(os.path.join(out_dir, "best_config.json"), "w", encoding="utf8") as fh:
   268:         json.dump({"params": best.params, "metrics": best.metrics}, fh, indent=2)
   269: 
   270:     # markdown summary -----------------------------------------------------
   271:     md_path = os.path.join(out_dir, "grid_summary.md")
   272:     with open(md_path, "w", encoding="utf8") as fh:
   273:         fh.write(
   274:             "| timeframe | PF | MaxDD% | PnL | trades |\n|---|---|---|---|---|\n"
   275:         )
   276:         for r in results[:10]:
   277:             m = r.metrics
   278:             fh.write(
   279:                 f"| {r.params['timeframe']} | {m['profit_factor']:.2f} | {m['max_dd_pct']:.2f} | {m['pnl_usdt']:.2f} | {int(m['trades'])} |\n"
   280:             )
   281: 
   282:     # optional scatter plot ------------------------------------------------
   283:     try:  # pragma: no cover - optional dependency
   284:         import matplotlib.pyplot as plt
   285: 
   286:         pf = [r.metrics["profit_factor"] for r in results]
   287:         dd = [r.metrics["max_dd_pct"] for r in results]
   288:         trades = [r.metrics["trades"] for r in results]
   289:         tfs = [r.params["timeframe"] for r in results]
   290:         colors = {tf: i for i, tf in enumerate(sorted(set(tfs)))}
   291:         c = [colors[tf] for tf in tfs]
   292:         plt.figure(figsize=(6, 4))
   293:         plt.scatter(dd, pf, c=c, s=[max(10, t) for t in trades], alpha=0.7)
   294:         plt.xlabel("MaxDD%")
   295:         plt.ylabel("Profit Factor")
   296:         plt.title("PF vs MaxDD")
   297:         plt.savefig(os.path.join(out_dir, "pf_vs_dd.png"))
   298:         plt.close()
   299:     except Exception:  # pragma: no cover
   300:         pass
   301: 
   302:     return results
   303: 
   304: 
   305: __all__ = ["run_grid_search", "build_param_grid", "parse_hours", "GridResult"]

--------------------------------------------------------------------------------
FILE: engine/backtest/loader_csv.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/backtest/loader_csv.py
     2: from __future__ import annotations
     3: 
     4: import csv
     5: from typing import Dict, List
     6: 
     7: from engine.services.data_cache import csv_path
     8: 
     9: # Format de sortie : liste de bougies [ts, open, high, low, close, volume]
    10: def load_ohlcv_csv(symbol: str, timeframe: str) -> List[List[float]]:
    11:     path = csv_path(symbol, timeframe)
    12:     rows: List[List[float]] = []
    13:     with open(path, "r") as f:
    14:         r = csv.DictReader(f)
    15:         for row in r:
    16:             rows.append([
    17:                 int(row["timestamp"]),
    18:                 float(row["open"]),
    19:                 float(row["high"]),
    20:                 float(row["low"]),
    21:                 float(row["close"]),
    22:                 float(row["volume"]),
    23:             ])
    24:     rows.sort(key=lambda x: x[0])
    25:     return rows
    26: 
    27: 
    28: def load_many(symbols: List[str], timeframe: str) -> Dict[str, List[List[float]]]:
    29:     out: Dict[str, List[List[float]]] = {}
    30:     for s in symbols:
    31:         out[s] = load_ohlcv_csv(s, timeframe)
    32:     return out

--------------------------------------------------------------------------------
FILE: engine/backtest/market_data.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import time
     6: from pathlib import Path
     7: from typing import Any, Iterable, Optional, Sequence, Tuple
     8: from urllib.request import Request, urlopen
     9: from urllib.error import URLError, HTTPError
    10: 
    11: import pandas as pd
    12: 
    13: # ============================================================================
    14: # Logs & utilitaires
    15: # ============================================================================
    16: BT_DEBUG = int(os.getenv("BT_DEBUG", "0") or "0")
    17: def _log(msg: str) -> None:
    18:     if BT_DEBUG:
    19:         print(f"[bt.debug] {msg}", flush=True)
    20: 
    21: def _now_ms() -> int:
    22:     return int(time.time() * 1000)
    23: 
    24: def _tf_to_seconds(tf: str) -> int:
    25:     tf = tf.lower().strip()
    26:     table = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"4h":14400,"1d":86400}
    27:     if tf not in table:
    28:         raise ValueError(f"Timeframe non supporté: {tf}")
    29:     return table[tf]
    30: 
    31: def _parse_duration(s: str) -> int:
    32:     """
    33:     '90s','15m','2h','3d' -> secondes
    34:     """
    35:     s = s.strip().lower()
    36:     if s.endswith("s"): return int(float(s[:-1]))
    37:     if s.endswith("m"): return int(float(s[:-1])*60)
    38:     if s.endswith("h"): return int(float(s[:-1])*3600)
    39:     if s.endswith("d"): return int(float(s[:-1])*86400)
    40:     return int(float(s))  # secondes
    41: 
    42: # ============================================================================
    43: # Politique de fraîcheur (par défaut + overrides via ENV)
    44: # ============================================================================
    45: def _default_max_age_seconds(tf: str) -> int:
    46:     """
    47:     Règles par défaut (conservatrices) :
    48:       - 1m..15m : 2 × TF  (ex: 5m -> 10m)
    49:       - 30m     : 1h
    50:       - 1h      : 6h
    51:       - 4h      : 24h
    52:       - 1d      : 3d
    53:     """
    54:     tf = tf.lower()
    55:     if tf in ("1m","3m","5m","15m"):
    56:         return 2 * _tf_to_seconds(tf)
    57:     if tf == "30m":
    58:         return 3600
    59:     if tf == "1h":
    60:         return 6*3600
    61:     if tf == "4h":
    62:         return 24*3600
    63:     if tf == "1d":
    64:         return 3*86400
    65:     raise ValueError(tf)
    66: 
    67: def _max_age_seconds(tf: str) -> int:
    68:     """
    69:     Overrides possibles (au choix) :
    70:       - CSV_MAX_AGE_MULT=NN → NN × TF  (ex: 50 pour 1m => 50 minutes)
    71:       - CSV_MAX_AGE_5m="45m" (prioritaire si présent)
    72:       - CSV_MAX_AGE_DEFAULT="2h" (fallback global)
    73:     """
    74:     tfk = tf.lower().replace(":", "")
    75:     env_spec = os.getenv(f"CSV_MAX_AGE_{tfk}")
    76:     if env_spec:
    77:         return _parse_duration(env_spec)
    78:     mult = os.getenv("CSV_MAX_AGE_MULT")
    79:     if mult:
    80:         return int(float(mult) * _tf_to_seconds(tf))
    81:     g = os.getenv("CSV_MAX_AGE_DEFAULT")
    82:     if g:
    83:         return _parse_duration(g)
    84:     return _default_max_age_seconds(tf)
    85: 
    86: # ============================================================================
    87: # CSV helpers + validation
    88: # ============================================================================
    89: def _data_dir(default: str = "data") -> Path:
    90:     root = Path(os.getenv("DATA_DIR", default))
    91:     root.mkdir(parents=True, exist_ok=True)
    92:     return root
    93: 
    94: def _csv_path(symbol: str, timeframe: str) -> Path:
    95:     tf = timeframe.replace(":", "")
    96:     return _data_dir() / f"{symbol}-{tf}.csv"
    97: 
    98: def _rows_to_df(rows: Iterable[Iterable[float]]) -> pd.DataFrame:
    99:     rows = list(rows)
   100:     if not rows:
   101:         raise ValueError("OHLCV vide")
   102:     unit = "ms" if rows[0][0] > 10_000_000_000 else "s"
   103:     df = pd.DataFrame(rows, columns=["ts","open","high","low","close","volume"])
   104:     df["timestamp"] = pd.to_datetime(df["ts"], unit=unit, utc=True)
   105:     return df.drop(columns=["ts"]).set_index("timestamp").sort_index()
   106: 
   107: def _read_csv(path: Path) -> pd.DataFrame:
   108:     df = pd.read_csv(path)
   109:     # tolère quelques variations de colonnes
   110:     cols = {c.lower(): c for c in df.columns}
   111:     ts_col = cols.get("timestamp") or cols.get("time") or cols.get("date") or cols.get("ts")
   112:     if not ts_col:
   113:         raise ValueError("Colonne temps absente (timestamp/time/date/ts)")
   114:     rename = {ts_col: "timestamp"}
   115:     for c in ("open","high","low","close","volume"):
   116:         if c not in cols:
   117:             raise ValueError(f"Colonne manquante: {c}")
   118:         rename[cols[c]] = c
   119:     df = df.rename(columns=rename)
   120:     df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True, infer_datetime_format=True)
   121:     df = df[["timestamp","open","high","low","close","volume"]].sort_values("timestamp")
   122:     df = df.drop_duplicates("timestamp")
   123:     df = df.set_index("timestamp")
   124:     return df
   125: 
   126: def _write_csv(path: Path, df: pd.DataFrame) -> None:
   127:     out = df.reset_index().rename(columns={"index": "timestamp"})
   128:     out.to_csv(path, index=False)
   129: 
   130: def _is_csv_fresh_and_valid(path: Path, timeframe: str, *, min_rows: int = 100) -> Tuple[bool, str]:
   131:     """
   132:     Retourne (ok, reason). ok=True si le CSV est utilisable:
   133:       - schéma valide
   134:       - assez de lignes
   135:       - fraîcheur < seuil selon TF
   136:     """
   137:     if not path.exists():
   138:         return False, "absent"
   139:     try:
   140:         df = _read_csv(path)
   141:     except Exception as e:
   142:         return False, f"invalid({e})"
   143:     if len(df) < min_rows:
   144:         return False, f"too_few_rows({len(df)}<{min_rows})"
   145:     # Fraîcheur
   146:     last_ts = int(df.index.max().timestamp())
   147:     age_s = int(time.time()) - last_ts
   148:     max_age = _max_age_seconds(timeframe)
   149:     if age_s > max_age:
   150:         return False, f"stale({age_s}s>{max_age}s)"
   151:     # Monotonicité (échantillon)
   152:     if not df.index.is_monotonic_increasing:
   153:         return False, "not_monotonic"
   154:     return True, "ok"
   155: 
   156: # ============================================================================
   157: # Fallback réseau (CCXT d'abord, HTTP sinon)
   158: # ============================================================================
   159: def _ensure_ccxt() -> Any | None:
   160:     try:
   161:         import ccxt  # type: ignore
   162:         return ccxt
   163:     except Exception:
   164:         return None
   165: 
   166: def _fetch_via_ccxt(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   167:     ccxt = _ensure_ccxt()
   168:     if not ccxt:
   169:         _log("ccxt indisponible")
   170:         return None
   171:     ex = ccxt.bitget({"enableRateLimit": True, "options": {"defaultType": "swap"}})
   172:     ex.load_markets()
   173:     base = symbol.upper()
   174:     if not base.endswith("USDT"):
   175:         raise ValueError("symbol doit finir par USDT (ex: BTCUSDT)")
   176:     coin = base[:-4]
   177:     candidates = [f"{coin}/USDT:USDT", f"{coin}/USDT"]  # perp puis spot
   178:     for ccxt_sym in candidates:
   179:         try:
   180:             rows = ex.fetch_ohlcv(ccxt_sym, timeframe=timeframe, limit=limit)
   181:             if rows:
   182:                 return _rows_to_df(sorted(rows, key=lambda r: r[0]))
   183:         except Exception as e:
   184:             _log(f"ccxt fail {ccxt_sym}: {e}")
   185:             continue
   186:     return None
   187: 
   188: # === (facultatif) HTTP Bitget v1 minimal ===
   189: _GRAN_MIX = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1day"}
   190: _PERIOD_SPOT = {"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","1d":"1day"}
   191: 
   192: def _http_get(url: str, timeout: int = 20) -> dict | list:
   193:     req = Request(url, headers={"User-Agent":"backtest-marketdata/1.0"})
   194:     with urlopen(req, timeout=timeout) as resp:
   195:         return json.loads(resp.read().decode("utf-8"))
   196: 
   197: def _normalize_http_rows(payload: dict | list) -> list[list[float]]:
   198:     rows = payload.get("data") if isinstance(payload, dict) else payload
   199:     if not isinstance(rows, list):
   200:         raise ValueError(f"Réponse inattendue: {payload}")
   201:     out = []
   202:     for r in rows:
   203:         ts = int(str(r[0])); o,h,l,c,v = map(float,(r[1],r[2],r[3],r[4],r[5]))
   204:         out.append([ts,o,h,l,c,v])
   205:     out.sort(key=lambda x:x[0])
   206:     return out
   207: 
   208: def _fetch_via_http(symbol: str, timeframe: str, limit: int = 1000) -> Optional[pd.DataFrame]:
   209:     tf = timeframe.lower()
   210:     g = _GRAN_MIX.get(tf); p = _PERIOD_SPOT.get(tf)
   211:     if not (g and p):
   212:         return None
   213:     # mix umcbl puis spot spbl, paramètres minimum (v1)
   214:     trials = [
   215:         f"https://api.bitget.com/api/mix/v1/market/candles?symbol={symbol}_UMCBL&granularity={g}&limit={limit}",
   216:         f"https://api/bitget.com/api/mix/v1/market/candles?symbol={symbol}&granularity={g}&limit={limit}",
   217:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}_SPBL&period={p}&limit={limit}",
   218:         f"https://api.bitget.com/api/spot/v1/market/candles?symbol={symbol}&period={p}&limit={limit}",
   219:     ]
   220:     for url in trials:
   221:         try:
   222:             payload = _http_get(url)
   223:             if isinstance(payload, dict) and "code" in payload and str(payload["code"]) != "00000" and "data" not in payload:
   224:                 raise RuntimeError(f"Bitget error {payload.get('code')}: {payload.get('msg')}")
   225:             rows = _normalize_http_rows(payload)
   226:             if rows:
   227:                 return _rows_to_df(rows)
   228:         except Exception as e:
   229:             _log(f"HTTP fail: {url} -> {e}")
   230:             continue
   231:     return None
   232: 
   233: # ============================================================================
   234: # API publique utilisée par l’orchestrateur/backtest
   235: # ============================================================================
   236: def fetch_ohlcv_best(symbol: str, timeframe: str, *, limit: int = 1000) -> pd.DataFrame:
   237:     """
   238:     Tente d’abord CCXT (si présent), sinon HTTP v1. Lève si tout échoue.
   239:     """
   240:     df = _fetch_via_ccxt(symbol, timeframe, limit=limit)
   241:     if df is not None:
   242:         _log(f"source=ccxt  n={len(df)}")
   243:         return df
   244:     df = _fetch_via_http(symbol, timeframe, limit=limit)
   245:     if df is not None:
   246:         _log(f"source=http  n={len(df)}")
   247:         return df
   248:     raise RuntimeError(f"Aucune source OHLCV pour {symbol} {timeframe}")
   249: 
   250: def hybrid_loader(
   251:     data_dir: str = "data",
   252:     *,
   253:     use_cache_first: bool = True,
   254:     min_rows: int = 100,
   255:     refill_if_stale: bool = True,
   256:     network_limit: int = 1000,
   257: ):
   258:     """
   259:     Loader smart :
   260:       1) si CSV présent ET frais/valide → le renvoie
   261:       2) sinon, si refill_if_stale → recharge (CCXT>HTTP) puis écrit CSV
   262:       3) sinon → lève
   263:     """
   264:     os.environ.setdefault("DATA_DIR", data_dir)
   265: 
   266:     def load(symbol: str, timeframe: str, start: str | None, end: str | None) -> pd.DataFrame:
   267:         path = _csv_path(symbol, timeframe)
   268: 
   269:         if use_cache_first:
   270:             ok, why = _is_csv_fresh_and_valid(path, timeframe, min_rows=min_rows)
   271:             if ok:
   272:                 _log(f"CSV OK: {path}")
   273:                 df = _read_csv(path)
   274:             else:
   275:                 _log(f"CSV non utilisable ({why}): {path}")
   276:                 if not refill_if_stale:
   277:                     raise RuntimeError(f"CSV invalide et recharge désactivée: {path} ({why})")
   278:                 df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   279:                 _write_csv(path, df)
   280:         else:
   281:             df = fetch_ohlcv_best(symbol, timeframe, limit=network_limit)
   282:             _write_csv(path, df)
   283: 
   284:         # Fenêtrage temporel si demandé (timestamps UTC)
   285:         if start:
   286:             df = df.loc[pd.Timestamp(start, tz="UTC") :]
   287:         if end:
   288:             df = df.loc[: pd.Timestamp(end, tz="UTC")]
   289:         return df
   290: 
   291:     return load

--------------------------------------------------------------------------------
FILE: engine/backtest/metrics.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import math
     3: from dataclasses import dataclass
     4: from typing import List, Dict
     5: 
     6: @dataclass
     7: class Trade:
     8:     ts: int
     9:     side: str
    10:     entry: float
    11:     exit: float
    12:     pnl_abs: float
    13:     pnl_pct: float
    14:     dur_min: float
    15: 
    16: def equity_to_drawdown(equity: List[float]) -> float:
    17:     peak = -1e18; maxdd = 0.0
    18:     for v in equity:
    19:         if v > peak: peak = v
    20:         dd = 0.0 if peak == 0 else (peak - v) / peak
    21:         if dd > maxdd: maxdd = dd
    22:     return maxdd
    23: 
    24: def sharpe(returns: List[float], rf: float = 0.0, period_per_year: int = 365*24*12) -> float:
    25:     # returns: per-bar (ex: par 5m) log or simple; ici simple
    26:     if not returns: return 0.0
    27:     mean = sum(returns)/len(returns)
    28:     var = sum((r-mean)**2 for r in returns)/max(1, len(returns)-1)
    29:     std = math.sqrt(var) if var>0 else 0.0
    30:     if std == 0: return 0.0
    31:     return (mean - rf) / std * math.sqrt(period_per_year)
    32: 
    33: def summarize(trades: List[Trade], equity: List[float], bar_returns: List[float], start_ts: int, end_ts: int) -> Dict:
    34:     wins = [t for t in trades if t.pnl_abs > 0]
    35:     losses = [t for t in trades if t.pnl_abs < 0]
    36:     wr = len(wins)/len(trades) if trades else 0.0
    37:     gross_win = sum(t.pnl_abs for t in wins)
    38:     gross_loss = abs(sum(t.pnl_abs for t in losses))
    39:     pf = (gross_win / gross_loss) if gross_loss > 0 else float('inf') if gross_win > 0 else 0.0
    40:     mdd = equity_to_drawdown(equity)
    41:     shp = sharpe(bar_returns)
    42:     expectancy = (gross_win - gross_loss) / max(1, len(trades))
    43:     n_years = max(1e-9, (end_ts - start_ts) / (365*24*3600*1000))
    44:     cagr = (equity[-1]/equity[0])**(1/n_years) - 1 if equity and equity[0] > 0 else 0.0
    45:     score = (wr*0.2) + (min(pf,3.0)/3.0*0.3) + (max(0.0,1.0-mdd)*0.3) + (max(0.0, min(shp/3,1.0))*0.2)
    46:     return {
    47:         "trades": len(trades),
    48:         "winrate": wr, "pf": pf, "maxdd": mdd, "sharpe": shp,
    49:         "expectancy": expectancy, "cagr": cagr, "score": score,
    50:         "equity_start": equity[0] if equity else None,
    51:         "equity_end": equity[-1] if equity else None,
    52:     }

--------------------------------------------------------------------------------
FILE: engine/backtest/optimize.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: """Parameter sweep utilities for strategy optimisation.
     4: 
     5: This module performs a grid search over a parameter space in parallel.  It
     6: tries to use :mod:`ray` for distributed execution when available and falls
     7: back to :mod:`multiprocessing` otherwise.
     8: """
     9: 
    10: import itertools
    11: import json
    12: import multiprocessing as mp
    13: import os
    14: from typing import Any, Dict, Iterable, List, Sequence
    15: 
    16: try:  # Optional dependency
    17:     import ray  # type: ignore
    18: except Exception:  # pragma: no cover - ray is optional
    19:     ray = None
    20: 
    21: from engine.backtest import backtest_trades
    22: 
    23: 
    24: # ---------------------------------------------------------------------------
    25: # Parameter space
    26: # ---------------------------------------------------------------------------
    27: 
    28: def param_space_default() -> Dict[str, Sequence[Any]]:
    29:     """Return the default parameter search space.
    30: 
    31:     The keys correspond to strategy parameters while the values are iterables
    32:     of possible settings.  The defaults represent a small but representative
    33:     grid and can be overridden by callers.
    34:     """
    35: 
    36:     return {
    37:         "ema_fast": [10, 20, 30],
    38:         "ema_slow": [50, 100, 200],
    39:         "rsi_period": [14, 21],
    40:         "atr_period": [14, 21],
    41:     }
    42: 
    43: 
    44: def _param_grid(space: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:
    45:     """Expand *space* into a list of parameter combinations."""
    46: 
    47:     keys = list(space)
    48:     values = [space[k] for k in keys]
    49:     return [dict(zip(keys, combo)) for combo in itertools.product(*values)]
    50: 
    51: 
    52: # ---------------------------------------------------------------------------
    53: # Evaluation
    54: # ---------------------------------------------------------------------------
    55: 
    56: def eval_params_one(grid_item: Dict[str, Any]) -> Dict[str, Any]:
    57:     """Run a backtest for a single parameter combination.
    58: 
    59:     ``grid_item`` contains the parameter values along with optional ``trades``
    60:     to evaluate.  The function returns a copy of the parameters augmented with
    61:     the computed PnL under the key ``pnl``.
    62:     """
    63: 
    64:     params = dict(grid_item)
    65:     trades = params.pop("trades", [])
    66:     fee_rate = params.pop("fee_rate", None)
    67:     pnl = backtest_trades(trades, fee_rate=fee_rate)
    68:     params["pnl"] = pnl
    69:     return params
    70: 
    71: 
    72: # ---------------------------------------------------------------------------
    73: # Orchestration
    74: # ---------------------------------------------------------------------------
    75: 
    76: def run_param_sweep(space: Dict[str, Iterable[Any]] | None = None, *, jobs: int | None = None) -> List[Dict[str, Any]]:
    77:     """Evaluate the full parameter grid in parallel and return results."""
    78: 
    79:     space = space or param_space_default()
    80:     grid = _param_grid(space)
    81: 
    82:     # Determine execution backend
    83:     use_ray = False
    84:     if ray is not None:
    85:         try:  # pragma: no cover - depends on ray
    86:             ray.init(ignore_reinit_error=True)
    87:             use_ray = True
    88:         except Exception:
    89:             use_ray = False
    90: 
    91:     if use_ray:
    92:         remote_eval = ray.remote(eval_params_one)  # type: ignore
    93:         futures = [remote_eval.remote(g) for g in grid]
    94:         results = ray.get(futures)
    95:     else:
    96:         jobs = jobs or int(os.getenv("OPT_JOBS", "0")) or mp.cpu_count()
    97:         with mp.Pool(processes=jobs) as pool:
    98:             results = pool.map(eval_params_one, grid)
    99: 
   100:     return results
   101: 
   102: 
   103: def optimize(space: Dict[str, Iterable[Any]] | None = None, *, outfile: str = "opt_results.json", jobs: int | None = None) -> List[Dict[str, Any]]:
   104:     """High level helper executing the sweep and saving aggregated results."""
   105: 
   106:     results = run_param_sweep(space, jobs=jobs)
   107:     with open(outfile, "w", encoding="utf8") as fh:
   108:         json.dump(results, fh, indent=2, sort_keys=True)
   109:     return results
   110: 
   111: 
   112: def main() -> None:  # pragma: no cover - convenience CLI
   113:     optimize()
   114: 
   115: 
   116: if __name__ == "__main__":  # pragma: no cover
   117:     main()

--------------------------------------------------------------------------------
FILE: engine/backtest/position_sizing.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/backtest/position_sizing.py
     2: from __future__ import annotations
     3: from engine.core.signal import Signal
     4: 
     5: def position_size_from_signal(equity: float, sig: Signal, risk_pct: float) -> float:
     6:     """
     7:     Taille = (equity * risk_pct) / |entry - sl|
     8:     Retourne la QUANTITÉ (unités de la crypto).
     9:     """
    10:     risk = max(1e-12, abs(sig.entry - sig.sl))
    11:     cash_at_risk = max(0.0, equity) * max(0.0, risk_pct)
    12:     return max(0.0, cash_at_risk / risk)
    13: 
    14: def fees_cost(notional: float, bps: float) -> float:
    15:     return abs(notional) * (bps / 10000.0)

--------------------------------------------------------------------------------
FILE: engine/backtest/run_multi.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # annulé

--------------------------------------------------------------------------------
FILE: engine/backtest/runner.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/backtest/runner.py
     2: from __future__ import annotations
     3: import argparse
     4: import os
     5: from typing import Dict, List
     6: from engine.strategy.factory import load_strategies_cfg
     7: from engine.backtest.engine import BacktestEngine
     8: 
     9: def run_once(
    10:     symbol: str,
    11:     timeframe: str,
    12:     csv_path: str,
    13:     strategies_cfg_path: str = "scalper/config/strategies.yml",
    14:     csv_1h_path: str = "",
    15:     equity: float = 1000.0,
    16:     risk: float = 0.01,
    17:     fees_bps: float = 6.0,
    18: ) -> Dict[str, float]:
    19:     cfg = load_strategies_cfg(strategies_cfg_path)
    20:     data = BacktestEngine.load_csv(csv_path)
    21:     data_1h = BacktestEngine.load_csv(csv_1h_path) if csv_1h_path and os.path.isfile(csv_1h_path) else None
    22: 
    23:     eng = BacktestEngine(
    24:         symbol=symbol, timeframe=timeframe, data=data, data_1h=data_1h,
    25:         equity_start=equity, risk_pct=risk, fees_bps=fees_bps, strategies_cfg=cfg,
    26:     )
    27:     eng.run()
    28:     eng.save_results()
    29:     return eng.summary()
    30: 
    31: def main():
    32:     ap = argparse.ArgumentParser(description="Runner Backtest (point d'entrée unique)")
    33:     ap.add_argument("--symbol", required=True, help="ex: BTCUSDT")
    34:     ap.add_argument("--tf", required=True, help="ex: 5m, 1h")
    35:     ap.add_argument("--csv", required=True, help="CSV OHLCV principal (timestamp,open,high,low,close,volume)")
    36:     ap.add_argument("--csv_1h", default="", help="CSV 1h (optionnel) pour filtre MTF")
    37:     ap.add_argument("--cfg", default="scalper/config/strategies.yml", help="config stratégies (YAML/JSON)")
    38:     ap.add_argument("--equity", type=float, default=1000.0)
    39:     ap.add_argument("--risk", type=float, default=0.01)
    40:     ap.add_argument("--fees_bps", type=float, default=6.0)
    41:     args = ap.parse_args()
    42: 
    43:     summary = run_once(
    44:         symbol=args.symbol, timeframe=args.tf, csv_path=args.csv,
    45:         strategies_cfg_path=args.cfg, csv_1h_path=args.csv_1h,
    46:         equity=args.equity, risk=args.risk, fees_bps=args.fees_bps,
    47:     )
    48:     print("== Résumé ==")
    49:     print(summary)
    50: 
    51: if __name__ == "__main__":
    52:     main()

--------------------------------------------------------------------------------
FILE: engine/backtest/walkforward.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from itertools import product
     4: from statistics import mean, stdev
     5: from typing import Dict, Iterable, Optional
     6: 
     7: from ..strategy import max_drawdown
     8: 
     9: 
    10: def _sharpe(returns: Iterable[float]) -> float:
    11:     vals = list(returns)
    12:     if not vals:
    13:         return 0.0
    14:     mu = mean(vals)
    15:     if len(vals) > 1:
    16:         sd = stdev(vals)
    17:     else:
    18:         sd = 0.0
    19:     return mu / sd if sd > 0 else 0.0
    20: 
    21: 
    22: def _stability(equity: Iterable[float]) -> float:
    23:     curve = list(equity)
    24:     n = len(curve)
    25:     if n < 2:
    26:         return 0.0
    27:     x = list(range(n))
    28:     x_mean = sum(x) / n
    29:     y_mean = sum(curve) / n
    30:     ss_tot = sum((y - y_mean) ** 2 for y in curve)
    31:     denom = sum((xi - x_mean) ** 2 for xi in x)
    32:     if denom == 0 or ss_tot == 0:
    33:         return 0.0
    34:     b = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, curve)) / denom
    35:     a = y_mean - b * x_mean
    36:     ss_res = sum((yi - (a + b * xi)) ** 2 for xi, yi in zip(x, curve))
    37:     return 1 - ss_res / ss_tot
    38: 
    39: 
    40: def walk_forward(
    41:     df,
    42:     splits: int = 5,
    43:     train_ratio: float = 0.7,
    44:     params: Optional[Dict[str, Iterable]] = None,
    45: ) -> Dict[str, float]:
    46:     """Perform walk-forward optimisation and evaluation.
    47: 
    48:     Parameters
    49:     ----------
    50:     df:
    51:         DataFrame containing per-period percentage returns. The first column is
    52:         used when a dedicated ``"returns"`` column is not found.
    53:     splits:
    54:         Number of walk-forward test windows.
    55:     train_ratio:
    56:         Proportion of the data used for training in the initial window.
    57:     params:
    58:         Optional parameter grid. If provided, columns in ``df`` matching each
    59:         parameter combination are evaluated and the best Sharpe ratio on the
    60:         training window is selected. When ``None``, the first column is used.
    61:     """
    62: 
    63:     if df.empty:
    64:         return {"sharpe": 0.0, "mdd": 0.0, "pnl": 0.0, "stability": 0.0}
    65: 
    66:     returns_col = "returns" if "returns" in df.columns else df.columns[0]
    67:     data = df.copy()
    68: 
    69:     n = len(data)
    70:     train_len = max(1, int(n * train_ratio))
    71:     test_len = max(1, (n - train_len) // splits) if splits else max(1, n - train_len)
    72: 
    73:     sharpe_list = []
    74:     mdd_list = []
    75:     pnl_list = []
    76:     stability_list = []
    77: 
    78:     from . import walk_forward_windows
    79: 
    80:     indices = list(range(n))
    81: 
    82:     for tr_idx, te_idx in walk_forward_windows(indices, train_len, test_len):
    83:         train_df = data.iloc[tr_idx]
    84:         test_df = data.iloc[te_idx]
    85: 
    86:         # Parameter optimisation based on Sharpe ratio
    87:         if params:
    88:             best_col = None
    89:             best_score = float("-inf")
    90:             keys, values = zip(*params.items()) if params else ([], [])
    91:             for combo in product(*values):
    92:                 col_name = "_".join(f"{k}={v}" for k, v in zip(keys, combo))
    93:                 if col_name not in data.columns:
    94:                     continue
    95:                 score = _sharpe(train_df[col_name])
    96:                 if score > best_score:
    97:                     best_score = score
    98:                     best_col = col_name
    99:             series = test_df[best_col] if best_col else test_df[returns_col]
   100:         else:
   101:             series = test_df[returns_col]
   102: 
   103:         sharpe_list.append(_sharpe(series))
   104:         equity = (1 + series / 100.0).cumprod()
   105:         mdd_list.append(max_drawdown(equity))
   106:         pnl_list.append((equity.iloc[-1] - 1) * 100 if len(equity) else 0.0)
   107:         stability_list.append(_stability(equity))
   108: 
   109:     count = len(sharpe_list) or 1
   110:     mean_sharpe = sum(sharpe_list) / count
   111:     mean_mdd = sum(mdd_list) / count
   112:     mean_pnl = sum(pnl_list) / count
   113:     mean_stability = sum(stability_list) / count
   114: 
   115:     return {
   116:         "sharpe": mean_sharpe,
   117:         "mdd": mean_mdd,
   118:         "pnl": mean_pnl,
   119:         "stability": mean_stability,
   120:     }

--------------------------------------------------------------------------------
FILE: engine/bitget_client.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import json
     2: import logging
     3: import time
     4: import hmac
     5: import hashlib
     6: import base64
     7: import uuid
     8: from typing import Any, Dict, List, Optional
     9: 
    10: import requests
    11: 
    12: 
    13: # Mapping of deprecated v1 product type identifiers to the new v2 names
    14: _PRODUCT_TYPE_ALIASES = {
    15:     "UMCBL": "USDT-FUTURES",
    16:     "DMCBL": "USDC-FUTURES",
    17:     "CMCBL": "COIN-FUTURES",
    18: }
    19: 
    20: # Granularity aliases from v1 to v2 nomenclature
    21: _GRANULARITY_ALIASES = {
    22:     "MIN1": "1m",
    23:     "MIN3": "3m",
    24:     "MIN5": "5m",
    25:     "MIN15": "15m",
    26:     "MIN30": "30m",
    27:     "HOUR1": "1H",
    28:     "HOUR4": "4H",
    29:     "HOUR12": "12H",
    30:     "DAY1": "1D",
    31:     "WEEK1": "1W",
    32: }
    33: 
    34: 
    35: # Default margin coin for each product type. Some authenticated endpoints
    36: # require ``marginCoin`` in addition to ``productType``; supplying a sensible
    37: # default avoids ``400 Bad Request`` responses when the caller does not provide
    38: # it explicitly.
    39: _DEFAULT_MARGIN_COIN = {
    40:     "USDT-FUTURES": "USDT",
    41:     "USDC-FUTURES": "USDC",
    42: }
    43: 
    44: 
    45: class BitgetFuturesClient:
    46:     """Lightweight REST client for Bitget LAPI v2 futures endpoints."""
    47: 
    48:     def __init__(
    49:         self,
    50:         access_key: str,
    51:         secret_key: str,
    52:         base_url: str,
    53:         *,
    54:         product_type: str = "USDT-FUTURES",
    55:         recv_window: int = 30,
    56:         paper_trade: bool = True,
    57:         requests_module: Any = requests,
    58:         log_event: Optional[Any] = None,
    59:         passphrase: Optional[str] = None,
    60:     ) -> None:
    61:         self.ak = access_key
    62:         self.sk = secret_key
    63:         self.base = base_url.rstrip("/")
    64:         pt = product_type.upper()
    65:         self.product_type = _PRODUCT_TYPE_ALIASES.get(pt, pt)
    66:         self.recv_window = recv_window
    67:         self.paper_trade = paper_trade
    68:         self.requests = requests_module
    69:         self.log_event = log_event or (lambda *a, **k: None)
    70:         self.passphrase = passphrase
    71:         if not self.ak or not self.sk or self.ak == "A_METTRE" or self.sk == "B_METTRE":
    72:             logging.warning(
    73:                 "\u26a0\ufe0f Cl\u00e9s API non d\u00e9finies. Le mode r\u00e9el ne fonctionnera pas.",
    74:             )
    75:         # Cache for contract precision details to avoid repeated network calls
    76:         self._contract_cache: Dict[str, Dict[str, Any]] = {}
    77: 
    78:     # ------------------------------------------------------------------
    79:     # Helpers
    80:     # ------------------------------------------------------------------
    81:     @staticmethod
    82:     def _ms() -> int:
    83:         return int(time.time() * 1000)
    84: 
    85:     @staticmethod
    86:     def _urlencode_sorted(params: Dict[str, Any]) -> str:
    87:         if not params:
    88:             return ""
    89:         items = []
    90:         for k in sorted(params.keys()):
    91:             v = "" if params[k] is None else str(params[k])
    92:             items.append(f"{k}={v}")
    93:         return "&".join(items)
    94: 
    95:     def _sign(self, prehash: str) -> str:
    96:         """Return a base64-encoded HMAC SHA256 signature."""
    97:         digest = hmac.new(self.sk.encode(), prehash.encode(), hashlib.sha256).digest()
    98:         return base64.b64encode(digest).decode()
    99: 
   100:     def _headers(self, signature: str, timestamp: int) -> Dict[str, str]:
   101:         headers = {
   102:             "ACCESS-KEY": self.ak,
   103:             "ACCESS-SIGN": signature,
   104:             "ACCESS-TIMESTAMP": str(timestamp),
   105:             "ACCESS-RECV-WINDOW": str(self.recv_window),
   106:             "Content-Type": "application/json",
   107:         }
   108:         if self.passphrase:
   109:             headers["ACCESS-PASSPHRASE"] = self.passphrase
   110:         return headers
   111: 
   112:     def _format_symbol(self, symbol: str) -> str:
   113:         """Return ``symbol`` formatted for Bitget API.
   114: 
   115:         The v2 endpoints expect the trading pair without any product type
   116:         suffix (``BTCUSDT``). Older configurations may provide symbols like
   117:         ``BTC_USDT`` or ``BTCUSDT_UMCBL``; these are normalised by removing the
   118:         separators and any trailing product type string (legacy or v2).
   119:         """
   120: 
   121:         if not symbol:
   122:             return symbol
   123: 
   124:         sym = symbol.replace("_", "").upper()
   125:         # Strip product type suffix if present (e.g. BTCUSDTUMCBL)
   126:         if sym.endswith(self.product_type):
   127:             sym = sym[: -len(self.product_type)]
   128:         else:
   129:             for old in _PRODUCT_TYPE_ALIASES.keys():
   130:                 if sym.endswith(old):
   131:                     sym = sym[: -len(old)]
   132:                     break
   133:         return sym
   134: 
   135:     def _product_type(self, pt: Optional[str] = None) -> str:
   136:         """Normalise ``pt`` to a valid v2 product type identifier."""
   137:         key = (pt or self.product_type or "").upper()
   138:         return _PRODUCT_TYPE_ALIASES.get(key, key)
   139: 
   140:     # ------------------------------------------------------------------
   141:     # Public endpoints
   142:     # ------------------------------------------------------------------
   143:     def get_contract_detail(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   144:         """Return futures contract information.
   145: 
   146:         The previous implementation queried ``/contract-detail`` which does not
   147:         exist on Bitget's v2 API and resulted in a 404 error.  The correct
   148:         endpoint is ``/contracts`` with the symbol supplied as a query
   149:         parameter."""
   150: 
   151:         url = f"{self.base}/api/v2/mix/market/contracts"
   152:         params: Dict[str, Any] = {"productType": self.product_type}
   153:         if symbol:
   154:             params["symbol"] = self._format_symbol(symbol)
   155:         r = self.requests.get(url, params=params, timeout=15)
   156:         if r.status_code == 404:  # pragma: no cover - depends on network
   157:             logging.error("Contract detail introuvable pour %s", symbol)
   158:             return {"success": False, "code": 404, "data": None}
   159:         r.raise_for_status()
   160:         return r.json()
   161: 
   162:     # ------------------------------------------------------------------
   163:     def _get_contract_precision(self, symbol: str) -> tuple[int, int]:
   164:         """Return price and volume precision for ``symbol``.
   165: 
   166:         Results are cached to minimise HTTP requests. If the contract
   167:         information cannot be retrieved, ``(0, 0)`` is returned.
   168:         """
   169:         sym = self._format_symbol(symbol)
   170:         info = self._contract_cache.get(sym)
   171:         if info is None:
   172:             detail = self.get_contract_detail(sym)
   173:             try:
   174:                 data = detail.get("data", [])
   175:                 if isinstance(data, list) and data:
   176:                     info = data[0]
   177:                 else:
   178:                     info = {}
   179:             except Exception:
   180:                 info = {}
   181:             self._contract_cache[sym] = info
   182:         price_place = int(info.get("pricePlace") or 0)
   183:         volume_place = int(info.get("volumePlace") or 0)
   184:         return price_place, volume_place
   185: 
   186:     def get_kline(
   187:         self,
   188:         symbol: str,
   189:         interval: str = "1m",
   190:         start: Optional[int] = None,
   191:         end: Optional[int] = None,
   192:     ) -> Dict[str, Any]:
   193:         # Endpoint expects the trading pair in query parameters rather than
   194:         # encoded in the path. Using ``/candles/{symbol}`` results in a 404
   195:         # response from Bitget. See: https://api.bitget.com/api/v2/mix/market/candles
   196:         url = f"{self.base}/api/v2/mix/market/candles"
   197:         interval_norm = _GRANULARITY_ALIASES.get(interval.replace("_", "").upper(), interval)
   198:         params: Dict[str, Any] = {
   199:             "symbol": self._format_symbol(symbol),
   200:             "productType": self.product_type,
   201:             "granularity": interval_norm,
   202:         }
   203:         if start is not None:
   204:             params["startTime"] = int(start)
   205:         if end is not None:
   206:             params["endTime"] = int(end)
   207:         r = self.requests.get(url, params=params, timeout=15)
   208:         r.raise_for_status()
   209:         data = r.json()
   210: 
   211:         rows = data.get("data") if isinstance(data, dict) else None
   212:         if isinstance(rows, list) and rows and isinstance(rows[0], list):
   213:             cols = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   214:             for row in rows:
   215:                 if len(row) < 7:
   216:                     continue
   217:                 try:
   218:                     ts, op, hi, lo, cl, vol, qv = row[:7]
   219:                     cols["ts"].append(int(ts))
   220:                     cols["open"].append(float(op))
   221:                     cols["high"].append(float(hi))
   222:                     cols["low"].append(float(lo))
   223:                     cols["close"].append(float(cl))
   224:                     cols["volume"].append(float(vol))
   225:                     cols["quoteVolume"].append(float(qv))
   226:                 except (TypeError, ValueError):
   227:                     continue
   228:             data["data"] = cols
   229:         elif isinstance(rows, list):
   230:             data["data"] = {"ts": [], "open": [], "high": [], "low": [], "close": [], "volume": [], "quoteVolume": []}
   231:         return data
   232: 
   233:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   234:         if symbol:
   235:             url = f"{self.base}/api/v2/mix/market/ticker"
   236:             params = {
   237:                 "symbol": self._format_symbol(symbol),
   238:                 "productType": self.product_type,
   239:             }
   240:         else:
   241:             url = f"{self.base}/api/v2/mix/market/tickers"
   242:             params = {"productType": self.product_type}
   243:         r = self.requests.get(url, params=params, timeout=15)
   244:         r.raise_for_status()
   245:         return r.json()
   246: 
   247:     # ------------------------------------------------------------------
   248:     # Private endpoints
   249:     # ------------------------------------------------------------------
   250:     def _private_request(
   251:         self,
   252:         method: str,
   253:         path: str,
   254:         *,
   255:         params: Optional[Dict[str, Any]] = None,
   256:         body: Optional[Dict[str, Any]] = None,
   257:     ) -> Dict[str, Any]:
   258:         method = method.upper()
   259:         ts = self._ms()
   260: 
   261:         if method in ("GET", "DELETE"):
   262:             qs = self._urlencode_sorted(params or {})
   263:             req_path = path + (f"?{qs}" if qs else "")
   264:             sig = self._sign(f"{ts}{method}{req_path}")
   265:             headers = self._headers(sig, ts)
   266:             url = f"{self.base}{req_path}"
   267:             r = self.requests.request(method, url, headers=headers, timeout=20)
   268:         elif method == "POST":
   269:             qs = self._urlencode_sorted(params or {})
   270:             req_path = path + (f"?{qs}" if qs else "")
   271:             body_str = json.dumps(body or {}, separators=(",", ":"), ensure_ascii=False)
   272:             sig = self._sign(f"{ts}{method}{req_path}{body_str}")
   273:             headers = self._headers(sig, ts)
   274:             url = f"{self.base}{req_path}"
   275:             r = self.requests.post(
   276:                 url,
   277:                 data=body_str.encode("utf-8"),
   278:                 headers=headers,
   279:                 timeout=20,
   280:             )
   281:         else:
   282:             raise ValueError("M\u00e9thode non support\u00e9e")
   283: 
   284:         resp_text = getattr(r, "text", "")
   285:         try:
   286:             data = r.json()
   287:         except Exception:
   288:             data = {
   289:                 "success": False,
   290:                 "error": resp_text,
   291:                 "status_code": getattr(r, "status_code", None),
   292:             }
   293: 
   294:         status = getattr(r, "status_code", 0)
   295:         if status >= 400:
   296:             code = str(data.get("code")) if isinstance(data, dict) else ""
   297:             if code == "22001":
   298:                 logging.info("Aucun ordre à annuler (%s %s)", method, path)
   299:             else:
   300:                 try:
   301:                     r.raise_for_status()
   302:                 except Exception as e:
   303:                     if not resp_text:
   304:                         resp_text = getattr(r, "text", "") or str(e)
   305:                 logging.error(
   306:                     "Erreur HTTP/JSON %s %s -> %s %s",
   307:                     method,
   308:                     path,
   309:                     status,
   310:                     resp_text,
   311:                 )
   312:                 if isinstance(data, dict):
   313:                     data.setdefault("success", False)
   314:                     data.setdefault("status_code", status)
   315:                     data.setdefault("error", resp_text)
   316: 
   317:         self.log_event(
   318:             "http_private",
   319:             {"method": method, "path": path, "params": params, "body": body, "response": data},
   320:         )
   321:         return data
   322: 
   323:     # Accounts & positions -------------------------------------------------
   324:     def get_assets(self, margin_coin: Optional[str] = None) -> Dict[str, Any]:
   325:         if self.paper_trade:
   326:             return {
   327:                 "success": True,
   328:                 "code": 0,
   329:                 "data": [
   330:                     {
   331:                         "currency": "USDT",
   332:                         "equity": 100.0,
   333:                     }
   334:                 ],
   335:             }
   336: 
   337:         params = {"productType": self.product_type}
   338:         if margin_coin is None:
   339:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   340:         if margin_coin:
   341:             params["marginCoin"] = margin_coin
   342:         data = self._private_request(
   343:             "GET", "/api/v2/mix/account/accounts", params=params
   344:         )
   345:         if isinstance(data, dict):
   346:             data.setdefault("success", str(data.get("code")) == "00000")
   347:         try:
   348:             for row in data.get("data", []):
   349:                 if "currency" not in row and row.get("marginCoin"):
   350:                     row["currency"] = str(row["marginCoin"]).upper()
   351:                 chosen = None
   352:                 for key in ("available", "cashBalance", "equity", "usdtEquity"):
   353:                     val = row.get(key)
   354:                     if val is not None:
   355:                         chosen = val
   356:                         break
   357:                 if chosen is not None:
   358:                     row["equity"] = chosen
   359:                 try:
   360:                     row["equity"] = float(row["equity"])
   361:                 except Exception:
   362:                     pass
   363:         except Exception:  # pragma: no cover - best effort
   364:             pass
   365:         return data
   366: 
   367:     def get_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   368:         if self.paper_trade:
   369:             return {"success": True, "code": 0, "data": []}
   370:         data = self._private_request(
   371:             "GET",
   372:             "/api/v2/mix/position/all-position",
   373:             params={"productType": self._product_type(product_type)},
   374:         )
   375:         try:
   376:             positions = data.get("data", [])
   377:             filtered = []
   378:             for pos in positions:
   379:                 vol = pos.get("vol")
   380:                 try:
   381:                     if vol is not None and float(vol) > 0:
   382:                         filtered.append(pos)
   383:                 except (TypeError, ValueError):
   384:                     continue
   385:             data["data"] = filtered
   386:         except Exception:  # pragma: no cover - best effort
   387:             pass
   388:         return data
   389: 
   390:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   391:         if self.paper_trade:
   392:             return {"success": True, "code": 0, "data": []}
   393:         params: Dict[str, Any] = {"productType": self.product_type}
   394:         if symbol:
   395:             params["symbol"] = self._format_symbol(symbol)
   396:         return self._private_request("GET", "/api/v2/mix/order/orders-pending", params=params)
   397: 
   398:     # Account configuration -------------------------------------------------
   399:     def set_position_mode_one_way(self, symbol: str, product_type: Optional[str] = None) -> Dict[str, Any]:
   400:         body = {
   401:             "productType": self._product_type(product_type),
   402:             "symbol": self._format_symbol(symbol),
   403:             "posMode": "one_way_mode",
   404:         }
   405:         return self._private_request("POST", "/api/v2/mix/account/set-position-mode", body=body)
   406: 
   407:     def set_leverage(
   408:         self,
   409:         symbol: str,
   410:         product_type: Optional[str] = None,
   411:         margin_coin: str = "USDT",
   412:         leverage: int = 1,
   413:     ) -> Dict[str, Any]:
   414:         body = {
   415:             "symbol": self._format_symbol(symbol),
   416:             "productType": self._product_type(product_type),
   417:             "marginCoin": margin_coin,
   418:             "leverage": int(leverage),
   419:         }
   420:         return self._private_request(
   421:             "POST", "/api/v2/mix/account/set-leverage", body=body
   422:         )
   423: 
   424:     def place_market_order_one_way(
   425:         self,
   426:         symbol: str,
   427:         side: str,
   428:         size: float,
   429:         product_type: Optional[str] = None,
   430:         margin_coin: str = "USDT",
   431:         *,
   432:         time_in_force: str = "normal",
   433:     ) -> Dict[str, Any]:
   434:         side = side.lower()
   435:         if side not in {"buy", "sell"}:
   436:             raise ValueError("side must be 'buy' or 'sell'")
   437:         body = {
   438:             "symbol": self._format_symbol(symbol),
   439:             "productType": self._product_type(product_type),
   440:             "marginCoin": margin_coin,
   441:             "marginMode": "crossed",
   442:             "posMode": "one_way_mode",
   443:             "orderType": "market",
   444:             "side": side,
   445:             "size": str(size),
   446:             "timeInForceValue": time_in_force,
   447:             "clientOid": str(uuid.uuid4())[:32],
   448:         }
   449:         return self._private_request(
   450:             "POST", "/api/v2/mix/order/place-order", body=body
   451:         )
   452: 
   453:     # Orders ---------------------------------------------------------------
   454:     def place_order(
   455:         self,
   456:         symbol: str,
   457:         side: int,
   458:         vol: int,
   459:         order_type: int,
   460:         *,
   461:         price: Optional[float] = None,
   462:         open_type: int = 1,
   463:         leverage: Optional[int] = None,
   464:         position_id: Optional[int] = None,
   465:         external_oid: Optional[str] = None,
   466:         stop_loss: Optional[float] = None,
   467:         take_profit: Optional[float] = None,
   468:         position_mode: Optional[int] = None,
   469:         margin_coin: Optional[str] = None,
   470:         time_in_force: str = "normal",
   471:     ) -> Dict[str, Any]:
   472:         """Submit an order.
   473: 
   474:         This helper keeps backward compatibility with the older numeric
   475:         parameters used by the bot while translating them to the string based
   476:         fields required by Bitget's v2 API.
   477:         """
   478:         if self.paper_trade:
   479:             logging.info(
   480:                 "PAPER_TRADE=True -> ordre simul\u00e9: side=%s vol=%s type=%s price=%s",
   481:                 side,
   482:                 vol,
   483:                 order_type,
   484:                 price,
   485:             )
   486:             return {
   487:                 "success": True,
   488:                 "paperTrade": True,
   489:                 "simulated": {
   490:                     "symbol": symbol,
   491:                     "side": side,
   492:                     "vol": vol,
   493:                     "type": order_type,
   494:                     "price": price,
   495:                     "openType": open_type,
   496:                     "leverage": leverage,
   497:                     "stopLossPrice": stop_loss,
   498:                     "takeProfitPrice": take_profit,
   499:                 },
   500:             }
   501: 
   502:         # ------------------------------------------------------------------
   503:         # Parameter mapping
   504:         # ------------------------------------------------------------------
   505:         side_map = {
   506:             1: ("buy", "long"),
   507:             2: ("buy", "short"),
   508:             3: ("sell", "short"),
   509:             4: ("sell", "long"),
   510:         }
   511:         if isinstance(side, int):
   512:             mapped = side_map.get(side)
   513:             if not mapped:
   514:                 raise ValueError(f"Invalid side value: {side}")
   515:             side_str, pos_side = mapped
   516:         else:
   517:             side_str = str(side)
   518:             pos_side = None
   519: 
   520:         order_map = {1: "market", 2: "limit", 3: "post_only", 4: "fok", 5: "limit"}
   521:         if isinstance(order_type, int):
   522:             order_str = order_map.get(order_type)
   523:             if order_str is None:
   524:                 order_str = "limit" if price is not None else "market"
   525:         else:
   526:             order_str = str(order_type)
   527: 
   528:         margin_mode = "crossed" if int(open_type) == 1 else "isolated"
   529: 
   530:         if margin_coin is None:
   531:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   532: 
   533:         # ------------------------------------------------------------------
   534:         # Precision handling
   535:         # ------------------------------------------------------------------
   536:         try:
   537:             price_place, volume_place = self._get_contract_precision(symbol)
   538:         except Exception:  # pragma: no cover - best effort
   539:             price_place = volume_place = 0
   540:         if price is not None:
   541:             price = round(float(price), price_place)
   542:         if vol is not None:
   543:             vol = round(float(vol), volume_place)
   544: 
   545:         body = {
   546:             "symbol": self._format_symbol(symbol),
   547:             "productType": self.product_type,
   548:             "marginMode": margin_mode,
   549:             "orderType": order_str,
   550:             "side": side_str,
   551:             "size": vol,
   552:             "timeInForceValue": time_in_force,
   553:         }
   554:         if pos_side is not None:
   555:             body["posSide"] = pos_side
   556:         if margin_coin:
   557:             body["marginCoin"] = margin_coin
   558:         if price is not None:
   559:             body["price"] = float(price)
   560:         if leverage is not None:
   561:             body["leverage"] = int(leverage)
   562:         if position_id is not None:
   563:             body["positionId"] = int(position_id)
   564:         if external_oid:
   565:             body["clientOid"] = str(external_oid)[:32]
   566:         else:
   567:             body["clientOid"] = str(uuid.uuid4())[:32]
   568:         if stop_loss is not None:
   569:             body["stopLossPrice"] = float(stop_loss)
   570:         if take_profit is not None:
   571:             body["takeProfitPrice"] = float(take_profit)
   572:         if position_mode is not None:
   573:             body["posMode"] = "one_way_mode" if int(position_mode) == 1 else "hedge_mode"
   574:         elif pos_side is not None:
   575:             body["posMode"] = "hedge_mode"
   576: 
   577:         return self._private_request("POST", "/api/v2/mix/order/place-order", body=body)
   578: 
   579:     def cancel_order(self, order_ids: List[int]) -> Dict[str, Any]:
   580:         if self.paper_trade:
   581:             logging.info(
   582:                 "PAPER_TRADE=True -> annulation simulée: order_ids=%s", order_ids
   583:             )
   584:             return {"success": True, "code": 0}
   585:         return self._private_request(
   586:             "POST", "/api/v2/mix/order/cancel-order", body={"orderIds": order_ids}
   587:         )
   588: 
   589:     def cancel_all(
   590:         self,
   591:         symbol: Optional[str] = None,
   592:         margin_coin: Optional[str] = None,
   593:     ) -> Dict[str, Any]:
   594:         if self.paper_trade:
   595:             logging.info(
   596:                 "PAPER_TRADE=True -> annulation simulée de tous les ordres"
   597:             )
   598:             return {"success": True, "code": 0}
   599:         body = {"productType": self.product_type}
   600:         if symbol:
   601:             body["symbol"] = self._format_symbol(symbol)
   602:         if margin_coin is None:
   603:             margin_coin = _DEFAULT_MARGIN_COIN.get(self.product_type)
   604:         if margin_coin:
   605:             body["marginCoin"] = margin_coin
   606:         return self._private_request(
   607:             "POST", "/api/v2/mix/order/cancel-all-orders", body=body
   608:         )
   609: 
   610:     def close_position(
   611:         self,
   612:         symbol: str,
   613:         size: Optional[int] = None,
   614:         hold_side: Optional[str] = None,
   615:     ) -> Dict[str, Any]:
   616:         """Close an open position for ``symbol``.
   617: 
   618:         Parameters
   619:         ----------
   620:         symbol:
   621:             Trading symbol to close.
   622:         size:
   623:             Optional number of contracts to close. If omitted the entire
   624:             position is closed.
   625:         hold_side:
   626:             Optional side (``"long"``/``"short"``) to close when ``size`` is
   627:             specified. If not provided the exchange will infer it.
   628:         """
   629: 
   630:         if self.paper_trade:
   631:             logging.info(
   632:                 "PAPER_TRADE=True -> fermeture simulée de la position %s", symbol
   633:             )
   634:             return {"success": True, "code": 0}
   635: 
   636:         body = {"symbol": self._format_symbol(symbol)}
   637:         if size is not None:
   638:             body["size"] = int(size)
   639:         if hold_side:
   640:             body["holdSide"] = hold_side
   641: 
   642:         body["productType"] = self.product_type
   643:         return self._private_request(
   644:             "POST", "/api/v2/mix/position/close-position", body=body
   645:         )
   646: 
   647:     def close_all_positions(self, product_type: Optional[str] = None) -> Dict[str, Any]:
   648:         """Close all open positions."""
   649:         results = []
   650:         try:
   651:             for pos in self.get_positions(product_type).get("data", []):
   652:                 sym = pos.get("symbol")
   653:                 if sym:
   654:                     results.append(self.close_position(sym))
   655:         except Exception as exc:  # pragma: no cover - best effort
   656:             logging.error("Erreur fermeture de toutes les positions: %s", exc)
   657:         return {"success": True, "data": results}

--------------------------------------------------------------------------------
FILE: engine/client.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import logging
     2: from typing import Any, Dict, Optional
     3: 
     4: import requests
     5: from requests.adapters import HTTPAdapter
     6: from urllib3.util.retry import Retry
     7: 
     8: 
     9: class HTTPError(RuntimeError):
    10:     """Raised when an HTTP request fails"""
    11: 
    12: 
    13: class HttpClient:
    14:     """Simple HTTP client with persistent session and retry logic.
    15: 
    16:     The client exposes a :py:meth:`close` method and implements the context
    17:     manager protocol so it can be used with ``with`` statements to ensure
    18:     that the underlying :class:`requests.Session` is properly closed.
    19:     """
    20: 
    21:     def __init__(
    22:         self,
    23:         base_url: str,
    24:         *,
    25:         timeout: float = 10.0,
    26:         max_retries: int = 3,
    27:         backoff_factor: float = 0.3,
    28:         status_forcelist: Optional[list[int]] = None,
    29:     ) -> None:
    30:         self.base_url = base_url.rstrip("/")
    31:         self.timeout = timeout
    32:         self.session = requests.Session()
    33:         retry = Retry(
    34:             total=max_retries,
    35:             backoff_factor=backoff_factor,
    36:             status_forcelist=status_forcelist or [429, 500, 502, 503, 504],
    37:             allowed_methods=[
    38:                 "HEAD",
    39:                 "GET",
    40:                 "OPTIONS",
    41:                 "POST",
    42:                 "PUT",
    43:                 "DELETE",
    44:                 "PATCH",
    45:             ],
    46:         )
    47:         adapter = HTTPAdapter(max_retries=retry)
    48:         self.session.mount("http://", adapter)
    49:         self.session.mount("https://", adapter)
    50: 
    51:     def close(self) -> None:
    52:         """Close the underlying :class:`requests.Session`."""
    53:         self.session.close()
    54: 
    55:     # ------------------------------------------------------------------
    56:     # Context manager support
    57:     # ------------------------------------------------------------------
    58:     def __enter__(self) -> "HttpClient":
    59:         return self
    60: 
    61:     def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[override]
    62:         self.close()
    63: 
    64:     def request(
    65:         self,
    66:         method: str,
    67:         path: str,
    68:         *,
    69:         params: Optional[Dict[str, Any]] = None,
    70:         json: Optional[Dict[str, Any]] = None,
    71:         headers: Optional[Dict[str, str]] = None,
    72:     ) -> Dict[str, Any]:
    73:         """Perform an HTTP request and return JSON data.
    74: 
    75:         Errors during the request raise ``HTTPError``. If the response cannot
    76:         be decoded as JSON, a dictionary describing the issue is returned.
    77:         """
    78:         url = f"{self.base_url}{path}"
    79:         try:
    80:             resp = self.session.request(
    81:                 method,
    82:                 url,
    83:                 params=params,
    84:                 json=json,
    85:                 headers=headers,
    86:                 timeout=self.timeout,
    87:             )
    88:             resp.raise_for_status()
    89:         except requests.RequestException as exc:  # network or HTTP errors
    90:             msg = f"HTTP error calling {url}: {exc}"
    91:             logging.error(msg)
    92:             raise HTTPError(msg) from exc
    93: 
    94:         try:
    95:             return resp.json()
    96:         except ValueError:  # invalid JSON
    97:             msg = "Invalid JSON in response"
    98:             logging.error("%s for %s: %s", msg, url, resp.text)
    99:             return {"success": False, "error": msg, "text": resp.text}

--------------------------------------------------------------------------------
FILE: engine/config/loader.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import os
     3: from pathlib import Path
     4: from typing import Any, Dict, Tuple
     5: 
     6: try:
     7:     import yaml
     8: except Exception:
     9:     yaml = None
    10: 
    11: # Aliases ENV -> clés canoniques (SECRETS UNIQUEMENT)
    12: _ALIASES: Dict[str, Tuple[str, ...]] = {
    13:     "BITGET_ACCESS_KEY": ("BITGET_API_KEY", "BITGET_KEY"),
    14:     "BITGET_SECRET_KEY": ("BITGET_API_SECRET", "BITGET_SECRET"),
    15:     "BITGET_PASSPHRASE": ("BITGET_API_PASSPHRASE", "BITGET_PASSWORD", "BITGET_API_PASSWORD"),
    16:     "TELEGRAM_BOT_TOKEN": ("TELEGRAM_TOKEN", "TG_TOKEN"),
    17:     "TELEGRAM_CHAT_ID": ("TG_CHAT_ID", "TELEGRAM_TO", "CHAT_ID"),
    18: }
    19: 
    20: def _adopt_alias(target: str) -> None:
    21:     if os.getenv(target):
    22:         return
    23:     for alt in _ALIASES.get(target, ()):
    24:         v = os.getenv(alt)
    25:         if v:
    26:             os.environ[target] = v
    27:             return
    28: 
    29: def apply_env_aliases() -> None:
    30:     for k in _ALIASES:
    31:         _adopt_alias(k)
    32: 
    33: def _default_paths() -> Dict[str, str]:
    34:     data_root = os.getenv("DATA_ROOT", "/notebooks/scalp_data")  # HORS REPO
    35:     root = Path(data_root)
    36:     return {
    37:         "data_dir": str(root / "data"),
    38:         "log_dir": str(root / "logs"),
    39:         "reports_dir": str(root / "reports"),
    40:     }
    41: 
    42: def load_yaml_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    43:     if path is None:
    44:         path = Path(__file__).resolve().parent / "config.yaml"
    45:     path = Path(path)
    46:     if yaml is None or not path.exists():
    47:         return {}
    48:     with path.open("r", encoding="utf-8") as fh:
    49:         return yaml.safe_load(fh) or {}
    50: 
    51: def load_config(path: str | os.PathLike | None = None) -> Dict[str, Any]:
    52:     cfg = load_yaml_config(path)
    53:     apply_env_aliases()
    54: 
    55:     # Secrets depuis .env parent (sitecustomize.py les charge)
    56:     cfg.setdefault("secrets", {})
    57:     cfg["secrets"]["bitget"] = {
    58:         "access": os.getenv("BITGET_ACCESS_KEY") or "",
    59:         "secret": os.getenv("BITGET_SECRET_KEY") or "",
    60:         "passphrase": os.getenv("BITGET_PASSPHRASE") or "",
    61:     }
    62:     cfg["secrets"]["telegram"] = {
    63:         "token": os.getenv("TELEGRAM_BOT_TOKEN") or "",
    64:         "chat_id": os.getenv("TELEGRAM_CHAT_ID") or "",
    65:     }
    66: 
    67:     # Chemins hors repo
    68:     defaults = _default_paths()
    69:     r = cfg.setdefault("runtime", {})
    70:     r.setdefault("data_dir", defaults["data_dir"])
    71:     r.setdefault("log_dir", defaults["log_dir"])
    72:     r.setdefault("reports_dir", defaults["reports_dir"])
    73:     r.setdefault("paper_trade", True)
    74:     r.setdefault("allowed_symbols", [])
    75:     r.setdefault("refresh_secs", 5)
    76: 
    77:     s = cfg.setdefault("strategy", {})
    78:     s.setdefault("live_timeframe", "1m")
    79: 
    80:     return cfg

--------------------------------------------------------------------------------
FILE: engine/core/indicators.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/core/indicators.py
     2: from __future__ import annotations
     3: from typing import Sequence, Tuple, List
     4: 
     5: def _to_list(x: Sequence[float]) -> List[float]:
     6:     return list(map(float, x))
     7: 
     8: def ema(series: Sequence[float], period: int) -> List[float]:
     9:     s = _to_list(series)
    10:     if period <= 1 or len(s) == 0:
    11:         return s[:]
    12:     k = 2.0 / (period + 1.0)
    13:     out = [s[0]]
    14:     for i in range(1, len(s)):
    15:         out.append(s[i] * k + out[-1] * (1.0 - k))
    16:     return out
    17: 
    18: def sma(series: Sequence[float], period: int) -> List[float]:
    19:     s = _to_list(series)
    20:     out: List[float] = []
    21:     acc = 0.0
    22:     for i, v in enumerate(s):
    23:         acc += v
    24:         if i >= period:
    25:             acc -= s[i - period]
    26:         out.append(acc / min(i + 1, period))
    27:     return out
    28: 
    29: def rsi(closes: Sequence[float], period: int = 14) -> List[float]:
    30:     c = _to_list(closes)
    31:     if len(c) < 2:
    32:         return [50.0] * len(c)
    33:     gains = [0.0]
    34:     losses = [0.0]
    35:     for i in range(1, len(c)):
    36:         ch = c[i] - c[i - 1]
    37:         gains.append(max(ch, 0.0))
    38:         losses.append(max(-ch, 0.0))
    39:     avg_gain = sma(gains, period)
    40:     avg_loss = sma(losses, period)
    41:     out = []
    42:     for g, l in zip(avg_gain, avg_loss):
    43:         if l == 0:
    44:             out.append(100.0)
    45:         else:
    46:             rs = g / l
    47:             out.append(100.0 - (100.0 / (1.0 + rs)))
    48:     return out
    49: 
    50: def macd(closes: Sequence[float], fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[List[float], List[float], List[float]]:
    51:     c = _to_list(closes)
    52:     ema_fast = ema(c, fast)
    53:     ema_slow = ema(c, slow)
    54:     macd_line = [f - s for f, s in zip(ema_fast, ema_slow)]
    55:     signal_line = ema(macd_line, signal)
    56:     hist = [m - s for m, s in zip(macd_line, signal_line)]
    57:     return macd_line, signal_line, hist
    58: 
    59: def atr(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], period: int = 14) -> List[float]:
    60:     h, l, c = _to_list(highs), _to_list(lows), _to_list(closes)
    61:     if not h:
    62:         return []
    63:     trs = [h[0] - l[0]]
    64:     for i in range(1, len(h)):
    65:         tr = max(h[i] - l[i], abs(h[i] - c[i - 1]), abs(l[i] - c[i - 1]))
    66:         trs.append(tr)
    67:     return ema(trs, period)
    68: 
    69: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    70:     c, v = _to_list(closes), _to_list(volumes)
    71:     out = [0.0]
    72:     for i in range(1, len(c)):
    73:         if c[i] > c[i - 1]:
    74:             out.append(out[-1] + v[i])
    75:         elif c[i] < c[i - 1]:
    76:             out.append(out[-1] - v[i])
    77:         else:
    78:             out.append(out[-1])
    79:     return out
    80: 
    81: def vwap(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    82:     h, l, c, v = _to_list(highs), _to_list(lows), _to_list(closes), _to_list(volumes)
    83:     out: List[float] = []
    84:     cum_tp_vol = 0.0
    85:     cum_vol = 0.0
    86:     for hi, lo, cl, vol in zip(h, l, c, v):
    87:         tp = (hi + lo + cl) / 3.0
    88:         cum_tp_vol += tp * vol
    89:         cum_vol += max(vol, 1e-12)
    90:         out.append(cum_tp_vol / cum_vol)
    91:     return out
    92: 
    93: def slope(series: Sequence[float], lookback: int = 5) -> List[float]:
    94:     s = _to_list(series)
    95:     out: List[float] = []
    96:     for i in range(len(s)):
    97:         if i < lookback:
    98:             out.append(0.0)
    99:         else:
   100:             denom = abs(s[i - lookback]) if abs(s[i - lookback]) > 1e-12 else 1e-12
   101:             out.append((s[i] - s[i - lookback]) / denom)
   102:     return out

--------------------------------------------------------------------------------
FILE: engine/core/signal.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/core/signal.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass, field
     4: from typing import List, Optional, Literal, Dict, Any
     5: 
     6: Side = Literal["long", "short"]
     7: 
     8: @dataclass
     9: class Signal:
    10:     symbol: str
    11:     timeframe: str
    12:     side: Side
    13:     entry: float
    14:     sl: float
    15:     tp1: Optional[float] = None
    16:     tp2: Optional[float] = None
    17:     qty: Optional[float] = None
    18:     score: float = 0.0          # 0..1 (ou entier, normalisé au besoin)
    19:     quality: float = 0.0        # 0..1
    20:     reasons: List[str] = field(default_factory=list)
    21:     timestamp: Optional[int] = None  # ms epoch de la bougie de déclenchement
    22:     extra: Dict[str, Any] = field(default_factory=dict)
    23: 
    24:     def risk_per_unit(self) -> float:
    25:         return abs(self.entry - self.sl)
    26: 
    27:     def as_dict(self) -> Dict[str, Any]:
    28:         d = {
    29:             "symbol": self.symbol, "timeframe": self.timeframe, "side": self.side,
    30:             "entry": self.entry, "sl": self.sl, "tp1": self.tp1, "tp2": self.tp2,
    31:             "qty": self.qty, "score": self.score, "quality": self.quality,
    32:             "timestamp": self.timestamp, "reasons": "|".join(self.reasons),
    33:         }
    34:         d.update(self.extra or {})
    35:         return d

--------------------------------------------------------------------------------
FILE: engine/exchange/bitget_rest.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # engine/exchange/bitget_rest.py
     2: from __future__ import annotations
     3: 
     4: import base64
     5: import hashlib
     6: import hmac
     7: import json
     8: import logging
     9: import time
    10: from dataclasses import dataclass
    11: from typing import Any, Dict, Mapping, Optional
    12: 
    13: import requests
    14: 
    15: __all__ = ["BitgetFuturesClient", "ApiError"]
    16: 
    17: log = logging.getLogger("engine.exchange.bitget_rest")
    18: 
    19: 
    20: # =============================================================================
    21: # Exceptions
    22: # =============================================================================
    23: class ApiError(RuntimeError):
    24:     """Erreur API Bitget (HTTP != 200, code != '00000', ou payload invalide)."""
    25: 
    26:     def __init__(self, message: str, *, http_status: int | None = None, body: Any | None = None):
    27:         super().__init__(message)
    28:         self.http_status = http_status
    29:         self.body = body
    30: 
    31: 
    32: # =============================================================================
    33: # Helpers
    34: # =============================================================================
    35: def _now_ms() -> int:
    36:     return int(time.time() * 1000)
    37: 
    38: 
    39: def _canonical_json(obj: Mapping[str, Any] | None) -> str:
    40:     if not obj:
    41:         return ""
    42:     # JSON compact, trié, ascii pour signature stable
    43:     return json.dumps(obj, separators=(",", ":"), sort_keys=True, ensure_ascii=True)
    44: 
    45: 
    46: # =============================================================================
    47: # Client REST Futures (USDT-M)
    48: # =============================================================================
    49: @dataclass
    50: class _Auth:
    51:     access_key: str
    52:     secret_key: str
    53:     passphrase: str
    54:     recv_window: int = 30_000  # ms
    55: 
    56: 
    57: class BitgetFuturesClient:
    58:     """
    59:     Client REST léger pour les Futures USDT-M de Bitget.
    60: 
    61:     Points clés:
    62:     - Public: get_ticker(symbol?), get_klines(symbol, interval, limit, start/end?)
    63:     - Privé : get_account(), get_open_orders(symbol?), cancel_order(), cancel_all()
    64:               place_market_order_one_way(), place_limit_order_one_way()
    65:               set_position_mode_one_way(), set_leverage()
    66:     - Safe: gestion d’erreurs centralisée, timeouts, session réutilisable.
    67: 
    68:     Notes:
    69:     - Les endpoints et champs renvoyés sont harmonisés pour rester stables
    70:       côté moteur/orchestrateur. On tolère plusieurs variantes de clés (lastPr/lastPrice).
    71:     """
    72: 
    73:     def __init__(
    74:         self,
    75:         *,
    76:         access_key: str = "",
    77:         secret_key: str = "",
    78:         passphrase: str = "",
    79:         base_url: str = "https://api.bitget.com",
    80:         paper_trade: bool = True,
    81:         timeout: float = 10.0,
    82:         session: Optional[requests.Session] = None,
    83:     ) -> None:
    84:         self.base_url = base_url.rstrip("/")
    85:         self.auth = _Auth(access_key, secret_key, passphrase)
    86:         self.paper = paper_trade
    87:         self.timeout = float(timeout)
    88:         self.sess = session or requests.Session()
    89:         self.sess.headers.update({"Accept": "application/json"})
    90:         log.info("BitgetFuturesClient ready (paper=%s base=%s)", self.paper, self.base_url)
    91: 
    92:     # -------------------------------------------------------------------------
    93:     # Core HTTP
    94:     # -------------------------------------------------------------------------
    95:     def _sign(self, ts_ms: int, method: str, path: str, query: str, body: str) -> str:
    96:         """
    97:         Signature :
    98:           sign = base64( HMAC_SHA256(secret, f"{ts}{method}{path}{query}{body}") )
    99:         - method en MAJUSCULES
   100:         - query inclut '?' si présent, sinon ""
   101:         - body = chaîne JSON canonique (ou vide)
   102:         """
   103:         msg = f"{ts_ms}{method.upper()}{path}{query}{body}"
   104:         return base64.b64encode(hmac.new(self.auth.secret_key.encode(), msg.encode(), hashlib.sha256).digest()).decode()
   105: 
   106:     def _request(
   107:         self,
   108:         method: str,
   109:         path: str,
   110:         *,
   111:         params: Optional[Mapping[str, Any]] = None,
   112:         body: Optional[Mapping[str, Any]] = None,
   113:         signed: bool = False,
   114:     ) -> Dict[str, Any]:
   115:         url = f"{self.base_url}{path}"
   116:         params = dict(params or {})
   117:         body_json = _canonical_json(body)
   118:         query = ""
   119: 
   120:         headers = {"Content-Type": "application/json"}
   121:         if not signed:
   122:             # Public
   123:             resp = self.sess.request(
   124:                 method=method.upper(),
   125:                 url=url,
   126:                 params=params or None,
   127:                 timeout=self.timeout,
   128:                 headers=headers,
   129:             )
   130:         else:
   131:             # Privé: timestamp + recvWindow
   132:             ts = _now_ms()
   133:             if "recvWindow" not in params:
   134:                 params["recvWindow"] = self.auth.recv_window
   135:             # Construire la query string stable (requests la reformate si on passe 'params')
   136:             if params:
   137:                 q_items = "&".join(f"{k}={params[k]}" for k in sorted(params))
   138:                 query = f"?{q_items}"
   139:             signature = self._sign(ts, method, path, query, body_json)
   140: 
   141:             headers.update(
   142:                 {
   143:                     "ACCESS-KEY": self.auth.access_key,
   144:                     "ACCESS-SIGN": signature,
   145:                     "ACCESS-TIMESTAMP": str(ts),
   146:                     "ACCESS-PASSPHRASE": self.auth.passphrase,
   147:                 }
   148:             )
   149: 
   150:             resp = self.sess.request(
   151:                 method=method.upper(),
   152:                 url=url,
   153:                 params=params or None,
   154:                 data=body_json if body_json else None,
   155:                 timeout=self.timeout,
   156:                 headers=headers,
   157:             )
   158: 
   159:         # Gestion d’erreurs HTTP
   160:         if resp.status_code != 200:
   161:             raise ApiError(f"HTTP {resp.status_code} for {path}", http_status=resp.status_code, body=resp.text)
   162: 
   163:         # Décodage JSON
   164:         try:
   165:             data = resp.json()
   166:         except Exception as exc:
   167:             raise ApiError(f"Non-JSON response for {path}: {resp.text[:200]}") from exc
   168: 
   169:         # Protocole Bitget: code == '00000' attendu
   170:         code = str(data.get("code", ""))
   171:         if code and code != "00000":
   172:             raise ApiError(f"Bitget API error code={code} for {path}", body=data)
   173: 
   174:         return data
   175: 
   176:     # -------------------------------------------------------------------------
   177:     # PUBLIC
   178:     # -------------------------------------------------------------------------
   179:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   180:         """
   181:         Ticker futures. Si `symbol` est fourni, retourne uniquement cette entrée.
   182:         """
   183:         params = {"productType": "USDT-FUTURES"}
   184:         data = self._request("GET", "/api/v2/mix/market/tickers", params=params, signed=False)
   185:         if not symbol:
   186:             return data
   187: 
   188:         # Harmoniser: extraire l’entrée du symbole demandé
   189:         items = data.get("data") or []
   190:         sym = symbol.replace("_", "").upper()
   191:         hit: Dict[str, Any] | None = None
   192:         for it in items:
   193:             if (it.get("symbol") or "").replace("_", "").upper() == sym:
   194:                 hit = it
   195:                 break
   196:         return {"data": hit or {}}
   197: 
   198:     def get_klines(
   199:         self,
   200:         symbol: str,
   201:         interval: str = "1m",
   202:         limit: int = 100,
   203:         start: Optional[int] = None,
   204:         end: Optional[int] = None,
   205:     ) -> Dict[str, Any]:
   206:         """
   207:         OHLCV Futures.
   208:         interval: '1m', '5m', '15m', '1h', ...
   209:         start/end: timestamps ms optionnels.
   210:         """
   211:         params: Dict[str, Any] = {
   212:             "symbol": symbol.replace("_", "").upper(),
   213:             "granularity": interval,
   214:             "productType": "USDT-FUTURES",
   215:             "limit": max(1, min(int(limit), 1000)),
   216:         }
   217:         if start is not None:
   218:             params["startTime"] = int(start)
   219:         if end is not None:
   220:             params["endTime"] = int(end)
   221: 
   222:         return self._request("GET", "/api/v2/mix/market/candles", params=params, signed=False)
   223: 
   224:     # -------------------------------------------------------------------------
   225:     # PRIVÉ (Futures One-Way par défaut)
   226:     # -------------------------------------------------------------------------
   227:     def get_account(self) -> Dict[str, Any]:
   228:         """Infos compte futures (marges, balances)."""
   229:         return self._request("GET", "/api/v2/mix/account/accounts", params={"productType": "USDT-FUTURES"}, signed=True)
   230: 
   231:     def get_open_orders(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   232:         params: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   233:         if symbol:
   234:             params["symbol"] = symbol.replace("_", "").upper()
   235:         return self._request("GET", "/api/v2/mix/order/open-orders", params=params, signed=True)
   236: 
   237:     def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
   238:         body = {
   239:             "symbol": symbol.replace("_", "").upper(),
   240:             "productType": "USDT-FUTURES",
   241:             "orderId": order_id,
   242:         }
   243:         return self._request("POST", "/api/v2/mix/order/cancel-order", body=body, signed=True)
   244: 
   245:     def cancel_all(self, symbol: Optional[str] = None) -> Dict[str, Any]:
   246:         body: Dict[str, Any] = {"productType": "USDT-FUTURES"}
   247:         if symbol:
   248:             body["symbol"] = symbol.replace("_", "").upper()
   249:         return self._request("POST", "/api/v2/mix/order/cancel-batch-orders", body=body, signed=True)
   250: 
   251:     # -- Mode de position & levier ---------------------------------------------
   252:     def set_position_mode_one_way(self, symbol: str, product_type: str = "USDT-FUTURES") -> Dict[str, Any]:
   253:         """Passe le mode de position en One-Way (si nécessaire)."""
   254:         body = {
   255:             "productType": product_type,
   256:             "symbol": symbol.replace("_", "").upper(),
   257:             "holdMode": "one_way",
   258:         }
   259:         return self._request("POST", "/api/v2/mix/account/set-position-mode", body=body, signed=True)
   260: 
   261:     def set_leverage(
   262:         self,
   263:         symbol: str,
   264:         product_type: str = "USDT-FUTURES",
   265:         margin_coin: str = "USDT",
   266:         leverage: int = 2,
   267:         side: str = "long",
   268:     ) -> Dict[str, Any]:
   269:         """Règle l’effet de levier (par side 'long'/'short' ou global selon l’API)."""
   270:         lev = max(1, int(leverage))
   271:         body = {
   272:             "symbol": symbol.replace("_", "").upper(),
   273:             "productType": product_type,
   274:             "marginCoin": margin_coin,
   275:             "leverage": str(lev),
   276:             "holdSide": side.lower(),  # 'long' ou 'short'
   277:         }
   278:         return self._request("POST", "/api/v2/mix/account/set-leverage", body=body, signed=True)
   279: 
   280:     # -- Placement d’ordres (One-Way) ------------------------------------------
   281:     def place_market_order_one_way(
   282:         self,
   283:         symbol: str,
   284:         side: str,
   285:         size: float,
   286:         product_type: str = "USDT-FUTURES",
   287:         margin_coin: str = "USDT",
   288:         client_oid: Optional[str] = None,
   289:     ) -> Dict[str, Any]:
   290:         """
   291:         Place un ordre MARKET en mode one-way.
   292:         side: 'buy' ou 'sell'
   293:         size: quantité de contrat (format arrondi côté serveur)
   294:         """
   295:         body: Dict[str, Any] = {
   296:             "symbol": symbol.replace("_", "").upper(),
   297:             "productType": product_type,
   298:             "marginCoin": margin_coin,
   299:             "size": f"{float(size):.6f}",
   300:             "side": side.lower(),
   301:             "orderType": "market",
   302:         }
   303:         if client_oid:
   304:             body["clientOid"] = client_oid
   305:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   306: 
   307:     def place_limit_order_one_way(
   308:         self,
   309:         symbol: str,
   310:         side: str,
   311:         size: float,
   312:         price: float,
   313:         product_type: str = "USDT-FUTURES",
   314:         margin_coin: str = "USDT",
   315:         tif: str = "GTC",
   316:         client_oid: Optional[str] = None,
   317:     ) -> Dict[str, Any]:
   318:         """
   319:         Place un ordre LIMIT en mode one-way.
   320:         tif: GTC/IOC/FOK suivant l’API.
   321:         """
   322:         body: Dict[str, Any] = {
   323:             "symbol": symbol.replace("_", "").upper(),
   324:             "productType": product_type,
   325:             "marginCoin": margin_coin,
   326:             "size": f"{float(size):.6f}",
   327:             "price": f"{float(price):.8f}",
   328:             "side": side.lower(),
   329:             "orderType": "limit",
   330:             "timeInForceValue": tif.upper(),
   331:         }
   332:         if client_oid:
   333:             body["clientOid"] = client_oid
   334:         return self._request("POST", "/api/v2/mix/order/place-order", body=body, signed=True)
   335: 
   336:     # -------------------------------------------------------------------------
   337:     # Helpers d’accès
   338:     # -------------------------------------------------------------------------
   339:     def last_price(self, symbol: str) -> float:
   340:         """Renvoie un prix last connu en tolérant plusieurs structures/clefs."""
   341:         tick = self.get_ticker(symbol)
   342:         data = tick.get("data")
   343:         if isinstance(data, list) and data:
   344:             data = data[0]
   345:         if not isinstance(data, dict):
   346:             return 0.0
   347:         price_str = (
   348:             data.get("lastPr")
   349:             or data.get("lastPrice")
   350:             or data.get("close")
   351:             or data.get("price")
   352:             or data.get("l")
   353:         )
   354:         try:
   355:             return float(price_str)
   356:         except Exception:
   357:             return 0.0

--------------------------------------------------------------------------------
FILE: engine/hooks/prewarm_cache.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: """
     3: Pré-chauffe léger du cache OHLCV.
     4: 
     5: Objectif: ne PAS bloquer le lancement. On log juste un statut "warmup OK"
     6: pour chaque symbole, et on s'assure que le dossier data existe.
     7: Si tu veux rebrancher un vrai downloader plus tard, expose simplement une
     8: fonction `prewarm_cache(cfg, symbols, timeframe, out_dir)` avec la même
     9: signature.
    10: """
    11: from __future__ import annotations
    12: from pathlib import Path
    13: from typing import Iterable
    14: 
    15: 
    16: def prewarm_cache(cfg: dict, symbols: Iterable[str], timeframe: str, out_dir: str | Path) -> None:
    17:     out = Path(out_dir)
    18:     out.mkdir(parents=True, exist_ok=True)
    19:     for sym in symbols:
    20:         # Marqueur vide; permet à d’autres services de voir que le symbole est "préparé"
    21:         (out / f"{sym}-{timeframe}.csv").touch(exist_ok=True)
    22:         print(f"[cache] warmup OK for {sym}")

--------------------------------------------------------------------------------
FILE: engine/live/notify.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import asyncio, logging, os
     3: from typing import Any, AsyncIterator, Dict, Optional
     4: import requests
     5: log = logging.getLogger("engine.live.notify")
     6: 
     7: class _NullNotifier:
     8:     async def send(self, text: str) -> None:
     9:         log.info("[NOTIFY] %s", text)
    10: 
    11: class TelegramNotifier:
    12:     def __init__(self, token: str, chat_id: str, timeout: float = 5.0) -> None:
    13:         self.token, self.chat_id, self.timeout = token, chat_id, timeout
    14:     async def send(self, text: str) -> None:
    15:         url = f"https://api.telegram.org/bot{self.token}/sendMessage"
    16:         payload = {"chat_id": self.chat_id, "text": text}
    17:         def _post() -> None:
    18:             requests.post(url, json=payload, timeout=self.timeout)
    19:         loop = asyncio.get_running_loop()
    20:         await loop.run_in_executor(None, _post)
    21: 
    22: def build_notifier_and_commands(cfg: Dict[str, Any] | None = None) -> tuple[Any, AsyncIterator[Dict[str, Any]] | None]:
    23:     token = os.getenv("TELEGRAM_BOT_TOKEN") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("token")
    24:     chat_id = os.getenv("TELEGRAM_CHAT_ID") or (cfg or {}).get("secrets", {}).get("telegram", {}).get("chat_id")
    25:     if token and chat_id:
    26:         return TelegramNotifier(token, chat_id), None
    27:     return _NullNotifier(), None

--------------------------------------------------------------------------------
FILE: engine/live/orchestrator.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import asyncio, logging, time
     3: from dataclasses import dataclass
     4: from pathlib import Path
     5: from typing import Any, AsyncIterator, List, Sequence
     6: 
     7: log = logging.getLogger("engine.live.orchestrator")
     8: 
     9: @dataclass(slots=True)
    10: class RunConfig:
    11:     symbols: Sequence[str]
    12:     timeframe: str = "1m"
    13:     refresh_secs: int = 5
    14:     cache_dir: str = "/notebooks/scalp_data/data"  # fallback sûr hors repo
    15: 
    16: def _ensure_dir(p: str | Path) -> Path:
    17:     path = Path(p)
    18:     path.mkdir(parents=True, exist_ok=True)
    19:     return path
    20: 
    21: def _parse_last_price_from_ohlcv(ohlcv: List[List[float]]) -> float:
    22:     if not ohlcv:
    23:         return 0.0
    24:     try:
    25:         return float(ohlcv[-1][4])
    26:     except Exception:
    27:         return 0.0
    28: 
    29: async def _fetch_ohlcv_any(exchange: Any, symbol: str, timeframe: str, limit: int = 150) -> List[List[float]]:
    30:     # 1) CCXT
    31:     fetch = getattr(exchange, "fetch_ohlcv", None)
    32:     if callable(fetch):
    33:         try:
    34:             data = await fetch(symbol, timeframe, limit=limit)  # async
    35:             return list(data or [])
    36:         except TypeError:
    37:             return list(fetch(symbol, timeframe, limit=limit) or [])  # sync
    38:         except Exception:
    39:             pass
    40:     # 2) REST
    41:     get_klines = getattr(exchange, "get_klines", None)
    42:     if callable(get_klines):
    43:         try:
    44:             resp = get_klines(symbol, interval=timeframe, limit=int(limit))
    45:             rows = resp.get("data") or []
    46:             out: List[List[float]] = []
    47:             for r in rows:
    48:                 try:
    49:                     out.append([int(r[0]), float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5]) if len(r)>5 else 0.0])
    50:                 except Exception:
    51:                     continue
    52:             out.sort(key=lambda x: x[0])
    53:             return out
    54:         except Exception:
    55:             pass
    56:     return []
    57: 
    58: class _NullNotifier:
    59:     async def send(self, text: str) -> None:
    60:         log.info("[NOTIFY] %s", text)
    61: 
    62: def _csv_row(path: Path, headers: Sequence[str], row: Sequence[Any]) -> None:
    63:     path.parent.mkdir(parents=True, exist_ok=True)
    64:     new = not path.exists()
    65:     with path.open("a", encoding="utf-8") as f:
    66:         if new:
    67:             f.write(",".join(headers) + "\n")
    68:         vals = [str(v).replace(",", " ") if isinstance(v, str) else str(v) for v in row]
    69:         f.write(",".join(vals) + "\n")
    70: 
    71: async def run_orchestrator(
    72:     exchange: Any,
    73:     cfg: RunConfig,
    74:     notifier: Any | None = None,
    75:     command_stream: AsyncIterator[dict] | None = None,
    76: ) -> None:
    77:     notifier = notifier or _NullNotifier()
    78:     cache_dir = _ensure_dir(cfg.cache_dir)
    79:     log_dir = _ensure_dir(cache_dir / "live" / "logs")
    80:     sig_path = log_dir / "signals.csv"
    81: 
    82:     await notifier.send(f"Bot démarré • tf={cfg.timeframe} • {len(cfg.symbols)} symboles")
    83: 
    84:     async def _tick_once() -> None:
    85:         ts = int(time.time() * 1000)
    86:         for sym in cfg.symbols:
    87:             ohlcv = await _fetch_ohlcv_any(exchange, sym, cfg.timeframe, limit=200)
    88:             price = _parse_last_price_from_ohlcv(ohlcv)
    89:             if price > 0:
    90:                 _csv_row(sig_path, ["ts", "symbol", "price", "tf"], [ts, sym, price, cfg.timeframe])
    91: 
    92:     last_hb = 0.0
    93:     try:
    94:         while True:
    95:             await _tick_once()
    96:             now = time.time()
    97:             if now - last_hb > max(30, cfg.refresh_secs * 6):
    98:                 try:
    99:                     await notifier.send("Listing ok ✅")
   100:                 except Exception:
   101:                     pass
   102:                 last_hb = now
   103:             await asyncio.sleep(max(1, int(cfg.refresh_secs)))
   104:     except asyncio.CancelledError:
   105:         raise
   106:     except KeyboardInterrupt:
   107:         log.info("Arrêt orchestrateur (Ctrl+C)")
   108:     finally:
   109:         try:
   110:             await notifier.send("Bot arrêté proprement 📴")
   111:         except Exception:
   112:             pass

--------------------------------------------------------------------------------
FILE: engine/logging_utils.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Logging helpers for the Scalp bot."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import atexit
     6: import csv
     7: import json
     8: import os
     9: import sqlite3
    10: import time
    11: from pathlib import Path
    12: from typing import Any, Dict, List
    13: 
    14: 
    15: def get_jsonl_logger(path: str, max_bytes: int = 0, backup_count: int = 0):
    16:     """Return a callable that logs events as JSON lines.
    17: 
    18:     Parameters
    19:     ----------
    20:     path: str
    21:         Target file path for JSON lines.
    22:     max_bytes: int, optional
    23:         If >0, rotate the file when its size exceeds this value.
    24:     backup_count: int, optional
    25:         Number of rotated files to keep when ``max_bytes`` is set.
    26:     """
    27:     os.makedirs(os.path.dirname(path), exist_ok=True)
    28:     log_file = open(path, "a", encoding="utf-8")
    29: 
    30:     def _close_file() -> None:
    31:         try:
    32:             log_file.close()
    33:         except Exception:
    34:             pass
    35: 
    36:     atexit.register(_close_file)
    37: 
    38:     def _rotate() -> None:
    39:         nonlocal log_file
    40:         log_file.close()
    41:         for i in range(backup_count - 1, 0, -1):
    42:             src = f"{path}.{i}"
    43:             dst = f"{path}.{i + 1}"
    44:             if os.path.exists(src):
    45:                 os.replace(src, dst)
    46:         os.replace(path, f"{path}.1")
    47:         log_file = open(path, "a", encoding="utf-8")
    48: 
    49:     def _log(event: str, payload: Dict[str, Any]) -> None:
    50:         nonlocal log_file
    51:         payload = dict(payload or {})
    52:         payload["event"] = event
    53:         payload["ts"] = int(time.time() * 1000)
    54:         line = json.dumps(payload, ensure_ascii=False)
    55:         if max_bytes and backup_count > 0:
    56:             if log_file.tell() + len(line) + 1 > max_bytes:
    57:                 _rotate()
    58:         log_file.write(line + "\n")
    59:         log_file.flush()
    60: 
    61:     return _log
    62: 
    63: 
    64: class TradeLogger:
    65:     """Helper writing trade information to CSV and SQLite files."""
    66: 
    67:     fields = [
    68:         "pair",
    69:         "tf",
    70:         "dir",
    71:         "entry",
    72:         "sl",
    73:         "tp",
    74:         "score",
    75:         "reasons",
    76:         "pnl",
    77:     ]
    78: 
    79:     def __init__(self, csv_path: str, sqlite_path: str) -> None:
    80:         os.makedirs(os.path.dirname(csv_path), exist_ok=True)
    81:         self.csv_path = csv_path
    82:         self.sqlite_path = sqlite_path
    83: 
    84:         # Ensure CSV has header
    85:         if not os.path.exists(csv_path):
    86:             with open(csv_path, "w", newline="", encoding="utf-8") as f:
    87:                 writer = csv.DictWriter(f, fieldnames=self.fields)
    88:                 writer.writeheader()
    89: 
    90:         # Setup SQLite store
    91:         self.conn = sqlite3.connect(sqlite_path)
    92:         cur = self.conn.cursor()
    93:         cur.execute(
    94:             """
    95:             CREATE TABLE IF NOT EXISTS trades (
    96:                 pair TEXT,
    97:                 tf TEXT,
    98:                 dir TEXT,
    99:                 entry REAL,
   100:                 sl REAL,
   101:                 tp REAL,
   102:                 score REAL,
   103:                 reasons TEXT,
   104:                 pnl REAL
   105:             )
   106:             """
   107:         )
   108:         self.conn.commit()
   109:         atexit.register(self.conn.close)
   110: 
   111:     def log(self, data: Dict[str, Any]) -> None:
   112:         row = {k: data.get(k) for k in self.fields}
   113:         with open(self.csv_path, "a", newline="", encoding="utf-8") as f:
   114:             writer = csv.DictWriter(f, fieldnames=self.fields)
   115:             writer.writerow(row)
   116:         cur = self.conn.cursor()
   117:         cur.execute(
   118:             "INSERT INTO trades (pair, tf, dir, entry, sl, tp, score, reasons, pnl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
   119:             (
   120:                 row["pair"],
   121:                 row["tf"],
   122:                 row["dir"],
   123:                 row["entry"],
   124:                 row["sl"],
   125:                 row["tp"],
   126:                 row["score"],
   127:                 row["reasons"],
   128:                 row["pnl"],
   129:             ),
   130:         )
   131:         self.conn.commit()
   132: 
   133: 
   134: BASE_DIR = Path(__file__).resolve().parents[2]
   135: 
   136: 
   137: def _append_csv(path: Path, fields: List[str], row: Dict[str, Any]) -> None:
   138:     """Append a row to ``path`` creating the file with ``fields`` if needed."""
   139:     path.parent.mkdir(parents=True, exist_ok=True)
   140:     file_exists = path.exists()
   141:     with path.open("a", newline="", encoding="utf-8") as f:
   142:         writer = csv.DictWriter(f, fieldnames=fields)
   143:         if not file_exists:
   144:             writer.writeheader()
   145:         writer.writerow({k: row.get(k) for k in fields})
   146: 
   147: 
   148: def log_position(data: Dict[str, Any]) -> None:
   149:     """Log a closed position to ``../positions.csv``."""
   150:     fields = [
   151:         "timestamp",
   152:         "pair",
   153:         "direction",
   154:         "entry",
   155:         "exit",
   156:         "pnl_pct",
   157:         "fee_rate",
   158:         "notes",
   159:     ]
   160:     _append_csv(BASE_DIR / "positions.csv", fields, data)
   161: 
   162: 
   163: def log_operation_memo(data: Dict[str, Any]) -> None:
   164:     """Log operation details to ``../operations_memo.csv``."""
   165:     fields = ["timestamp", "pair", "details"]
   166:     _append_csv(BASE_DIR / "operations_memo.csv", fields, data)

--------------------------------------------------------------------------------
FILE: engine/metrics.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Utility metrics for trading calculations."""
     2: 
     3: from __future__ import annotations
     4: 
     5: 
     6: from typing import Iterable
     7: 
     8: __all__ = ["calc_pnl_pct", "calc_rsi", "calc_atr", "calc_macd", "backtest_position"]
     9: 
    10: 
    11: def calc_pnl_pct(
    12:     entry_price: float, exit_price: float, side: int, fee_rate: float = 0.0
    13: ) -> float:
    14:     """Return percentage PnL between entry and exit prices minus fees.
    15: 
    16: 
    17:     Parameters
    18:     ----------
    19:     entry_price: float
    20:         Trade entry price (>0).
    21:     exit_price: float
    22:         Trade exit price (>0).
    23:     side: int
    24:         +1 for long, -1 for short.
    25:     fee_rate: float, optional
    26:         Trading fee rate per operation (e.g., 0.0006 for 0.06%). The fee is
    27:         applied twice (entry + exit).
    28:     """
    29:     if entry_price <= 0 or exit_price <= 0:
    30:         raise ValueError("Prices must be positive")
    31:     if side not in (1, -1):
    32:         raise ValueError("side must be +1 (long) or -1 (short)")
    33: 
    34:     pnl = (exit_price - entry_price) / entry_price * 100.0 * side
    35:     fee_pct = fee_rate * 2 * 100.0  # entrée + sortie
    36:     return pnl - fee_pct
    37: 
    38: 
    39: def calc_rsi(prices: Iterable[float], period: int = 14) -> float:
    40:     """Compute the Relative Strength Index (RSI) using Wilder's smoothing.
    41: 
    42: 
    43:     Parameters
    44:     ----------
    45:     prices:
    46:         Ordered sequence of closing prices.
    47:     period:
    48:         Number of periods to use for the calculation. Must be positive and the
    49:         length of ``prices`` must be at least ``period + 1``.
    50:     """
    51: 
    52:     prices_list = [float(p) for p in prices]
    53: 
    54:     if period <= 0:
    55:         raise ValueError("period must be positive")
    56:     if len(prices_list) < period + 1:
    57: 
    58:         raise ValueError("len(prices) must be >= period + 1")
    59: 
    60:     gains: list[float] = []
    61:     losses: list[float] = []
    62:     for i in range(1, period + 1):
    63: 
    64:         diff = prices_list[i] - prices_list[i - 1]
    65: 
    66:         if diff >= 0:
    67:             gains.append(diff)
    68:             losses.append(0.0)
    69:         else:
    70:             gains.append(0.0)
    71:             losses.append(-diff)
    72: 
    73:     avg_gain = sum(gains) / period
    74:     avg_loss = sum(losses) / period
    75: 
    76:     for i in range(period + 1, len(prices_list)):
    77:         diff = prices_list[i] - prices_list[i - 1]
    78: 
    79:         gain = max(diff, 0.0)
    80:         loss = max(-diff, 0.0)
    81:         avg_gain = (avg_gain * (period - 1) + gain) / period
    82:         avg_loss = (avg_loss * (period - 1) + loss) / period
    83: 
    84:     if avg_gain == 0 and avg_loss == 0:
    85:         return 50.0
    86:     if avg_loss == 0:
    87:         return 100.0
    88:     if avg_gain == 0:
    89:         return 0.0
    90:     rs = avg_gain / avg_loss
    91:     return 100.0 - (100.0 / (1.0 + rs))
    92: 
    93: 
    94: def calc_atr(
    95:     highs: Iterable[float],
    96:     lows: Iterable[float],
    97:     closes: Iterable[float],
    98:     period: int = 14,
    99: ) -> float:
   100:     """Compute the Average True Range (ATR) using Wilder's smoothing.
   101: 
   102: 
   103:     Parameters
   104:     ----------
   105:     highs, lows, closes:
   106:         Ordered sequences of high, low and close prices. All sequences must
   107:         have the same length and contain at least ``period + 1`` elements.
   108:     period:
   109:         Number of periods to use for the calculation. Must be positive.
   110:     """
   111: 
   112:     highs_list = [float(h) for h in highs]
   113:     lows_list = [float(low) for low in lows]
   114:     closes_list = [float(c) for c in closes]
   115: 
   116:     length = len(highs_list)
   117:     if length != len(lows_list) or length != len(closes_list):
   118: 
   119:         raise ValueError("Input sequences must have the same length")
   120:     if period <= 0:
   121:         raise ValueError("period must be positive")
   122:     if length < period + 1:
   123:         raise ValueError("Input sequences must have at least period + 1 elements")
   124: 
   125:     trs: list[float] = []
   126:     for i in range(1, len(highs_list)):
   127:         tr = max(
   128:             highs_list[i] - lows_list[i],
   129:             abs(highs_list[i] - closes_list[i - 1]),
   130:             abs(lows_list[i] - closes_list[i - 1]),
   131:         )
   132:         trs.append(tr)
   133: 
   134:     atr = sum(trs[:period]) / period
   135:     for tr in trs[period:]:
   136:         atr = (atr * (period - 1) + tr) / period
   137:     return atr
   138: 
   139: 
   140: def calc_macd(
   141:     prices: Sequence[float],
   142:     fast: int = 12,
   143:     slow: int = 26,
   144:     signal: int = 9,
   145: ) -> tuple[float, float, float]:
   146:     """Return MACD, signal line and histogram values.
   147: 
   148:     The implementation computes exponential moving averages using Wilder's
   149:     smoothing. ``prices`` must contain at least ``slow + signal`` elements.
   150:     """
   151: 
   152:     prices_list = [float(p) for p in prices]
   153:     if fast <= 0 or slow <= 0 or signal <= 0:
   154:         raise ValueError("periods must be positive")
   155:     min_len = max(fast, slow) + signal
   156:     if len(prices_list) < min_len:
   157:         raise ValueError("len(prices) must be >= slow + signal")
   158: 
   159:     def _ema_series(series: Sequence[float], window: int) -> list[float]:
   160:         k = 2.0 / (window + 1.0)
   161:         out = [float(series[0])]
   162:         for x in series[1:]:
   163:             out.append(float(x) * k + out[-1] * (1.0 - k))
   164:         return out
   165: 
   166:     fast_ema = _ema_series(prices_list, fast)
   167:     slow_ema = _ema_series(prices_list, slow)
   168:     macd_series = [f - s for f, s in zip(fast_ema, slow_ema)]
   169:     signal_series = _ema_series(macd_series, signal)
   170:     macd_val = macd_series[-1]
   171:     signal_val = signal_series[-1]
   172:     hist = macd_val - signal_val
   173:     return macd_val, signal_val, hist
   174: 
   175: 
   176: def backtest_position(
   177:     prices: list[float], entry_idx: int, exit_idx: int, side: int
   178: ) -> bool:
   179:     """Run a basic backtest to verify a position's coherence.
   180: 
   181:     Parameters
   182:     ----------
   183:     prices: list[float]
   184:         Sequential list of prices to evaluate.
   185:     entry_idx: int
   186:         Index in ``prices`` where the position is opened.
   187:     exit_idx: int
   188:         Index in ``prices`` where the position is closed (must be > ``entry_idx``).
   189:     side: int
   190:         +1 for long, -1 for short.
   191: 
   192:     Returns
   193:     -------
   194:     bool
   195:         ``True`` if the resulting PnL is non-negative, meaning the position is
   196:         coherent with the direction of price movement. ``False`` otherwise.
   197:     """
   198:     if side not in (1, -1):
   199:         raise ValueError("side must be +1 (long) or -1 (short)")
   200:     if not (0 <= entry_idx < exit_idx < len(prices)):
   201:         raise ValueError(
   202:             "entry_idx and exit_idx must be valid and entry_idx < exit_idx"
   203:         )
   204: 
   205:     entry_price = float(prices[entry_idx])
   206:     exit_price = float(prices[exit_idx])
   207:     pnl = calc_pnl_pct(entry_price, exit_price, side)
   208:     return pnl >= 0.0

--------------------------------------------------------------------------------
FILE: engine/pairs.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: """Utilities to select trading pairs and detect signals."""
     2: from __future__ import annotations
     3: from typing import Any, Dict, List, Optional, Callable
     4: from engine.strategy import Signal
     5: 
     6: from engine.bot_config import CONFIG
     7: from engine.strategy import ema as default_ema, cross as default_cross
     8: from engine.notifier import notify
     9: 
    10: 
    11: def get_trade_pairs(client: Any) -> List[Dict[str, Any]]:
    12:     """Return all trading pairs using the client's ``get_ticker`` method."""
    13:     tick = client.get_ticker()
    14:     data = tick.get("data") if isinstance(tick, dict) else []
    15:     if not data:
    16:         return []
    17:     return data if isinstance(data, list) else [data]
    18: 
    19: 
    20: def filter_trade_pairs(
    21:     client: Any,
    22:     *,
    23:     volume_min: float = 5_000_000,
    24:     max_spread_bps: float = 5.0,
    25:     top_n: int = 40,
    26: ) -> List[Dict[str, Any]]:
    27:     """Filter pairs by volume and spread."""
    28:     pairs = get_trade_pairs(client)
    29:     eligible: List[Dict[str, Any]] = []
    30: 
    31:     for info in pairs:
    32:         sym = info.get("symbol")
    33:         if not sym:
    34:             continue
    35:         try:
    36:             vol = float(info.get("volume", 0))
    37:         except (TypeError, ValueError):
    38:             continue
    39:         if vol < volume_min:
    40:             continue
    41:         try:
    42:             bid = float(info.get("bidPrice", 0))
    43:             ask = float(info.get("askPrice", 0))
    44:         except (TypeError, ValueError):
    45:             continue
    46:         if bid <= 0 or ask <= 0:
    47:             continue
    48:         spread_bps = (ask - bid) / ((ask + bid) / 2) * 10_000
    49:         if spread_bps >= max_spread_bps:
    50:             continue
    51:         eligible.append(info)
    52: 
    53:     eligible.sort(key=lambda row: float(row.get("volume", 0)), reverse=True)
    54:     return eligible[:top_n]
    55: 
    56: 
    57: def select_top_pairs(client: Any, top_n: int = 40, key: str = "volume") -> List[Dict[str, Any]]:
    58:     """Return ``top_n`` pairs sorted by ``key``."""
    59:     pairs = get_trade_pairs(client)
    60: 
    61:     def volume(row: Dict[str, Any]) -> float:
    62:         try:
    63:             return float(row.get(key, 0))
    64:         except (TypeError, ValueError):
    65:             return 0.0
    66: 
    67:     pairs.sort(key=volume, reverse=True)
    68:     return pairs[:top_n]
    69: 
    70: 
    71: def _ancienne_impl(
    72:     client: Any,
    73:     pairs: List[Dict[str, Any]],
    74:     *,
    75:     interval: str = "1m",
    76:     ema_fast_n: Optional[int] = None,
    77:     ema_slow_n: Optional[int] = None,
    78:     ema_func=default_ema,
    79:     cross_func=default_cross,
    80: ) -> List[Dict[str, Any]]:
    81:     """Original implementation returning dicts."""
    82:     ema_fast_n = ema_fast_n or CONFIG.get("EMA_FAST", 9)
    83:     ema_slow_n = ema_slow_n or CONFIG.get("EMA_SLOW", 21)
    84:     results: List[Dict[str, Any]] = []
    85: 
    86:     for info in pairs:
    87:         symbol = info.get("symbol")
    88:         if not symbol:
    89:             continue
    90:         k = client.get_kline(symbol, interval=interval)
    91:         closes = k.get("data", {}).get("close", []) if isinstance(k, dict) else []
    92:         if len(closes) < max(ema_fast_n, ema_slow_n) + 2:
    93:             continue
    94:         efull = ema_func(closes, ema_fast_n)
    95:         eslow = ema_func(closes, ema_slow_n)
    96:         signal = cross_func(efull[-1], eslow[-1], efull[-2], eslow[-2])
    97:         if signal == 1:
    98:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
    99:             results.append({"symbol": symbol, "signal": "long", "price": float(price_str)})
   100:         elif signal == -1:
   101:             price_str = info.get("lastPr") or info.get("lastPrice") or 0.0
   102:             results.append({"symbol": symbol, "signal": "short", "price": float(price_str)})
   103:     return results
   104: 
   105: 
   106: def _to_signal(d: dict) -> Signal:
   107:     side = 1 if d.get("signal") in ("long", "buy", 1, True) else -1
   108:     return Signal(
   109:         symbol=d.get("symbol"),
   110:         side=side,
   111:         entry=float(d.get("price", d.get("entry", 0))),
   112:         sl=float(d.get("sl", 0)),
   113:         tp1=float(d.get("tp1", 0)) or None,
   114:         tp2=float(d.get("tp2", 0)) or None,
   115:         score=d.get("score"),
   116:         quality=d.get("quality"),
   117:         reasons=d.get("reasons", []),
   118:     )
   119: 
   120: 
   121: def find_trade_positions(
   122:     client: Any,
   123:     pairs: List[Dict[str, Any]],
   124:     *,
   125:     interval: str = "1m",
   126:     ema_fast_n: Optional[int] = None,
   127:     ema_slow_n: Optional[int] = None,
   128:     ema_func=default_ema,
   129:     cross_func=default_cross,
   130: ) -> List[Signal]:
   131:     raw = _ancienne_impl(
   132:         client,
   133:         pairs,
   134:         interval=interval,
   135:         ema_fast_n=ema_fast_n,
   136:         ema_slow_n=ema_slow_n,
   137:         ema_func=ema_func,
   138:         cross_func=cross_func,
   139:     )
   140:     return [_to_signal(x) for x in raw]
   141: 
   142: 
   143: def send_selected_pairs(
   144:     client: Any,
   145:     top_n: int = 40,
   146:     *,
   147:     select_fn: Callable[[Any, int], List[Dict[str, Any]]] = select_top_pairs,
   148:     notify_fn: Callable[[str, Optional[Dict[str, Any]]], None] = notify,
   149: ) -> Dict[str, str]:
   150:     """Fetch top pairs, drop USD/USDT/USDC duplicates and notify their list.
   151: 
   152:     Returns the payload sent to ``notify_fn``. The mapping contains the
   153:     comma-separated symbols for each color group (``green``, ``orange`` and
   154:     ``red``) or an empty dictionary when no pairs are available.
   155:     """
   156: 
   157:     def split_symbol(sym: str) -> tuple[str, str]:
   158:         if "_" in sym:
   159:             left, right = sym.split("_", 1)
   160:             # Legacy style: BTC_USDT
   161:             if len(right) <= 4:
   162:                 return left, right
   163:             # Bitget futures style: BTCUSDT_UMCBL
   164:             main = left
   165:             if main.endswith("USDT"):
   166:                 return main[:-4], "USDT"
   167:             if main.endswith("USDC"):
   168:                 return main[:-4], "USDC"
   169:             if main.endswith("USD"):
   170:                 return main[:-3], "USD"
   171:             return main, ""
   172:         if sym.endswith("USDT"):
   173:             return sym[:-4], "USDT"
   174:         if sym.endswith("USDC"):
   175:             return sym[:-4], "USDC"
   176:         if sym.endswith("USD"):
   177:             return sym[:-3], "USD"
   178:         return sym, ""
   179: 
   180:     pairs = select_fn(client, top_n=top_n * 3)
   181:     allowed = {s.split("_")[0].upper() for s in CONFIG.get("ALLOWED_SYMBOLS", [])}
   182:     by_base: Dict[str, Dict[str, Any]] = {}
   183:     for info in pairs:
   184:         sym = info.get("symbol")
   185:         if not sym:
   186:             continue
   187:         norm_sym = sym.split("_")[0].upper()
   188:         if allowed and norm_sym not in allowed:
   189:             continue
   190:         base, quote = split_symbol(sym)
   191:         existing = by_base.get(base)
   192:         priority = {"USDT": 3, "USDC": 2, "USD": 1}
   193:         if existing is None or priority.get(quote, 0) > priority.get(existing["quote"], 0):
   194:             by_base[base] = {"data": info, "quote": quote}
   195: 
   196:     unique = sorted(
   197:         (v["data"] for v in by_base.values()),
   198:         key=lambda row: float(row.get("volume", 0)),
   199:         reverse=True,
   200:     )
   201:     symbols: list[str] = []
   202:     for row in unique[:top_n]:
   203:         sym = row.get("symbol")
   204:         if not sym:
   205:             continue
   206:         base, _ = split_symbol(sym)
   207:         symbols.append(base)
   208:     if symbols:
   209:         n = len(symbols)
   210:         third = max(n // 3, 1)
   211:         green = symbols[:third]
   212:         orange = symbols[third : 2 * third]
   213:         red = symbols[2 * third :]
   214:         payload: Dict[str, str] = {}
   215:         if green:
   216:             payload["green"] = ", ".join(green)
   217:         if orange:
   218:             payload["orange"] = ", ".join(orange)
   219:         if red:
   220:             payload["red"] = ", ".join(red)
   221:         notify_fn("pair_list", payload)
   222:         return payload
   223:     return {}
   224: 
   225: 
   226: def heat_score(volatility: float, volume: float, news: bool = False) -> float:
   227:     """Return a heat score combining volatility, volume and a news flag."""
   228:     mult = 2.0 if news else 1.0
   229:     return volatility * volume * mult
   230: 
   231: 
   232: def select_top_heat_pairs(
   233:     pairs: List[Dict[str, Any]], *, top_n: int = 3
   234: ) -> List[Dict[str, Any]]:
   235:     """Return ``top_n`` pairs ranked by ``heat_score``."""
   236: 
   237:     scored: List[Dict[str, Any]] = []
   238:     for info in pairs:
   239:         try:
   240:             vol = float(info.get("volatility", 0))
   241:             volume = float(info.get("volume", 0))
   242:         except (TypeError, ValueError):
   243:             continue
   244:         score = heat_score(vol, volume, bool(info.get("news")))
   245:         row = dict(info)
   246:         row["heat_score"] = score
   247:         scored.append(row)
   248: 
   249:     scored.sort(key=lambda r: r["heat_score"], reverse=True)
   250:     return scored[:top_n]
   251: 
   252: 
   253: def decorrelate_pairs(
   254:     pairs: List[Dict[str, Any]],
   255:     corr: Dict[str, Dict[str, float]],
   256:     *,
   257:     threshold: float = 0.8,
   258:     top_n: int = 3,
   259: ) -> List[Dict[str, Any]]:
   260:     """Return top pairs while avoiding highly correlated symbols.
   261: 
   262:     ``corr`` is a mapping of pair symbol to correlation with other symbols.  Two
   263:     pairs are considered too correlated when the absolute value of the
   264:     correlation exceeds ``threshold``.
   265:     """
   266: 
   267:     selected: List[Dict[str, Any]] = []
   268:     for info in select_top_heat_pairs(pairs, top_n=len(pairs)):
   269:         sym = info.get("symbol")
   270:         if not sym:
   271:             continue
   272:         if all(abs(corr.get(sym, {}).get(p["symbol"], 0.0)) < threshold for p in selected):
   273:             selected.append(info)
   274:         if len(selected) >= top_n:
   275:             break
   276:     return selected

--------------------------------------------------------------------------------
FILE: engine/positions/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/positions/state.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: from dataclasses import dataclass, field
     3: from enum import Enum, auto
     4: from typing import List, Optional
     5: import time
     6: 
     7: class PositionStatus(Enum):
     8:     IDLE = auto()
     9:     PENDING_ENTRY = auto()
    10:     OPEN = auto()
    11:     PENDING_EXIT = auto()
    12:     CLOSED = auto()
    13: 
    14: class PositionSide(Enum):
    15:     LONG = 1
    16:     SHORT = -1
    17: 
    18: @dataclass
    19: class Fill:
    20:     order_id: str
    21:     trade_id: str
    22:     price: float
    23:     qty: float
    24:     fee: float
    25:     ts: int
    26: 
    27: @dataclass
    28: class PositionState:
    29:     symbol: str
    30:     side: PositionSide
    31:     status: PositionStatus = PositionStatus.IDLE
    32:     entry_order_id: Optional[str] = None
    33:     exit_order_id: Optional[str] = None
    34:     req_qty: float = 0.0
    35:     filled_qty: float = 0.0
    36:     avg_entry_price: float = 0.0
    37:     avg_exit_price: float = 0.0
    38:     sl: Optional[float] = None
    39:     tp: Optional[float] = None
    40:     realized_pnl: float = 0.0
    41:     fees: float = 0.0
    42:     opened_ts: Optional[int] = None
    43:     closed_ts: Optional[int] = None
    44:     fills: List[Fill] = field(default_factory=list)
    45:     last_sync_ts: int = field(default_factory=lambda: int(time.time()*1000))
    46: 
    47:     def apply_fill_entry(self, f: Fill) -> None:
    48:         self.fills.append(f)
    49:         self.filled_qty += f.qty
    50:         # moyenne pondérée
    51:         notional = self.avg_entry_price * (self.filled_qty - f.qty) + f.price * f.qty
    52:         self.avg_entry_price = notional / max(1e-12, self.filled_qty)
    53:         self.fees += abs(f.fee)
    54:         if self.opened_ts is None:
    55:             self.opened_ts = f.ts
    56:         if self.filled_qty > 1e-12:
    57:             self.status = PositionStatus.OPEN
    58: 
    59:     def apply_fill_exit(self, f: Fill) -> None:
    60:         self.fills.append(f)
    61:         qty = min(self.filled_qty, f.qty)
    62:         # realized pnl sur la quantité fermée
    63:         if self.side == PositionSide.LONG:
    64:             self.realized_pnl += (f.price - self.avg_entry_price) * qty
    65:         else:
    66:             self.realized_pnl += (self.avg_entry_price - f.price) * qty
    67:         self.fees += abs(f.fee)
    68:         self.filled_qty = max(0.0, self.filled_qty - qty)
    69:         # moyenne de sortie indicative
    70:         closed_q = (self.req_qty - self.filled_qty)
    71:         self.avg_exit_price = ((self.avg_exit_price * (closed_q - qty)) + f.price * qty) / max(1e-12, closed_q)
    72:         if self.filled_qty <= 1e-12:
    73:             self.status = PositionStatus.CLOSED
    74:             self.closed_ts = f.ts
    75: 

--------------------------------------------------------------------------------
FILE: engine/risk/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalp/risk/__init__.py
     2: from .manager import (
     3:     Caps,
     4:     compute_size,
     5:     calc_position_size,  # alias legacy
     6:     RiskManager,         # shim legacy
     7: )
     8: 
     9: __all__ = ["Caps", "compute_size", "calc_position_size", "RiskManager"]

--------------------------------------------------------------------------------
FILE: engine/risk/manager.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalp/risk/manager.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any
     5: 
     6: @dataclass
     7: class Caps:
     8:     min_qty: float = 0.0
     9:     min_notional: float = 0.0
    10:     max_leverage: float = 20.0
    11: 
    12: def _get_caps(caps_by_symbol: Optional[Dict[str, Any]], symbol: str) -> Caps:
    13:     if not caps_by_symbol:
    14:         return Caps()
    15:     c = caps_by_symbol.get(symbol, {})
    16:     return Caps(
    17:         min_qty=float(c.get("min_qty", 0.0) or 0.0),
    18:         min_notional=float(c.get("min_notional", 0.0) or 0.0),
    19:         max_leverage=float(c.get("max_leverage", 20.0) or 20.0),
    20:     )
    21: 
    22: def compute_size(
    23:     *,
    24:     symbol: str,
    25:     price: float,
    26:     balance_cash: float,
    27:     risk_pct: float = 0.5,
    28:     caps_by_symbol: Optional[Dict[str, Any]] = None,
    29: ) -> float:
    30:     """Sizing robuste avec gardes min_notional / min_qty."""
    31:     price = max(1e-9, float(price))
    32:     balance_cash = max(0.0, float(balance_cash))
    33:     risk_pct = max(0.0, float(risk_pct))
    34: 
    35:     notionnel = balance_cash * risk_pct
    36:     qty = notionnel / price
    37: 
    38:     caps = _get_caps(caps_by_symbol, symbol)
    39:     if caps.min_notional > 0 and (qty * price) < caps.min_notional:
    40:         qty = caps.min_notional / price
    41:     if caps.min_qty > 0 and qty < caps.min_qty:
    42:         qty = caps.min_qty
    43:     return max(0.0, qty)
    44: 
    45: # --- Shims pour compatibilité ancienne API -----------------------------------
    46: 
    47: def calc_position_size(symbol: str, price: float, balance_cash: float,
    48:                        risk_pct: float = 0.5,
    49:                        caps_by_symbol: Optional[Dict[str, Any]] = None) -> float:
    50:     """Alias legacy → compute_size."""
    51:     return compute_size(
    52:         symbol=symbol, price=price, balance_cash=balance_cash,
    53:         risk_pct=risk_pct, caps_by_symbol=caps_by_symbol
    54:     )
    55: 
    56: class RiskManager:
    57:     """
    58:     Shim minimal compatible avec l'ancien code:
    59:       rm = RiskManager(risk_pct=0.5, caps_by_symbol={...})
    60:       qty = rm.size(symbol, price, balance_cash)
    61:     """
    62:     def __init__(self, risk_pct: float = 0.5, caps_by_symbol: Optional[Dict[str, Any]] = None):
    63:         self.risk_pct = float(risk_pct)
    64:         self.caps_by_symbol = caps_by_symbol or {}
    65: 
    66:     def size(self, symbol: str, price: float, balance_cash: float) -> float:
    67:         return compute_size(
    68:             symbol=symbol, price=price, balance_cash=balance_cash,
    69:             risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
    70:         )

--------------------------------------------------------------------------------
FILE: engine/selection/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Pair selection helpers for the Scalp bot.
     2: 
     3: This package exposes two utilities used during the preparation phase of the
     4: trading strategy:
     5: 
     6: ``scan_pairs``
     7:     Performs the first level market scan by filtering pairs based on volume,
     8:     spread and hourly volatility.
     9: 
    10: ``select_active_pairs``
    11:     Refines a list of pairs by keeping only those showing an EMA20/EMA50
    12:     crossover and a sufficiently high ATR.
    13: """
    14: 
    15: from .scanner import scan_pairs
    16: from .momentum import select_active_pairs
    17: 
    18: __all__ = ["scan_pairs", "select_active_pairs"]
    19: 

--------------------------------------------------------------------------------
FILE: engine/selection/momentum.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Utilities to select pairs exhibiting strong momentum."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List, Sequence
     6: 
     7: from ..metrics import calc_atr
     8: 
     9: 
    10: def ema(series: Sequence[float], window: int) -> List[float]:
    11:     """Simple exponential moving average implementation."""
    12: 
    13:     if window <= 1 or not series:
    14:         return list(series)
    15:     k = 2.0 / (window + 1.0)
    16:     out: List[float] = [float(series[0])]
    17:     prev = out[0]
    18:     for x in series[1:]:
    19:         prev = float(x) * k + prev * (1.0 - k)
    20:         out.append(prev)
    21:     return out
    22: 
    23: 
    24: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    25:     """Return 1 if a bullish cross occurred, -1 for bearish, 0 otherwise."""
    26: 
    27:     if prev_fast <= prev_slow and last_fast > last_slow:
    28:         return 1
    29:     if prev_fast >= prev_slow and last_fast < last_slow:
    30:         return -1
    31:     return 0
    32: 
    33: 
    34: def _quantile(values: Sequence[float], q: float) -> float:
    35:     """Return the *q* quantile of *values* (0 <= q <= 1)."""
    36: 
    37:     if not values:
    38:         return 0.0
    39:     q = min(max(q, 0.0), 1.0)
    40:     vals = sorted(values)
    41:     idx = int((len(vals) - 1) * q)
    42:     return vals[idx]
    43: 
    44: 
    45: def select_active_pairs(
    46:     client: Any,
    47:     pairs: Sequence[Dict[str, Any]],
    48:     *,
    49:     interval: str = "Min5",
    50:     ema_fast: int = 20,
    51:     ema_slow: int = 50,
    52:     atr_period: int = 14,
    53:     atr_quantile: float = 0.5,
    54:     top_n: int = 5,
    55: ) -> List[Dict[str, Any]]:
    56:     """Return pairs with an EMA crossover and high ATR.
    57: 
    58:     Only pairs where ``EMA20`` crosses ``EMA50`` on the latest candle are kept.
    59:     Among those candidates, the Average True Range is computed and only pairs
    60:     whose ATR is above the provided quantile are returned.  The resulting
    61:     dictionaries include an ``atr`` key for convenience.
    62:     """
    63: 
    64:     candidates: List[Dict[str, Any]] = []
    65:     atrs: List[float] = []
    66: 
    67:     for info in pairs:
    68:         sym = info.get("symbol")
    69:         if not sym:
    70:             continue
    71:         k = client.get_kline(sym, interval=interval)
    72:         kdata = k.get("data") if isinstance(k, dict) else {}
    73:         closes = kdata.get("close", [])
    74:         highs = kdata.get("high", [])
    75:         lows = kdata.get("low", [])
    76:         if len(closes) < max(ema_slow, atr_period) + 2:
    77:             continue
    78:         efast = ema(closes, ema_fast)
    79:         eslow = ema(closes, ema_slow)
    80:         if cross(efast[-1], eslow[-1], efast[-2], eslow[-2]) == 0:
    81:             continue
    82:         atr_val = calc_atr(highs, lows, closes, atr_period)
    83:         row = dict(info)
    84:         row["atr"] = atr_val
    85:         candidates.append(row)
    86:         atrs.append(atr_val)
    87: 
    88:     if not candidates:
    89:         return []
    90: 
    91:     threshold = _quantile(atrs, atr_quantile)
    92:     selected = [row for row in candidates if row["atr"] >= threshold]
    93:     selected.sort(key=lambda r: r["atr"], reverse=True)
    94:     return selected[:top_n]
    95: 
    96: 
    97: __all__ = ["select_active_pairs"]
    98: 

--------------------------------------------------------------------------------
FILE: engine/selection/scanner.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Utilities for scanning tradable pairs on the exchange."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from typing import Any, Dict, List
     6: 
     7: 
     8: def scan_pairs(
     9:     client: Any,
    10:     *,
    11:     volume_min: float = 5_000_000,
    12:     max_spread_bps: float = 5.0,
    13:     min_hourly_vol: float = 0.0,
    14:     top_n: int = 40,
    15: ) -> List[Dict[str, Any]]:
    16:     """Return pairs satisfying basic liquidity and volatility filters.
    17: 
    18:     Parameters
    19:     ----------
    20:     client: Any
    21:         Client instance exposing ``get_ticker`` and ``get_kline`` methods.
    22:     volume_min: float, optional
    23:         Minimum 24h volume required to keep a pair.
    24:     max_spread_bps: float, optional
    25:         Maximum allowed bid/ask spread expressed in basis points.
    26:     min_hourly_vol: float, optional
    27:         Minimum volatility over the last hour expressed as ``(high - low) /
    28:         close``.  When set to ``0`` the filter is disabled.
    29:     top_n: int, optional
    30:         Limit the number of returned pairs.
    31:     """
    32: 
    33:     tick = client.get_ticker()
    34:     data = tick.get("data") if isinstance(tick, dict) else []
    35:     if not isinstance(data, list):
    36:         data = [data]
    37: 
    38:     eligible: List[Dict[str, Any]] = []
    39: 
    40:     for row in data:
    41:         sym = row.get("symbol")
    42:         if not sym:
    43:             continue
    44:         try:
    45:             vol = float(row.get("volume", 0))
    46:             bid = float(row.get("bidPrice", 0))
    47:             ask = float(row.get("askPrice", 0))
    48:         except (TypeError, ValueError):
    49:             continue
    50:         if vol < volume_min or bid <= 0 or ask <= 0:
    51:             continue
    52:         spread_bps = (ask - bid) / ((ask + bid) / 2.0) * 10_000
    53:         if spread_bps >= max_spread_bps:
    54:             continue
    55: 
    56:         if min_hourly_vol > 0:
    57:             k = client.get_kline(sym, interval="Min60")
    58:             kdata = k.get("data") if isinstance(k, dict) else {}
    59:             highs = kdata.get("high", [])
    60:             lows = kdata.get("low", [])
    61:             closes = kdata.get("close", [])
    62:             if not highs or not lows or not closes:
    63:                 continue
    64:             try:
    65:                 h = float(highs[-1])
    66:                 l = float(lows[-1])
    67:                 c = float(closes[-1])
    68:             except (TypeError, ValueError):
    69:                 continue
    70:             hourly_vol = (h - l) / c if c else 0.0
    71:             if hourly_vol < min_hourly_vol:
    72:                 continue
    73: 
    74:         eligible.append(row)
    75: 
    76:     eligible.sort(key=lambda r: float(r.get("volume", 0)), reverse=True)
    77:     return eligible[:top_n]
    78: 
    79: 
    80: __all__ = ["scan_pairs"]
    81: 

--------------------------------------------------------------------------------
FILE: engine/selfcheck.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/selfcheck.py
     2: from __future__ import annotations
     3: import os, sys, importlib, traceback
     4: from pathlib import Path
     5: 
     6: NOTEBOOKS = Path("/notebooks")
     7: REPO = (NOTEBOOKS / "scalp") if NOTEBOOKS.exists() else Path(__file__).resolve().parents[2]
     8: 
     9: def _mask(val: str) -> str:
    10:     if not val: return ""
    11:     return (val[:3] + "…" + val[-3:]) if len(val) > 6 else "********"
    12: 
    13: def _try_import(modname: str):
    14:     try:
    15:         m = importlib.import_module(modname)
    16:         return True, m
    17:     except Exception:
    18:         return False, traceback.format_exc()
    19: 
    20: def preflight(verbose: bool = False) -> list[str]:
    21:     """
    22:     Retourne la liste des 'issues' trouvées (vide si tout est OK).
    23:     Ne lève pas d'exception. N'écrit que de l'info lisible.
    24:     """
    25:     issues: list[str] = []
    26:     # s'assurer que le repo est bien dans sys.path
    27:     if str(REPO) not in sys.path:
    28:         sys.path.insert(0, str(REPO))
    29: 
    30:     print("=== SCALPER PREFLIGHT ===")
    31:     print(f"[i] Repo: {REPO}")
    32:     print(f"[i] Python: {sys.version.split()[0]}")
    33: 
    34:     # backtest API
    35:     ok, mod = _try_import("engine.backtest")
    36:     if not ok:
    37:         print("[✗] Import engine.backtest KO")
    38:         if verbose: print(mod)  # ici 'mod' contient la trace
    39:         issues.append("backtest import")
    40:     else:
    41:         has_single = hasattr(mod, "run_single")
    42:         has_multi  = hasattr(mod, "run_multi")
    43:         print(f"[✓] engine.backtest: run_single={has_single} run_multi={has_multi}")
    44:         if not (has_single and has_multi):
    45:             issues.append("backtest API incomplète")
    46: 
    47:     # trade_utils
    48:     ok, mod = _try_import("engine.trade_utils")
    49:     if not ok:
    50:         print("[✗] Import engine.trade_utils KO")
    51:         if verbose: print(mod)
    52:         issues.append("trade_utils import")
    53:     else:
    54:         print(f"[✓] engine.trade_utils: compute_position_size={'compute_position_size' in dir(mod)}")
    55: 
    56:     # fees
    57:     ok, mod = _try_import("engine.exchange.fees")
    58:     if not ok:
    59:         print("[✗] Import engine.exchange.fees KO")
    60:         if verbose: print(mod)
    61:         issues.append("fees import")
    62:     else:
    63:         need = {"get_fee", "load_bitget_fees"}
    64:         miss = [n for n in need if not hasattr(mod, n)]
    65:         if miss: issues.append("fees API manquante: " + ",".join(miss))
    66:         print("[✓] engine.exchange.fees OK")
    67: 
    68:     # notify/commands/backtest_telegram/orchestrator
    69:     for name, required in [
    70:         ("engine.live.notify", ("build_notifier_and_stream",)),
    71:         ("engine.live.commands", ("CommandHandler",)),
    72:         ("engine.live.backtest_telegram", ("handle_backtest_command",)),
    73:         ("engine.live.orchestrator", ("run_orchestrator", "Orchestrator")),
    74:     ]:
    75:         ok, mod = _try_import(name)
    76:         if not ok:
    77:             print(f"[✗] Import {name} KO")
    78:             if verbose: print(mod)
    79:             issues.append(f"{name} import")
    80:         else:
    81:             miss = [a for a in required if not hasattr(mod, a)]
    82:             if miss: issues.append(f"{name} API manquante: {','.join(miss)}")
    83:             print(f"[✓] {name} OK")
    84: 
    85:     # ENV (masqué)
    86:     tg_t = os.getenv("TELEGRAM_BOT_TOKEN", "")
    87:     tg_c = os.getenv("TELEGRAM_CHAT_ID", "")
    88:     gu   = os.getenv("GIT_USER", "")
    89:     gt   = os.getenv("GIT_TOKEN", "")
    90:     print("\n-- ENV --")
    91:     print(f"  TELEGRAM_BOT_TOKEN: {_mask(tg_t)} {'(ABSENT)' if not tg_t else ''}")
    92:     print(f"  TELEGRAM_CHAT_ID  : {_mask(tg_c)} {'(ABSENT)' if not tg_c else ''}")
    93:     print(f"  GIT_USER          : {gu or '(ABSENT)'}")
    94:     print(f"  GIT_TOKEN         : {_mask(gt)} {'(ABSENT)' if not gt else ''}")
    95: 
    96:     # Data
    97:     data_dir = (REPO / "data")
    98:     print("\n-- DATA --")
    99:     if data_dir.exists():
   100:         csvs = list(data_dir.glob("*.csv"))
   101:         print(f"  {len(csvs)} CSV trouvé(s) dans data/ (OK si tu backtestes via CSV)")
   102:     else:
   103:         print("  data/ absent (OK si loader API)")
   104: 
   105:     return issues
   106: 
   107: def preflight_or_die(verbose: bool = False) -> None:
   108:     issues = preflight(verbose=verbose)
   109:     if issues:
   110:         print("\n[✗] Préflight a détecté des problèmes :")
   111:         for it in issues: print("   -", it)
   112:         print("\nConseils :")
   113:         print(" - Vérifie les fichiers remplacés (backtest/__init__.py, trade_utils.py, exchange/fees.py).")
   114:         print(" - Évite d'importer optimize/walkforward dans backtest/__init__.py.")
   115:         print(" - Charge /notebooks/.env si TELEGRAM/GIT sont absents (source /notebooks/.env).")
   116:         raise SystemExit(1)
   117:     print("\n[✓] Préflight OK — démarrage du bot.")

--------------------------------------------------------------------------------
FILE: engine/services/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: engine/services/data_cache.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/services/data_cache.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Iterable, List, Optional, Tuple, Dict
     9: 
    10: # ---------------------------------------------------------------------
    11: # Réglages via env (valeurs sûres par défaut)
    12: # ---------------------------------------------------------------------
    13: DATA_DIR = os.getenv("DATA_DIR", "/notebooks/data")           # dossier PERSISTANT (hors-git)
    14: CSV_MAX_AGE = int(os.getenv("CSV_MAX_AGE_SECONDS", "0"))      # 0 = auto (en fonction du TF)
    15: CSV_MIN_ROWS = int(os.getenv("CSV_MIN_ROWS", "200"))          # minimum de lignes attendues
    16: STALE_FACTOR = float(os.getenv("CSV_STALE_FACTOR", "6"))      # âge max = STALE_FACTOR * tf_sec
    17: PREFETCH_CONC = int(os.getenv("CSV_PREFETCH_CONC", "4"))      # concurrence préchauffage
    18: 
    19: os.makedirs(DATA_DIR, exist_ok=True)
    20: 
    21: 
    22: # ---------------------------------------------------------------------
    23: # Helpers
    24: # ---------------------------------------------------------------------
    25: def parse_timeframe_to_seconds(tf: str) -> int:
    26:     tf = tf.strip().lower()
    27:     unit = tf[-1]
    28:     try:
    29:         n = int(tf[:-1])
    30:     except Exception as e:
    31:         raise ValueError(f"timeframe invalide: {tf}") from e
    32:     if unit == "m":
    33:         return n * 60
    34:     if unit == "h":
    35:         return n * 3600
    36:     if unit == "d":
    37:         return n * 86400
    38:     raise ValueError(f"timeframe invalide: {tf}")
    39: 
    40: 
    41: def csv_path(symbol: str, timeframe: str) -> str:
    42:     return os.path.join(DATA_DIR, f"{symbol}-{timeframe}.csv")
    43: 
    44: 
    45: def read_csv_ohlcv(path: str) -> List[Tuple[int, float, float, float, float, float]]:
    46:     rows: List[Tuple[int, float, float, float, float, float]] = []
    47:     if not os.path.exists(path):
    48:         return rows
    49:     with open(path, "r", newline="") as f:
    50:         r = csv.reader(f)
    51:         header = next(r, None)  # accepte avec ou sans header
    52:         for line in r:
    53:             if not line:
    54:                 continue
    55:             ts, o, h, l, c, v = line[:6]
    56:             rows.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
    57:     return rows
    58: 
    59: 
    60: def write_csv_ohlcv(path: str, data: Iterable[Tuple[int, float, float, float, float, float]]) -> None:
    61:     first = not os.path.exists(path)
    62:     os.makedirs(os.path.dirname(path), exist_ok=True)
    63:     with open(path, "a", newline="") as f:
    64:         w = csv.writer(f)
    65:         if first:
    66:             w.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    67:         for row in data:
    68:             w.writerow(row)
    69: 
    70: 
    71: def last_ts(rows: List[Tuple[int, float, float, float, float, float]]) -> Optional[int]:
    72:     return rows[-1][0] if rows else None
    73: 
    74: 
    75: # ---------------------------------------------------------------------
    76: # Fetch CCXT paginé
    77: # ---------------------------------------------------------------------
    78: async def ccxt_fetch_ohlcv_all(
    79:     exchange,
    80:     symbol: str,
    81:     timeframe: str,
    82:     since_ms: Optional[int],
    83:     limit: int = 1000,
    84: ) -> List[Tuple[int, float, float, float, float, float]]:
    85:     """
    86:     Récupère OHLCV par pages (limit 1000) depuis since_ms jusqu'à ~now.
    87:     Retourne une liste triée/dédupliquée.
    88:     """
    89:     out: List[Tuple[int, float, float, float, float, float]] = []
    90:     tf_ms = parse_timeframe_to_seconds(timeframe) * 1000
    91:     now_ms = exchange.milliseconds() if hasattr(exchange, "milliseconds") else int(time.time() * 1000)
    92: 
    93:     cursor = since_ms or (now_ms - 200 * tf_ms)
    94:     while True:
    95:         batch = await exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=cursor, limit=limit)
    96:         if not batch:
    97:             break
    98:         for ts, o, h, l, c, v in batch:
    99:             out.append((int(ts), float(o), float(h), float(l), float(c), float(v)))
   100:         next_cursor = batch[-1][0] + tf_ms
   101:         if next_cursor <= cursor:
   102:             break
   103:         cursor = next_cursor
   104:         if cursor >= now_ms + (2 * tf_ms):
   105:             break
   106:         await asyncio.sleep(getattr(exchange, "rateLimit", 200) / 1000)
   107: 
   108:     out.sort(key=lambda x: x[0])
   109:     dedup: List[Tuple[int, float, float, float, float, float]] = []
   110:     seen = set()
   111:     for row in out:
   112:         if row[0] in seen:
   113:             continue
   114:         seen.add(row[0])
   115:         dedup.append(row)
   116:     return dedup
   117: 
   118: 
   119: # ---------------------------------------------------------------------
   120: # Cache manager
   121: # ---------------------------------------------------------------------
   122: async def ensure_symbol_csv_cache(
   123:     exchange,
   124:     symbol: str,
   125:     timeframe: str,
   126:     min_rows: int = CSV_MIN_ROWS,
   127: ) -> str:
   128:     """
   129:     Garantit qu'un CSV OHLCV récent existe pour (symbol, timeframe).
   130:     Crée/append si nécessaire. Retourne le chemin.
   131:     """
   132:     path = csv_path(symbol, timeframe)
   133:     rows = read_csv_ohlcv(path)
   134:     tf_sec = parse_timeframe_to_seconds(timeframe)
   135:     tf_ms = tf_sec * 1000
   136:     now_ms = int(time.time() * 1000)
   137: 
   138:     # âge max
   139:     max_age = CSV_MAX_AGE if CSV_MAX_AGE > 0 else int(tf_sec * STALE_FACTOR)
   140: 
   141:     need_full = False
   142:     need_append = False
   143: 
   144:     if not rows:
   145:         need_full = True
   146:     else:
   147:         last = last_ts(rows) or 0
   148:         age_sec = max(0, (now_ms - last) // 1000)
   149:         if age_sec > max_age or len(rows) < min_rows:
   150:             need_append = True
   151: 
   152:     if need_full:
   153:         since = now_ms - (tf_ms * 2000)  # ~2000 bougies
   154:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   155:         if len(fresh) < min_rows:
   156:             since = now_ms - (tf_ms * 5000)
   157:             fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   158:         if os.path.exists(path):
   159:             os.remove(path)
   160:         write_csv_ohlcv(path, fresh)
   161:         return path
   162: 
   163:     if need_append:
   164:         since = (last_ts(rows) or now_ms - (tf_ms * 2000)) + tf_ms
   165:         fresh = await ccxt_fetch_ohlcv_all(exchange, symbol, timeframe, since_ms=since)
   166:         if fresh:
   167:             write_csv_ohlcv(path, fresh)
   168: 
   169:     return path
   170: 
   171: 
   172: async def prewarm_csv_cache(exchange, symbols: Iterable[str], timeframe: str) -> Dict[str, str]:
   173:     """
   174:     Prépare le cache pour plusieurs symboles (concurrence limitée).
   175:     Retourne {symbol: path}.
   176:     """
   177:     sem = asyncio.Semaphore(PREFETCH_CONC)
   178:     result: Dict[str, str] = {}
   179: 
   180:     async def _one(sym: str):
   181:         async with sem:
   182:             p = await ensure_symbol_csv_cache(exchange, sym, timeframe)
   183:             result[sym] = p
   184: 
   185:     await asyncio.gather(*[_one(s) for s in symbols])
   186:     return result

--------------------------------------------------------------------------------
FILE: engine/services/order_service.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: from dataclasses import dataclass
     3: from typing import Any, Dict, Optional, Protocol
     4: from engine.trade_utils import extract_available_balance
     5: 
     6: 
     7: @dataclass
     8: class OrderCaps:
     9:     min_trade_usdt: float = 5.0
    10:     leverage: float = 1.0
    11: 
    12: 
    13: @dataclass
    14: class OrderRequest:
    15:     symbol: str
    16:     side: str
    17:     price: float
    18:     sl: float
    19:     tp: Optional[float]
    20:     risk_pct: float
    21: 
    22: 
    23: @dataclass
    24: class OrderResult:
    25:     accepted: bool
    26:     reason: str = ""
    27:     payload: Dict[str, Any] = None
    28:     order_id: Optional[str] = None
    29:     status: Optional[str] = None
    30:     avg_price: Optional[float] = None
    31:     filled_qty: Optional[float] = None
    32: 
    33: 
    34: class Exchange(Protocol):
    35:     def get_assets(self) -> Dict[str, Any]: ...
    36:     def get_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]: ...
    37:     def place_order(
    38:         self,
    39:         symbol: str,
    40:         side: str,
    41:         quantity: float,
    42:         order_type: str,
    43:         price: Optional[float] = None,
    44:         stop_loss: Optional[float] = None,
    45:         take_profit: Optional[float] = None,
    46:     ) -> Dict[str, Any]: ...
    47: 
    48: 
    49: class OrderService:
    50:     def __init__(self, exchange: Exchange, caps: OrderCaps = OrderCaps()):
    51:         self.exchange = exchange
    52:         self.caps = caps
    53: 
    54:     @staticmethod
    55:     def _abs(x: float) -> float:
    56:         return -x if x < 0 else x
    57: 
    58:     def _calc_qty(self, equity_usdt: float, price: float, sl: float, risk_pct: float) -> float:
    59:         dist = self._abs(price - sl)
    60:         if dist <= 0:
    61:             return 0.0
    62:         risk_usdt = max(0.0, equity_usdt * risk_pct)
    63:         return 0.0 if price <= 0 else (risk_usdt / dist)
    64: 
    65:     def prepare_and_place(self, equity_usdt: float, req: OrderRequest) -> OrderResult:
    66:         qty = self._calc_qty(equity_usdt, req.price, req.sl, req.risk_pct)
    67:         if qty <= 0:
    68:             return OrderResult(False, "invalid_size")
    69:         notional = qty * req.price
    70:         if notional < self.caps.min_trade_usdt:
    71:             return OrderResult(False, "under_min_notional")
    72:         assets = self.exchange.get_assets()
    73:         available = extract_available_balance(assets)
    74:         required_margin = notional / max(1.0, self.caps.leverage)
    75:         if available < required_margin:
    76:             return OrderResult(False, "insufficient_margin")
    77:         side = "BUY" if req.side == "long" else "SELL"
    78:         out = self.exchange.place_order(
    79:             symbol=req.symbol, side=side, quantity=qty,
    80:             order_type="limit", price=req.price,
    81:             stop_loss=req.sl, take_profit=req.tp
    82:         )
    83:         # extraire infos utiles
    84:         oid = None; status = None; avg = None; filled = None
    85:         try:
    86:             data = out.get("data") if isinstance(out, dict) else out
    87:             if isinstance(data, dict):
    88:                 oid = str(data.get("orderId") or data.get("ordId") or data.get("id") or "")
    89:                 status = (data.get("status") or data.get("state") or "new").lower()
    90:                 avg = float(data.get("avgPrice", data.get("avgPx", 0)) or 0)
    91:                 filled = float(data.get("filledQty", data.get("fillSz", 0)) or 0)
    92:         except Exception:
    93:             pass
    94:         return OrderResult(True, "", out, oid, status, avg, filled)

--------------------------------------------------------------------------------
FILE: engine/services/utils.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/services/utils.py
     2: from __future__ import annotations
     3: import asyncio
     4: from typing import Callable, Any
     5: 
     6: 
     7: class NullNotifier:
     8:     async def send(self, _msg: str) -> None:
     9:         return
    10: 
    11: 
    12: async def heartbeat_task(running_getter: Callable[[], bool], notifier: Any, period: float = 30.0) -> None:
    13:     if notifier is None:
    14:         notifier = NullNotifier()
    15:     try:
    16:         while running_getter():
    17:             await notifier.send("heartbeat alive")
    18:             await asyncio.sleep(period)
    19:     except asyncio.CancelledError:
    20:         pass
    21: 
    22: 
    23: async def log_stats_task(
    24:     notifier: Any,
    25:     ticks_getter: Callable[[], int],
    26:     symbols_getter: Callable[[], list[str]],
    27:     period: float = 30.0,
    28: ) -> None:
    29:     if notifier is None:
    30:         notifier = NullNotifier()
    31:     last = 0
    32:     try:
    33:         while True:
    34:             total = int(ticks_getter() or 0)
    35:             delta = total - last
    36:             last = total
    37:             syms = symbols_getter() or []
    38:             msg = f"[stats] ticks_total={total} (+{delta} /30s) | pairs=" + ",".join(syms)
    39:             print(msg)
    40:             await notifier.send(msg)
    41:             await asyncio.sleep(period)
    42:     except asyncio.CancelledError:
    43:         pass

--------------------------------------------------------------------------------
FILE: engine/signals/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: __all__ = ["factory"]

--------------------------------------------------------------------------------
FILE: engine/signals/current.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/signals/current.py
     2: from __future__ import annotations
     3: 
     4: # Wrapper pour utiliser la stratégie live actuelle en mode "plugin"
     5: from engine.strategy import generate_signal as _generate_signal
     6: 
     7: def generate_signal(**kwargs):
     8:     """
     9:     Expose la même signature que engine.strategy.generate_signal.
    10:     Sert d’adaptateur pour la factory.
    11:     """
    12:     return _generate_signal(**kwargs)

--------------------------------------------------------------------------------
FILE: engine/signals/factory.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/signals/factory.py
     2: from __future__ import annotations
     3: from typing import Callable, Dict, Any
     4: import importlib
     5: import os
     6: import json
     7: 
     8: try:
     9:     import yaml  # type: ignore
    10: except Exception:
    11:     yaml = None  # type: ignore
    12: 
    13: SignalFn = Callable[..., Any]
    14: 
    15: # IMPORTANT : on pointe par défaut sur TA stratégie actuelle dans scalper/strategy.py
    16: _REGISTRY: Dict[str, str] = {
    17:     "current": "engine.strategy:generate_signal",
    18:     # Tu pourras ajouter d'autres stratégies ici, par ex :
    19:     # "ema_cross": "engine.strategies.ema_cross:generate_signal",
    20: }
    21: 
    22: def _load_callable(path: str) -> SignalFn:
    23:     if ":" not in path:
    24:         raise ValueError(f"Chemin callable invalide: {path}")
    25:     module_name, attr = path.split(":", 1)
    26:     mod = importlib.import_module(module_name)
    27:     fn = getattr(mod, attr, None)
    28:     if not callable(fn):
    29:         raise ValueError(f"{attr} n'est pas callable dans {module_name}")
    30:     return fn  # type: ignore
    31: 
    32: def load_signal(name: str) -> SignalFn:
    33:     key = (name or "").strip().lower()
    34:     if key not in _REGISTRY:
    35:         raise KeyError(f"Stratégie inconnue: '{name}'. Registre: {list(_REGISTRY)}")
    36:     return _load_callable(_REGISTRY[key])
    37: 
    38: def _read_yaml(path: str) -> dict:
    39:     if yaml is None:
    40:         with open(path, "r", encoding="utf-8") as f:
    41:             return json.load(f)
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         return yaml.safe_load(f) or {}
    44: 
    45: def load_strategies_cfg(path: str | None) -> dict:
    46:     """
    47:     Charge le mapping (symbole, timeframe) -> nom de stratégie.
    48:     Si le fichier n'existe pas, retourne une config par défaut fonctionnelle.
    49:     """
    50:     default_cfg = {"default": "current", "by_timeframe": {}, "by_symbol": {}}
    51:     if not path:
    52:         return default_cfg
    53:     if not os.path.isfile(path):
    54:         # Pas de fichier ? On continue avec les valeurs par défaut.
    55:         return default_cfg
    56:     cfg = _read_yaml(path)
    57:     cfg.setdefault("default", "current")
    58:     cfg.setdefault("by_timeframe", {})
    59:     cfg.setdefault("by_symbol", {})
    60:     return cfg
    61: 
    62: def resolve_strategy_name(symbol: str, timeframe: str, cfg: dict) -> str:
    63:     symbol = (symbol or "").upper()
    64:     timeframe = (timeframe or "").lower()
    65:     return (
    66:         cfg.get("by_symbol", {}).get(symbol, {}).get(timeframe)
    67:         or cfg.get("by_timeframe", {}).get(timeframe)
    68:         or cfg.get("default", "current")
    69:     )
    70: 
    71: def resolve_signal_fn(symbol: str, timeframe: str, cfg: dict) -> SignalFn:
    72:     return load_signal(resolve_strategy_name(symbol, timeframe, cfg))

--------------------------------------------------------------------------------
FILE: engine/signals/generator.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from typing import Any, Dict, List, Optional
     4: 
     5: import pandas as pd
     6: 
     7: from data.indicators import compute_all
     8: 
     9: __all__ = ["generate_signal"]
    10: 
    11: 
    12: def _quality_from_score(score: float) -> str:
    13:     if score >= 0.8:
    14:         return "A"
    15:     if score >= 0.5:
    16:         return "B"
    17:     return "C"
    18: 
    19: 
    20: def generate_signal(
    21:     df: pd.DataFrame,
    22:     *,
    23:     trend_tf: Optional[pd.DataFrame] = None,
    24:     confirm_tf: Optional[pd.DataFrame] = None,
    25:     atr_mult: float = 1.0,
    26:     trailing: bool = False,
    27:     **_: Any,
    28: ) -> Optional[Dict[str, Any]]:
    29:     """Generate a trading signal with confluence scoring.
    30: 
    31:     Parameters
    32:     ----------
    33:     df: pd.DataFrame
    34:         Primary timeframe OHLCV data.
    35:     trend_tf: pd.DataFrame, optional
    36:         Higher timeframe used for trend filtering.
    37:     confirm_tf: pd.DataFrame, optional
    38:         Lower timeframe used for confirmation.
    39:     atr_mult: float, optional
    40:         Multiplier applied to ATR for stop/target calculation.
    41:     trailing: bool, optional
    42:         When ``True`` include a ``trail`` distance (ATR * ``atr_mult``).
    43: 
    44:     Returns
    45:     -------
    46:     dict | None
    47:         Dictionary describing the signal or ``None`` if no trade setup exists.
    48:     """
    49: 
    50:     if df is None or len(df) < 2:
    51:         return None
    52: 
    53:     df = compute_all(df)
    54:     last = df.iloc[-1]
    55: 
    56:     conditions: List[bool] = []
    57:     reasons: List[str] = []
    58:     direction: Optional[str] = None
    59: 
    60:     # --- Basic trend via EMAs ----------------------------------------------
    61:     if last["close"] > last["ema20"] > last["ema50"]:
    62:         direction = "long"
    63:         reasons.append("price_above_ema")
    64:         conditions.append(True)
    65:     elif last["close"] < last["ema20"] < last["ema50"]:
    66:         direction = "short"
    67:         reasons.append("price_below_ema")
    68:         conditions.append(True)
    69:     else:
    70:         conditions.append(False)
    71:         return None
    72: 
    73:     # --- RSI ---------------------------------------------------------------
    74:     if direction == "long":
    75:         cond = last["rsi"] > 55
    76:         if cond:
    77:             reasons.append("rsi_bullish")
    78:         conditions.append(cond)
    79:     else:
    80:         cond = last["rsi"] < 45
    81:         if cond:
    82:             reasons.append("rsi_bearish")
    83:         conditions.append(cond)
    84: 
    85:     # --- MACD --------------------------------------------------------------
    86:     if direction == "long":
    87:         cond = last["macd"] > last["macd_signal"]
    88:         if cond:
    89:             reasons.append("macd_bullish")
    90:         conditions.append(cond)
    91:     else:
    92:         cond = last["macd"] < last["macd_signal"]
    93:         if cond:
    94:             reasons.append("macd_bearish")
    95:         conditions.append(cond)
    96: 
    97:     # --- OBV momentum ------------------------------------------------------
    98:     if len(df) >= 2:
    99:         obv_up = df["obv"].iloc[-1] > df["obv"].iloc[-2]
   100:         if obv_up:
   101:             reasons.append("obv_trending")
   102:         conditions.append(obv_up)
   103: 
   104:     # --- Trend timeframe filter -------------------------------------------
   105:     if trend_tf is not None and len(trend_tf) >= 2:
   106:         tdf = compute_all(trend_tf)
   107:         ema50 = tdf["ema50"]
   108:         slope = ema50.iloc[-1] - ema50.iloc[-2]
   109:         if direction == "long":
   110:             cond = slope > 0
   111:             if cond:
   112:                 reasons.append("trend_up")
   113:             conditions.append(cond)
   114:         else:
   115:             cond = slope < 0
   116:             if cond:
   117:                 reasons.append("trend_down")
   118:             conditions.append(cond)
   119: 
   120:     # --- Confirmation timeframe filter ------------------------------------
   121:     if confirm_tf is not None and len(confirm_tf) > 0:
   122:         cdf = compute_all(confirm_tf)
   123:         rsi = cdf["rsi"].iloc[-1]
   124:         if direction == "long":
   125:             cond = rsi > 50
   126:             if cond:
   127:                 reasons.append("confirm_rsi_bullish")
   128:             conditions.append(cond)
   129:         else:
   130:             cond = rsi < 50
   131:             if cond:
   132:                 reasons.append("confirm_rsi_bearish")
   133:             conditions.append(cond)
   134: 
   135:     score = (
   136:         sum(1 for c in conditions if c) / len(conditions) if conditions else 0.0
   137:     )
   138:     quality = _quality_from_score(score)
   139: 
   140:     atr = last.get("atr")
   141:     if pd.isna(atr) or atr == 0:
   142:         return None
   143: 
   144:     entry = float(last["close"])
   145:     if direction == "long":
   146:         sl = entry - atr * atr_mult
   147:         tp = entry + atr * atr_mult * 2
   148:     else:
   149:         sl = entry + atr * atr_mult
   150:         tp = entry - atr * atr_mult * 2
   151: 
   152:     result: Dict[str, Any] = {
   153:         "direction": direction,
   154:         "entry": entry,
   155:         "sl": sl,
   156:         "tp": tp,
   157:         "score": round(score, 3),
   158:         "reasons": reasons,
   159:         "quality": quality,
   160:     }
   161: 
   162:     if trailing:
   163:         result["trail"] = atr * atr_mult
   164: 
   165:     return result

--------------------------------------------------------------------------------
FILE: engine/strategy/factory.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: annulé

--------------------------------------------------------------------------------
FILE: engine/strategy.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: """Core trading strategy components for scalping EMA/VWAP/RSI/ATR.
     2: 
     3: This module implements a minimal but functional version of the strategy
     4: outlined in the project specification.  The focus is on pure Python
     5: implementations so the logic can easily be unit tested without requiring
     6: external services or heavy third‑party dependencies.
     7: 
     8: The strategy is deliberately stateless; functions operate on passed data and
     9: return simple data structures.  This makes it easy to plug the logic into
    10: real‑time trading loops or backtest engines.
    11: """
    12: 
    13: from __future__ import annotations
    14: 
    15: from dataclasses import dataclass
    16: from typing import Sequence, List, Dict, Optional, Tuple, Any
    17: 
    18: from .metrics import calc_rsi, calc_atr, calc_pnl_pct, calc_macd
    19: from .risk import calc_position_size
    20: 
    21: # ---------------------------------------------------------------------------
    22: # Helpers
    23: # ---------------------------------------------------------------------------
    24: 
    25: def ema(series: Sequence[float], window: int) -> List[float]:
    26:     """Return the exponential moving average of *series*.
    27: 
    28:     The first value is the raw input to remain consistent with most trading
    29:     platforms.  ``window`` must be positive; when it equals ``1`` the input is
    30:     returned unchanged.
    31:     """
    32: 
    33:     if window <= 1 or not series:
    34:         return list(series)
    35:     k = 2.0 / (window + 1.0)
    36:     out: List[float] = [float(series[0])]
    37:     prev = out[0]
    38:     for x in series[1:]:
    39:         prev = float(x) * k + prev * (1.0 - k)
    40:         out.append(prev)
    41:     return out
    42: 
    43: def vwap(highs: Sequence[float], lows: Sequence[float],
    44:          closes: Sequence[float], volumes: Sequence[float]) -> float:
    45:     """Compute the volume weighted average price (VWAP).
    46: 
    47:     Parameters
    48:     ----------
    49:     highs, lows, closes, volumes: Sequence[float]
    50:         Matching sequences for the period considered.
    51:     """
    52: 
    53:     tp_vol = 0.0
    54:     vol_sum = 0.0
    55:     for h, low, c, v in zip(highs, lows, closes, volumes):
    56:         tp = (h + low + c) / 3.0
    57:         tp_vol += tp * v
    58:         vol_sum += v
    59:     return tp_vol / vol_sum if vol_sum else 0.0
    60: 
    61: def obv(closes: Sequence[float], volumes: Sequence[float]) -> List[float]:
    62:     """Return the On Balance Volume (OBV) series."""
    63: 
    64:     if not closes:
    65:         return []
    66:     out: List[float] = [0.0]
    67:     for i in range(1, len(closes)):
    68:         if closes[i] > closes[i - 1]:
    69:             out.append(out[-1] + volumes[i])
    70:         elif closes[i] < closes[i - 1]:
    71:             out.append(out[-1] - volumes[i])
    72:         else:
    73:             out.append(out[-1])
    74:     return out
    75: 
    76: 
    77: def cross(last_fast: float, last_slow: float, prev_fast: float, prev_slow: float) -> int:
    78:     """Detect a crossing between two series.
    79: 
    80:     Returns ``1`` for a bullish crossover, ``-1`` for a bearish crossover and
    81:     ``0`` otherwise.
    82:     """
    83: 
    84:     if prev_fast <= prev_slow and last_fast > last_slow:
    85:         return 1
    86:     if prev_fast >= prev_slow and last_fast < last_slow:
    87:         return -1
    88:     return 0
    89: 
    90: 
    91: def order_book_imbalance(bid_vol: float, ask_vol: float) -> float:
    92:     """Compute order book imbalance.
    93: 
    94:     The value is normalised between ``-1`` and ``1`` where positive numbers
    95:     indicate bid dominance.  ``0`` is returned when both volumes are zero.
    96:     """
    97: 
    98:     total = bid_vol + ask_vol
    99:     return (bid_vol - ask_vol) / total if total else 0.0
   100: 
   101: 
   102: def swing_levels(
   103:     highs: Sequence[float], lows: Sequence[float], lookback: int
   104: ) -> Tuple[float, float]:
   105:     """Return the most recent swing high and swing low.
   106: 
   107:     ``lookback`` defines how many completed candles are inspected.  The current
   108:     candle is excluded to avoid look‑ahead bias.
   109:     """
   110: 
   111:     if len(highs) < lookback + 1 or len(lows) < lookback + 1:
   112:         return highs[-1], lows[-1]
   113:     high = max(highs[-lookback - 1 : -1])
   114:     low = min(lows[-lookback - 1 : -1])
   115:     return high, low
   116: 
   117: # ---------------------------------------------------------------------------
   118: # Pair selection
   119: # ---------------------------------------------------------------------------
   120: 
   121: # The first and second level pair selection helpers now live in
   122: # :mod:`engine.selection`.  They are re-exported here for backward compatibility
   123: # and to keep the public API unchanged.
   124: from .selection.scanner import scan_pairs  # noqa: E402
   125: from .selection.momentum import select_active_pairs  # noqa: E402
   126: 
   127: # ---------------------------------------------------------------------------
   128: # Signal generation
   129: # ---------------------------------------------------------------------------
   130: 
   131: @dataclass
   132: class Signal:
   133:     """Trading signal with risk parameters."""
   134: 
   135:     symbol: str
   136:     side: int  # 1 for long, -1 for short
   137:     entry: float
   138:     sl: float
   139:     tp1: float
   140:     tp2: float
   141:     qty: float = 0.0
   142:     score: Optional[float] = None
   143:     quality: Optional[float] = None
   144:     reasons: Optional[List[str]] = None
   145: 
   146:     def __post_init__(self) -> None:  # pragma: no cover - simple coercion
   147:         if isinstance(self.side, str):
   148:             self.side = 1 if self.side.lower() in {"long", "buy", "1", "true"} else -1
   149: 
   150:     @property
   151:     def price(self) -> float:
   152:         return self.entry
   153: 
   154: 
   155: def _generate_signal(
   156:     symbol: str,
   157:     ohlcv: Dict[str, Sequence[float]],
   158:     *,
   159:     equity: float,
   160:     risk_pct: float,
   161:     ohlcv_15m: Optional[Dict[str, Sequence[float]]] = None,
   162:     ohlcv_1h: Optional[Dict[str, Sequence[float]]] = None,
   163:     order_book: Optional[Dict[str, float]] = None,
   164:     tick_ratio_buy: Optional[float] = None,
   165:     atr_disable_pct: float = 0.2,
   166:     atr_reduce_pct: float = 2.0,
   167:     swing_lookback: int = 5,
   168:     macd_fast: int = 12,
   169:     macd_slow: int = 26,
   170:     macd_signal: int = 9,
   171:     trend_ema_period: int = 200,
   172: ) -> Optional[Signal]:
   173:     """Return a trading :class:`Signal` if conditions are met.
   174: 
   175:     ``ohlcv`` must contain ``open``, ``high``, ``low``, ``close`` and ``volume``
   176:     sequences ordered from oldest to newest.  The function checks the following
   177:     rules:
   178: 
   179:     * price positioned relative to VWAP and EMA20/EMA50 trend
   180:     * RSI(14) crossing key levels (40/60)
   181:     * OBV rising or high short‑term volume
   182:     * Multi time frame confirmation (H1 EMA50 slope, RSI15 >/< 50)
   183:     * Micro‑structure breakout of last swing high/low
   184:     * MACD trend filter
   185:     * Long‑term trend via configurable EMA filter
   186:     * Order book imbalance and tape filters
   187:     * Dynamic ATR‑based stop‑loss and take‑profit
   188:     * Position sizing via ``calc_position_size``
   189:     """
   190: 
   191:     closes = [float(x) for x in ohlcv.get("close", [])]
   192:     highs = [float(x) for x in ohlcv.get("high", [])]
   193:     lows = [float(x) for x in ohlcv.get("low", [])]
   194:     vols = [float(x) for x in ohlcv.get("volume", [])]
   195:     if len(closes) < 60 or len(highs) != len(lows) or len(closes) != len(highs):
   196:         return None
   197: 
   198:     price = closes[-1]
   199:     ema20 = ema(closes, 20)
   200:     ema50 = ema(closes, 50)
   201:     ema_trend = ema(closes, trend_ema_period)
   202:     v = vwap(highs, lows, closes, vols)
   203:     obv_series = obv(closes, vols)
   204:     obv_rising = obv_series[-1] > obv_series[-2]
   205:     vol_last3 = sum(vols[-3:])
   206:     vol_ma20 = sum(vols[-20:]) / 20.0
   207:     vol_rising = vol_last3 > vol_ma20
   208: 
   209:     macd_val, macd_sig, _ = calc_macd(
   210:         closes, fast=macd_fast, slow=macd_slow, signal=macd_signal
   211:     )
   212: 
   213:     # Multi timeframe filters -------------------------------------------------
   214:     trend_dir = 0  # 1 = long only, -1 = short only, 0 = neutral
   215:     if ohlcv_1h:
   216:         h_closes = [float(x) for x in ohlcv_1h.get("close", [])]
   217:         if len(h_closes) >= 52:
   218:             h_ema50 = ema(h_closes, 50)
   219:             if len(h_ema50) >= 2:
   220:                 slope = h_ema50[-1] - h_ema50[-2]
   221:                 if slope > 0:
   222:                     trend_dir = 1
   223:                 elif slope < 0:
   224:                     trend_dir = -1
   225: 
   226:     rsi_15 = None
   227:     if ohlcv_15m:
   228:         m_closes = [float(x) for x in ohlcv_15m.get("close", [])]
   229:         if len(m_closes) >= 15:
   230:             rsi_15 = calc_rsi(m_closes, 14)
   231: 
   232:     # RSI crossing logic (5m)
   233:     rsi_curr = calc_rsi(closes[-15:], 14)
   234:     rsi_prev = calc_rsi(closes[-16:-1], 14)
   235: 
   236:     atr = calc_atr(highs, lows, closes, 14)
   237:     atr_pct = atr / price * 100.0 if price else 0.0
   238:     if atr_pct < atr_disable_pct:
   239:         return None
   240:     size_mult = 0.5 if atr_pct > atr_reduce_pct else 1.0
   241: 
   242:     sl_dist = 0.5 * atr
   243:     tp1_dist = 1.0 * atr
   244:     tp2_dist = 1.5 * atr
   245: 
   246:     swing_high, swing_low = swing_levels(highs, lows, swing_lookback)
   247: 
   248:     obi_ok_long = obi_ok_short = True
   249:     if order_book is not None:
   250:         bid = float(order_book.get("bid_vol_aggreg", 0))
   251:         ask = float(order_book.get("ask_vol_aggreg", 0))
   252:         obi = order_book_imbalance(bid, ask)
   253:         obi_ok_long = obi > 0.1
   254:         obi_ok_short = obi < -0.1
   255: 
   256:     tick_ok_long = tick_ratio_buy is None or tick_ratio_buy > 0.55
   257:     tick_ok_short = tick_ratio_buy is None or tick_ratio_buy < 0.45
   258: 
   259:     def _size(dist: float) -> float:
   260:         return calc_position_size(equity, risk_pct, dist) * size_mult
   261:     weights = {
   262:         "ema": 15.0,
   263:         "macd": 15.0,
   264:         "vwap": 15.0,
   265:         "rsi": 15.0,
   266:         "obv": 10.0,
   267:         "swing": 10.0,
   268:         "atr": 20.0,
   269:     }
   270: 
   271:     atr_score = min(atr_pct / atr_reduce_pct, 1.0) * weights["atr"]
   272: 
   273:     long_score = atr_score
   274:     long_reasons: List[str] = []
   275:     if price > v:
   276:         long_score += weights["vwap"]
   277:         long_reasons.append("vwap")
   278:     if ema20[-1] > ema50[-1]:
   279:         long_score += weights["ema"]
   280:         long_reasons.append("ema")
   281:     if rsi_prev <= 40 < rsi_curr:
   282:         long_score += weights["rsi"]
   283:         long_reasons.append("rsi")
   284:     if macd_val > macd_sig:
   285:         long_score += weights["macd"]
   286:         long_reasons.append("macd")
   287:     if obv_rising or vol_rising:
   288:         long_score += weights["obv"]
   289:         long_reasons.append("obv")
   290:     if price > swing_high:
   291:         long_score += weights["swing"]
   292:         long_reasons.append("swing")
   293: 
   294:     short_score = atr_score
   295:     short_reasons: List[str] = []
   296:     if price < v:
   297:         short_score += weights["vwap"]
   298:         short_reasons.append("vwap")
   299:     if ema20[-1] < ema50[-1]:
   300:         short_score += weights["ema"]
   301:         short_reasons.append("ema")
   302:     if rsi_prev >= 60 > rsi_curr:
   303:         short_score += weights["rsi"]
   304:         short_reasons.append("rsi")
   305:     if macd_val < macd_sig:
   306:         short_score += weights["macd"]
   307:         short_reasons.append("macd")
   308:     if obv_series[-1] < obv_series[-2] or vol_rising:
   309:         short_score += weights["obv"]
   310:         short_reasons.append("obv")
   311:     if price < swing_low:
   312:         short_score += weights["swing"]
   313:         short_reasons.append("swing")
   314: 
   315:     side: Optional[str] = None
   316:     score: float = 0.0
   317:     reasons: List[str] = []
   318:     if (
   319:         long_score >= short_score
   320:         and long_score > 0
   321:         and macd_val > macd_sig
   322:         and obi_ok_long
   323:         and tick_ok_long
   324:         and trend_dir >= 0
   325:         and price > ema_trend[-1]
   326:     ):
   327:         side = "long"
   328:         score = long_score
   329:         reasons = long_reasons
   330:         sl = price - sl_dist
   331:         tp1 = price + tp1_dist
   332:         tp2 = price + tp2_dist
   333:     elif (
   334:         short_score > long_score
   335:         and short_score > 0
   336:         and macd_val < macd_sig
   337:         and obi_ok_short
   338:         and tick_ok_short
   339:         and trend_dir <= 0
   340:         and price < ema_trend[-1]
   341:     ):
   342:         side = "short"
   343:         score = short_score
   344:         reasons = short_reasons
   345:         sl = price + sl_dist
   346:         tp1 = price - tp1_dist
   347:         tp2 = price - tp2_dist
   348:     else:
   349:         return None
   350: 
   351:     qty = _size(sl_dist)
   352:     return Signal(symbol, side, price, sl, tp1, tp2, qty, score, score, reasons)
   353: 
   354: 
   355: def generate_signal(*args, **kwargs) -> Optional[Signal]:
   356:     if "config" in kwargs:
   357:         config = kwargs.pop("config")
   358:         symbol = kwargs.pop("symbol", None)
   359:         ohlcv = kwargs.pop("ohlcv", None)
   360:         if ohlcv is None:
   361:             raise TypeError("ohlcv argument required")
   362:         return _generate_signal(
   363:             symbol or ohlcv.get("symbol", ""),
   364:             ohlcv,
   365:             equity=kwargs.pop("equity", 0.0),
   366:             risk_pct=getattr(config, "RISK_PCT", 0.0),
   367:             **kwargs,
   368:         )
   369:     return _generate_signal(*args, **kwargs)
   370: 
   371: # ---------------------------------------------------------------------------
   372: # Backtesting utilities
   373: # ---------------------------------------------------------------------------
   374: 
   375: def max_drawdown(equity_curve: Sequence[float]) -> float:
   376:     peak = equity_curve[0]
   377:     mdd = 0.0
   378:     for x in equity_curve:
   379:         if x > peak:
   380:             peak = x
   381:         dd = (peak - x) / peak * 100.0
   382:         if dd > mdd:
   383:             mdd = dd
   384:     return mdd
   385: 
   386: def backtest(
   387:     trades: Sequence[Dict[str, Any]],
   388:     *,
   389:     equity_start: float = 1_000.0,
   390:     fee_rate: float = 0.0,
   391: ) -> Dict[str, float]:
   392:     """Evaluate a list of trade dictionaries.
   393: 
   394:     Each trade must provide ``symbol``, ``entry``, ``exit``, ``side`` and may
   395:     optionally include ``duration`` in minutes.  Results are aggregated into
   396:     common performance metrics to quickly evaluate the strategy.
   397:     """
   398: 
   399:     equity = equity_start
   400:     equity_curve = [equity]
   401:     pnl_pct_list: List[float] = []
   402:     wins = losses = 0
   403:     win_sum = loss_sum = 0.0
   404:     total_duration = 0.0
   405: 
   406:     for t in trades:
   407:         pnl_pct = calc_pnl_pct(t["entry"], t["exit"], t["side"], fee_rate)
   408:         pnl_pct_list.append(pnl_pct)
   409:         if pnl_pct >= 0:
   410:             wins += 1
   411:             win_sum += pnl_pct
   412:         else:
   413:             losses += 1
   414:             loss_sum += pnl_pct
   415:         equity *= 1 + pnl_pct / 100.0
   416:         equity_curve.append(equity)
   417:         total_duration += float(t.get("duration", 0.0))
   418: 
   419:     pnl_pct_total = sum(pnl_pct_list)
   420:     pnl_usdt = equity - equity_start
   421:     profit_factor = (win_sum / abs(loss_sum)) if loss_sum else float("inf")
   422:     winrate = wins / len(trades) * 100.0 if trades else 0.0
   423:     mdd = max_drawdown(equity_curve)
   424:     avg_trade_time = total_duration / len(trades) if trades else 0.0
   425:     exposure = total_duration  # in minutes, callers can normalise if desired
   426:     # Sharpe ratio based on per-trade returns
   427:     if len(pnl_pct_list) > 1:
   428:         mean = sum(pnl_pct_list) / len(pnl_pct_list)
   429:         var = sum((r - mean) ** 2 for r in pnl_pct_list) / (len(pnl_pct_list) - 1)
   430:         sharpe = mean / (var ** 0.5) if var > 0 else 0.0
   431:     else:
   432:         sharpe = 0.0
   433: 
   434:     return {
   435:         "pnl_usdt": pnl_usdt,
   436:         "pnl_pct": pnl_pct_total,
   437:         "profit_factor": profit_factor,
   438:         "winrate": winrate,
   439:         "max_drawdown": mdd,
   440:         "avg_trade_time": avg_trade_time,
   441:         "exposure": exposure,
   442:         "sharpe": sharpe,
   443:     }

--------------------------------------------------------------------------------
FILE: engine/trade_utils.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/trade_utils.py
     2: from __future__ import annotations
     3: 
     4: from typing import Optional
     5: 
     6: 
     7: def compute_position_size(
     8:     equity: float,
     9:     price: float,
    10:     risk_pct: float,
    11:     *,
    12:     symbol: Optional[str] = None,
    13:     min_qty: float = 0.0,
    14:     max_leverage: float = 1.0,
    15: ) -> float:
    16:     """
    17:     Sizing simple: position notionnelle = equity * risk_pct * max_leverage
    18:     qty = notionnel / price
    19:     - min_qty : borne basse éventuelle (0 pour ignorer)
    20:     - max_leverage : si tu veux simuler un levier (1 par défaut)
    21:     """
    22:     equity = float(max(0.0, equity))
    23:     price = float(max(1e-12, price))
    24:     risk_pct = float(max(0.0, risk_pct))
    25:     notionnel = equity * risk_pct * max_leverage
    26:     qty = notionnel / price
    27:     if min_qty > 0 and qty < min_qty:
    28:         return 0.0
    29:     return float(qty)

--------------------------------------------------------------------------------
FILE: engine/version.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Utilities for managing the Scalp bot version."""
     2: 
     3: from __future__ import annotations
     4: 
     5: from pathlib import Path
     6: import re
     7: 
     8: import subprocess
     9: 
    10: 
    11: # Path to the VERSION file within the package
    12: _VERSION_FILE = Path(__file__).resolve().parent / "VERSION"
    13: _VERSION_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
    14: 
    15: 
    16: def get_version() -> str:
    17:     """Return the current version of the bot.
    18: 
    19:     If the VERSION file does not exist the default version ``0.0.0`` is
    20:     returned.
    21:     """
    22:     if not _VERSION_FILE.exists():
    23:         return "0.0.0"
    24:     return _VERSION_FILE.read_text().strip()
    25: 
    26: 
    27: def _parse(version: str) -> tuple[int, int, int]:
    28:     match = _VERSION_RE.match(version)
    29:     if not match:
    30:         raise ValueError(f"Invalid version: {version!r}")
    31:     return tuple(int(x) for x in match.groups())
    32: 
    33: 
    34: def bump_version(part: str = "patch") -> str:
    35:     """Bump the version stored in the VERSION file.
    36: 
    37:     Parameters
    38:     ----------
    39:     part:
    40:         Which component to increment. Accepted values are ``"major"``,
    41:         ``"minor"`` and ``"patch"`` (default).
    42:     """
    43:     major, minor, patch = _parse(get_version())
    44:     if part == "major":
    45:         major += 1
    46:         minor = 0
    47:         patch = 0
    48:     elif part == "minor":
    49:         minor += 1
    50:         patch = 0
    51: 
    52:     elif part == "patch":
    53:         patch += 1
    54:     else:
    55:         raise ValueError(f"Unknown part: {part}")
    56:     new_version = f"{major}.{minor}.{patch}"
    57:     _VERSION_FILE.write_text(f"{new_version}\n")
    58:     return new_version
    59: 
    60: 
    61: def bump_version_from_message(message: str) -> str:
    62:     """Bump the version according to a commit message.
    63: 
    64:     ``message`` is evaluated using a tiny subset of the Conventional
    65:     Commits spec. Messages starting with ``feat`` bump the *minor*
    66:     version, messages whose header ends with ``!`` or contain
    67:     ``BREAKING CHANGE`` bump the *major* version. All other messages
    68:     bump the *patch* component.
    69:     """
    70: 
    71:     header = message.strip().splitlines()[0].lower()
    72:     lower = message.lower()
    73:     type_part = header.split(":")[0]
    74:     if "!" in type_part or "breaking change" in lower:
    75:         part = "major"
    76:     elif type_part.startswith("feat"):
    77:         part = "minor"
    78:     else:
    79:         part = "patch"
    80:     return bump_version(part)
    81: 
    82: 
    83: def bump_version_from_git() -> str:
    84:     """Read the latest git commit message and bump the version accordingly."""
    85:     try:
    86:         message = subprocess.check_output(
    87:             ["git", "log", "-1", "--pretty=%B"], text=True
    88:         ).strip()
    89:     except Exception:
    90:         message = ""
    91:     return bump_version_from_message(message)
    92: 
    93: 
    94: if __name__ == "__main__":
    95:     print(bump_version_from_git())

--------------------------------------------------------------------------------
FILE: engine/ws.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Minimal websocket manager with heartbeat and auto-resubscribe.
     2: 
     3: This module provides a light-weight framework to maintain a realtime
     4: connection to an exchange.  The actual network layer is expected to be
     5: supplied by the caller via ``connect`` and ``subscribe`` callbacks.  The
     6: manager handles retrying failed connections and periodically invoking the
     7: ``subscribe`` callback as a heartbeat.  This keeps the code fully testable
     8: without opening real network sockets.
     9: """
    10: from __future__ import annotations
    11: 
    12: import asyncio
    13: import logging
    14: from typing import Awaitable, Callable, Optional
    15: 
    16: 
    17: class WebsocketManager:
    18:     """Maintain a websocket connection with heartbeat and retry."""
    19: 
    20:     def __init__(
    21:         self,
    22:         connect: Callable[[], Awaitable[None]],
    23:         subscribe: Callable[[], Awaitable[None]],
    24:         *,
    25:         heartbeat_interval: float = 30.0,
    26:         max_retries: int = 3,
    27:     ) -> None:
    28:         self._connect = connect
    29:         self._subscribe = subscribe
    30:         self.heartbeat_interval = heartbeat_interval
    31:         self.max_retries = max_retries
    32:         self._heartbeat_task: Optional[asyncio.Task] = None
    33: 
    34:     async def run(self) -> None:
    35:         """Open the connection retrying on failure."""
    36:         retries = 0
    37:         while True:
    38:             try:
    39:                 await self._connect()
    40:                 await self._subscribe()
    41:                 self._heartbeat_task = asyncio.create_task(self._heartbeat())
    42:                 return
    43:             except Exception as exc:  # pragma: no cover - network errors
    44:                 logging.error("websocket connect failed: %s", exc)
    45:                 retries += 1
    46:                 if retries > self.max_retries:
    47:                     raise
    48:                 await asyncio.sleep(1)
    49: 
    50:     async def _heartbeat(self) -> None:
    51:         """Send periodic heartbeats and resubscribe on failure."""
    52:         while True:
    53:             await asyncio.sleep(self.heartbeat_interval)
    54:             try:
    55:                 await self._subscribe()
    56:             except Exception as exc:  # pragma: no cover - network errors
    57:                 logging.warning("websocket heartbeat failed: %s", exc)
    58:                 await self.run()
    59:                 break
    60: 
    61:     async def stop(self) -> None:
    62:         """Cancel the heartbeat task if it is running."""
    63:         task = self._heartbeat_task
    64:         if task and not task.done():
    65:             task.cancel()
    66:             try:
    67:                 await task
    68:             except BaseException:  # pragma: no cover - cancellation
    69:                 pass
    70:         self._heartbeat_task = None

--------------------------------------------------------------------------------
FILE: init.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: """Install all project dependencies.
     3: 
     4: Run this script once to install every ``requirements*.txt`` file found in the
     5: repository as well as the packages needed for the test suite.  All subsequent
     6: invocations of the bot or its submodules will then share the same Python
     7: environment with the required dependencies available.
     8: """
     9: 
    10: from __future__ import annotations
    11: 
    12: import subprocess
    13: import sys
    14: from pathlib import Path
    15: 
    16: 
    17: def install_packages(*args: str) -> None:
    18:     """Install packages using pip for the current Python interpreter."""
    19:     cmd = [sys.executable, "-m", "pip", "install", *args]
    20:     subprocess.check_call(cmd)
    21: 
    22: 
    23: def main() -> None:
    24:     repo_root = Path(__file__).resolve().parent
    25: 
    26:     # Install from any requirements*.txt file across the repository so that
    27:     # sub-packages with their own dependency lists are also covered.
    28:     for req in sorted(repo_root.rglob("requirements*.txt")):
    29:         install_packages("-r", str(req))
    30: 
    31:     # Ensure test dependencies are available
    32:     install_packages("pytest")
    33: 
    34: 
    35: if __name__ == "__main__":
    36:     main()

--------------------------------------------------------------------------------
FILE: pytest.ini  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: [pytest]
     2: addopts = -q

--------------------------------------------------------------------------------
FILE: requirements-dev.txt  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: pytest

--------------------------------------------------------------------------------
FILE: requirements.txt  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: requests
     2: python-dotenv
     3: pydantic==1.10.15 ; python_version < "3.11"
     4: 
     5: # pydantic v1 déjà pin si environnement ancien
     6: # rien à ajouter ici pour market_data (pas de nouvelle dépendance)

--------------------------------------------------------------------------------
FILE: resultat.log  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: .................................................................................................                        [100%]
     2: 97 passed in 0.42s

--------------------------------------------------------------------------------
FILE: scalper/config/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from .loader import load_settings
     2: __all__ = ['load_settings']

--------------------------------------------------------------------------------
FILE: scalper/config/loader.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalp/config/loader.py
     2: from __future__ import annotations
     3: import os, json
     4: from typing import Any, Dict, Tuple
     5: 
     6: # YAML est recommandé, mais on fallback proprement si PyYAML n'est pas installé
     7: try:
     8:     import yaml  # type: ignore
     9: except Exception:
    10:     yaml = None  # fallback JSON si besoin
    11: 
    12: # dotenv (facultatif) pour charger un .env automatiquement
    13: try:
    14:     from dotenv import load_dotenv  # type: ignore
    15: except Exception:
    16:     load_dotenv = None
    17: 
    18: # ---------------- Utils ----------------
    19: 
    20: def _parse_bool(x: Any, default: bool = False) -> bool:
    21:     if isinstance(x, bool): return x
    22:     s = str(x).strip().lower()
    23:     if s in ("1","true","yes","y","on"): return True
    24:     if s in ("0","false","no","n","off",""): return False
    25:     return default
    26: 
    27: def _parse_float(x: Any, default: float | None = None) -> float | None:
    28:     try: return float(x)
    29:     except Exception: return default
    30: 
    31: def _parse_int(x: Any, default: int | None = None) -> int | None:
    32:     try: return int(str(x).strip())
    33:     except Exception: return default
    34: 
    35: def _parse_csv(x: Any) -> list[str]:
    36:     if x is None: return []
    37:     if isinstance(x, (list, tuple)): return [str(v).strip() for v in x if str(v).strip()]
    38:     return [t.strip() for t in str(x).replace(" ", "").split(",") if t.strip()]
    39: 
    40: def _read_yaml(path: str) -> Dict[str, Any]:
    41:     if not os.path.exists(path): return {}
    42:     with open(path, "r", encoding="utf-8") as f:
    43:         if yaml:
    44:             return yaml.safe_load(f) or {}
    45:         # fallback JSON si quelqu’un met du JSON dans config.yml (rare mais safe)
    46:         try:
    47:             return json.load(f)
    48:         except Exception:
    49:             raise RuntimeError(f"Impossible de lire {path}: installe PyYAML (`pip install pyyaml`) ou fournis du JSON valide.")
    50: 
    51: def _merge_dict(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    52:     # shallow merge suffisant ici (structure plate)
    53:     out = dict(a)
    54:     out.update({k: v for k, v in b.items() if v is not None})
    55:     return out
    56: 
    57: # ---------------- Public API ----------------
    58: 
    59: def load_settings(
    60:     config_path: str = "config.yml",
    61:     config_local_path: str = "config.local.yml",
    62: ) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    63:     """
    64:     Retourne (config_runtime, secrets) :
    65:       - config_runtime : paramètres de stratégie / exécution (OK pour versionner)
    66:       - secrets        : clés API & tokens (NE PAS versionner)
    67:     Priorité : config.yml < config.local.yml < ENV (non sensibles)
    68:     Secrets proviennent EXCLUSIVEMENT de l'ENV (.env)
    69:     """
    70:     # 1) .env (pour secrets & env non sensibles). Faculatif.
    71:     if load_dotenv is not None:
    72:         load_dotenv(override=False)
    73: 
    74:     # 2) Charge YAML (config.yml + override local)
    75:     base = _read_yaml(config_path)
    76:     local = _read_yaml(config_local_path)
    77:     cfg = _merge_dict(base, local)
    78: 
    79:     # 3) Overlay ENV **non sensibles** (permet de surcharger sans toucher au YAML)
    80:     env_overlay: Dict[str, Any] = {}
    81:     # Verbosité
    82:     env_overlay["QUIET"] = _parse_bool(os.getenv("QUIET", cfg.get("QUIET", 0)), bool(cfg.get("QUIET", 0)))
    83:     env_overlay["PRINT_OHLCV_SAMPLE"] = _parse_bool(os.getenv("PRINT_OHLCV_SAMPLE", cfg.get("PRINT_OHLCV_SAMPLE", 0)),
    84:                                                     bool(cfg.get("PRINT_OHLCV_SAMPLE", 0)))
    85:     # Runtime / Stratégie
    86:     env_overlay["TIMEFRAME"] = os.getenv("TIMEFRAME", cfg.get("TIMEFRAME", "5m"))
    87:     env_overlay["CASH"] = _parse_float(os.getenv("CASH", cfg.get("CASH", 10000)), cfg.get("CASH", 10000))
    88:     env_overlay["RISK_PCT"] = _parse_float(os.getenv("RISK_PCT", cfg.get("RISK_PCT", 0.5)), cfg.get("RISK_PCT", 0.5))
    89:     env_overlay["SLIPPAGE_BPS"] = _parse_float(os.getenv("SLIPPAGE_BPS", cfg.get("SLIPPAGE_BPS", 0)), cfg.get("SLIPPAGE_BPS", 0))
    90:     # Watchlist
    91:     env_overlay["WATCHLIST_MODE"] = os.getenv("WATCHLIST_MODE", cfg.get("WATCHLIST_MODE", "static"))
    92:     env_overlay["WATCHLIST_LOCAL_CONC"] = _parse_int(
    93:         os.getenv("WATCHLIST_LOCAL_CONC", cfg.get("WATCHLIST_LOCAL_CONC", 4)), cfg.get("WATCHLIST_LOCAL_CONC", 4)
    94:     )
    95:     env_overlay["TOP_SYMBOLS"] = _parse_csv(os.getenv("TOP_SYMBOLS", cfg.get("TOP_SYMBOLS")))
    96:     env_overlay["TOP_CANDIDATES"] = _parse_csv(os.getenv("TOP_CANDIDATES", cfg.get("TOP_CANDIDATES")))
    97:     # Caps (optionnel) : on accepte YAML (dict) ou ENV JSON
    98:     caps_env = os.getenv("CAPS_JSON")
    99:     if caps_env:
   100:         try:
   101:             env_overlay["CAPS"] = json.loads(caps_env)
   102:         except Exception:
   103:             env_overlay["CAPS"] = cfg.get("CAPS", {})
   104:     else:
   105:         env_overlay["CAPS"] = cfg.get("CAPS", {})
   106: 
   107:     # 4) Secrets UNIQUEMENT via ENV (jamais via YAML)
   108:     secrets = {
   109:         "BITGET_API_KEY": os.getenv("BITGET_API_KEY", ""),
   110:         "BITGET_API_SECRET": os.getenv("BITGET_API_SECRET", ""),
   111:         "BITGET_API_PASSWORD": os.getenv("BITGET_API_PASSWORD", ""),
   112:         "BITGET_USE_TESTNET": _parse_bool(os.getenv("BITGET_USE_TESTNET", os.getenv("BITGET_TESTNET", "1")), True),
   113:         "BITGET_PRODUCT": os.getenv("BITGET_PRODUCT", "umcbl"),
   114:         "TELEGRAM_BOT_TOKEN": os.getenv("TELEGRAM_BOT_TOKEN", ""),
   115:         "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),
   116:     }
   117: 
   118:     # 5) Runtime normalisé pour l’orchestrateur
   119:     runtime = {
   120:         "quiet": bool(env_overlay["QUIET"]),
   121:         "print_sample": bool(env_overlay["PRINT_OHLCV_SAMPLE"]),
   122:         "timeframe": str(env_overlay["TIMEFRAME"]),
   123:         "cash": float(env_overlay["CASH"]),
   124:         "risk_pct": float(env_overlay["RISK_PCT"]),
   125:         "slippage_bps": float(env_overlay["SLIPPAGE_BPS"]),
   126:         "watchlist_mode": str(env_overlay["WATCHLIST_MODE"]),
   127:         "watchlist_local_conc": int(env_overlay["WATCHLIST_LOCAL_CONC"]),
   128:         "top_symbols": env_overlay["TOP_SYMBOLS"],          # list[str]
   129:         "top_candidates": env_overlay["TOP_CANDIDATES"],    # list[str]
   130:         "caps": env_overlay["CAPS"],                        # dict
   131:         # rempli au boot par les frais Bitget
   132:         "fees_by_symbol": {}, 
   133:     }
   134: 
   135:     return runtime, secrets
   136:     

--------------------------------------------------------------------------------
FILE: scalper/config/strategies.yml  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/config/strategies.yml
     2: default: current
     3: by_timeframe:
     4:   "1m": current
     5:   "5m": current
     6:   "15m": current
     7:   "1h": current
     8: by_symbol:
     9:   BTCUSDT:
    10:     "1m": current
    11:     "5m": current
    12:   ETHUSDT:
    13:     "5m": current

--------------------------------------------------------------------------------
FILE: scalper/exchange/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # Rend le sous-package exchanges importable
     2: __all__ = ["bitget"]

--------------------------------------------------------------------------------
FILE: scalper/exchange/bitget.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/exchange/bitget.py
     2: from __future__ import annotations
     3: import os
     4: import requests
     5: from typing import List, Dict, Any
     6: 
     7: BASE_URL = "https://api.bitget.com"
     8: 
     9: # Spot: period strings
    10: _SPOT_PERIOD = {
    11:     "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min", "30m": "30min",
    12:     "1h": "1hour", "4h": "4hour", "6h": "6hour", "12h": "12hour",
    13:     "1d": "1day", "3d": "3day", "1w": "1week",
    14: }
    15: # Mix: granularity seconds
    16: _MIX_GRAN = {
    17:     "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
    18:     "1h": 3600, "4h": 14400, "6h": 21600, "12h": 43200,
    19:     "1d": 86400, "3d": 259200, "1w": 604800,
    20: }
    21: 
    22: def _market_from_symbol(symbol: str) -> str:
    23:     s = symbol.upper()
    24:     if s.endswith("_SPBL"):
    25:         return "spot"
    26:     if s.endswith("_UMCBL"):
    27:         return "umcbl"
    28:     if s.endswith("_DMCBL"):
    29:         return "dmcbl"
    30:     if s.endswith("_CMCBL"):
    31:         return "cmcbl"
    32:     # fallback env / défaut umcbl
    33:     return os.getenv("BITGET_MARKET", "umcbl").lower()
    34: 
    35: def _product_type(market: str) -> str:
    36:     # valeur attendue par les endpoints mix (umcbl/dmcbl/cmcbl)
    37:     if market in ("umcbl", "dmcbl", "cmcbl"):
    38:         return market
    39:     return "umcbl"
    40: 
    41: class BitgetExchange:
    42:     """
    43:     Wrapper simple: get_ohlcv(symbol, timeframe, limit) -> [[ts, o, h, l, c, v], ...]
    44:     symbol spot ex: BTCUSDT_SPBL
    45:     symbol perp ex: BTCUSDT_UMCBL / BTCUSD_DMCBL / BTCUSD_CMCBL
    46:     """
    47:     def __init__(self, api_key: str = "", api_secret: str = "", api_passphrase: str = "", timeout: int = 20) -> None:
    48:         self.session = requests.Session()
    49:         self.session.headers.update({"User-Agent": "scalp-bot/1.0"})
    50:         self.timeout = timeout
    51: 
    52:     def _get(self, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
    53:         url = BASE_URL + path
    54:         r = self.session.get(url, params=params, timeout=self.timeout)
    55:         r.raise_for_status()
    56:         data = r.json()
    57:         # Bitget: {"code":"00000","msg":"success","requestTime":..., "data":[...]}
    58:         if not isinstance(data, dict) or str(data.get("code")) not in ("00000", "0", "200"):
    59:             raise RuntimeError(f"Bitget error payload: {data}")
    60:         return data
    61: 
    62:     def get_ohlcv(self, symbol: str, timeframe: str = "5m", limit: int = 500) -> List[List[float]]:
    63:         timeframe = timeframe.lower()
    64:         mkt = _market_from_symbol(symbol)
    65: 
    66:         if mkt == "spot":
    67:             period = _SPOT_PERIOD.get(timeframe)
    68:             if not period:
    69:                 raise ValueError(f"timeframe spot non supporté: {timeframe}")
    70:             # Bitget spot: limit max souvent 1000
    71:             lim = max(1, min(int(limit), 1000))
    72:             params = {"symbol": symbol, "period": period, "limit": lim}
    73:             data = self._get("/api/spot/v1/market/candles", params=params)
    74:             rows = data.get("data") or []
    75:             out: List[List[float]] = []
    76:             # Bitget renvoie décroissant -> on inverse
    77:             for r in reversed(rows):
    78:                 ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
    79:                 out.append([ts, o, h, l, c, v])
    80:             return out
    81: 
    82:         # MIX (umcbl/dmcbl/cmcbl)
    83:         gran = _MIX_GRAN.get(timeframe)
    84:         if not gran:
    85:             raise ValueError(f"timeframe mix non supporté: {timeframe}")
    86: 
    87:         # Bitget mix: limit max souvent 200, granularity en secondes, productType parfois requis
    88:         lim = max(1, min(int(limit), 200))
    89:         params = {
    90:             "symbol": symbol,
    91:             "granularity": int(gran),
    92:             "limit": lim,
    93:             "productType": _product_type(mkt),
    94:         }
    95: 
    96:         # essais: candles -> history-candles (certaines régions)
    97:         try:
    98:             data = self._get("/api/mix/v1/market/candles", params=params)
    99:         except requests.HTTPError:
   100:             data = self._get("/api/mix/v1/market/history-candles", params=params)
   101: 
   102:         rows = data.get("data") or []
   103:         out: List[List[float]] = []
   104:         for r in reversed(rows):
   105:             ts = int(r[0]); o, h, l, c = map(float, r[1:5]); v = float(r[5])
   106:             out.append([ts, o, h, l, c, v])
   107:         return out

--------------------------------------------------------------------------------
FILE: scalper/exchange/bitget_ccxt.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/exchange/bitget_ccxt.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import csv
     6: import os
     7: import time
     8: from typing import Any, List, Optional
     9: 
    10: # CCXT async
    11: try:
    12:     import ccxt.async_support as ccxt
    13: except Exception as e:  # noqa: BLE001
    14:     raise RuntimeError("CCXT n'est pas installé. Fais `pip install ccxt`.") from e
    15: 
    16: 
    17: def _now_ms() -> int:
    18:     return int(time.time() * 1000)
    19: 
    20: 
    21: class BitgetExchange:
    22:     """
    23:     Échange Bitget via CCXT (async) avec cache CSV local.
    24:     - Orienté SPOT pour simplifier (BTCUSDT, ETHUSDT, ...).
    25:     - fetch_ohlcv(symbol, timeframe, limit) -> list[list] façon CCXT:
    26:         [[ts, open, high, low, close, volume], ...]
    27:     """
    28: 
    29:     def __init__(
    30:         self,
    31:         *,
    32:         api_key: Optional[str] = None,
    33:         secret: Optional[str] = None,
    34:         password: Optional[str] = None,  # Bitget a souvent "password" (API passphrase)
    35:         data_dir: str = "/notebooks/data",
    36:         use_cache: bool = True,
    37:         min_fresh_seconds: int = 0,  # fraicheur minimale requise (0 = on accepte tout)
    38:         spot: bool = True,           # True = SPOT (recommandé ici)
    39:     ) -> None:
    40:         self.data_dir = data_dir
    41:         self.use_cache = use_cache
    42:         self.min_fresh = int(min_fresh_seconds)
    43:         self.spot = spot
    44: 
    45:         os.makedirs(self.data_dir, exist_ok=True)
    46: 
    47:         # Instance CCXT (async)
    48:         self.ex = ccxt.bitget({
    49:             "apiKey": api_key or "",
    50:             "secret": secret or "",
    51:             "password": password or "",
    52:             "enableRateLimit": True,
    53:             # CCXT timeframe natif (pas besoin de rajouter des headers…)
    54:         })
    55: 
    56:         # Pré‑charge les marchés SPOT pour résoudre correctement symboles
    57:         self._markets_task: Optional[asyncio.Task[Any]] = None
    58: 
    59:     async def _ensure_markets(self) -> None:
    60:         if self._markets_task is None:
    61:             self._markets_task = asyncio.create_task(self.ex.load_markets())
    62:         await self._markets_task
    63: 
    64:     # ---------- CSV cache ----------
    65:     def _csv_path(self, symbol: str, timeframe: str) -> str:
    66:         safe = symbol.replace("/", "").replace(":", "")
    67:         return os.path.join(self.data_dir, f"{safe}-{timeframe}.csv")
    68: 
    69:     def _read_cache(self, path: str) -> List[List[float]]:
    70:         if not os.path.exists(path):
    71:             return []
    72:         rows: List[List[float]] = []
    73:         try:
    74:             with open(path, "r", newline="") as f:
    75:                 rd = csv.reader(f)
    76:                 for r in rd:
    77:                     if not r:
    78:                         continue
    79:                     # ts, o, h, l, c, v
    80:                     try:
    81:                         rows.append([
    82:                             int(r[0]),
    83:                             float(r[1]),
    84:                             float(r[2]),
    85:                             float(r[3]),
    86:                             float(r[4]),
    87:                             float(r[5]),
    88:                         ])
    89:                     except Exception:
    90:                         # on ignore les lignes corrompues
    91:                         continue
    92:         except Exception:
    93:             return []
    94:         return rows
    95: 
    96:     def _write_cache(self, path: str, data: List[List[float]]) -> None:
    97:         # On ré‑écrit intégralement (simple et sûr)
    98:         tmp = path + ".tmp"
    99:         with open(tmp, "w", newline="") as f:
   100:             wr = csv.writer(f)
   101:             wr.writerows(data)
   102:         os.replace(tmp, path)
   103: 
   104:     # ---------- API publique pour orchestrateur ----------
   105:     async def fetch_ohlcv(
   106:         self, symbol: str, timeframe: str, limit: int, since: Optional[int] = None
   107:     ) -> List[List[float]]:
   108:         """
   109:         Conformité orchestrateur : signature (symbol, timeframe, limit).
   110:         Retour CCXT OHLCV. Utilise cache si dispo/assez frais, sinon CCXT.
   111:         """
   112:         await self._ensure_markets()
   113: 
   114:         # Bitget (spot) symbol format CCXT: "BTC/USDT"
   115:         ccxt_symbol = symbol.replace("USDT", "/USDT")
   116:         cache_path = self._csv_path(symbol, timeframe)
   117: 
   118:         # 1) Cache
   119:         if self.use_cache:
   120:             cached = self._read_cache(cache_path)
   121:             if cached:
   122:                 # fraicheur = diff entre maintenant et ts dernière bougie
   123:                 last_ts = int(cached[-1][0])
   124:                 if self.min_fresh == 0 or (_now_ms() - last_ts) <= self.min_fresh * 1000:
   125:                     # suffisant => on retourne la fin
   126:                     if len(cached) >= limit:
   127:                         return cached[-limit:]
   128:                     # pas assez, on essaiera de compléter via CCXT plus bas
   129:                 # sinon: on tentera de rafraîchir plus loin
   130: 
   131:         # 2) Remote via CCXT
   132:         # CCXT fetch_ohlcv: since=None, limit=…  (since en ms)
   133:         # On demande 'limit' bougies; si cache partiel, on pourra fusionner ensuite.
   134:         params: dict[str, Any] = {}
   135:         if self.spot is True:
   136:             params["type"] = "spot"  # ccxt bitget accepte 'type' pour certain endpoints
   137: 
   138:         try:
   139:             ohlcv = await self.ex.fetch_ohlcv(ccxt_symbol, timeframe, since=since, limit=limit, params=params)
   140:         except Exception as e:  # noqa: BLE001
   141:             # En cas d’échec remote: si on a du cache, on le renvoie quand même
   142:             cached = self._read_cache(cache_path) if self.use_cache else []
   143:             if cached:
   144:                 return cached[-limit:]
   145:             raise RuntimeError(f"Bitget CCXT fetch_ohlcv failed for {symbol} {timeframe}: {e}") from e
   146: 
   147:         # 3) Merge simple cache + remote et ré‑écrit (sans doublons sur ts)
   148:         if self.use_cache:
   149:             base = self._read_cache(cache_path)
   150:             merged = _merge_ohlcv(base, ohlcv)
   151:             self._write_cache(cache_path, merged)
   152:             # retourne la fin
   153:             return merged[-limit:]
   154: 
   155:         return ohlcv[-limit:]
   156: 
   157:     async def close(self) -> None:
   158:         try:
   159:             await self.ex.close()
   160:         except Exception:
   161:             pass
   162: 
   163: 
   164: def _merge_ohlcv(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
   165:     """
   166:     Fusionne deux listes OHLCV par timestamp, en écrasant a par b sur collision.
   167:     """
   168:     if not a:
   169:         return list(b)
   170:     if not b:
   171:         return list(a)
   172: 
   173:     # index rapide par ts
   174:     by_ts: dict[int, List[float]] = {int(row[0]): row for row in a}
   175:     for row in b:
   176:         by_ts[int(row[0])] = row
   177:     return [by_ts[k] for k in sorted(by_ts)]

--------------------------------------------------------------------------------
FILE: scalper/exchange/fees.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/exchange/fees.py
     2: from __future__ import annotations
     3: 
     4: from typing import Dict, Iterable
     5: 
     6: # Valeurs par défaut (Bitget spot/futures ~ ordre de grandeur ; sera écrasé quand on charge les frais)
     7: DEFAULT_TAKER_BPS = 6    # 0.06%
     8: DEFAULT_MAKER_BPS = 2    # 0.02%
     9: 
    10: # Cache local: symbol -> {"taker_bps": int, "maker_bps": int}
    11: _FEES_BY_SYMBOL: Dict[str, Dict[str, float]] = {}
    12: 
    13: 
    14: def get_fee(symbol: str, kind: str = "taker") -> float:
    15:     """
    16:     Retourne le fee rate (fraction, ex 0.0006) pour 'symbol' et 'kind' ("taker" ou "maker").
    17:     Utilise le cache alimenté par load_bitget_fees(), sinon valeurs par défaut.
    18:     """
    19:     rec = _FEES_BY_SYMBOL.get(symbol, {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS})
    20:     bps = rec["taker_bps"] if kind == "taker" else rec["maker_bps"]
    21:     return float(bps) / 10_000.0
    22: 
    23: 
    24: async def load_bitget_fees(exchange, symbols: Iterable[str]) -> Dict[str, Dict[str, float]]:
    25:     """
    26:     Tente de charger les frais auprès de l'exchange (type ccxt):
    27:       - fetch_trading_fees(symbols) si dispo
    28:       - sinon fetch_trading_fee(symbol) pour chaque symbole
    29:     Remplit le cache _FEES_BY_SYMBOL avec des BPS (entiers).
    30:     """
    31:     symbols = list(symbols)
    32:     fees: Dict[str, Dict[str, float]] = {}
    33: 
    34:     try:
    35:         if hasattr(exchange, "fetch_trading_fees"):
    36:             data = await exchange.fetch_trading_fees(symbols)
    37:             for s in symbols:
    38:                 d = (data or {}).get(s, {}) or {}
    39:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    40:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    41:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    42:         else:
    43:             for s in symbols:
    44:                 try:
    45:                     d = await exchange.fetch_trading_fee(s)
    46:                 except Exception:
    47:                     d = {}
    48:                 taker = float(d.get("taker", DEFAULT_TAKER_BPS / 10_000))
    49:                 maker = float(d.get("maker", DEFAULT_MAKER_BPS / 10_000))
    50:                 fees[s] = {"taker_bps": round(taker * 10_000), "maker_bps": round(maker * 10_000)}
    51:     except Exception:
    52:         # fallback: défauts
    53:         for s in symbols:
    54:             fees[s] = {"taker_bps": DEFAULT_TAKER_BPS, "maker_bps": DEFAULT_MAKER_BPS}
    55: 
    56:     # maj du cache
    57:     _FEES_BY_SYMBOL.update(fees)
    58:     return fees

--------------------------------------------------------------------------------
FILE: scalper/live/__init__.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: __all__ = ["orchestrator", "fetcher", "runner"]

--------------------------------------------------------------------------------
FILE: scalper/live/backtest_telegram.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/live/backtest_telegram.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: import os
     6: from typing import List
     7: 
     8: from engine.backtest import BTCfg, run_multi
     9: from engine.services.utils import safe_call
    10: 
    11: # Exchange CCXT asynchrone pour OHLCV publics (Bitget)
    12: async def _get_exchange():
    13:     try:
    14:         import ccxt.async_support as ccxt  # type: ignore
    15:     except Exception:
    16:         raise RuntimeError("CCXT n'est pas installé. Lance: pip install ccxt")
    17:     return ccxt.bitget()
    18: 
    19: def _parse_symbols(defaults: List[str]) -> List[str]:
    20:     env = os.getenv("BACKTEST_SYMBOLS", "")
    21:     if env.strip():
    22:         return [s.strip().upper() for s in env.split(",") if s.strip()]
    23:     return defaults
    24: 
    25: async def handle_backtest_command(notifier, defaults: List[str], timeframe: str = "5m") -> None:
    26:     """Lancé par l'orchestrateur quand l'utilisateur tape /backtest sur Telegram."""
    27:     symbols = _parse_symbols(defaults)
    28:     cash = float(os.getenv("BT_CASH", "10000"))
    29:     risk = float(os.getenv("BT_RISK_PCT", "0.05"))
    30:     slip = float(os.getenv("BT_SLIPPAGE_BPS", "0.0"))
    31:     limit = int(os.getenv("BT_LIMIT", "1500"))
    32: 
    33:     await notifier.send(
    34:         "🧪 Backtest en cours...\n"
    35:         f"• Symbols: {', '.join(symbols)}\n"
    36:         f"• TF: {timeframe}\n"
    37:         f"• Cash: {cash:,.0f}  • Risk: {risk:0.4f}  • Slippage: {slip:0.1f} bps\n"
    38:         f"• Source: exchange.fetch_ohlcv (adapté) + cache CSV"
    39:     )
    40: 
    41:     async def _run():
    42:         exchange = await _get_exchange()
    43:         try:
    44:             cfg = BTCfg(symbols=symbols, timeframe=timeframe, cash=cash,
    45:                         risk_pct=risk, slippage_bps=slip, limit=limit)
    46:             res = await run_multi(cfg, exchange)
    47:             await notifier.send(f"✅ Backtest terminé. Résultats: `{res['out_dir']}`")
    48:         finally:
    49:             try:
    50:                 await exchange.close()
    51:             except Exception:
    52:                 pass
    53: 
    54:     try:
    55:         await safe_call(_run, label="backtest", max_retry=1)  # 1 tir = si fail on avertit
    56:     except Exception as e:
    57:         await notifier.send(f"⚠️ Backtest : erreur inattendue: {e}")

--------------------------------------------------------------------------------
FILE: scalper/live/commands.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/live/commands.py
     2: from __future__ import annotations
     3: 
     4: import asyncio
     5: from typing import Awaitable, Callable
     6: 
     7: 
     8: class CommandHandler:
     9:     """
    10:     Gère les commandes reçues d'un CommandStream (Telegram ou Null).
    11:     Chaque commande est routée vers un callback approprié.
    12:     Les erreurs de callbacks sont capturées pour ne pas tuer l'orchestrateur.
    13:     """
    14: 
    15:     def __init__(self, notifier, command_stream, status_getter, status_sender):
    16:         self.notifier = notifier
    17:         self.stream = command_stream
    18:         self.status_getter = status_getter
    19:         self.status_sender = status_sender
    20: 
    21:     async def _safe_call(self, coro: Awaitable[None], err_msg: str) -> None:
    22:         try:
    23:             await coro
    24:         except Exception as e:
    25:             try:
    26:                 await self.notifier.send(f"⚠️ {err_msg}: {e}")
    27:             except Exception:
    28:                 pass  # on ne propage jamais
    29: 
    30:     async def run(
    31:         self,
    32:         on_pause: Callable[[], None],
    33:         on_resume: Callable[[], None],
    34:         on_stop: Callable[[], Awaitable[None]] | None,
    35:         on_setup_apply: Callable[[dict], None],
    36:         on_backtest: Callable[[str], Awaitable[None]] | None = None,
    37:     ):
    38:         """
    39:         Boucle asynchrone qui lit les lignes du CommandStream
    40:         et exécute le callback approprié.
    41:         TOUTE exception de callback est absorbée pour ne pas terminer cette task.
    42:         """
    43:         async for line in self.stream:
    44:             txt = (line or "").strip()
    45:             if not txt:
    46:                 continue
    47: 
    48:             try:
    49:                 if txt.startswith("/pause"):
    50:                     on_pause()
    51:                     await self.notifier.send("⏸️ Pause.")
    52: 
    53:                 elif txt.startswith("/resume"):
    54:                     on_resume()
    55:                     await self.notifier.send("▶️ Resume.")
    56: 
    57:                 elif txt.startswith("/stop"):
    58:                     if on_stop:
    59:                         await self._safe_call(on_stop(), "Arrêt échoué")
    60: 
    61:                 elif txt.startswith("/status"):
    62:                     snap = self.status_getter()
    63:                     await self.notifier.send(f"ℹ️ {snap}")
    64: 
    65:                 elif txt.startswith("/setup"):
    66:                     await self.notifier.send("🧩 Setup wizard à compléter.")
    67: 
    68:                 elif txt.startswith("/backtest"):
    69:                     if on_backtest:
    70:                         tail = txt[len("/backtest"):].strip()
    71:                         # IMPORTANT : on ne bloque PAS la boucle de commandes.
    72:                         asyncio.create_task(self._safe_call(
    73:                             on_backtest(tail), "Backtest échoué"
    74:                         ))
    75:                         await self.notifier.send("🧪 Backtest lancé en tâche de fond.")
    76:                     else:
    77:                         await self.notifier.send("⚠️ Backtest non disponible.")
    78: 
    79:                 else:
    80:                     await self.notifier.send(
    81:                         "❓ Commandes: /status /pause /resume /stop /setup /backtest"
    82:                     )
    83: 
    84:             except Exception as e:
    85:                 # On protège la boucle quoi qu'il arrive
    86:                 try:
    87:                     await self.notifier.send(f"⚠️ Erreur commande: {e}")
    88:                 except Exception:
    89:                     pass

--------------------------------------------------------------------------------
FILE: scalper/live/data_utils.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/live/data_utils.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Sequence
     4: 
     5: Cols = ("timestamp", "open", "high", "low", "close", "volume")
     6: 
     7: def ohlcv_rows_to_dict(rows: Sequence[Sequence[float]]) -> Dict[str, List[float]]:
     8:     """
     9:     Convertit [[ts,o,h,l,c,v], ...] -> dict de listes.
    10:     Tolère float|int|str numériques.
    11:     """
    12:     out: Dict[str, List[float]] = {k: [] for k in Cols}
    13:     for r in rows:
    14:         if len(r) < 6:
    15:             raise ValueError("Ligne OHLCV invalide (6 colonnes attendues).")
    16:         out["timestamp"].append(float(r[0]))
    17:         out["open"].append(float(r[1]))
    18:         out["high"].append(float(r[2]))
    19:         out["low"].append(float(r[3]))
    20:         out["close"].append(float(r[4]))
    21:         out["volume"].append(float(r[5]))
    22:     return out
    23: 
    24: def ohlcv_df_or_dict_to_dict(obj) -> Dict[str, List[float]]:
    25:     """
    26:     Accepte:
    27:       - pandas.DataFrame avec colonnes Cols
    28:       - dict de listes
    29:     """
    30:     if hasattr(obj, "columns"):
    31:         missing = [c for c in Cols if c not in obj.columns]
    32:         if missing:
    33:             raise ValueError(f"Colonnes OHLCV manquantes: {missing}")
    34:         return {k: [float(x) for x in obj[k].tolist()] for k in Cols}
    35:     if isinstance(obj, dict):
    36:         missing = [c for c in Cols if c not in obj]
    37:         if missing:
    38:             raise ValueError(f"Clés OHLCV manquantes: {missing}")
    39:         return {k: [float(x) for x in obj[k]] for k in Cols}
    40:     raise TypeError("Format OHLCV non supporté (DataFrame ou dict attendu).")
    41: 
    42: def map_index_secondary(ts_main: float, ts_arr: List[float]) -> int:
    43:     """
    44:     Retourne l'index i du timestamp secondaire le plus proche
    45:     inférieur/égal à ts_main. Recherche linéaire suffisante en live.
    46:     """
    47:     j = 0
    48:     n = len(ts_arr)
    49:     while j + 1 < n and ts_arr[j + 1] <= ts_main:
    50:         j += 1
    51:     return j

--------------------------------------------------------------------------------
FILE: scalper/live/fetcher.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalper/live/fetcher.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional, Any
     4: 
     5: class DataFetcher:
     6:     """
     7:     Récupération OHLCV depuis un client d'exchange.
     8:     Compatible:
     9:       - Wrapper custom: client.get_ohlcv(symbol, timeframe, limit)
    10:       - ccxt direct:    client.fetch_ohlcv(symbol, timeframe=..., limit=...)
    11:     Retour standardisé: dict[str, list[float]] avec clés:
    12:       timestamp, open, high, low, close, volume
    13:     """
    14:     def __init__(self, client: Any) -> None:
    15:         self.client = client
    16:         # Détection des méthodes disponibles
    17:         self._has_get = hasattr(client, "get_ohlcv")
    18:         self._has_fetch = hasattr(client, "fetch_ohlcv")
    19: 
    20:         if not (self._has_get or self._has_fetch):
    21:             raise AttributeError(
    22:                 "Le client exchange doit exposer get_ohlcv(...) ou fetch_ohlcv(...). "
    23:                 "Ex: wrapper custom ou objet ccxt.bitget."
    24:             )
    25: 
    26:     @staticmethod
    27:     def _to_dict(rows: List[List[float]]) -> Dict[str, List[float]]:
    28:         cols = ("timestamp", "open", "high", "low", "close", "volume")
    29:         out = {k: [] for k in cols}
    30:         for r in rows:
    31:             # rows: [ts, open, high, low, close, volume]
    32:             out["timestamp"].append(float(r[0]))
    33:             out["open"].append(float(r[1]))
    34:             out["high"].append(float(r[2]))
    35:             out["low"].append(float(r[3]))
    36:             out["close"].append(float(r[4]))
    37:             out["volume"].append(float(r[5]))
    38:         return out
    39: 
    40:     def fetch(self, symbol: str, timeframe: str, limit: int = 1500) -> Dict[str, List[float]]:
    41:         if self._has_get:
    42:             rows = self.client.get_ohlcv(symbol=symbol, timeframe=timeframe, limit=limit)
    43:         else:
    44:             # ccxt: fetch_ohlcv(symbol, timeframe=..., limit=...)
    45:             rows = self.client.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    46:         return self._to_dict(rows)
    47: 
    48:     def try_fetch_1h(self, symbol: str, limit: int = 1500) -> Optional[Dict[str, List[float]]]:
    49:         try:
    50:             if self._has_get:
    51:                 rows = self.client.get_ohlcv(symbol=symbol, timeframe="1h", limit=limit)
    52:             else:
    53:                 rows = self.client.fetch_ohlcv(symbol, timeframe="1h", limit=limit)
    54:             return self._to_dict(rows)
    55:         except Exception:
    56:             return None

--------------------------------------------------------------------------------
FILE: scalper/live/journal.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import os, csv
     3: from typing import Any, Dict, List
     4: 
     5: class LogWriter:
     6:     """Gestion simple des CSV (création à la volée + append)."""
     7:     def __init__(self, dirpath: str) -> None:
     8:         self.dir = dirpath
     9:         os.makedirs(self.dir, exist_ok=True)
    10: 
    11:     def init(self, fname: str, headers: List[str]) -> None:
    12:         p = os.path.join(self.dir, fname)
    13:         if not os.path.exists(p):
    14:             with open(p, "w", newline="", encoding="utf-8") as f:
    15:                 csv.DictWriter(f, fieldnames=headers).writeheader()
    16: 
    17:     def row(self, fname: str, row: Dict[str, Any]) -> None:
    18:         p = os.path.join(self.dir, fname)
    19:         with open(p, "a", newline="", encoding="utf-8") as f:
    20:             csv.DictWriter(f, fieldnames=list(row.keys())).writerow(row)

--------------------------------------------------------------------------------
FILE: scalper/live/logs.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalp/live/logs.py
     2: from __future__ import annotations
     3: import os, csv
     4: from typing import Any, List, Dict
     5: 
     6: class CsvLog:
     7:     def __init__(self, path: str, headers: List[str]):
     8:         self.path = path
     9:         self.headers = headers
    10:         self._ensure_header()
    11: 
    12:     def _ensure_header(self):
    13:         must_write = not os.path.exists(self.path) or os.path.getsize(self.path) == 0
    14:         os.makedirs(os.path.dirname(self.path), exist_ok=True)
    15:         if must_write:
    16:             with open(self.path, "w", newline="") as f:
    17:                 csv.writer(f).writerow(self.headers)
    18: 
    19:     def write_row(self, row: Dict[str, Any]):
    20:         with open(self.path, "a", newline="") as f:
    21:             w = csv.DictWriter(f, fieldnames=self.headers)
    22:             w.writerow({k: row.get(k, "") for k in self.headers})

--------------------------------------------------------------------------------
FILE: scalper/live/loops/trade.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # scalp/live/loops/trade.py
     2: from __future__ import annotations
     3: import asyncio, os
     4: from dataclasses import dataclass, field
     5: from typing import Any, Dict, List, Callable
     6: 
     7: from ...services.utils import safe_call
     8: from ...risk.manager import compute_size
     9: 
    10: QUIET = int(os.getenv("QUIET", "0") or "0")
    11: PRINT_OHLCV_SAMPLE = int(os.getenv("PRINT_OHLCV_SAMPLE", "0") or "0")
    12: 
    13: class PositionFSM:
    14:     def __init__(self):
    15:         self.state = "FLAT"
    16:         self.side = "flat"
    17:         self.entry = 0.0
    18:         self.qty = 0.0
    19:     def can_open(self): return self.state == "FLAT"
    20:     def on_open(self, side, entry, qty): self.state, self.side, self.entry, self.qty = "OPEN", side, entry, qty
    21:     def can_close(self): return self.state == "OPEN"
    22:     def on_close(self): self.state, self.side, self.entry, self.qty = "FLAT", "flat", 0.0, 0.0
    23: 
    24: @dataclass
    25: class SymbolContext:
    26:     symbol: str
    27:     timeframe: str
    28:     ohlcv: List[List[float]] = field(default_factory=list)
    29:     ticks: int = 0
    30:     fsm: PositionFSM = field(default_factory=PositionFSM)
    31: 
    32: class TradeLoop:
    33:     """
    34:     Boucle par symbole, indépendante de l'orchestrateur.
    35:     """
    36:     def __init__(
    37:         self,
    38:         symbol: str,
    39:         timeframe: str,
    40:         ohlcv_fetch: Callable[..., Any],           # async fn(symbol, timeframe, limit) -> ohlcv
    41:         order_market: Callable[..., Any],          # async fn(symbol, side, qty) -> order dict
    42:         generate_signal: Callable[[List[List[float]], Dict[str, Any]], Dict[str, Any]],
    43:         config: Dict[str, Any],
    44:         mode_getter: Callable[[], str],
    45:         log_signals, log_orders, log_fills,
    46:         tick_counter_add: Callable[[int], None],
    47:     ):
    48:         self.symbol = symbol
    49:         self.timeframe = timeframe
    50:         self.fetch = ohlcv_fetch
    51:         self.order_market = order_market
    52:         self.generate_signal = generate_signal
    53:         self.config = config
    54:         self.get_mode = mode_getter
    55:         self.log_signals = log_signals
    56:         self.log_orders = log_orders
    57:         self.log_fills = log_fills
    58:         self.ctx = SymbolContext(symbol, timeframe)
    59:         self._tick_add = tick_counter_add
    60: 
    61:         # Risk/frais
    62:         self.risk_pct = float(self.config.get("risk_pct", 0.5))
    63:         self.caps_by_symbol = self.config.get("caps", {})  # dict optionnel
    64:         self.fees_map = self.config.get("fees_by_symbol", {})  # {sym: {"maker_bps":..., "taker_bps":...}}
    65:         self.slippage_bps = float(self.config.get("slippage_bps", 0.0))
    66: 
    67:     def _bps_for(self, order_type: str = "market") -> float:
    68:         # market -> taker; limit post-only -> maker
    69:         per = self.fees_map.get(self.symbol, {})
    70:         if order_type == "limit":
    71:             return float(per.get("maker_bps", 0.0))
    72:         return float(per.get("taker_bps", 0.0))
    73: 
    74:     async def run(self, running: Callable[[], bool]):
    75:         lookback = 200
    76:         while running():
    77:             if self.get_mode() != "RUNNING":
    78:                 await asyncio.sleep(0.5); continue
    79: 
    80:             async def _fetch():
    81:                 return await self.fetch(self.symbol, timeframe=self.timeframe, limit=lookback+2)
    82:             ohlcv = await safe_call(_fetch, label=f"fetch_ohlcv:{self.symbol}")
    83:             if not ohlcv or len(ohlcv) < lookback+1:
    84:                 await asyncio.sleep(1.0); continue
    85: 
    86:             self.ctx.ohlcv = ohlcv
    87:             self.ctx.ticks += 1
    88:             self._tick_add(1)
    89: 
    90:             window = ohlcv[-(lookback+1):]
    91:             ts, _o, _h, _l, c, _v = window[-1]
    92: 
    93:             try:
    94:                 sig = self.generate_signal(window, self.config) or {}
    95:             except Exception as e:
    96:                 if not QUIET:
    97:                     print(f"[trade:{self.symbol}] generate_signal error: {e}", flush=True)
    98:                 await asyncio.sleep(0.5); continue
    99: 
   100:             side = sig.get("side","flat"); entry = float(sig.get("entry", c)); sl = sig.get("sl"); tp = sig.get("tp")
   101:             self.log_signals.write_row({"ts": ts, "symbol": self.symbol, "side": side, "entry": entry, "sl": sl, "tp": tp, "last": c})
   102: 
   103:             # --- Entrée (market -> taker)
   104:             if self.ctx.fsm.state == "FLAT" and side in ("long","short"):
   105:                 balance = float(self.config.get("cash", 10_000.0))
   106:                 qty = compute_size(
   107:                     symbol=self.symbol, price=entry or c, balance_cash=balance,
   108:                     risk_pct=self.risk_pct, caps_by_symbol=self.caps_by_symbol
   109:                 )
   110:                 if qty > 0:
   111:                     async def _place():
   112:                         return await self.order_market(self.symbol, side, qty)
   113:                     order = await safe_call(_place, label=f"order:{self.symbol}")
   114:                     self.ctx.fsm.on_open(side, entry or c, qty)
   115:                     self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": side, "qty": qty,
   116:                                                "status": "placed", "order_id": (order or {}).get("id",""), "note": f"entry taker={self._bps_for('market')}bps"})
   117: 
   118:             # --- Sortie (market -> taker)
   119:             elif self.ctx.fsm.state == "OPEN" and (side == "flat" or (side in ("long","short") and side != self.ctx.fsm.side)):
   120:                 qty = self.ctx.fsm.qty
   121:                 exit_side = "sell" if self.ctx.fsm.side == "long" else "buy"
   122:                 async def _close():
   123:                     return await self.order_market(self.symbol, exit_side, qty)
   124:                 order = await safe_call(_close, label=f"close:{self.symbol}")
   125: 
   126:                 # fill avec slippage + frais (taker)
   127:                 price_fill = float(c)
   128:                 price_fill *= (1 + (self.slippage_bps/10000.0)) if exit_side == "buy" else (1 - (self.slippage_bps/10000.0))
   129:                 self.log_orders.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "qty": qty,
   130:                                            "status": "placed", "order_id": (order or {}).get("id",""), "note": f"exit taker={self._bps_for('market')}bps"})
   131:                 self.log_fills.write_row({"ts": ts, "symbol": self.symbol, "side": exit_side, "price": price_fill, "qty": qty,
   132:                                           "order_id": (order or {}).get("id","")})
   133:                 self.ctx.fsm.on_close()
   134: 
   135:             if PRINT_OHLCV_SAMPLE and (self.ctx.ticks % 20 == 0) and not QUIET:
   136:                 print(f"[{self.symbol}] last={c} ticks={self.ctx.ticks}", flush=True)
   137: 
   138:             await asyncio.sleep(0.1 if QUIET else 0.01)

--------------------------------------------------------------------------------
FILE: scalper/live/notify.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: from __future__ import annotations
     3: import os
     4: import asyncio
     5: from dataclasses import dataclass
     6: from typing import AsyncIterator, Optional
     7: 
     8: 
     9: @dataclass
    10: class BaseNotifier:
    11:     async def send(self, text: str) -> None:  # pragma: no cover
    12:         print(text)
    13: 
    14: 
    15: class NullNotifier(BaseNotifier):
    16:     pass
    17: 
    18: 
    19: class TelegramNotifier(BaseNotifier):
    20:     def __init__(self, token: str, chat_id: str, session: Optional[asyncio.AbstractEventLoop]=None):
    21:         import aiohttp  # lazy
    22:         self._token = token
    23:         self._chat = chat_id
    24:         self._session: aiohttp.ClientSession | None = None
    25: 
    26:     async def _ensure(self):
    27:         import aiohttp
    28:         if self._session is None or self._session.closed:
    29:             self._session = aiohttp.ClientSession()
    30: 
    31:     async def send(self, text: str) -> None:
    32:         import aiohttp
    33:         await self._ensure()
    34:         # pas de markdown pour éviter les erreurs 400 de parsing
    35:         url = f"https://api.telegram.org/bot{self._token}/sendMessage"
    36:         payload = {"chat_id": self._chat, "text": text, "disable_web_page_preview": True}
    37:         try:
    38:             async with self._session.post(url, json=payload, timeout=20) as r:
    39:                 await r.text()  # on ignore la réponse pour rester simple
    40:         except Exception:
    41:             # on fait un fallback silencieux pour ne pas casser le bot
    42:             print("[notify:telegram] send fail (ignored)")
    43: 
    44:     async def close(self):
    45:         if self._session and not self._session.closed:
    46:             await self._session.close()
    47: 
    48: 
    49: class _NullCommands:
    50:     """Itérateur async vide utilisé quand Telegram n'est pas configuré."""
    51:     def __aiter__(self) -> AsyncIterator[str]:
    52:         return self
    53:     async def __anext__(self) -> str:
    54:         await asyncio.sleep(3600)  # jamais
    55:         raise StopAsyncIteration
    56: 
    57: 
    58: async def build_notifier_and_commands(config: dict) -> tuple[BaseNotifier, AsyncIterator[str]]:
    59:     """
    60:     Retourne (notifier, command_stream).
    61: 
    62:     - Si TELEGRAM_BOT_TOKEN et TELEGRAM_CHAT_ID sont présents: TelegramNotifier,
    63:       et un flux (vide) – l’orchestreur n’en a besoin que si on implémente des
    64:       commandes interactives plus tard.
    65:     - Sinon: NullNotifier + flux vide.
    66:     """
    67:     token = os.getenv("TELEGRAM_BOT_TOKEN")
    68:     chat = os.getenv("TELEGRAM_CHAT_ID")
    69:     if token and chat:
    70:         print("[notify] TELEGRAM configured.")
    71:         return TelegramNotifier(token, chat), _NullCommands()
    72:     print("[notify] TELEGRAM not configured -> Null notifier will be used.")
    73:     return NullNotifier(), _NullCommands()

--------------------------------------------------------------------------------
FILE: scalper/live/ohlcv_service.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import time
     3: from typing import Any, Dict, List, Optional
     4: 
     5: try:
     6:     from engine.adapters.market_data import MarketData
     7: except Exception:
     8:     MarketData = None  # type: ignore
     9: 
    10: class OhlcvService:
    11:     """Lecture/normalisation OHLCV avec fallback agressifs."""
    12:     def __init__(self, exchange) -> None:
    13:         self.exchange = exchange
    14:         self.md = MarketData(exchange) if MarketData is not None else None
    15: 
    16:     @staticmethod
    17:     def normalize_rows(rows: Any) -> List[Dict[str, float]]:
    18:         out: List[Dict[str, float]] = []
    19:         if not rows: return out
    20:         for r in rows:
    21:             if isinstance(r, dict):
    22:                 ts = int(r.get("ts") or r.get("time") or r.get("timestamp") or 0)
    23:                 o = float(r.get("open", 0.0)); h = float(r.get("high", o)); l = float(r.get("low", o)); c = float(r.get("close", o))
    24:                 v = float(r.get("volume", r.get("vol", 0.0)))
    25:             else:
    26:                 rr = list(r)
    27:                 if len(rr) >= 6 and isinstance(rr[0], (int, float)) and rr[0] > 10**10:
    28:                     ts, o, h, l, c = int(rr[0]), float(rr[1]), float(rr[2]), float(rr[3]), float(rr[4]); v = float(rr[5])
    29:                 else:
    30:                     o = float(rr[0]) if len(rr) > 0 else 0.0
    31:                     h = float(rr[1]) if len(rr) > 1 else o
    32:                     l = float(rr[2]) if len(rr) > 2 else o
    33:                     c = float(rr[3]) if len(rr) > 3 else o
    34:                     v = float(rr[4]) if len(rr) > 4 else 0.0
    35:                     ts = int(rr[5]) if len(rr) > 5 else 0
    36:             out.append({"ts": ts, "open": o, "high": h, "low": l, "close": c, "volume": v})
    37:         return out
    38: 
    39:     async def fetch_once(self, symbol: str, interval: str = "1m", limit: int = 100) -> List[Dict[str, float]]:
    40:         # 1) MarketData (si dispo)
    41:         if self.md is not None:
    42:             try:
    43:                 d = self.md.get_ohlcv(symbol, interval, limit)
    44:                 if isinstance(d, dict) and d.get("success") and d.get("data"):
    45:                     return self.normalize_rows(d["data"])
    46:             except Exception:
    47:                 pass
    48: 
    49:         # 2) Exchange natif
    50:         rows: List[Any] = []
    51:         try:
    52:             data = self.exchange.get_kline(symbol, interval=interval)
    53:         except Exception:
    54:             data = None
    55: 
    56:         if isinstance(data, dict):
    57:             rows = (
    58:                 data.get("data") or data.get("result") or data.get("records") or
    59:                 data.get("list") or data.get("items") or data.get("candles") or []
    60:             )
    61:             guard = 0
    62:             while isinstance(rows, dict) and guard < 3:
    63:                 rows = (
    64:                     rows.get("data") or rows.get("result") or rows.get("records") or
    65:                     rows.get("list") or rows.get("items") or rows.get("candles") or rows.get("klines") or rows.get("bars") or []
    66:                 )
    67:                 guard += 1
    68:         elif isinstance(data, (list, tuple)):
    69:             rows = list(data)
    70: 
    71:         out = self.normalize_rows(rows)[-limit:]
    72:         if out: return out
    73: 
    74:         # 3) Fallback strict via ticker -> bougie synthétique
    75:         try:
    76:             tkr = self.exchange.get_ticker(symbol)
    77:             items = []
    78:             if isinstance(tkr, dict): items = tkr.get("data") or tkr.get("result") or tkr.get("tickers") or []
    79:             elif isinstance(tkr, (list, tuple)): items = list(tkr)
    80:             if items:
    81:                 last = items[0]
    82:                 if isinstance(last, dict):
    83:                     p = float(last.get("lastPrice", last.get("close", last.get("markPrice", 0.0))))
    84:                     v = float(last.get("volume", last.get("usdtVolume", last.get("quoteVolume", 0.0))))
    85:                 else:
    86:                     seq = list(last); p = float(seq[3] if len(seq) > 3 else seq[-2]); v = float(seq[4] if len(seq) > 4 else seq[-1])
    87:                 ts = int(time.time()*1000)
    88:                 return [{"ts": ts, "open": p, "high": p, "low": p, "close": p, "volume": v}]
    89:         except Exception:
    90:             pass
    91:         return []

--------------------------------------------------------------------------------
FILE: scalper/live/orchestrator.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/live/orchestrator.py
     2: from __future__ import annotations
     3: import time
     4: from typing import List, Tuple, Dict, Any
     5: from engine.live.fetcher import DataFetcher
     6: from engine.live.runner import JobRunner
     7: 
     8: class Orchestrator:
     9:     def __init__(
    10:         self,
    11:         *,
    12:         exchange_client: Any,
    13:         strategies_cfg: Dict[str, Any],
    14:         jobs: List[Tuple[str, str]],   # [(symbol, timeframe)]
    15:         interval_sec: int = 60,
    16:         equity: float = 1000.0,
    17:         risk_pct: float = 0.01,
    18:     ) -> None:
    19:         self.fetcher = DataFetcher(exchange_client)
    20:         self.runner = JobRunner(strategies_cfg, equity, risk_pct)
    21:         self.jobs = [(s.upper(), tf) for s, tf in jobs]
    22:         self.interval = max(5, int(interval_sec))
    23: 
    24:     def _tick(self) -> None:
    25:         for symbol, tf in self.jobs:
    26:             try:
    27:                 data = self.fetcher.fetch(symbol, tf)
    28:                 data_1h = self.fetcher.try_fetch_1h(symbol)
    29:                 sig = self.runner.run_once(symbol=symbol, timeframe=tf, ohlcv=data, ohlcv_1h=data_1h)
    30:                 if sig is None:
    31:                     print(f"[{symbol}/{tf}] Aucun signal.")
    32:                 else:
    33:                     d = sig.as_dict()
    34:                     print(f"[{symbol}/{tf}] side={d['side']} entry={d['entry']:.6f} "
    35:                           f"sl={d['sl']:.6f} tp1={d['tp1']:.6f} tp2={d['tp2']:.6f} "
    36:                           f"score={d['score']} q={d['quality']:.2f} :: {d.get('reasons','')}")
    37:             except Exception as e:
    38:                 print(f"[{symbol}/{tf}] ERREUR: {e}")
    39: 
    40:     def loop(self) -> None:
    41:         print(f"[Orchestrator] jobs={self.jobs} interval={self.interval}s")
    42:         while True:
    43:             t0 = time.time()
    44:             self._tick()
    45:             dt = time.time() - t0
    46:             time.sleep(max(0.0, self.interval - dt))

--------------------------------------------------------------------------------
FILE: scalper/live/orders.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # live/orders.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Any, Optional
     5: 
     6: from engine.services.order_service import OrderService, OrderRequest
     7: 
     8: @dataclass
     9: class OrderResult:
    10:     accepted: bool
    11:     order_id: str | None = None
    12:     status: str | None = None
    13:     reason: str | None = None
    14: 
    15: class OrderExecutor:
    16:     """
    17:     Fine couche autour d'OrderService + exchange :
    18:       - calcule l'équité USDT
    19:       - place une entrée (risk_pct)
    20:       - récupère les fills (normalisés)
    21:     L'orchestrateur n’appelle plus OrderService directement.
    22:     """
    23: 
    24:     def __init__(self, order_service: OrderService, exchange: Any, config: Any) -> None:
    25:         self.order_service = order_service
    26:         self.exchange = exchange
    27:         self.config = config
    28: 
    29:     # ---------- Equity ----------
    30:     def get_equity_usdt(self) -> float:
    31:         equity = 0.0
    32:         try:
    33:             assets = self.exchange.get_assets()
    34:             if isinstance(assets, dict):
    35:                 for a in (assets.get("data") or []):
    36:                     if str(a.get("currency")).upper() == "USDT":
    37:                         equity = float(a.get("equity", 0.0))
    38:                         break
    39:         except Exception:
    40:             pass
    41:         return equity
    42: 
    43:     # ---------- Entrée ----------
    44:     def place_entry(self, *, symbol: str, side: str, price: float,
    45:                     sl: float | None, tp: float | None, risk_pct: float) -> OrderResult:
    46:         """
    47:         side: 'long' | 'short'
    48:         Retourne OrderResult(accepted, order_id, status, reason)
    49:         """
    50:         equity = self.get_equity_usdt()
    51:         req = OrderRequest(symbol=symbol, side=side, price=float(price),
    52:                            sl=(float(sl) if sl else None), tp=(float(tp) if tp else None),
    53:                            risk_pct=float(risk_pct))
    54:         try:
    55:             res = self.order_service.prepare_and_place(equity, req)
    56:             return OrderResult(accepted=bool(getattr(res, "accepted", False)),
    57:                                order_id=getattr(res, "order_id", None),
    58:                                status=getattr(res, "status", None),
    59:                                reason=getattr(res, "reason", None))
    60:         except Exception as e:
    61:             return OrderResult(accepted=False, reason=str(e))
    62: 
    63:     # ---------- Fills ----------
    64:     def fetch_fills(self, symbol: str, order_id: str | None, limit: int = 50) -> list[dict]:
    65:         """
    66:         Normalise le format en liste de dicts {orderId, tradeId, price, qty, fee}
    67:         """
    68:         try:
    69:             raw = self.exchange.get_fills(symbol, order_id, limit)
    70:         except Exception:
    71:             return []
    72: 
    73:         items: list = []
    74:         if isinstance(raw, dict):
    75:             items = raw.get("data") or raw.get("result") or raw.get("fills") or []
    76:         elif isinstance(raw, (list, tuple)):
    77:             items = list(raw)
    78: 
    79:         out: list[dict] = []
    80:         for f in items:
    81:             if isinstance(f, dict):
    82:                 out.append({
    83:                     "orderId": f.get("orderId") or f.get("order_id") or "",
    84:                     "tradeId": f.get("tradeId") or f.get("trade_id") or "",
    85:                     "price": float(f.get("price", f.get("fillPrice", 0.0)) or 0.0),
    86:                     "qty": float(f.get("qty", f.get("size", f.get("fillQty", 0.0))) or 0.0),
    87:                     "fee": float(f.get("fee", f.get("fillFee", 0.0)) or 0.0),
    88:                 })
    89:             else:
    90:                 try:
    91:                     seq = list(f)
    92:                     out.append({
    93:                         "orderId": str(seq[0]) if seq else "",
    94:                         "tradeId": str(seq[1]) if len(seq) > 1 else "",
    95:                         "price": float(seq[2]) if len(seq) > 2 else 0.0,
    96:                         "qty": float(seq[3]) if len(seq) > 3 else 0.0,
    97:                         "fee": float(seq[4]) if len(seq) > 4 else 0.0,
    98:                     })
    99:                 except Exception:
   100:                     continue
   101:         return out

--------------------------------------------------------------------------------
FILE: scalper/live/position_fsm.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # live/position_fsm.py
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import Optional, Dict, Any, List
     5: 
     6: 
     7: STATE_FLAT = "FLAT"
     8: STATE_PENDING_ENTRY = "PENDING_ENTRY"
     9: STATE_OPEN = "OPEN"
    10: STATE_PENDING_EXIT = "PENDING_EXIT"
    11: 
    12: 
    13: @dataclass
    14: class PositionState:
    15:     symbol: str
    16:     state: str = STATE_FLAT
    17:     order_id: Optional[str] = None
    18:     side: Optional[str] = None   # "long" | "short"
    19:     qty: float = 0.0
    20:     entry: float = 0.0
    21: 
    22: 
    23: class PositionFSM:
    24:     """
    25:     FSM ultra-simple par symbole.
    26:     - set_pending_entry(order_id, side)
    27:     - reconcile(open_positions, fills) -> met à jour l'état à partir des données Bitget
    28:     """
    29: 
    30:     def __init__(self, symbols: List[str]) -> None:
    31:         self._by_symbol: Dict[str, PositionState] = {s: PositionState(s) for s in symbols}
    32: 
    33:     # -------- API utilisateur --------
    34:     def ensure_symbol(self, symbol: str) -> None:
    35:         if symbol not in self._by_symbol:
    36:             self._by_symbol[symbol] = PositionState(symbol)
    37: 
    38:     def set_pending_entry(self, symbol: str, order_id: str, side: str) -> None:
    39:         self.ensure_symbol(symbol)
    40:         st = self._by_symbol[symbol]
    41:         st.state = STATE_PENDING_ENTRY
    42:         st.order_id = order_id
    43:         st.side = side
    44: 
    45:     def mark_pending_exit(self, symbol: str) -> None:
    46:         self.ensure_symbol(symbol)
    47:         st = self._by_symbol[symbol]
    48:         st.state = STATE_PENDING_EXIT
    49: 
    50:     def force_flat(self, symbol: str) -> None:
    51:         self._by_symbol[symbol] = PositionState(symbol)
    52: 
    53:     # -------- Lecture --------
    54:     def get(self, symbol: str) -> PositionState:
    55:         self.ensure_symbol(symbol)
    56:         return self._by_symbol[symbol]
    57: 
    58:     def all(self) -> Dict[str, PositionState]:
    59:         return self._by_symbol
    60: 
    61:     # -------- Réconciliation --------
    62:     def reconcile(self, open_positions: List[Dict[str, Any]], fills: Dict[str, List[Dict[str, Any]]]) -> None:
    63:         """
    64:         open_positions: liste [{symbol, side, qty, avgEntryPrice}]
    65:         fills: dict symbol -> liste de fills [{orderId, price, qty, ...}]
    66:         """
    67:         # indexer positions ouvertes
    68:         idx_open = {p["symbol"]: p for p in open_positions if float(p.get("qty", 0.0)) > 0.0}
    69: 
    70:         for sym, st in self._by_symbol.items():
    71:             p = idx_open.get(sym)
    72: 
    73:             if st.state == STATE_PENDING_ENTRY:
    74:                 # si on voit des fills de l'ordre en attente -> OPEN
    75:                 f_list = fills.get(sym) or []
    76:                 qty_filled = sum(float(f.get("qty", 0.0)) for f in f_list if not st.order_id or str(f.get("orderId")) == str(st.order_id))
    77:                 if qty_filled > 0.0 or p:
    78:                     st.state = STATE_OPEN
    79:                     st.qty = float(p.get("qty", qty_filled)) if p else qty_filled
    80:                     st.entry = float(p.get("avgEntryPrice", f_list[0].get("price", 0.0) if f_list else 0.0)) if p else \
    81:                                float(f_list[0].get("price", 0.0)) if f_list else 0.0
    82:             elif st.state == STATE_OPEN:
    83:                 # si plus de position ouverte -> FLAT
    84:                 if not p:
    85:                     st.state = STATE_FLAT
    86:                     st.order_id = None
    87:                     st.side = None
    88:                     st.qty = 0.0
    89:                     st.entry = 0.0
    90:                 else:
    91:                     st.qty = float(p.get("qty", st.qty))
    92:                     st.entry = float(p.get("avgEntryPrice", st.entry))
    93:             elif st.state == STATE_PENDING_EXIT:
    94:                 # si plus de position -> FLAT ; sinon reste OPEN
    95:                 if not p:
    96:                     st.state = STATE_FLAT
    97:                     st.order_id = None
    98:                     st.side = None
    99:                     st.qty = 0.0
   100:                     st.entry = 0.0
   101:                 else:
   102:                     st.state = STATE_OPEN  # pas encore clos
   103:             else:
   104:                 # FLAT: si une position apparaît (cas reboot) -> OPEN
   105:                 if p:
   106:                     st.state = STATE_OPEN
   107:                     st.qty = float(p.get("qty", 0.0))
   108:                     st.entry = float(p.get("avgEntryPrice", 0.0))

--------------------------------------------------------------------------------
FILE: scalper/live/runner.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # scalper/live/runner.py
     2: from __future__ import annotations
     3: from typing import Dict, List, Optional
     4: from engine.signals.factory import resolve_signal_fn
     5: 
     6: class JobRunner:
     7:     def __init__(self, strategies_cfg: dict, equity: float, risk_pct: float) -> None:
     8:         self.cfg = strategies_cfg
     9:         self.equity = float(equity)
    10:         self.risk = float(risk_pct)
    11: 
    12:     def run_once(
    13:         self, *, symbol: str, timeframe: str,
    14:         ohlcv: Dict[str, List[float]],
    15:         ohlcv_1h: Optional[Dict[str, List[float]]] = None
    16:     ):
    17:         fn = resolve_signal_fn(symbol, timeframe, self.cfg)
    18:         return fn(
    19:             symbol=symbol, timeframe=timeframe, ohlcv=ohlcv,
    20:             equity=self.equity, risk_pct=self.risk, ohlcv_1h=ohlcv_1h
    21:         )

--------------------------------------------------------------------------------
FILE: scalper/live/setup_wizard.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import asyncio, os
     3: from dataclasses import dataclass
     4: from typing import List, Dict, Optional, Callable
     5: from ..signals.factory import load_signal
     6: from ..backtest.runner import BacktestRunner
     7: from .notify import Notifier, CommandStream
     8: 
     9: @dataclass
    10: class SetupResult:
    11:     strategy: str
    12:     symbols: List[str]
    13:     timeframes: List[str]
    14:     risk_pct: float
    15:     accepted: bool
    16:     summary_path: str
    17: 
    18: class SetupWizard:
    19:     """
    20:     Wizard interactif Telegram avant lancement des trades.
    21:     Utilise Notifier (send/send_menu) + CommandStream (async iterator).
    22:     """
    23:     def __init__(self, notifier: Notifier, cmd_stream: CommandStream,
    24:                  ohlcv_loader_sync: Callable, out_dir: str = "out_bt_setup",
    25:                  admin_chat_id: Optional[int]=None):
    26:         self.notifier = notifier
    27:         self.cmd_stream = cmd_stream
    28:         self.loader = ohlcv_loader_sync
    29:         self.out_dir = out_dir
    30:         self.admin_chat_id = admin_chat_id
    31: 
    32:     async def _ask_list(self, prompt: str, choices: List[str], allow_multi=True) -> List[str]:
    33:         await self.notifier.send_menu(prompt, choices)
    34:         async for msg in self.cmd_stream:
    35:             txt = msg.strip()
    36:             if allow_multi and ("," in txt or " " in txt):
    37:                 sel = [t.strip() for t in txt.replace(" ", "").split(",") if t.strip()]
    38:                 return sel
    39:             if txt.isdigit():
    40:                 i = int(txt)-1
    41:                 if 0 <= i < len(choices):
    42:                     return [choices[i]]
    43:             if txt in choices:
    44:                 return [txt]
    45:             await self.notifier.send("Entrée invalide. Réessaie.")
    46: 
    47:     async def _ask_value(self, prompt: str, cast: Callable, default):
    48:         await self.notifier.send(f"{prompt} (défaut: {default})")
    49:         async for msg in self.cmd_stream:
    50:             txt = msg.strip()
    51:             if txt == "" or txt.lower() in ("d","defaut","default"):
    52:                 return default
    53:             try:
    54:                 return cast(txt)
    55:             except Exception:
    56:                 await self.notifier.send("Entrée invalide. Réessaie.")
    57: 
    58:     async def run(self, default_symbols: List[str], default_timeframes: List[str],
    59:                   default_strategy: str="current") -> SetupResult:
    60:         await self.notifier.send("🧪 Validation avant trading : choix strat/symbols/TF → backtest → validation.")
    61:         # 1) stratégie
    62:         strategies = ["current","ema_cross","vwap_break"]
    63:         [strategy] = await self._ask_list("Choisis la stratégie :", strategies, allow_multi=False)
    64: 
    65:         # 2) symboles
    66:         symbols = await self._ask_list("Sélectionne les symboles :", default_symbols, allow_multi=True)
    67: 
    68:         # 3) timeframes
    69:         timeframes = await self._ask_list("Sélectionne les timeframes :", default_timeframes, allow_multi=True)
    70: 
    71:         # 4) risk %
    72:         risk_pct = await self._ask_value("Risk % du solde (ex: 0.5 = 50%)", float, 0.5)
    73: 
    74:         # 5) période backtest
    75:         start = await self._ask_value("Date de début (YYYY-MM-DD)", str, "2024-01-01")
    76:         end   = await self._ask_value("Date de fin   (YYYY-MM-DD)", str, "2025-08-01")
    77: 
    78:         # 6) run backtest
    79:         from ..backtest.cli import parse_ts
    80:         start_ms, end_ms = parse_ts(start), parse_ts(end)
    81:         runner = BacktestRunner(self.loader, self.out_dir, strategy,
    82:                                 cfg={}, cash=10_000.0, risk_pct=risk_pct, max_conc=6)
    83:         res = await runner.run_all(symbols, timeframes, start_ms, end_ms)
    84: 
    85:         # 7) résumé
    86:         sum_path = os.path.join(self.out_dir, "metrics.json")
    87:         prop = res["proposal"]
    88:         lines = ["**Proposition** :"]
    89:         for sym, best in prop["per_symbol_best"].items():
    90:             lines.append(f"• {sym}: {best['timeframe']}  score={best['score']:.3f}  PF={best['pf']:.2f}  WR={best['winrate']:.1%}  DD={best['maxdd']:.1%}")
    91:         await self.notifier.send("\n".join(lines) + f"\nFichier: {sum_path}\n✅ Tape **ACCEPTER** pour lancer\n🔁 **MODIFIER** pour relancer\n❌ **ANNULER** pour quitter.")
    92: 
    93:         # 8) décision
    94:         async for msg in self.cmd_stream:
    95:             t = msg.strip().lower()
    96:             if t in ("accepter","accept","ok","go","start"):
    97:                 await self.notifier.send("✅ Validation reçue — passage en RUNNING.")
    98:                 return SetupResult(strategy, symbols, timeframes, risk_pct, True, sum_path)
    99:             if t in ("modifier","again","repeat"):
   100:                 return await self.run(default_symbols, default_timeframes, default_strategy=strategy)
   101:             if t in ("annuler","cancel","stop"):
   102:                 await self.notifier.send("❌ Annulé.")
   103:                 return SetupResult(strategy, symbols, timeframes, risk_pct, False, sum_path)

--------------------------------------------------------------------------------
FILE: scalper/live/state_store.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # live/state_store.py
     2: from __future__ import annotations
     3: import json, os, time, asyncio
     4: from typing import Callable, Dict, Any
     5: 
     6: class StateStore:
     7:     """
     8:     Persistance légère de l'état (FSM + horodatages) dans un JSON.
     9:     - save_state(snapshot: dict) -> écrit sur disque
    10:     - load_state() -> dict
    11:     - task_autosave(get_snapshot: callable) -> boucle d’auto‑save
    12:     """
    13: 
    14:     def __init__(self, filepath: str, period_s: float = 10.0) -> None:
    15:         self.filepath = filepath
    16:         self.period_s = period_s
    17:         os.makedirs(os.path.dirname(self.filepath), exist_ok=True)
    18:         self._running = False
    19: 
    20:     # -------- I/O --------
    21:     def save_state(self, snapshot: Dict[str, Any]) -> None:
    22:         tmp = self.filepath + ".tmp"
    23:         with open(tmp, "w", encoding="utf-8") as f:
    24:             json.dump(snapshot, f, ensure_ascii=False, indent=2)
    25:         os.replace(tmp, self.filepath)
    26: 
    27:     def load_state(self) -> Dict[str, Any]:
    28:         if not os.path.exists(self.filepath):
    29:             return {}
    30:         try:
    31:             with open(self.filepath, "r", encoding="utf-8") as f:
    32:                 return json.load(f)
    33:         except Exception:
    34:             return {}
    35: 
    36:     # -------- Autosave --------
    37:     async def task_autosave(self, get_snapshot: Callable[[], Dict[str, Any]]):
    38:         self._running = True
    39:         while self._running:
    40:             try:
    41:                 snap = get_snapshot()
    42:                 snap["saved_at"] = int(time.time() * 1000)
    43:                 self.save_state(snap)
    44:             except Exception:
    45:                 pass
    46:             await asyncio.sleep(self.period_s)
    47: 
    48:     def stop(self): self._running = False

--------------------------------------------------------------------------------
FILE: scalper/live/telegram_async.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: import time
     3: import requests
     4: import asyncio
     5: from typing import Optional, Dict, Any, List
     6: 
     7: 
     8: class TelegramAsync:
     9:     """
    10:     Client Telegram simple basé sur requests, utilisé de manière non bloquante via asyncio.to_thread.
    11:     Sans nouvelle dépendance.
    12:     """
    13:     def __init__(self, token: Optional[str], chat_id: Optional[str]) -> None:
    14:         self.token = token
    15:         self.chat_id = chat_id
    16:         self.base = f"https://api.telegram.org/bot{token}" if token else None
    17:         self._offset = 0
    18:         self._enabled = bool(token and chat_id)
    19: 
    20:     def enabled(self) -> bool:
    21:         return self._enabled
    22: 
    23:     # ---------- sync I/O (appelées via to_thread) ----------
    24:     def _send_message_sync(self, text: str) -> Dict[str, Any]:
    25:         if not self._enabled:
    26:             return {"ok": False, "reason": "disabled"}
    27:         url = f"{self.base}/sendMessage"
    28:         payload = {"chat_id": self.chat_id, "text": text}
    29:         try:
    30:             r = requests.post(url, json=payload, timeout=10)
    31:             return r.json()
    32:         except Exception as e:
    33:             return {"ok": False, "error": repr(e)}
    34: 
    35:     def _get_updates_sync(self, timeout_s: int = 30) -> Dict[str, Any]:
    36:         if not self._enabled:
    37:             return {"ok": True, "result": []}
    38:         url = f"{self.base}/getUpdates"
    39:         params = {"timeout": timeout_s, "offset": self._offset}
    40:         try:
    41:             r = requests.get(url, params=params, timeout=timeout_s + 5)
    42:             return r.json()
    43:         except Exception as e:
    44:             return {"ok": False, "error": repr(e), "result": []}
    45: 
    46:     # ---------- async wrappers ----------
    47:     async def send_message(self, text: str) -> None:
    48:         await asyncio.to_thread(self._send_message_sync, text)
    49: 
    50:     async def poll_commands(self, timeout_s: int = 30) -> List[Dict[str, Any]]:
    51:         data = await asyncio.to_thread(self._get_updates_sync, timeout_s)
    52:         if not data.get("ok"):
    53:             return []
    54:         out = []
    55:         for upd in data.get("result", []):
    56:             self._offset = max(self._offset, int(upd.get("update_id", 0)) + 1)
    57:             msg = upd.get("message") or {}
    58:             text = (msg.get("text") or "").strip()
    59:             if not text:
    60:                 continue
    61:             out.append({
    62:                 "date": msg.get("date"),
    63:                 "chat": str((msg.get("chat") or {}).get("id")),
    64:                 "text": text,
    65:                 "from": (msg.get("from") or {}).get("username") or (msg.get("from") or {}).get("first_name") or "unknown",
    66:             })
    67:         return out

--------------------------------------------------------------------------------
FILE: scalper/live/watchlist.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # -*- coding: utf-8 -*-
     2: from __future__ import annotations
     3: from dataclasses import dataclass
     4: from typing import List
     5: 
     6: 
     7: @dataclass
     8: class WatchlistManager:
     9:     symbols: List[str]
    10: 
    11:     @classmethod
    12:     def from_env_or_default(cls) -> "WatchlistManager":
    13:         # Tu peux lire une variable d'env ici si tu veux surcharger
    14:         default = [
    15:             "BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT",
    16:             "DOGEUSDT","ADAUSDT","LTCUSDT","AVAXUSDT","LINKUSDT"
    17:         ]
    18:         return cls(default)

--------------------------------------------------------------------------------
FILE: sitecustomize.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: # sitecustomize.py
     2: """
     3: Ce fichier est importé automatiquement par Python au démarrage, si présent sur sys.path.
     4: On l'utilise pour lancer un préflight de 'scalper' avant l'exécution du bot,
     5: sans modifier bot.py. Désactivable via SKIP_PREFLIGHT=1.
     6: """
     7: 
     8: import os
     9: 
    10: if os.getenv("SKIP_PREFLIGHT", "0") not in ("1", "true", "yes"):
    11:     try:
    12:         # Optionnel: charger /notebooks/.env si présent
    13:         try:
    14:             from dotenv import load_dotenv  # pip install python-dotenv si besoin
    15:             load_dotenv("/notebooks/.env")
    16:         except Exception:
    17:             pass
    18: 
    19:     except Exception:
    20:         pass
    21: 
    22:     try:
    23:         from engine.selfcheck import preflight_or_die
    24:         preflight_or_die(verbose=False)
    25:     except SystemExit:
    26:         # le préflight a signalé un problème -> on laisse l'arrêt se propager
    27:         raise
    28:     except Exception as e:
    29:         # On ne bloque pas le démarrage si le selfcheck lui-même plante,
    30:         # mais on affiche une alerte claire.
    31:         print(f"[sitecustomize] Avertissement: selfcheck non exécuté ({e})")

--------------------------------------------------------------------------------
FILE: tests/conftest.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Test configuration and shared fixtures."""
     2: 
     3: import sys
     4: import types
     5: from pathlib import Path
     6: 
     7: 
     8: # Ensure the project root is importable so tests can ``import bot``.
     9: ROOT = Path(__file__).resolve().parents[1]
    10: sys.path.insert(0, str(ROOT))
    11: 
    12: 
    13: # Provide a dummy ``requests`` module so ``bot.py`` doesn't attempt to install
    14: # the real dependency during test collection. Individual tests patch the
    15: # functions they need (``request``/``post``/``get``).
    16: sys.modules.setdefault(
    17:     "requests",
    18:     types.SimpleNamespace(HTTPError=Exception, request=None, post=None, get=None),
    19: )
    20: 

--------------------------------------------------------------------------------
FILE: tests/test_analyse_risque.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.SimpleNamespace(
     7:     request=lambda *a, **k: None,
     8:     post=lambda *a, **k: None,
     9:     HTTPError=Exception,
    10: )
    11: 
    12: from bot import analyse_risque  # noqa: E402
    13: 
    14: 
    15: def make_contract_detail():
    16:     return {
    17:         "data": [
    18:             {
    19:                 "symbol": "BTC_USDT",
    20:                 "contractSize": 0.01,
    21:                 "volUnit": 1,
    22:                 "minVol": 1,
    23:             }
    24:         ]
    25:     }
    26: 
    27: 
    28: def test_analyse_risque_limits_and_leverage():
    29:     contract_detail = make_contract_detail()
    30:     # Risk level 1: leverage halved, limit 1 position
    31:     open_pos = [{"symbol": "BTC_USDT", "side": "long"}]
    32:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    33:                                symbol="BTC_USDT", side="long", risk_level=1)
    34:     assert lev == 5
    35:     assert vol == 0  # already one long position
    36: 
    37:     # Risk level 2: base leverage, limit 3 positions
    38:     open_pos = [
    39:         {"symbol": "BTC_USDT", "side": "long"},
    40:         {"symbol": "BTC_USDT", "side": "long"},
    41:         {"symbol": "BTC_USDT", "side": "long"},
    42:     ]
    43:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    44:                                symbol="BTC_USDT", side="long", risk_level=2)
    45:     assert lev == 10
    46:     assert vol == 0
    47: 
    48:     # Risk level 3: leverage doubled, no existing position
    49:     open_pos = []
    50:     vol, lev = analyse_risque(contract_detail, open_pos, 1000, 50000, 0.01, 10,
    51:                                symbol="BTC_USDT", side="long", risk_level=3)
    52:     assert lev == 20
    53:     assert vol == 1

--------------------------------------------------------------------------------
FILE: tests/test_backtest.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import pytest
     2: 
     3: import bot
     4: 
     5: 
     6: def test_backtest_trades():
     7:     trades = [
     8:         {"symbol": "AAA", "entry": 100.0, "exit": 110.0, "side": 1},
     9:         {"symbol": "BBB", "entry": 100.0, "exit": 90.0, "side": -1},
    10:     ]
    11:     pnl = bot.backtest_trades(trades, fee_rate=0.001)
    12:     # Both trades: 10% - 0.2% fee = 9.8% each
    13:     assert pnl == pytest.approx(19.6)

--------------------------------------------------------------------------------
FILE: tests/test_backtest_multi.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import csv
     2: import random
     3: from datetime import datetime, timedelta, timezone
     4: from pathlib import Path
     5: 
     6: import pytest
     7: 
     8: from engine.backtest.run_multi import run_backtest_multi
     9: from engine.strategy import Signal
    10: 
    11: 
    12: def make_csv(tmp_path: Path, symbol: str, timeframe: str = "1m") -> None:
    13:     start = datetime(2024, 1, 1, tzinfo=timezone.utc)
    14:     filename = tmp_path / f"{symbol.replace('/', '')}-{timeframe}.csv"
    15:     with open(filename, "w", newline="") as fh:
    16:         writer = csv.writer(fh)
    17:         writer.writerow(["timestamp", "open", "high", "low", "close", "volume"])
    18:         for i in range(200):
    19:             ts = int((start + timedelta(minutes=i)).timestamp() * 1000)
    20:             price = 100 + i
    21:             writer.writerow([ts, price, price * 1.02, price * 0.995, price, 1])
    22: 
    23: 
    24: def simple_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    25:     closes = ohlcv["close"]
    26:     if len(closes) < 10:
    27:         return None
    28:     price = closes[-1]
    29:     sl = price * 0.99
    30:     tp = price * 1.01
    31:     qty = equity * risk_pct / (price - sl)
    32:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty, score=1.0, reasons=["test"])
    33: 
    34: 
    35: def random_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    36:     if len(ohlcv["close"]) < 10 or random.random() > 0.3:
    37:         return None
    38:     price = ohlcv["close"][-1]
    39:     sl = price * 0.99
    40:     tp = price * 1.01
    41:     qty = equity * risk_pct / (price - sl)
    42:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, qty)
    43: 
    44: 
    45: def tiny_qty_signal(symbol, ohlcv, equity, risk_pct, **kwargs):
    46:     closes = ohlcv["close"]
    47:     if len(closes) < 10:
    48:         return None
    49:     price = closes[-1]
    50:     sl = price * 0.99
    51:     tp = price * 1.01
    52:     return Signal(symbol, "long", price, sl, tp, tp * 1.01, 0.00005)
    53: 
    54: 
    55: def find_row(summary, symbol):
    56:     for row in summary:
    57:         if row["symbol"] == symbol:
    58:             return row
    59:     raise KeyError(symbol)
    60: 
    61: 
    62: def test_csv_multi_pairs(tmp_path, monkeypatch):
    63:     for sym in ["BTC/USDT", "ETH/USDT"]:
    64:         make_csv(tmp_path, sym)
    65:     monkeypatch.setattr("engine.strategy.generate_signal", simple_signal)
    66:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
    67:     out = tmp_path / "out"
    68:     summary, trades = run_backtest_multi(
    69:         symbols=["BTC/USDT", "ETH/USDT"],
    70:         exchange="csv",
    71:         timeframe="1m",
    72:         csv_dir=str(tmp_path),
    73:         fee_rate=0.0,
    74:         slippage_bps=0.0,
    75:         risk_pct=0.01,
    76:         initial_equity=1000,
    77:         leverage=1.0,
    78:         paper_constraints=True,
    79:         seed=42,
    80:         out_dir=str(out),
    81:         plot=False,
    82:     )
    83:     btc_trades = [t for t in trades if t["symbol"] == "BTC/USDT"]
    84:     eth_trades = [t for t in trades if t["symbol"] == "ETH/USDT"]
    85:     assert len(btc_trades) > 0 and len(eth_trades) > 0
    86:     assert find_row(summary, "BTC/USDT")["pnl_usdt"] > 0
    87:     total = find_row(summary, "TOTAL")["pnl_usdt"]
    88:     assert pytest.approx(total) == find_row(summary, "BTC/USDT")["pnl_usdt"] + find_row(summary, "ETH/USDT")["pnl_usdt"]
    89:     # files
    90:     assert (out / "report_summary.csv").exists()
    91:     assert (out / "report_trades.csv").exists()
    92:     assert (out / "equity_curve_total.csv").exists()
    93:     assert (out / "equity_curve_BTC_USDT.csv").exists()
    94:     # columns in trades
    95:     for col in ["entry_time", "exit_time", "symbol", "side", "entry", "exit", "pnl_pct", "pnl_usdt"]:
    96:         assert col in trades[0]
    97: 
    98: 
    99: def test_fee_slippage(tmp_path, monkeypatch):
   100:     make_csv(tmp_path, "BTC/USDT")
   101:     monkeypatch.setattr("engine.strategy.generate_signal", simple_signal)
   102:     monkeypatch.setattr("backtest.engine.generate_signal", simple_signal)
   103:     summary1, _ = run_backtest_multi(
   104:         symbols=["BTC/USDT"],
   105:         exchange="csv",
   106:         timeframe="1m",
   107:         csv_dir=str(tmp_path),
   108:         fee_rate=0.0,
   109:         slippage_bps=0.0,
   110:         out_dir=str(tmp_path / "o1"),
   111:     )
   112:     summary2, _ = run_backtest_multi(
   113:         symbols=["BTC/USDT"],
   114:         exchange="csv",
   115:         timeframe="1m",
   116:         csv_dir=str(tmp_path),
   117:         fee_rate=0.01,
   118:         slippage_bps=100,
   119:         out_dir=str(tmp_path / "o2"),
   120:     )
   121:     pnl1 = find_row(summary1, "TOTAL")["pnl_usdt"]
   122:     pnl2 = find_row(summary2, "TOTAL")["pnl_usdt"]
   123:     assert pnl2 < pnl1
   124: 
   125: 
   126: def test_paper_constraints(tmp_path, monkeypatch):
   127:     make_csv(tmp_path, "BTC/USDT")
   128:     monkeypatch.setattr("engine.strategy.generate_signal", tiny_qty_signal)
   129:     monkeypatch.setattr("backtest.engine.generate_signal", tiny_qty_signal)
   130:     summary, trades = run_backtest_multi(
   131:         symbols=["BTC/USDT"],
   132:         exchange="csv",
   133:         timeframe="1m",
   134:         csv_dir=str(tmp_path),
   135:         paper_constraints=True,
   136:         out_dir=str(tmp_path / "o"),
   137:     )
   138:     assert all(t["qty"] >= 0.001 for t in trades)
   139:     assert all(abs((t["qty"] * 10000) % 1) < 1e-9 for t in trades)
   140:     assert all(t["entry"] * t["qty"] >= 5 - 1e-9 for t in trades)
   141: 
   142: 
   143: def test_seed_reproducible(tmp_path, monkeypatch):
   144:     make_csv(tmp_path, "BTC/USDT")
   145:     monkeypatch.setattr("engine.strategy.generate_signal", random_signal)
   146:     monkeypatch.setattr("backtest.engine.generate_signal", random_signal)
   147:     s1, t1 = run_backtest_multi(
   148:         symbols=["BTC/USDT"],
   149:         exchange="csv",
   150:         timeframe="1m",
   151:         csv_dir=str(tmp_path),
   152:         seed=7,
   153:         out_dir=str(tmp_path / "o1"),
   154:     )
   155:     s2, t2 = run_backtest_multi(
   156:         symbols=["BTC/USDT"],
   157:         exchange="csv",
   158:         timeframe="1m",
   159:         csv_dir=str(tmp_path),
   160:         seed=7,
   161:         out_dir=str(tmp_path / "o2"),
   162:     )
   163:     assert t1 == t2
   164:     assert s1 == s2

--------------------------------------------------------------------------------
FILE: tests/test_backtest_position.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import pytest
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: 
     7: from engine.metrics import backtest_position
     8: 
     9: 
    10: def test_backtest_position_long():
    11:     prices = [100.0, 110.0, 120.0]
    12:     assert backtest_position(prices, 0, 2, 1) is True
    13: 
    14: 
    15: def test_backtest_position_short():
    16:     prices = [100.0, 90.0, 80.0]
    17:     assert backtest_position(prices, 0, 2, -1) is True
    18: 
    19: 
    20: def test_backtest_position_incoherent():
    21:     prices = [100.0, 110.0, 120.0]
    22:     assert backtest_position(prices, 0, 2, -1) is False
    23: 
    24: 
    25: def test_backtest_position_bad_indices():
    26:     prices = [100.0, 110.0]
    27:     with pytest.raises(ValueError):
    28:         backtest_position(prices, 1, 0, 1)

--------------------------------------------------------------------------------
FILE: tests/test_bitget_futures_pairs.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import json
     2: from pathlib import Path
     3: from typing import Any, Dict
     4: 
     5: import pytest
     6: 
     7: import bitget_futures_pairs as bfp
     8: 
     9: 
    10: class DummyResponse:
    11:     def __init__(self, status: int, payload: Dict[str, Any]):
    12:         self.status_code = status
    13:         self._payload = payload
    14:         self.text = json.dumps(payload)
    15: 
    16:     def json(self):
    17:         return self._payload
    18: 
    19: 
    20: def test_fetch_contracts_success(monkeypatch):
    21:     payload = {"code": "00000", "data": [{"symbol": "BTCUSDT"}]}
    22: 
    23:     def fake_get(url, params=None, timeout=0):
    24:         return DummyResponse(200, payload)
    25: 
    26:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    27:     contracts = bfp.fetch_contracts("USDT-FUTURES")
    28:     assert contracts == payload["data"]
    29: 
    30: 
    31: def test_fetch_contracts_error(monkeypatch):
    32:     payload = {"code": "10001"}
    33: 
    34:     def fake_get(url, params=None, timeout=0):
    35:         return DummyResponse(200, payload)
    36: 
    37:     monkeypatch.setattr(bfp, "requests", type("R", (), {"get": staticmethod(fake_get)})())
    38:     with pytest.raises(RuntimeError):
    39:         bfp.fetch_contracts("USDT-FUTURES")
    40: 
    41: 
    42: def test_normalize_rows():
    43:     contracts = [
    44:         {
    45:             "symbol": "BTCUSDT",
    46:             "baseCoin": "BTC",
    47:             "quoteCoin": "USDT",
    48:             "symbolType": "perpetual",
    49:             "symbolStatus": "normal",
    50:             "maxLever": "50",
    51:             "minLever": "1",
    52:             "minTradeNum": "0.001",
    53:             "sizeMultiplier": "1",
    54:             "pricePlace": "2",
    55:             "volumePlace": "3",
    56:             "launchTime": 0,
    57:             "deliveryTime": 0,
    58:         }
    59:     ]
    60:     rows = bfp.normalize_rows("USDT-FUTURES", contracts)
    61:     assert rows[0]["symbol"] == "BTCUSDT"
    62:     assert rows[0]["productType"] == "USDT-FUTURES"
    63: 
    64: 
    65: def test_write_csv(tmp_path: Path):
    66:     path = tmp_path / "pairs.csv"
    67:     bfp.write_csv([], str(path))
    68:     assert path.exists()
    69:     content = path.read_text().splitlines()
    70:     assert content[0].startswith("productType,")

--------------------------------------------------------------------------------
FILE: tests/test_bot_place_order_caps.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import types
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: sys.modules['requests'] = types.ModuleType('requests')
     6: 
     7: from bot import attempt_entry, Signal
     8: 
     9: 
    10: class DummyClient:
    11:     def __init__(self):
    12:         self.last_order = None
    13: 
    14:     def place_order(self, *args, **kwargs):  # pragma: no cover - simple store
    15:         self.last_order = (args, kwargs)
    16:         return {"code": "00000"}
    17: 
    18: 
    19: class DummyRisk:
    20:     def __init__(self, pct):
    21:         self.risk_pct = pct
    22: 
    23: 
    24: def _detail():
    25:     return {
    26:         "data": [
    27:             {
    28:                 "symbol": "BTC_USDT",
    29:                 "contractSize": 0.001,
    30:                 "volUnit": 1,
    31:                 "minVol": 1,
    32:                 "minTradeUSDT": 5,
    33:             }
    34:         ]
    35:     }
    36: 
    37: 
    38: def test_attempt_entry_respects_caps(monkeypatch):
    39:     captured = {}
    40: 
    41:     def fake_notify(event, payload):
    42:         captured[event] = payload
    43: 
    44:     monkeypatch.setattr("bot.notify", fake_notify)
    45:     client = DummyClient()
    46:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    47:     rm = DummyRisk(0.02)
    48:     equity = 100
    49:     available = 2.2  # just enough for 1 contract with buffer
    50:     params = attempt_entry(
    51:         client,
    52:         _detail(),
    53:         sig,
    54:         equity_usdt=equity,
    55:         available_usdt=available,
    56:         cfg={"LEVERAGE": 10},
    57:         risk_mgr=rm,
    58:         user_risk_level=1,
    59:     )
    60:     assert client.last_order is not None
    61:     assert params["vol"] >= 1
    62:     opened = captured["position_opened"]
    63:     assert opened["notional_usdt"] >= 5
    64:     assert opened["vol"] >= 1
    65: 
    66: 
    67: def test_attempt_entry_insufficient_margin(monkeypatch):
    68:     captured = {}
    69: 
    70:     def fake_notify(event, payload):
    71:         captured[event] = payload
    72: 
    73:     monkeypatch.setattr("bot.notify", fake_notify)
    74:     client = DummyClient()
    75:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    76:     rm = DummyRisk(0.02)
    77:     equity = 100
    78:     available = 1.0  # below required margin
    79:     params = attempt_entry(
    80:         client,
    81:         _detail(),
    82:         sig,
    83:         equity_usdt=equity,
    84:         available_usdt=available,
    85:         cfg={"LEVERAGE": 10},
    86:         risk_mgr=rm,
    87:         user_risk_level=1,
    88:     )
    89:     assert client.last_order is None
    90:     assert params["vol"] == 0
    91:     assert captured["order_blocked"]["reason"].startswith("volume reduced")
    92: 
    93: 
    94: def test_attempt_entry_under_min_trade(monkeypatch):
    95:     captured = {}
    96: 
    97:     def fake_notify(event, payload):
    98:         captured[event] = payload
    99: 
   100:     monkeypatch.setattr("bot.notify", fake_notify)
   101:     client = DummyClient()
   102:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
   103:     rm = DummyRisk(0.02)
   104:     detail = {
   105:         "data": [
   106:             {
   107:                 "symbol": "BTC_USDT",
   108:                 "contractSize": 0.001,
   109:                 "volUnit": 1,
   110:                 "minVol": 1,
   111:                 "minTradeUSDT": 50,
   112:             }
   113:         ]
   114:     }
   115:     equity = 100
   116:     available = 100
   117:     params = attempt_entry(
   118:         client,
   119:         detail,
   120:         sig,
   121:         equity_usdt=equity,
   122:         available_usdt=available,
   123:         cfg={"LEVERAGE": 10},
   124:         risk_mgr=rm,
   125:         user_risk_level=1,
   126:     )
   127:     assert client.last_order is None
   128:     assert params["vol"] == 0
   129:     assert captured["order_blocked"]["reason"].startswith("volume reduced")

--------------------------------------------------------------------------------
FILE: tests/test_bot_update.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import logging
     2: import bot
     3: 
     4: 
     5: def test_update_displays_pairs(monkeypatch, caplog):
     6:     def fake_send(client, top_n=40):
     7:         assert (client, top_n) == ("cli", 5)
     8:         return {"green": "BTC", "orange": "ETH", "red": "XRP"}
     9: 
    10:     monkeypatch.setattr(bot, "send_selected_pairs", fake_send)
    11:     with caplog.at_level(logging.INFO):
    12:         payload = bot.update("cli", top_n=5)
    13:     assert payload["green"] == "BTC"
    14:     assert "Listing ok" in caplog.text
    15: 
    16: 
    17: def test_update_survives_errors(monkeypatch, caplog):
    18:     """``update`` should never raise even if pair selection fails."""
    19: 
    20:     def boom(client, top_n=40):  # pragma: no cover - simulated failure
    21:         raise RuntimeError("network down")
    22: 
    23:     monkeypatch.setattr(bot, "send_selected_pairs", boom)
    24:     with caplog.at_level(logging.INFO):
    25:         payload = bot.update("cli", top_n=5)
    26: 
    27:     # The function returns an empty payload and logs the error, but still logs
    28:     # the "Listing ok" acknowledgement so callers can proceed.
    29:     assert payload == {}
    30:     assert "network down" in caplog.text
    31:     assert "Listing ok" in caplog.text
    32: 

--------------------------------------------------------------------------------
FILE: tests/test_break_even_stop.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from engine.trade_utils import break_even_stop
     2: 
     3: 
     4: def test_break_even_stop_long() -> None:
     5:     sl = break_even_stop("long", entry_price=100, current_price=110, atr=5, sl=95)
     6:     assert sl == 100
     7:     sl = break_even_stop("long", entry_price=100, current_price=102, atr=5, sl=95)
     8:     assert sl == 95
     9: 
    10: 
    11: def test_break_even_stop_short() -> None:
    12:     sl = break_even_stop("short", entry_price=100, current_price=90, atr=5, sl=105)
    13:     assert sl == 100
    14:     sl = break_even_stop("short", entry_price=100, current_price=97, atr=5, sl=105)
    15:     assert sl == 105

--------------------------------------------------------------------------------
FILE: tests/test_calc_pnl_pct.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import pytest
     4: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     5: 
     6: from engine.metrics import calc_pnl_pct
     7: 
     8: 
     9: def test_calc_pnl_pct_long():
    10:     assert calc_pnl_pct(100.0, 110.0, 1) == 10.0
    11: 
    12: def test_calc_pnl_pct_short():
    13:     assert calc_pnl_pct(100.0, 90.0, -1) == 10.0
    14: 
    15: 
    16: def test_calc_pnl_pct_with_fee():
    17:     # 10% move minus 0.1%*2 fees = 9.8%
    18:     assert calc_pnl_pct(100.0, 110.0, 1, fee_rate=0.001) == pytest.approx(9.8)

--------------------------------------------------------------------------------
FILE: tests/test_check_config.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import logging
     2: from bot import check_config
     3: 
     4: 
     5: def test_check_config_only_logs_critical_missing(monkeypatch, caplog):
     6:     monkeypatch.delenv("BITGET_ACCESS_KEY", raising=False)
     7:     monkeypatch.delenv("BITGET_SECRET_KEY", raising=False)
     8:     monkeypatch.delenv("NOTIFY_URL", raising=False)
     9:     with caplog.at_level(logging.INFO):
    10:         check_config()
    11:     messages = [r.getMessage() for r in caplog.records]
    12:     assert any("BITGET_ACCESS_KEY" in m for m in messages)
    13:     assert any("BITGET_SECRET_KEY" in m for m in messages)
    14:     assert all("NOTIFY_URL" not in m for m in messages)
    15: 
    16: 
    17: def test_check_config_does_not_log_present_keys(monkeypatch, caplog):
    18:     monkeypatch.setenv("BITGET_ACCESS_KEY", "abcdef")
    19:     monkeypatch.setenv("BITGET_SECRET_KEY", "abcdef")
    20:     monkeypatch.setenv("BITGET_PASSPHRASE", "abcdef")
    21:     with caplog.at_level(logging.INFO):
    22:         check_config()
    23:     assert caplog.records == []

--------------------------------------------------------------------------------
FILE: tests/test_cli.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Tests for the command line interface defined in :mod:`cli`."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import cli
     6: 
     7: 
     8: def test_opt_invokes_parallel_optimization(monkeypatch):
     9:     """The ``opt`` command should call ``run_parallel_optimization``."""
    10: 
    11:     called = {}
    12: 
    13:     def fake_run(pairs, tf, jobs):  # pragma: no cover - executed via CLI
    14:         called["args"] = (pairs, tf, jobs)
    15: 
    16:     monkeypatch.setattr(cli, "run_parallel_optimization", fake_run)
    17:     cli.main(["opt", "--pairs", "BTCUSDT", "ETHUSDT", "--tf", "1h", "--jobs", "4"])
    18:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], "1h", 4)
    19: 
    20: 
    21: def test_walkforward_invokes_analysis(monkeypatch):
    22:     """The ``walkforward`` command calls ``run_walkforward_analysis``."""
    23: 
    24:     called = {}
    25: 
    26:     def fake_run(pair, tf, splits, train_ratio):  # pragma: no cover
    27:         called["args"] = (pair, tf, splits, train_ratio)
    28: 
    29:     monkeypatch.setattr(cli, "run_walkforward_analysis", fake_run)
    30:     cli.main(
    31:         [
    32:             "walkforward",
    33:             "--pair",
    34:             "BTCUSDT",
    35:             "--tf",
    36:             "1m",
    37:             "--splits",
    38:             "3",
    39:             "--train-ratio",
    40:             "0.8",
    41:         ]
    42:     )
    43:     assert called["args"] == ("BTCUSDT", "1m", 3, 0.8)
    44: 
    45: 
    46: def test_live_invokes_async_pipeline(monkeypatch):
    47:     """The ``live`` command must execute the async pipeline via ``asyncio.run``."""
    48: 
    49:     called = {}
    50: 
    51:     async def fake_live(pairs, tfs):  # pragma: no cover - executed asynchronously
    52:         called["args"] = (pairs, list(tfs))
    53: 
    54:     monkeypatch.setattr(cli, "run_live_pipeline", fake_live)
    55:     cli.main(["live", "--pairs", "BTCUSDT", "ETHUSDT", "--tfs", "1m", "1h"])
    56:     assert called["args"] == (["BTCUSDT", "ETHUSDT"], ["1m", "1h"])
    57: 
    58: 
    59: def test_bump_version_invokes_helper(monkeypatch):
    60:     """The ``bump-version`` command calls ``bump_version_from_git``."""
    61: 
    62:     called = {}
    63: 
    64:     def fake_bump():  # pragma: no cover - executed via CLI
    65:         called["called"] = True
    66:         return "0.1.0"
    67: 
    68:     monkeypatch.setattr(cli, "bump_version_from_git", fake_bump)
    69:     cli.main(["bump-version"])
    70:     assert called["called"] is True
    71: 

--------------------------------------------------------------------------------
FILE: tests/test_client.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import json
     2: import hmac
     3: import hashlib
     4: import base64
     5: import pytest
     6: import bot
     7: from bot import BitgetFuturesClient
     8: 
     9: 
    10: @pytest.fixture(autouse=True)
    11: def no_log_event(monkeypatch):
    12:     monkeypatch.setattr(bot, "log_event", lambda *a, **k: None)
    13: 
    14: 
    15: def test_private_request_get_signature(monkeypatch):
    16:     client = BitgetFuturesClient("key", "secret", "https://test")
    17:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    18: 
    19:     called = {}
    20: 
    21:     def fake_request(method, url, headers=None, timeout=None):
    22:         called["method"] = method
    23:         called["url"] = url
    24:         called["headers"] = headers
    25: 
    26:         class Resp:
    27:             def raise_for_status(self):
    28:                 pass
    29: 
    30:             def json(self):
    31:                 return {"success": True}
    32: 
    33:         return Resp()
    34: 
    35:     monkeypatch.setattr(bot.requests, "request", fake_request)
    36: 
    37:     resp = client._private_request("GET", "/api/test", params={"b": "2", "a": "1"})
    38:     assert resp["success"] is True
    39:     qs = "a=1&b=2"
    40:     prehash = f"1000GET/api/test?{qs}"
    41:     expected = base64.b64encode(
    42:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    43:     ).decode()
    44:     assert called["headers"]["ACCESS-SIGN"] == expected
    45:     assert called["headers"]["ACCESS-KEY"] == "key"
    46:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    47:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    48:     assert called["url"] == "https://test/api/test?a=1&b=2"
    49: 
    50: 
    51: def test_private_request_post_signature(monkeypatch):
    52:     client = BitgetFuturesClient("key", "secret", "https://test")
    53:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    54: 
    55:     called = {}
    56: 
    57:     def fake_post(url, data=None, headers=None, timeout=None):
    58:         called["url"] = url
    59:         called["data"] = data
    60:         called["headers"] = headers
    61: 
    62:         class Resp:
    63:             def raise_for_status(self):
    64:                 pass
    65: 
    66:             def json(self):
    67:                 return {"success": True}
    68: 
    69:         return Resp()
    70: 
    71:     monkeypatch.setattr(bot.requests, "post", fake_post)
    72: 
    73:     resp = client._private_request("POST", "/api/test", body={"a": 1, "b": 2})
    74:     assert resp["success"] is True
    75:     body = json.dumps({"a": 1, "b": 2}, separators=(",", ":"), ensure_ascii=False)
    76:     prehash = f"1000POST/api/test{body}"
    77:     expected = base64.b64encode(
    78:         hmac.new(b"secret", prehash.encode(), hashlib.sha256).digest()
    79:     ).decode()
    80:     assert called["headers"]["ACCESS-SIGN"] == expected
    81:     assert called["headers"]["ACCESS-KEY"] == "key"
    82:     assert called["headers"]["ACCESS-TIMESTAMP"] == "1000"
    83:     assert called["headers"]["ACCESS-RECV-WINDOW"] == "30"
    84:     assert called["data"].decode("utf-8") == body
    85:     assert called["url"] == "https://test/api/test"
    86: 
    87: 
    88: def test_private_request_http_error(monkeypatch):
    89:     client = BitgetFuturesClient("key", "secret", "https://test")
    90:     monkeypatch.setattr(BitgetFuturesClient, "_ms", staticmethod(lambda: 1000))
    91: 
    92:     class Resp:
    93:         status_code = 418
    94: 
    95:         def raise_for_status(self):
    96:             raise bot.requests.HTTPError("teapot")
    97: 
    98:         def json(self):
    99:             return {"unused": True}
   100: 
   101:     monkeypatch.setattr(bot.requests, "request", lambda *a, **k: Resp())
   102: 
   103:     resp = client._private_request("GET", "/api/test")
   104:     assert resp["success"] is False
   105:     assert resp["status_code"] == 418
   106:     assert "teapot" in resp["error"]
   107: 
   108: 
   109: def test_get_assets_normalization(monkeypatch):
   110:     client = BitgetFuturesClient("key", "secret", "https://test")
   111: 
   112:     called = {}
   113: 
   114:     def fake_private(self, method, path, params=None, body=None):
   115:         called["method"] = method
   116:         called["path"] = path
   117:         called["params"] = params
   118:         return {"code": "00000", "data": [{"marginCoin": "usdt", "equity": "1"}]}
   119: 
   120:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   121: 
   122:     assets = client.get_assets()
   123: 
   124:     assert assets["success"] is True
   125:     usdt = assets.get("data", [])[0]
   126:     assert usdt["currency"].upper() == "USDT"
   127:     assert usdt["equity"] == 1.0
   128:     assert called["params"] == {"productType": "USDT-FUTURES", "marginCoin": "USDT"}
   129: 
   130: 
   131: def test_get_assets_equity_fallback(monkeypatch):
   132:     client = BitgetFuturesClient("key", "secret", "https://test")
   133: 
   134:     def fake_private(self, method, path, params=None, body=None):
   135:         return {"code": "00000", "data": [{"marginCoin": "USDT", "available": "2"}]}
   136: 
   137:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   138: 
   139:     assets = client.get_assets()
   140:     usdt = assets.get("data", [])[0]
   141:     assert usdt["currency"] == "USDT"
   142:     assert usdt["equity"] == 2.0
   143: 
   144: 
   145: def test_get_assets_prefers_available(monkeypatch):
   146:     """When both equity and available are returned, available should win."""
   147:     client = BitgetFuturesClient("key", "secret", "https://test")
   148: 
   149:     def fake_private(self, method, path, params=None, body=None):
   150:         return {
   151:             "code": "00000",
   152:             "data": [
   153:                 {
   154:                     "marginCoin": "USDT",
   155:                     "equity": "5",
   156:                     "available": "1",
   157:                 }
   158:             ],
   159:         }
   160: 
   161:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   162: 
   163:     assets = client.get_assets()
   164:     usdt = assets.get("data", [])[0]
   165:     assert usdt["equity"] == 1.0
   166: 
   167: 
   168: 
   169: def test_get_assets_zero_available(monkeypatch):
   170:     """Zero available balance should propagate as zero equity."""
   171:     client = BitgetFuturesClient("key", "secret", "https://test")
   172: 
   173:     def fake_private(self, method, path, params=None, body=None):
   174:         return {
   175:             "code": "00000",
   176:             "data": [
   177:                 {
   178:                     "marginCoin": "USDT",
   179:                     "available": "0",
   180:                     "equity": "5",
   181:                 }
   182:             ],
   183:         }
   184: 
   185:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   186: 
   187:     assets = client.get_assets()
   188:     usdt = assets.get("data", [])[0]
   189:     assert usdt["equity"] == 0.0
   190: 
   191: 
   192: def test_get_assets_available_balance(monkeypatch):
   193:     """Support alternative ``availableBalance`` field name."""
   194:     client = BitgetFuturesClient("key", "secret", "https://test")
   195: 
   196:     def fake_private(self, method, path, params=None, body=None):
   197:         return {
   198:             "code": "00000",
   199:             "data": [{"marginCoin": "USDT", "availableBalance": "3.5"}],
   200:         }
   201: 
   202:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   203: 
   204:     assets = client.get_assets()
   205:     usdt = assets.get("data", [])[0]
   206:     assert usdt["equity"] == 3.5
   207: 
   208: 
   209: def test_get_ticker_normalization(monkeypatch):
   210:     client = BitgetFuturesClient("key", "secret", "https://test")
   211: 
   212:     called = {}
   213: 
   214:     def fake_get(url, params=None, timeout=None):
   215:         called["url"] = url
   216:         called["params"] = params
   217: 
   218:         class Resp:
   219:             def raise_for_status(self):
   220:                 pass
   221: 
   222:             def json(self):
   223:                 return {
   224:                     "data": {
   225:                         "instId": "BTCUSDT",
   226:                         "lastPr": "1",
   227:                         "bestBidPrice": "0.9",
   228:                         "bestAskPrice": "1.1",
   229:                         "usdtVolume": "100",
   230:                     }
   231:                 }
   232: 
   233:         return Resp()
   234: 
   235:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   236: 
   237:     ticker = client.get_ticker("BTC_USDT")
   238: 
   239:     assert ticker["success"] is True
   240:     data = ticker["data"][0]
   241:     assert data["symbol"] == "BTCUSDT"
   242:     assert data["lastPrice"] == "1"
   243:     assert data["bidPrice"] == "0.9"
   244:     assert data["askPrice"] == "1.1"
   245:     assert data["volume"] == 100.0
   246:     assert called["params"] == {"symbol": "BTCUSDT", "productType": "USDT-FUTURES"}
   247: 
   248: 
   249: def test_http_client_context_manager(monkeypatch):
   250:     import sys
   251:     import importlib
   252:     sys.modules.pop('requests', None)
   253:     real_requests = importlib.import_module('requests')
   254:     sys.modules['requests'] = real_requests
   255:     import engine.client as http_client
   256:     importlib.reload(http_client)
   257: 
   258:     closed = {"count": 0}
   259: 
   260:     class DummySession:
   261:         def mount(self, *a, **k):
   262:             pass
   263: 
   264:         def request(self, *a, **k):
   265:             class Resp:
   266:                 def raise_for_status(self):
   267:                     pass
   268: 
   269:                 def json(self):
   270:                     return {}
   271: 
   272:                 text = "{}"
   273: 
   274:             return Resp()
   275: 
   276:         def close(self):
   277:             closed["count"] += 1
   278: 
   279:     monkeypatch.setattr(http_client.requests, "Session", lambda: DummySession())
   280: 
   281:     http = http_client.HttpClient("http://example.com")
   282:     http.close()
   283:     assert closed["count"] == 1
   284: 
   285:     closed["count"] = 0
   286:     with http_client.HttpClient("http://example.com") as hc:
   287:         hc.request("GET", "/")
   288:     assert closed["count"] == 1
   289: 
   290: 
   291: def test_get_kline_query_params(monkeypatch):
   292:     """Ensure ``get_kline`` hits the correct endpoint and passes symbol as a
   293:     query parameter. The previous implementation embedded the symbol in the
   294:     path which resulted in a 404 from Bitget."""
   295: 
   296:     client = BitgetFuturesClient("key", "secret", "https://test")
   297: 
   298:     called = {}
   299: 
   300:     def fake_get(url, params=None, timeout=None):
   301:         called["url"] = url
   302:         called["params"] = params
   303: 
   304:         class Resp:
   305:             def raise_for_status(self):
   306:                 pass
   307: 
   308:             def json(self):
   309:                 return {"data": []}
   310: 
   311:         return Resp()
   312: 
   313:     # Some tests replace ``bot.requests`` with a lightweight namespace that
   314:     # doesn't define ``get``. ``raising=False`` ensures the attribute is added
   315:     # even if missing so we can observe the call.
   316:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   317: 
   318:     client.get_kline("BTC_USDT", interval="Min1")
   319: 
   320:     assert called["url"].endswith("/api/v2/mix/market/candles")
   321:     assert called["params"] == {
   322:         "symbol": "BTCUSDT",
   323:         "productType": "USDT-FUTURES",
   324:         "granularity": "1m",
   325:     }
   326: 
   327: 
   328: def test_get_open_orders_endpoint(monkeypatch):
   329:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   330: 
   331:     called = {}
   332: 
   333:     def fake_private(self, method, path, params=None, body=None):
   334:         called["method"] = method
   335:         called["path"] = path
   336:         called["params"] = params
   337:         return {"success": True}
   338: 
   339:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   340: 
   341:     client.get_open_orders("BTCUSDT_UMCBL")
   342: 
   343:     assert called["path"] == "/api/v2/mix/order/orders-pending"
   344:     assert called["params"] == {
   345:         "productType": "USDT-FUTURES",
   346:         "symbol": "BTCUSDT",
   347:     }
   348: 
   349: 
   350: def test_product_type_alias():
   351:     client = BitgetFuturesClient("key", "secret", "https://test", product_type="umcbl")
   352:     assert client.product_type == "USDT-FUTURES"
   353: 
   354: 
   355: def test_get_contract_detail_endpoint(monkeypatch):
   356:     client = BitgetFuturesClient("key", "secret", "https://test")
   357: 
   358:     called = {}
   359: 
   360:     def fake_get(url, params=None, timeout=None):
   361:         called["url"] = url
   362:         called["params"] = params
   363: 
   364:         class Resp:
   365:             status_code = 200
   366: 
   367:             def raise_for_status(self):
   368:                 pass
   369: 
   370:             def json(self):
   371:                 return {"data": []}
   372: 
   373:         return Resp()
   374: 
   375:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   376: 
   377:     client.get_contract_detail("BTCUSDT_UMCBL")
   378: 
   379:     assert called["url"].endswith("/api/v2/mix/market/contracts")
   380:     assert called["params"] == {
   381:         "productType": "USDT-FUTURES",
   382:         "symbol": "BTCUSDT",
   383:     }
   384: 
   385: 
   386: def test_cancel_all_endpoint(monkeypatch):
   387:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   388: 
   389:     called = {}
   390: 
   391:     def fake_private(self, method, path, params=None, body=None):
   392:         called["method"] = method
   393:         called["path"] = path
   394:         called["params"] = params
   395:         called["body"] = body
   396:         return {"success": True}
   397: 
   398:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   399: 
   400:     client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   401: 
   402:     assert called["method"] == "POST"
   403:     assert called["path"] == "/api/v2/mix/order/cancel-all-orders"
   404:     assert called["params"] is None
   405:     assert called["body"] == {
   406:         "productType": "USDT-FUTURES",
   407:         "symbol": "BTCUSDT",
   408:         "marginCoin": "USDT",
   409:     }
   410: 
   411: 
   412: def test_place_order_endpoint(monkeypatch):
   413:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   414: 
   415:     called = {}
   416: 
   417:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   418: 
   419:     def fake_private(self, method, path, params=None, body=None):
   420:         called["method"] = method
   421:         called["path"] = path
   422:         called["body"] = body
   423:         return {"success": True}
   424: 
   425:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   426: 
   427:     resp = client.place_order("BTCUSDT_UMCBL", side=1, vol=1, order_type=1)
   428: 
   429:     assert resp["success"] is True
   430:     assert called["method"] == "POST"
   431:     assert called["path"] == "/api/v2/mix/order/place-order"
   432:     body = called["body"]
   433:     assert body["symbol"] == "BTCUSDT"
   434:     assert body["marginCoin"] == "USDT"
   435:     assert body["marginMode"] == "crossed"
   436:     assert body["side"] == "buy"
   437:     assert body["posSide"] == "long"
   438:     assert "reduceOnly" not in body
   439:     assert body["posMode"] == "hedge_mode"
   440: 
   441: 
   442: @pytest.mark.parametrize(
   443:     "code, side_str, pos_side",
   444:     [
   445:         (4, "sell", "long"),
   446:         (2, "buy", "short"),
   447:     ],
   448: )
   449: def test_place_order_close_positions(monkeypatch, code, side_str, pos_side):
   450:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   451: 
   452:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (0, 0))
   453: 
   454:     called = {}
   455: 
   456:     def fake_private(self, method, path, params=None, body=None):
   457:         called["body"] = body
   458:         return {"success": True}
   459: 
   460:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   461: 
   462:     client.place_order("BTCUSDT_UMCBL", side=code, vol=1, order_type=1)
   463: 
   464:     body = called["body"]
   465:     assert body["side"] == side_str
   466:     assert body["posSide"] == pos_side
   467:     assert "reduceOnly" not in body
   468: 
   469: 
   470: def test_place_order_precision(monkeypatch):
   471:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   472: 
   473:     monkeypatch.setattr(BitgetFuturesClient, "_get_contract_precision", lambda self, symbol: (2, 3))
   474: 
   475:     called = {}
   476: 
   477:     def fake_private(self, method, path, params=None, body=None):
   478:         called["body"] = body
   479:         return {"success": True}
   480: 
   481:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   482: 
   483:     client.place_order(
   484:         "BTCUSDT_UMCBL", side=1, vol=1.23456, order_type=1, price=1234.5678
   485:     )
   486: 
   487:     assert called["body"]["price"] == 1234.57
   488:     assert called["body"]["size"] == 1.235
   489: 
   490: 
   491: def test_margin_cap_skips_order(monkeypatch):
   492:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   493:     called = {}
   494: 
   495:     def fake_private(method, path, **kwargs):
   496:         called["path"] = path
   497:         return {"code": "00000"}
   498: 
   499:     monkeypatch.setattr(client, "_private_request", fake_private)
   500:     contract_detail = {
   501:         "data": {
   502:             "symbol": "BTCUSDT_UMCBL",
   503:             "contractSize": 1,
   504:             "volUnit": 1,
   505:             "minVol": 1,
   506:             "minTradeUSDT": 5,
   507:         }
   508:     }
   509:     price = 100.0
   510:     available = 0.5
   511:     vol = bot.compute_position_size(
   512:         contract_detail,
   513:         equity_usdt=available,
   514:         price=price,
   515:         risk_pct=1.0,
   516:         leverage=10,
   517:         symbol="BTCUSDT_UMCBL",
   518:         available_usdt=available,
   519:     )
   520:     if vol > 0:
   521:         client.place_order(
   522:             "BTCUSDT_UMCBL", side=1, vol=vol, order_type=1, price=price, leverage=10
   523:         )
   524:     assert called == {}
   525: 
   526: 
   527: def test_margin_cap_reduces_volume(monkeypatch):
   528:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=False)
   529:     called = {}
   530: 
   531:     def fake_private(method, path, **kwargs):
   532:         called["body"] = kwargs.get("body")
   533:         return {"code": "00000"}
   534: 
   535:     monkeypatch.setattr(client, "_private_request", fake_private)
   536:     contract_detail = {
   537:         "data": {
   538:             "symbol": "BTCUSDT_UMCBL",
   539:             "contractSize": 1,
   540:             "volUnit": 1,
   541:             "minVol": 1,
   542:             "minTradeUSDT": 5,
   543:         }
   544:     }
   545:     price = 10.0
   546:     vol_theoretical = bot.compute_position_size(
   547:         contract_detail,
   548:         equity_usdt=100,
   549:         price=price,
   550:         risk_pct=1.0,
   551:         leverage=10,
   552:         symbol="BTCUSDT_UMCBL",
   553:     )
   554:     available = 20.0
   555:     vol_final = bot.compute_position_size(
   556:         contract_detail,
   557:         equity_usdt=available,
   558:         price=price,
   559:         risk_pct=1.0,
   560:         leverage=10,
   561:         symbol="BTCUSDT_UMCBL",
   562:         available_usdt=available,
   563:     )
   564:     assert vol_final < vol_theoretical
   565:     client.place_order(
   566:         "BTCUSDT_UMCBL", side=1, vol=vol_final, order_type=1, price=price, leverage=10
   567:     )
   568:     assert called["body"]["size"] == vol_final
   569: 
   570: def test_get_open_orders_paper_trade(monkeypatch):
   571:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   572: 
   573:     called = {"count": 0}
   574: 
   575:     def fake_private(*a, **k):
   576:         called["count"] += 1
   577:         return {"success": True}
   578: 
   579:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   580: 
   581:     resp = client.get_open_orders("BTCUSDT_UMCBL")
   582: 
   583:     assert resp["success"] is True
   584:     assert resp["data"] == []
   585:     assert called["count"] == 0
   586: 
   587: 
   588: def test_cancel_all_paper_trade(monkeypatch):
   589:     client = BitgetFuturesClient("key", "secret", "https://test", paper_trade=True)
   590: 
   591:     called = {"count": 0}
   592: 
   593:     def fake_private(*a, **k):
   594:         called["count"] += 1
   595:         return {"success": True}
   596: 
   597:     monkeypatch.setattr(BitgetFuturesClient, "_private_request", fake_private)
   598: 
   599:     resp = client.cancel_all("BTCUSDT_UMCBL", margin_coin="USDT")
   600: 
   601:     assert resp["success"] is True
   602:     assert called["count"] == 0
   603: 
   604: 
   605: def test_get_kline_transforms_data(monkeypatch):
   606:     client = BitgetFuturesClient("key", "secret", "https://test")
   607: 
   608:     def fake_get(url, params=None, timeout=None):
   609:         class Resp:
   610:             def raise_for_status(self):
   611:                 pass
   612: 
   613:             def json(self):
   614:                 return {
   615:                     "data": [
   616:                         ["1", "2", "3", "1", "2", "10", "20"],
   617:                         ["2", "3", "4", "2", "3", "11", "21"],
   618:                     ]
   619:                 }
   620: 
   621:         return Resp()
   622: 
   623:     monkeypatch.setattr(bot.requests, "get", fake_get, raising=False)
   624: 
   625:     data = client.get_kline("BTC_USDT", interval="1m")
   626:     kdata = data["data"]
   627:     assert kdata["open"] == [2.0, 3.0]
   628:     assert kdata["high"] == [3.0, 4.0]
   629:     assert kdata["low"] == [1.0, 2.0]
   630:     assert kdata["close"] == [2.0, 3.0]
   631:     assert kdata["volume"] == [10.0, 11.0]
   632:     assert kdata["quoteVolume"] == [20.0, 21.0]

--------------------------------------------------------------------------------
FILE: tests/test_compute_position_size.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules["requests"] = types.ModuleType("requests")
     8: import bot  # noqa: E402
     9: from bot import compute_position_size  # noqa: E402
    10: 
    11: 
    12: def test_compute_position_size_basic():
    13:     contract_detail = {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.01,
    18:                 "volUnit": 1,
    19:                 "minVol": 1,
    20:             }
    21:         ]
    22:     }
    23:     vol = compute_position_size(contract_detail, equity_usdt=1000, price=50000,
    24:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    25:     assert vol == 1
    26: 
    27: 
    28: def test_compute_position_size_symbol_not_found():
    29:     contract_detail = {"data": [{"symbol": "ETH_USDT", "contractSize": 0.1}]}
    30:     with pytest.raises(ValueError):
    31:         compute_position_size(contract_detail, equity_usdt=1000, price=500,
    32:                                 risk_pct=0.01, leverage=10, symbol="BTC_USDT")
    33: 
    34: 
    35: def test_compute_position_size_invalid_price():
    36:     contract_detail = {
    37:         "data": [
    38:             {
    39:                 "symbol": "BTC_USDT",
    40:                 "contractSize": 0.01,
    41:                 "volUnit": 1,
    42:                 "minVol": 1,
    43:             }
    44:         ]
    45:     }
    46:     vol = compute_position_size(
    47:         contract_detail,
    48:         equity_usdt=1000,
    49:         price=0,
    50:         risk_pct=0.01,
    51:         leverage=10,
    52:         symbol="BTC_USDT",
    53:     )
    54:     assert vol == 0
    55: 
    56: 
    57: def test_compute_position_size_respects_equity():
    58:     contract_detail = {
    59:         "data": [
    60:             {
    61:                 "symbol": "BTC_USDT",
    62:                 "contractSize": 1,
    63:                 "volUnit": 1,
    64:                 "minVol": 1,
    65:             }
    66:         ]
    67:     }
    68:     vol = compute_position_size(
    69:         contract_detail,
    70:         equity_usdt=5,
    71:         price=100,
    72:         risk_pct=0.01,
    73:         leverage=10,
    74:         symbol="BTC_USDT",
    75:     )
    76:     assert vol == 0
    77: 
    78: 
    79: def test_compute_position_size_leaves_fee_buffer():
    80:     contract_detail = {
    81:         "data": [
    82:             {
    83:                 "symbol": "BTC_USDT",
    84:                 "contractSize": 1,
    85:                 "volUnit": 1,
    86:                 "minVol": 1,
    87:             }
    88:         ]
    89:     }
    90:     vol = compute_position_size(
    91:         contract_detail,
    92:         equity_usdt=100,
    93:         price=100,
    94:         risk_pct=1.0,
    95:         leverage=1,
    96:         symbol="BTC_USDT",
    97:     )
    98:     assert vol == 0
    99: 
   100: 
   101: def test_compute_position_size_under_min_notional_returns_zero():
   102:     contract_detail = {
   103:         "data": [
   104:             {
   105:                 "symbol": "PI_USDT",
   106:                 "contractSize": 1,
   107:                 "volUnit": 1,
   108:                 "minVol": 1,
   109:                 "minTradeUSDT": 5,
   110:             }
   111:         ]
   112:     }
   113:     vol = compute_position_size(
   114:         contract_detail,
   115:         equity_usdt=100,
   116:         price=0.5,
   117:         risk_pct=0.0001,
   118:         leverage=20,
   119:         symbol="PI_USDT",
   120:     )
   121:     assert vol == 0
   122: 
   123: 
   124: def test_compute_position_size_cap_by_available():
   125:     contract_detail = {
   126:         "data": [
   127:             {
   128:                 "symbol": "BTC_USDT",
   129:                 "contractSize": 1,
   130:                 "volUnit": 2,
   131:                 "minVol": 2,
   132:                 "minTradeUSDT": 5,
   133:             }
   134:         ]
   135:     }
   136:     vol = compute_position_size(
   137:         contract_detail,
   138:         equity_usdt=100,
   139:         price=10,
   140:         risk_pct=0.5,
   141:         leverage=10,
   142:         symbol="BTC_USDT",
   143:         available_usdt=0.5,
   144:     )
   145:     assert vol == 0
   146:     vol = compute_position_size(
   147:         contract_detail,
   148:         equity_usdt=100,
   149:         price=10,
   150:         risk_pct=0.5,
   151:         leverage=10,
   152:         symbol="BTC_USDT",
   153:         available_usdt=10,
   154:     )
   155:     assert vol == 8
   156:     fee_rate = max(bot.CONFIG.get("FEE_RATE", 0.0), 0.001)
   157:     required = (10 * 1 * vol / 10 + fee_rate * 10 * 1 * vol) * 1.03
   158:     assert required <= 10

--------------------------------------------------------------------------------
FILE: tests/test_compute_position_size_cap.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import types
     4: import pytest
     5: 
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: sys.modules['requests'] = types.ModuleType('requests')
     8: 
     9: from bot import compute_position_size, CONFIG
    10: 
    11: 
    12: def _detail(vol_unit=1, min_vol=1, min_trade=5):
    13:     return {
    14:         "data": [
    15:             {
    16:                 "symbol": "BTC_USDT",
    17:                 "contractSize": 0.001,
    18:                 "volUnit": vol_unit,
    19:                 "minVol": min_vol,
    20:                 "minTradeUSDT": min_trade,
    21:             }
    22:         ]
    23:     }
    24: 
    25: 
    26: def test_volume_zero_when_available_low():
    27:     detail = _detail()
    28:     vol = compute_position_size(
    29:         detail,
    30:         equity_usdt=1000,
    31:         price=10000,
    32:         risk_pct=0.01,
    33:         leverage=10,
    34:         symbol="BTC_USDT",
    35:         available_usdt=0.5,
    36:     )
    37:     assert vol == 0
    38: 
    39: 
    40: def test_margin_close_to_available():
    41:     detail = _detail()
    42:     CONFIG["FEE_RATE"] = 0.001
    43:     available = 1.05
    44:     vol = compute_position_size(
    45:         detail,
    46:         equity_usdt=1000,
    47:         price=10000,
    48:         risk_pct=1,
    49:         leverage=10,
    50:         symbol="BTC_USDT",
    51:         available_usdt=available,
    52:     )
    53:     assert vol == 1
    54:     notional = 10000 * 0.001 * vol
    55:     fee = max(CONFIG.get("FEE_RATE", 0.0), 0.001) * notional
    56:     required = (notional / 10 + fee) * 1.03
    57:     assert required == pytest.approx(available, rel=0.05)
    58: 
    59: 
    60: def test_respects_units_and_minimums():
    61:     detail = _detail(vol_unit=2, min_vol=2, min_trade=5)
    62:     vol = compute_position_size(
    63:         detail,
    64:         equity_usdt=1000,
    65:         price=1000,
    66:         risk_pct=1,
    67:         leverage=5,
    68:         symbol="BTC_USDT",
    69:         available_usdt=1000,
    70:     )
    71:     assert vol % 2 == 0 and vol >= 2

--------------------------------------------------------------------------------
FILE: tests/test_dynamic_allocation.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import math
     2: from engine.risk import adjust_risk_pct
     3: 
     4: 
     5: def test_adjust_risk_pct_increase_decrease():
     6:     base = 0.01
     7:     assert adjust_risk_pct(base, win_streak=2, loss_streak=0) > base
     8:     assert adjust_risk_pct(base, win_streak=0, loss_streak=2) < base
     9: 
    10: 
    11: def test_adjust_risk_pct_bounds():
    12:     assert math.isclose(
    13:         adjust_risk_pct(0.05, win_streak=2, loss_streak=0, max_pct=0.05), 0.05
    14:     )
    15:     assert math.isclose(
    16:         adjust_risk_pct(0.001, win_streak=0, loss_streak=2, min_pct=0.001), 0.001
    17:     )

--------------------------------------------------------------------------------
FILE: tests/test_effective_leverage.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import pytest
     2: from engine.trade_utils import effective_leverage
     3: 
     4: 
     5: def test_effective_leverage_basic():
     6:     lev = effective_leverage(
     7:         entry_price=100.0,
     8:         liquidation_price=90.0,
     9:         position_margin=10.0,
    10:         position_size=1.0,
    11:     )
    12:     assert lev == pytest.approx(10.0)
    13: 
    14: 
    15: def test_effective_leverage_estimated_margin():
    16:     lev = effective_leverage(
    17:         entry_price=200.0,
    18:         liquidation_price=180.0,
    19:         position_margin=0.0,
    20:         position_size=2.0,
    21:     )
    22:     # price diff 20 * size 2 -> margin 40; notional 400
    23:     assert lev == pytest.approx(10.0)
    24: 
    25: 
    26: def test_effective_leverage_short_position():
    27:     lev = effective_leverage(
    28:         entry_price=100.0,
    29:         liquidation_price=110.0,
    30:         position_margin=10.0,
    31:         position_size=-1.5,
    32:     )
    33:     assert lev == pytest.approx(15.0)
    34: 
    35: 
    36: def test_effective_leverage_invalid():
    37:     assert effective_leverage(0, 0, 0, 0) == 0.0

--------------------------------------------------------------------------------
FILE: tests/test_env_loading.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: """Tests for loading environment variables from ``notebook/.env``."""
     2: 
     3: from __future__ import annotations
     4: 
     5: import importlib
     6: import os
     7: import sys
     8: from pathlib import Path
     9: 
    10: 
    11: def test_parent_env_loaded(tmp_path, monkeypatch) -> None:
    12:     """Module should load variables from ``notebook/.env`` if present."""
    13: 
    14:     notebook = tmp_path / "notebook"
    15:     spot = notebook / "spot"
    16:     spot.mkdir(parents=True)
    17:     bitget_bot = spot / "bitget_bot.py"
    18:     bitget_bot.write_text("")
    19:     env_file = notebook / ".env"
    20:     env_file.write_text("BITGET_ACCESS_KEY=from_env\n")
    21: 
    22:     old = os.environ.pop("BITGET_ACCESS_KEY", None)
    23:     monkeypatch.setattr(sys, "argv", [str(bitget_bot)])
    24:     import scalp
    25: 
    26:     importlib.reload(scalp)
    27: 
    28:     try:
    29:         assert os.getenv("BITGET_ACCESS_KEY") == "from_env"
    30:     finally:
    31:         env_file.unlink(missing_ok=True)
    32:         if old is None:
    33:             os.environ.pop("BITGET_ACCESS_KEY", None)
    34:         else:
    35:             os.environ["BITGET_ACCESS_KEY"] = old

--------------------------------------------------------------------------------
FILE: tests/test_grid_search.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import json
     2: import random
     3: 
     4: import pytest
     5: 
     6: from engine.backtest import grid_search
     7: 
     8: 
     9: def test_build_grid_sampling():
    10:     param_lists = {
    11:         "timeframe": ["1m", "5m", "15m"],
    12:         "score_min": [50, 55, 60],
    13:         "atr_min_ratio": [0.0015, 0.002, 0.003],
    14:     }
    15:     combos = grid_search.build_param_grid(param_lists, grid_max=6)
    16:     assert len(combos) == 6
    17:     tfs = {c["timeframe"] for c in combos}
    18:     assert {"1m", "5m", "15m"}.issubset(tfs)
    19: 
    20: 
    21: def test_run_grid_search_with_mock(tmp_path):
    22:     calls = []
    23: 
    24:     def fake_run_backtest_multi(**kwargs):
    25:         tf = kwargs.get("timeframe")
    26:         risk = kwargs.get("risk_pct")
    27:         # fabricate metrics based on params
    28:         pf = {"1m": 1.5, "5m": 3.0}[tf]
    29:         pf += risk  # tiny variation
    30:         metrics = {
    31:             "symbol": "TOTAL",
    32:             "pnl_usdt": 100 * risk,
    33:             "profit_factor": pf,
    34:             "max_drawdown_pct": 5.0 if tf == "1m" else 3.0,
    35:             "winrate_pct": 50.0,
    36:             "trades": 40 if tf == "1m" else 30,
    37:         }
    38:         calls.append((tf, risk))
    39:         return [metrics], []
    40: 
    41:     param_lists = {
    42:         "timeframe": ["1m", "5m"],
    43:         "risk_pct": [0.005, 0.01],
    44:     }
    45:     base_params = {
    46:         "timeframe": "1m",
    47:         "risk_pct": 0.005,
    48:     }
    49:     out_dir = tmp_path / "grid"
    50:     grid_search.run_grid_search(
    51:         symbols=["BTC/USDT"],
    52:         exchange="csv",
    53:         base_params=base_params,
    54:         param_lists=param_lists,
    55:         grid_max=4,
    56:         csv_dir="/dev/null",
    57:         out_dir=str(out_dir),
    58:         run_func=fake_run_backtest_multi,
    59:     )
    60:     best = json.loads((out_dir / "best_config.json").read_text())
    61:     # best PF should be timeframe 5m risk 0.01
    62:     assert best["params"]["timeframe"] == "5m"
    63:     assert best["params"]["risk_pct"] == 0.01
    64:     assert len(calls) == 4
    65: 
    66: 
    67: def test_parse_hours():
    68:     assert grid_search.parse_hours("7-11,13-17") == [7, 8, 9, 10, 11, 13, 14, 15, 16, 17]
    69: 
    70: 
    71: def test_deterministic_results(tmp_path):
    72:     def fake_run_backtest_multi(**kwargs):
    73:         # metrics vary with global random state
    74:         pf = random.uniform(1.0, 3.0)
    75:         metrics = {
    76:             "symbol": "TOTAL",
    77:             "pnl_usdt": random.uniform(-10, 10),
    78:             "profit_factor": pf,
    79:             "max_drawdown_pct": random.uniform(1, 5),
    80:             "winrate_pct": 50.0,
    81:             "trades": random.randint(10, 50),
    82:         }
    83:         return [metrics], []
    84: 
    85:     param_lists = {"timeframe": ["1m", "5m"]}
    86:     base_params = {"timeframe": "1m"}
    87:     out_dir = tmp_path / "grid"
    88:     res1 = grid_search.run_grid_search(
    89:         symbols=["BTC/USDT"],
    90:         exchange="csv",
    91:         base_params=base_params,
    92:         param_lists=param_lists,
    93:         grid_max=2,
    94:         csv_dir="/dev/null",
    95:         out_dir=str(out_dir),
    96:         seed=42,
    97:         run_func=fake_run_backtest_multi,
    98:     )
    99:     best1 = json.loads((out_dir / "best_config.json").read_text())
   100:     # run again
   101:     out_dir2 = tmp_path / "grid2"
   102:     res2 = grid_search.run_grid_search(
   103:         symbols=["BTC/USDT"],
   104:         exchange="csv",
   105:         base_params=base_params,
   106:         param_lists=param_lists,
   107:         grid_max=2,
   108:         csv_dir="/dev/null",
   109:         out_dir=str(out_dir2),
   110:         seed=42,
   111:         run_func=fake_run_backtest_multi,
   112:     )
   113:     best2 = json.loads((out_dir2 / "best_config.json").read_text())
   114:     assert best1 == best2
   115:     # also ensure results object same best params
   116:     assert res1[0].params == res2[0].params

--------------------------------------------------------------------------------
FILE: tests/test_heat_score.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from engine.pairs import heat_score, select_top_heat_pairs, decorrelate_pairs
     2: 
     3: 
     4: def test_heat_score_value():
     5:     assert heat_score(2.0, 100.0) == 200.0
     6:     assert heat_score(2.0, 100.0, news=True) == 400.0
     7: 
     8: 
     9: def test_select_and_decorrelate_pairs():
    10:     pairs = [
    11:         {"symbol": "A", "volatility": 2, "volume": 100, "news": True},
    12:         {"symbol": "B", "volatility": 1, "volume": 200, "news": False},
    13:         {"symbol": "C", "volatility": 1.5, "volume": 150, "news": False},
    14:         {"symbol": "D", "volatility": 3, "volume": 50, "news": True},
    15:     ]
    16:     top = select_top_heat_pairs(pairs, top_n=3)
    17:     assert len(top) == 3
    18:     corr = {"A": {"B": 0.9}, "B": {"A": 0.9}, "C": {}, "D": {}}
    19:     selected = decorrelate_pairs(pairs, corr, threshold=0.8, top_n=3)
    20:     syms = {p["symbol"] for p in selected}
    21:     assert not ("A" in syms and "B" in syms)

--------------------------------------------------------------------------------
FILE: tests/test_indicators.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: 
     2: 
     3: import os
     4: import sys
     5: import pytest
     6: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     7: 
     8: 
     9: 
    10: 
    11: from engine.metrics import calc_rsi, calc_atr, calc_macd
    12: 
    13: 
    14: def test_calc_rsi_uptrend():
    15:     prices = list(range(1, 16))  # strictly increasing
    16:     assert calc_rsi(prices, period=14) == pytest.approx(100.0)
    17: 
    18: 
    19: def test_calc_rsi_downtrend():
    20:     prices = list(range(15, 0, -1))  # strictly decreasing
    21:     assert calc_rsi(prices, period=14) == pytest.approx(0.0)
    22: 
    23: 
    24: 
    25: def test_calc_rsi_flat():
    26:     prices = [1.0] * 15  # no movement
    27:     assert calc_rsi(prices, period=14) == pytest.approx(50.0)
    28: 
    29: 
    30: 
    31:     highs = [10, 11, 12, 13, 14]
    32:     lows = [9, 10, 11, 12, 13]
    33:     closes = [9.5, 10.5, 11.5, 12.5, 13.5]
    34:     assert calc_atr(highs, lows, closes, period=3) == pytest.approx(1.5)
    35: 
    36: 
    37: def test_calc_macd_trend():
    38:     prices = list(range(1, 60))
    39:     macd, signal, hist = calc_macd(prices)
    40:     assert macd > signal
    41:     assert hist > 0
    42: 
    43: 
    44: def test_calc_macd_flat():
    45:     prices = [100.0] * 60
    46:     macd, signal, hist = calc_macd(prices)
    47:     assert macd == pytest.approx(0.0)
    48:     assert signal == pytest.approx(0.0)
    49:     assert hist == pytest.approx(0.0)
    50: 
    51: 
    52: 
    53: @pytest.mark.parametrize("prices, period", [([1, 2, 3], 0), ([1, 2, 3], 5)])
    54: def test_calc_rsi_invalid_inputs(prices, period):
    55:     with pytest.raises(ValueError):
    56:         calc_rsi(prices, period=period)
    57: 
    58: 
    59: @pytest.mark.parametrize(
    60:     "highs, lows, closes, period",
    61:     [
    62:         ([1, 2, 3], [1, 2], [1, 2, 3], 2),
    63:         ([1, 2], [1, 1], [1, 1], 3),
    64:     ],
    65: )
    66: def test_calc_atr_invalid_inputs(highs, lows, closes, period):
    67:     with pytest.raises(ValueError):
    68:         calc_atr(highs, lows, closes, period=period)
    69: 

--------------------------------------------------------------------------------
FILE: tests/test_min_qty_rules.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import os
     2: import sys
     3: import types
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import _apply_contract_checks
     9: 
    10: 
    11: def _detail():
    12:     return {
    13:         "data": [
    14:             {
    15:                 "symbol": "BTC_USDT",
    16:                 "contractSize": 1,
    17:                 "volUnit": 5,
    18:                 "minVol": 10,
    19:                 "minTradeUSDT": 5,
    20:             }
    21:         ]
    22:     }
    23: 
    24: 
    25: def test_min_qty_floor_and_validation():
    26:     detail = _detail()
    27:     vol, N, req = _apply_contract_checks(1, 13, 10, 100, detail, "BTC_USDT")
    28:     assert vol == 10
    29:     vol2, N2, req2 = _apply_contract_checks(1, 7, 10, 100, detail, "BTC_USDT")
    30:     assert vol2 == 0

--------------------------------------------------------------------------------
FILE: tests/test_notifier.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import engine.notifier as notifier
     2: 
     3: 
     4: def test_notify_skips_without_targets(monkeypatch):
     5:     called = False
     6: 
     7:     def fake_post(url, json=None, timeout=5):  # pragma: no cover - fallback
     8:         nonlocal called
     9:         called = True
    10: 
    11:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    12:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    13:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    14:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    15:     notifier.notify("test", {"foo": 1})
    16:     assert called is False
    17: 
    18: 
    19: def test_notify_posts_http(monkeypatch):
    20:     payload = {}
    21: 
    22:     def fake_post(url, json=None, timeout=5):
    23:         payload["url"] = url
    24:         payload["json"] = json
    25:         payload["timeout"] = timeout
    26: 
    27:     monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    28:     monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
    29:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    30:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    31:     notifier.notify("evt", {"bar": 2})
    32:     assert payload["url"] == "http://example.com"
    33:     assert payload["json"]["event"] == "evt"
    34:     assert payload["json"]["bar"] == 2
    35: 
    36: 
    37: def test_notify_posts_telegram(monkeypatch):
    38:     payload = {}
    39: 
    40:     def fake_post(url, json=None, timeout=5):
    41:         payload["url"] = url
    42:         payload["json"] = json
    43:         payload["timeout"] = timeout
    44: 
    45:     monkeypatch.delenv("NOTIFY_URL", raising=False)
    46:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    47:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    48:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    49: 
    50:     notifier.notify("evt", {"bar": 2})
    51: 
    52:     assert payload["url"] == "https://api.telegram.org/botabc/sendMessage"
    53:     assert payload["json"]["chat_id"] == "123"
    54:     assert "evt" in payload["json"]["text"]
    55: 
    56: 
    57: def test_notify_posts_both(monkeypatch):
    58:     calls = []
    59: 
    60:     def fake_post(url, json=None, timeout=5):
    61:         calls.append({"url": url, "json": json, "timeout": timeout})
    62: 
    63:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    64:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    65:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    66:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    67: 
    68:     notifier.notify("evt", {"bar": 2})
    69: 
    70:     assert len(calls) == 2
    71:     urls = {c["url"] for c in calls}
    72:     assert "http://example.com" in urls
    73:     assert "https://api.telegram.org/botabc/sendMessage" in urls
    74: 
    75: 
    76: def test_notify_skips_telegram_for_pair_list(monkeypatch):
    77:     calls = []
    78: 
    79:     def fake_post(url, json=None, timeout=5):
    80:         calls.append(url)
    81: 
    82:     monkeypatch.setenv("NOTIFY_URL", "http://example.com")
    83:     monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "abc")
    84:     monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
    85:     monkeypatch.setattr(notifier.requests, "post", fake_post)
    86: 
    87:     notifier.notify("pair_list", {"pairs": "BTC"})
    88: 
    89:     # Only the generic webhook should be called, not Telegram
    90:     assert calls == ["http://example.com"]
    91: 
    92: 
    93: def test_format_text_open_position():
    94:     payload = {
    95:         "symbol": "BTCUSDT",
    96:         "side": "short",
    97:         "price": 18350,
    98:         "vol": 37,
    99:         "contract_size": 1,
   100:         "notional_usdt": 120.5,
   101:         "leverage": 5,
   102:         "required_margin_usdt": 25.3,
   103:         "available_usdt": 134,
   104:         "risk_level_user": 3,
   105:         "signal_level": 2,
   106:         "risk_color": "🟡",
   107:         "risk_pct_eff": 0.01,
   108:         "fee_rate": 0.001,
   109:     }
   110:     text = notifier._format_text("position_opened", payload)
   111:     lines = text.splitlines()
   112: 
   113:     assert lines[0] == "🟡 Ouvre short BTC"
   114:     assert lines[1] == "Notional: 120.5 USDT   Levier: x5"
   115:     assert lines[2] == "Marge estimée: 25.3 USDT (dispo: 134 USDT)"
   116:     assert lines[3] == "Risque: lvl 2/3 (risk_pct=1.0000%)"
   117:     assert lines[4] == "Prix: 18350   Vol: 37 (cs=1)"
   118: 
   119: 
   120: def test_format_text_closed_position():
   121:     payload = {
   122:         "symbol": "BTCUSDT",
   123:         "side": "short",
   124:         "entry_price": 18350,
   125:         "exit_price": 18328,
   126:         "vol": 37,
   127:         "contract_size": 1,
   128:         "notional_entry_usdt": 120.5,
   129:         "notional_exit_usdt": 120.3,
   130:         "fees_usdt": 0.03,
   131:         "pnl_usdt": 0.84,
   132:         "pnl_pct_on_margin": 3.25,
   133:         "leverage": 5,
   134:         "risk_color": "🟡",
   135:         "fee_rate": 0.001,
   136:     }
   137:     text = notifier._format_text("position_closed", payload)
   138:     lines = text.splitlines()
   139:     assert lines[0] == "Ferme short BTC 🟡"
   140:     assert lines[1] == "PnL net: +0.84 USDT (frais: 0.03)"
   141:     assert lines[2] == "% sur marge: 3.25%"
   142:     assert lines[3] == "Entrée: 18350  Sortie: 18328"
   143:     assert lines[4] == "Vol: 37  Notional: in 120.5 → out 120.3 USDT"
   144: 
   145: 
   146: def test_format_text_pair_list_and_start():
   147:     assert notifier._format_text("bot_started") == "🤖 Bot démarré"
   148:     text = notifier._format_text(
   149:         "pair_list", {"green": "AAA", "orange": "BBB", "red": "CCC"}
   150:     )
   151:     assert text == "Listing ok"
   152: 
   153: 
   154: def test_format_pair_list_helper():
   155:     payload = {"green": "AAA", "orange": "BBB", "red": "CCC"}
   156:     text = notifier._format_pair_list(payload)
   157:     assert text == "Listing ok"
   158: 
   159: 
   160: def test_format_position_event_helper():
   161:     payload = {
   162:         "symbol": "BTCUSDT",
   163:         "side": "short",
   164:         "price": 18350,
   165:         "vol": 37,
   166:         "contract_size": 1,
   167:         "notional_usdt": 120.5,
   168:         "leverage": 5,
   169:         "required_margin_usdt": 25.3,
   170:         "available_usdt": 134,
   171:         "risk_level_user": 3,
   172:         "signal_level": 2,
   173:         "risk_color": "🟡",
   174:         "risk_pct_eff": 0.01,
   175:         "fee_rate": 0.001,
   176:     }
   177:     text = notifier._format_position_event("position_opened", payload)
   178:     assert text.splitlines()[0] == "🟡 Ouvre short BTC"
   179: 
   180: 

--------------------------------------------------------------------------------
FILE: tests/test_notional_and_pnl_units.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import os, sys, types, pytest
     2: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     3: sys.modules['requests'] = types.ModuleType('requests')
     4: 
     5: from engine.trade_utils import (
     6:     get_contract_size,
     7:     notional as calc_notional,
     8:     required_margin as calc_required_margin,
     9:     compute_pnl_usdt,
    10:     compute_pnl_with_fees,
    11: )
    12: 
    13: 
    14: def _detail():
    15:     return {"data": [{"symbol": "BTC_USDT", "contractSize": 0.001}]}
    16: 
    17: 
    18: def test_notional_and_pnl_units():
    19:     detail = _detail()
    20:     cs = get_contract_size(detail, "BTC_USDT")
    21:     N = calc_notional(10000, 2, cs)
    22:     assert N == pytest.approx(10000 * 0.001 * 2)
    23:     margin = calc_required_margin(N, 10, 0.001, buffer=0.0)
    24:     assert margin == pytest.approx(N / 10 + 0.001 * N)
    25:     pnl = compute_pnl_usdt(detail, 10000, 10100, 2, 1, symbol="BTC_USDT")
    26:     assert pnl == pytest.approx((10100 - 10000) * 0.001 * 2)
    27:     pnl_net, pct = compute_pnl_with_fees(
    28:         detail, 10000, 10100, 2, 1, 10, 0.001, symbol="BTC_USDT"
    29:     )
    30:     gross = (10100 - 10000) * cs * 2
    31:     fees = 0.001 * (calc_notional(10000, 2, cs) + calc_notional(10100, 2, cs))
    32:     expected = gross - fees
    33:     expected_pct = expected / (N / 10) * 100
    34:     assert pnl_net == pytest.approx(expected)
    35:     assert pct == pytest.approx(expected_pct)

--------------------------------------------------------------------------------
FILE: tests/test_pair_selection.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import bot
     2: 
     3: 
     4: def test_get_trade_pairs():
     5:     class Client:
     6:         def get_ticker(self, symbol=None):
     7:             return {
     8:                 "success": True,
     9:                 "data": [
    10:                     {"symbol": "BTC_USDT"},
    11:                     {"symbol": "ETH_USDT"},
    12:                 ],
    13:             }
    14: 
    15:     pairs = bot.get_trade_pairs(Client())
    16:     assert [p["symbol"] for p in pairs] == ["BTC_USDT", "ETH_USDT"]
    17: 
    18: 
    19: def test_select_top_pairs():
    20:     class Client:
    21:         def get_ticker(self, symbol=None):
    22:             return {
    23:                 "success": True,
    24:                 "data": [
    25:                     {"symbol": "A", "volume": "1"},
    26:                     {"symbol": "B", "volume": "3"},
    27:                     {"symbol": "C", "volume": "2"},
    28:                 ],
    29:             }
    30: 
    31:     top = bot.select_top_pairs(Client(), top_n=2)
    32:     assert [p["symbol"] for p in top] == ["B", "C"]
    33: 
    34: 
    35: def test_select_top_pairs_default_count():
    36:     class Client:
    37:         def get_ticker(self, symbol=None):
    38:             data = []
    39:             for i in range(100):
    40:                 data.append({"symbol": str(i), "volume": str(i)})
    41:             return {"success": True, "data": data}
    42: 
    43:     top = bot.select_top_pairs(Client())
    44:     assert len(top) == 40
    45: 
    46: 
    47: def test_filter_trade_pairs():
    48:     class Client:
    49:         def get_ticker(self, symbol=None):
    50:             return {
    51:                 "success": True,
    52:                 "data": [
    53:                     {
    54:                         "symbol": "AAA",
    55:                         "volume": "6000000",
    56:                         "bidPrice": "100",
    57:                         "askPrice": "100.03",
    58:                     },  # spread ~3 bps
    59:                     {
    60:                         "symbol": "BBB",
    61:                         "volume": "10000000",
    62:                         "bidPrice": "50",
    63:                         "askPrice": "50.1",
    64:                     },  # spread ~200 bps
    65:                     {
    66:                         "symbol": "CCC",
    67:                         "volume": "7000000",
    68:                         "bidPrice": "10",
    69:                         "askPrice": "10.01",
    70:                     },  # spread ~100 bps
    71:                     {
    72:                         "symbol": "DDD",
    73:                         "volume": "4000000",
    74:                         "bidPrice": "20",
    75:                         "askPrice": "20.01",
    76:                     },  # volume trop faible
    77:                 ],
    78:             }
    79: 
    80:     pairs = bot.filter_trade_pairs(
    81:         Client(),
    82:         volume_min=5_000_000,
    83:         max_spread_bps=5,
    84:     )
    85:     assert [p["symbol"] for p in pairs] == ["AAA"]
    86: 
    87: 
    88: def test_find_trade_positions(monkeypatch):
    89:     class Client:
    90:         def __init__(self):
    91:             self.data = {
    92:                 "AAA": {"data": {"close": [1, 2, 3]}},
    93:                 "BBB": {"data": {"close": [3, 2, 1]}},
    94:             }
    95: 
    96:         def get_kline(self, symbol, interval="1m"):
    97:             return self.data[symbol]
    98: 
    99:     pairs = [
   100:         {"symbol": "AAA", "lastPrice": "1"},
   101:         {"symbol": "BBB", "lastPrice": "1"},
   102:     ]
   103: 
   104:     monkeypatch.setattr(bot, "ema", lambda series, window: series)
   105: 
   106:     def fake_cross(last_fast, last_slow, prev_fast, prev_slow):
   107:         if last_fast > prev_fast:
   108:             return 1
   109:         if last_fast < prev_fast:
   110:             return -1
   111:         return 0
   112: 
   113:     monkeypatch.setattr(bot, "cross", fake_cross)
   114: 
   115:     signals = bot.find_trade_positions(Client(), pairs, ema_fast_n=1, ema_slow_n=1)
   116:     assert signals == [
   117:         {"symbol": "AAA", "signal": "long", "price": 1.0},
   118:         {"symbol": "BBB", "signal": "short", "price": 1.0},
   119:     ]

--------------------------------------------------------------------------------
FILE: tests/test_pairs.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import bot
     2: 
     3: 
     4: def test_send_selected_pairs(monkeypatch):
     5:     sent = {}
     6: 
     7:     def fake_notify(event, payload=None):
     8:         sent["event"] = event
     9:         sent["payload"] = payload
    10: 
    11:     monkeypatch.setattr(bot, "notify", fake_notify)
    12:     monkeypatch.setattr(
    13:         bot,
    14:         "filter_trade_pairs",
    15:         lambda client, top_n=120: [
    16:             {"symbol": "WIFUSDT", "volume": 10},
    17:             {"symbol": "WIFUSDT", "volume": 9},
    18:             {"symbol": "BTCUSD", "volume": 8},
    19:             {"symbol": "BTCUSDT", "volume": 7},
    20:             {"symbol": "DOGEUSDT", "volume": 6},
    21:             {"symbol": "ETHUSDC", "volume": 5},
    22:             {"symbol": "ETHUSDT", "volume": 4},
    23:         ],
    24:     )
    25: 
    26:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", ["BTCUSDT", "ETHUSDT"])
    27: 
    28:     payload = bot.send_selected_pairs(object(), top_n=4)
    29: 
    30:     assert sent["event"] == "pair_list"
    31:     assert sent["payload"]["green"] == "BTC"
    32:     assert sent["payload"]["orange"] == "ETH"
    33:     assert "red" not in sent["payload"]
    34:     assert payload == sent["payload"]
    35: 
    36: 
    37: def test_send_selected_pairs_no_whitelist(monkeypatch):
    38:     sent = {}
    39: 
    40:     def fake_notify(event, payload=None):
    41:         sent["payload"] = payload
    42: 
    43:     monkeypatch.setattr(bot, "notify", fake_notify)
    44:     monkeypatch.setattr(
    45:         bot,
    46:         "filter_trade_pairs",
    47:         lambda client, top_n=120: [
    48:             {"symbol": "AAAUSDT", "volume": 10},
    49:             {"symbol": "BBBUSD", "volume": 9},
    50:             {"symbol": "CCCUSDC", "volume": 8},
    51:             {"symbol": "DDDUSDT", "volume": 7},
    52:         ],
    53:     )
    54:     monkeypatch.setitem(bot.CONFIG, "ALLOWED_SYMBOLS", [])
    55: 
    56:     payload = bot.send_selected_pairs(object(), top_n=4)
    57: 
    58:     assert payload == sent["payload"]
    59:     assert payload["green"] == "AAA"
    60:     assert payload["orange"] == "BBB"
    61:     assert payload["red"] == "CCC, DDD"
    62: 
    63: 
    64: def test_filter_trade_pairs_all_pairs(monkeypatch):
    65:     class DummyClient:
    66:         def get_ticker(self):
    67:             return {
    68:                 "data": [
    69:                     {"symbol": "BTCUSDT", "volume": 100, "bidPrice": 1, "askPrice": 1.0001},
    70:                     {"symbol": "ETHUSDT", "volume": 90, "bidPrice": 1, "askPrice": 1.0001},
    71:                 ]
    72:             }
    73: 
    74:     client = DummyClient()
    75:     res = bot.filter_trade_pairs(client, volume_min=0, max_spread_bps=10, top_n=5)
    76:     assert [r["symbol"] for r in res] == ["BTCUSDT", "ETHUSDT"]
    77: 

--------------------------------------------------------------------------------
FILE: tests/test_risk_manager.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: from scalp import RiskManager
     2: 
     3: 
     4: def test_kill_switch_triggered() -> None:
     5:     rm = RiskManager(max_daily_loss_pct=2.0, max_positions=1, risk_pct=0.01)
     6:     rm.record_trade(-1.0)
     7:     rm.record_trade(-1.5)
     8:     assert rm.kill_switch is True
     9: 
    10: 
    11: def test_profit_kill_switch_triggered() -> None:
    12:     rm = RiskManager(
    13:         max_daily_loss_pct=10.0,
    14:         max_daily_profit_pct=3.0,
    15:         max_positions=1,
    16:         risk_pct=0.01,
    17:     )
    18:     rm.record_trade(1.5)
    19:     rm.record_trade(1.6)
    20:     assert rm.kill_switch is True
    21: 
    22: 
    23: def test_pause_and_can_open() -> None:
    24:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    25:     rm.record_trade(-0.5)
    26:     rm.record_trade(-0.6)
    27:     rm.record_trade(-0.7)
    28:     assert rm.pause_duration() == 15 * 60
    29:     rm.record_trade(-0.8)
    30:     rm.record_trade(-0.9)
    31:     assert rm.pause_duration() == 60 * 60
    32:     assert rm.can_open(0) is True
    33:     assert rm.can_open(1) is False
    34: 
    35: 
    36: def test_risk_pct_scaling() -> None:
    37:     rm = RiskManager(max_daily_loss_pct=10.0, max_positions=1, risk_pct=0.01)
    38:     rm.record_trade(1.0)
    39:     rm.record_trade(1.0)
    40:     assert rm.risk_pct > 0.01
    41:     rm.record_trade(-1.0)
    42:     rm.record_trade(-1.0)
    43:     assert rm.risk_pct < 0.01

--------------------------------------------------------------------------------
FILE: tests/test_risk_utils.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import pytest
     2: 
     3: from engine.risk import calc_risk_amount, calc_position_size
     4: 
     5: 
     6: def test_calc_risk_amount_basic():
     7:     assert calc_risk_amount(1000, 0.01) == 10.0
     8: 
     9: 
    10: def test_calc_position_size_basic():
    11:     # risk_amount = 1000 * 0.01 = 10; position size = 10 / 50 = 0.2
    12:     assert calc_position_size(1000, 0.01, 50) == 0.2
    13: 
    14: 
    15: @pytest.mark.parametrize("equity,risk_pct", [
    16:     (0, 0.01),
    17:     (-100, 0.01),
    18:     (1000, 0),
    19:     (1000, -0.1),
    20:     (1000, 1.5),
    21: ])
    22: def test_calc_risk_amount_invalid(equity, risk_pct):
    23:     with pytest.raises(ValueError):
    24:         calc_risk_amount(equity, risk_pct)
    25: 
    26: 
    27: @pytest.mark.parametrize("stop_distance", [0, -1])
    28: def test_calc_position_size_invalid_stop(stop_distance):
    29:     with pytest.raises(ValueError):
    30:         calc_position_size(1000, 0.01, stop_distance)

--------------------------------------------------------------------------------
FILE: tests/test_signal_risk.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import types
     2: import os
     3: import sys
     4: 
     5: sys.path.append(os.path.dirname(os.path.dirname(__file__)))
     6: sys.modules['requests'] = types.ModuleType('requests')
     7: 
     8: from bot import (
     9:     map_score_to_sig_level,
    10:     compute_risk_params,
    11:     prepare_order,
    12:     Signal,
    13:     CONFIG,
    14: )
    15: 
    16: 
    17: class DummyRisk:
    18:     def __init__(self, pct: float) -> None:
    19:         self.risk_pct = pct
    20: 
    21: 
    22: def _contract_detail():
    23:     return {
    24:         "data": [
    25:             {
    26:                 "symbol": "BTC_USDT",
    27:                 "contractSize": 0.001,
    28:                 "volUnit": 1,
    29:                 "minVol": 1,
    30:                 "minTradeUSDT": 5,
    31:             }
    32:         ]
    33:     }
    34: 
    35: 
    36: def test_score_to_level_mapping():
    37:     assert map_score_to_sig_level(10) == 1
    38:     assert map_score_to_sig_level(35) == 2
    39:     assert map_score_to_sig_level(69.9) == 2
    40:     assert map_score_to_sig_level(70) == 3
    41: 
    42: 
    43: def test_risk_tables():
    44:     rp, lev, cap = compute_risk_params(2, 3, 0.01, 20)
    45:     assert rp == 0.01 * 1.25
    46:     assert lev == int(20 * 0.75)
    47:     assert cap == 0.55
    48:     rp2, lev2, cap2 = compute_risk_params(3, 1, 0.01, 20)
    49:     assert rp2 == 0.01 * 1.0
    50:     assert lev2 == int(20 * 0.5)
    51:     assert cap2 == 0.35
    52: 
    53: 
    54: def test_notional_cap():
    55:     rm = DummyRisk(0.05)
    56:     sig = Signal("BTC_USDT", "long", 10000, 9900, 10100, 10200, 1, score=80)
    57:     available = 1000
    58:     params = prepare_order(
    59:         sig,
    60:         _contract_detail(),
    61:         equity_usdt=available,
    62:         available_usdt=available,
    63:         base_leverage=10,
    64:         risk_mgr=rm,
    65:         user_risk_level=2,
    66:     )
    67:     assert params["notional"] <= params["cap_ratio"] * available + 1e-6

--------------------------------------------------------------------------------
FILE: tests/test_slippage.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from engine.trade_utils import marketable_limit_price
     2: 
     3: 
     4: def test_marketable_limit_price_buy_sell():
     5:     price_buy = marketable_limit_price("buy", best_bid=9.9, best_ask=10.0, slippage=0.001)
     6:     assert price_buy == 10.0 * 1.001
     7:     price_sell = marketable_limit_price("sell", best_bid=9.9, best_ask=10.0, slippage=0.001)
     8:     assert price_sell == 9.9 * (1 - 0.001)

--------------------------------------------------------------------------------
FILE: tests/test_strategy_v2.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import pytest
     2: 
     3: from scalp import strategy
     4: from engine.trade_utils import trailing_stop, should_scale_in, timeout_exit
     5: 
     6: 
     7: def make_ohlcv(n=60, start=100, step=1):
     8:     closes = [start + i * step for i in range(n)]
     9:     highs = [c + 1 for c in closes]
    10:     lows = [c - 1 for c in closes]
    11:     vols = [1 for _ in closes]
    12:     return {"open": closes, "high": highs, "low": lows, "close": closes, "volume": vols}
    13: 
    14: 
    15: def test_generate_signal_atr_adaptation(monkeypatch):
    16:     base = make_ohlcv(step=2)
    17:     ohlcv_15 = make_ohlcv(n=15, step=2)
    18:     ohlcv_1h = make_ohlcv(step=2)
    19: 
    20:     # patches for deterministic RSI values
    21:     rsi_vals = iter([60, 41, 39])
    22:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    23:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    24:     # low ATR -> signal disabled
    25:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 0.1)
    26:     sig = strategy.generate_signal(
    27:         "AAA",
    28:         base,
    29:         equity=1_000,
    30:         risk_pct=0.01,
    31:         ohlcv_15m=ohlcv_15,
    32:         ohlcv_1h=ohlcv_1h,
    33:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    34:         tick_ratio_buy=0.6,
    35:     )
    36:     assert sig is None
    37: 
    38:     # high ATR -> size reduced
    39:     rsi_vals = iter([60, 41, 39])
    40:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    41:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 5.0)
    42:     sig = strategy.generate_signal(
    43:         "AAA",
    44:         base,
    45:         equity=1_000,
    46:         risk_pct=0.01,
    47:         ohlcv_15m=ohlcv_15,
    48:         ohlcv_1h=ohlcv_1h,
    49:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
    50:         tick_ratio_buy=0.6,
    51:     )
    52:     assert sig and sig.side == "long"
    53:     assert sig.qty == 50
    54: 
    55: 
    56: def test_generate_signal_short_with_filters(monkeypatch):
    57:     base = make_ohlcv(start=200, step=-2)
    58:     ohlcv_15 = make_ohlcv(n=15, start=200, step=-2)
    59:     ohlcv_1h = make_ohlcv(start=200, step=-2)
    60: 
    61:     rsi_vals = iter([40, 59, 61])
    62:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
    63:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
    64:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
    65: 
    66:     sig = strategy.generate_signal(
    67:         "AAA",
    68:         base,
    69:         equity=1_000,
    70:         risk_pct=0.01,
    71:         ohlcv_15m=ohlcv_15,
    72:         ohlcv_1h=ohlcv_1h,
    73:         order_book={"bid_vol_aggreg": 80, "ask_vol_aggreg": 120},
    74:         tick_ratio_buy=0.4,
    75:     )
    76:     assert sig and sig.side == "short"
    77:     assert sig.qty == 100
    78: 
    79: 
    80: def test_trailing_and_timeout():
    81:     # trailing stop
    82:     sl = trailing_stop("long", current_price=110, atr=10, sl=90)
    83:     assert sl == pytest.approx(102.5)
    84:     # scaling
    85:     assert should_scale_in(100, 105, 100, 10, "long") is True
    86:     assert should_scale_in(100, 95, 100, 10, "short") is True
    87:     # timeout
    88:     # before the progress window no exit should be triggered
    89:     assert not timeout_exit(0, 10 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    90:     # after ``progress_min`` minutes without favourable movement we close
    91:     assert timeout_exit(0, 20 * 60, 100, 99, "long", progress_min=15, timeout_min=30)
    92: 
    93: 
    94: def test_generate_signal_macd_filter(monkeypatch):
    95:     base = make_ohlcv(step=2)
    96:     ohlcv_15 = make_ohlcv(n=15, step=2)
    97:     ohlcv_1h = make_ohlcv(step=2)
    98: 
    99:     rsi_vals = iter([60, 41, 39])
   100:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   101:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   102:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   103:     monkeypatch.setattr(strategy, "calc_macd", lambda *args, **kwargs: (-1.0, 0.0, -1.0))
   104: 
   105:     sig = strategy.generate_signal(
   106:         "AAA",
   107:         base,
   108:         equity=1_000,
   109:         risk_pct=0.01,
   110:         ohlcv_15m=ohlcv_15,
   111:         ohlcv_1h=ohlcv_1h,
   112:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   113:         tick_ratio_buy=0.6,
   114:     )
   115:     assert sig is None
   116: 
   117: 
   118: 
   119: def test_generate_signal_trend_ema_filter(monkeypatch):
   120:     base = make_ohlcv(step=2)
   121:     ohlcv_15 = make_ohlcv(n=15, step=2)
   122:     ohlcv_1h = make_ohlcv(step=2)
   123: 
   124:     rsi_vals = iter([60, 41, 39])
   125:     monkeypatch.setattr(strategy, "calc_rsi", lambda *args, **kwargs: next(rsi_vals))
   126:     monkeypatch.setattr(strategy, "calc_position_size", lambda equity, risk, dist: 100)
   127:     monkeypatch.setattr(strategy, "calc_atr", lambda *args, **kwargs: 1.0)
   128: 
   129:     orig_ema = strategy.ema
   130: 
   131:     def fake_ema(series, window):
   132:         if window == 200:
   133:             return [x + 1000 for x in orig_ema(series, window)]
   134:         return orig_ema(series, window)
   135: 
   136:     monkeypatch.setattr(strategy, "ema", fake_ema)
   137: 
   138:     sig = strategy.generate_signal(
   139:         "AAA",
   140:         base,
   141:         equity=1_000,
   142:         risk_pct=0.01,
   143:         ohlcv_15m=ohlcv_15,
   144:         ohlcv_1h=ohlcv_1h,
   145:         order_book={"bid_vol_aggreg": 120, "ask_vol_aggreg": 80},
   146:         tick_ratio_buy=0.6,
   147:         trend_ema_period=200,
   148:     )
   149:     assert sig is None
   150:     

--------------------------------------------------------------------------------
FILE: tests/test_telegram_bot.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from engine.telegram_bot import TelegramBot
     2: 
     3: 
     4: class DummyClient:
     5: 
     6:     def __init__(self):
     7:         self.closed = []
     8:         self.closed_all = False
     9: 
    10: 
    11:     def get_assets(self):
    12:         return {"data": [{"currency": "USDT", "equity": 123.45}]}
    13: 
    14:     def get_positions(self):
    15:         return {
    16:             "data": [
    17:                 {
    18:                     "symbol": "BTC_USDT",
    19:                     "side": "long",
    20:                     "vol": 2,
    21:                     "pnl_usd": 1.0,
    22:                     "pnl_pct": 5.0,
    23:                 }
    24:             ]
    25:         }
    26: 
    27:     def close_position(self, sym):
    28:         self.closed.append(sym)
    29: 
    30:     def close_all_positions(self):
    31:         self.closed_all = True
    32: 
    33: 
    34: 
    35: class DummyRiskMgr:
    36: 
    37:     def __init__(self):
    38:         self.reset_called = False
    39:         self.max_positions = 1
    40:         self.risk_pct = 0.01
    41: 
    42:     def reset_day(self):
    43:         self.reset_called = True
    44: 
    45: 
    46: class DummyRequests:
    47:     def __init__(self):
    48:         self.posts = []
    49: 
    50:     def post(self, url, json=None, timeout=5):
    51:         self.posts.append((url, json))
    52: 
    53:     def get(self, url, params=None, timeout=5):  # pragma: no cover - unused
    54:         return type("R", (), {"json": lambda self: {}, "raise_for_status": lambda self: None})()
    55: 
    56: 
    57: def make_bot(config=None, requests_module=None):
    58:     cfg = {"RISK_LEVEL": 2, "MAX_POSITIONS": 1}
    59:     if config:
    60:         cfg.update(config)
    61:     if requests_module is None:
    62:         requests_module = DummyRequests()
    63:     return TelegramBot("t", "1", DummyClient(), cfg, DummyRiskMgr(), requests_module=requests_module)
    64: 
    65: 
    66: def test_handle_balance():
    67:     bot = make_bot()
    68: 
    69:     resp, kb = bot.handle_callback("balance", 0.0)
    70:     assert "123.45" in resp
    71:     assert kb == bot.main_keyboard
    72: 
    73: 
    74: 
    75: def test_handle_positions():
    76:     bot = make_bot()
    77:     resp, _ = bot.handle_callback("positions", 0.0)
    78:     assert "BTC" in resp
    79:     assert "PnL" in resp
    80: 
    81: 
    82: def test_handle_positions_zero_pnl():
    83:     bot = make_bot()
    84: 
    85:     def zero_positions():
    86:         return {
    87:             "data": [
    88:                 {
    89:                     "symbol": "BTC_USDT",
    90:                     "side": "long",
    91:                     "vol": 1,
    92:                     "pnl_usd": 0.0,
    93:                     "pnl_pct": 0.0,
    94:                 }
    95:             ]
    96:         }
    97: 
    98:     bot.client.get_positions = zero_positions
    99:     resp, _ = bot.handle_callback("positions", 0.0)
   100:     assert "PnL: 0.00 USDT" in resp
   101: 
   102: 
   103: 
   104: def test_handle_pnl():
   105:     bot = make_bot()
   106:     resp, _ = bot.handle_callback("pnl", 5.0)
   107: 
   108:     assert "5.00" in resp
   109: 
   110: 
   111: def test_handle_risk_change():
   112:     bot = make_bot()
   113: 
   114:     resp, kb = bot.handle_callback("risk_red", 0.0)
   115:     assert "3" in resp
   116:     assert bot.config["RISK_LEVEL"] == 3
   117:     assert kb == bot.main_keyboard
   118: 
   119: 
   120: def test_risk_menu():
   121:     bot = make_bot()
   122:     resp, kb = bot.handle_callback("risk", 0.0)
   123:     assert "risque" in resp.lower()
   124:     assert kb == bot.risk_keyboard
   125: 
   126: 
   127: 
   128: def test_stop_menu_and_actions():
   129:     bot = make_bot()
   130:     resp, kb = bot.handle_callback("stop", 0.0)
   131:     assert any(
   132:         btn["callback_data"] == "stop_BTC_USDT" for row in kb for btn in row
   133:     )
   134:     assert any(btn["callback_data"] == "stop_all" for row in kb for btn in row)
   135:     resp, _ = bot.handle_callback("stop_BTC_USDT", 0.0)
   136:     assert "fermée" in resp.lower()
   137:     assert bot.client.closed == ["BTC_USDT"]
   138:     resp, _ = bot.handle_callback("stop_all", 0.0)
   139:     assert bot.client.closed_all is True
   140: 
   141: 
   142: def test_handle_unknown():
   143:     bot = make_bot()
   144:     resp, kb = bot.handle_callback("foobar", 0.0)
   145:     assert resp is None
   146:     assert kb is None
   147: 
   148: 
   149: def test_reset_all():
   150:     bot = make_bot()
   151:     resp, kb = bot.handle_callback("reset_all", 0.0)
   152:     assert "réinitialisés" in resp.lower()
   153:     assert bot.risk_mgr.reset_called is True
   154:     assert bot.client.closed_all is True
   155:     assert kb == bot.settings_keyboard
   156: 
   157: 
   158: def test_shutdown_bot():
   159:     bot = make_bot()
   160:     resp, kb = bot.handle_callback("shutdown", 0.0)
   161:     assert "arrêt" in resp.lower()
   162:     assert bot.stop_requested is True
   163:     assert kb == bot.main_keyboard
   164: 
   165: 
   166: def test_start_sends_menu():
   167:     req = DummyRequests()
   168:     make_bot(requests_module=req)
   169:     assert req.posts
   170:     text = req.posts[0][1]["text"]
   171:     assert "Solde" in text and "PnL session" in text
   172:     assert "Positions max" in text
   173:     assert "Risque actuel" in text
   174: 
   175: 
   176: def test_settings_menu_and_reset_risk():
   177:     bot = make_bot()
   178:     resp, kb = bot.handle_callback("settings", 0.0)
   179:     assert "réglages" in resp.lower()
   180:     assert kb == bot.settings_keyboard
   181:     resp, kb = bot.handle_callback("reset_risk", 0.0)
   182:     assert "risque" in resp.lower()
   183:     assert bot.risk_mgr.reset_called is True
   184:     assert kb == bot.settings_keyboard
   185: 
   186: 
   187: def test_update_button(monkeypatch):
   188:     bot = make_bot()
   189:     called = {}
   190: 
   191:     def fake_update():
   192:         called["called"] = True
   193: 
   194:     bot.update_pairs = fake_update
   195:     resp, kb = bot.handle_callback("update", 0.0)
   196:     assert called["called"] is True
   197:     assert "mise à jour" in resp.lower()
   198:     assert kb == bot.main_keyboard
   199: 
   200: 
   201: def test_maxpos_menu_and_change():
   202:     bot = make_bot()
   203:     resp, kb = bot.handle_callback("maxpos", 0.0)
   204:     assert "nombre" in resp.lower()
   205:     assert kb == bot.maxpos_keyboard
   206:     resp, kb = bot.handle_callback("maxpos_3", 0.0)
   207:     assert "3" in resp
   208:     assert bot.config["MAX_POSITIONS"] == 3
   209:     assert bot.risk_mgr.max_positions == 3
   210:     assert kb == bot.main_keyboard
   211: 
   212: 
   213: def test_stop_no_positions():
   214:     bot = make_bot()
   215:     bot.client.get_positions = lambda: {"data": []}
   216:     resp, kb = bot.handle_callback("stop", 0.0)
   217:     assert "aucune crypto" in resp.lower()
   218:     assert kb == bot.settings_keyboard
   219: 

--------------------------------------------------------------------------------
FILE: tests/test_utils.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import pytest
     2: from bot import ema, cross, compute_position_size, CONFIG
     3: from engine.trade_utils import extract_available_balance
     4: 
     5: 
     6: def test_ema_basic():
     7:     data = [1, 2, 3, 4, 5]
     8:     result = ema(data, 3)
     9:     assert result == pytest.approx([1, 1.5, 2.25, 3.125, 4.0625])
    10: 
    11: 
    12: def test_cross_up_down_none():
    13:     assert cross(3, 2, 1, 2) == 1  # up cross
    14:     assert cross(0.5, 1, 2, 1) == -1  # down cross
    15:     assert cross(2, 2, 2, 2) == 0  # no cross
    16: 
    17: 
    18: def test_compute_position_size():
    19:     detail = {
    20:         "data": [
    21:             {
    22:                 "symbol": CONFIG["SYMBOL"],
    23:                 "contractSize": 0.001,
    24:                 "volUnit": 1,
    25:                 "minVol": 1,
    26:             }
    27:         ]
    28:     }
    29:     vol = compute_position_size(detail, equity_usdt=100.0, price=20000.0,
    30:                                 risk_pct=0.01, leverage=5)
    31:     assert vol == 1
    32: 
    33: 
    34: def test_compute_position_size_missing_symbol():
    35:     with pytest.raises(ValueError):
    36:         compute_position_size({"data": []}, 100.0, 1.0, 0.01, 5)
    37: 
    38: 
    39: def test_extract_available_balance_fallback():
    40:     assets = {
    41:         "data": [
    42:             {
    43:                 "currency": "USDT",
    44:                 "available": 0,
    45:                 "cashBalance": "150.5",
    46:                 "equity": "200",
    47:             }
    48:         ]
    49:     }
    50:     assert extract_available_balance(assets) == 150.5
    51: 
    52: 
    53: def test_extract_available_balance_equity_only():
    54:     assets = {
    55:         "data": [
    56:             {
    57:                 "currency": "USDT",
    58:                 "equity": "42",
    59:             }
    60:         ]
    61:     }
    62:     assert extract_available_balance(assets) == 42.0
    63: 
    64: 
    65: def test_extract_available_balance_zero_available_returns_zero():
    66:     assets = {
    67:         "data": [
    68:             {
    69:                 "currency": "USDT",
    70:                 "available": 0,
    71:                 "availableBalance": 0,
    72:                 "equity": "42",
    73:             }
    74:         ]
    75:     }
    76:     assert extract_available_balance(assets) == 0.0

--------------------------------------------------------------------------------
FILE: tests/test_version.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: import pytest
     2: from scalp import version
     3: 
     4: 
     5: def test_get_version(monkeypatch, tmp_path):
     6:     vfile = tmp_path / "VERSION"
     7:     vfile.write_text("1.2.3")
     8:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
     9:     assert version.get_version() == "1.2.3"
    10: 
    11: 
    12: def test_bump_version(monkeypatch, tmp_path):
    13:     vfile = tmp_path / "VERSION"
    14: 
    15:     vfile.write_text("0.1.2\n")
    16:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    17:     assert version.bump_version("minor") == "0.2.0"
    18:     assert vfile.read_text().strip() == "0.2.0"
    19: 
    20: 
    21: def test_bump_version_invalid_part(monkeypatch, tmp_path):
    22:     vfile = tmp_path / "VERSION"
    23:     vfile.write_text("0.1.0\n")
    24:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    25:     with pytest.raises(ValueError):
    26:         version.bump_version("foo")
    27: 
    28: 
    29: def test_bump_from_message(monkeypatch, tmp_path):
    30:     vfile = tmp_path / "VERSION"
    31:     vfile.write_text("1.0.0\n")
    32:     monkeypatch.setattr(version, "_VERSION_FILE", vfile)
    33:     assert version.bump_version_from_message("feat: add x") == "1.1.0"
    34:     assert version.bump_version_from_message("fix: bug") == "1.1.1"
    35:     assert version.bump_version_from_message("feat!: major change") == "2.0.0"
    36: 

--------------------------------------------------------------------------------
FILE: tests/test_walk_forward.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: from engine.backtest import walk_forward_windows
     2: 
     3: 
     4: def test_walk_forward_windows():
     5:     data = list(range(10))
     6:     windows = list(walk_forward_windows(data, train=4, test=2))
     7:     assert windows == [
     8:         ([0, 1, 2, 3], [4, 5]),
     9:         ([2, 3, 4, 5], [6, 7]),
    10:         ([4, 5, 6, 7], [8, 9]),
    11:     ]

--------------------------------------------------------------------------------
FILE: tests/test_ws.py  (last modified: 2025-08-24 12:16:03)
--------------------------------------------------------------------------------
     1: import asyncio
     2: 
     3: from engine.ws import WebsocketManager
     4: 
     5: 
     6: def test_websocket_manager_stop():
     7:     async def connect():
     8:         return None
     9: 
    10:     async def subscribe():
    11:         return None
    12: 
    13:     ws = WebsocketManager(connect, subscribe, heartbeat_interval=0.01)
    14: 
    15:     async def run_and_stop():
    16:         await ws.run()
    17:         assert ws._heartbeat_task is not None
    18:         await ws.stop()
    19:         assert ws._heartbeat_task is None
    20: 
    21:     asyncio.run(run_and_stop())

--------------------------------------------------------------------------------
FILE: tg_diag.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # tg_diag.py
     2: import asyncio, os, aiohttp
     3: 
     4: TOKEN = os.getenv("TELEGRAM_TOKEN", "")
     5: CHAT  = os.getenv("TELEGRAM_CHAT_ID", "")
     6: 
     7: async def main():
     8:     if not TOKEN or not CHAT:
     9:         print("❌ Manque TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID dans l'env.")
    10:         return
    11:     url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    12:     payload = {"chat_id": CHAT, "text": "🔎 Test Telegram OK ?"}
    13:     try:
    14:         async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15)) as s:
    15:             async with s.post(url, json=payload) as r:
    16:                 body = await r.text()
    17:                 print("HTTP:", r.status)
    18:                 print("Body:", body[:500])
    19:     except Exception as e:
    20:         print("❌ Exception:", repr(e))
    21: 
    22: if __name__ == "__main__":
    23:     asyncio.run(main())

--------------------------------------------------------------------------------
FILE: tools/dump-repo.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: """
     3: tools/dump-repo.py
     4: 
     5: Génère un dump complet du repo notebooks/scalp :
     6: - timestamp dans le nom
     7: - arborescence des fichiers
     8: - date de dernière modification de chaque fichier
     9: - contenu intégral des fichiers texte avec numéro de ligne
    10: - exclusion des fichiers binaires et dossiers inutiles (git, cache, trash…)
    11: 
    12: Usage :
    13:     python tools/dump-repo.py
    14: """
    15: 
    16: from __future__ import annotations
    17: 
    18: import datetime as dt
    19: import os
    20: import sys
    21: from pathlib import Path
    22: 
    23: # Racine du repo = notebooks/scalp/
    24: REPO_ROOT = Path(__file__).resolve().parents[1]
    25: DUMP_DIR = REPO_ROOT / "dumps"
    26: DUMP_DIR.mkdir(parents=True, exist_ok=True)
    27: 
    28: TS = dt.datetime.now().strftime("%Y%m%d-%H%M%S")
    29: OUT_PATH = DUMP_DIR / f"DUMP_{TS}.txt"
    30: 
    31: # Extensions/fichiers à ignorer (binaires ou inutiles)
    32: IGNORE_EXT = {
    33:     ".png", ".jpg", ".jpeg", ".gif", ".pdf",
    34:     ".pkl", ".db", ".sqlite", ".zip", ".tar", ".gz",
    35:     ".pyc", ".pyo",
    36: }
    37: IGNORE_DIRS = {".git", "__pycache__", ".ipynb_checkpoints"}
    38: IGNORE_PREFIX = {"TRASH_"}
    39: 
    40: def is_text_file(path: Path) -> bool:
    41:     if path.suffix.lower() in IGNORE_EXT:
    42:         return False
    43:     try:
    44:         with open(path, "rb") as f:
    45:             chunk = f.read(1024)
    46:             if b"\x00" in chunk:
    47:                 return False
    48:         return True
    49:     except Exception:
    50:         return False
    51: 
    52: def write_header(f, title: str) -> None:
    53:     f.write("\n" + "=" * 80 + "\n")
    54:     f.write(f"{title}\n")
    55:     f.write("=" * 80 + "\n")
    56: 
    57: def dump_tree(root: Path, f) -> None:
    58:     write_header(f, "ARBORESCENCE")
    59:     for p in sorted(root.rglob("*")):
    60:         rel = p.relative_to(root)
    61:         if any(part in IGNORE_DIRS for part in rel.parts):
    62:             continue
    63:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX):
    64:             continue
    65:         if p.is_file():
    66:             mtime = dt.datetime.fromtimestamp(p.stat().st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    67:             f.write(f"{rel}  (last modified: {mtime})\n")
    68:         else:
    69:             f.write(str(rel) + "/\n")
    70: 
    71: def dump_files(root: Path, f) -> None:
    72:     write_header(f, "FICHIERS COMPLETS")
    73:     for p in sorted(root.rglob("*")):
    74:         rel = p.relative_to(root)
    75:         if p.is_dir():
    76:             continue
    77:         if any(part in IGNORE_DIRS for part in rel.parts):
    78:             continue
    79:         if any(str(rel).startswith(pref) for pref in IGNORE_PREFIX):
    80:             continue
    81:         if not is_text_file(p):
    82:             continue
    83:         try:
    84:             content = p.read_text(encoding="utf-8", errors="replace").splitlines()
    85:         except Exception as e:
    86:             f.write(f"\n[!!] Impossible de lire {rel}: {e}\n")
    87:             continue
    88:         mtime = dt.datetime.fromtimestamp(p.stat().st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    89:         f.write("\n" + "-" * 80 + "\n")
    90:         f.write(f"FILE: {rel}  (last modified: {mtime})\n")
    91:         f.write("-" * 80 + "\n")
    92:         for i, line in enumerate(content, 1):
    93:             f.write(f"{i:6d}: {line}\n")
    94: 
    95: def main() -> int:
    96:     with open(OUT_PATH, "w", encoding="utf-8") as f:
    97:         f.write(f"# DUMP {TS}\nRepo: {REPO_ROOT}\n")
    98:         dump_tree(REPO_ROOT, f)
    99:         dump_files(REPO_ROOT, f)
   100:     print(f"[✓] Dump écrit: {OUT_PATH}")
   101:     return 0
   102: 
   103: if __name__ == "__main__":
   104:     sys.exit(main())

--------------------------------------------------------------------------------
FILE: tools/migrate-to-engine.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # ops/migrate_to_engine.py
     2: from __future__ import annotations
     3: import re, shutil
     4: from pathlib import Path
     5: 
     6: ROOT = Path(__file__).resolve().parents[1]
     7: ENGINE = ROOT / "engine"
     8: ENGINE.mkdir(exist_ok=True)
     9: 
    10: # 1) Déplacer anciens packages s'ils existent
    11: CANDIDATE_PKGS = ["scalper", "scalp"]  # anciens noms possibles de package interne
    12: for name in CANDIDATE_PKGS:
    13:     src = ROOT / name
    14:     if src.exists() and src.is_dir():
    15:         dst = ENGINE
    16:         # on déplace le contenu interne dans engine/
    17:         for p in src.iterdir():
    18:             dest = dst / p.name
    19:             if dest.exists():
    20:                 continue
    21:             shutil.move(str(p), str(dest))
    22:         # on laisse le répertoire racine (vide) à supprimer manuellement si besoin
    23: 
    24: # 2) Mettre à jour les imports dans tout le repo (hors TRASH et .git)
    25: PATTERNS = [
    26:     (re.compile(r"\bscalper\."), "engine."),
    27:     (re.compile(r"\bscalp\."), "engine."),   # ancien package interne homonyme du repo
    28: ]
    29: def fix_file(path: Path) -> None:
    30:     try:
    31:         txt = path.read_text(encoding="utf-8")
    32:     except Exception:
    33:         return
    34:     orig = txt
    35:     for rx, repl in PATTERNS:
    36:         txt = rx.sub(repl, txt)
    37:     if txt != orig:
    38:         path.write_text(txt, encoding="utf-8")
    39: 
    40: for p in ROOT.rglob("*.py"):
    41:     rel = p.relative_to(ROOT)
    42:     if any(part.startswith("TRASH_") for part in rel.parts):
    43:         continue
    44:     if rel.parts and rel.parts[0] in (".git",):
    45:         continue
    46:     fix_file(p)
    47: 
    48: print("[✓] Migration terminée. Vérifie les imports et supprime l’ancien dossier vide si présent.")

--------------------------------------------------------------------------------
FILE: tools/trashify.py  (last modified: 2025-08-24 12:14:38)
--------------------------------------------------------------------------------
     1: # tools/trashify.py
     2: # Déplacement sécurisé des fichiers/dossiers "candidats" vers TRASH_YYYYMMDD-HHMMSS/
     3: # Usage:
     4: #   python tools/trashify.py            # dry-run (affiche seulement)
     5: #   python tools/trashify.py --apply    # déplace réellement
     6: # Options:
     7: #   --trash-dir NAME   # nom personnalisé du dossier trash (sinon timestamp)
     8: #   --no-git           # force l'utilisation de shutil.move au lieu de `git mv`
     9: #
    10: # Notes:
    11: # - Détecte automatiquement un repo Git et utilise `git mv` si possible (meilleure traçabilité).
    12: # - Écrit un manifeste: TRASH_.../TRASH_MANIFEST.txt avec la liste des éléments déplacés.
    13: # - La liste des "candidats" ci-dessous est issue du dump fourni le 2025-08-24 (répertoire racine: Scalp/).  #  [oai_citation:1‡Vierge 19.txt](file-service://file-9QiWVhpqthb1XibRXMXmiu)
    14: 
    15: from __future__ import annotations
    16: 
    17: import argparse
    18: import datetime as dt
    19: import os
    20: import shutil
    21: import subprocess
    22: from pathlib import Path
    23: from typing import Iterable, List, Tuple
    24: 
    25: # --------------------------------------------------------------------------------------
    26: # Candidats à déplacer (conservateur). Ajuste cette liste si besoin avant --apply.
    27: # --------------------------------------------------------------------------------------
    28: CANDIDATES: List[str] = [
    29:     # 1) Ancienne corbeille entière (archives obsolètes) — doublons du code actuel
    30:     "TRASH_20250823-124533",
    31: 
    32:     # 2) Duplication manifeste: indicateurs déjà présents sous scalper/core/indicators.py
    33:     "data/indicators.py",
    34: 
    35:     # 3) Typo de dossier de stratégie (probablement un essai non concluant)
    36:     "scalper/strategy/startegies",  # <- oui "startegies" (typo)
    37: 
    38:     # 4) Scripts ponctuels/démo non utilisés par bot.py
    39:     # (laisse commentés par défaut; décommente si tu valides)
    40:     # "tg_diag.py",
    41:     # "TRASH_20250823-124533/quick_order.py",
    42:     # "TRASH_20250823-124533/dashboard.py",
    43:     # "TRASH_20250823-124533/notebooks",
    44: 
    45:     # 5) Anciennes configs/legacy dans TRASH (redondantes avec scalper/config/* actuels)
    46:     # (déjà couvert par la ligne 1 déplaçant le dossier complet)
    47: ]
    48: 
    49: # Racine du repo = dossier parent de CE fichier, puis deux niveaux si placé dans tools/
    50: HERE = Path(__file__).resolve()
    51: REPO_ROOT = HERE.parent.parent if HERE.parent.name == "tools" else HERE.parent
    52: assert (REPO_ROOT / ".").exists(), f"Repo root introuvable: {REPO_ROOT}"
    53: 
    54: 
    55: def _is_git_repo(root: Path) -> bool:
    56:     return (root / ".git").exists()
    57: 
    58: 
    59: def _git_mv(src: Path, dst: Path) -> Tuple[bool, str]:
    60:     try:
    61:         subprocess.run(["git", "mv", str(src), str(dst)], cwd=REPO_ROOT, check=True, capture_output=True)
    62:         return True, "git mv"
    63:     except Exception as e:
    64:         return False, f"git mv failed: {e}"
    65: 
    66: 
    67: def _shutil_mv(src: Path, dst: Path) -> Tuple[bool, str]:
    68:     try:
    69:         dst.parent.mkdir(parents=True, exist_ok=True)
    70:         shutil.move(str(src), str(dst))
    71:         return True, "shutil.move"
    72:     except Exception as e:
    73:         return False, f"move failed: {e}"
    74: 
    75: 
    76: def _timestamp() -> str:
    77:     return dt.datetime.now().strftime("%Y%m%d-%H%M%S")
    78: 
    79: 
    80: def resolve_existing(paths: Iterable[str]) -> List[Path]:
    81:     out: List[Path] = []
    82:     for p in paths:
    83:         rp = (REPO_ROOT / p).resolve()
    84:         if rp.exists():
    85:             out.append(rp)
    86:     return out
    87: 
    88: 
    89: def write_manifest(trash_dir: Path, moved: List[Path], skipped: List[Tuple[Path, str]]) -> None:
    90:     manifest = trash_dir / "TRASH_MANIFEST.txt"
    91:     lines: List[str] = []
    92:     lines.append(f"Repo root: {REPO_ROOT}")
    93:     lines.append(f"Trash dir: {trash_dir}")
    94:     lines.append(f"Moved count: {len(moved)}")
    95:     lines.append("Moved items:")
    96:     for p in moved:
    97:         rel = p.relative_to(trash_dir)
    98:         lines.append(f"  - {rel}")
    99:     if skipped:
   100:         lines.append("")
   101:         lines.append("Skipped/not moved (reason):")
   102:         for p, reason in skipped:
   103:             lines.append(f"  - {p.relative_to(REPO_ROOT)} :: {reason}")
   104:     manifest.parent.mkdir(parents=True, exist_ok=True)
   105:     manifest.write_text("\n".join(lines) + "\n", encoding="utf-8")
   106: 
   107: 
   108: def main() -> int:
   109:     ap = argparse.ArgumentParser(description="Déplacer des fichiers/dossiers vers un répertoire TRASH_*")
   110:     ap.add_argument("--apply", action="store_true", help="Exécuter réellement les déplacements (sinon dry-run)")
   111:     ap.add_argument("--trash-dir", default="", help="Nom personnalisé du répertoire trash (par défaut TRASH_<timestamp>)")
   112:     ap.add_argument("--no-git", action="store_true", help="Ne pas utiliser git mv, forcer shutil.move")
   113:     args = ap.parse_args()
   114: 
   115:     # Résolution des candidats présents
   116:     existing = resolve_existing(CANDIDATES)
   117:     missing = sorted(set(CANDIDATES) - {str(p.relative_to(REPO_ROOT)) for p in existing})
   118:     if missing:
   119:         print("[i] Éléments non trouvés (ignorés) :")
   120:         for m in missing:
   121:             print(f"    - {m}")
   122: 
   123:     if not existing:
   124:         print("[✓] Rien à déplacer: aucun candidat présent.")
   125:         return 0
   126: 
   127:     # Dossier TRASH cible
   128:     trash_name = args.trash_dir.strip() or f"TRASH_{_timestamp()}"
   129:     trash_dir = (REPO_ROOT / trash_name).resolve()
   130: 
   131:     print(f"[i] Repo: {REPO_ROOT}")
   132:     print(f"[i] Trash: {trash_dir}")
   133:     print("[i] Candidats résolus:")
   134:     for p in existing:
   135:         print(f"    - {p.relative_to(REPO_ROOT)}")
   136: 
   137:     if not args.apply:
   138:         print("\n[DRY-RUN] Ajoute --apply pour exécuter réellement les déplacements.")
   139:         return 0
   140: 
   141:     # Exécution
   142:     moved: List[Path] = []
   143:     skipped: List[Tuple[Path, str]] = []
   144:     use_git = _is_git_repo(REPO_ROOT) and not args.no_git
   145: 
   146:     for src in existing:
   147:         rel = src.relative_to(REPO_ROOT)
   148:         dst = trash_dir / rel  # conserve la structure relative
   149:         dst.parent.mkdir(parents=True, exist_ok=True)
   150: 
   151:         if use_git:
   152:             ok, how = _git_mv(src, dst)
   153:         else:
   154:             ok, how = _shutil_mv(src, dst)
   155: 
   156:         if ok:
   157:             print(f"[→] {rel}  ->  {dst.relative_to(REPO_ROOT)}  ({how})")
   158:             moved.append(dst)
   159:         else:
   160:             print(f"[!] SKIP {rel} ({how})")
   161:             skipped.append((src, how))
   162: 
   163:     # Manifeste
   164:     write_manifest(trash_dir, moved, skipped)
   165:     print(f"[✓] Manifeste écrit: {trash_dir / 'TRASH_MANIFEST.txt'}")
   166:     print("[✓] Terminé.")
   167:     return 0
   168: 
   169: 
   170: if __name__ == "__main__":
   171:     raise SystemExit(main())
